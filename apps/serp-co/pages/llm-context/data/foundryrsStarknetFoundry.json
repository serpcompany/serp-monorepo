[
  {
    "owner": "foundry-rs",
    "repo": "starknet-foundry",
    "content": "TITLE: Executing Starknet Tests using snforge CLI (Shell)\nDESCRIPTION: Shows the command-line instruction to execute the Starknet Foundry test suite defined in the project.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ snforge test\n```\n\n----------------------------------------\n\nTITLE: Running Starknet Foundry tests\nDESCRIPTION: Command to run tests in a Starknet Foundry project using the 'snforge test' command. This executes all tests in the project and displays the results.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test\n```\n\n----------------------------------------\n\nTITLE: Cheating the Contract Constructor Caller Address - Cairo\nDESCRIPTION: This Cairo code presents the setup needed to pre-set the caller address for a contract's constructor. By invoking start_cheat_caller_address prior to contract instantiation with a precalculated contract address (using ContractClassTrait's precalculate_address), tests can simulate specific deployer addresses. Dependency on contract class and precise address calculation is required.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/using_cheatcodes_others/tests/cheat_constructor.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Example of Scarb.toml Manifest File\nDESCRIPTION: Presents a complete Scarb.toml manifest encapsulating package metadata, dependencies, dev-dependencies, target Starknet contract settings, scripts, tool.snforge test configuration including fork setups, Cairo compiler profiles, and feature flags. This example demonstrates how to integrate all discussed options into a single working configuration for building, testing, and profiling Starknet projects.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"example_package\"\nversion = \"0.1.0\"\nedition = \"2023_11\"\n\n# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n\n[dependencies]\nstarknet = \"2.8.2\"\n\n[dev-dependencies]\nsnforge_std = \"0.33.0\"\nstarknet = \">=2.8.2\"\nopenzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", branch = \"cairo-2\" }\n\n[[target.starknet-contract]]\nsierra = true\nbuild-external-contracts = [\"openzeppelin::account::account::Account\"]\n\n[scripts]\ntest = \"snforge test\"\n# foo = { path = \"vendor/foo\" }\n\n[tool.snforge]\nexit_first = true\nfuzzer_runs = 1234\nfuzzer_seed = 1111\n\n[[tool.snforge.fork]]\nname = \"SOME_NAME\"\nurl = \"http://your.rpc.url\"\nblock_id.tag = \"latest\"\n\n[[tool.snforge.fork]]\nname = \"SOME_SECOND_NAME\"\nurl = \"http://your.second.rpc.url\"\nblock_id.number = \"123\"\n\n[[tool.snforge.fork]]\nname = \"SOME_THIRD_NAME\"\nurl = \"http://your.third.rpc.url\"\nblock_id.hash = \"0x123\"\n\n[profile.dev.cairo]\nunstable-add-statements-code-locations-debug-info = true\nunstable-add-statements-functions-debug-info = true\ninlining-strategy = \"avoid\"\n\n[features]\nenable_for_tests = []\n```\n\n----------------------------------------\n\nTITLE: Asserting Test Panics with `#[should_panic]` in Rust\nDESCRIPTION: The `#[should_panic]` attribute marks a test function expected to panic. It can optionally check the panic data against a specific ByteArray, shortstring, or tuple of shortstrings. If the test panics as expected (and matches the specified data, if provided), it passes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-attributes.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[should_panic(expected: \"No such file or directory (os error 2)\")]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[should_panic(expected: 'panic message')]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[should_panic(expected: ('panic message', 'second message', ))]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[should_panic]\n```\n\n----------------------------------------\n\nTITLE: Fuzz Testing Example in Cairo\nDESCRIPTION: This Cairo code snippet demonstrates a basic example of fuzz testing. It utilizes the `#[fuzzer]` attribute to enable fuzzing for the test function. The function takes parameters that will be populated with randomly generated values during the fuzzing process.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fuzz-testing.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fuzz_testing/src/basic_example.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Fork Testing with Named Fork - Cairo\nDESCRIPTION: This code snippet demonstrates how to perform a fork test using a fork configuration defined in `Scarb.toml`.  It specifies the name of the fork in the `#[fork(...)]` attribute, allowing the test to run against the configured forked state. It obtains a dispatcher, instantiates it with a real contract address from the forked state, calls a method to modify the contract's state, and then asserts the changed state.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fork-testing.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fork_testing/tests/name.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Mocking a Starknet Contract Call for a Specific Number of Times (Rust)\nDESCRIPTION: The `mock_call` cheatcode mocks calls to a specified `function_selector` on a given `contract_address`. It forces the call to return the provided `ret_data` for the first `n_times` invocations. This works even for non-existent contracts or entry points but only mocks external entry point calls, not internal ones. The return data type `T` must implement `Serde` and `Destruct`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/mock_call.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn mock_call<T, impl TSerde: serde::Serde<T>, impl TDestruct: Destruct<T>>(\n  contract_address: ContractAddress, function_selector: felt252, ret_data: T, n_times: u32\n)\n```\n\n----------------------------------------\n\nTITLE: Starting global signature cheat - Starknet Foundry Rust\nDESCRIPTION: This cheatcode applies a transaction signature override that affects all subsequent transactions for any target contract. It requires the new signature as a `Span<felt252>`. This global cheat persists until explicitly canceled using `stop_cheat_signature_global()`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/signature.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_signature_global(signature: Span<felt252>)\n```\n\n----------------------------------------\n\nTITLE: Calling a Starknet Contract using sncast\nDESCRIPTION: Basic example of calling a contract function on the Sepolia network using sncast. This command queries the 'balance_of' function of a token contract with a specific account address as an argument.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/call.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n  call \\\n  --network sepolia \\\n  --contract-address 0x522dc7cbe288037382a02569af5a4169531053d284193623948eac8dd051716 \\\n  --function \"balance_of\" \\\n  --arguments '0x0554d15a839f0241ba465bb176d231730c01cf89cdcb95fe896c51d4a6f4bb8f'\n```\n\n----------------------------------------\n\nTITLE: Global Fuzzer Configuration in TOML\nDESCRIPTION: This TOML configuration snippet shows how to configure the fuzzer globally in the `Scarb.toml` file. It sets `fuzzer_runs` and `fuzzer_seed` under the `[tool.snforge]` section.  These settings will be applied to all tests within the project.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fuzz-testing.md#_snippet_4\n\nLANGUAGE: TOML\nCODE:\n```\n# ...\n[tool.snforge]\nfuzzer_runs = 1234\nfuzzer_seed = 1111\n# ...\n```\n\n----------------------------------------\n\nTITLE: Initializing an L1 Message Spy in Rust (snforge)\nDESCRIPTION: Demonstrates how to import the `spy_messages_to_l1` function from the `snforge_std` library and call it within a Rust test function (`#[test]`) to create a spy object. This spy object is used to capture and assert messages sent to L1 during the test execution.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-messages-to-l1.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nuse snforge_std::{spy_messages_to_l1};\n\n#[test]\nfn test_spying_l1_messages() {\n    let mut spy = spy_messages_to_l1();\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying a Starknet Contract using sncast (Shell)\nDESCRIPTION: Illustrates deploying a previously declared Starknet contract using `sncast deploy`. Requires the `class_hash` of the declared contract. Examples show specifying the account and Starknet RPC URL via flags (`--account`, `--url`) or using settings from `snfoundry.toml`. Successful deployment returns the contract address and transaction hash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/crates/sncast/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast --account my_account \\\n    deploy --class-hash 0x0227f52a4d2138816edf8231980d5f9e6e0c8a3deab45b601a1fcee3d4427b02 \\\n    --url http://127.0.0.1:5055\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Using default profile from snfoundry.toml\n$ sncast deploy \\\n--class-hash 0x0227f52a4d2138816edf8231980d5f9e6e0c8a3deab45b601a1fcee3d4427b02\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Example Output\ncommand: Deploy\ncontract_address: [..]\ntransaction_hash: [..]\n```\n\n----------------------------------------\n\nTITLE: Stopping Block Timestamp Cheat for Target\nDESCRIPTION: The `stop_cheat_block_timestamp` function cancels the block timestamp cheat for a specific target. It accepts a `target` contract address as input. This allows a developer to reset or remove the timestamp changes made by `cheat_block_timestamp` or `start_cheat_block_timestamp` for a given contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_timestamp.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_block_timestamp(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Cheating the Caller Address in a Test - Cairo\nDESCRIPTION: This Cairo test demonstrates leveraging the start_cheat_caller_address cheatcode to override the transaction's caller address for subsequent calls. Required dependencies include the 'snforge_std' cheats infrastructure. The cheatcode must be invoked before any function call dependent on caller validation and can be reverted using the respective stop function if needed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/using_cheatcodes_cheat_address/tests/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Invoking a Contract Function with sncast\nDESCRIPTION: This command sends a transaction to invoke a function on a contract using the provided account. It uses the `sncast invoke` subcommand after specifying the account using the `--account` flag, contract address, function, arguments, and network. Requires an existing account, a deployed contract, and `sncast` to be installed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/101.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast   --account my_account   invoke   --contract-address 0x00cd8f9ab31324bb93251837e4efb4223ee195454f6304fcfcb277e277653008   --function put   --arguments '0x123, 100'   --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Deploying a Contract with sncast\nDESCRIPTION: This command deploys a declared contract to the Starknet network. It uses the `sncast deploy` command, specifying the class hash, account, and network. Requires an existing account, a declared contract (class hash), and `sncast` to be installed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/101.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast   --account my_account   deploy   --class-hash 0x06813150c8b6256546fe2324b49f85021a207b6a383fc207d587f4bfacec00d8   --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Declaring and Deploying StarkNet Contracts with Foundry in Rust\nDESCRIPTION: This snippet shows a full example script written in Rust for declaring, deploying, and interacting with a MapContract on StarkNet. It demonstrates end-to-end contract lifecycle actions and interaction patterns within a Scarb package. Requires the MapContract source code and Foundry environment with sncast tooling. Inputs include contract definitions, deployment scripts, and network parameters. Outputs include class hashes, deployment addresses, transaction hashes, and call results. The example illustrates idempotent behavior and deployment failure handling when state files are omitted.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/map3/src/lib.cairo}}\n```\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/full_example/src/full_example.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Starting Specific Paymaster Data Cheat - Starknet Foundry Cairo\nDESCRIPTION: Initiates an override for `paymaster_data` specifically for the given `target` contract address. The provided `paymaster_data` will be used for transactions involving this target. This cheat remains active for the specific target until explicitly stopped.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/paymaster_data.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\nfn start_cheat_paymaster_data(target: ContractAddress, paymaster_data: Span<felt252>)\n```\n\n----------------------------------------\n\nTITLE: Defining Multicall Transaction Calls in TOML\nDESCRIPTION: This snippet provides an example TOML file format used to declare multiple calls within a multicall transaction for Starknet Foundry. Each call entry supports fields such as `call_type` to specify the action type (deploy or invoke), contract identifiers (e.g., `class_hash` or `contract_address`), function name, input parameters, and unique identifiers. This format enables batch execution of deployments and contract method invocations and requires correct syntax and appropriate call field values to be parsed by the `run` command.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/multicall/run.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[[call]]\ncall_type = \"deploy\"\nclass_hash = \"0x076e94149fc55e7ad9c5fe3b9af570970ae2cf51205f8452f39753e9497fe849\"\ninputs = []\nid = \"map_contract\"\nunique = false\n\n[[call]]\ncall_type = \"invoke\"\ncontract_address = \"0x38b7b9507ccf73d79cb42c2cc4e58cf3af1248f342112879bfdf5aa4f606cc9\"\nfunction = \"put\"\ninputs = [\"0x123\", \"234\"]\n\n[[call]]\ncall_type = \"invoke\"\ncontract_address = \"map_contract\"\nfunction = \"put\"\ninputs = [\"0x123\", \"234\"]\n\n[[call]]\ncall_type = \"deploy\"\nclass_hash = \"0x2bb3d35dba2984b3d0cd0901b4e7de5411daff6bff5e072060bcfadbbd257b1\"\ninputs = [\"0x123\", \"map_contract\"]\nunique = false\n```\n\n----------------------------------------\n\nTITLE: Fork Configuration in Scarb.toml - TOML\nDESCRIPTION: This snippet shows how to configure a fork within the `Scarb.toml` file by specifying the fork's name, RPC URL, and block identifier (using a tag like `latest`). This configuration allows for reuse of the same fork across multiple tests using a name.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fork-testing.md#_snippet_4\n\nLANGUAGE: TOML\nCODE:\n```\n[[tool.snforge.fork]]\nname = \"SEPOLIA_LATEST\"\nurl = \"https://starknet-sepolia.public.blastapi.io/rpc/v0_7\"\nblock_id.tag = \"latest\"\n```\n\n----------------------------------------\n\nTITLE: Invoking a Starknet Contract Function using sncast (Shell)\nDESCRIPTION: Shows how to invoke a function on a deployed Starknet contract using `sncast invoke`. This command sends a transaction to the network. It requires the contract address (`--contract-address`), the function name (`--function`), and function arguments (`--arguments`). Examples demonstrate providing account and URL details via flags or `snfoundry.toml`. The output includes the transaction hash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/crates/sncast/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n    --account my_account \\\n    invoke \\\n    --contract-address 0x0589a8b8bf819b7820cb699ea1f6c409bc012c9b9160106ddc3dacd6a89653cf \\\n    --function \"sum_numbers\" \\\n    --arguments '1, 2, 3' \\\n    --url http://127.0.0.1:5055/rpc\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Using default profile from snfoundry.toml (example still shows --url explicitly)\n$ sncast invoke \\\n    --contract-address 0x0589a8b8bf819b7820cb699ea1f6c409bc012c9b9160106ddc3dacd6a89653cf \\\n    --function \"sum_numbers\" \\\n    --arguments '1, 2, 3' \\\n    --url http://127.0.0.1:5055/rpc\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Example Output\ncommand: invoke\ntransaction_hash: [..]\n\nTo see invocation details, visit:\ntransaction: https://sepolia.starkscan.co/tx/[..]\n```\n\n----------------------------------------\n\nTITLE: Contract Deployment via Enhanced ContractClass Trait in Cairo\nDESCRIPTION: This Cairo snippet illustrates contract deployment using a revised interface, with `ContractClass` providing both address precalculation and deployment methods as traits. It first declares the contract, then deterministically precalculates the address before possible state warp, and finally deploys the instance, obtaining the dispatcher for further calls. This design requires modification of the `declare` cheatcode to return a typed `ContractClass`, and the implementation of associated deployment and precalculation traits. Key inputs include contract identifiers and constructor calldata arrays, with outputs as new contract addresses.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/prepare_cheatcode.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\nmod HelloStarknet {\n    // ...\n    \n    #[constructor]\n    fn constructor(ref self: ContractState) {\n        let timestamp = starknet::get_block_timestamp();\n        self.create_time.write(timestamp);\n    }\n}\n\n#[test]\nfn call_and_invoke() {\n    // Declare the contract\n    let contract = declare(\"HelloStarknet\");\n        \n    // Precalculate the address\n    let contract_address = contract.precalulucate_address(@ArrayTrait::new());\n    \n    // Warp the address\n    start_warp(contract_address, 1234);\n    \n    // Deploy with warped constructor\n    let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n    let dispatcher = IHelloStarknetDispatcher { contract_address };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing L1 Message Content with Spy Methods in Cairo\nDESCRIPTION: Shows how to retrieve the contents of the messages captured by the L1 spy within a Cairo test. By calling the `get_messages()` method (part of the `MessageToL1SpyTrait`), the test can access the details of each sent message (address and payload) for more complex or custom assertions. The actual code is included from an external file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-messages-to-l1.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_messages_to_l1/tests/detailed.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Asserting Events Emitted with emit_event_syscall Using Spy in Cairo\nDESCRIPTION: Extends the SpyEventsChecker contract with an emit_event_with_syscall method to emit events using emit_event_syscall, which supports nonstandard keys and data formats. The test snippet uses spy.assert_emitted and the snforge_std Event struct to assert these nontraditional events, enabling validation of events that lack predefined structures or are from external sources. This technique improves flexibility in event testing scenarios.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-events.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/testing_events/src/syscall_dummy.cairo}}\n```\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/testing_events/tests/syscall.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Changing Transaction Tip for Specific Target in Rust\nDESCRIPTION: Defines `start_cheat_tip` which sets the transaction tip for a single specific contract address target. Accepts a `ContractAddress` and a 128-bit tip value, enabling simulated fee manipulation for targeted transactions without specifying a span.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/tip.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_tip(target: ContractAddress, tip: u128)\n```\n\n----------------------------------------\n\nTITLE: Accessing Class Hash from DeclareResult in Cairo\nDESCRIPTION: This code snippet defines the `DeclareResultTrait` to access the `class_hash` from a `DeclareResult`. The `class_hash` is crucial for identifying declared contracts. It provides access to the `class_hash` regardless of whether the contract was declared successfully or already declared. This snippet shows how to retrieve class hash from the result of the declare operation. It's used with the result of a successful contract declaration or when a contract is already declared.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/declare.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub trait DeclareResultTrait {\n    fn class_hash(self: @DeclareResult) -> @ClassHash;\n}\n```\n\n----------------------------------------\n\nTITLE: Writing a Basic Starknet Contract Test with snforge (Cairo)\nDESCRIPTION: Illustrates a basic test case for the `SimpleContract` using `snforge`. The test deploys the contract and calls one of its functions, asserting the expected outcome. Note that constructor arguments (calldata) require Serde serialization, although this example uses empty calldata.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_smart_contracts_writing_tests/tests/simple_contract.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Changing Sequencer Address for Specific Target in Rust\nDESCRIPTION: This function changes the sequencer address for a specific contract target during a defined span. It requires the ContractAddress types for both the target and the sequencer address, as well as a CheatSpan specifying the duration. The input parameters influence which target's sequencer address is changed and for how long. No output is specified as it modifies internal state affecting contract behavior during tests.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/sequencer_address.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_sequencer_address(target: ContractAddress, sequencer_address: ContractAddress, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Creating Starknet Account with Starkli-Style Keystore using sncast\nDESCRIPTION: This command creates a new OpenZeppelin account using the starkli-style keystore mechanism. It generates a keystore file containing the private key and an account JSON file containing the account information. It requires interactive input for setting the keystore password.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n    --keystore my_key.json \\\n    --account my_account.json \\\n    account create \\\n    --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Running StarkNet Deployment and Interaction Scripts with sncast in Shell\nDESCRIPTION: This snippet demonstrates how to execute a contract deployment and interaction script using the 'sncast' CLI tool, specifying the user account, script name, and network ('sepolia'). It includes examples showing successful deployment with generated class hashes and transaction hashes, repeated execution demonstrating idempotent behavior due to state files, and invocation failure when skipping state files for previously deployed contracts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n  --account example_user \\\n  script run map_script \\\n  --network sepolia\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n  --account example_user \\\n  script run map_script \\\n  --network sepolia \\\n  --no-state-file\n```\n\n----------------------------------------\n\nTITLE: Fork Testing with Block Number - Cairo\nDESCRIPTION: This code demonstrates how to perform a fork test by specifying the RPC URL and a specific block number in the `#[fork(...)]` attribute.  It obtains a dispatcher, instantiates it with a real contract address from the forked state, calls a method to modify the contract's state, and then asserts the changed state.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fork-testing.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fork_testing/tests/explicit/block_number.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Changing Transaction Hash for Specific Target Contract - Rust\nDESCRIPTION: Defines a function to change the transaction hash for a specific contract address within a given span during testing. Requires the target contract's address, the new transaction hash value, and a span representing the cheatcode's application duration. Used to tailor transaction hashes scoped to a contract and execution span.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_hash.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn cheat_transaction_hash(target: ContractAddress, transaction_hash: felt252, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Creating Starknet Account Info Locally with sncast\nDESCRIPTION: This command creates the necessary local information for a new Starknet account, including the private key and potential address, tied to a specific network and name. It does not deploy the account to the blockchain. The output includes the generated address and the maximum fee needed to prefund the address before deployment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n    account create \\\n    --network sepolia \\\n    --name new_account\n```\n\n----------------------------------------\n\nTITLE: Full Example: Using CheatSpan with Caller Address - Cairo\nDESCRIPTION: This Cairo file demonstrates a complete, practical application of the CheatSpan feature in the context of caller address manipulation during contract function testing. It is a comprehensive test covering various activation, use, and deactivation scenarios of caller address cheating, aiding in understanding cheatcode temporal scopes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/using_cheatcodes_others/tests/caller_address/span.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Adding snforge_std dependency to Scarb.toml\nDESCRIPTION: Configuration to add the 'snforge_std' package as a development dependency in the Scarb.toml file. The version should match the installed snforge version.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n# ...\n\n[dev-dependencies]\nsnforge_std = \"0.33.0\"\n```\n\n----------------------------------------\n\nTITLE: Idempotency Wrapper Function for Transaction Execution - Rust\nDESCRIPTION: Provides a Rust higher order function `skip_if_done` designed to wrap transaction-related function calls to ensure idempotency when interacting with the Starknet chain. The function checks the state file to determine if a transaction has already succeeded, and conditionally executes the wrapped function accordingly. It allows avoiding duplicate transactions and managing retries by referring to saved transaction hashes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/cairo_deployment_scripts.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn skip_if_done<F>(func: F)\nwhere\n    F: Fn() + 'static,\n{\n    // Decorator logic here\n    // Check the state file and decide whether to execute the function or not\n\n    if should_execute {\n        func();\n        // write func outputs to state file\n    } else {\n        // Do nothing or return an appropriate value\n    }\n}\n\nfn main() {\n    skip_if_done(|| {\n        dispatcher.send_eth(...);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Starknet Contract with Constructor Calldata using sncast Shell\nDESCRIPTION: Deploys a Starknet contract that has a constructor requiring input arguments. The arguments are passed as a list of felt252 values via the `--constructor-calldata` parameter, respecting type serialization rules (e.g., u256 requires two felts). Requires the contract's class hash. Outputs the deployed contract address and transaction hash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/deploy.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast deploy \\\n    --class-hash 0x02e93ad9922ac92f3eed232be8ca2601fe19f843b7af8233a2e722c9975bc4ea \\\n    --constructor-calldata 0x1 0x2 0x3\n```\n\n----------------------------------------\n\nTITLE: Creating Starknet Account with Specific Salt using sncast\nDESCRIPTION: This command creates local account information allowing the user to specify the salt value used in the account address calculation instead of relying on a randomly generated one. This is useful for deterministic address generation. You must provide the network, name, and the desired salt.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n    account create \\\n    --network sepolia \\\n    --name another_account_3 \\\n    --salt 0x1\n```\n\n----------------------------------------\n\nTITLE: Enabling transaction wait mode with sncast\nDESCRIPTION: Flag that makes the command wait until the transaction is either accepted or rejected before returning.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n--wait, -w\n```\n\n----------------------------------------\n\nTITLE: Configuring Fork Testing Inline with `#[fork]` in Rust\nDESCRIPTION: The `#[fork]` attribute enables state forking for a test case, specifying the RPC endpoint URL and the state reference point. The reference point can be a block number, block hash, or the 'latest' block tag.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-attributes.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[fork(url: \"http://example.com\", block_number: 123)]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[fork(url: \"http://example.com\", block_hash: 0x123deadbeef)]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[fork(url: \"http://example.com\", block_tag: latest)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Fuzz Testing with `#[fuzzer]` in Rust\nDESCRIPTION: The `#[fuzzer]` attribute enables fuzz testing for a test function, which must accept parameters to be fuzzed. It allows configuring the number of runs and the initial seed for reproducibility. If parameters are omitted, default values (runs=256) are used. Test functions without parameters will cause a crash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-attributes.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n#[fuzzer(runs: 10, seed: 123)]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[fuzzer]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[fuzzer(runs: 10)]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[fuzzer(seed: 123)]\n```\n\n----------------------------------------\n\nTITLE: Using expect_events Cheatcode\nDESCRIPTION: This test case demonstrates how to use the `expect_events` cheatcode to verify the emission of specific events after a contract call.  It sets up expected events using `expect_events` and then calls `emit_store_name` which triggers the event. It asserts that if the emitted events match, it will not panic. Prerequisites are `snforge_std` library and a contract instance `contract` of a contract implementing `IHelloEvent`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/accessing_emitted_events.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nuse snforge_std::expect_events;\nuse snforge_std::Event;\n\n#[test]\nfn check_emitted_event() {\n    // ...\n\texpect_events(array![Event { name: 'StoredName', keys: array![123], data: array![456] }]);\n    let res = contract.emit_store_name(...);  // if the event is not emitted it will panic\n\n    let res = contract.emit_store_name(...);  // expect_events does not work here\n    \n    expect_exact_events(array![Event { name: 'StoredName', keys: array![123], data: array![456] }]);\n    let res = contract.emit_store_name(...);  // function has to emit exactly those events defined in the array otherwise it will panic\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Transaction Deployment with Wait Option Using sncast in Shell\nDESCRIPTION: Shows how to deploy a Starknet contract class using the sncast CLI with explicit account specification and the --wait flag enabled. The command waits for transaction confirmation up to the ACCEPTED_ON_L2 status, displaying retry messages during the waiting period. Parameters include the network, class hash, and account. The snippet includes an example output illustrating the waiting mechanism and final confirmation, signaling transaction success. Requirements include configured account credentials and network connectivity.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/sncast-overview.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast --account my_account \\\n    --wait \\\n    deploy \\\n\t--network sepolia \\\n    --class-hash 0x0227f52a4d2138816edf8231980d5f9e6e0c8a3deab45b601a1fcee3d4427b02\n```\n\n----------------------------------------\n\nTITLE: Modifying Nonce for a Specific Target and Span (Rust)\nDESCRIPTION: Sets the transaction nonce for a specific contract address (`target`) to a specified value (`nonce`) for a defined duration (`span`). This is a temporary modification tied to the span, reverting afterwards.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_nonce(target: ContractAddress, nonce: felt252, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Setting wait timeout with sncast\nDESCRIPTION: Flag for specifying the maximum time in seconds to wait for a transaction when --wait is used. Defaults to 60 seconds.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n--wait-timeout <TIME_IN_SECONDS>\n```\n\n----------------------------------------\n\nTITLE: Importing Existing Starknet Account with sncast\nDESCRIPTION: Use this command to import an existing Starknet account into the local accounts file managed by `sncast`. You must provide the network, a local name for the account, the account's address, its private key, and the account type (e.g., oz for OpenZeppelin).\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n    account import \\\n\t--network sepolia \\\n    --name my_imported_account \\\n    --address 0x3a0bcb72428d8056cc7c2bbe5168ddfc844db2737dda3b4c67ff057691177e1 \\\n    --private-key 0x2 \\\n    --type oz\n```\n\n----------------------------------------\n\nTITLE: sncast Verification Command Output in Shell\nDESCRIPTION: This output illustrates the confirmation prompt and informational messages displayed by sncast when initiating contract verification. It warns about submitting the entire workspace to the third-party verifier, advises on keystore handling, and provides a verification status link upon user confirmation. No user input beyond interactive confirmation (Y/n) is required; sensitive information must be handled outside the project to avoid accidental disclosure.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/verify.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n\n    You are about to submit the entire workspace code to the third-party verifier at walnut.\n\n    Important: Make sure your project does not include sensitive information like private keys. The snfoundry.toml file will be uploaded. Keep the keystore outside the project to prevent it from being uploaded.\n\n    Are you sure you want to proceed? (Y/n): Y\n\ncommand: verify\nmessage: Contract verification has started. You can check the verification status at the following link: https://app.walnut.dev/verification/status/77f1d905-fdb4-4280-b7d6-57cd029d1259.\n```\n\n----------------------------------------\n\nTITLE: Initialize a New sncast Cairo Deployment Script - Shell\nDESCRIPTION: Shell command to bootstrap a new Cairo deployment script package compatible with Starknet Foundry's sncast tool. The `sncast script init` command creates necessary directories and configuration files enabling developers to start writing deployment scripts with the proper scaffolding. A prerequisite is having sncast installed. Running this command creates a directory structure under a specified script name, including 'Scarb.toml' and source directories, facilitating integration into a Scarbs workspace.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ sncast script init my_script\n```\n\n----------------------------------------\n\nTITLE: Asserting Event Emission Using assert_emitted Method in Cairo\nDESCRIPTION: Shows how to deploy the SpyEventsChecker contract and create an event spy using the spy_events cheatcode. It demonstrates the assert_emitted method which asserts that an array snapshot of expected (ContractAddress, event) tuples was emitted by the contract. This approach is convenient because it does not require explicitly fetching events. The snippet assumes previously deployed contract and correct spy initialization.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-events.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/testing_events/tests/assert_emitted.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Calling a Starknet Contract Function using sncast (Shell)\nDESCRIPTION: Demonstrates how to call a read-only (view) function on a deployed Starknet contract using `sncast call`. This command does not send a transaction or modify state. It requires the contract address (`--contract-address`), function name (`--function`), arguments (`--arguments`), and the Starknet RPC URL (`--url`). The example shows providing arguments via flags, but `snfoundry.toml` can also be used for the URL. The output displays the function's return value.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/crates/sncast/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n    call \\\n    --contract-address 0x0589a8b8bf819b7820cb699ea1f6c409bc012c9b9160106ddc3dacd6a89653cf \\\n    --function \"sum_numbers\" \\\n    --arguments '1, 2, 3' \\\n    --url http://127.0.0.1:5055/rpc\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Using default profile from snfoundry.toml (example still shows --url explicitly)\n$ sncast call \\\n    --contract-address 0x0589a8b8bf819b7820cb699ea1f6c409bc012c9b9160106ddc3dacd6a89653cf \\\n    --function \"sum_numbers\" \\\n    --arguments '1, 2, 3' \\\n    --url http://127.0.0.1:5055/rpc\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Example Output\ncommand: call\nresponse: [0x6]\n```\n\n----------------------------------------\n\nTITLE: Starting Global Paymaster Data Cheat - Starknet Foundry Cairo\nDESCRIPTION: Initiates a global override for `paymaster_data`. The provided `paymaster_data` will be applied to all subsequent transactions originating from the test environment, regardless of the target contract. This cheat remains active until explicitly stopped.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/paymaster_data.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfn start_cheat_paymaster_data_global(paymaster_data: Span<felt252>)\n```\n\n----------------------------------------\n\nTITLE: Creating an Account using sncast\nDESCRIPTION: This command creates a new Starknet account, generating account details. It uses the `sncast account create` command with options to specify the account name and network.  The output includes the address and max_fee required for prefunding.  Requires `sncast` to be installed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/101.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast account create   --name my_account   --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Declaring a Contract with sncast\nDESCRIPTION: This command declares a contract to the Starknet network. It uses the `sncast declare` command with the contract name and network.  The contract code is expected to be present in the project configured with `scarb`. Requires an existing account, a compiled contract, and `sncast` and `scarb` installed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/101.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast   --account my_account   declare   --contract-name HelloStarknet   --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Deploying Starknet Contract with Unique Address using sncast Shell\nDESCRIPTION: Deploys a Starknet contract using the `--unique` flag. This parameter modifies the salt used in address calculation by incorporating the deployer account's address, ensuring a unique address per deployer for a given class hash and optional salt. Outputs the deployed contract address and transaction hash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/deploy.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast deploy \\\n    --class-hash 0x0227f52a4d2138813edf8231980d5f9e6e0c8a3deab45b601a1fcee3d4427b02 \\\n    --unique\n```\n\n----------------------------------------\n\nTITLE: Changing Sequencer Address for Specific Target in Rust\nDESCRIPTION: Starts modifying the sequencer address for a given contract target. It requires the target's ContractAddress and the new sequencer address as inputs. This change persists until explicitly stopped. Useful for scoped address changes during testing or debugging.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/sequencer_address.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_sequencer_address(target: ContractAddress, sequencer_address: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Setting Accounts File Path - TOML\nDESCRIPTION: This TOML snippet configures the path to an accounts file for a specified profile, which specifies which account to use for transactions.  The `accounts-file` setting is used to determine where sncast will search for account details, and this allows you to specify a path to the file containing the account information. If the value isn't present, it defaults to `~/.starknet_accounts/starknet_open_zeppelin_accounts.json`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\naccounts-file = \"path/to/accounts.json\"\n```\n\n----------------------------------------\n\nTITLE: Define Multicall Operations in TOML for sncast\nDESCRIPTION: Example TOML configuration file defining a sequence of operations (deploy and invoke) for `sncast multicall run`. It demonstrates deploying a contract using `class_hash`, assigning an `id`, and then invoking a function (`put`) on the deployed contract using the assigned `id` as `contract_address`. Inputs can be hex strings or numbers.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/multicall.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[[call]]\ncall_type = \"deploy\"\nclass_hash = \"0x076e94149fc55e7ad9c5fe3b9af570970ae2cf51205f8452f39753e9497fe849\"\ninputs = []\nid = \"map_contract\"\nunique = false\n\n[[call]]\ncall_type = \"invoke\"\ncontract_address = \"map_contract\"\nfunction = \"put\"\ninputs = [\"0x123\", 234]  # Numbers can be used directly without quotes\n```\n\n----------------------------------------\n\nTITLE: Generate trace data for Starknet tests using snforge\nDESCRIPTION: This command instructs snforge to generate trace data files for each passing test. These files can then be used as input for cairo-profiler to analyze the execution of the Starknet contracts. The trace files are saved to the `snfoundry_trace` directory.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/profiling.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --save-trace-data\n```\n\n----------------------------------------\n\nTITLE: Felt-only storage map entry access\nDESCRIPTION: This example showcases how to access and manipulate entries in a map within a Starknet contract's storage using Snforge. It uses the `map_entry_address` function in conjunction with `selector!` to target a specific key-value pair in the map, demonstrating both writing and reading operations. Dependencies include Starknet and Snforge.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/direct_storage_access/tests/felts_only/map_entry.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Generating a new multicall template using shell command\nDESCRIPTION: This snippet explains how to invoke the `multicall new` command to generate an empty `.toml` template file for multicall configurations. It outlines required and optional arguments, including the output file path and options for overwriting existing files. The snippet provides context on executing this command to set up multicall templates efficiently.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/multicall/new.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nmulticall new <OUTPUT-PATH> [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Specifying Fee Settings in StarkNet Deployment Scripts using Rust\nDESCRIPTION: This Rust snippet shows various methods of specifying transaction fee settings in StarkNet scripts. It includes automatic fee estimation, manual specification of resource bounds (L1 gas, gas price, L2 gas, and associated prices denoted in FRI), and setting an explicit maximum fee. These settings influence gas consumption and payment during contract invocation or deployment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet fee_settings = FeeSettingsTrait::estimate();\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet fee_settings = FeeSettingsTrait::resource_bounds(\n  100000, // l1 gas\n  10000000000000, // l1 gas price\n  1000000000, // l2 gas\n  100000000000000000000, // l2 gas price\n  100000, // l1 data gas\n  10000000000000, // l1 data gas price\n);\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet fee_settings = FeeSettingsTrait::max_fee(100000000000000000000);\n```\n\n----------------------------------------\n\nTITLE: Defining Features for Conditional Compilation in TOML\nDESCRIPTION: Defines the [features] section for specifying named compile-time features in Scarb.toml that enable or disable conditional compilation. Each feature can optionally enable other features automatically. This mechanism is used to include or exclude code through attributes like #[cfg(feature: '<feature-name>')] in Rust or Cairo code, allowing flexible build configurations and testing setups.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[features]\nenable_for_tests = []\n```\n\n----------------------------------------\n\nTITLE: Running All snforge Tests (Shell)\nDESCRIPTION: Executes all tests found within the Starknet Foundry package. This is the default behavior of the `snforge test` command when no arguments or flags are provided. The output shows the number of tests collected, run, and the results (PASS/FAIL), along with gas usage estimates.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/running-tests.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test\n```\n\n----------------------------------------\n\nTITLE: Running Tests for Specific Package\nDESCRIPTION: This command runs tests for a specific package within a Scarb workspace using the `--package` flag.  Dependencies: `snforge`, a Scarb workspace, and the package name.  Input: The package name is passed as a parameter to the `--package` flag. Output: Test results specifically for the designated package.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-workspaces.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --package addition\n```\n\n----------------------------------------\n\nTITLE: Filtering snforge Tests by Name (Shell)\nDESCRIPTION: Runs only those tests whose absolute module tree path matches the provided filter string (e.g., `calling`). This allows users to execute a subset of tests relevant to a specific feature or component without running the entire test suite. The output confirms which tests were collected and run based on the filter.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/running-tests.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test calling\n```\n\n----------------------------------------\n\nTITLE: Invoking a Smart Contract Function Without Arguments using sncast\nDESCRIPTION: Example of using sncast to invoke the 'get_balance' function on a smart contract without passing any arguments. This demonstrates the simplified command structure when no parameters are needed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/invoke.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast invoke \\\n  --contract-address 0x0589a8b8bf819b7820cb699ea1f6c409bc012c9b9160106ddc3dacd6a89653cf \\\n  --function \"get_balance\"\n```\n\n----------------------------------------\n\nTITLE: Filtering Events by Contract Address with emitted_by Method in Cairo\nDESCRIPTION: Illustrates filtering emitted events on the Events structure by specific contract addresses using the emitted_by method, allowing testers to focus assertions on subsets of events emitted by individual contracts. The snippet returns events_from_first_address and events_from_second_address arrays respectively, demonstrating selective event retrieval for enhanced test accuracy.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-events.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/testing_events/tests/filter.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining the MessageToL1 Struct in Rust\nDESCRIPTION: Defines the `MessageToL1` struct, representing the raw format of a message sent to L1 as observed via the RPC-API. It includes the destination Ethereum address (`to_address`) and the message `payload` (an array of felt252), enabling assertions on the exact content of sent messages.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_messages_to_l1.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct MessageToL1 {\n    /// An ethereum address where the message is destined to go\n    to_address: EthAddress,\n    /// Actual payload which will be delivered to L1 contract\n    payload: Array<felt252>\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Unit Tests in Rust Modules with #[cfg(test)] - Rust\nDESCRIPTION: This snippet demonstrates how to define both valid and invalid unit tests in Rust when using Snforge. Functions not wrapped in a #[cfg(test)] module will not be recognized or executed, while those within such a module will. The test function `my_invalid_test` will be ignored, while tests inside the `tests` module (such as `my_test`) will be collected and run by Snforge. No external dependencies are required beyond the snforge_std plugin. The primary input is Rust test code in files contained in the `src` directory, and correctness of test collection depends on module placement and attribute usage.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-collection.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// src/example.rs\n// ...\n\n// This test is not in module marked with `#[cfg(test)]` so it won't work\n#[test]\nfn my_invalid_test() {\n    // ...\n}\n\n#[cfg(test)]\nmod tests {\n    // This test is in module marked with `#[cfg(test)]` so it will work\n    #[test]\n    fn my_test() {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventSpyAssertionsTrait - Rust\nDESCRIPTION: Defines the `EventSpyAssertionsTrait`, which provides functions to assert the emission (or lack thereof) of specific events. `assert_emitted` checks if a given array of events was emitted, and `assert_not_emitted` checks if a given array of events was not emitted.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_events.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\ntrait EventSpyAssertionsTrait<T, impl TEvent: starknet::Event<T>, impl TDrop: Drop<T>> {\n    fn assert_emitted(ref self: EventSpy, events: @Array<(ContractAddress, T)>);\n    fn assert_not_emitted(ref self: EventSpy, events: @Array<(ContractAddress, T)>);\n}\n```\n\n----------------------------------------\n\nTITLE: sncast show-config output\nDESCRIPTION: This shows the output of the sncast show-config command. It displays the command being executed, the account used, the chain ID, and the RPC URL.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/show_config.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncommand: show-config\naccount: my_account\nchain_id: alpha-sepolia\nrpc_url: http://127.0.0.1:5055/rpc\n```\n\n----------------------------------------\n\nTITLE: Defining Integration Tests in the Tests Directory - Rust\nDESCRIPTION: This snippet illustrates a valid integration test file placed in the `tests` directory. Tests in this directory do not need to be contained within a #[cfg(test)] module, and each test file is treated as its own module by Scarb and Snforge. No external dependencies apart from the snforge_std plugin are required. The input is a Rust test file, and the output is that each test function (such as `my_test_1`) will be collected and executed during the build process.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-collection.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// tests/example.rs\n// ...\n\n// This test is in `tests` directory\n// so it works without being in module with `#[cfg(test)]` \n#[test]\nfn my_test_1() {\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Panics Gracefully using SafeDispatcher (Cairo)\nDESCRIPTION: Demonstrates how to use `SafeDispatcher` to call a potentially panicking contract function (`panic_with_felt252`). The call returns a `Result`, allowing the test to catch the `Err` variant containing the panic data and assert its contents, thus verifying the panic behavior correctly.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_9\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_smart_contracts_safe_dispatcher/tests/safe_dispatcher.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining Library Module Imports in lib.cairo - Rust\nDESCRIPTION: The snippet provides an example of a `lib.cairo` file in the `tests` directory, demonstrating how to explicitly include test modules. When `lib.cairo` is present, only tests reachable from this file will be collected and compiled, and files not imported will be ignored. The main prerequisite is the correct placement of `lib.cairo` in the `tests` directory. The key input is the list of modules imported with the `mod` statement, which controls the set of active test targets.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-collection.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// tests/lib.cairo\n\nmod module1;\nmod module2;\n```\n\n----------------------------------------\n\nTITLE: Deploying Starknet Contract with sncast Shell\nDESCRIPTION: Deploys a previously declared Starknet contract using the `sncast deploy` command. Requires the class hash of the declared contract, the account name, and the network to deploy on. The tool uses the Universal Deployer Contract (UDC) internally. Outputs the deployed contract address and the transaction hash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/deploy.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n    --account my_account \\\n    deploy \\\n    --network sepolia \\\n    --class-hash 0x0227f52a4d2138816edf8231980d5f9e6e0c8a3deab45b601a1fcee3d4427b02\n```\n\n----------------------------------------\n\nTITLE: Configuring StarkNet Contract Dependencies and Build Settings in TOML\nDESCRIPTION: This TOML snippet illustrates the configuration of a Scarb package for the script named 'map_script'. It specifies package metadata, contract dependencies (including paths to local contract directories), enables Sierra and CASM compilations, and declares external contract building via the 'build-external-contracts' property. This setup is needed to generate artifacts to access external contracts from scripts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"map_script\"\nversion = \"0.1.0\"\n\n[dependencies]\nstarknet = \">=2.8.0\"\nsncast_std = \"0.33.0\"\nmap = { path = \"../contracts\" }\n\n[lib]\nsierra = true\ncasm = true\n\n[[target.starknet-contract]]\nbuild-external-contracts = [\n    \"map::MapContract\"\n]\n```\n\n----------------------------------------\n\nTITLE: Defining CheatSpan Enum for Cheatcode Duration Control in Rust\nDESCRIPTION: This Rust enum defines CheatSpan with two variants: Indefinite and TargetCalls. Indefinite applies the cheatcode without time limit until manually canceled, while TargetCalls limits the cheatcode application to a specified number of calls, after which the cheatcode stops automatically or can be canceled manually. It is used to control the duration of cheatcodes for target contracts within the starknet-foundry testing framework.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/cheat_span.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nenum CheatSpan {\n    Indefinite: (),\n    TargetCalls: usize\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ContractClassTrait in Rust\nDESCRIPTION: This snippet defines the `ContractClassTrait` and its associated methods for interacting with a `ContractClass`. It includes `precalculate_address` to estimate the contract address before deployment, `deploy` to deploy a new contract, and `deploy_at` to deploy a contract at a specified address.  The `new` function constructs a `ContractClass` instance. This trait provides the fundamental functionality for deploying and interacting with contracts in the StarkNet environment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/contract_class.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait ContractClassTrait {\n    fn precalculate_address(\n        self: @ContractClass, constructor_calldata: @Array::<felt252>\n    ) -> ContractAddress;\n\n    fn deploy(\n        self: @ContractClass, constructor_calldata: @Array::<felt252>\n    ) -> SyscallResult<(ContractAddress, Span<felt252>)>;\n\n    fn deploy_at(\n        self: @ContractClass,\n        constructor_calldata: @Array::<felt252>,\n        contract_address: ContractAddress\n    ) -> SyscallResult<(ContractAddress, Span<felt252>)>;\n\n    fn new<T, +Into<T, ClassHash>>(class_hash: T) -> ContractClass;\n}\n```\n\n----------------------------------------\n\nTITLE: Running snforge with Automatic Coverage Generation\nDESCRIPTION: Shell command to run snforge tests and automatically generate coverage reports using cairo-coverage.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/coverage.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --coverage\n```\n\n----------------------------------------\n\nTITLE: Configuring snforge_std Dependency in Scarb.toml (TOML)\nDESCRIPTION: Adds the `snforge_std` package as a development dependency in the `Scarb.toml` configuration file. This is required to use the testing utilities provided by Starknet Foundry's snforge.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[dev-dependencies]\nsnforge_std = \"0.37.0\"\n```\n\n----------------------------------------\n\nTITLE: Stopping snforge Tests on First Failure (Shell)\nDESCRIPTION: Runs the test suite but immediately stops execution as soon as the first test fails, using the `--exit-first` flag. This saves time by preventing the full suite from running when an early failure indicates a significant issue. The output shows the failure details and notes which tests were skipped due to the early exit.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/running-tests.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --exit-first\n```\n\n----------------------------------------\n\nTITLE: Running snforge with Trace Data Generation\nDESCRIPTION: Shell command to run snforge tests while saving trace data for coverage analysis.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/coverage.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --save-trace-data\n```\n\n----------------------------------------\n\nTITLE: Generate Multicall Template with sncast new\nDESCRIPTION: Shell command using `sncast multicall new` to generate a template TOML file (`./template.toml`) for defining multicall operations. This helps in structuring the multicall configuration.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/multicall.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast multicall new ./template.toml\n```\n\n----------------------------------------\n\nTITLE: Adding snforge_std using Scarb command\nDESCRIPTION: Alternative method to add the snforge_std dependency using the 'scarb add' command. This is equivalent to manually editing the Scarb.toml file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ scarb add snforge_std@0.33.0 --dev\n```\n\n----------------------------------------\n\nTITLE: Defining a Contract with Conditional Compilation (Cairo)\nDESCRIPTION: This snippet demonstrates how to define a Cairo contract with a `#[cfg(feature: '<FEATURE_NAME>')]` attribute, allowing it to be compiled only when the specified feature is enabled. The contract's functionality is determined by the feature flag. This is crucial for enabling or disabling test-specific contracts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/conditional-compilation.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/conditional_compilation/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining Structures for StarkNet Contract Declaration in Rust\nDESCRIPTION: This snippet defines the `DeclareResult` enum to represent the outcomes of a contract declaration (Success or AlreadyDeclared), and the `DeclareResultTrait` with a method `contract_class` to extract the `ContractClass` from a `DeclareResult`. It also shows the signature for the `declare` function, which takes the contract bytecode as `ByteArray` and returns a `Result` containing either a `DeclareResult` or an error represented by an array of `felt252`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/declare.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Drop, Serde, Clone)]\nenum DeclareResult {\n    Success: ContractClass,\n    AlreadyDeclared: ContractClass,\n}\n\ntrait DeclareResultTrait {\n    /// Gets inner `ContractClass`\n    /// `self` - an instance of the struct `DeclareResult` which is obtained by calling `declare`\n    // Returns the `@ContractClass`\n    fn contract_class(self: @DeclareResult) -> @ContractClass;\n}\n\nfn declare(contract: ByteArray) -> Result<DeclareResult, Array<felt252>>\n```\n\n----------------------------------------\n\nTITLE: Defining Deploy Result Struct - Rust\nDESCRIPTION: Defines the `DeployResult` struct, which is returned by the `deploy` function after a successful contract deployment. The struct holds the deployed contract's address and the transaction hash.  This struct is a vital component of the deploy process, enabling the client to track the deployment status.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/deploy.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#[derive(Drop, Clone, Debug)]\npub struct DeployResult {\n    pub contract_address: ContractAddress,\n    pub transaction_hash: felt252,\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Starkli-Style Keystore Account with sncast (Example: Declare)\nDESCRIPTION: This snippet demonstrates how to use an account managed via a starkli-style keystore file (`--keystore`) and account JSON file (`--account`) when executing a `sncast` command (here, `declare`). This method requires interactive input for the keystore password.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n    --keystore keystore.json \\\n    --account account.json  \\\n    declare \\\n\t--network sepolia \\\n    --contract-name my_contract\n```\n\n----------------------------------------\n\nTITLE: FileParser Trait Supporting Plain Text and JSON Parsing in Cairo\nDESCRIPTION: A generic Rust trait FileParser with parameters T and a Serde interface for T. It provides two functions, parse_txt and parse_json, which take a File reference and return an Option wrapping an instance of T. These functions enable polymorphic parsing of file contents either as plain text or JSON, facilitating deserialization into custom data types.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/fs.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntrait FileParser<T, +Serde<T>> {\n    fn parse_txt(file: @File) -> Option<T>;\n    fn parse_json(file: @File) -> Option<T>;\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting No Event Emission with assert_not_emitted Function in Cairo\nDESCRIPTION: Demonstrates usage of the assert_not_emitted function to verify that specific events were not emitted during execution. This method panics if the given event with the exact name and payload was emitted, making it useful for negative test cases. The example shows how to assert that a FirstEvent with different payload data was not emitted by the SpyEventsChecker contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-events.md#_snippet_2\n\nLANGUAGE: cairo\nCODE:\n```\nspy.assert_not_emitted(@array![\n    (\n        contract_address,\n        SpyEventsChecker::Event::FirstEvent(\n            SpyEventsChecker::FirstEvent { some_data: 456 }\n        )\n    )\n]);\n```\n\n----------------------------------------\n\nTITLE: Defining CheatSpan for Fine-Grained Cheatcode Control - Cairo\nDESCRIPTION: This Cairo code snippet defines the CheatSpan enum for specifying how long cheatcodes remain active. CheatSpan can be Indefinite or for a fixed number of TargetCalls, making it integral for targeted testing of contract functions under manipulated blockchain state. Used as an argument when activating cheatcodes for step-wise granularity.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nenum CheatSpan {\n    Indefinite: (),\n    TargetCalls: usize,\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Caller Address for Target with start_cheat_caller_address in Rust\nDESCRIPTION: This function sets the caller address for a specific contract in the testing environment. Inputs include the targeted contract address and the new caller address. This is used for granular control during targeted tests, particularly when multiple contracts require distinct simulated callers; depends on Starknet Foundrys cheatcode mechanisms.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/caller_address.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_caller_address(target: ContractAddress, caller_address: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Generating Pseudo-Random Felt252 Values in Rust\nDESCRIPTION: Defines a Rust function `generate_random_felt` that returns a pseudo-random value of type Felt252. This function is used for generating random elements conforming to the Felt252 field size, typically used in cryptographic operations within Starknet projects. No explicit dependencies or parameters are listed in the snippet; the function returns a Felt252 instance. Inputs are internal to the function's random generation logic, and output is a Felt252 number representing the random value.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/generate_random_felt.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn generate_random_felt() -> Felt252\n```\n\n----------------------------------------\n\nTITLE: Declaring and Preparing Contract Deployment with Cheatcodes in Cairo\nDESCRIPTION: This snippet demonstrates declaring a contract, preparing it for deployment, predicting its eventual on-chain address using `precalculate_address`, and deploying it with modified constructor behavior using cheatcodes in Starknet Foundry's testing framework. It requires the relevant cheatcodes (`declare`, `precalculate_address`, `deploy`), assumes the existence of a contract named `HelloStarknet`, and calls a `start_warp` utility to manipulate state. Inputs are the contract name and possibly custom constructor calldata, and the output is an initialized instance at a known address.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/prepare_cheatcode.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nmod HelloStarknet {\n    // ...\n    \n    #[constructor]\n    fn constructor(ref self: ContractState) {\n        let timestamp = starknet::get_block_timestamp();\n        self.create_time.write(timestamp);\n    }\n}\n\n#[test]\nfn call_and_invoke() {\n    // Declare the contract\n    let class_hash = declare(\"HelloStarknet\");\n    \n    // Prepare contract for deployment\n    let prepared = PreparedContract { class_hash: class_hash, constructor_calldata: @ArrayTrait::new() };\n    \n    // Precalculate the address\n    let contract_address = precalulucate_address(prepared);\n    \n    // Warp the address\n    start_warp(contract_address, 1234);\n    \n    // Deploy with warped constructor\n    let contract_address = deploy(prepared).unwrap();\n    let dispatcher = IHelloStarknetDispatcher { contract_address };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring snforge Settings in Scarb.toml (TOML)\nDESCRIPTION: This code snippet shows how to configure `snforge` settings directly in the `Scarb.toml` file.  This allows for setting options like `exit_first` without needing to pass them via the command line.  `snforge` automatically searches for `Scarb.toml` in the current or parent directories.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/projects/configuration.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n# ...\n[tool.snforge]\nexit_first = true\n# ...\n```\n\n----------------------------------------\n\nTITLE: Calling a Contract Function with sncast\nDESCRIPTION: This command calls a function on a deployed contract without requiring a signing account. It uses the `sncast call` command, specifying the contract address, the function name, the arguments, and the network. This requires the contract address of a deployed contract and `sncast` to be installed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/101.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast call   --contract-address 0x00cd8f9ab31324bb93251837e4efb4223ee195454f6304fcfcb277e277653008   --function get   --arguments '0x123'   --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Using a Contract in a Test (Cairo)\nDESCRIPTION: This code snippet demonstrates how to create a test that uses a contract defined with a conditional compilation feature. The test interacts with the contract, validating its behavior. Prerequisites include the contract itself and a correctly configured Scarb.toml file with the relevant feature declared.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/conditional-compilation.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/conditional_compilation/tests/test.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Configuring Starknet Contract Build Target in TOML\nDESCRIPTION: Specifies the [[target.starknet-contract]] section used to configure Starknet contract artifact generation. Options include enabling Sierra contract class generation ('sierra = true'), and optionally enabling CASM generation ('casm = true'), although CASM generation is discouraged to avoid redundant recompilation overhead. The 'build-external-contracts' field lists external dependency contracts to include during testing, facilitating reuse of external code. This section controls contract compilation targets with precision.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[[target.starknet-contract]]\nsierra = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[[target.starknet-contract]]\ncasm = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[[target.starknet-contract]]\nbuild-external-contracts = [\"openzeppelin::account::account::Account\"]\n```\n\n----------------------------------------\n\nTITLE: Simplified Contract Deployment without Address Precalculation in Cairo\nDESCRIPTION: This snippet shows the typical deployment flow in Starknet Foundry's Cairo test environment when prior knowledge of the contract address is not needed. It declares the contract, prepares a deployment struct, deploys it in one step, and instantiates a dispatcher for invoking methods. Dependencies include the `declare` and `deploy` cheatcodes and a basic dispatcher pattern. Input parameters include the contract name and constructor calldata, with the output being a contract ready for interaction.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/prepare_cheatcode.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n#[test]\nfn call_and_invoke() {\n    // Declare the contract\n    let class_hash = declare(\"HelloStarknet\");\n    \n    // Prepare contract for deployment\n    let prepared = PreparedContract { class_hash: class_hash, constructor_calldata: @ArrayTrait::new() };\n        \n    // Deploy\n    let contract_address = deploy(prepared).unwrap();\n    let dispatcher = IHelloStarknetDispatcher { contract_address };\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting PowerShell Execution Policy - PowerShell\nDESCRIPTION: Changes the PowerShell execution policy for the current user to `RemoteSigned`. This may be required to allow the execution of the completion script generated and invoked from the profile.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_8\n\nLANGUAGE: PowerShell\nCODE:\n```\nSet-ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n\n----------------------------------------\n\nTITLE: Replacing Contract Bytecode in Starknet with Rust\nDESCRIPTION: Defines a function to replace the class hash of a given contract address with a new class hash in Starknet. The new class hash must be declared beforehand to ensure that the contract can execute code correctly after replacement. The function returns a Result with Ok on success or a ReplaceBytecodeError enum variant describing failure reasons such as undeployed contract or undeclared class hash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/replace_bytecode.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn replace_bytecode(contract: ContractAddress, new_class: ClassHash) -> Result<(), ReplaceBytecodeError>\n\npub enum ReplaceBytecodeError {\n    /// Means that the contract does not exist, and thus bytecode cannot be replaced\n    ContractNotDeployed,\n    /// Means that the given class for replacement is not declared\n    UndeclaredClassHash,\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Caller Address with cheat_caller_address in Rust\nDESCRIPTION: This function changes the caller address for a given target smart contract within a specified span in a Starknet Foundry test. Dependencies include use of Starknet Foundry cheatcode interfaces and types such as ContractAddress and CheatSpan. Inputs are the target contract address, the new caller address, and a span object specifying which function calls are affected; there is no direct output except for the altered call context. Requires that cheatcode infrastructure is enabled for the testing scenario.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/caller_address.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn cheat_caller_address(target: ContractAddress, caller_address: ContractAddress, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Starting global max_fee cheatcode Syntax\nDESCRIPTION: This function initiates a global change to the transaction maximum fee, affecting all subsequent transactions until stopped. It requires the new maximum fee value as a u128 integer.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/max_fee.md#_snippet_1\n\nLANGUAGE: Syntax\nCODE:\n```\nfn start_cheat_max_fee_global(max_fee: u128)\n```\n\n----------------------------------------\n\nTITLE: Using Fee Setting Methods in Cast Scripts\nDESCRIPTION: Highlights the addition of methods (`max_fee()`, `resource_bounds()`, `estimate()`) to the `FeeSettingsTrait` in the `sncast_std` library. These methods are used within Cairo deployment scripts to programmatically define transaction fee parameters, enhancing script flexibility for setting gas limits and prices.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nFeeSettingsTrait methods: max_fee(), resource_bounds(), estimate()\n```\n\n----------------------------------------\n\nTITLE: Handling ByteArray Panics with SafeDispatcher (Cairo)\nDESCRIPTION: Illustrates using `SafeDispatcher` to handle panics that use a `ByteArray` argument, common with `assert!` or `panic!` macros. The example shows deserializing the `panic_data` from the `Result::Err` to assert the specific error message.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_12\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_smart_contracts_handling_errors/tests/handle_panic.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Displaying Detailed Resources for snforge Tests (Shell)\nDESCRIPTION: Executes the test suite and provides a detailed breakdown of resources consumed by each test using the `--detailed-resources` flag. This includes steps, memory holes, builtins (like `range_check`, `pedersen`), and syscalls (`CallContract`, `StorageRead`, etc.). This is crucial for understanding the computational cost and optimizing Cairo/Starknet code.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/running-tests.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --detailed-resources\n```\n\n----------------------------------------\n\nTITLE: Checking version of snforge CLI\nDESCRIPTION: This command is used to display the installed version of the `snforge` command-line tool. It helps users confirm they are using the expected version before running other commands.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsnforge --version\n```\n\n----------------------------------------\n\nTITLE: Defining EventsFilterTrait - Rust\nDESCRIPTION: Defines the `EventsFilterTrait`, which provides a function to filter events by contract address. The `emitted_by` function takes an `Events` instance and a `ContractAddress` as input, and returns a new `Events` instance containing only the events emitted by the specified contract address.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_events.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\ntrait EventsFilterTrait {\n    fn emitted_by(self: @Events, contract_address: ContractAddress) -> Events;\n}\n```\n\n----------------------------------------\n\nTITLE: Running sncast Command with Subcommands in Shell\nDESCRIPTION: Shows the basic invocation pattern of the sncast CLI tool where a subcommand is passed as an argument. This snippet demonstrates the general usage format to execute various Starknet RPC-related operations. It is expected to be run in a shell environment where sncast is accessible as a command.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/sncast-overview.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast <subcommand>\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in StarkNet Scripts Using Rust Result Types\nDESCRIPTION: This Rust snippet demonstrates error handling mechanisms in StarkNet deployment and interaction scripts. The 'declare', 'deploy', 'invoke', and 'call' functions return 'Result<T, ScriptCommandError>', allowing programmatic error handling. Errors implement the 'Debug' trait for printing. The example uses Rust's 'assert!' and 'println!' macros to assert and output errors, providing robust script resilience.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/error_handling/src/error_handling.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Starknet Smart Contract for Testing (Cairo)\nDESCRIPTION: Defines a basic Starknet smart contract named `SimpleContract` in Cairo. This contract includes simple storage variables and functions, serving as an example for demonstrating testing procedures. The module name (`SimpleContract`) is used as the contract identifier in tests.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_smart_contracts_writing_tests/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Globally Modifying Nonce Data Availability Mode (Rust)\nDESCRIPTION: The start_cheat_nonce_data_availability_mode_global function enables modification of the nonce data availability mode for all contract targets globally. This function accepts a single parameter, a u32 specifying the desired nonce data availability mode. Dependencies include the StarkNet cheat engine and related types. It is used to simulate network-wide changes and is typically called prior to executing transactions that require a uniform nonce data mode. Output is a system-wide override for nonce data availability mode until cancelled. Must be later stopped explicitly.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce_data_availability_mode.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_nonce_data_availability_mode_global(nonce_data_availability_mode: u32)\n```\n\n----------------------------------------\n\nTITLE: Example Transactional Test in Proposed Cairo Framework\nDESCRIPTION: Illustrates a sample transactional test function written in a proposed Cairo-based syntax. It demonstrates deploying accounts and contracts, creating and signing a transaction, sending it to a devnet environment (specified via attribute), handling the transaction status (accepted/rejected), interacting with deployed contracts (`call`), making assertions, and using environment-specific features like setting time (`set_time`) and dumping state (`dump`). Assumes hypothetical standard and devnet libraries (`xxx_std`, `xxx_devnet_extras`).\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/transactional_testing/transactional_testing.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nfrom xxx_std import {deploy_account, deploy_contracts, end_txn, call, stark_curve, Transaction, TransactionStatus, Calldata, Call};  \nfrom xxx_devnet_extras import {set_time, dump};\n\nconst PREFUNDED_ADDRESS = 0x31231; // Set by the user, or generated inside the test\n\n#[devnet_test(url=localhost:3000)]\nfn test_signature_validation() {\n    let account_contract = deploy_account(\"OZAccount\", PREFUNDED_ADDRESS, );\n    let mock_contract = deploy_contract(\"MockContract\"); // The one that account is calling\n\n    let txn = Transaction(\n        version=2,      // Different versions could be supported\n        address=account_contract.address,\n        function=\"__execute__\", \n        calldata=Calldata::from_calls(array![Call(...), Call(...)])),\n        max_fee=100000,\n    );\n    \n    let signed_txn = stark_curve::sign(txn); // This would also be pluggable, for users to be able to sign with different curves\n    \n    set_time(123); // Set time for txn\n    let result = send_txn(signed_txn); // Synchronous\n    match result {\n        TransactionStatus::Rejected(data) => { /* assert failure data or gas */ },\n        TransactionStatus::Accepted(data) => { /* assert result data  or gas */ }\n    };\n    \n    let account_balance = call(\n        address=mock_contract.address, \n        function=\"get_balance\",\n        calldata=Calldata::from_calls(array![Call(...), Call(...)])\n    );\n    \n    assert(account_balance > ..., \"not correct balance\");\n    dump(); // Dump can be used for pre-populating your test environment\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EventSpy Struct - Rust\nDESCRIPTION: Defines the `EventSpy` struct. This struct likely holds the state necessary to track and retrieve events emitted after its instantiation. The internal fields of the struct are not shown in the provided snippet but are crucial to its functionality.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_events.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nstruct EventSpy {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Starknet Account with sncast (Shell)\nDESCRIPTION: This shell snippet demonstrates the use of the `sncast` command-line tool to create a new Starknet account. It specifies the `sepolia` network and assigns the name `my_first_account` to the new account. The accompanying configuration comment indicates this snippet is intended to be run within the context of the `hello_starknet` package and its output should be ignored during documentation processing.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/shell-snippets.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n    account create \\\n    --network sepolia \\\n    --name my_first_account\n```\n\n----------------------------------------\n\nTITLE: Setting Global Block Number Using Starknet Foundry Cheatcode (Rust)\nDESCRIPTION: The 'start_cheat_block_number_global' function changes the block number for all contract addresses globally within the test environment. It takes a single u64 parameter indicating the desired block number. This function is essential for scenarios where a uniform block number is required for all targets, and operates at a higher scope than individual cheats.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_number.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_block_number_global(block_number: u64)\n```\n\n----------------------------------------\n\nTITLE: Loading Contract Storage in Foundry-rs (Rust)\nDESCRIPTION: The `load` function retrieves data from a specified StarkNet contract's storage. It takes the contract address (`target`), the storage address (`storage_address`) to start reading from, and the number of felts to read (`size`). The function's output is an array of felts representing the data loaded from the contract's storage. This function is a part of the Foundry-rs framework for interacting with StarkNet contracts. It's important to note that the `felt252` data type is a specific type for representing field elements.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/load.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn load(target: ContractAddress, storage_address: felt252, size: felt252) -> Array<felt252> \n```\n\n----------------------------------------\n\nTITLE: Defining the MessagesToL1 Wrapper Struct in Rust\nDESCRIPTION: Defines the `MessagesToL1` struct, which acts as a wrapper around an array of L1 messages. This structure holds tuples of `(l2_sender_address, message)` and is designed to facilitate smooth filtering operations on collected messages.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_messages_to_l1.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct MessagesToL1 {\n    messages: Array<(ContractAddress, MessageToL1)>\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Gas Limits with `#[available_gas]` in Rust\nDESCRIPTION: The `#[available_gas]` attribute sets gas limits for a test case. If the test exceeds the specified limit for L1 gas, L1 data gas, L2 gas, or an overall limit, the test fails. Limits for specific gas types or an overall limit can be provided.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-attributes.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[available_gas(l2_gas: 5)]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[available_gas(l1_gas: 5, l1_data_gas: 5, l2_gas: 5)]\n```\n\nLANGUAGE: Rust\nCODE:\n```\n#[available_gas(5)]\n```\n\n----------------------------------------\n\nTITLE: Defining the `get_call_trace` Function Signature in Rust\nDESCRIPTION: Declares the `get_call_trace` function which returns a `CallTrace` object. This object represents the nested execution trace of contract interactions within a StarkNet Foundry test up to the point of the call. The full `CallTrace` structure definition is available in the `snforge-std` source code.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/get_call_trace.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn get_call_trace() -> CallTrace;\n```\n\n----------------------------------------\n\nTITLE: Mocking a Starknet Contract Call Indefinitely (Rust)\nDESCRIPTION: The `start_mock_call` cheatcode mocks calls to a specified `function_selector` on a given `contract_address` indefinitely. Subsequent calls to this entry point will always return the provided `ret_data` until stopped. Similar to `mock_call`, it works for non-existent contracts/entry points and only mocks external calls. The return data type `T` requires `Serde` and `Destruct` implementations.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/mock_call.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_mock_call<T, impl TSerde: serde::Serde<T>, impl TDestruct: Destruct<T>>(\n  contract_address: ContractAddress, function_selector: felt252, ret_data: T\n)\n```\n\n----------------------------------------\n\nTITLE: Defining sncast Profiles in snfoundry.toml (TOML)\nDESCRIPTION: This code snippet demonstrates how to define profiles for `sncast` within the `snfoundry.toml` file.  A profile contains configurations for interacting with a Starknet network, such as the account, accounts file, and RPC URL. This removes the need to supply these parameters via the command line.  The profile can then be specified using the `--profile` argument.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/projects/configuration.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n# ...\n[sncast.myprofile]\naccount = \"user\"\naccounts-file = \"~/my_accounts.json\"\nurl = \"http://127.0.0.1:5050/rpc\"\n# ...\n```\n\n----------------------------------------\n\nTITLE: Stopping Caller Address Modification with stop_cheat_caller_address in Rust\nDESCRIPTION: This function cancels any prior caller address changes for a given contract target that were made using cheat_caller_address or start_cheat_caller_address. It accepts the target contract address and restores default caller address behavior for that contract. This ensures cleanup and test isolation, and relies on the Starknet cheatcode control.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/caller_address.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_caller_address(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Deleting Local Starknet Account Info with sncast\nDESCRIPTION: This command removes the specified account's information from the local accounts file and its associated Scarb profile. It requires the account name and the network it belongs to. Note that this operation only affects local storage and does not remove the account from the Starknet blockchain.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nsncast account delete \\\n    --name new_account \\\n    --network-name alpha-sepolia\n```\n\n----------------------------------------\n\nTITLE: Globally Changing Caller Address with start_cheat_caller_address_global in Rust\nDESCRIPTION: This function applies a new caller address to all targets under test in the current Starknet Foundry environment. It takes a single ContractAddress input and maintains this as the caller context until stopped. This cheatcode is used to simplify test scenarios where a uniform caller identity is required for all contract interactions; interaction with the Foundry cheat infrastructure is required.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/caller_address.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_caller_address_global(caller_address: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Running Fuzz Tests with snforge\nDESCRIPTION: This shell command executes the `snforge test` command to run fuzz tests.  This command initiates the test execution process within the snforge environment, using the default configuration or any command-line arguments provided.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fuzz-testing.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ snforge test\n```\n\n----------------------------------------\n\nTITLE: Writing Standard Tests for Smart Contract State - Cairo\nDESCRIPTION: This Cairo snippet depicts a standard test file, usually defining tests that interact with the contract's functionality (such as increasing a balance) and assert expected outcomes. Dependencies include the declared test contract, test macro infrastructure, and, if used, assertion macros. This baseline helps illustrate scenarios where default blockchain state prevents a test from passing  setting the stage for introducing cheatcodes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/using_cheatcodes/tests/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Setting Transaction Nonce for a Specific Target (Rust)\nDESCRIPTION: Sets the transaction nonce for a specific contract address (`target`) to the specified value (`nonce`). This modification persists until explicitly stopped for that target using `stop_cheat_nonce`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_nonce(target: ContractAddress, nonce: felt252)\n```\n\n----------------------------------------\n\nTITLE: Adding snforge_std dependency in Scarb.toml - TOML\nDESCRIPTION: This code snippet demonstrates how to specify the 'snforge_std' package as a development dependency in your Scarb.toml, which is required for leveraging cheatcodes in your testing environment. The dependency must be under the [dev-dependencies] section and the correct, compatible version should be supplied. No Cairo or Rust code is needed, but this configuration is a prerequisite for all following cheatcode-powered tests.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dev-dependencies]\nsnforge_std = \"0.33.0\"\n```\n\n----------------------------------------\n\nTITLE: Modifying Nonce Data Availability Mode for Single Target (Rust)\nDESCRIPTION: start_cheat_nonce_data_availability_mode modifies the nonce data availability mode for a single contract target. It requires a ContractAddress and a u32 nonce data availability mode parameter. Meant for test harnesses or debugging specific contract interactions. The function applies the cheat to the designated contract, impacting only its subsequent transactions until stopped or overridden. Must be called before operations that need an alternative nonce data availability configuration for the target.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce_data_availability_mode.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_nonce_data_availability_mode(target: ContractAddress, nonce_data_availability_mode: u32)\n```\n\n----------------------------------------\n\nTITLE: Declaring Contracts with `declare` Function in Cairo\nDESCRIPTION: The `declare` function declares a contract. It takes `contract_name` (the name of the contract as a Cairo string), `fee_settings`, and an optional `nonce`. The function returns a `DeclareResult`. The code snippet demonstrates the function signature and includes a Cairo implementation.  Dependencies include the `ByteArray`, `FeeSettings`, and `Option<felt252>` types. Expected inputs are the contract name, fee settings, and optionally, a nonce. The output is a `DeclareResult` that can be either `Success` or `AlreadyDeclared`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/declare.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Gas Estimation for Single Test Using snforge CLI in Shell\nDESCRIPTION: Shows the output format when running a single test case using snforge. It reports gas estimates for layer 1 gas, layer 1 data gas, and layer 2 gas based on VM resource usage, contract deployments, storage updates, events, and inter-layer messages. The snippet exemplifies how a passing test outputs approximate resource costs.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/gas-and-resource-estimation.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n[PASS] tests::simple_test (l1_gas: ~1, l1_data_gas: ~1, l2_gas: ~1)\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Caller Address Modification with stop_cheat_caller_address_global in Rust\nDESCRIPTION: This function reverts the global caller address change initialized by start_cheat_caller_address_global, applying default caller behavior to all future contract calls. It requires no parameters and should be invoked for proper teardown of test environments that modify caller identity globally. Relies on Starknet Foundry testing infrastructure.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/caller_address.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_caller_address_global()\n```\n\n----------------------------------------\n\nTITLE: Running Deployment Scripts with sncast Command - Bash\nDESCRIPTION: Demonstrates how to run a compiled Cairo deployment script on the Starknet chain using the `sncast` CLI tool. The snippet exemplifies invoking the `script` subcommand with the path to the script file. This assumes sncast is installed and properly configured to interact with Starknet nodes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/cairo_deployment_scripts.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sncast script /path/to/myscript.s.cairo\n```\n\n----------------------------------------\n\nTITLE: Stopping Specific Paymaster Data Cheat - Starknet Foundry Cairo\nDESCRIPTION: Cancels any active `cheat_paymaster_data` or `start_cheat_paymaster_data` overrides that were previously set for the specified `target` contract address. This restores the default transaction paymaster data behavior for that contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/paymaster_data.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\nfn stop_cheat_paymaster_data(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Setting RPC Provider URL - TOML\nDESCRIPTION: This TOML snippet configures the RPC provider URL for the `myprofile` profile. The `url` field specifies the address to which sncast will send RPC requests. This is essential for interacting with the StarkNet network or a local development environment. Ensure the URL is valid and points to a reachable RPC endpoint.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\nurl = \"http://example.com\"\n```\n\n----------------------------------------\n\nTITLE: Sending Contract Verification Request via Voyager API Adapter in Rust\nDESCRIPTION: This snippet demonstrates constructing a verification HTTP POST request to the Voyager explorer API using a Rust HTTP client. It builds a JSON payload containing contract metadata and source files, then asynchronously posts it to the explorer. Dependencies include the serde_json crate for JSON serialization and an async HTTP client (such as reqwest). Key parameters are the contract address, class hash, class name, and a collection of source code files mapped by path. Expected input is a filled payload object; output is the verification status printed to stdout. At least one of contract_address or class_hash must be provided.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/contract_verification.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nconst url = `${voyager.testnet.url}/contract/`\n\nconst payload = serde_json::json!({\n        \"contract_address\": \"0x0\", // this is optional if class_hash is provided\n        \"class_hash\": \"0x0\", // this is optional if contract_address is provided\n        \"class_name\": \"balance\",\n        \"source_code\": {\n            \"Scarb.toml\" : {\n                \"\"\"\n                [package]\n                ...\n                [dependencies]\n                starknet = \"2.3.0-rc0\"\n                \"\"\"\n            },\n            \"src/lib.cairo\" : {\n                \"\"\"\n                mod balance;\n                mod forty_two;\n                \"\"\"\n            },\n            \"src/balance.cairo\" : {\n                \"\"\"\n                #[starknet::interface]\n                ...\n                #[starknet::contract]\n                mod Balance {\n                    ...\n                }\n                \"\"\"\n            },\n            \"src/forty_two.cairo\" : {\n                \"\"\"\n                #[starknet::contract]\n                mod FortyTwo {\n                    ...\n                }\n                \"\"\"\n            }\n        }\n    });\n\nconst resp = client\n    .post(url)\n    .json(&payload)\n    .send()\n    .await?;\n\nprintln!(resp.verification_status)\n\n```\n\n----------------------------------------\n\nTITLE: Listing Local Starknet Accounts with sncast\nDESCRIPTION: This command lists all Starknet accounts currently saved in the default local accounts file, grouped by the network they are associated with. It provides details like network, public key, address, deployment status, and account type. Optional flags allow specifying a custom accounts file or displaying private keys.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nsncast account list\n```\n\n----------------------------------------\n\nTITLE: Project Structure Listing for StarkNet Contracts and Scripts in Shell\nDESCRIPTION: This snippet shows the directory tree structure of a Scarb package used for deploying and scripting StarkNet contracts. It illustrates how contracts and scripts are organized across different directories in the project, facilitating modular builds and external contract referencing for deployment scripts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n\n.\n contracts\n     Scarb.toml\n     src\n         lib.cairo\n scripts\n     Scarb.toml\n     src\n         lib.cairo\n         map_script.cairo\n\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Nonce Data Availability Mode Cheat (Rust)\nDESCRIPTION: stop_cheat_nonce_data_availability_mode_global cancels the global override of nonce data availability mode established by start_cheat_nonce_data_availability_mode_global. This parameterless function removes the cheat from all targets, restoring the original data availability mode for transaction nonces across the test system.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce_data_availability_mode.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_nonce_data_availability_mode_global()\n```\n\n----------------------------------------\n\nTITLE: Deploying Starknet Account to Network with sncast\nDESCRIPTION: After creating account information locally and prefunding the generated address with STRK tokens, this command deploys the account contract to the specified Starknet network. It references the account information previously saved using its network and name. The output includes the transaction hash for the deployment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n    account deploy \\\n    --network sepolia \\\n\t--name new_account\n```\n\n----------------------------------------\n\nTITLE: Configuring Scarb.toml for Coverage Support\nDESCRIPTION: Required Cairo compiler configuration in Scarb.toml to enable debug information needed for coverage reporting.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/coverage.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[profile.dev.cairo]\nunstable-add-statements-code-locations-debug-info = true\nunstable-add-statements-functions-debug-info = true\ninlining-strategy = \"avoid\"\n```\n\n----------------------------------------\n\nTITLE: Felt-only storage field access\nDESCRIPTION: This example shows how to directly access and modify a simple felt-only storage field in a Starknet contract using Snforge. It demonstrates writing a value to a specific storage address and then reading it back to verify the operation. Dependencies include Starknet and Snforge.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/direct_storage_access/tests/felts_only/field.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Testing a Panicking Function (Expected Failure) (Cairo)\nDESCRIPTION: Demonstrates a test case that directly calls the `panic_with_felt252` function. Without special handling, calling a panicking function like this will cause the test itself to fail.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_smart_contracts_handling_errors/tests/panic.cairo:first_half}}\n{{#include ../../listings/testing_smart_contracts_handling_errors/tests/panic.cairo:second_half}}\n```\n\n----------------------------------------\n\nTITLE: Updating Universal Sierra Compiler - Shell\nDESCRIPTION: Downloads the installation script for the Universal Sierra Compiler (USC) from the official repository using `curl` and immediately executes it using `sh`. This command performs a manual update or installation of USC.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ncurl -L https://raw.githubusercontent.com/software-mansion/universal-sierra-compiler/master/scripts/install.sh | sh\n```\n\n----------------------------------------\n\nTITLE: Enabling SafeDispatcher Directly Before Usage (Cairo)\nDESCRIPTION: Illustrates applying the `#[feature(\"safe_dispatcher\")]` attribute directly before a specific expression that uses the `SafeDispatcher` functionality.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_15\n\nLANGUAGE: Cairo\nCODE:\n```\n#[feature(\"safe_dispatcher\")]\nlet result = safe_dispatcher.some_function();\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Fee Data Availability Mode - Rust\nDESCRIPTION: This function cancels the global transaction fee data availability mode that was set for all contracts using `start_cheat_fee_data_availability_mode_global`. It takes no parameters and reverts the global fee data availability mode back to its default state, allowing tests to resume normal fee data behavior after global mode manipulations.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/fee_data_availability_mode.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_fee_data_availability_mode_global()\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Account Deployment Data Change in Rust\nDESCRIPTION: Cancels the effect of start_cheat_account_deployment_data_global, reverting to the original account deployment data behavior for all contracts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_deployment_data.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_account_deployment_data_global()\n```\n\n----------------------------------------\n\nTITLE: Stopping max_fee cheat for target cheatcode Syntax\nDESCRIPTION: This function cancels any active max_fee cheatcode effect (like 'cheat_max_fee' or 'start_cheat_max_fee') specifically for the provided contract target. It requires the target contract address.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/max_fee.md#_snippet_3\n\nLANGUAGE: Syntax\nCODE:\n```\nfn stop_cheat_max_fee(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Linting Code with alias\nDESCRIPTION: This command runs Clippy using a predefined alias within the project, simplifying the linting process.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo lint\n```\n\n----------------------------------------\n\nTITLE: Defining Named Fork Configurations in `Scarb.toml`\nDESCRIPTION: Defines reusable fork configurations within the `Scarb.toml` file under the `tool.snforge.fork` table. Each configuration requires a name, URL, and block identifier (tag, number, or hash).\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-attributes.md#_snippet_3\n\nLANGUAGE: TOML\nCODE:\n```\n[[tool.snforge.fork]]\nname = \"TESTNET\"\nurl = \"http://your.rpc.url\"\nblock_id.tag = \"latest\"\n```\n\n----------------------------------------\n\nTITLE: Setting Transaction Wait Parameters - TOML\nDESCRIPTION: This TOML snippet configures waiting parameters for transactions. The `wait-params` field allows defining custom values for the timeout and retry-interval.  The timeout sets the maximum time (in seconds) to wait for a transaction confirmation, and retry-interval controls how often (in seconds) sncast will check for transaction confirmation.  If not specified, default values of `timeout = 300` and `retry-interval = 5` will be used.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\nwait-params = { timeout = 300, retry-interval = 5 }\n```\n\n----------------------------------------\n\nTITLE: Defining Transaction Status Structures in Rust for Starknet Queries\nDESCRIPTION: Provides Rust enum and struct definitions used to represent the possible status values for Starknet transaction queries. FinalityStatus and ExecutionStatus enums enumerate the potential state and result of a transaction, such as Received or Succeeded, with TxStatusResult acting as a wrapper struct returned by status queries. All types include standard trait derivations for Serde serialization/deserialization and partial equality checks, and require the Serde and Drop traits. These types must match the Starknet node's response schema for correct deserialization.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/tx_status.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Drop, Clone, Debug, Serde, PartialEq)]\npub enum FinalityStatus {\n    Received,\n    Rejected,\n    AcceptedOnL2,\n    AcceptedOnL1\n}\n\n#[derive(Drop, Copy, Debug, Serde, PartialEq)]\npub enum ExecutionStatus {\n    Succeeded,\n    Reverted,\n}\n\n#[derive(Drop, Clone, Debug, Serde, PartialEq)]\npub struct TxStatusResult {\n    pub finality_status: FinalityStatus,\n    pub execution_status: Option<ExecutionStatus>\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example snforge Output with SafeDispatcher Test Passing (Shell)\nDESCRIPTION: Sample output from `snforge test` showing that the test utilizing `SafeDispatcher` to correctly handle and assert the panic now passes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\nCollected 1 test(s) from testing_smart_contracts_safe_dispatcher package\nRunning 0 test(s) from src/\nRunning 1 test(s) from tests/\n[PASS] testing_smart_contracts_safe_dispatcher_integrationtest::safe_dispatcher::handling_errors (l1_gas: ~0, l1_data_gas: ~96, l2_gas: ~280000)\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Fork Testing with Block Tag - Cairo\nDESCRIPTION: This code demonstrates how to perform a fork test by specifying the RPC URL and a specific block tag (e.g., `latest`) in the `#[fork(...)]` attribute. It obtains a dispatcher, instantiates it with a real contract address from the forked state, calls a method to modify the contract's state, and then asserts the changed state.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fork-testing.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fork_testing/tests/explicit/block_tag.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Run a Deployment Script on Sepolia Network Using sncast - Shell\nDESCRIPTION: Shell command demonstrating how to execute a previously created Cairo deployment script named 'my_script' via sncast CLI on the Sepolia Starknet testnet. The command `sncast script run` triggers the script's main function and uses the network flag to specify the target blockchain environment. It expects the script package to be present and dependencies resolved, optionally using a state file for idempotency. Output includes the result of contract interactions such as call results and status messages.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ sncast \\n  script run my_script\\n  --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Calling a Starknet Contract at a Specific Block\nDESCRIPTION: Example of calling a contract function on the Sepolia network at a specific block height. This demonstrates how to use the '--block-id' parameter to query historical contract state.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/call.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsncast call \\\n  --network sepolia \\\n  --contract-address 0x522dc7cbe288037382a02569af5a4169531053d284193623948eac8dd051716 \\\n  --function \"balance_of\" \\\n  --arguments '0x0554d15a839f0241ba465bb176d231730c01cf89cdcb95fe896c51d4a6f4bb8f' \\\n  --block-id 77864\n```\n\n----------------------------------------\n\nTITLE: Using cheat_caller_address with CheatSpan::TargetCalls - Cairo\nDESCRIPTION: This Cairo code shows a typical invocation of cheat_caller_address with the CheatSpan::TargetCalls enum, limiting the cheat to N subsequent contract calls. Proper application of this parameter enables automatic deactivation after the set number of calls, supporting precise, revertible test state behavior. Both contract address and caller address must be provided, along with the chosen span.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\ncheat_caller_address(contract_address, new_caller_address, CheatSpan::TargetCalls(1))\n```\n\n----------------------------------------\n\nTITLE: Stopping signature cheat for target - Starknet Foundry Rust\nDESCRIPTION: This cheatcode cancels any active signature cheat (either `cheat_signature` or `start_cheat_signature`) that was previously applied to the specified contract address (`target`). It requires the target contract address to identify which cheat to stop.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/signature.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_signature(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Enabling SafeDispatcher at Function Level (Cairo)\nDESCRIPTION: Demonstrates enabling the `SafeDispatcher` feature gate specifically for a single Cairo function using the `#[feature(\"safe_dispatcher\")]` attribute.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_14\n\nLANGUAGE: Cairo\nCODE:\n```\n#[feature(\"safe_dispatcher\")]\nfn my_function() { ... }\n```\n\n----------------------------------------\n\nTITLE: Example Scarb Package Configuration for Cairo Deployment Script - TOML\nDESCRIPTION: TOML snippet defining a Scarb package configuration for a Cairo deployment script named 'my_script'. It specifies package version and necessary dependencies on 'starknet' version >= 2.8.0 and 'sncast_std' 0.33.0 or higher. This configuration is required for building and running the deployment script within a Scarbs workspace, ensuring proper linking to the Starknet and sncast standard libraries. It influences the compilation and runtime behavior of scripts relying on Starknet Foundry tooling.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_3\n\nLANGUAGE: TOML\nCODE:\n```\n[package]\\nname = \"my_script\"\\nversion = \"0.1.0\"\\n\\n[dependencies]\\nstarknet = \">=2.8.0\"\\nsncast_std = \"0.33.0\"\n```\n\n----------------------------------------\n\nTITLE: Testing storage of CustomStruct with store/load\nDESCRIPTION: This test case demonstrates storing and loading a `CustomStruct` into the contract's storage.  It deploys the `HelloStarknet` contract, gets the address of the `custom_struct` storage variable, stores a `CustomStruct` value, loads the stored value, and asserts that the `a` and `b` fields of the loaded struct match the stored values. It relies on `contract_state_for_testing` and the `store` and `load` cheatcodes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/store_load_cheatcodes.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n#[test]\nfn test_custom_struct() {\n    let contract_address = deploy_hello_contract();\n    let state = HelloStarknet::contract_state_for_testing();\n    \n    \n    let a = 420;\n    let b = 69;\n    let value = CustomStruct {a, b};\n    let variable_address = state.custom_struct.address();\n    \n    store::<CustomStruct>(contract_address, variable_address, value);\n    let stored_value = load::<CustomStruct>(contract_address, variable_address);\n    \n    assert(stored_value.a == 420, 'Wrong custom_struct.a stored');\n    assert(stored_value.b == 69, 'Wrong custom_struct.a stored');   \n}\n```\n\n----------------------------------------\n\nTITLE: Executing Tests with a Panicking Function Call (Shell)\nDESCRIPTION: Shows the command to run the snforge test suite again after adding a test that calls a panicking function without handling.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ snforge test\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Coverage Report from LCOV Data\nDESCRIPTION: Shell command to convert the generated LCOV coverage data into an HTML report using genhtml tool.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/coverage.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ genhtml -o coverage_report coverage.lcov\n```\n\n----------------------------------------\n\nTITLE: Deploying Starknet Contract with Custom Salt using sncast Shell\nDESCRIPTION: Deploys a Starknet contract and specifies a custom `salt` value using the `--salt` parameter. The salt is used in the Universal Deployer Contract (UDC) logic to modify the calculation of the final contract address. If not provided, a salt is automatically generated. Outputs the deployed contract address and transaction hash.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/deploy.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast deploy \\\n    --class-hash 0x0227f52a4d2138816edf8231980d5f9e6e0c8a3deab45b601a1fcee3d4427b02 \\\n    --salt 0x123\n```\n\n----------------------------------------\n\nTITLE: Fork Testing with Block Hash - Cairo\nDESCRIPTION: This code demonstrates how to perform a fork test by specifying the RPC URL and a specific block hash in the `#[fork(...)]` attribute.  It obtains a dispatcher, instantiates it with a real contract address from the forked state, calls a method to modify the contract's state, and then asserts the changed state.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fork-testing.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fork_testing/tests/explicit/block_hash.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Modifying Block Timestamp for a Target\nDESCRIPTION: The `cheat_block_timestamp` function modifies the block timestamp for a specific contract (`target`) within a given span. It takes the contract address, the desired block timestamp (`u64`), and a `CheatSpan` to define the duration or context of the cheat. It requires the `ContractAddress` type and assumes the presence of a `CheatSpan` struct, likely representing the scope or life cycle of the cheat.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_timestamp.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_block_timestamp(target: ContractAddress, block_timestamp: u64, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Serving mdBook with Live Reload\nDESCRIPTION: This command serves the mdBook locally and automatically reloads the browser whenever changes are made to the source files. This is useful for previewing the book during development.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ mdbook serve\n```\n\n----------------------------------------\n\nTITLE: Running snforge Tests with Detailed VM Resources Estimation in Shell\nDESCRIPTION: Shows how to invoke the snforge test command with the --detailed-resources flag to enable detailed VM resource tracking. The output includes per-test resource usage such as steps executed, memory holes, counts of builtins (e.g., range_check, pedersen) and syscalls performed. This data provides an in-depth view into the VM execution characteristics underlying gas estimations.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/gas-and-resource-estimation.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --detailed-resources\n\nCollected 2 test(s) from hello_starknet package\nRunning 2 test(s) from tests/\n[PASS] hello_starknet_integrationtest::test_contract::test_cannot_increase_balance_with_zero_value (l1_gas: ~0, l1_data_gas: ~96, l2_gas: ~360000)\n        steps: 3405\n        memory holes: 22\n        builtins: (range_check: 77, pedersen: 7)\n        syscalls: (CallContract: 2, StorageRead: 1, Deploy: 1)\n\n[PASS] hello_starknet_integrationtest::test_contract::test_increase_balance (l1_gas: ~0, l1_data_gas: ~192, l2_gas: ~480000)\n        steps: 4535\n        memory holes: 15\n        builtins: (range_check: 95, pedersen: 7)\n        syscalls: (CallContract: 3, StorageRead: 3, Deploy: 1, StorageWrite: 1)\n\nRunning 0 test(s) from src/\nTests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Using the profile flag with sncast\nDESCRIPTION: Flag for specifying a profile name used for both snfoundry.toml and Scarb.toml configuration files. Defaults to 'default' for snfoundry.toml and 'dev' for Scarb.toml.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n--profile, -p <PROFILE_NAME>\n```\n\n----------------------------------------\n\nTITLE: Using Named Fork Configurations with `#[fork]` in Rust\nDESCRIPTION: Applies a predefined fork configuration from `Scarb.toml` to a test case by referencing its name within the `#[fork]` attribute. This avoids repeating URL and block details.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-attributes.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n#[fork(\"TESTNET\")] \n```\n\n----------------------------------------\n\nTITLE: Testing storage of felt252 with store/load\nDESCRIPTION: This test case demonstrates storing and loading a `felt252` value directly into the contract's storage using the `store` and `load` cheatcodes.  It deploys the `HelloStarknet` contract, gets the address of the `balance` variable, stores a new value, loads the stored value, and asserts that the stored value is equal to the new value. It uses the `contract_state_for_testing` to obtain the address of the storage variable.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/store_load_cheatcodes.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\nuse array::ArrayTrait;\nuse result::ResultTrait;\nuse option::OptionTrait;\nuse traits::TryInto;\nuse starknet::ContractAddress;\nuse starknet::Felt252TryIntoContractAddress;\n\nuse snforge_std::{ declare, ContractClassTrait, store, load };\n\nuse pkg::HelloStarknet;\nuse pkg::HelloStarknet::{balanceContractMemberStateTrait, CustomStruct};\n\nfn deploy_hello_contract() -> ContractAddress {\n    let contract_class = declare(\"HelloStarknet\");\n    contract_class.deploy(@array![]).unwrap()\n}\n\n#[test]\nfn test_felt252() {\n    let contract_address = deploy_hello_contract();\n    let state = HelloStarknet::contract_state_for_testing();\n    let variable_address = state.balance.address();\n    \n    let new_balance = 420;\n    store::<felt252>(contract_address, variable_address, new_balance);\n    let stored_value = load::<felt252>(contract_address, variable_address);\n    \n    assert(stored_value == 420, 'Wrong balance stored');    \n}\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Transaction Version Modification in Starknet Foundry\nDESCRIPTION: Cancels any active global transaction version modification. Removes the effects of a previous start_cheat_transaction_version_global call across all contracts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_version.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_transaction_version_global()\n```\n\n----------------------------------------\n\nTITLE: Stopping global signature cheat - Starknet Foundry Rust\nDESCRIPTION: This cheatcode cancels the global transaction signature override that was initiated using `start_cheat_signature_global()`. After calling this function, transaction signatures will revert to their normal behavior unless another cheat is active.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/signature.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_signature_global()\n```\n\n----------------------------------------\n\nTITLE: Canceling Sequencer Address Change for Specific Target in Rust\nDESCRIPTION: Stops any active sequencer address modification for the specified contract target. The only parameter is the target's ContractAddress. This function reverts the sequencer address to its original state for that target. It is used to clean up or revert changes made by cheat_sequencer_address or start_cheat_sequencer_address.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/sequencer_address.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_sequencer_address(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Starting Block Timestamp Cheat for Target\nDESCRIPTION: The `start_cheat_block_timestamp` function sets the block timestamp for a specific contract. It takes a `target` contract address and a `block_timestamp` (u64). This function provides a way to simulate the passage of time, or to influence the current time for an individual contract without affecting others.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_timestamp.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_block_timestamp(target: ContractAddress, block_timestamp: u64)\n```\n\n----------------------------------------\n\nTITLE: Globally Modifying Block Timestamp\nDESCRIPTION: The `start_cheat_block_timestamp_global` function alters the block timestamp for all targets. It accepts a `block_timestamp` value of type `u64`. This function is designed to provide a means of setting the timestamp for all contracts deployed or otherwise involved in a specific testing scenario.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_timestamp.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_block_timestamp_global(block_timestamp: u64)\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Block Timestamp Cheat\nDESCRIPTION: The `stop_cheat_block_timestamp_global` function cancels the global block timestamp cheat. This function is designed to revert the state of the blockchain time if modified via `start_cheat_block_timestamp_global` back to its original state or default behavior. It takes no arguments.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_timestamp.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_block_timestamp_global()\n```\n\n----------------------------------------\n\nTITLE: Pass arguments to cairo-profiler through snforge\nDESCRIPTION: This command demonstrates how to pass additional arguments to cairo-profiler when using the `--build-profile` flag in snforge. Arguments after the `--` separator are passed directly to cairo-profiler, allowing customization of the profiling process.  Example show passing `--show-inlined-functions` argument.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/profiling.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --build-profile -- --show-inlined-functions\n```\n\n----------------------------------------\n\nTITLE: Checking version with sncast\nDESCRIPTION: Flag for printing the version of the sncast tool.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n--version, -v\n```\n\n----------------------------------------\n\nTITLE: Defining the `get_class_hash` Cheatcode Function (Rust)\nDESCRIPTION: This Rust function signature defines the `get_class_hash` cheatcode. It accepts a `ContractAddress` representing the target contract's address on Starknet and returns its corresponding `ClassHash`. This cheatcode is primarily used within Starknet Foundry tests to fetch the class hash of a specified contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/get_class_hash.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn get_class_hash(contract_address: ContractAddress) -> ClassHash\n```\n\n----------------------------------------\n\nTITLE: Changing Global Transaction Tip in Rust\nDESCRIPTION: Defines `start_cheat_tip_global` function that changes the transaction tip for all contract targets globally. Takes a 128-bit unsigned integer tip parameter to set a universal tip value during testing or simulation. This function requires no target address, affecting all transactions within the current cheat context.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/tip.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_tip_global(tip: u128)\n```\n\n----------------------------------------\n\nTITLE: Starting Transaction Version Modification for a Target in Starknet Foundry\nDESCRIPTION: Changes the transaction version for a specific contract address. Requires a target contract address and a version value as a felt252, and remains active until explicitly stopped.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_version.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_transaction_version(target: ContractAddress, version: felt252)\n```\n\n----------------------------------------\n\nTITLE: Configuring Scarb to use prebuilt plugins\nDESCRIPTION: Optional Scarb configuration to avoid compiling Cairo plugin locally. This requires Scarb version 2.10.0 or higher and allows using prebuilt plugins for snforge_std.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[tool.scarb]  \nallow-prebuilt-plugins = [\"snforge_std\"]\n```\n\n----------------------------------------\n\nTITLE: Starting signature cheat for target - Starknet Foundry Rust\nDESCRIPTION: This cheatcode applies a transaction signature override specifically for the given contract address (`target`). The cheat affects all subsequent transactions originating from or targeting this address. It requires the target contract address and the new signature as a `Span<felt252>`. This target-specific cheat persists until `stop_cheat_signature` is called for that target.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/signature.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_signature(target: ContractAddress, signature: Span<felt252>)\n```\n\n----------------------------------------\n\nTITLE: Define Starknet Contract with Storage\nDESCRIPTION: Defines a simple Starknet contract named `HelloStarknet` with storage variables including a `felt252` balance, a `LegacyMap`, and a custom struct `CustomStruct`. The `CustomStruct` is defined with two `felt252` fields, `a` and `b`.  This code shows how storage variables are declared in a Starknet contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/store_load_cheatcodes.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n#[starknet::contract]\nmod HelloStarknet {\n    #[derive(starknet::Store)]\n    struct CustomStruct {\n        a: felt252,\n        b: felt252,\n    }\n\n    #[storage]\n    struct Storage {\n        balance: felt252, \n        map: LegacyMap<felt252, felt252>,\n        custom_struct: CustomStruct,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overwrite Existing File with sncast multicall new\nDESCRIPTION: Shell command demonstrating the use of the `--overwrite` flag with `sncast multicall new`. This option allows the command to forcefully overwrite an existing file at the specified path (`./template.toml`) with the newly generated template.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/multicall.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast multicall new ./template.toml --overwrite\n```\n\n----------------------------------------\n\nTITLE: Applying Paymaster Data Cheat for Span - Starknet Foundry Cairo\nDESCRIPTION: Applies a specific `paymaster_data` value to a given `target` contract address. This cheat is active only for a limited duration defined by the `span`. Requires specifying the contract address, the data span, and the cheat's active span.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/paymaster_data.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn cheat_paymaster_data(target: ContractAddress, paymaster_data: Span<felt252>, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Enabling and Viewing Backtraces in snforge Tests (Shell)\nDESCRIPTION: This shell command demonstrates how to enable the backtrace feature by setting the `SNFORGE_BACKTRACE=1` environment variable before running `snforge test`. The output includes the original failure data along with detailed stack backtraces for each contract involved (e.g., 'InnerContract', 'OuterContract'), showing the function call sequence (e.g., `inner_call`, `inner`, `outer`) and the specific file paths and line numbers leading to the error.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/backtrace.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ SNFORGE_BACKTRACE=1 snforge test\n```\n\nLANGUAGE: shell\nCODE:\n```\nFailure data:\n    (0x454e545259504f494e545f4e4f545f464f554e44 ('ENTRYPOINT_NOT_FOUND'), 0x454e545259504f494e545f4641494c4544 ('ENTRYPOINT_FAILED'))\n    \nError occurred in contract 'InnerContract' at pc: '72'\nStack backtrace:\n   0: backtrace_vm_error::InnerContract::inner_call\n       at [..]/src/lib.cairo:47:9\n   1: backtrace_vm_error::InnerContract::InnerContract::inner\n       at [..]/src/lib.cairo:38:13\n   2: backtrace_vm_error::InnerContract::__wrapper__InnerContract__inner\n       at [..]/src/lib.cairo:37:9\n\nError occurred in contract 'OuterContract' at pc: '107'\nStack backtrace:\n   0: backtrace_vm_error::IInnerContractDispatcherImpl::inner\n       at [..]/src/lib.cairo:22:1\n   1: backtrace_vm_error::OuterContract::OuterContract::outer\n       at [..]/src/lib.cairo:17:13\n   2: backtrace_vm_error::OuterContract::__wrapper__OuterContract__outer\n       at [..]/src/lib.cairo:15:9\n```\n\n----------------------------------------\n\nTITLE: Setting Global Transaction Nonce (Rust)\nDESCRIPTION: Sets the transaction nonce globally to the specified value (`nonce`) for all contract interactions until explicitly stopped using `stop_cheat_nonce_global`. Affects all subsequent transactions regardless of the target contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_nonce_global(nonce: felt252)\n```\n\n----------------------------------------\n\nTITLE: Changing Transaction Tip for Target and Span in Rust\nDESCRIPTION: Defines a function `cheat_tip` that modifies the transaction tip for a specific contract address (`target`) and span (`span`). Requires a `ContractAddress` and a 128-bit unsigned integer tip value. It is used to simulate or test altered transaction fees for a targeted contract in a given execution span.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/tip.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn cheat_tip(target: ContractAddress, tip: u128, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Example State File (JSON)\nDESCRIPTION: This JSON snippet illustrates the structure of a state file used to track transactions executed by the scripts.  The file maintains information about the script's execution, including the function name, parameters, output, status, and timestamp of each transaction.  This enables features such as transaction verification, retries, and replay.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/cairo_deployment_scripts.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": 1,\n  \"transactions\" : {\n    \"<create_account_id>\": {\n      \"name\": \"create_account\",\n      \"arguments\": {\n        \"name\": \"whatever\",\n        (...)\n      },\n      \"output\": {\n        \"address\": \"0x123\",\n        \"max_fee\": \"0x321\"\n      },\n      \"status\": \"accepted\",\n      \"timestamp\": (...)\n    },\n    \"<prefund_account_id>\": {\n      \"name\": \"prefound_account\",\n      \"arguments\": {\n        (...)\n      },\n      \"output\": {\n        \"error\": \"...\"\n      },\n      \"status\": \"rejected\",\n      \"timestamp\": (...)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example snforge Output Showing Panic Failure (Shell)\nDESCRIPTION: Sample output from `snforge test` where one test fails due to an unhandled panic. The output includes the specific panic data reported by the contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nCollected 2 test(s) from testing_smart_contracts_handling_errors package\nRunning 2 test(s) from tests/\n[FAIL] testing_smart_contracts_handling_errors_integrationtest::panic::failing\n\nFailure data:\n    (0x50414e4943 ('PANIC'), 0x444159544148 ('DAYTAH'))\n\n[PASS] testing_smart_contracts_handling_errors_integrationtest::handle_panic::handling_string_errors (l1_gas: ~0, l1_data_gas: ~96, l2_gas: ~280000)\nRunning 0 test(s) from src/\nTests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out\n\nFailures:\n    testing_smart_contracts_handling_errors_integrationtest::panic::failing\n```\n\n----------------------------------------\n\nTITLE: Stopping Block Number Cheat for a Target in Starknet Foundry (Rust)\nDESCRIPTION: The 'stop_cheat_block_number' function cancels the effect of 'cheat_block_number' or 'start_cheat_block_number' for a given contract address. It takes a ContractAddress as input and resets the block number behavior for the specified target to default. Useful for orderly cleanup within tests or reverting specific cheats.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_number.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_block_number(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Defining Events Struct - Rust\nDESCRIPTION: Defines the `Events` struct, which is a wrapper around an array of `(ContractAddress, Event)` tuples. This structure is used to store and manage the collected events, providing methods for filtering and accessing them.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_events.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Events {\n    events: Array<(ContractAddress, Event)>\n}\n```\n\n----------------------------------------\n\nTITLE: Cheating Caller Addresses Globally with Global Cheatcodes - Cairo\nDESCRIPTION: This Cairo snippet showcases the use of a global cheatcode (cheat_caller_address with the _global suffix) to override the caller address universally for all contracts in the testing session. Unlike targeted cheats, this requires neither a span nor a target argument, and stays active indefinitely. Intended for situations where cross-contract global state manipulation is needed, it may affect test isolation if misused.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/using_cheatcodes_others/tests/caller_address/proper_use_global.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Starting Fee Data Availability Mode for Specific Target - Rust\nDESCRIPTION: This function sets the transaction fee data availability mode for a particular Starknet contract identified by its contract address. It accepts two parameters: the contract's address and the desired fee data availability mode represented as a 32-bit unsigned integer. This targeted alteration remains active until explicitly stopped and facilitates contract-specific fee mode testing.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/fee_data_availability_mode.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_fee_data_availability_mode(target: ContractAddress, fee_data_availability_mode: u32)\n```\n\n----------------------------------------\n\nTITLE: Stopping Mocking of a Starknet Contract Call (Rust)\nDESCRIPTION: The `stop_mock_call` cheatcode cancels any active mocking previously set up by `mock_call` or `start_mock_call` for a specific `function_selector` on the target `contract_address`. After calling this, subsequent calls to the entry point will execute normally (or fail if the contract/entry point doesn't exist).\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/mock_call.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_mock_call(contract_address: ContractAddress, function_selector: felt252)\n```\n\n----------------------------------------\n\nTITLE: Asserting L1 Messages Directly with Spy Methods in Cairo\nDESCRIPTION: Illustrates how to use assertion methods directly on the L1 message spy object within a Cairo test. This approach utilizes methods like `assert_sent` and `assert_not_sent` from the `MessageToL1SpyAssertionsTrait` to verify if specific messages were sent to L1 during the execution of the tested code. The actual code is included from an external file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-messages-to-l1.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_messages_to_l1/tests/simple.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Setting integer output format with sncast\nDESCRIPTION: Flag that specifies values should be displayed in decimal format. The default format displays addresses as hexadecimal and fees as integers.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n--int-format\n```\n\n----------------------------------------\n\nTITLE: Defining Starknet Contract Constructor in Rust (Cairo)\nDESCRIPTION: Example definition of a constructor function for a Starknet contract written in Cairo syntax within a Rust block. Shows parameters (`felt252`, `u256`) that require specific serialization when passed as constructor calldata during deployment. This serves as context for the subsequent deployment command.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/deploy.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[constructor]\nfn constructor(ref self: ContractState, first: felt252, second: u256) {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Plain Text File Content\nDESCRIPTION: Shows the format for a plain text file intended to be read by the proposed `read_txt` function. It contains space-separated felt values, including numbers and short strings enclosed in single quotes.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/loading_data_from_files.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n1 40 'hello' 100\n```\n\n----------------------------------------\n\nTITLE: Example JSON File Content for DFS Traversal\nDESCRIPTION: Provides an example of a JSON file structure. The proposed `read_json` function would parse this file, traversing the JSON tree using Depth-First Search (DFS), and return the values (1, 40, 'hello', 100) as an `Array<felt252>`. Note the use of double quotes for strings as per JSON specification.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/loading_data_from_files.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"a\": 1,\n  \"b\": {\n    \"c\": {\n        \"array\": [40, {\"e\": \"hello\"}]\n      }\n    },\n  \"d\": 100\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Features in Scarb.toml (TOML)\nDESCRIPTION: This snippet shows how to configure features in the `Scarb.toml` file. The `[features]` section defines the features, such as `enable_for_tests`, to be used for conditional compilation. The `default` key specifies default features to be enabled. This setup ensures that the specified features are available during compilation and testing.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/conditional-compilation.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[features]\nenable_for_tests = []\n```\n\n----------------------------------------\n\nTITLE: Defining Fuzzable Trait for Rust fuzz testing\nDESCRIPTION: Defines the `Fuzzable` trait with associated generic parameter `T` and a Debug constraint. Provides two required functions: `blank()`, which returns a default or empty value of type `T`, and `generate()`, which returns a randomly generated instance of type `T`. This trait is designed to be implemented for types used in fuzz testing with the snforge framework, enabling automatic generation of test inputs.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/fuzzable.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Fuzzable<T, +Debug<T>> {\n    fn blank() -> T;\n    fn generate() -> T;\n}\n```\n\n----------------------------------------\n\nTITLE: Execute Multicall Operations with sncast run\nDESCRIPTION: Shell command to execute the multicall operations defined in a TOML file (`multicall_example.toml`) using `sncast multicall run`. This command bundles all defined calls into a single Starknet transaction.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/multicall.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast multicall run --path multicall_example.toml\n```\n\n----------------------------------------\n\nTITLE: Setting hexadecimal output format with sncast\nDESCRIPTION: Flag that specifies values should be displayed in hexadecimal format. The default format displays addresses as hexadecimal and fees as integers.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n--hex-format\n```\n\n----------------------------------------\n\nTITLE: Using spy_events Cheatcode\nDESCRIPTION: This test case demonstrates the usage of the `spy_events` cheatcode. It captures emitted events, asserts on their presence or absence, and validates event data.  The `spy_events` cheatcode returns an `EventSpy` instance used to inspect emitted events.  Uses `assert_emitted`, `fetch_events` and `event_name_hash` to check the details.  Dependencies are `snforge_std` and contract implementing event emission.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/accessing_emitted_events.md#_snippet_4\n\nLANGUAGE: cairo\nCODE:\n```\nuse snforge_std::spy_events;\nuse snforge_std::EventSpy;\nuse snforge_std::EventFetcher;\nuse snforge_std::EventAsserions;\nuse snforge_std::event_name_hash;\n\n#[test]\nfn check_emitted_event_simple() {\n    // ...\n\tlet mut spy = spy_events();  // all events emitted after this line will be saved under the `spy` variable\n    let res = contract.emit_store_name(...);\n    \n    // after this line there will be no events under the `spy.events`\n    spy.assert_emitted(array![Event {from: ..., name: 'StoredName', ...}]);\n\n    let res = contract.emit_store_name(...);\n    let res = contract.emit_store_name(...);\n    \n    spy.assert_emitted(\n        array![\n            Event {from: ..., name: 'StoredName', ...},\n            Event {from: ..., name: 'StoredName', ...}\n        ]\n    );\n    \n    assert(spy.events.len() == 0, 'All events should be consumed');\n    // ...\n}\n\n#[test]\nfn check_emitted_event_complex() {\n    // ...\n\tlet mut spy = spy_events();  // all events emitted after this line will be saved under the `spy` variable\n    let res = contract.emit_store_name(...);\n    \n    spy.fetch_events();\n    \n    // users can assert events on their own\n    assert(spy.events.len() == 1, 'There should be one event');\n    assert(spy.events.at(0).name == event_name_hash('StoredName'), 'Wrong event name');\n    \n    let data = array![...];\n    assert(spy.events.at(0).data == data, 'Wrong data');\n\n    let res = contract.emit_store_name(...);\n    let res = contract.emit_store_name(...);\n    \n    // events will not be present before fetching\n    assert!(spy.events.len() == 1, 'There should be one event');\n    \n    spy.fetch_events();\n    assert(spy.events.len() == 3, 'There should be three events');\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Signature Verification Trait - Cairo\nDESCRIPTION: Defines the `VerifierTrait`, an interface for verifying signatures. Implementations must provide a `verify()` method that takes a message hash (`H`) and a signature (`U`), returning a boolean indicating the validity of the signature against the associated public key.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/signature.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\ntrait VerifierTrait<T, H, U> {\n    fn verify(self: T, message_hash: H, signature: U) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Globally Cheat Block Hash Stop - Rust\nDESCRIPTION: The `stop_cheat_block_hash_global` function reverts the global modification of the block hash. It takes the block number as input to stop a specific cheat. This effectively undoes the changes applied by `start_cheat_block_hash_global`. The function assumes that `start_cheat_block_hash_global` has been previously called for the given block number.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_hash.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_block_hash_global(block_number: u64)\n```\n\n----------------------------------------\n\nTITLE: Complete snfoundry.toml Example - TOML\nDESCRIPTION: This provides a complete example showing a fully-configured `snfoundry.toml` file with multiple profiles. This TOML snippet demonstrates a comprehensive configuration with multiple profiles, showcasing the use of `url`, `accounts-file`, `account`, `keystore`, `wait-params`, `block-explorer`, and `show-explorer-links`. It provides a ready-to-use template for configuring various sncast functionalities across different environments.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile1]\nurl = \"http://127.0.0.1:5050/\"\naccounts-file = \"../account-file\"\naccount = \"mainuser\"\nkeystore = \"~/keystore\"\nwait-params = { timeout = 500, retry-interval = 10 }\nblock-explorer = \"StarkScan\"\nshow-explorer-links = true\n\n[sncast.dev]\nurl = \"http://127.0.0.1:5056/rpc\"\naccount = \"devuser\"\n```\n\n----------------------------------------\n\nTITLE: Invoking a Smart Contract Function with Arguments using sncast\nDESCRIPTION: Example of using sncast to invoke the 'add' function on a smart contract deployed on Sepolia network with a complex PokemonData argument structure. This demonstrates how to format structured data arguments when calling contract functions.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/invoke.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n  --account my_account \\\n  invoke \\\n  --network sepolia \\\n  --contract-address 0x522dc7cbe288037382a02569af5a4169531053d284193623948eac8dd051716 \\\n  --function \"add\" \\\n  --arguments 'pokemons::model::PokemonData {'\\'name: \"Magmar\",'\\'element: pokemons::model::Element::Fire'\\'}'\n```\n\n----------------------------------------\n\nTITLE: Defining the L1 Message Structure in Rust (snforge)\nDESCRIPTION: Defines the `MessageToL1` struct in Rust as used by `snforge`. This structure represents a raw message sent to L1, containing the destination Ethereum address (`to_address`) and the message payload (`payload`) as an array of felt252 values. This structure is used when asserting sent messages.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-messages-to-l1.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n/// Raw message to L1 format (as seen via the RPC-API), can be used for asserting the sent messages.\nstruct MessageToL1 {\n    /// An ethereum address where the message is destined to go\n    to_address: starknet::EthAddress,\n    /// Actual payload which will be delivered to L1 contract\n    payload: Array<felt252>\n}\n```\n\n----------------------------------------\n\nTITLE: Cancelling Cheatcodes in Tests with stop_cheat_caller_address - Cairo\nDESCRIPTION: This Cairo example employs start_cheat_caller_address to activate a cheatcode and stop_cheat_caller_address to cancel it before additional contract interactions. Utilizing the SafeDispatcher, the snippet shows precise timing of cheatcode application and its cancellation effect on contract calls governed by caller validation. Dependencies include the cheatcode infrastructure and contract references.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/using_cheatcodes_cancelling_cheat/tests/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Invoking PowerShell Completions - PowerShell\nDESCRIPTION: These commands should be added to the PowerShell profile script (`$profile`). They generate the completion script output and execute it using `Invoke-Expression`, enabling completions for `sncast` and `snforge` within PowerShell sessions.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_7\n\nLANGUAGE: PowerShell\nCODE:\n```\nInvoke-Expression -Command $(sncast completion powershell | Out-String)\nInvoke-Expression -Command $(snforge completion powershell | Out-String)\n```\n\n----------------------------------------\n\nTITLE: Configuring Scarb for Backtrace Debug Information in TOML\nDESCRIPTION: This TOML configuration snippet shows the required settings within the `[profile.dev.cairo]` section of `Scarb.toml` to enable debug information generation for Starknet Foundry backtraces. Setting `unstable-add-statements-code-locations-debug-info` and `unstable-add-statements-functions-debug-info` to true is necessary for basic backtraces. The `panic-backtrace` flag (for specific Scarb nightly versions) provides improved backtraces for panics. Note that enabling these flags increases compilation time, memory usage, and artifact size.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/backtrace.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[profile.dev.cairo]\nunstable-add-statements-code-locations-debug-info = true\nunstable-add-statements-functions-debug-info = true\npanic-backtrace = true # only for scarb nightly-2025-03-27\n```\n\n----------------------------------------\n\nTITLE: Generating Random Felt Value\nDESCRIPTION: Announces the addition of the `generate_random_felt()` function to the Forge testing environment. This function provides a simple way to produce pseudo-random `felt` values. It is particularly useful for generating varied inputs for property-based testing or fuzzing within Cairo contracts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\ngenerate_random_felt()\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Transaction Hash Change - Rust\nDESCRIPTION: Defines a function to cancel the global transaction hash override applied to all targets. No parameters are required. It stops the active global transaction hash cheatcode to restore default behavior.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_hash.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_transaction_hash_global()\n```\n\n----------------------------------------\n\nTITLE: Fork Testing with Overridden Block ID - Cairo\nDESCRIPTION: This code snippet demonstrates how to override the `block_id` defined in the `Scarb.toml` file, using `block_number`, `block_hash`, or `block_tag` arguments in the `fork` attribute. It obtains a dispatcher, instantiates it with a real contract address from the forked state, calls a method to modify the contract's state, and then asserts the changed state.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fork-testing.md#_snippet_6\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fork_testing/tests/overridden_name.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Verifying a Cairo Contract Using sncast CLI in Shell\nDESCRIPTION: This snippet demonstrates how to verify a deployed Cairo contract class using the sncast CLI tool. It passes the contract's class hash, contract name, verifier (e.g. Walnut), and target network as arguments. Dependencies include a deployed contract, a properly configured Scarb.toml in the project, and network access. Inputs are shell arguments specifying contract details; the output is a verification request submitted to the provider, with status available at a provided URL. Avoid including sensitive files like keystores in the project as all workspace code will be submitted.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/verify.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n    verify \\\n    --class-hash 0x031966c9fe618bcee61d267750b9d46e3d71469e571e331f35f0ca26efe306dc \\\n    --contract-name SimpleBalance \\\n    --verifier walnut \\\n    --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Changing Block Number for a Target Using Starknet Foundry Cheatcode (Rust)\nDESCRIPTION: This function, 'cheat_block_number', sets the block number for a given contract address within a defined cheat span in Starknet Foundry. It is useful for simulating specific block numbers during tests, requiring the contract address (target), desired block number, and a specification of the cheat span. Inputs are a ContractAddress, a u64 block number, and a CheatSpan. Dependencies include Starknet Foundry test environment and related data types.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_number.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_block_number(target: ContractAddress, block_number: u64, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Setting Keystore Path - TOML\nDESCRIPTION: This TOML snippet configures the path to the keystore file. The `keystore` field specifies the location of the keystore file, which contains sensitive cryptographic keys. It is important to keep the file safe. If not provided the application might throw an error.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\nkeystore = \"path/to/keystore\"\n```\n\n----------------------------------------\n\nTITLE: Testing Internal Contract Functions in Cairo\nDESCRIPTION: A test function demonstrating how to test internal contract functions using the proposed contract-based test design. It initializes the contract state, writes values to storage, and calls an internal function from the contract.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/test_design.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nuse pkg::HelloStarknet::balanceContractMemberStateTrait;\nuse pkg::HelloStarknet::debtContractMemberStateTrait;\n\n#[test]\nfn test_internal() {\n    let mut state = HelloStarknet::contract_state_for_testing();\n\n    state.balance.write(10);\n    state.debt.write(5);\n    \n    HelloStarknet::InternalImpl::internal_function(@state);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring External Contracts in Scarb.toml for Testing\nDESCRIPTION: Sets up external contract dependencies in the `Scarb.toml` configuration file to enable their use in tests. This configuration specifies paths to external contracts so that the build system can incorporate them during compilation.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contract-collection/new-mechanism.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[[target.starknet-contract]]\nbuild-external-contracts = [\"path::to::Contract1\", \"other::path::to::Contract2\"]\n```\n\n----------------------------------------\n\nTITLE: Canceling Global Sequencer Address Change in Rust\nDESCRIPTION: Stops any globally applied sequencer address modification that affects all contract targets. This function requires no parameters and restores the default sequencer address behavior globally. It is important for resetting global state after testing modifications.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/sequencer_address.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_sequencer_address_global()\n```\n\n----------------------------------------\n\nTITLE: Fuzz Test Configuration in Cairo\nDESCRIPTION: This Cairo code snippet shows how to configure the number of runs of the random fuzzer and its seed for a specific test case. It utilizes the `#[fuzzer]` attribute and allows for setting fuzzer runs and seed values.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fuzz-testing.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fuzz_testing/src/with_parameters.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Calling a Starknet Contract Function Using sncast in Shell\nDESCRIPTION: Demonstrates how to use sncast to call a specific function in a Starknet smart contract deployed on the Sepolia network. It specifies parameters such as network, contract address, function name, function arguments in human-readable form, and block identifier. This example shows how to pass arguments using the --arguments flag and how the output contains the contract call's response as a list of field elements. This snippet requires sncast installed and network access to Sepolia RPC providers.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/sncast-overview.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast call \\\n    --network sepolia \\\n    --contract-address 0x522dc7cbe288037382a02569af5a4169531053d284193623948eac8dd051716 \\\n    --function \"pokemon\" \\\n    --arguments '\"Charizard\"' \\\n    --block-id latest\n```\n\n----------------------------------------\n\nTITLE: Complex structures storage load and store\nDESCRIPTION: This example demonstrates loading and storing complex data structures in Starknet contract storage using Snforge. It builds upon the `complex_structures.cairo` contract and tests the `load` and `store` cheatcodes in the context of those structs. Dependencies include Starknet and Snforge.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/direct_storage_access/tests/complex_structures.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Starting Block Number Cheat for a Specific Target in Starknet Foundry (Rust)\nDESCRIPTION: This function, 'start_cheat_block_number', changes the block number for a specific contract address (target) to a provided u64 value. It requires the contract address and target block number, and is suitable for simulating a new block environment for individual contracts rather than the entire chain. Only the specified target is affected, not globally.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_number.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_block_number(target: ContractAddress, block_number: u64)\n```\n\n----------------------------------------\n\nTITLE: Structures Used for Declaring Contract in Cairo\nDESCRIPTION: The code snippets define the structures used by the `declare` command: `DeclareResult`, `DeclareTransactionResult`, and `AlreadyDeclaredResult`. These structures represent the outcome of a contract declaration. `DeclareResult` can be either `Success` or `AlreadyDeclared`. `DeclareTransactionResult` holds the `class_hash` and the transaction hash. `AlreadyDeclaredResult` holds only the `class_hash`.  Dependencies include `Drop`, `Copy`, `Debug`, and `Serde` traits.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/declare.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Drop, Copy, Debug, Serde)]\npub enum DeclareResult {\n    Success: DeclareTransactionResult,\n    AlreadyDeclared: AlreadyDeclaredResult,\n}\n\n#[derive(Drop, Copy, Debug, Serde)]\npub struct DeclareTransactionResult {\n    pub class_hash: ClassHash,\n    pub transaction_hash: felt252,\n}\n\n#[derive(Drop, Copy, Debug, Serde)]\npub struct AlreadyDeclaredResult {\n    pub class_hash: ClassHash,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Conditional Compilation (Cairo)\nDESCRIPTION: This snippet shows how to define a function that utilizes conditional compilation. The function will be compiled based on the active features. This enables the selective inclusion of function implementations, enhancing code flexibility and optimization in scenarios based on defined features.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/conditional-compilation.md#_snippet_5\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/conditional_compilation/src/function.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Configuring snforge Settings in TOML\nDESCRIPTION: Defines the [tool.snforge] section within Scarb.toml for configuring the Starknet Foundry Forge test runner. This includes options such as 'exit_first' to stop tests after the first failure, 'fuzzer_runs' for the number of random fuzzer runs, and 'fuzzer_seed' for the fuzzer seed. These fields are optional and control test execution behavior and randomness. The configuration supports forked tests defined under [[tool.snforge.fork]], including RPC endpoints and fork block identification.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[tool.snforge]\nexit_first = true\n```\n\nLANGUAGE: toml\nCODE:\n```\n[tool.snforge]\nfuzzer_runs = 1234\nfuzzer_seed = 1111\n```\n\nLANGUAGE: toml\nCODE:\n```\n[[tool.snforge.fork]]\nname = \"SOME_NAME\"\nurl = \"http://your.rpc.url\"\nblock_id.tag = \"latest\"\n```\n\nLANGUAGE: toml\nCODE:\n```\n[[tool.snforge.fork]]\nname = \"SOME_SECOND_NAME\"\nurl = \"http://your.second.rpc.url\"\nblock_id.number = \"123\"\n```\n\n----------------------------------------\n\nTITLE: Changing signature for target within span - Starknet Foundry Rust\nDESCRIPTION: This cheatcode changes the transaction signature for a specified contract address, but the change is only active for the duration or block range defined by the `span`. It requires the target contract address, the new signature represented as a `Span<felt252>`, and a `CheatSpan` object specifying the active period.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/signature.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_signature(target: ContractAddress, signature: Span<felt252>, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Deploying a Contract Implementation - Cairo\nDESCRIPTION: This snippet, included from an external file, likely contains the core Cairo implementation details for deploying a contract.  It likely utilizes the provided parameters such as `class_hash`, `constructor_calldata`, `salt`, and `unique` to interact with the StarkNet blockchain and deploy the contract. It is the actual mechanism which handles the contract deployment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/deploy.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../../listings/deploy/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Contract using Enums in Storage\nDESCRIPTION: This snippet provides the contract implementation which utilizes enums in its storage. The purpose is to demonstrate how enums are stored and accessed using Snforge cheatcodes, considering the 1-based layout for most enums.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/direct_storage_access/src/using_enums.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining the MessageToL1FilterTrait in Rust\nDESCRIPTION: Defines the `MessageToL1FilterTrait`, which equips the `MessagesToL1` struct with filtering methods. The `sent_by` method filters messages based on the L2 sender `ContractAddress`, and the `sent_to` method filters based on the L1 destination `EthAddress`, returning a new `MessagesToL1` instance with the filtered results.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_messages_to_l1.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\ntrait MessageToL1FilterTrait {\n    /// Filter messages emitted by a sender of a given [`ContractAddress`]\n    fn sent_by(self: @MessagesToL1, contract_address: ContractAddress) -> MessagesToL1;\n    /// Filter messages emitted by a receiver of a given ethereum address\n    fn sent_to(self: @MessagesToL1, to_address: EthAddress) -> MessagesToL1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Environmental Variables in snfoundry.toml (TOML)\nDESCRIPTION: This code snippet demonstrates using environmental variables in `snfoundry.toml`. The snippet uses the $NODE_URL environmental variable for the `url` field. This provides a way to avoid hardcoding sensitive values directly in the configuration file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/projects/configuration.md#_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n# ...\n[sncast.default]\naccount = \"my_account\"\naccounts-file = \"~/my_accounts.json\"\nurl = \"$NODE_URL\"\n# ...\n```\n\n----------------------------------------\n\nTITLE: Manually Asserting Emitted Events on Events Structure in Cairo\nDESCRIPTION: Details how to manually assert event data by fetching events from the EventSpy using get_events(), accessing the enclosed events fieldan array of (ContractAddress, Event) tuples. It highlights key implementation details like unpacking tuples, checking event emission, and verifying event properties such as hashed event names using the selector! macro. This method provides fine-grained control over event verification beyond automatic assertions.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-events.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/testing_events/tests/assert_manually.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Reading Environment Variables with `var`\nDESCRIPTION: The `var` function reads an environment variable without parsing its content. The serialization of the output is determined by the inferred input type. Single quotes treat the variable as a short string, while double quotes serialize it as a `ByteArray` for deserialization with `Serde`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/env.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn var(name: ByteArray) -> Array<felt252>\n```\n\n----------------------------------------\n\nTITLE: Generating Fuzz Argument in Cairo\nDESCRIPTION: This snippet shows the function signature for `generate_arg`, a helper function used in Starknet Foundry's fuzz testing framework to generate random values within a specified range. It takes minimum and maximum bounds (`min_value`, `max_value`) of a generic type `T` and returns a random value of the same type. The function requires `T` to implement `Serde`, `Drop`, and be convertible `Into<felt252>`, indicating its use in serialization, resource management, and conversion within the Starknet environment. This function is instrumental in implementing the `Fuzzable` trait for various types.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/generate_arg.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn generate_arg<T, +Serde<T>, +Drop<T>, +Into<T, felt252>>(min_value: T, max_value: T) -> T\n```\n\n----------------------------------------\n\nTITLE: Stopping Transaction Hash Change for Specific Target - Rust\nDESCRIPTION: Defines a function to cancel or stop the transaction hash override previously set for a specific contract target. Accepts the contract address as input and disables any active transaction hash cheatcodes for that address.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_hash.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_transaction_hash(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Setting accounts file path with sncast\nDESCRIPTION: Flag for specifying the path to the open zeppelin accounts file holding accounts information. Defaults to ~/.starknet_accounts/starknet_open_zeppelin_accounts.json.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n--accounts-file, -f <PATH_TO_ACCOUNTS_FILE>\n```\n\n----------------------------------------\n\nTITLE: Enabling starknet-contract target in Scarb.toml\nDESCRIPTION: Configuration required in Scarb.toml to enable the starknet-contract target, which is necessary for using snforge with existing Scarb projects.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n# ...\n[[target.starknet-contract]]\n```\n\n----------------------------------------\n\nTITLE: Example Contract Call Script Using Starknet Foundry sncast - Rust\nDESCRIPTION: This Rust snippet demonstrates how to write a minimal deployment script for calling an already deployed Cairo contract using Starknet Foundry's sncast scripting framework. The script assumes inclusion within a Scarb package, depends on 'starknet' and 'sncast_std' libraries (minimum version 0.33.0), and defines a 'main' function as script entry point. It showcases interacting with a contract on a specified network via sncast's runtime. The example highlights the typical input of deployed contract address and the output containing call result data. Limitations include reliance on prior contract deployment (no deploy step shown) and experimental status of sncast features.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/script.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n{{#include ../../listings/basic_example/src/basic_example.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Creating Starknet Account with Custom Class Hash using sncast\nDESCRIPTION: This command creates local account information using a specific account contract class hash instead of the default. It allows using custom deployed versions of OpenZeppelin, Argent, or Braavos account contracts. You must specify the network, name, the desired class hash, and the account type.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/account.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nsncast \\\n    account create \\\n    --name new_account_2 \\\n    --network sepolia \\\n    --class-hash 0x00e2eb8f5672af4e6a4e8a8f1b44989685e668489b0a25437733756c5a34a1d6\n    --type oz\n```\n\n----------------------------------------\n\nTITLE: Contract with Complex Structures\nDESCRIPTION: This snippet defines a Starknet contract and supporting structs with derived serialization methods, leveraging `#[derive(starknet::Store)]`. It serves as a basis for demonstrating direct storage interaction with complex data types.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/direct_storage_access/src/complex_structures.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Adding sncast_std Dependency in Scarb.toml\nDESCRIPTION: This TOML snippet demonstrates how to add the `sncast_std` package as a dependency in a project's `Scarb.toml` file. Specify the package name under the `[dependencies]` section and set the desired version (e.g., \"0.33.0\") to make the library functions available in your Starknet Foundry project.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nsncast_std = \"0.33.0\"\n```\n\n----------------------------------------\n\nTITLE: Defining Event Struct - Rust\nDESCRIPTION: Defines the `Event` struct, representing the raw event format as seen via the RPC-API. It includes an array of keys and an array of data, both of type `felt252`. This structure captures the low-level details of an emitted event.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_events.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nstruct Event {\n    keys: Array<felt252>,\n    data: Array<felt252>\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying an Account using sncast\nDESCRIPTION: This command deploys an account to the specified Starknet network after it has been prefunded. It utilizes the `sncast account deploy` command with parameters for the network and account name.  This assumes the account was previously created and funded.  Requires a prefunded account and `sncast` to be installed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/101.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast account deploy   --network sepolia   --name my_account\n```\n\n----------------------------------------\n\nTITLE: Changing Sequencer Address Globally in Rust\nDESCRIPTION: This function sets a global sequencer address that applies to all contract targets. It takes a single ContractAddress representing the sequencer address. This global modification affects every target until canceled. The function has no output and alters global state used during testing or simulation.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/sequencer_address.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_sequencer_address_global(sequencer_address: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Example snforge Test Output (Shell)\nDESCRIPTION: Provides sample output from running `snforge test`. This example shows a mix of passing and failing tests, including failure data and gas usage information.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nCollected 2 test(s) from testing_smart_contracts_handling_errors package\nRunning 2 test(s) from tests/\n[FAIL] testing_smart_contracts_handling_errors_integrationtest::panic::failing\n\nFailure data:\n    (0x50414e4943 ('PANIC'), 0x444159544148 ('DAYTAH'))\n\n[PASS] testing_smart_contracts_handling_errors_integrationtest::handle_panic::handling_string_errors (l1_gas: ~0, l1_data_gas: ~96, l2_gas: ~280000)\nRunning 0 test(s) from src/\nTests: 1 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out\n\nFailures:\n    testing_smart_contracts_handling_errors_integrationtest::panic::failing\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Nonce Cheat (Rust)\nDESCRIPTION: Cancels the global nonce modification previously set by `start_cheat_nonce_global`. Subsequent transactions for all targets will use their actual nonces unless overridden by a specific target cheat.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_nonce_global()\n```\n\n----------------------------------------\n\nTITLE: Implementing Fuzzable Trait for Custom Type Message in Rust\nDESCRIPTION: Provides an implementation example of the `Fuzzable` trait for a custom struct `Message` containing fields `id` and `text`. The `blank()` method returns a default instance with an `id` of 0 and a default value for `text`. The `generate()` method returns a randomly generated `Message` where `id` is produced using the `generate_arg` cheatcode constrained by the u64 range, and `text` uses the `generate()` method of a `Fuzzable` implementation for `ByteArray`. This example depends on the `snforge_std` crate, the `generate_arg` cheatcode, and the `Bounded` trait for specifying value ranges.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/fuzzable.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse core::num::traits::Bounded;\nuse snforge_std::fuzzable::{Fuzzable, generate_arg};\n\n#[derive(Debug, Drop)]\nstruct Message {\n    id: u64,\n    text: ByteArray\n}\n\nimpl FuzzableMessage of Fuzzable<Message> {\n    fn blank() -> Message {\n        Message {\n            // Implementation may consist of:\n            // Specifying a concrete value for the field\n            id: 0,\n            // Or using default value from `Default` trait\n            text: Default::default()\n        }\n    }\n\n    fn generate() -> Message {\n        Message {\n            // Using `generate_arg` cheatcode\n            id: generate_arg(0, Bounded::<u64>::MAX),\n            // Or calling `generate` function on a type that already implements `Fuzzable`\n            text: Fuzzable::<ByteArray>::generate()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using External Contracts from Dependencies in TOML\nDESCRIPTION: Illustrates a comprehensive example of Scarb.toml featuring dependency declarations with version constraints and Git sources, alongside the [[target.starknet-contract]] configuration to enable inclusion of external contracts in tests via 'build-external-contracts'. This facilitates integrating external libraries, like OpenZeppelin contracts, into the Starknet project's testing environment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nstarknet = \">=2.8.2\"\nopenzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", branch = \"cairo-2\" }\n\n[[target.starknet-contract]]\nbuild-external-contracts = [\"openzeppelin::account::account::Account\"]\n```\n\n----------------------------------------\n\nTITLE: Testing storage of LegacyMap with store/load\nDESCRIPTION: This test case demonstrates storing and loading a value into a `LegacyMap` in the contract's storage. It deploys the `HelloStarknet` contract, gets the address of a specific key in the `map`, stores a value, loads the stored value, and asserts that the loaded value matches the stored value.  It relies on `contract_state_for_testing` to get the variable address, and specifies a key to store the value at.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/store_load_cheatcodes.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n#[test]\nfn test_legacy_map() {\n    let contract_address = deploy_hello_contract();\n    let state = HelloStarknet::contract_state_for_testing();\n    \n    \n    let key = 420;\n    let value = 69;\n    let variable_address = state.map.address(key);\n    \n    store::<felt252>(contract_address, variable_address, value);\n    let stored_value = load::<felt252>(contract_address, variable_address);\n    \n    assert(stored_value == 69, 'Wrong k:v stored');   \n}\n```\n\n----------------------------------------\n\nTITLE: Setting wait retry interval with sncast\nDESCRIPTION: Flag for specifying the retry interval in seconds when --wait is used, determining how often sncast should fetch transaction information from the node. Defaults to 5 seconds.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n--wait-retry-timeout <TIME_IN_SECONDS>\n```\n\n----------------------------------------\n\nTITLE: Defining the MessageToL1Spy Struct in Rust\nDESCRIPTION: Defines the `MessageToL1Spy` struct. Instances of this struct are created using `spy_messages_to_l1()` and are used to capture messages sent to L1 from the point of its creation onwards.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_messages_to_l1.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct MessageToL1Spy {\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Setting global account contract address in Rust\nDESCRIPTION: Changes the address of an account which the transaction originates from for all target contracts. Requires only the new account contract address parameter.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_contract_address.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_account_contract_address_global(account_contract_address: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Modifying Nonce Data Availability Mode for Contract Target (Rust)\nDESCRIPTION: This function, cheat_nonce_data_availability_mode, changes the transaction nonce data availability mode for a specified contract address and operational span. Dependencies include the StarkNet framework, a ContractAddress type, and a CheatSpan instance. Expected input parameters are a target contract address, a u32 value indicating the new nonce data availability mode, and a CheatSpan which defines the duration or context over which the cheat applies. This function is intended for testing or simulation. Outputs are the modified state for the specified target and within the given span. Requires cheat infrastructure to be enabled.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce_data_availability_mode.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_nonce_data_availability_mode(target: ContractAddress, nonce_data_availability_mode: u32, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Account Nonce in Rust\nDESCRIPTION: Defines a public Rust function `get_nonce` that accepts a `block_tag` of type `felt252` (expected to be either `pending` or `latest`) and returns the account nonce as a `felt252`. The function interfaces with StarkNet to query the latest or pending nonce for an account. It relies on the Felt252 type representing field elements in Cairo and StarkNet primitives. Input is the block tag specifying state context and output is the nonce at that block tag.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/get_nonce.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn get_nonce(block_tag: felt252) -> felt252\n```\n\n----------------------------------------\n\nTITLE: Declaring a Starknet Contract using sncast (Shell)\nDESCRIPTION: Demonstrates how to declare a Starknet contract using the `sncast declare` command. Examples show providing the account via the `--account` flag and alternatively relying on configuration from `snfoundry.toml`. The `--contract-name` specifies the contract to declare. Expects a compiled contract artifact (e.g., `HelloSncast.contract_class.json`) in the project.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/crates/sncast/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast --account my_account \\\n    declare \\\n    --contract-name HelloSncast\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Using default profile from snfoundry.toml\n$ sncast declare \\\n    --contract-name HelloSncast\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Example Output\ncommand: Declare\nclass_hash: [..]\ntransaction_hash: [..]\n```\n\n----------------------------------------\n\nTITLE: Implementing the 'call' function for smart contract invocation in Rust\nDESCRIPTION: Defines a public Rust function 'call' which interacts with a smart contract at a specified address, executes a function identified by a selector with given calldata, and returns a 'Result' containing a 'CallResult' or an error, facilitating contract interaction in the starknet-foundry environment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/call.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn call(\n    contract_address: ContractAddress, function_selector: felt252, calldata: Array::<felt252>\n) -> Result<CallResult, ScriptCommandError>\n```\n\n----------------------------------------\n\nTITLE: Build profile data automatically using snforge\nDESCRIPTION: This command tells snforge to automatically call cairo-profiler on the generated trace files. The profiling data, which contains information about resource usage and the call tree, is saved to the `profile` directory. This simplifies the profiling process by automating the call to cairo-profiler.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/profiling.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --build-profile\n```\n\n----------------------------------------\n\nTITLE: Running Tests after Cheatcode Cancel (Failing Example) - Shell\nDESCRIPTION: This shell transcript shows execution of 'snforge test' after cancelling an active cheatcode. It clearly displays a failed test and the output message that pinpoints the failures origin, demonstrating the revert of blockchain state effect after cheatcode cancellation.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test\n\nCollected 1 test(s) from using_cheatcodes_cancelling_cheat package\nRunning 1 test(s) from tests/\n[FAIL] using_cheatcodes_cancelling_cheat_tests::call_and_invoke\n\nFailure data:\n    0x5365636f6e642063616c6c206661696c656421 ('Second call failed!')\n\nRunning 0 test(s) from src/\nTests: 0 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out\n\nFailures:\n    using_cheatcodes_cancelling_cheat_tests::call_and_invoke\n```\n\n----------------------------------------\n\nTITLE: Running Tests for All Packages in Workspace\nDESCRIPTION: This command uses the `--workspace` flag to execute tests for all packages present in the Scarb workspace.  Dependencies: `snforge` and a Scarb workspace.  Input: The `--workspace` flag tells `snforge test` to run tests across all packages.  Output: Test results aggregated from all packages in the workspace.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-workspaces.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --workspace\n```\n\n----------------------------------------\n\nTITLE: Generated Cairo Code for Parametrized Tests\nDESCRIPTION: Illustrates the expected compiler-generated code for the parametrized test defined using `#[test_case]` attributes. For each `#[test_case]`, a distinct `#[test]` function is created. Inside each generated function, the parameters of the original function (`a` and `b`) are declared and initialized with the fixed values provided in the corresponding `#[test_case` attribute.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/parametrizing_tests_with_fixed_values.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n#[test]\nfn my_test_case_1() {\n  let a: felt252 = 1;\n  let b: u32 = 3;\n  // ...\n}\n\n#[test]\nfn my_test_case_2() {\n    let a: felt252 = 3;\n    let b: u32 = 5;\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Contract Compilation using Feature Flags in Rust\nDESCRIPTION: Demonstrates a Rust code snippet defining a Starknet contract module which is conditionally compiled only if the specified feature ('enable_for_tests') is enabled. This uses Rust's #[cfg(feature = \"...\")] attribute to gate compilation, allowing modular test contracts depending on manifest feature declarations.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[starknet::contract]\n#[cfg(feature: 'enable_for_tests')]\nmod MockContract {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StarkNet Foundry Error Structures and Enums in Rust\nDESCRIPTION: This Rust code defines several structs (`ErrorData`, `ContractErrorData`, `TransactionExecutionErrorData`, `ContractExecutionErrorInner`) and enums (`ContractExecutionError`, `StarknetError`, `ProviderError`, `TransactionError`, `WaitForTransactionError`, `ScriptCommandError`) to represent various error types encountered within the StarkNet Foundry framework. These types are used for detailed error handling, covering issues from contract execution failures and transaction rejections to provider problems and script command errors. Attributes like `Drop`, `PartialEq`, `Serde`, and `Debug` are derived for common traits.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/errors.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Drop, PartialEq, Serde, Debug)]\npub struct ErrorData {\n    msg: ByteArray\n}\n\n#[derive(Drop, PartialEq, Serde, Debug)]\npub struct ContractErrorData {\n    revert_error: ContractExecutionError\n}\n\n#[derive(Drop, PartialEq, Debug)]\npub struct TransactionExecutionErrorData {\n    transaction_index: felt252,\n    execution_error: ContractExecutionError,\n}\n\n#[derive(Drop, PartialEq, Debug)]\npub enum ContractExecutionError {\n    Nested: Box<ContractExecutionErrorInner>,\n    Message: ByteArray\n}\n\n#[derive(Drop, Serde, Debug)]\npub struct ContractExecutionErrorInner {\n    contract_address: ContractAddress,\n    class_hash: felt252,\n    selector: felt252,\n    error: ContractExecutionError,\n}\n\n#[derive(Drop, Serde, PartialEq, Debug)]\npub enum StarknetError {\n    /// Failed to receive transaction\n    FailedToReceiveTransaction,\n    /// Contract not found\n    ContractNotFound,\n    /// Requested entrypoint does not exist in the contract\n    EntryPointNotFound,\n    /// Block not found\n    BlockNotFound,\n    /// Invalid transaction index in a block\n    InvalidTransactionIndex,\n    /// Class hash not found\n    ClassHashNotFound,\n    /// Transaction hash not found\n    TransactionHashNotFound,\n    /// Contract error\n    ContractError: ContractErrorData,\n    /// Transaction execution error\n    TransactionExecutionError: TransactionExecutionErrorData,\n    /// Class already declared\n    ClassAlreadyDeclared,\n    /// Invalid transaction nonce\n    InvalidTransactionNonce,\n    /// The transaction's resources don't cover validation or the minimal transaction fee\n    InsufficientResourcesForValidate,\n    /// Account balance is smaller than the transaction's max_fee\n    InsufficientAccountBalance,\n    /// Account validation failed\n    ValidationFailure: ErrorData,\n    /// Compilation failed\n    CompilationFailed,\n    /// Contract class size it too large\n    ContractClassSizeIsTooLarge,\n    /// Sender address in not an account contract\n    NonAccount,\n    /// A transaction with the same hash already exists in the mempool\n    DuplicateTx,\n    /// the compiled class hash did not match the one supplied in the transaction\n    CompiledClassHashMismatch,\n    /// the transaction version is not supported\n    UnsupportedTxVersion,\n    /// the contract class version is not supported\n    UnsupportedContractClassVersion,\n    /// An unexpected error occurred\n    UnexpectedError: ErrorData,\n}\n\n#[derive(Drop, Serde, PartialEq, Debug)]\npub enum ProviderError {\n    StarknetError: StarknetError,\n    RateLimited,\n    UnknownError: ErrorData,\n}\n\n#[derive(Drop, Serde, PartialEq, Debug)]\npub enum TransactionError {\n    Rejected,\n    Reverted: ErrorData,\n}\n\n#[derive(Drop, Serde, PartialEq, Debug)]\npub enum WaitForTransactionError {\n    TransactionError: TransactionError,\n    TimedOut,\n    ProviderError: ProviderError,\n}\n\n#[derive(Drop, Serde, PartialEq, Debug)]\npub enum ScriptCommandError {\n    UnknownError: ErrorData,\n    ContractArtifactsNotFound: ErrorData,\n    WaitForTransactionError: WaitForTransactionError,\n    ProviderError: ProviderError,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Specific snforge Test Exactly (Shell)\nDESCRIPTION: Executes a single, specific test identified by its fully qualified name (e.g., `hello_snforge_integrationtest::test_contract::test_calling`) using the `--exact` flag. This is useful for isolating and debugging individual tests and results in optimized compilation only for the targeted test. The fully qualified name, including module path, is required.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/running-tests.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test hello_snforge_integrationtest::test_contract::test_calling --exact\n```\n\n----------------------------------------\n\nTITLE: Defining EventSpyTrait - Rust\nDESCRIPTION: Defines the `EventSpyTrait`, which provides the `get_events` function. The `get_events` function retrieves all events that have been emitted since the creation of the `EventSpy` instance. The function takes a reference to `EventSpy` and returns an `Events` struct.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_events.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\ntrait EventSpyTrait {\n    fn get_events(ref self: EventSpy) -> Events;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Contract in Tests with Snforge (Shell)\nDESCRIPTION: This shell command demonstrates how to run tests using snforge, enabling specific features.  The `--features` flag is used to specify which features to enable. It compiles and runs the tests associated with the enabled features, using conditional compilation. This command enables the `enable_for_tests` feature.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/conditional-compilation.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --features enable_for_tests\n```\n\n----------------------------------------\n\nTITLE: Cheat Block Hash Start - Rust\nDESCRIPTION: The `start_cheat_block_hash` cheatcode modifies the block hash for a given contract and block number. It is similar to `cheat_block_hash` but does not immediately apply the change; instead, it sets up the modification until the cheat is explicitly stopped. It requires a contract address, block number, and new block hash as input.  This cheat is applicable within the Foundry testing environment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_hash.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_block_hash(contract_address: ContractAddress, block_number: u64, block_hash: felt252)\n```\n\n----------------------------------------\n\nTITLE: Contract Interface Definition - Cairo\nDESCRIPTION: This code snippet defines the interface for the `Pokemons` contract along with the structures used by its external functions. This interface is used to interact with the contract in the forked environment. It defines types such as `Pokemon`, `Trainer`, `TrainingSession`, and the interface `IPokemonsDispatcher` for interacting with the contract's methods.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fork-testing.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/fork_testing/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of StarkCurveKeyPairTrait for Signing and Verification in Cairo\nDESCRIPTION: Demonstrates usage of the StarkCurveKeyPairTrait in a test function. A new key pair is generated using the trait's generate method, a message hash is defined, and the sign method produces a signature tuple. The verify method then confirms the validity of the signature against the message hash, with an assertion to ensure correctness. This example shows how to implement signing and verification flows for testing custom account behavior in Cairo.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/stark_curve_signatures.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\nuse snforge_std::{StarkCurveKeyPair, StarkCurveKeyPairTrait};\n\n#[test]\nfn test_stark_curve() {\n    let mut key_pair = StarkCurveKeyPairTrait::generate();\n    let message_hash = 12345;\n    \n    let signature = key_pair.sign(message_hash);\n    \n    assert(key_pair.verify(message_hash, signature), 'Signature is incorrect');\n}\n```\n\n----------------------------------------\n\nTITLE: Opening PowerShell Profile - PowerShell\nDESCRIPTION: Ensures the parent directory for the PowerShell profile script exists (suppressing errors if it already does) and then opens the user's PowerShell profile file (`$profile`) in Notepad for editing.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_6\n\nLANGUAGE: PowerShell\nCODE:\n```\nmkdir -Path (Split-Path -Parent $profile) -ErrorAction SilentlyContinue\nnotepad $profile\n```\n\n----------------------------------------\n\nTITLE: Example sncast tx-status Output\nDESCRIPTION: This is an example of the output from the `sncast tx-status` command. It shows the `execution_status` as Succeeded and the `finality_status` as AcceptedOnL1.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/tx-status.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncommand: tx-status\nexecution_status: Succeeded\nfinality_status: AcceptedOnL1\n```\n\n----------------------------------------\n\nTITLE: Proposed Cairo Interface for File Reading\nDESCRIPTION: Defines the proposed Cairo interface for file handling. It includes a `File` struct to hold the path, a `FileTrait` with a `new` constructor, its implementation, and function signatures for `read_txt` and `read_json` which take a `File` reference and return an `Array<felt252>`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/loading_data_from_files.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n// struct to store path of the file\nstruct File {\n    path: felt252 // relative path to the file\n}\n\ntrait FileTrait {\n    fn new(path: felt252) -> File;\n}\n\nimpl FileTraitImpl of FileTrait {\n    fn new(path: felt252) -> File {\n        File { path }\n    }\n}\n\nfn read_txt(file: @File) -> Array<felt252>;\nfn read_json(file: @File) -> Array<felt252>;\n```\n\n----------------------------------------\n\nTITLE: Specifying output file path with --output-path or -p\nDESCRIPTION: This snippet describes how to specify the file path for the generated `.toml` template using the `--output-path` or `-p` option. If the option is omitted, the template content will be printed to stdout. This allows users to direct the output to a particular file for easier management.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/multicall/new.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n--output-path, -p <PATH>\n```\n\n----------------------------------------\n\nTITLE: Checking project directory structure\nDESCRIPTION: Commands to navigate to the project directory and view its structure using the tree command. This shows the basic layout of a Starknet Foundry project.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cd hello_starknet\n$ tree . -L 1\n```\n\n----------------------------------------\n\nTITLE: Running snforge Tests Without Backtrace Enabled (Shell)\nDESCRIPTION: This shell command executes `snforge test`. The output shows a typical failure message without detailed backtrace information, indicating an error occurred (e.g., 'ENTRYPOINT_NOT_FOUND', 'ENTRYPOINT_FAILED') and prompting the user to rerun with the `SNFORGE_BACKTRACE=1` environment variable for more details.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/backtrace.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test\n```\n\nLANGUAGE: shell\nCODE:\n```\nFailure data:\n    (0x454e545259504f494e545f4e4f545f464f554e44 ('ENTRYPOINT_NOT_FOUND'), 0x454e545259504f494e545f4641494c4544 ('ENTRYPOINT_FAILED'))\nnote: run with `SNFORGE_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Defining StarkCurveKeyPair Struct and Trait for Stark Curve Signing in Cairo\nDESCRIPTION: Defines the StarkCurveKeyPair struct representing a key pair with private and public keys as felt252 types. Introduces the StarkCurveKeyPairTrait trait with methods to generate a new key pair, sign a message hash returning a signature tuple, and verify a signature given a message hash. This snippet forms the core cryptographic interface for signing and verification on the Stark Curve in Cairo and requires familiarity with felt252 and Cairo traits.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/stark_curve_signatures.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nstruct StarkCurveKeyPair {\n    private_key: felt252,\n    public_key: felt252 \n}\n\ntrait StarkCurveKeyPairTrait {\n    fn generate() -> StarkCurveKeyPair;\n    fn sign(ref self: StarkCurveKeyPair, message_hash: felt252) -> (felt252, felt252);\n    fn verify(ref self: StarkCurveKeyPair, message_hash: felt252, signature: (felt252, felt252)) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Overwriting existing file with --overwrite or -o\nDESCRIPTION: This snippet explains how to enable overwriting of an existing file at the specified output path by using the `--overwrite` or `-o` option. When this flag is set, the command will replace any existing file, ensuring the new template is saved without manual deletion.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/multicall/new.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n--overwrite, -o <OVERWRITE>\n```\n\n----------------------------------------\n\nTITLE: Global Fuzzer Configuration via CLI\nDESCRIPTION: This shell command demonstrates configuring the fuzzer globally using command line arguments. Specifically, it sets the number of fuzzer runs and the fuzzer seed. These settings will apply to all tests run with this command, unless overridden at the test level.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/fuzz-testing.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ snforge test --fuzzer-runs 1234 --fuzzer-seed 1111\n```\n\n----------------------------------------\n\nTITLE: Updating Rust\nDESCRIPTION: This command updates the installed Rust version to the latest stable release. It ensures that the development environment is using the most up-to-date Rust toolchain.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ rustup update\n```\n\n----------------------------------------\n\nTITLE: Specifying Gas Bounds with #[available_gas] Attribute\nDESCRIPTION: Shows how the `#[available_gas]` attribute now accepts named arguments for specifying L1 gas, L1 data gas, and L2 gas resource bounds individually. This provides fine-grained control over the gas allocated for a specific function or test, replacing the previous single gas value.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n#[available_gas(l1_gas: 1, l1_data_gas: 2, l2_gas: 3)]\n```\n\n----------------------------------------\n\nTITLE: Example Output of sncast multicall run\nDESCRIPTION: Shows the typical output after successfully running `sncast multicall run`, including the command executed, the resulting transaction hash, and a link to view the transaction details on a Starknet explorer.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/multicall.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncommand: multicall\ntransaction_hash: [..]\n\nTo see invocation details, visit:\ntransaction: https://sepolia.starkscan.co/tx/[..]\n```\n\n----------------------------------------\n\nTITLE: Storage access from base address\nDESCRIPTION: This example demonstrates direct storage access using `storage_address_from_base`. It provides a use case for interacting with a Starknet contract's storage by calculating addresses from the base storage variable address. Dependencies include Starknet and Snforge.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/direct_storage_access/tests/using_storage_address_from_base.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Deserializing ByteArray from felt252 Span in Cairo\nDESCRIPTION: Defines the function `try_deserialize_bytearray_error` which attempts to convert a serialized contract call output, represented as a `Span<felt252>`, into a `ByteArray`. It returns a `Result` containing the parsed `ByteArray` on success or an `Err` with a `ByteArray` representing the error reason on failure.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/byte_array.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nfn try_deserialize_bytearray_error(x: Span<felt252>) -> Result<ByteArray, ByteArray>\n```\n\n----------------------------------------\n\nTITLE: Displaying various data types in Starknet Foundry\nDESCRIPTION: A collection of example data values including integers, strings, hexadecimal numbers, and a large numeric value. These could represent test cases, constants, or sample inputs for Starknet smart contract testing.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/crates/forge/tests/data/file_reading/data/valid.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n1\n'hello'\n3\n\n0x678\n\n'      '\n\n\n'hello\\nworld'\n'world'\n\n\n0\n3618502788666131213697322783095070105623107215331596699973092056135872020480\n```\n\n----------------------------------------\n\nTITLE: Implementing IHelloEvent Trait and Events\nDESCRIPTION: This Cairo code defines a trait and an implementation for emitting events in a Starknet smart contract, specifically `StoredName` events. It includes the necessary attributes (`#[event]`, `#[derive]`) to define the event structure and its storage, along with the `emit_store_name` function for triggering the event emission.  The dependencies are `starknet` library and specific functions like `get_caller_address()`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/accessing_emitted_events.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n#[starknet::interface]\ntrait IHelloEvent<TContractState> {\n    fn emit_store_name(self: @TContractState, name: felt252);\n}\n\nmod HelloEvent {\n    // ...\n    \n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        StoredName: StoredName, \n    }\n\n    #[derive(Drop, starknet::Event)]\n    struct StoredName {\n        #[key]\n        user: ContractAddress,\n        name: felt252\n    }\n    \n    #[abi(embed_v0)]\n    impl IHelloEventImpl of super::IHelloEvent<ContractState> {\n        fn emit_store_name(self: @ContractState, name: felt252) {\n            // ...\n            self.emit(Event::StoredName(StoredName { user: get_caller_address(), name: name }));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Account Nonce Retrieval in Cairo\nDESCRIPTION: This snippet refers to Cairo code implementation of the nonce retrieval functionality embedded in the Rust project. It likely contains the logic querying StarkNet to fetch the nonce of an account at a given block tag. The code snippet is expected to work with Felt252 data types within Cairo and interacts with StarkNet's storage or state. The snippet supports the Rust interface by providing lower-level on-chain computation or query logic.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/get_nonce.md#_snippet_1\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../../listings/get_nonce/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Linting Code with Clippy\nDESCRIPTION: This command runs Clippy, a Rust linter, to identify potential issues and enforce code quality standards within the Starknet Foundry project.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo clippy --all-targets --all-features -- --no-deps -W clippy::pedantic -A clippy::missing_errors_doc -A clippy::missing_panics_doc -A clippy::default_trait_access\n```\n\n----------------------------------------\n\nTITLE: Changing Account Deployment Data Globally in Rust\nDESCRIPTION: Changes the transaction account deployment data for all target contracts. Takes account deployment data as a Span of felt252 values and applies the change globally until stopped.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_deployment_data.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_account_deployment_data_global(account_deployment_data: Span<felt252>)\n```\n\n----------------------------------------\n\nTITLE: ContractClass Trait Interface Definition for Deployment in Cairo\nDESCRIPTION: This code fragment provides the suggested trait interface and data structure for the improved deployment flow. `ContractClass` is defined as a struct with at least a `class_hash` member, while `ContractClassTrait` provides `precalculate_address` and `deploy` for predictable deployments. This design necessitates updating cheatcode infrastructure and integrating these traits, and expects instances with contract hashes and constructor input arrays as parameters for its methods.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/prepare_cheatcode.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\nstruct ContractClass {\n    class_hash: ClassHash\n    // ...\n}\n\ntrait ContractClassTrait {\n    fn precalculate_address(self: @ContractClass, constructor_calldata: @Array::<felt252>) -> ContractAddress;\n    fn deploy(self: @ContractClass, constructor_calldata: @Array::<felt252>) -> Result::<ContractAddress, RevertedTransaction>;\n}\n\nimpl ContractClassTrait of ContractClassTrait {\n    // ...\n}\n\nfn declare(contract: felt252) -> ContractClass;\n\n```\n\n----------------------------------------\n\nTITLE: Modifying Transaction Version for a Target with Span in Starknet Foundry\nDESCRIPTION: Modifies the transaction version for a specific contract address within a defined span. Requires a target contract address, a version value as a felt252, and a CheatSpan to define the duration of the modification.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_version.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn cheat_transaction_version(target: ContractAddress, version: felt252, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Displaying help with sncast\nDESCRIPTION: Flag for printing the help information, showing available commands and options.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n--help, -h\n```\n\n----------------------------------------\n\nTITLE: Using array!.span() in Cast Arguments\nDESCRIPTION: Describes the support for using the `array![].span()` syntax directly within the `--arguments` flag of Cast commands (`call`, `invoke`, `deploy`). This allows passing array spans as arguments without manual serialization, simplifying command-line interaction.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Cairo/Cast\nCODE:\n```\narray![].span()\n```\n\n----------------------------------------\n\nTITLE: Creating Deployment Script Template in Bash\nDESCRIPTION: This script facilitates the creation of a deployment template by generating the necessary file and directory structure for a specified script name. It creates the 'scripts' directory and nested folders, along with template files for Cairo code and project configuration. Dependencies include basic shell commands and the environment must support Bash scripting.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/script/init.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Create deployment script template\n# Usage: ./init <SCRIPT_NAME>\n\nSCRIPT_NAME=\"$1\"\n\n# Define directory structure\nmkdir -p \"scripts/$SCRIPT_NAME/src\"\n\n# Create template files\ncat <<EOF > \"scripts/$SCRIPT_NAME/Scarb.toml\"\n# Scarb configuration file for $SCRIPT_NAME\nEOF\n\ncat <<EOF > \"scripts/$SCRIPT_NAME/src/lib.cairo\"\n// Cairo library code for $SCRIPT_NAME\nEOF\n\ncat <<EOF > \"scripts/$SCRIPT_NAME/src/$SCRIPT_NAME.cairo\"\n// Cairo script: $SCRIPT_NAME\nEOF\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Status in Starknet with Rust\nDESCRIPTION: Defines a Rust function, tx_status, which queries the status of a Starknet transaction given its transaction_hash parameter of type felt252. The function returns a Result containing TxStatusResult or ScriptCommandError. Dependencies include the Starknet client libraries and types like felt252, TxStatusResult, and ScriptCommandError. The tx_status function expects a valid transaction hash and outputs a structured result with finality and execution status; it may return an error if the transaction is not found or the query fails.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/tx_status.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn tx_status(transaction_hash: felt252) -> Result<TxStatusResult, ScriptCommandError>\n```\n\n----------------------------------------\n\nTITLE: Included Cairo code snippet\nDESCRIPTION: Includes external Cairo code snippet related to the invoke command, likely containing the implementation details or additional context for the invoke operation. Requires the file path to be available at runtime.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/invoke.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../../listings/invoke/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Signature Traits Across Curves - Cairo/Rust (Test)\nDESCRIPTION: Provides a test case demonstrating the usage of the signature traits across different curves (secp256r1, secp256k1, and StarkCurve) within a Starknet test environment. It shows how to generate key pairs, sign a hypothetical message hash (`msg_hash`), and verify the resulting signatures using the trait methods implemented for each curve.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/signature.md#_snippet_4\n\nLANGUAGE: Cairo/Rust (Test)\nCODE:\n```\nuse snforge_std::signature::KeyPairTrait;\n\nuse snforge_std::signature::secp256r1_curve::{Secp256r1CurveKeyPairImpl, Secp256r1CurveSignerImpl, Secp256r1CurveVerifierImpl};\nuse snforge_std::signature::secp256k1_curve::{Secp256k1CurveKeyPairImpl, Secp256k1CurveSignerImpl, Secp256k1CurveVerifierImpl};\nuse snforge_std::signature::stark_curve::{StarkCurveKeyPairImpl, StarkCurveSignerImpl, StarkCurveVerifierImpl};\n\nuse starknet::secp256r1::{Secp256r1Point, Secp256r1PointImpl};\nuse starknet::secp256k1::{Secp256k1Point, Secp256k1PointImpl};\nuse core::starknet::SyscallResultTrait;\n\n#[test]\nfn test_using_curves() {\n    // Secp256r1\n    let key_pair = KeyPairTrait::<u256, Secp256r1Point>::generate();\n    let (r, s): (u256, u256) = key_pair.sign(msg_hash).unwrap();\n    let is_valid = key_pair.verify(msg_hash, (r, s));\n    \n    // Secp256k1\n    let key_pair = KeyPairTrait::<u256, Secp256k1Point>::generate();\n    let (r, s): (u256, u256) = key_pair.sign(msg_hash).unwrap();\n    let is_valid = key_pair.verify(msg_hash, (r, s));\n    \n    // StarkCurve\n    let key_pair = KeyPairTrait::<felt252, felt252>::generate();\n    let (r, s): (felt252, felt252) = key_pair.sign(msg_hash).unwrap();\n    let is_valid = key_pair.verify(msg_hash, (r, s));\n}\n```\n\n----------------------------------------\n\nTITLE: Cheat Block Hash for Contract - Rust\nDESCRIPTION: The `cheat_block_hash` function is a cheatcode used to change the block hash for a specific contract and block number. It takes the contract address, block number, and the new block hash as input. This allows developers to test contract behavior under different block hash scenarios.  There are no specific dependencies beyond being within a Foundry environment.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_hash.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_block_hash(contract_address: ContractAddress, block_number: u64, block_hash: felt252, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Stopping Transaction Version Modification for a Target in Starknet Foundry\nDESCRIPTION: Cancels any active transaction version modification for a specific contract address. Takes a target contract address and removes the effects of previous cheat_transaction_version or start_cheat_transaction_version calls.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_version.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_transaction_version(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Specifying Script Modules and Contracts in sncast CLI - Bash\nDESCRIPTION: These CLI examples demonstrate the proposed unified approach for referencing script modules and contracts using the sncast tool with Scarb projects. Scripts and contracts can be referenced by their path with module/package separation using '::' syntax, or by their bare name when unambiguous. If a contract or script's name is ambiguous across packages, the '--package' flag must be used to resolve it. No code dependencies are required for these CLI command usages, but Scarb workspace environment and sncast must be set up appropriately.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/sncast_interface_overhaul.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sncast script path::to::script_module\n$ sncast script to::script_module\n$ sncast script script_module\n\n$ sncast declare path::to::contract\n$ sncast declare to::contract\n$ sncast declare contract\n\n$ sncast declare --package packagea contract\n```\n\n----------------------------------------\n\nTITLE: Defining a Default sncast Profile in snfoundry.toml (TOML)\nDESCRIPTION: This code snippet shows how to define a default profile in `snfoundry.toml`.  The `[sncast.default]` section specifies the default configuration to use if no `--profile` argument is provided to `sncast`. It requires details such as the account, account file, and RPC URL.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/projects/configuration.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n# ...\n[sncast.default]\naccount = \"user123\"\naccounts-file = \"~/my_accounts.json\"\nurl = \"http://127.0.0.1:5050/rpc\"\n# ...\n```\n\n----------------------------------------\n\nTITLE: Stopping Fee Data Availability Mode for Specific Target - Rust\nDESCRIPTION: This function cancels any previously set fee data availability mode changes for a designated contract target. It takes the contract's address as its single parameter and reverts any changes applied via `cheat_fee_data_availability_mode` or `start_cheat_fee_data_availability_mode` functions. It is used to clean up or reset fee data modes after testing phases targeting individual contracts.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/fee_data_availability_mode.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_fee_data_availability_mode(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Setting up Bash Completions - Bash\nDESCRIPTION: Creates the necessary directory structure for ASDF completions and generates the Bash completion scripts for `sncast` and `snforge`, saving them to the ASDF completions directory. This prepares the files needed for enabling completions.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions\"\nsncast completion bash > \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions/sncast.bash\"\nsnforge completion bash > \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions/snforge.bash\"\n```\n\n----------------------------------------\n\nTITLE: Store and read enum value\nDESCRIPTION: This example showcases storing an `Option<u256>` value in Starknet contract storage using Snforge and subsequently reading it back. It highlights the nuances of enum storage layout, particularly the 1-based indexing for enums with derived `Store` implementations and the special case for `Option`. Dependencies include Starknet and Snforge.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/direct_storage_access/tests/using_enums.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Functions to Read Files as Arrays of felt252 in Cairo\nDESCRIPTION: Two standalone Rust functions, read_txt and read_json, each accepting a File reference and returning an Array of felt252 elements. They are designed to read either plain text or JSON files respectively and convert file data into a felt252 array suitable for further processing within Cairo programs.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/fs.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn read_txt(file: @File) -> Array<felt252>;\nfn read_json(file: @File) -> Array<felt252>;\n```\n\n----------------------------------------\n\nTITLE: Running Tests with snforge (Passing Example) - Shell\nDESCRIPTION: This shell snippet conveys test execution for a case where cheatcodes have enabled bypassing caller validation, resulting in a passing test. The output confirms that the cheatcode manipulation was effective and the test suite recognizes the altered blockchain context.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test\n\nCollected 1 test(s) from using_cheatcodes_cheat_address package\nRunning 0 test(s) from src/\nRunning 1 test(s) from tests/\n[PASS] using_cheatcodes_cheat_address_tests::call_and_invoke (l1_gas: ~0, l1_data_gas: ~288, l2_gas: ~600000)\nTests: 1 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out\n```\n\n----------------------------------------\n\nTITLE: Adding a Panicking Function to a Starknet Contract (Cairo)\nDESCRIPTION: Modifies the example contract to include a function `panic_with_felt252` that is designed to panic unconditionally. This function will be used to demonstrate error handling in tests.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_5\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/testing_smart_contracts_handling_errors/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Installing mdBook with Cargo\nDESCRIPTION: This command installs the mdBook tool using Cargo, the Rust package manager. It downloads and compiles mdBook, placing the executable in Cargo's bin directory, making it available globally in the shell.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo install mdbook\n```\n\n----------------------------------------\n\nTITLE: Generating Fish Completion Scripts - Bash\nDESCRIPTION: Generates the Fish completion scripts for `sncast` and `snforge` and saves them directly into the standard Fish completions directory (`~/.config/fish/completions`). Fish automatically loads scripts from this directory.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsncast completion fish > ~/.config/fish/completions/sncast.fish\nsnforge completion fish > ~/.config/fish/completions/snforge.fish\n```\n\n----------------------------------------\n\nTITLE: Including Cairo test code in Rust test files\nDESCRIPTION: Each snippet includes Cairo code segments via macro includes from specified file paths, integrating Cairo tests within a Rust testing environment for the smart contracts. These inclusions facilitate testing Cairo functions directly within the Rust test harness, aiding in unit testing and debugging.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/first_test/src/lib.cairo}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/panicking_test/src/lib.cairo}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/should_panic_example/src/lib.cairo:byte_array}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/should_panic_example/src/lib.cairo:felt}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/should_panic_example/src/lib.cairo:tuple}}\n```\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../listings/ignoring_example/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Enabling SafeDispatcher at Module Level (Cairo)\nDESCRIPTION: Shows how to enable the `SafeDispatcher` feature gate for an entire Cairo module using the `#[feature(\"safe_dispatcher\")]` attribute.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_13\n\nLANGUAGE: Cairo\nCODE:\n```\n#[feature(\"safe_dispatcher\")]\nmod my_module;\n```\n\n----------------------------------------\n\nTITLE: Example Deployment Script (Cairo)\nDESCRIPTION: This Cairo code snippet demonstrates a basic deployment script using the `sncast` library. It showcases the creation and deployment of accounts and contracts. It shows how to use functions from the `sncast` library to interact with the Starknet blockchain. This example uses functions for account creation, deployment, contract declaration and invocation.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/cairo_deployment_scripts.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\n// we might need to rename account functions to avoid confusion\nuse sncast::starknet_commands::account::create::create as create_account\nuse sncast::starknet_commands::account::deploy::deploy as deploy_account\nuse sncast::{get_provider, get_account};\nuse sncast::starknet_commands::{declare, deploy, invoke, call};\n(...)\n\nfn make_account(provider: &JsonRpcClient<HttpTransport>) -> Result<SingleOwnerAccount<&'a JsonRpcClient<HttpTransport>, LocalWallet>> {\n  let mut prefunder = get_account(\"user\", &provider)?; // the user that will prefund new account \n  let user = create_account(\"user1\", &provider);\n  let prefund_account = invoke(\"0x123\", \"deposit\", [1234, user.address], &prefunder);\n  deploy_account(\"user1\", &provider);\n  get_account(\"user1\", &provider)?\n}\n\nfn main() {\n  ler provider = get_provider(\"http://127.0.0.1:5050/rpc\")?;\n  let user = make_account(provider);\n\n  let declared_contract = declare(\"mycontract\", &user, \"/path/to/Scarb.toml\");\n  let contract = deploy(&declared_contract.class_hash, [], &user);\n\n  let dispatcher = DispatcherMyContract { contract.contract_address };\n\n  skip_if_done(|| {\n        dispatcher.increase_balance(5);\n    });\n  let get_balance = skip_if_done(|| {\n        dispatcher.get_balance();\n    });\n\n  let called_balance = call(&contract.contract_address, \"get_balance\", [], \"latest\"); \n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Gas Estimation for Fuzzed Tests Using snforge CLI in Shell\nDESCRIPTION: Demonstrates the expanded output format of the snforge CLI when running fuzzed tests with multiple iterations. Includes statistics for runs count and the max, min, mean, and standard deviation values of gas usage in layer 1 gas, layer 1 data gas, and layer 2 gas. This detailed statistical output helps analyze gas consumption variability across fuzzed test inputs.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/gas-and-resource-estimation.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n[PASS] tests::fuzzing_test (runs: 256, l1_gas: {max: ~126, min: ~1, mean: ~65.00, std deviation: ~37.31}, l1_data_gas: {max: ~126, min: ~1, mean: ~65.00, std deviation: ~37.31}, l2_gas: {max: ~126, min: ~1, mean: ~65.00, std deviation: ~37.31})\n```\n\n----------------------------------------\n\nTITLE: Calling a Contract Function with sncast using Default Profile (Shell)\nDESCRIPTION: This code snippet demonstrates calling a contract function with `sncast` using the default profile defined in `snfoundry.toml`.  Because a default profile is defined, the `--profile` argument is not required. It still needs the contract address, function name, and block identifier.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/projects/configuration.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast call \\\n    --contract-address 0x0589a8b8bf819b7820cb699ea1f6c409bc012c9b9160106ddc3dacd6a89653cf \\\n    --function get_balance \\\n    --block-id latest\n```\n\nLANGUAGE: shell\nCODE:\n```\ncommand: call\nresponse: [0x0]\n```\n\n----------------------------------------\n\nTITLE: Defining SpyEventsChecker Contract in Cairo\nDESCRIPTION: Defines the SpyEventsChecker contract which serves as the basis for testing event emissions in Starknet using Cairo language. This contract provides event definitions and emits events which are intercepted and tested in later examples. It is a prerequisite dependency for running the event spying and assertions demonstrated throughout the examples.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-events.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n{{#include ../../listings/testing_events/src/contract.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Proposed Cairo File Reading Interface\nDESCRIPTION: Demonstrates how to use the proposed file reading interface in Cairo. It creates a `File` instance using `FileTrait::new`, reads data from a text file using `read_txt` into an `Array<felt252>`, and then deserializes this data into a custom struct `A` using the `Serde` trait.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/loading_data_from_files.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n#[derive(Serde, Drop, PartialEq)]\nstruct A {\n    item_one: felt252,\n    item_two: felt252,\n}\n\nlet file = FileTrait::new('data/file.txt');\nlet data = read_txt(file);\n\nlet mut span = data.span();\nlet deserialized_struct: A = Serde::<A>::deserialize(ref span).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Displaying Directory Structure Using tree Command - Shell\nDESCRIPTION: This shell snippet shows usage of the `tree` command to display the contents of the `tests/` directory, highlighting several module files that will be collected for test compilation. The command requires the `tree` utility to be installed and outputs a hierarchical view of the directory. It helps developers understand which files are recognized as separate test targets by Scarb. Expected output is a plain text directory listing. Only structure is shown; no test logic is involved.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/test-collection.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ tree\n```\n\n----------------------------------------\n\nTITLE: Configuring Starknet Foundry in Github Actions Workflow - YAML\nDESCRIPTION: This YAML snippet provides an example Github Actions workflow configuration to set up the Starknet Foundry environment. It demonstrates how to utilize the setup-snfoundry and setup-scarb actions, including their parameters such as providing the path to Scarb.lock for dependency caching. All prerequisites, such as limiting support to Linux and MacOS environments, are covered. The workflow should be placed in your project's .github/workflows directory and adjusted with the appropriate file paths for your project setup.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/starknet-foundry-github-action.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n{{#include ../../example_workflows/basic_workflow.yml}}\n```\n\n----------------------------------------\n\nTITLE: Stopping Nonce Data Availability Mode Cheat for Target (Rust)\nDESCRIPTION: The stop_cheat_nonce_data_availability_mode function cancels a previously set nonce data availability mode cheat for a specific contract target. This function takes a ContractAddress parameter and undoes the effect of both cheat_nonce_data_availability_mode and start_cheat_nonce_data_availability_mode for that target. There are no outputs; the system reverts to default behavior for the given contract address.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce_data_availability_mode.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_nonce_data_availability_mode(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Creating a new Starknet Foundry project\nDESCRIPTION: Command to create a new project using the 'snforge new' command, which generates a project with a simple HelloStarknet contract. Additional templates can be specified using the --template flag.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge new hello_starknet\n```\n\n----------------------------------------\n\nTITLE: Defining File Trait for Path-based File Creation in Cairo\nDESCRIPTION: A Rust trait named FileTrait which declares a single function 'new' to instantiate a File object from a ByteArray representing the file path. It abstracts file creation logic allowing different implementations to initialize file objects from a given path string.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/fs.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait FileTrait {\n    fn new(path: ByteArray) -> File;\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Contract Function with sncast using a Profile (Shell)\nDESCRIPTION: This code snippet shows how to call a contract function using `sncast` with a defined profile.  The `--profile myprofile` argument tells `sncast` to use the configuration specified in the `myprofile` section of the `snfoundry.toml` file. It requires the contract address and function name, and block identifier to execute the call.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/projects/configuration.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast --profile myprofile \\\n    call \\\n    --contract-address 0x0589a8b8bf819b7820cb699ea1f6c409bc012c9b9160106ddc3dacd6a89653cf \\\n    --function get_balance \\\n    --block-id latest\n```\n\nLANGUAGE: shell\nCODE:\n```\ncommand: call\nresponse: [0x0]\n```\n\n----------------------------------------\n\nTITLE: Checking Spelling with Typos\nDESCRIPTION: This command executes the `typos` tool to identify spelling errors in the Starknet Foundry project, helping to maintain code readability and professional quality.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ typos\n```\n\n----------------------------------------\n\nTITLE: Default Feature Configuration in Scarb.toml (TOML)\nDESCRIPTION: This snippet shows how to configure default features in the `Scarb.toml` file. The `[features]` section defines the features, such as `enable_for_tests`, to be used for conditional compilation. The `default` key specifies which features should be enabled by default. This means the `enable_for_tests` feature is automatically activated.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/conditional-compilation.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[features]\n\ndefault = [\"enable_for_tests\"]\nenable_for_tests = []\n```\n\n----------------------------------------\n\nTITLE: Running Starknet Foundry Tests\nDESCRIPTION: This is the standard command used to execute tests within the Starknet Foundry framework (`snforge`). When run, `snforge` discovers and executes all tests, including the generated cases for parametrized tests. The output (shown in the next snippet) displays the results of each test case.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/parametrizing_tests_with_fixed_values.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nsnforge test\n```\n\n----------------------------------------\n\nTITLE: Changing max_fee for target/span cheatcode Syntax\nDESCRIPTION: This cheatcode function allows changing the transaction max fee for a specific contract target within a defined time span. It takes the target contract address, the desired maximum fee as a u128 integer, and a CheatSpan object defining the duration.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/max_fee.md#_snippet_0\n\nLANGUAGE: Syntax\nCODE:\n```\nfn cheat_max_fee(target: ContractAddress, max_fee: u128, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Generating shell completion script in foundry-rs CLI (Shell)\nDESCRIPTION: This snippet details a command for generating a shell completion script for the specified shell or auto-detected shell. It accepts an optional SHELL parameter and outputs the script to stdout, aiding users in script auto-completion setup. The command includes options for help display, and supported shells include bash, elvish, fish, powershell, and zsh.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/completion.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n# `completion`\nGenerates a completion script for the specified shell and writes it to `stdout`.\n\n## `[SHELL]`\nOptional \n\nIf not specified, the script will be generated for the shell detected under `$SHELL` variable.\n\nPossible values: `bash`, `elvish`, `fish`, `powershell`, `zsh`\n\n## `-h`, `--help`\n\nPrint help.\n```\n\n----------------------------------------\n\nTITLE: Defining EventSpy Structure\nDESCRIPTION: Defines the `EventSpy` and related structures for capturing and inspecting emitted events using the `spy_events` cheatcode.  `EventSpy` stores the emitted events, and `Event` encapsulates the event details (from, name, keys, and data). It also defines interfaces for fetching and asserting events. It depends on the felt252 and Array primitives.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/accessing_emitted_events.md#_snippet_3\n\nLANGUAGE: cairo\nCODE:\n```\nstruct EventSpy {\n    events: Array<snforge_std::Event>,\n}\n\nstruct Event {\n    from: ContractAddress,\n    name: felt252,\n    keys: Array<felt252>,\n    data: Array<felt252>\n}\n\ntrait EventFetcher {\n    fn fetch_events(ref self: EventSpy);\n}\n\ntrait EventAssertions {\n    fn assert_emitted(ref self: EventSpy, events: Array<snforge_std::Event>);\n}\n```\n\n----------------------------------------\n\nTITLE: Parametrizing Cairo Tests with Complex Types\nDESCRIPTION: Shows how the `#[test_case]` attribute can be used with complex data types, such as a struct (`MyStruct`) containing a primitive (`a: felt252`) and an array (`b: array!`). The attribute accepts a single complex type argument that corresponds to the test function's single parameter (`a: MyStruct`). The compiler is expected to generate code to initialize the struct with the provided values.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/parametrizing_tests_with_fixed_values.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\n#[test_case(MyStruct { a: 1, b: array![2, 3] })]\nfn my_test(a: MyStruct) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the MessageToL1SpyAssertionsTrait in Rust\nDESCRIPTION: Defines the `MessageToL1SpyAssertionsTrait`, providing assertion capabilities for `MessageToL1Spy` instances. The `assert_sent` method verifies if expected messages were sent, while `assert_not_sent` checks if specified messages were *not* sent within the spy's scope. Both methods operate on an array of `(ContractAddress, MessageToL1)` tuples.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_messages_to_l1.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ntrait MessageToL1SpyAssertionsTrait {\n    fn assert_sent(ref self: MessageToL1Spy, messages: @Array<(ContractAddress, MessageToL1)>);\n    fn assert_not_sent(ref self: MessageToL1Spy, messages: @Array<(ContractAddress, MessageToL1)>);\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Transaction Hash Change for Specific Target - Rust\nDESCRIPTION: Defines a function to begin changing the transaction hash for a given contract address. Requires the target contract address and the new transaction hash value of type 'felt252'. Initiates the override for the specified target until stopped or reset.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_hash.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_transaction_hash(target: ContractAddress, transaction_hash: felt252)\n```\n\n----------------------------------------\n\nTITLE: Setting Global Transaction Hash for All Targets - Rust\nDESCRIPTION: Defines a function to change the transaction hash globally across all contract targets for the current context or test. Accepts a single transaction hash value of type 'felt252' to be applied universally, enabling broad control over transaction hashes during test execution.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_hash.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_transaction_hash_global(transaction_hash: felt252)\n```\n\n----------------------------------------\n\nTITLE: Inspect Transaction Status using sncast\nDESCRIPTION: This command uses `sncast` to check the status of a Starknet transaction. It requires the transaction hash and the network to query. The output includes the `execution_status` and `finality_status` of the transaction.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/tx-status.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n tx-status \\\n 0x07d2067cd7675f88493a9d773b456c8d941457ecc2f6201d2fe6b0607daadfd1 \\\n --network sepolia\n```\n\n----------------------------------------\n\nTITLE: Configuring ZSH Completions - Bash\nDESCRIPTION: These lines, added to your ZSH configuration (e.g., `.zshrc`), add the directory containing the completion files to the `fpath` and initialize ZSH's completion system (`compinit`). This enables the generated completions.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# append completions to fpath\nfpath=(${ASDF_DATA_DIR:-$HOME/.asdf}/completions $fpath)\n# initialise completions with ZSH's compinit\nautoload -Uz compinit && compinit\n```\n\n----------------------------------------\n\nTITLE: Starting Global Transaction Version Modification in Starknet Foundry\nDESCRIPTION: Changes the transaction version for all contract addresses in the test environment. Takes a version parameter as a felt252 and applies it globally until explicitly stopped.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/transaction_version.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_transaction_version_global(version: felt252)\n```\n\n----------------------------------------\n\nTITLE: Defining Parametrized Test Cases in Cairo\nDESCRIPTION: Demonstrates how to use the proposed `#[test_case]` attribute to define multiple sets of fixed arguments for a single test function in Starknet Foundry (`snforge`). Each `#[test_case]` line specifies the values for the function's parameters in order. The `my_test` function will be implicitly run twice, once with the arguments `(1, 3)` and once with `(3, 5)`.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/parametrizing_tests_with_fixed_values.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\n#[test_case(1, 3)]\n#[test_case(3, 5)]\nfn my_test(a: felt252, b: u32) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Globally Cheat Block Hash Start - Rust\nDESCRIPTION: The `start_cheat_block_hash_global` cheatcode sets a global modification to the block hash for a specified block number. It modifies the block hash across the entire execution context until it is stopped. It takes the block number and new block hash as input.  No specific dependencies outside of the Foundry environment are present.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_hash.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_block_hash_global(block_number: u64, block_hash: felt252)\n```\n\n----------------------------------------\n\nTITLE: Specifying an account with sncast\nDESCRIPTION: Flag for specifying an account name used to interact with the network. It overrides the account from snfoundry.toml. When used with --keystore, it should be a path to a starkli account JSON file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--account, -a <ACCOUNT_NAME>\n```\n\n----------------------------------------\n\nTITLE: Modifying Fee Data Availability Mode for Target Contract - Rust\nDESCRIPTION: This function adjusts the transaction fee data availability mode for a specified contract address and a given span, enabling fine-grained control over fee data behavior during testing. It requires the target contract's address, a 32-bit unsigned integer representing the desired fee data availability mode, and a CheatSpan defining the scope or lifespan of the mode alteration. The output is a side-effect mode change within the cheatcode environment, supporting enhanced testing setups.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/fee_data_availability_mode.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn cheat_fee_data_availability_mode(target: ContractAddress, fee_data_availability_mode: u32, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Configuring Scarb to Build External Contracts (TOML)\nDESCRIPTION: This TOML configuration snippet demonstrates how to instruct Scarb to build specific contracts from project dependencies. By adding the `build-external-contracts` key under the `[[target.starknet-contract]]` section in `Scarb.toml`, developers can make external contracts like the OpenZeppelin account contract available for declaration and use within Starknet Foundry tests.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contract-collection/old-mechanism.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[[target.starknet-contract]]\nbuild-external-contracts = [\"openzeppelin::account::account::Account\"]\n```\n\n----------------------------------------\n\nTITLE: Appending Elvish Completions - Bash\nDESCRIPTION: Generates the Elvish completion scripts for `sncast` and `snforge` and appends their output to the user's Elvish runtime configuration file (`~/.config/elvish/rc.elv`). The `>>` operator ensures existing configurations are not overwritten.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsncast completion elvish >> ~/.config/elvish/rc.elv\nsnforge completion elvish >> ~/.config/elvish/rc.elv\n```\n\n----------------------------------------\n\nTITLE: Defining ContractClass Struct in Rust\nDESCRIPTION: This snippet defines the `ContractClass` struct in Rust, which represents a contract class by storing its `class_hash`. The `class_hash` is essential for interacting with deployed contracts and performing operations like deployment and address precalculation. No dependencies are explicitly stated within the provided context.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/contract_class.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct ContractClass {\n    class_hash: ClassHash,\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Panic Backtrace in Scarb.toml\nDESCRIPTION: Explains how to configure Scarb to display full backtraces when a contract panics during execution. This is achieved by setting the `panic-backtrace` key to `true` within the `Scarb.toml` configuration file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_7\n\nLANGUAGE: TOML\nCODE:\n```\npanic-backtrace = true\n```\n\n----------------------------------------\n\nTITLE: Run test using snforge\nDESCRIPTION: This shell command executes the test suite for the `using_enums` module within the `direct_storage_access` package using snforge. It's used to verify the correct storage and retrieval of enum values. Dependencies include Snforge.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/snforge-advanced-features/storage-cheatcodes.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nsnforge test test_store_and_read\n```\n\n----------------------------------------\n\nTITLE: Starting Global Fee Data Availability Mode - Rust\nDESCRIPTION: This function initiates a global change to the transaction fee data availability mode for all contract targets. It takes a single 32-bit unsigned integer parameter specifying the new global fee data availability mode to apply. This global setting affects all relevant transactions during testing until it is canceled or overridden. It requires no contract address parameter, emphasizing its global scope.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/fee_data_availability_mode.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nfn start_cheat_fee_data_availability_mode_global(fee_data_availability_mode: u32)\n```\n\n----------------------------------------\n\nTITLE: Changing Account Deployment Data for Target and Span in Rust\nDESCRIPTION: Modifies the transaction account deployment data for a specific target contract address within a defined span. Requires the target address, account deployment data as a Span of felt252 values, and a CheatSpan to define the duration of the modification.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_deployment_data.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn cheat_account_deployment_data(target: ContractAddress, account_deployment_data: Span<felt252>, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Root Package Workspace\nDESCRIPTION: This command runs tests within a Scarb workspace that has a root package. It demonstrates how to execute all tests in the root package's src and tests directories using `snforge test` without any flags.  Dependencies:  `snforge` and a properly configured Scarb workspace. Input:  No flags are used, which means the default behavior of running tests within the root package. Output:  Test results, including passes, failures, and gas usage.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/testing-workspaces.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test\n```\n\n----------------------------------------\n\nTITLE: Constructing a Starknet Contract Call Command in CLI\nDESCRIPTION: This code snippet describes the CLI command `call` used to invoke a smart contract function on Starknet. It includes required parameters for contract address and function name, and optional parameters for RPC URL, network, calldata, and block ID. The inputs include hexadecimal addresses, function names, and various identifiers for network and block, enabling flexible contract interaction.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/call.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# call a smart contract on Starknet with the specified parameters\n#\n# Required:\n# --contract-address (-a): Contract address in hex (0x...) or decimal\n# --function (-f): Function name to call\n#\n# Optional:\n# --url (-u): RPC node URL, overrides config\n# --network: Use predefined network (mainnet, sepolia)\n# --calldata (-c): List of inputs as space-delimited values\n# --block-id (-b): Block identifier (pending, latest, hash, number)\n\n```\n\n----------------------------------------\n\nTITLE: Stopping Transaction Tip Modification for Target in Rust\nDESCRIPTION: Defines `stop_cheat_tip` to cancel any ongoing tip modification for a given contract address target. It requires only the `ContractAddress` parameter and reverts tip changes applied via `cheat_tip` or `start_cheat_tip` for that target.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/tip.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_tip(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Example Cairo Test Using Proposed File Reading\nDESCRIPTION: Illustrates a hypothetical Cairo test case demonstrating the desired functionality. It reads data from 'file.txt' using a proposed `read_array_from_file` function (conceptual) and asserts its content against a hardcoded array.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/loading_data_from_files.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nlet array = array![2, 90];\nlet file_data = read_array_from_file('file.txt').unwrap();\nassert(*array[0] == *file_data[0] && *array[1] == *file_data[1], 'arrays are not equal');\n```\n\n----------------------------------------\n\nTITLE: Declaring a Starknet Test Contract - Cairo\nDESCRIPTION: This Cairo code snippet presents the basic structure of a test contract used as the subject for cheatcode manipulation. The contract typically contains state-modifying functions (e.g., increase_balance) and user validation that relies on blockchain or transaction context. It acts as a target for test demonstrations, especially where caller address checks or other context-based validation are present.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../listings/using_cheatcodes/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Cheat Block Hash Stop - Rust\nDESCRIPTION: The `stop_cheat_block_hash` function stops an active block hash modification for a specified contract and block number. This reverses the effects of the `start_cheat_block_hash` call for the given contract address and block number. This cheat takes the contract address and block number as input. It must be used after a corresponding `start_cheat_block_hash` invocation.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_hash.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_block_hash(contract_address: ContractAddress, block_number: u64)\n```\n\n----------------------------------------\n\nTITLE: Building Starknet Foundry from Source - Shell\nDESCRIPTION: Navigates into the `starknet-foundry` directory and compiles the project in release mode using `cargo build --release`. This command builds the executables and places them in the `target/release` directory.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ncd starknet-foundry && cargo build --release\n```\n\n----------------------------------------\n\nTITLE: Proposed File Organization for E2E Tests in Scarb Workspace\nDESCRIPTION: Shows the suggested directory structure for organizing end-to-end (e2e) transactional tests within a Scarb project. Tests can reside in a top-level `e2e` directory for workspace-level integration tests and within package-specific `e2e` directories.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/transactional_testing/transactional_testing.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nproject/\n Scarb.toml\n e2e/\n    test_integration.cairo\n    test_integration2.cairo\n pkg1/\n    src\n    test\n    e2e/\n        test_contract_1.cairo\n pkg2\n ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Cairo Compiler Profiles for Dev or Release in TOML\nDESCRIPTION: Defines optional compiler configuration settings under [profile.<dev|release>.cairo], enabling advanced profiling and coverage features for Cairo source compilation. Parameters include 'unstable-add-statements-code-locations-debug-info' for code location debug info, 'unstable-add-statements-functions-debug-info' for function-level debug info, and 'inlining-strategy' which determines function inlining behavior. These settings influence debugging and optimization during compilation.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[profile.dev.cairo]\nunstable-add-statements-code-locations-debug-info = true\nunstable-add-statements-functions-debug-info = true\ninlining-strategy = \"avoid\"\n```\n\n----------------------------------------\n\nTITLE: Running Tests with snforge (Failing Example) - Shell\nDESCRIPTION: This shell session snippet shows how to run tests with 'snforge test' and the resulting failed output when caller validation fails. It validates that the test suite is executed from the correct package and displays success/failure status, aiding developers in verifying the effect of context-based assertions in their Cairo tests.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/using-cheatcodes.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test\n\nCollected 1 test(s) from using_cheatcodes package\nRunning 0 test(s) from src/\nRunning 1 test(s) from tests/\n[FAIL] using_cheatcodes_tests::call_and_invoke\n\nFailure data:\n    0x75736572206973206e6f7420616c6c6f776564 ('user is not allowed')\n\nTests: 0 passed, 1 failed, 0 skipped, 0 ignored, 0 filtered out\n\nFailures:\n    using_cheatcodes_tests::call_and_invoke\n```\n\n----------------------------------------\n\nTITLE: Starting max_fee cheat for target cheatcode Syntax\nDESCRIPTION: This function begins changing the transaction maximum fee specifically for the provided contract target until explicitly stopped. It takes the target contract address and the desired maximum fee as a u128 integer.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/max_fee.md#_snippet_2\n\nLANGUAGE: Syntax\nCODE:\n```\nfn start_cheat_max_fee(target: ContractAddress, max_fee: u128)\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to cairo-coverage via snforge\nDESCRIPTION: Shell command demonstrating how to pass additional arguments to cairo-coverage through snforge using the -- separator.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/coverage.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge test --coverage -- --include macros\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Block Number Cheat in Starknet Foundry (Rust)\nDESCRIPTION: This function, 'stop_cheat_block_number_global', cancels the global block number override set by 'start_cheat_block_number_global'. It takes no parameters and resets the block number state for all targets, ensuring no global block number manipulation persists after test execution.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/block_number.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_block_number_global()\n```\n\n----------------------------------------\n\nTITLE: Example Output of sncast multicall new\nDESCRIPTION: Shows the output of the `sncast multicall new` command, including the command executed, the default generated TOML template content with placeholders for deploy and invoke calls, and the path where the file was saved.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/multicall.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncommand: multicall new\ncontent: [[call]]\ncall_type = \"deploy\"\nclass_hash = \"\"\ninputs = []\nid = \"\"\nunique = false\n\n[[call]]\ncall_type = \"invoke\"\ncontract_address = \"\"\nfunction = \"\"\ninputs = []\n\npath: ./template.toml\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Profiler/Coverage via Forge\nDESCRIPTION: Provides an example demonstrating how to pass arguments to the underlying `cairo-profiler` or `cairo-coverage` tools when running `snforge test` with `--build-profile`. Arguments appearing after the `--` separator on the command line are forwarded to the respective profiling or coverage tool.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nsnforge test --build-profile -- --show-inlined-functions\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Transaction Tip Modification in Rust\nDESCRIPTION: Defines `stop_cheat_tip_global` which cancels the global tip modification started by `start_cheat_tip_global`. This function takes no parameters and stops any universal transaction tip changes in the cheat context.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/tip.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_tip_global()\n```\n\n----------------------------------------\n\nTITLE: Verifying Scarb Installation Path (Shell)\nDESCRIPTION: Checks the installation path of the `scarb` tool using the `which` command. This is important for development with Starknet Foundry, as it requires `scarb` installed via `asdf` to ensure tests run correctly. The expected output shows the path pointing to the `asdf` shims directory.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/crates/sncast/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ which scarb\n```\n\nLANGUAGE: shell\nCODE:\n```\n# Example Output\n$HOME/.asdf/shims/scarb\n```\n\n----------------------------------------\n\nTITLE: Generating ZSH Completion Scripts - Bash\nDESCRIPTION: Creates the directory for ASDF completions and generates the ZSH completion scripts for `sncast` and `snforge`. The scripts are redirected to files in the ASDF completions directory, prefixed with `_` as is common for ZSH completion files.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions\"\nsncast completion zsh > \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions/_sncast\"\nsnforge completion zsh > \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions/_snforge\"\n```\n\n----------------------------------------\n\nTITLE: Contract with Internal Function Example in Cairo\nDESCRIPTION: A sample contract module with storage structure and an internal function that reads the balance value from storage. This demonstrates the context of a typical Starknet contract with internal functionality that needs testing.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/test_design.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\n#[starknet::contract]\nmod Contract {\n    #[storage]\n    struct Storage {\n        balance: felt252, \n        debt: felt252,\n    }\n    \n    //...\n    \n    #[generate_trait]\n    impl InternalImpl of InternalTrait {\n        fn internal_function(self: @ContractState) -> felt252 {\n            self.balance.read()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a sncast Profile - TOML\nDESCRIPTION: This TOML snippet demonstrates the basic structure for defining a profile within the `sncast` configuration.  It creates a section specifically for a profile named `myprofile`.  It serves as a starting point for configuring the various settings available for sncast, allowing users to customize behavior for different environments.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\n# ...\n```\n\n----------------------------------------\n\nTITLE: Enabling Prebuilt Plugins with tool.scarb in TOML\nDESCRIPTION: Specifies the [tool.scarb] section that allows enabling prebuilt plugins like 'snforge_std' in the Scarb package manager. This configuration requires Scarb version 2.10.0 or higher and permits downloading precompiled dependencies from the registry to avoid local compilation of Rust Cairo plugins, improving build efficiency.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/scarb-toml.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[tool.scarb]\nallow-prebuilt-plugins = [\"snforge_std\"]\n```\n\n----------------------------------------\n\nTITLE: Stopping Global Paymaster Data Cheat - Starknet Foundry Cairo\nDESCRIPTION: Cancels the active `start_cheat_paymaster_data_global` override. This restores the default transaction paymaster data behavior for all targets, effectively ending the global paymaster data cheat.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/paymaster_data.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\nfn stop_cheat_paymaster_data_global()\n```\n\n----------------------------------------\n\nTITLE: Requiring #[fuzzer] Attribute for Fuzz Tests\nDESCRIPTION: Notes that the `#[fuzzer]` attribute is now explicitly required for functions intended to be run as fuzz tests in Forge. This clearly marks fuzzable tests and ensures they are processed correctly by the Forge test runner, improving test definition clarity.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_4\n\nLANGUAGE: Cairo\nCODE:\n```\n#[fuzzer]\n```\n\n----------------------------------------\n\nTITLE: Printing the Call Trace using `println!` in Rust\nDESCRIPTION: Demonstrates how to print the `CallTrace` returned by `get_call_trace()`. The `println!` macro utilizes the `Display` trait implementation of the `CallTrace` struct to produce a formatted, indented representation of the execution trace.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/get_call_trace.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nprintln!(\"{}\", get_call_trace());\n```\n\n----------------------------------------\n\nTITLE: Setting Account Name - TOML\nDESCRIPTION: This TOML snippet configures which account from the accounts file to use. The `account` field is used to specify the account name to be used for executing transactions. It references an entry in the `accounts-file` for identifying which account to use. The account must exist in the specified account file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\naccount = \"user-dev\"\n```\n\n----------------------------------------\n\nTITLE: Stopping Nonce Cheat for a Specific Target (Rust)\nDESCRIPTION: Cancels any active nonce modification previously set by `cheat_nonce` or `start_cheat_nonce` for the specified contract address (`target`). Subsequent transactions for this target will use the actual nonce.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/nonce.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nfn stop_cheat_nonce(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Implementing Into Trait for Event Types\nDESCRIPTION: Documents the implementation of the `Into` trait for converting `starknet::Event` into `snforge_std::Event`. This allows for easier handling and assertion of events in Cairo test functions by providing a standard conversion path between different event type representations.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/CHANGELOG.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\nInto<snforge_std::Event> for starknet::Event\n```\n\n----------------------------------------\n\nTITLE: Checking snforge version\nDESCRIPTION: Command to check the currently installed version of snforge. This helps ensure compatibility with the snforge_std dependency version.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/first-steps.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ snforge --version\n```\n\n----------------------------------------\n\nTITLE: Procedural Macro for Conditional Function Execution based on Transaction State - Rust\nDESCRIPTION: Illustrates a procedural macro implementation pattern using `proc_macro_hack` to conditionally execute Rust functions depending on transaction completion state stored externally. The macro `skip_if_done` can wrap arbitrary code blocks and check if function execution is necessary based on JSON state files. This allows elegant, compile-time annotation of idempotency behavior without modifying core business logic.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/cairo_deployment_scripts.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// skip_if_done.rs\nuse proc_macro_hack::proc_macro_hack;\n\n#[proc_macro_hack]\npub use skip_if_done_impl::skip_if_done;\n\n\n// skip_if_done_impl.rs\nuse quote::quote;\nuse std::env;\n\nfn should_execute() -> bool {\n    // Your logic to check whether the function should be executed goes here\n    true\n}\n\n#[macro_export]\nmacro_rules! skip_if_done {\n    ($($tokens:tt)*) => {\n        {\n            if should_execute() {\n                $($tokens)*\n            }\n        }\n    };\n}\n\n// main.rs\n#[path = \"skip_if_done.rs\"]\nmod skip_if_done;\n\nfn main() {\n    skip_if_done! {\n        dispatcher.send_eth(...);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building the mdBook\nDESCRIPTION: This command builds the mdBook from the source files. It processes the markdown files and generates the static HTML files for the book, typically placing them in a 'book' directory.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ mdbook build\n```\n\n----------------------------------------\n\nTITLE: Display Current Configuration with sncast\nDESCRIPTION: This example shows how to use the `show-config` subcommand with the `sncast` command-line tool to display the current configuration. It specifies an account and then uses `show-config` to print the active settings.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/show_config.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ sncast \\\n  --account my_account \\\n  show-config \n```\n\n----------------------------------------\n\nTITLE: Modifying account contract address for specific target and span in Rust\nDESCRIPTION: Changes the address of an account which the transaction originates from for a specific target contract and time span. Requires target contract address, new account contract address, and span parameters.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_contract_address.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn cheat_account_contract_address(target: ContractAddress, account_contract_address: ContractAddress, span: CheatSpan)\n```\n\n----------------------------------------\n\nTITLE: Starting Account Deployment Data Change for Target in Rust\nDESCRIPTION: Initiates a change to the transaction account deployment data for a specific target contract address. The change persists until explicitly stopped with the corresponding stop function.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_deployment_data.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_account_deployment_data(target: ContractAddress, account_deployment_data: Span<felt252>)\n```\n\n----------------------------------------\n\nTITLE: Running Tests\nDESCRIPTION: This command executes all tests in the Starknet Foundry project. This is crucial for verifying the correctness of code changes and ensuring that the project remains stable.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo test\n```\n\n----------------------------------------\n\nTITLE: Generated Cairo Code for Complex Type Parametrization\nDESCRIPTION: Depicts the compiler-generated code for a parametrized test using a complex type (a struct). A new `#[test]` function is created where the test function's parameter (`a`) is initialized with the complex value (`MyStruct { a: 1, b: array![2, 3] }`) provided in the `#[test_case]` attribute. This demonstrates that complex types are handled similarly to simple types in the generation process.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/parametrizing_tests_with_fixed_values.md#_snippet_3\n\nLANGUAGE: Cairo\nCODE:\n```\n#[test]\nfn my_test_1() {\n    let a = MyStruct { a: 1, b: array![2, 3] };\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling JSON output format with sncast\nDESCRIPTION: Flag that specifies the output should be displayed in JSON format instead of the default human-readable format.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n--json, -j\n```\n\n----------------------------------------\n\nTITLE: Executing Tests with SafeDispatcher Handling (Shell)\nDESCRIPTION: Shows the command to run the snforge test suite, now including the test that uses `SafeDispatcher` to handle expected panics.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/testing/contracts.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\n$ snforge test\n```\n\n----------------------------------------\n\nTITLE: Using a keystore file with sncast\nDESCRIPTION: Flag for specifying the path to a keystore file for authentication. When specified, the --account argument must be a path to a starkli account JSON file.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast/common.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n--keystore, -k <PATH_TO_KEYSTORE_FILE>\n```\n\n----------------------------------------\n\nTITLE: Stopping global max_fee cheatcode Syntax\nDESCRIPTION: This function cancels the effect of 'start_cheat_max_fee_global', returning the transaction maximum fee behavior to its default state. It takes no arguments.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/max_fee.md#_snippet_4\n\nLANGUAGE: Syntax\nCODE:\n```\nfn stop_cheat_max_fee_global()\n```\n\n----------------------------------------\n\nTITLE: Stopping Account Deployment Data Change for Target in Rust\nDESCRIPTION: Cancels the effect of cheat_account_deployment_data or start_cheat_account_deployment_data for a specific target contract address, reverting to the original account deployment data behavior.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_deployment_data.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_account_deployment_data(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Setting account contract address for specific target in Rust\nDESCRIPTION: Changes the address of an account which the transaction originates from for a specific target contract. Requires target contract address and new account contract address parameters.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_contract_address.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn start_cheat_account_contract_address(target: ContractAddress, account_contract_address: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Canceling account contract address modification for specific target in Rust\nDESCRIPTION: Cancels previously applied account contract address modifications for a specific target contract. Requires the target contract address parameter.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_contract_address.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_account_contract_address(target: ContractAddress)\n```\n\n----------------------------------------\n\nTITLE: Sourcing Bash Completion Scripts - Bash\nDESCRIPTION: These lines should be added to your Bash configuration file (e.g., `.bashrc`) to source the generated completion scripts. Sourcing executes the script in the current shell environment, making the completions available.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/getting-started/installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# source completion scripts\n. \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions/sncast.bash\"     \n. \"${ASDF_DATA_DIR:-$HOME/.asdf}/completions/snforge.bash\"\n```\n\n----------------------------------------\n\nTITLE: Canceling global account contract address modification in Rust\nDESCRIPTION: Cancels previously applied global account contract address modifications. Takes no parameters.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/account_contract_address.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn stop_cheat_account_contract_address_global()\n```\n\n----------------------------------------\n\nTITLE: Enabling Explorer Links - TOML\nDESCRIPTION: This TOML snippet enables printing links to transaction details in the chosen block explorer. Setting `show-explorer-links` to `true` will result in `sncast` printing explorer links for the user to view the transaction details. This setting depends on the 'block-explorer' field to determine the explorer service.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\nshow-explorer-links = true\n```\n\n----------------------------------------\n\nTITLE: Setting Block Explorer - TOML\nDESCRIPTION: This TOML snippet specifies which block explorer service to use.  The `block-explorer` field can be set to 'StarkScan', 'Voyager', 'ViewBlock', or 'OkLink', each pointing to a specific block explorer website.  This setting influences where links to transaction details are generated when `show-explorer-links` is enabled.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snfoundry-toml.md#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\n[sncast.myprofile]\nblock-explorer = \"StarkScan\"\n```\n\n----------------------------------------\n\nTITLE: Displaying snforge help menu\nDESCRIPTION: This command shows the help information for the `snforge` CLI. It lists all available commands and options, providing a quick reference for users.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsnforge --help\n```\n\n----------------------------------------\n\nTITLE: Example Output of sncast multicall new with Overwrite\nDESCRIPTION: Shows the output of the `sncast multicall new --overwrite` command. The output structure and content are identical to the standard `new` command output but confirm the successful execution even if the target file previously existed.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/starknet/multicall.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncommand: multicall new\ncontent: [[call]]\ncall_type = \"deploy\"\nclass_hash = \"\"\ninputs = []\nid = \"\"\nunique = false\n\n[[call]]\ncall_type = \"invoke\"\ncontract_address = \"\"\nfunction = \"\"\ninputs = []\n\npath: ./template.toml\n```\n\n----------------------------------------\n\nTITLE: Defining FeeSettingsTrait in Rust with Procedural Macros\nDESCRIPTION: This snippet declares the FeeSettingsTrait using the #[generate_trait] procedural macro, outlining three core methods: resource_bounds for explicitly setting L1/L2 gas and price bounds, max_fee for capping transaction fees, and estimate for automatic resource estimation. Each method returns a FeeSettings object and is intended for use in transaction cost configuration logic within StarkNet Foundry. Prerequisites include importing the macro and FeeSettings type, and all inputs must match the specified integer types; improper usage may result in compile-time type errors.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/fee_settings_trait.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[generate_trait]\npub trait FeeSettingsTrait {\n    /// Sets transaction resource bounds with specified gas values.\n    fn resource_bounds(\n        l1_gas: u64,\n        l1_gas_price: u128,\n        l2_gas: u64,\n        l2_gas_price: u128,\n        l1_data_gas: u64,\n        l1_data_gas_price: u128\n    ) -> FeeSettings;\n\n    /// Ensures that total resource bounds of transaction execution won't exceed the given value.\n    fn max_fee(max_fee: felt252) -> FeeSettings;\n\n    /// Performs an automatic estimation of the resource bounds.\n    fn estimate() -> FeeSettings;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Output for Parametrized Tests in snforge\nDESCRIPTION: Provides an example of how `snforge` might display the results of running parametrized tests, as proposed in the document. It shows output lines for individual test cases, including their status (`[PASS]`, `[FAIL]`), name (showing parameter values for unnamed cases and custom names for named cases using square brackets), and any failure data like a panic message. This illustrates the proposed user experience for viewing parametrized test results.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/parametrizing_tests_with_fixed_values.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n[PASS] tests::parametrized(a = 1, b = 2)              # unnamed test case\n[PASS] tests::parametrized[a_test](a = 3, b = 5)      # named test case\n[FAIL] tests::parametrized[my_case](a = 4, b = 5)     # named test case\n\nFailure data:\n    0x50414e4943 ('PANIC')\n    \n[PASS] tests::parametrized(a = 5, b = 7)\n# ...\n```\n\n----------------------------------------\n\nTITLE: Rust function definition for invoking a StarkNet contract\nDESCRIPTION: Defines the `invoke` function in Rust to call a contract method on StarkNet. It accepts parameters such as contract address, entry point selector, calldata, fee settings, and an optional nonce, returning a Result with InvokeResult or ScriptCommandError. Dependencies include `FeeSettingsTrait` for fee configuration and the `InvokeResult` structure for outputs.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/invoke.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn invoke(\n    contract_address: ContractAddress,\n    entry_point_selector: felt252,\n    calldata: Array::<felt252>,\n    fee_settings: FeeSettings,\n    nonce: Option<felt252>\n) -> Result<InvokeResult, ScriptCommandError>\n```\n\n----------------------------------------\n\nTITLE: Defining Event Structure in Cairo\nDESCRIPTION: This snippet defines the `Event` struct used by the `expect_events` and `spy_events` cheatcodes.  It encapsulates the structure of an emitted event, including the event name, key values, and other data. This struct is critical for matching expected events during testing.  It depends on `felt252` and `Array` from the `cairo` standard library.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/design_documents/accessing_emitted_events.md#_snippet_0\n\nLANGUAGE: cairo\nCODE:\n```\nstruct Event {\n    name: felt252,\n    keys: Array<felt252>,\n    data: Array<felt252>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Signing Trait - Cairo\nDESCRIPTION: Defines the `SignerTrait`, an interface for signing messages. Implementations must provide a `sign()` method that takes a message hash (`H`) and returns a signature (`U`), typically wrapped in a `Result` to handle potential errors.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/signature.md#_snippet_2\n\nLANGUAGE: Cairo\nCODE:\n```\ntrait SignerTrait<T, H, U> {\n    fn sign(self: T, message_hash: H) -> Result<U, SignError> ;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Key Pair Generation Trait - Cairo\nDESCRIPTION: Defines the `KeyPairTrait`, an interface specifying methods for creating `KeyPair` instances. Implementations must provide a `generate()` method to create a new key pair and `from_secret_key()` to construct one from an existing secret key.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/signature.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\ntrait KeyPairTrait<SK, PK> {\n    fn generate() -> KeyPair<SK, PK>;\n    fn from_secret_key(secret_key: SK) -> KeyPair<SK, PK>;\n}\n```\n\n----------------------------------------\n\nTITLE: Included Cairo code snippet for contract call implementation details\nDESCRIPTION: References an external Cairo code snippet included in the project, which details the low-level implementation of the contract call logic used within the 'call' Rust function. This inclusion suggests integration between Rust and Cairo for contract interactions.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/call.md#_snippet_1\n\nLANGUAGE: Cairo\nCODE:\n```\n{{#include ../../../listings/call/src/lib.cairo}}\n```\n\n----------------------------------------\n\nTITLE: Defining the MessageToL1SpyTrait in Rust\nDESCRIPTION: Defines the `MessageToL1SpyTrait`, which specifies the interface for `MessageToL1Spy`. It includes the `get_messages` method to retrieve all messages captured by a specific `MessageToL1Spy` instance since its creation, returning them wrapped in a `MessagesToL1` structure.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/cheatcodes/spy_messages_to_l1.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait MessageToL1SpyTrait {\n    /// Gets all messages given [`MessageToL1Spy`] spies for.\n    fn get_messages(ref self: MessageToL1Spy) -> MessagesToL1;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of CallResult data structure in Rust\nDESCRIPTION: Defines a Rust struct 'CallResult' with Debug, Clone, and Drop traits, containing a single field 'data' which is an array of felt252 elements. This structure models the data returned from a contract call and is used as the success output of the 'call' function.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/call.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Drop, Clone, Debug)]\npub struct CallResult {\n    pub data: Array::<felt252>,\n}\n```\n\n----------------------------------------\n\nTITLE: InvokeResult data structure in Rust\nDESCRIPTION: Defines the `InvokeResult` struct with traits for Drop, Clone, and Debug in Rust. Contains a single field `transaction_hash` which is a felt252 representing the hash of the invoked transaction. This structure is used as the successful output of the invoke function.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/sncast-library/invoke.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Drop, Clone, Debug)]\npub struct InvokeResult {\n    pub transaction_hash: felt252,\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Scarb Installation\nDESCRIPTION: This command checks the location of the `scarb` executable to verify that it is installed via `asdf`. Using the `asdf` version is crucial for ensuring that tests pass correctly.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ which scarb\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Key Pair Structure - Cairo\nDESCRIPTION: Defines a generic structure, `KeyPair`, used to hold a secret key (`SK`) and its corresponding public key (`PK`). This fundamental data structure encapsulates the cryptographic key pair required for signature operations within the module.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/appendix/snforge-library/signature.md#_snippet_0\n\nLANGUAGE: Cairo\nCODE:\n```\nstruct KeyPair<SK, PK> {\n    secret_key: SK,\n    public_key: PK,\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Code with Rustfmt\nDESCRIPTION: This command formats the Rust code in the Starknet Foundry project using rustfmt, ensuring consistent code style across the project.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo fmt\n```\n\n----------------------------------------\n\nTITLE: Fixing Typos Automatically\nDESCRIPTION: This command automatically corrects some spelling errors identified by the `typos` tool in the Starknet Foundry project. This simplifies maintaining the code's spelling accuracy.\nSOURCE: https://github.com/foundry-rs/starknet-foundry/blob/master/docs/src/development/environment-setup.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ typos -w\n```"
  }
]