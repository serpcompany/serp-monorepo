[
  {
    "owner": "tobymao",
    "repo": "sqlglot",
    "content": "TITLE: Generating Candidate Matchings for Leaf Nodes in Python\nDESCRIPTION: Function to create a list of candidate matchings between leaf nodes from source and target ASTs, using similarity scoring and type matching.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom heapq import heappush, heappop\n\ncandidate_matchings = []\nsource_leaves = _get_leaves(self._source)\ntarget_leaves = _get_leaves(self._target)\nfor source_leaf in source_leaves:\n    for target_leaf in target_leaves:\n        if _is_same_type(source_leaf, target_leaf):\n            similarity_score = dice_coefficient(\n                source_leaf, target_leaf\n            )\n            if similarity_score >= 0.6:\n                heappush(\n                    candidate_matchings,\n                    (\n                        -similarity_score,\n                        len(candidate_matchings),\n                        source_leaf,\n                        target_leaf,\n                    ),\n                )\n```\n\n----------------------------------------\n\nTITLE: Optimizing SQL Queries with SQLGlot in Python\nDESCRIPTION: Shows how to use SQLGlot's optimizer to rewrite and standardize SQL queries, performing various optimization techniques.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport sqlglot\nfrom sqlglot.optimizer import optimize\n\nprint(\n    optimize(\n        sqlglot.parse_one(\"\"\"\n            SELECT A OR (B OR (C AND D))\n            FROM x\n            WHERE Z = date '2021-01-01' + INTERVAL '1' month OR 1 = 0\n        \"\"\"),\n        schema={\"x\": {\"A\": \"INT\", \"B\": \"INT\", \"C\": \"INT\", \"D\": \"INT\", \"Z\": \"STRING\"}}\n    ).sql(pretty=True)\n)\n```\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  (\n    \"x\".\"a\" <> 0 OR \"x\".\"b\" <> 0 OR \"x\".\"c\" <> 0\n  )\n  AND (\n    \"x\".\"a\" <> 0 OR \"x\".\"b\" <> 0 OR \"x\".\"d\" <> 0\n  ) AS \"_col_0\"\nFROM \"x\" AS \"x\"\nWHERE\n  CAST(\"x\".\"z\" AS DATE) = CAST('2021-02-01' AS DATE)\n```\n\n----------------------------------------\n\nTITLE: Optimizer Rule Example: Subquery Unnesting\nDESCRIPTION: Example of the unnest_subqueries optimization rule that converts subqueries in predicates into join operations, which can be more efficient to execute.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md#2025-04-20_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\n-- The subquery can be converted into a left join\nSELECT *\nFROM x AS x\nWHERE (\n  SELECT y.a AS a\n  FROM y AS y\n  WHERE x.a = y.a\n) = 1;\n\nSELECT *\nFROM x AS x\nLEFT JOIN (\n  SELECT y.a AS a\n  FROM y AS y\n  WHERE TRUE\n  GROUP BY y.a\n) AS \"_u_0\"\n  ON x.a = \"_u_0\".a\nWHERE (\"_u_0\".a = 1 AND NOT \"_u_0\".a IS NULL)\n```\n\n----------------------------------------\n\nTITLE: Optimizer Rule Example: Predicate Pushdown\nDESCRIPTION: Example of the pushdown_predicates optimization rule that pushes filter conditions into the innermost query, allowing for earlier filtering of data during execution.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md#2025-04-20_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nSELECT *\nFROM (\n  SELECT *\n  FROM x AS x\n) AS y\nWHERE y.a = 1;\n\nSELECT *\nFROM (\n  SELECT *\n  FROM x AS x\n  WHERE y.a = 1\n) AS y WHERE TRUE\n```\n\n----------------------------------------\n\nTITLE: Parsing SQL into an AST with SQLGlot in Python\nDESCRIPTION: Demonstrates how to use SQLGlot to parse a SQL query into an abstract syntax tree (AST) and display its structure using Python's repr function.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import parse_one\n\nast = parse_one(\"SELECT a FROM (SELECT a FROM x) AS x\")\n\nrepr(ast)\n\n# Select(\n#   expressions=[\n#     Column(\n#       this=Identifier(this=a, quoted=False))],\n#   from=From(\n#     this=Subquery(\n#       this=Select(\n#         expressions=[\n#           Column(\n#             this=Identifier(this=a, quoted=False))],\n#         from=From(\n#           this=Table(\n#             this=Identifier(this=x, quoted=False)))),\n#       alias=TableAlias(\n#         this=Identifier(this=x, quoted=False)))))\n```\n\n----------------------------------------\n\nTITLE: Building SQL Expressions with SQLGlot in Python\nDESCRIPTION: Demonstrates how to incrementally build SQL expressions using SQLGlot's select and condition functions. The example creates a SELECT statement with a WHERE clause.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import select, condition\n\nwhere = condition(\"x=1\").and_(\"y=1\")\nselect(\"*\").from_(\"y\").where(where).sql()\n```\n\nLANGUAGE: sql\nCODE:\n```\n'SELECT * FROM y WHERE x = 1 AND y = 1'\n```\n\n----------------------------------------\n\nTITLE: Implementing Column-Level Lineage in SQLGlot\nDESCRIPTION: Example demonstrating how to trace column-level data lineage through multiple SQL queries using SQLGlot's lineage function.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom sqlglot.lineage import lineage\n\ntarget_query = \"\"\"\nWITH cte AS (\n  SELECT\n    traced_col\n  FROM\n    intermediate_table\n)\nSELECT\n  traced_col\nFROM\n  cte\n\"\"\"\n\nnode = lineage(\n    column=\"traced_col\",\n    sql=target_query,\n    sources={\"intermediate_table\": \"SELECT * FROM root_table\"},\n    schema={\"root_table\": {\"traced_col\": \"int\"}},\n)\n```\n\n----------------------------------------\n\nTITLE: Using Scope for Semantic Analysis in SQLGlot\nDESCRIPTION: Shows how to use SQLGlot's scope module for more semantic context-aware traversal of SQL queries, including finding actual tables in a query.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot.optimizer.scope import build_scope\n\nast = parse_one(\"\"\"\nWITH x AS (\n  SELECT a FROM y\n)\nSELECT a FROM x\n\"\"\")\n\nroot = build_scope(ast)\nfor scope in root.traverse():\n    print(scope)\n\n# Scope<SELECT a FROM y>\n# Scope<WITH x AS (SELECT a FROM y) SELECT a FROM x>\n\ntables = [\n    source\n    for scope in root.traverse()\n    for alias, (node, source) in scope.selected_sources.items()\n    if isinstance(source, exp.Table)\n]\n\nfor table in tables:\n    print(table)\n\n# y  -- Success!\n```\n\n----------------------------------------\n\nTITLE: Traversing SQLGlot AST with Walk Methods\nDESCRIPTION: Demonstrates how to use SQLGlot's walk methods (find, find_all, and walk) to traverse and analyze an AST.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import exp\n\nast.find(exp.Select)\n# Select(\n#   expressions=[\n#     Column(\n#       this=Identifier(this=a, quoted=False))],\n# ...\n\nlist(ast.find_all(exp.Select))\n# [Select(\n#   expressions=[\n#     Column(\n#       this=Identifier(this=a, quoted=False))],\n# ...\n\nfor node in ast.walk():\n    ...\n```\n\n----------------------------------------\n\nTITLE: SQL Query Table Reference Replacement\nDESCRIPTION: Demonstrates how table references are replaced with their source queries, where 'intermediate_table' is replaced with its generating query and given an alias.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_8\n\nLANGUAGE: SQL\nCODE:\n```\nWITH cte AS (\n  SELECT\n    traced_col\n  FROM (\n    SELECT\n      *\n    FROM\n      root_table\n  ) AS intermediate_table\n)\nSELECT\n  traced_col\nFROM\n  cte\n```\n\n----------------------------------------\n\nTITLE: Optimizer Rule Example: Normalization to CNF\nDESCRIPTION: Example of the normalize optimization rule that converts predicates into Conjunctive Normal Form (CNF) from Disjunctive Normal Form (DNF).\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md#2025-04-20_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n-- DNF\n(A AND B) OR (B AND C AND D);\n\n-- CNF\n(A OR C) AND (A OR D) AND B;\n```\n\n----------------------------------------\n\nTITLE: Optimizer Rule Example: Expression Simplification\nDESCRIPTION: Example of the simplify optimization rule that performs boolean and mathematical expression simplification, converting complex expressions into simpler equivalent forms.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md#2025-04-20_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\n((NOT FALSE) AND (x = x)) AND (TRUE OR 1 <> 3);\nx = x;\n\n1 + 1;\n2;\n```\n\n----------------------------------------\n\nTITLE: AST Transformation Using Custom Function in Python\nDESCRIPTION: Demonstrates how to transform an AST using a custom transformer function. Shows how to replace specific column nodes with function calls in a depth-first, pre-order traversal.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef transformer(node):\n    if isinstance(node, exp.Column) and node.name == \"a\":\n        # Return a new node to replace `node`\n        return exp.func(\"FUN\", node)\n    # Or return `node` to do nothing and continue traversing the tree\n    return node\n\nprint(parse_one(\"SELECT a, b FROM x\").transform(transformer))\n# SELECT FUN(a), b FROM x\n```\n\n----------------------------------------\n\nTITLE: Creating Custom SQL Dialects in Python\nDESCRIPTION: Demonstrates how to create a custom SQL dialect by subclassing SQLGlot's Dialect class and defining custom tokenization and generation rules.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import exp\nfrom sqlglot.dialects.dialect import Dialect\nfrom sqlglot.generator import Generator\nfrom sqlglot.tokens import Tokenizer, TokenType\n\n\nclass Custom(Dialect):\n    class Tokenizer(Tokenizer):\n        QUOTES = [\"'\", '\"']\n        IDENTIFIERS = [\"`\"]\n\n        KEYWORDS = {\n            **Tokenizer.KEYWORDS,\n            \"INT64\": TokenType.BIGINT,\n            \"FLOAT64\": TokenType.DOUBLE,\n        }\n\n    class Generator(Generator):\n        TRANSFORMS = {exp.Array: lambda self, e: f\"[{self.expressions(e)}]\"}\n\n        TYPE_MAPPING = {\n            exp.DataType.Type.TINYINT: \"INT64\",\n            exp.DataType.Type.SMALLINT: \"INT64\",\n            exp.DataType.Type.INT: \"INT64\",\n            exp.DataType.Type.BIGINT: \"INT64\",\n            exp.DataType.Type.DECIMAL: \"NUMERIC\",\n            exp.DataType.Type.FLOAT: \"FLOAT64\",\n            exp.DataType.Type.DOUBLE: \"FLOAT64\",\n            exp.DataType.Type.BOOLEAN: \"BOOL\",\n            exp.DataType.Type.TEXT: \"STRING\",\n        }\n\nprint(Dialect[\"custom\"])\n```\n\nLANGUAGE: python\nCODE:\n```\n<class '__main__.Custom'>\n```\n\n----------------------------------------\n\nTITLE: Modifying Parsed SQL AST in Python\nDESCRIPTION: Shows how to parse an existing SQL query and modify its AST structure. Demonstrates in-place modification using the select method with copy=False parameter.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nast = parse_one(\"\"\"\nSELECT * FROM (SELECT a, b FROM x)\n\"\"\")\n\n# To modify the AST in-place, set `copy=False`\nast.args[\"from\"].this.this.select(\"c\", copy=False)\n\nprint(ast)\n# SELECT * FROM (SELECT a, b, c FROM x)\n```\n\n----------------------------------------\n\nTITLE: Comparing SQL Expressions with AST Diff in Python\nDESCRIPTION: Shows how to use SQLGlot's diff function to calculate the semantic difference between two SQL expressions and output the changes as a sequence of actions.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import diff, parse_one\ndiff(parse_one(\"SELECT a + b, c, d\"), parse_one(\"SELECT c, a - b, d\"))\n```\n\nLANGUAGE: python\nCODE:\n```\n[\n  Remove(expression=Add(\n    this=Column(\n      this=Identifier(this=a, quoted=False)),\n    expression=Column(\n      this=Identifier(this=b, quoted=False)))),\n  Insert(expression=Sub(\n    this=Column(\n      this=Identifier(this=a, quoted=False)),\n    expression=Column(\n      this=Identifier(this=b, quoted=False)))),\n  Keep(\n    source=Column(this=Identifier(this=a, quoted=False)),\n    target=Column(this=Identifier(this=a, quoted=False))),\n  ...\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom SQL Dialect in Python\nDESCRIPTION: Example showing how to create a custom SQL dialect by extending the base Dialect class. Includes tokenizer configuration, parser customization, and generator implementations for SQL transformations.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom sqlglot import exp\nfrom sqlglot.dialects.dialect import Dialect\nfrom sqlglot.generator import Generator\nfrom sqlglot.tokens import Tokenizer, TokenType\n\n\nclass Custom(Dialect):\n    class Tokenizer(Tokenizer):\n        QUOTES = [\"'\", '\"']  # Strings can be delimited by either single or double quotes\n        IDENTIFIERS = [\"`\"]  # Identifiers can be delimited by backticks\n\n        # Associates certain meaningful words with tokens that capture their intent\n        KEYWORDS = {\n            **Tokenizer.KEYWORDS,\n            \"INT64\": TokenType.BIGINT,\n            \"FLOAT64\": TokenType.DOUBLE,\n        }\n\n      class Parser(Parser):\n           # Specifies how certain tokens are mapped to function AST nodes\n           FUNCTIONS = {\n             **parser.Parser.FUNCTIONS,\n             \"APPROX_PERCENTILE\": exp.ApproxQuantile.from_arg_list,\n           }\n\n          # Specifies how a specific construct e.g. CONSTRAINT is parsed\n          def _parse_constraint(self) -> t.Optional[exp.Expression]:\n            return super()._parse_constraint() or self._parse_projection_def()\n\n    class Generator(Generator):\n        # Specifies how AST nodes, i.e. subclasses of exp.Expression, should be converted into SQL\n        TRANSFORMS = {\n            exp.Array: lambda self, e: f\"[{self.expressions(e)}]\",\n        }\n\n        # Specifies how AST nodes representing data types should be converted into SQL\n        TYPE_MAPPING = {\n            exp.DataType.Type.TINYINT: \"INT64\",\n            exp.DataType.Type.SMALLINT: \"INT64\",\n            ...\n        }\n```\n\n----------------------------------------\n\nTITLE: Building SQL Query Using High-Level Methods in Python\nDESCRIPTION: Demonstrates how to programmatically build SQL queries using SQLGlot's high-level builder methods. Shows method chaining for select, from, where, and limit operations.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nast = (\n    exp\n    .select(\"a\", \"b\")\n    .from_(\"x\")\n    .where(\"b < 4\")\n    .limit(10)\n)\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Queries on Python Dictionaries\nDESCRIPTION: Shows how to use SQLGlot's execute function to run SQL queries on Python dictionaries representing tables, including joins and aggregations.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot.executor import execute\n\ntables = {\n    \"sushi\": [\n        {\"id\": 1, \"price\": 1.0},\n        {\"id\": 2, \"price\": 2.0},\n        {\"id\": 3, \"price\": 3.0},\n    ],\n    \"order_items\": [\n        {\"sushi_id\": 1, \"order_id\": 1},\n        {\"sushi_id\": 1, \"order_id\": 1},\n        {\"sushi_id\": 2, \"order_id\": 1},\n        {\"sushi_id\": 3, \"order_id\": 2},\n    ],\n    \"orders\": [\n        {\"id\": 1, \"user_id\": 1},\n        {\"id\": 2, \"user_id\": 2},\n    ],\n}\n\nexecute(\n    \"\"\"\n    SELECT\n      o.user_id,\n      SUM(s.price) AS price\n    FROM orders o\n    JOIN order_items i\n      ON o.id = i.order_id\n    JOIN sushi s\n      ON i.sushi_id = s.id\n    GROUP BY o.user_id\n    \"\"\",\n    tables=tables\n)\n```\n\nLANGUAGE: python\nCODE:\n```\nuser_id price\n      1   4.0\n      2   3.0\n```\n\n----------------------------------------\n\nTITLE: Using SQL Query Optimizer with Diff Function in Python\nDESCRIPTION: This example demonstrates how to use SQLGlot's query optimizer in conjunction with the diff function to compare canonical representations of SQL queries. It optimizes the source and target queries before generating the edit script.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> schema={\"t\": {\"a\": \"INT\", \"b\": \"INT\", \"c\": \"INT\", \"d\": \"INT\"}}\n>>> source = \"\"\"\n... SELECT 1 + 1 + a\n... FROM t\n... WHERE b = 1 OR (c = 2 AND d = 3)\n... \"\"\"\n>>> target = \"\"\"\n... SELECT 2 + a\n... FROM t\n... WHERE (b = 1 OR c = 2) AND (b = 1 OR d = 3)\n... \"\"\"\n>>> optimized_source = optimize(parse_one(source), schema=schema)\n>>> optimized_target = optimize(parse_one(target), schema=schema)\n>>> edit_script = diff(optimized_source, optimized_target)\n>>> sum(0 if isinstance(e, Keep) else 1 for e in edit_script)\n0\n```\n\n----------------------------------------\n\nTITLE: Traversing Matching Set to Generate Edits in Python\nDESCRIPTION: This code snippet shows how to traverse the matching set of nodes to generate Update, Move, and Keep edits. It checks if nodes are leaf expressions or identical, and generates appropriate edit operations based on the comparison.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfor source_node, target_node in matching_set:\n    if (\n        not isinstance(source_node, LEAF_EXPRESSION_TYPES)\n        or source_node == target_node\n    ):\n        move_edits = generate_move_edits(\n            source_node, target_node, matching_set\n        )\n        edit_script.extend(move_edits)\n        edit_script.append(Keep(source_node, target_node))\n    else:\n        edit_script.append(Update(source_node, target_node))\n```\n\n----------------------------------------\n\nTITLE: Qualifying SQL Queries with Schema in SQLGlot\nDESCRIPTION: Demonstration of query qualification with schema information to expand column references and table aliases.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nimport sqlglot\nfrom sqlglot.optimizer.qualify import qualify\n\nschema = {\"tbl\": {\"col\": \"INT\"}}\nexpression = sqlglot.parse_one(\"SELECT col FROM tbl\")\nqualify(expression, schema=schema).sql()\n\n# 'SELECT \"tbl\".\"col\" AS \"col\" FROM \"tbl\" AS \"tbl\"'\n```\n\n----------------------------------------\n\nTITLE: Modifying Parsed SQL Trees in Python\nDESCRIPTION: Shows how to modify a parsed SQL tree by changing the FROM clause of a SELECT statement.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import parse_one\nparse_one(\"SELECT x FROM y\").from_(\"z\").sql()\n```\n\nLANGUAGE: sql\nCODE:\n```\n'SELECT x FROM z'\n```\n\n----------------------------------------\n\nTITLE: Matching Inner Nodes in SQL ASTs using Python\nDESCRIPTION: Function to match inner nodes of SQL ASTs based on node type, leaf node similarity, and value similarity, implementing additional heuristics for small subtrees and high leaf similarity.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nleaves_matching_set = matching_set.copy()\n\nfor source_node in unmatched_source_nodes.copy():\n    for target_node in unmatched_target_nodes:\n        if _is_same_type(source_node, target_node):\n            source_leaves = set(_get_leaves(source_node))\n            target_leaves = set(_get_leaves(target_node))\n\n            max_leaves_num = max(len(source_leaves), len(target_leaves))\n            if max_leaves_num:\n                common_leaves_num = sum(\n                    1 if s in source_leaves and t in target_leaves else 0\n                    for s, t in leaves_matching_set\n                )\n                leaf_similarity_score = common_leaves_num / max_leaves_num\n            else:\n                leaf_similarity_score = 0.0\n\n            adjusted_t = (\n                0.6\n                if min(len(source_leaves), len(target_leaves)) > 4\n                else 0.4\n            )\n\n            if leaf_similarity_score >= 0.8 or (\n                leaf_similarity_score >= adjusted_t\n                and dice_coefficient(source_node, target_node) >= 0.6\n            ):\n                matching_set.add((source_node, target_node))\n                unmatched_source_nodes.remove(source_node)\n                unmatched_target_nodes.remove(target_node)\n                break\n```\n\n----------------------------------------\n\nTITLE: Generating Move Edits Using Longest Common Subsequence in Python\nDESCRIPTION: This function generates Move edits by comparing the children of source and target nodes using the Longest Common Subsequence (LCS) algorithm. It identifies nodes that are not in the LCS and not in the unmatched source nodes as moved nodes.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef generate_move_edits(source, target, matching_set):\n    source_children = _get_child_nodes(source)\n    target_children = _get_child_nodes(target)\n\n    lcs = set(\n        _longest_common_subsequence(\n            source_children,\n            target_children,\n            lambda l, r: (l, r) in matching_set\n        )\n    )\n\n    move_edits = []\n    for node in source_children:\n        if node not in lcs and node not in unmatched_source_nodes:\n            move_edits.append(Move(node))\n\n    return move_edits\n```\n\n----------------------------------------\n\nTITLE: Qualifying Columns in SQLGlot AST\nDESCRIPTION: Demonstrates how to use SQLGlot's qualify function to prefix all columns in an AST with their table names, useful for tracing column lineage.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot.optimizer.qualify import qualify\nfrom sqlglot.optimizer.scope import find_all_in_scope\n\nast = parse_one(\"\"\"\nSELECT\n  a,\n  c\nFROM (\n  SELECT\n    a,\n    b\n  FROM x\n) AS x\nJOIN (\n  SELECT\n    b,\n    c\n  FROM y\n) AS y\n  ON x.b = y.b\n\"\"\")\n\nqualify(ast)\n# SELECT\n#   x.a AS a,\n#   y.c AS c\n# FROM (\n#   SELECT\n#     x.a AS a,\n#     x.b AS b\n#   FROM x AS x\n# ) AS x\n# JOIN (\n#   SELECT\n#     y.b AS b,\n#     y.c AS c\n#   FROM y AS y\n# ) AS y\n#   ON x.b = y.b\n\nroot = build_scope(ast)\n\nfor column in find_all_in_scope(root.expression, exp.Column):\n    print(f\"{column} => {root.sources[column.table]}\")\n\n# x.a => Scope<SELECT x.a AS a, x.b AS b FROM x AS x>\n# y.c => Scope<SELECT y.b AS b, y.c AS c FROM y AS y>\n# x.b => Scope<SELECT x.a AS a, x.b AS b FROM x AS x>\n# y.b => Scope<SELECT y.b AS b, y.c AS c FROM y AS y>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating SQL AST Diff Output in Python\nDESCRIPTION: This code snippet shows an example of using the implemented diff function to compare two SQL queries. It parses the queries into ASTs and generates an edit script, which is then displayed as a list of edit operations.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> from sqlglot import parse_one, diff\n>>> diff(parse_one(\"SELECT a + b + c, d, e\"), parse_one(\"SELECT a - b + c, e, f\"))\n\nRemove(Add)\nRemove(Column(d))\nRemove(Identifier(d))\nInsert(Sub)\nInsert(Column(f))\nInsert(Identifier(f))\nKeep(Select, Select)\nKeep(Add, Add)\nKeep(Column(a), Column(a))\nKeep(Identifier(a), Identifier(a))\nKeep(Column(b), Column(b))\nKeep(Identifier(b), Identifier(b))\nKeep(Column(c), Column(c))\nKeep(Identifier(c), Identifier(c))\nKeep(Column(e), Column(e))\nKeep(Identifier(e), Identifier(e))\n```\n\n----------------------------------------\n\nTITLE: SQL Metadata Analysis\nDESCRIPTION: Example demonstrating how to analyze SQL queries to extract metadata like column and table references.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import parse_one, exp\n\n# print all column references (a and b)\nfor column in parse_one(\"SELECT a, b + 1 AS c FROM d\").find_all(exp.Column):\n    print(column.alias_or_name)\n\n# find all projections in select statements (a and c)\nfor select in parse_one(\"SELECT a, b + 1 AS c FROM d\").find_all(exp.Select):\n    for projection in select.expressions:\n        print(projection.alias_or_name)\n\n# find all tables (x, y, z)\nfor table in parse_one(\"SELECT * FROM x JOIN y JOIN z\").find_all(exp.Table):\n    print(table.name)\n```\n\n----------------------------------------\n\nTITLE: Low-Level AST Manipulation Methods in Python\nDESCRIPTION: Illustrates different approaches to modify AST nodes using both high-level and low-level methods. Shows equivalent operations using select, set, append, and replace methods.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnode = ast.args[\"from\"].this.this\n\n# These all do the same thing:\n\n# high-level\nnode.select(\"c\", copy=False)\n# low-level\nnode.set(\"expressions\", node.expressions + [exp.column(\"c\")])\nnode.append(\"expressions\", exp.column(\"c\"))\nnode.replace(node.copy().select(\"c\"))\n```\n\n----------------------------------------\n\nTITLE: Accessing AST Nodes and Their Children in SQLGlot\nDESCRIPTION: Shows how to access nodes and their children in a SQLGlot AST using the args attribute and parent references.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nast.args\n# {\n#    \"expressions\": [Column(this=...)],\n#    \"from\": From(this=...),\n#    ...\n# }\n\nast.args[\"expressions\"][0]\n# Column(this=...)\n\nast.args[\"expressions\"][0].args[\"this\"]\n# Identifier(this=...)\n\nast.args[\"from\"]\n# From(this=...)\n\nassert ast.args[\"expressions\"][0].args[\"this\"].parent.parent is ast\n```\n\n----------------------------------------\n\nTITLE: Optimizer Rule Example: Star Expansion\nDESCRIPTION: Example of the qualify_tables and qualify_columns optimization rules that add database qualifiers to tables, force aliases, ensure unambiguous column references, and expand star (*) references.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md#2025-04-20_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nSELECT * FROM x;\n\nSELECT \"db\".\"x\" AS \"x\";\n```\n\n----------------------------------------\n\nTITLE: Expanding SQL Star Expressions in SQLGlot\nDESCRIPTION: Example showing how the qualify rule expands '*' wildcards into explicit column lists using schema information.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nimport sqlglot\nfrom sqlglot.optimizer.qualify import qualify\n\n\nschema = {\"tbl\": {\"col\": \"INT\"}}\nexpression = sqlglot.parse_one(\"SELECT * FROM tbl\")\nqualify(expression, schema=schema).sql()\n\n\n# 'SELECT \"tbl\".\"col\" AS \"col\" FROM \"tbl\" AS \"tbl\"'\n```\n\n----------------------------------------\n\nTITLE: SQL Identifier and Type Translation\nDESCRIPTION: Example showing comprehensive SQL translation including identifier delimiters and data type conversions from generic SQL to Spark SQL dialect.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sqlglot\n\n# Spark SQL requires backticks (`) for delimited identifiers and uses `FLOAT` over `REAL`\nsql = \"\"\"WITH baz AS (SELECT a, c FROM foo WHERE a = 1) SELECT f.a, b.b, baz.c, CAST(\"b\".\"a\" AS REAL) d FROM foo f JOIN bar b ON f.a = b.a LEFT JOIN baz ON f.a = baz.a\"\"\"\n\n# Translates the query into Spark SQL, formats it, and delimits all of its identifiers\nprint(sqlglot.transpile(sql, write=\"spark\", identify=True, pretty=True)[0])\n```\n\n----------------------------------------\n\nTITLE: Creating Schema Definition in SQLGlot\nDESCRIPTION: Example demonstrating how to create a MappingSchema object to represent database table structure with column names and data types.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nschema = MappingSchema({\"t\": {\"x\": \"int\", \"y\": \"datetime\"}})\n```\n\n----------------------------------------\n\nTITLE: Direct AST Node Instantiation in Python\nDESCRIPTION: Shows how to directly instantiate AST nodes using the Expression class. Creates a Column node with an identifier and appends it to existing expressions.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ncol = exp.Column(\n    this=exp.to_identifier(\"c\")\n)\nnode.append(\"expressions\", col)\n```\n\n----------------------------------------\n\nTITLE: Generating Remove and Insert Edits for Unmatched Nodes in Python\nDESCRIPTION: This snippet demonstrates how to create Remove and Insert edits for unmatched nodes from the source and target trees respectively. It iterates through unmatched nodes and appends corresponding edit operations to the edit script.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nedit_script = []\n\nfor removed_node in unmatched_source_nodes:\n    edit_script.append(Remove(removed_node))\nfor inserted_node in unmatched_target_nodes:\n    edit_script.append(Insert(inserted_node))\n```\n\n----------------------------------------\n\nTITLE: SQL Query Column Qualification\nDESCRIPTION: Shows how columns are qualified with their source tables and asterisks are expanded into explicit column references.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_9\n\nLANGUAGE: SQL\nCODE:\n```\nWITH cte AS (\n  SELECT\n    intermediate_table.traced_col\n  FROM (\n    SELECT\n      root_table.traced_col\n    FROM\n      root_table AS root_table\n  ) AS intermediate_table\n)\nSELECT\n  cte.traced_col\nFROM\n  cte AS cte\n```\n\n----------------------------------------\n\nTITLE: Inspecting SQL Abstract Syntax Trees in Python\nDESCRIPTION: Demonstrates how to view the Abstract Syntax Tree (AST) representation of a parsed SQL query using the repr function.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import parse_one\nprint(repr(parse_one(\"SELECT a + 1 AS z\")))\n```\n\nLANGUAGE: python\nCODE:\n```\nSelect(\n  expressions=[\n    Alias(\n      this=Add(\n        this=Column(\n          this=Identifier(this=a, quoted=False)),\n        expression=Literal(this=1, is_string=False)),\n      alias=Identifier(this=z, quoted=False))])\n```\n\n----------------------------------------\n\nTITLE: Normalizing SQL Identifiers in SQLGlot\nDESCRIPTION: Examples showing identifier normalization across different SQL dialects using SQLGlot's normalize_identifiers function.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nimport sqlglot\nfrom sqlglot.optimizer.normalize_identifiers import normalize_identifiers\n\nnormalize_identifiers(\"Foo\").sql()\n# 'foo'\n\nnormalize_identifiers(\"Foo\", dialect=\"snowflake\").sql(\"snowflake\")\n# 'FOO'\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Mappings in Python for SQL Parsing\nDESCRIPTION: Example showing how SQLGlot maps SQL function names to their corresponding expression implementations. Demonstrates mapping LOG2 and LOG10 functions to exp.Log expressions with appropriate base values.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nFUNCTIONS: t.Dict[str, t.Callable] = {\n    \"LOG2\": lambda args: exp.Log(this=exp.Literal.number(2), expression=seq_get(args, 0)),\n    \"LOG10\": lambda args: exp.Log(this=exp.Literal.number(10), expression=seq_get(args, 0)),\n    \"MOD\": build_mod,\n     …,\n }\n```\n\n----------------------------------------\n\nTITLE: Building Initial Matching Set for Leaf Nodes in Python\nDESCRIPTION: Function to create the initial matching set by selecting leaf node pairs with the highest similarity scores from the candidate matchings.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmatching_set = set()\nwhile candidate_matchings:\n    _, _, source_leaf, target_leaf = heappop(candidate_matchings)\n    if (\n        source_leaf in unmatched_source_nodes\n        and target_leaf in unmatched_target_nodes\n    ):\n        matching_set.add((source_leaf, target_leaf))\n        unmatched_source_nodes.remove(source_leaf)\n        unmatched_target_nodes.remove(target_leaf)\n```\n\n----------------------------------------\n\nTITLE: Example SQL Query for Execution Process Demonstration\nDESCRIPTION: A sample SQL query used to demonstrate the processing steps in the SQLGlot engine. It includes a SELECT statement with column selection, an expression, a JOIN operation, and a WHERE clause filter.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/python_sql_engine.md#2025-04-20_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT\n  bar.a,\n  b + 1 AS b\nFROM bar\nJOIN baz\n  ON bar.a = baz.a\nWHERE bar.a > 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Column Expression in SQLGlot\nDESCRIPTION: Illustrates the structure of a Column expression type in SQLGlot, showing its inheritance from Expression and its arg_types definition.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/ast_primer.md#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Column(Expression):\n    arg_types = {\n      \"this\": True,\n      \"table\": False,\n      ...\n    }\n```\n\n----------------------------------------\n\nTITLE: SQL Comment Preservation\nDESCRIPTION: Example showing how SQLGlot preserves different types of SQL comments during translation.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsql = \"\"\"\n/* multi\n   line\n   comment\n*/\nSELECT\n  tbl.cola /* comment 1 */ + tbl.colb /* comment 2 */,\n  CAST(x AS SIGNED), # comment 3\n  y               -- comment 4\nFROM\n  bar /* comment 5 */,\n  tbl #          comment 6\n\"\"\"\n\n# Note: MySQL-specific comments (`#`) are converted into standard syntax\nprint(sqlglot.transpile(sql, read='mysql', pretty=True)[0])\n```\n\n----------------------------------------\n\nTITLE: Calculating Dice Coefficient for Node Similarity in Python\nDESCRIPTION: Function to compute the dice coefficient between two nodes using their bigram histograms, used for determining node similarity in the AST matching process.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef dice_coefficient(source, target):\n    source_histo = bigram_histo(source.sql())\n    target_histo = bigram_histo(target.sql())\n\n    total_grams = (\n        sum(source_histo.values()) + sum(target_histo.values())\n    )\n    if not total_grams:\n        return 1.0 if source == target else 0.0\n\n    overlap_len = 0\n    overlapping_grams = set(source_histo) & set(target_histo)\n    for g in overlapping_grams:\n        overlap_len += min(source_histo[g], target_histo[g])\n\n    return 2 * overlap_len / total_grams\n```\n\n----------------------------------------\n\nTITLE: Tokenizing a SQL Query in Python\nDESCRIPTION: This code demonstrates how to use SQLGlot's tokenize function to break down a SQL query into individual tokens. It shows the complete token output with metadata such as token type, text, line, column, and position information.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/onboarding.md#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import tokenize\n\ntokens = tokenize(\"SELECT b FROM table WHERE c = 1\")\nfor token in tokens:\n    print(token)\n\n# <Token token_type: <TokenType.SELECT: 'SELECT'>, text: 'SELECT', line: 1, col: 6, start: 0, end: 5, comments: []>\n# <Token token_type: <TokenType.VAR: 'VAR'>, text: 'b', line: 1, col: 8, start: 7, end: 7, comments: []>\n# <Token token_type: <TokenType.FROM: 'FROM'>, text: 'FROM', line: 1, col: 13, start: 9, end: 12, comments: []>\n# <Token token_type: <TokenType.TABLE: 'TABLE'>, text: 'table', line: 1, col: 19, start: 14, end: 18, comments: []>\n# <Token token_type: <TokenType.WHERE: 'WHERE'>, text: 'WHERE', line: 1, col: 25, start: 20, end: 24, comments: []>\n# <Token token_type: <TokenType.VAR: 'VAR'>, text: 'c', line: 1, col: 27, start: 26, end: 26, comments: []>\n# <Token token_type: <TokenType.EQ: 'EQ'>, text: '=', line: 1, col: 29, start: 28, end: 28, comments: []>\n# <Token token_type: <TokenType.NUMBER: 'NUMBER'>, text: '1', line: 1, col: 31, start: 30, end: 30, comments: []>\n```\n\n----------------------------------------\n\nTITLE: Custom Time Format Translation\nDESCRIPTION: Example demonstrating translation of custom time format strings between DuckDB and Hive dialects.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sqlglot\nsqlglot.transpile(\"SELECT STRFTIME(x, '%y-%-m-%S')\", read=\"duckdb\", write=\"hive\")[0]\n```\n\n----------------------------------------\n\nTITLE: Computing Bigram Histograms in Python\nDESCRIPTION: Function to generate a histogram of bigrams from a given string, counting the occurrences of each bigram.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom collections import defaultdict\n\ndef bigram_histo(string):\n    count = max(0, len(string) - 1)\n    bigram_histo = defaultdict(int)\n    for i in range(count):\n        bigram_histo[string[i : i + 2]] += 1\n    return bigram_histo\n```\n\n----------------------------------------\n\nTITLE: SQL Dialect Translation Example\nDESCRIPTION: Example showing how to translate SQL between different dialects, specifically converting a DuckDB EPOCH_MS function to Hive syntax.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sqlglot\nsqlglot.transpile(\"SELECT EPOCH_MS(1618088028295)\", read=\"duckdb\", write=\"hive\")[0]\n```\n\n----------------------------------------\n\nTITLE: Generating Bigrams from String in Python\nDESCRIPTION: Function to create bigrams (sequences of two adjacent elements) from a given string using a sliding window approach.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/posts/sql_diff.md#2025-04-20_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef bigram(string):\n    count = max(0, len(string) - 1)\n    return [string[i : i + 2] for i in range(count)]\n```\n\n----------------------------------------\n\nTITLE: Transforming SQL Expression Trees in Python\nDESCRIPTION: Demonstrates how to recursively transform a parsed SQL expression tree by applying a custom transformation function to each node.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom sqlglot import exp, parse_one\n\nexpression_tree = parse_one(\"SELECT a FROM x\")\n\ndef transformer(node):\n    if isinstance(node, exp.Column) and node.name == \"a\":\n        return parse_one(\"FUN(a)\")\n    return node\n\ntransformed_tree = expression_tree.transform(transformer)\ntransformed_tree.sql()\n```\n\nLANGUAGE: sql\nCODE:\n```\n'SELECT FUN(a) FROM x'\n```\n\n----------------------------------------\n\nTITLE: Installing SQLGlot via pip\nDESCRIPTION: Instructions for installing SQLGlot from PyPI, with options for installing with or without the Rust tokenizer.\nSOURCE: https://github.com/tobymao/sqlglot/blob/main/README.md#2025-04-20_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip3 install \"sqlglot[rs]\"\n\n# Without Rust tokenizer (slower):\n# pip3 install sqlglot\n```"
  }
]