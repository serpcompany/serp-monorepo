[
  {
    "owner": "yjs",
    "repo": "yjs",
    "content": "TITLE: Combining Multiple Yjs Providers (JavaScript)\nDESCRIPTION: Shows how to instantiate and connect a Yjs document to multiple provider types concurrently. It combines `IndexeddbPersistence` for local caching, `WebrtcProvider` for peer-to-peer syncing, and `WebsocketProvider` for syncing via a central server. This setup allows data to be loaded quickly, persisted offline, and synced across different network technologies.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport * as Y from 'yjs'\nimport { WebrtcProvider } from 'y-webrtc'\nimport { WebsocketProvider } from 'y-websocket'\nimport { IndexeddbPersistence } from 'y-indexeddb'\n\nconst ydoc = new Y.Doc()\n\n// this allows you to instantly get the (cached) documents data\nconst indexeddbProvider = new IndexeddbPersistence('count-demo', ydoc)\nindexeddbProvider.whenSynced.then(() => {\n  console.log('loaded data from indexed db')\n})\n\n// Sync clients with the y-webrtc provider.\nconst webrtcProvider = new WebrtcProvider('count-demo', ydoc)\n\n// Sync clients with the y-websocket provider\nconst websocketProvider = new WebsocketProvider(\n  'wss://demos.yjs.dev', 'count-demo', ydoc\n)\n\n// array of numbers which produce a sum\nconst yarray = ydoc.getArray('count')\n\n// observe changes of the sum\nyarray.observe(event => {\n  // print updates when the data changes\n  console.log('new sum: ' + yarray.toArray().reduce((a,b) => a + b))\n})\n\n// add 1 to the sum\nyarray.push([1]) // => \"new sum: 1\"\n```\n\n----------------------------------------\n\nTITLE: Syncing Clients Using Delta Updates\nDESCRIPTION: This snippet demonstrates syncing two clients efficiently by exchanging only the differences between their document states. It uses `Y.encodeStateVector`, `Y.encodeStateAsUpdate`, and `Y.applyUpdate` to compute and apply updates, minimizing the amount of data transferred. It requires the `ydoc1` and `ydoc2` Y.Doc instances to be initialized.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_14\n\nLANGUAGE: js\nCODE:\n```\nconst stateVector1 = Y.encodeStateVector(ydoc1)\nconst stateVector2 = Y.encodeStateVector(ydoc2)\nconst diff1 = Y.encodeStateAsUpdate(ydoc1, stateVector2)\nconst diff2 = Y.encodeStateAsUpdate(ydoc2, stateVector1)\nY.applyUpdate(ydoc1, diff2)\nY.applyUpdate(ydoc2, diff1)\n```\n\n----------------------------------------\n\nTITLE: Using Y.UndoManager\nDESCRIPTION: This snippet demonstrates how to use the `Y.UndoManager` to implement undo/redo functionality for a Yjs text type. It creates an instance of `Y.UndoManager` associated with a `Y.Text` type, then inserts text, calls `undo()`, and then calls `redo()` to restore the original state.  The initial `doc.getText('text')` call retrieves or creates a `Y.Text` instance.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_20\n\nLANGUAGE: js\nCODE:\n```\nconst ytext = doc.getText('text')\nconst undoManager = new Y.UndoManager(ytext)\n\nytext.insert(0, 'abc')\nundoManager.undo()\nytext.toString() // => ''\nundoManager.redo()\nytext.toString() // => 'abc'\n```\n\n----------------------------------------\n\nTITLE: Observing Yjs Array Changes (JavaScript)\nDESCRIPTION: Demonstrates how to create a Yjs document and obtain a shared array (`Y.Array`). An observer function is attached using `observe()` to react to any local or remote modifications to the array. The snippet shows triggering this observer by inserting a value into the array.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport * as Y from 'yjs';\n\nconst doc = new Y.Doc();\nconst yarray = doc.getArray('my-array')\nyarray.observe(event => {\n  console.log('yarray was modified')\n})\n// every time a local or remote client modifies yarray, the observer is called\nyarray.insert(0, ['val']) // => \"yarray was modified\"\n```\n\n----------------------------------------\n\nTITLE: Importing the Yjs Library (JavaScript)\nDESCRIPTION: The standard JavaScript import statement used to bring the Yjs library's functionality into scope. It imports all exports from the 'yjs' package under the namespace `Y`, making its classes and functions accessible via `Y.Doc`, `Y.Array`, etc. This is the first step in using the Yjs API.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nimport * as Y from 'yjs'\n```\n\n----------------------------------------\n\nTITLE: Inserting Text with Formatting in Y.Text\nDESCRIPTION: This code shows how to insert formatted text into a Y.Text instance.  The `insert` method allows specifying attributes that define the formatting (e.g., bold, italics) of the inserted text.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nytext.insert(0, 'bold text', { bold: true })\n```\n\n----------------------------------------\n\nTITLE: Nesting Yjs Types and Uniqueness Constraint (JavaScript)\nDESCRIPTION: Illustrates how to nest one shared Yjs type (`Y.Array`) within another (`Y.Map`). It demonstrates setting the array as a value in the map and then attempts to set the *same* array instance again under a different key, which results in an error due to the constraint that a shared type must be defined only once per document.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst ymap = doc.getMap('map')\nconst foodArray = new Y.Array()\nfoodArray.insert(0, ['apple', 'banana'])\nymap.set('food', foodArray)\nymap.get('food') === foodArray // => true\nymap.set('fruit', foodArray) // => Error! foodArray is already defined\n```\n\n----------------------------------------\n\nTITLE: Installing Yjs and Provider with npm (Shell)\nDESCRIPTION: Installs the Yjs core library and the y-websocket provider package using the Node Package Manager (npm). This command is typically run in the project's root directory to add these dependencies. Requires Node.js and npm to be installed.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm i yjs y-websocket\n```\n\n----------------------------------------\n\nTITLE: Initializing Y.Text\nDESCRIPTION: This code snippet demonstrates how to create a new instance of the Y.Text shared type in Yjs.  Y.Text is designed for collaborative text editing and allows assigning properties to ranges of text, enabling rich-text features.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst ytext = new Y.Text()\n```\n\n----------------------------------------\n\nTITLE: Initializing Y.Array\nDESCRIPTION: This code snippet demonstrates how to create a new instance of the Y.Array shared type in Yjs.  Y.Array is used to represent a shareable array-like data structure that supports efficient insertion and deletion of elements at any position.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst yarray = new Y.Array()\n```\n\n----------------------------------------\n\nTITLE: Initializing Y.Map\nDESCRIPTION: This code snippet shows how to create a new instance of the Y.Map shared type in Yjs.  Y.Map is used to represent a shareable Map data structure that holds key-value pairs.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst ymap = new Y.Map()\n```\n\n----------------------------------------\n\nTITLE: Transforming to RelativePosition and Back\nDESCRIPTION: This example shows how to create a relative position using `Y.createRelativePositionFromTypeIndex` and transform it into an absolute position using `Y.createAbsolutePositionFromRelativePosition`. The main purpose is to demonstrate the utility of `RelativePosition` which makes position tracking resilient to document changes.  It checks that type and index matches after transformation.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_17\n\nLANGUAGE: js\nCODE:\n```\nconst relPos = Y.createRelativePositionFromTypeIndex(ytext, 2)\nconst pos = Y.createAbsolutePositionFromRelativePosition(relPos, doc)\npos.type === ytext // => true\npos.index === 2 // => true\n```\n\n----------------------------------------\n\nTITLE: Sending Relative Position to Remote Client (Uint8Array)\nDESCRIPTION: This example shows how to encode a relative position into a Uint8Array using `Y.encodeRelativePosition` and send it to a remote client, then decode it on the client side using `Y.decodeRelativePosition` and transform it into an absolute position using `Y.createAbsolutePositionFromRelativePosition`.  Uses binary encoding for more efficient transfer of relative positions. Requires setup of `remoteDoc` and `remoteytext` on the remote client.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_19\n\nLANGUAGE: js\nCODE:\n```\nconst relPos = Y.createRelativePositionFromTypeIndex(ytext, 2)\nconst encodedRelPos = Y.encodeRelativePosition(relPos)\n// send encodedRelPos to remote client..\nconst parsedRelPos = Y.decodeRelativePosition(encodedRelPos)\nconst pos = Y.createAbsolutePositionFromRelativePosition(parsedRelPos, remoteDoc)\npos.type === remoteytext // => true\npos.index === 2 // => true\n```\n\n----------------------------------------\n\nTITLE: Sending Relative Position to Remote Client (JSON)\nDESCRIPTION: This snippet demonstrates how to serialize a relative position to JSON using `JSON.stringify` and send it to a remote client, then deserialize it using `JSON.parse` to retrieve the position using `Y.createAbsolutePositionFromRelativePosition`. This approach allows relative positions to be exchanged across clients over a network, using standard JSON format.  Requires the receiving client's `remoteDoc` and `remoteytext` to be setup.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_18\n\nLANGUAGE: js\nCODE:\n```\nconst relPos = Y.createRelativePositionFromTypeIndex(ytext, 2)\nconst encodedRelPos = JSON.stringify(relPos)\n// send encodedRelPos to remote client..\nconst parsedRelPos = JSON.parse(encodedRelPos)\nconst pos = Y.createAbsolutePositionFromRelativePosition(parsedRelPos, remoteDoc)\npos.type === remoteytext // => true\npos.index === 2 // => true\n```\n\n----------------------------------------\n\nTITLE: Applying Delta to Y.Text\nDESCRIPTION: This code demonstrates how to apply a Quill Delta to a Y.Text instance. The applyDelta method allows for synchronizing changes to a Y.Text object based on a Quill Delta, with the option to sanitize or not sanitize.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nytext.applyDelta(delta, { sanitize: false })\n```\n\n----------------------------------------\n\nTITLE: Starting y-websocket Server (Shell)\nDESCRIPTION: Executes the y-websocket server script located within the installed node_modules directory. It sets the `PORT` environment variable to `1234` before running the server, allowing it to listen on that specific port. Requires Node.js and the `y-websocket` package installed.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nPORT=1234 node ./node_modules/y-websocket/bin/server.cjs\n```\n\n----------------------------------------\n\nTITLE: Syncing Clients without Y.Doc Loading\nDESCRIPTION: This snippet shows how to sync clients and compute delta updates directly on the binary document updates without loading the Yjs document to memory. It uses `Y.encodeStateAsUpdate`, `Y.encodeStateVectorFromUpdate`, `Y.diffUpdate`, and `Y.mergeUpdates`.  The original `ydoc1` and `ydoc2` are destroyed after generating initial states.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_15\n\nLANGUAGE: js\nCODE:\n```\nlet currentState1 = Y.encodeStateAsUpdate(ydoc1)\nlet currentState2 = Y.encodeStateAsUpdate(ydoc2)\n// now we can continue syncing clients using state vectors without using the Y.Doc\nydoc1.destroy()\nydoc2.destroy()\n\nconst stateVector1 = Y.encodeStateVectorFromUpdate(currentState1)\nconst stateVector2 = Y.encodeStateVectorFromUpdate(currentState2)\nconst diff1 = Y.diffUpdate(currentState1, stateVector2)\nconst diff2 = Y.diffUpdate(currentState2, stateVector1)\n\n// sync clients\ncurrentState1 = Y.mergeUpdates([currentState1, diff2])\ncurrentState2 = Y.mergeUpdates([currentState2, diff1])\n```\n\n----------------------------------------\n\nTITLE: Specifying Tracked Origins for UndoManager - JavaScript\nDESCRIPTION: Illustrates how to control which changes are tracked by the UndoManager using the `trackedOrigins` option. Dependencies include Yjs library. This enables selective tracking of changes based on the origin, which can be a number or a custom class. It shows how origins affect undo operations.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_22\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass CustomBinding {}\n\nconst ytext = doc.getText('text')\nconst undoManager = new Y.UndoManager(ytext, {\n  trackedOrigins: new Set([42, CustomBinding])\n})\n\nytext.insert(0, 'abc')\nundoManager.undo()\nytext.toString() // => 'abc' (does not track because origin `null` and not part\n                 //           of `trackedTransactionOrigins`)\nytext.delete(0, 3) // revert change\n\ndoc.transact(() => {\n  ytext.insert(0, 'abc')\n}, 42)\nundoManager.undo()\nytext.toString() // => '' (tracked because origin is an instance of `trackedTransactionorigins`)\n\ndoc.transact(() => {\n  ytext.insert(0, 'abc')\n}, 41)\nundoManager.undo()\nytext.toString() // => 'abc' (not tracked because 41 is not an instance of\n                 //        `trackedTransactionorigins`)\nytext.delete(0, 3) // revert change\n\ndoc.transact(() => {\n  ytext.insert(0, 'abc')\n}, new CustomBinding())\nundoManager.undo()\nytext.toString() // => '' (tracked because origin is a `CustomBinding` and\n                 //        `CustomBinding` is in `trackedTransactionorigins`)\n```\n\n----------------------------------------\n\nTITLE: Adding Meta Information to StackItems - JavaScript\nDESCRIPTION: Demonstrates how to add and retrieve meta information for Undo/Redo StackItems.  It uses the `stack-item-added` and `stack-item-popped` events to store and restore custom data (cursor location).  Requires the Yjs library and a YText and UndoManager instance.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_23\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst ytext = doc.getText('text')\nconst undoManager = new Y.UndoManager(ytext, {\n  trackedOrigins: new Set([42, CustomBinding])\n})\n\nundoManager.on('stack-item-added', event => {\n  // save the current cursor location on the stack-item\n  event.stackItem.meta.set('cursor-location', getRelativeCursorLocation())\n})\n\nundoManager.on('stack-item-popped', event => {\n  // restore the current cursor location on the stack-item\n  restoreCursorLocation(event.stackItem.meta.get('cursor-location'))\n})\n```\n\n----------------------------------------\n\nTITLE: Stopping UndoManager Capture - JavaScript\nDESCRIPTION: Demonstrates how to stop the UndoManager from merging StackItems based on `captureTimeout`.  Requires Yjs library and a YText instance. The code shows how `stopCapturing()` prevents merging of inserts in a specific scenario, affecting how the undo operation works.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_21\n\nLANGUAGE: JavaScript\nCODE:\n```\n// without stopCapturing\nytext.insert(0, 'a')\nytext.insert(1, 'b')\nundoManager.undo()\nytext.toString() // => '' (note that 'ab' was removed)\n// with stopCapturing\nytext.insert(0, 'a')\nundoManager.stopCapturing()\nytext.insert(0, 'b')\nundoManager.undo()\nytext.toString() // => 'a' (note that only 'b' was removed)\n```\n\n----------------------------------------\n\nTITLE: Using Y.Map Iterator\nDESCRIPTION: This snippet demonstrates iterating over the key-value pairs of a Y.Map using a for...of loop.  Each iteration provides access to both the key and the value associated with it.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nfor (let [key, value] of ymap) { .. }\n```\n\n----------------------------------------\n\nTITLE: Using Y.Array Iterator\nDESCRIPTION: This snippet showcases how to iterate over the elements of a Y.Array using a for...of loop.  This allows accessing the values stored within the Y.Array in a sequential manner.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nfor (let value of yarray) { .. }\n```\n\n----------------------------------------\n\nTITLE: Obfuscating Document Updates\nDESCRIPTION: This snippet illustrates how to obfuscate a Yjs document update to protect user data while allowing updates to be merged. It demonstrates the use of `Y.encodeStateAsUpdate` to generate an update and `Y.obfuscateUpdate` to scramble the data within the update.  This can be useful when a user encounters a bug; the obfuscated data helps in reproducing the issue without compromising the user's actual data.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst ydoc = new Y.Doc()\n// perform some changes..\nydoc.getText().insert(0, 'hello world')\nconst update = Y.encodeStateAsUpdate(ydoc)\n// the below update contains scrambled data\nconst obfuscatedUpdate = Y.obfuscateUpdate(update)\nconst ydoc2 = new Y.Doc()\nY.applyUpdate(ydoc2, obfuscatedUpdate)\nydoc2.getText().toString() // => \"00000000000\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Y.XmlFragment\nDESCRIPTION: This code snippet illustrates how to create a new instance of the Y.XmlFragment shared type in Yjs.  Y.XmlFragment serves as a container for an array of Y.XmlElements, facilitating collaborative XML document manipulation.\nSOURCE: https://github.com/yjs/yjs/blob/main/README.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst yxml = new Y.XmlFragment()\n```"
  }
]