[
  {
    "owner": "groue",
    "repo": "grdb.swift",
    "content": "TITLE: Implementing Database Record Types in GRDB\nDESCRIPTION: This example shows how to define a struct as a database record type, create a corresponding database table, and perform insert and update operations on record instances.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    var coordinate: CLLocationCoordinate2D\n}\n\n// snip: turn Place into a \"record\" by adopting the protocols that\n// provide fetching and persistence methods.\n\ntry dbQueue.write { db in\n    // Create database table\n    try db.create(table: \"place\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.column(\"title\", .text).notNull()\n        t.column(\"favorite\", .boolean).notNull().defaults(to: false)\n        t.column(\"longitude\", .double).notNull()\n        t.column(\"latitude\", .double).notNull()\n    }\n    \n    var berlin = Place(\n        id: nil,\n        title: \"Berlin\",\n        isFavorite: false,\n        coordinate: CLLocationCoordinate2D(latitude: 52.52437, longitude: 13.41053))\n    \n    try berlin.insert(db)\n    berlin.id // some value\n    \n    berlin.isFavorite = true\n    try berlin.update(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL Statements in GRDB\nDESCRIPTION: This example shows how to execute raw SQL statements for creating tables and inserting data, including using SQL interpolation to safely insert values without SQL injection risks.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.execute(sql: \"\"\"\n        CREATE TABLE place (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          title TEXT NOT NULL,\n          favorite BOOLEAN NOT NULL DEFAULT 0,\n          latitude DOUBLE NOT NULL,\n          longitude DOUBLE NOT NULL)\n        \"\"\")\n    \n    try db.execute(sql: \"\"\"\n        INSERT INTO place (title, favorite, latitude, longitude)\n        VALUES (?, ?, ?, ?)\n        \"\"\", arguments: [\"Paris\", true, 48.85341, 2.3488])\n    \n    let parisId = db.lastInsertedRowID\n    \n    // Avoid SQL injection with SQL interpolation\n    try db.execute(literal: \"\"\"\n        INSERT INTO place (title, favorite, latitude, longitude)\n        VALUES (\\(\"King's Cross\"), \\(true), \\(51.52151), \\(-0.12763))\n        \"\"\")\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Database Setup and Usage in Swift with GRDB\nDESCRIPTION: This snippet demonstrates the four basic steps to start using GRDB: opening a database connection, defining a schema, creating a record type, and performing read/write operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport GRDB\n\n// 1. Open a database connection\nlet dbQueue = try DatabaseQueue(path: \"/path/to/database.sqlite\")\n\n// 2. Define the database schema\ntry dbQueue.write { db in\n    try db.create(table: \"player\") { t in\n        t.primaryKey(\"id\", .text)\n        t.column(\"name\", .text).notNull()\n        t.column(\"score\", .integer).notNull()\n    }\n}\n\n// 3. Define a record type\nstruct Player: Codable, FetchableRecord, PersistableRecord {\n    var id: String\n    var name: String\n    var score: Int\n}\n\n// 4. Write and read in the database\ntry dbQueue.write { db in\n    try Player(id: \"1\", name: \"Arthur\", score: 100).insert(db)\n    try Player(id: \"2\", name: \"Barbara\", score: 1000).insert(db)\n}\n\nlet players: [Player] = try dbQueue.read { db in\n    try Player.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using GRDB in Swift\nDESCRIPTION: This snippet demonstrates the basic usage of GRDB, including opening a database connection, defining a schema, creating a record type, and performing write and read operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/GRDB.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport GRDB\n\n// 1. Open a database connection\nlet dbQueue = try DatabaseQueue(path: \"/path/to/database.sqlite\")\n\n// 2. Define the database schema\ntry dbQueue.write { db in\n    try db.create(table: \"player\") { t in\n        t.primaryKey(\"id\", .text)\n        t.column(\"name\", .text).notNull()\n        t.column(\"score\", .integer).notNull()\n    }\n}\n\n// 3. Define a record type\nstruct Player: Codable, FetchableRecord, PersistableRecord {\n    var id: String\n    var name: String\n    var score: Int\n}\n\n// 4. Write and read in the database\ntry dbQueue.write { db in\n    try Player(id: \"1\", name: \"Arthur\", score: 100).insert(db)\n    try Player(id: \"2\", name: \"Barbara\", score: 1000).insert(db)\n}\n\nlet players: [Player] = try dbQueue.read { db in\n    try Player.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Column Selection for Individual Requests in GRDB Swift\nDESCRIPTION: Shows how to modify the columns selected for a specific query using the select() method. The examples demonstrate selecting aggregate functions and specifying the return type.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_148\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.select(max(Column(\"score\")))\nlet maxScore = try Int.fetchOne(db, request) // Int?\n\nlet request = Player.select(max(Column(\"score\")), as: Int.self)\nlet maxScore = try request.fetchOne(db)      // Int?\n```\n\n----------------------------------------\n\nTITLE: Using Query Interface in GRDB.swift\nDESCRIPTION: Example demonstrating GRDB's query interface for database operations including schema updates, fetching records with filters, counting, updating, and deleting records using a Swift-based API instead of raw SQL.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_117\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Update database schema\n    try db.create(table: \"wine\") { t in ... }\n    \n    // Fetch records\n    let wines = try Wine\n        .filter(originColumn == \"Burgundy\")\n        .order(priceColumn)\n        .fetchAll(db)\n    \n    // Count\n    let count = try Wine\n        .filter(colorColumn == Color.red)\n        .fetchCount(db)\n    \n    // Update\n    try Wine\n        .filter(originColumn == \"Burgundy\")\n        .updateAll(db, priceColumn *= 0.75)\n    \n    // Delete\n    try Wine\n        .filter(corkedColumn == true)\n        .deleteAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Raw Database Rows and Values in GRDB\nDESCRIPTION: This snippet demonstrates how to fetch and process raw database rows and individual values using GRDB, including reading typed values from rows and fetching scalar values directly.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    // Fetch database rows\n    let rows = try Row.fetchCursor(db, sql: \"SELECT * FROM place\")\n    while let row = try rows.next() {\n        let title: String = row[\"title\"]\n        let isFavorite: Bool = row[\"favorite\"]\n        let coordinate = CLLocationCoordinate2D(\n            latitude: row[\"latitude\"],\n            longitude: row[\"longitude\"])\n    }\n    \n    // Fetch values\n    let placeCount = try Int.fetchOne(db, sql: \"SELECT COUNT(*) FROM place\")! // Int\n    let placeTitles = try String.fetchAll(db, sql: \"SELECT title FROM place\") // [String]\n}\n\nlet placeCount = try dbQueue.read { db in\n    try Int.fetchOne(db, sql: \"SELECT COUNT(*) FROM place\")!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Table for Places in Swift using GRDB\nDESCRIPTION: Example of creating a database table named 'place' with columns for id, title, isFavorite flag, and geographic coordinates using GRDB's table creation DSL.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_113\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.create(table: \"place\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.column(\"title\", .text).notNull()\n        t.column(\"isFavorite\", .boolean).notNull().defaults(to: false)\n        t.column(\"longitude\", .double).notNull()\n        t.column(\"latitude\", .double).notNull()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Column Values in GRDB.swift\nDESCRIPTION: Demonstrates how to read values from database row columns by index, name, or using the query interface's Column type. These methods provide different ways to access the same underlying data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\nlet name: String = row[0]      // 0 is the leftmost column\nlet name: String = row[\"name\"] // Leftmost matching column - lookup is case-insensitive\nlet name: String = row[Column(\"name\")] // Using query interface's Column\n```\n\n----------------------------------------\n\nTITLE: Row Fetching Operations in GRDB.swift\nDESCRIPTION: Demonstrates various methods for fetching rows from the database, including cursor, array, set, and single row fetching.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    try Row.fetchCursor(db, sql: \"SELECT ...\", arguments: ...) // A Cursor of Row\n    try Row.fetchAll(db, sql: \"SELECT ...\", arguments: ...)    // [Row]\n    try Row.fetchSet(db, sql: \"SELECT ...\", arguments: ...)    // Set<Row>\n    try Row.fetchOne(db, sql: \"SELECT ...\", arguments: ...)    // Row?\n    \n    let rows = try Row.fetchCursor(db, sql: \"SELECT * FROM wine\")\n    while let row = try rows.next() {\n        let name: String = row[\"name\"]\n        let color: Color = row[\"color\"]\n        print(name, color)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Records from Requests in Swift using GRDB\nDESCRIPTION: This snippet demonstrates how to fetch records using different methods provided by GRDB. It shows how to use fetchCursor, fetchAll, fetchSet, and fetchOne to retrieve Player records based on a request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_176\n\nLANGUAGE: swift\nCODE:\n```\n// Some request based on `Player`\nlet request = Player.filter(...)... // QueryInterfaceRequest<Player>\n\n// Fetch players:\ntry request.fetchCursor(db) // A Cursor of Player\ntry request.fetchAll(db)    // [Player]\ntry request.fetchSet(db)    // Set<Player>\ntry request.fetchOne(db)    // Player?\n```\n\n----------------------------------------\n\nTITLE: Using Raw SQL in GRDB Swift Queries\nDESCRIPTION: Shows how to incorporate raw SQL snippets into query interface requests. This approach allows for complex SQL operations while still using the query builder pattern.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_146\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT DATE(creationDate), COUNT(*) FROM player WHERE name = 'Arthur' GROUP BY date(creationDate)\nPlayer\n    .select(sql: \"DATE(creationDate), COUNT(*)\")\n    .filter(sql: \"name = ?\", arguments: [\"Arthur\"])\n    .group(sql: \"DATE(creationDate)\")\n```\n\n----------------------------------------\n\nTITLE: GRDB Record Persistence Operations in Swift\nDESCRIPTION: Examples of basic persistence operations including insert, update, delete and existence checks for PersistableRecord types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_79\n\nLANGUAGE: swift\nCODE:\n```\n// INSERT\ntry place.insert(db)\nlet insertedPlace = try place.inserted(db) // non-mutating\n\n// UPDATE\ntry place.update(db)\ntry place.update(db, columns: [\"title\"])\n\n// Maybe UPDATE\ntry place.updateChanges(db, from: otherPlace)\ntry place.updateChanges(db) { $0.isFavorite = true }\n\n// INSERT or UPDATE\ntry place.save(db)\nlet savedPlace = place.saved(db) // non-mutating\n\n// UPSERT\ntry place.upsert(db)\nlet insertedPlace = place.upsertAndFetch(db)\n\n// DELETE\ntry place.delete(db)\n\n// EXISTENCE CHECK\nlet exists = try place.exists(db)\n```\n\n----------------------------------------\n\nTITLE: Avoiding SQL Injection with Statement Arguments\nDESCRIPTION: Demonstrates proper techniques for handling string values in SQL queries to avoid SQL injection vulnerabilities and the \"no such column\" error that can occur with double-quoted string literals in recent SQLite versions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_234\n\nLANGUAGE: swift\nCODE:\n```\nlet name: String = ...\n\n// NOT STANDARD (double quote)\ntry db.execute(sql: \"\"\"\n    UPDATE player SET name = \"\\(name)\"\n    \"\"\")\n\n// STANDARD, BUT STILL NOT RECOMMENDED (single quote)\ntry db.execute(sql: \"UPDATE player SET name = '\\(name)'\")\n\n// STANDARD, AND RECOMMENDED (statement arguments)\ntry db.execute(sql: \"UPDATE player SET name = ?\", arguments: [name])\n```\n\n----------------------------------------\n\nTITLE: Initializing DatabaseQueue and DatabasePool in Swift\nDESCRIPTION: Demonstrates how to create database connections using DatabaseQueue and DatabasePool classes. DatabaseQueue is recommended for most use cases, while DatabasePool allows concurrent access and uses WAL mode.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_7\n\nLANGUAGE: Swift\nCODE:\n```\nimport GRDB\n\n// Pick one:\nlet dbQueue = try DatabaseQueue(path: \"/path/to/database.sqlite\")\nlet dbPool = try DatabasePool(path: \"/path/to/database.sqlite\")\n```\n\n----------------------------------------\n\nTITLE: Performing Database Transactions with GRDB in Swift\nDESCRIPTION: Examples of database transactions using DatabaseQueue. The code demonstrates how to perform read and write operations within transaction boundaries, which ensure database integrity and concurrency safety.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Inside a transaction\n}\n\ntry dbQueue.read { db\n    // Inside a transaction\n}\n```\n\n----------------------------------------\n\nTITLE: SQL Interpolation for Query Arguments in GRDB.swift\nDESCRIPTION: Shows how to use SQL interpolation to embed query arguments directly into SQL statements using the execute(literal:) method, which safely handles parameter escaping to prevent SQL injection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    let name = \"O'Brien\"\n    let score = 550\n    try db.execute(literal: \"\"\"\n        INSERT INTO player (name, score) VALUES (\\(name), \\(score))\n        \"\"\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Associations to Fetch Related Records in GRDB\nDESCRIPTION: Example showing how to use associations to fetch related records. The code demonstrates fetching all novels from a specific author using the defined association between Author and Book.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n// Fetch all novels from an author\ntry dbQueue.read { db in\n    let author: Author = ...\n    let novels: [Book] = try author.request(for: Author.books)\n        .filter(kind: .novel)\n        .orderByTitle()\n        .fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Using insertAndFetch to Insert Partial Data and Retrieve Complete Record\nDESCRIPTION: Demonstrates how to insert a partial record and fetch the complete record with auto-generated and default values using the RETURNING clause. This method retrieves all columns from the inserted record.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_86\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    let partialPlayer = PartialPlayer(name: \"Alice\")\n    \n    // INSERT INTO player (name) VALUES ('Alice') RETURNING *\n    let player = try partialPlayer.insertAndFetch(db, as: Player.self)\n    print(player.id)    // The inserted id\n    print(player.name)  // The inserted name\n    print(player.score) // The default score\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a database in an application's support directory\nDESCRIPTION: This snippet demonstrates how to create or open a database file in the Application Support directory, following recommended practices for database file management.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_220\n\nLANGUAGE: swift\nCODE:\n```\n// HOW TO create an empty database, or open an existing database file\n\n// Create the \"Application Support/MyDatabase\" directory\nlet fileManager = FileManager.default\nlet appSupportURL = try fileManager.url(\n    for: .applicationSupportDirectory, in: .userDomainMask,\n    appropriateFor: nil, create: true) \nlet directoryURL = appSupportURL.appendingPathComponent(\"MyDatabase\", isDirectory: true)\ntry fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true)\n\n// Open or create the database\nlet databaseURL = directoryURL.appendingPathComponent(\"db.sqlite\")\nlet dbQueue = try DatabaseQueue(path: databaseURL.path)\n```\n\n----------------------------------------\n\nTITLE: Proper SQL Argument Handling to Avoid SQL Injection in GRDB\nDESCRIPTION: Illustrates correct and incorrect ways to handle SQL arguments, emphasizing the importance of using argument dictionaries, arrays, or SQL interpolation instead of embedding values directly into SQL strings.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n// WRONG: don't embed values in raw SQL strings\nlet id = 123\nlet name = textField.text\ntry db.execute(\n    sql: \"UPDATE player SET name = '\\(name)' WHERE id = \\(id)\")\n\n// CORRECT: use arguments dictionary\ntry db.execute(\n    sql: \"UPDATE player SET name = :name WHERE id = :id\",\n    arguments: [\"name\": name, \"id\": id])\n\n// CORRECT: use arguments array\ntry db.execute(\n    sql: \"UPDATE player SET name = ? WHERE id = ?\",\n    arguments: [name, id])\n\n// CORRECT: use SQL Interpolation\ntry db.execute(\n    literal: \"UPDATE player SET name = \\(name) WHERE id = \\(id)\")\n```\n\n----------------------------------------\n\nTITLE: Creating Tables and Executing SQL Updates in Swift with GRDB\nDESCRIPTION: Demonstrates how to execute SQL statements that modify the database structure or data, including creating tables, inserting records, and updating data using dbQueue.write and prepared statements with arguments.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.execute(sql: \"\"\"\n        CREATE TABLE player (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            score INT)\n        \"\"\")\n    \n    try db.execute(\n        sql: \"INSERT INTO player (name, score) VALUES (?, ?)\",\n        arguments: [\"Barbara\", 1000])\n    \n    try db.execute(\n        sql: \"UPDATE player SET score = :score WHERE id = :id\",\n        arguments: [\"score\": 1000, \"id\": 1])\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Swift Query Interface in GRDB\nDESCRIPTION: This snippet demonstrates GRDB's Swift query interface for fetching records, including filtering, ordering, and counting operations without writing raw SQL, though SQL is still supported when needed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    // Place\n    let paris = try Place.find(db, id: 1)\n    \n    // Place?\n    let berlin = try Place.filter(Column(\"title\") == \"Berlin\").fetchOne(db)\n    \n    // [Place]\n    let favoritePlaces = try Place\n        .filter(Column(\"favorite\") == true)\n        .order(Column(\"title\"))\n        .fetchAll(db)\n    \n    // Int\n    let favoriteCount = try Place.filter(Column(\"favorite\")).fetchCount(db)\n    \n    // SQL is always welcome\n    let places = try Place.fetchAll(db, sql: \"SELECT * FROM place\")\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Basic Database Operations with DatabaseWriter in Swift\nDESCRIPTION: Demonstrates the basic read, write, and observation operations using GRDB's DatabaseWriter protocol with Swift concurrency. The example shows how to read data, insert a record, and observe database changes using Swift's async/await syntax.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// Read\nlet playerCount = try await writer.read { db in\n    try Player.fetchCount(db)\n}\n\n// Write\nlet newPlayerCount = try await writer.write { db in\n    try Player(name: \"Arthur\").insert(db)\n    return try Player.fetchCount(db)\n}\n\n// Observe database changes\nlet observation = ValueObservation.tracking { db in\n    try Player.fetchAll(db)\n}\nfor try await players in observation.values(in: writer) {\n    print(\"Fresh players\", players)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Codable Record in Swift\nDESCRIPTION: Example of a simple record implementation using Swift's Codable protocol with GRDB's MutablePersistableRecord.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_78\n\nLANGUAGE: swift\nCODE:\n```\n// That's all\nstruct Player: Encodable, MutablePersistableRecord {\n    var id: Int64?\n    var name: String\n    var score: Int\n    \n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Column Name Mapping in Codable Records\nDESCRIPTION: Demonstrates how to customize the mapping between Swift property names and database column names by implementing strategies for column encoding and decoding. Allows conversion between camelCase properties and snake_case columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_98\n\nLANGUAGE: swift\nCODE:\n```\nprotocol FetchableRecord {\n    static var databaseColumnDecodingStrategy: DatabaseColumnDecodingStrategy { get }\n}\n\nprotocol EncodableRecord {\n    static var databaseColumnEncodingStrategy: DatabaseColumnEncodingStrategy { get }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Records into the Database\nDESCRIPTION: Shows how to create a new record instance and insert it into the database using the insert method available through the PersistableRecord protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_60\n\nLANGUAGE: swift\nCODE:\n```\nlet player = Player(name: \"Arthur\", email: \"arthur@example.com\")\ntry player.insert(db)\n```\n\n----------------------------------------\n\nTITLE: Using Prepared Statements and Cursors in GRDB.swift\nDESCRIPTION: Shows how to create a prepared statement, execute a SELECT query with parameters, and iterate through results using a database cursor. Demonstrates accessing row values by index position.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SQLSupport.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    let sql = \"SELECT id, score FROM player WHERE name = ?\"  \n    let statement = try db.makeStatement(sql: sql)\n    let rows = try Row.fetchCursor(statement, arguments: [\"O'Brien\"])\n    while let row = try rows.next() {\n        let id: Int64 = row[0]\n        let score: Int = row[1]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ValueObservation to Async Sequence in Swift\nDESCRIPTION: Demonstrates how to use a ValueObservation as an async sequence with Swift's async/await syntax, allowing values to be consumed in an asynchronous loop with error handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    for try await players in observation.values(in: dbQueue) {\n        print(\"Fresh players\", players)\n    }\n} catch {\n    // Handle error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Record Types\nDESCRIPTION: Shows how to define a basic record type with protocols for database operations and how to perform a write operation with record objects.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_58\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    if var place = try Place.fetchOne(db, id: 1) {\n        place.isFavorite = true\n        try place.update(db)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching and Accessing Database Rows in GRDB\nDESCRIPTION: Shows how to fetch database rows and access column values using subscript syntax, with type conversion for extracting strongly-typed values from row columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    if let row = try Row.fetchOne(db, sql: \"SELECT * FROM wine WHERE id = ?\", arguments: [1]) {\n        let name: String = row[\"name\"]\n        let color: Color = row[\"color\"]\n        print(name, color)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Record Persistence Methods in GRDB\nDESCRIPTION: Demonstrates using GRDB's record persistence methods for a more object-oriented approach to database operations, allowing direct insertion of custom model objects into the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nvar player = Player(name: \"Arthur\", score: 1000)\ntry player.insert(db)\nlet playerId = player.id\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Insert Statements with Parameters in GRDB.swift\nDESCRIPTION: Example of executing multiple SQL INSERT statements using a database queue writer with parameterized values. Demonstrates how to insert multiple records into a player table with name and score fields.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SQLSupport.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.execute(sql: \"\"\"\n        INSERT INTO player (name, score) VALUES (?, ?);\n        INSERT INTO player (name, score) VALUES (?, ?);\n        \"\"\", arguments: [\"Arthur\", 500, \"Barbara\", 1000])\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Authors with Book Count Using GRDB\nDESCRIPTION: Example showing how to fetch authors along with their book count. A dedicated AuthorInfo type is defined to model this view of the data, and annotations are used to include the count in the query results.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\n// Fetch all authors along with their number of books\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var bookCount: Int\n}\nlet authorInfos: [AuthorInfo] = try dbQueue.read { db in\n    try Author\n        .annotated(with: Author.books.count)\n        .asRequest(of: AuthorInfo.self)\n        .fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Records by Key in Swift using GRDB\nDESCRIPTION: This snippet shows how to fetch records by their primary or unique keys using GRDB. It demonstrates the use of find, fetchOne, and fetchAll methods for different types of keys.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_179\n\nLANGUAGE: swift\nCODE:\n```\ntry Player.find(db, id: 1)                   // Player\ntry Player.fetchOne(db, id: 1)               // Player?\ntry Country.fetchAll(db, ids: [\"FR\", \"US\"])  // [Countries]\n\ntry Player.find(db, key: 1)                  // Player\ntry Player.fetchOne(db, key: 1)              // Player?\ntry Country.fetchAll(db, keys: [\"FR\", \"US\"]) // [Country]\ntry Player.fetchOne(db, key: [\"email\": \"arthur@example.com\"])            // Player?\ntry Citizenship.fetchOne(db, key: [\"citizenId\": 1, \"countryCode\": \"FR\"]) // Citizenship?\n```\n\n----------------------------------------\n\nTITLE: Fetching Records from the Database\nDESCRIPTION: Demonstrates various methods for fetching records from the database, including raw SQL queries, query interface methods, and fetching by ID.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_61\n\nLANGUAGE: swift\nCODE:\n```\nlet arthur = try Player.fetchOne(db,            // Player?\n    sql: \"SELECT * FROM players WHERE name = ?\",\n    arguments: [\"Arthur\"])\n\nlet bestPlayers = try Player                    // [Player]\n    .order(Column(\"score\").desc)\n    .limit(10)\n    .fetchAll(db)\n    \nlet spain = try Country.fetchOne(db, id: \"ES\")  // Country?\nlet italy = try Country.find(db, id: \"IT\")      // Country\n```\n\n----------------------------------------\n\nTITLE: Preventing SQL Injection with Parameterized Queries in GRDB.swift\nDESCRIPTION: Safe approach to execute SQL queries using parameterized statements that properly escape and handle user input in GRDB.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_203\n\nLANGUAGE: swift\nCODE:\n```\nlet name = textField.text\ntry dbQueue.write { db in\n    // Good\n    try db.execute(\n        sql: \"UPDATE students SET name = ? WHERE id = ?\",\n        arguments: [name, id])\n    \n    // Just as good\n    try db.execute(\n        sql: \"UPDATE students SET name = :name WHERE id = :id\",\n        arguments: [\"name\": name, \"id\": id])\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Records in Swift using GRDB\nDESCRIPTION: This snippet shows how to update records in the database using GRDB. It demonstrates various ways to use updateAll method, including filtered updates, limit updates, and different types of column assignments.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_183\n\nLANGUAGE: swift\nCODE:\n```\n// UPDATE player SET score = 0, isHealthy = 1, bonus = NULL\ntry Player.updateAll(db, \n    Column(\"score\").set(to: 0), \n    Column(\"isHealthy\").set(to: true), \n    Column(\"bonus\").set(to: nil))\n\n// UPDATE player SET score = 0 WHERE team = 'red'\ntry Player\n    .filter(Column(\"team\") == \"red\")\n    .updateAll(db, Column(\"score\").set(to: 0))\n\n// UPDATE player SET top = 1 ORDER BY score DESC LIMIT 10\ntry Player\n    .order(Column(\"score\").desc)\n    .limit(10)\n    .updateAll(db, Column(\"top\").set(to: true))\n\n// UPDATE country SET population = 67848156 WHERE id = 'FR'\ntry Country\n    .filter(id: \"FR\")\n    .updateAll(db, Column(\"population\").set(to: 67_848_156))\n\n// UPDATE player SET score = score + (bonus * 2)\ntry Player.updateAll(db, Column(\"score\").set(to: Column(\"score\") + Column(\"bonus\") * 2))\n\n// UPDATE player SET score = score + (bonus * 2)\ntry Player.updateAll(db, Column(\"score\") += Column(\"bonus\") * 2)\n\n// UPDATE OR IGNORE player SET ...\ntry Player.updateAll(db, onConflict: .ignore, /* assignments... */)\n```\n\n----------------------------------------\n\nTITLE: Using Decodable with FetchableRecord in Swift using GRDB\nDESCRIPTION: Shows how to leverage Swift's Decodable protocol with FetchableRecord, which automatically provides the required init(row:) implementation without additional code.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_70\n\nLANGUAGE: swift\nCODE:\n```\n// That's all\nstruct Player: Decodable, FetchableRecord {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Record with Codable in GRDB.swift\nDESCRIPTION: A Codable struct implementation for a Place record with TableRecord, FetchableRecord, and MutablePersistableRecord protocol conformances. This approach leverages Swift's Codable protocol for database serialization/deserialization.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_114\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place: Codable {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    private var latitude: CLLocationDegrees\n    private var longitude: CLLocationDegrees\n    \n    var coordinate: CLLocationCoordinate2D {\n        get {\n            CLLocationCoordinate2D(\n                latitude: latitude,\n                longitude: longitude)\n        }\n        set {\n            latitude = newValue.latitude\n            longitude = newValue.longitude\n        }\n    }\n}\n\n// SQL generation\nextension Place: TableRecord {\n    /// The table columns\n    enum Columns {\n        static let id = Column(CodingKeys.id)\n        static let title = Column(CodingKeys.title)\n        static let isFavorite = Column(CodingKeys.isFavorite)\n        static let latitude = Column(CodingKeys.latitude)\n        static let longitude = Column(CodingKeys.longitude)\n    }\n}\n\n// Fetching methods\nextension Place: FetchableRecord { }\n\n// Persistence methods\nextension Place: MutablePersistableRecord {\n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Expressions and Components\nDESCRIPTION: Demonstrates proper usage of SQL components including expressions, ordering, selection, requests and subqueries with type-safe interfaces.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\n// SQLExpression\nSQL(\"name = \\(\"O'Brien\")\").sqlExpression\n\n// SQLOrdering\nSQL(\"name DESC)\").sqlOrdering\n\n// SQLSelection\nSQL(\"score + bonus AS total)\").sqlSelection\nSQL(\"*\").sqlSelection\n\n// SQLRequest\nSQLRequest<Player>(literal: \"SELECT * FROM player\")\n\n// SQLSubquery\nSQLRequest(literal: \"SELECT * FROM player\").sqlSubquery\n```\n\n----------------------------------------\n\nTITLE: Basic GRDB Query Request\nDESCRIPTION: Shows how to create and execute basic database requests using the TableRecord protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_184\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.all()  // QueryInterfaceRequest<Player>\n\ntry request.fetchCursor(db) // A Cursor of Player\ntry request.fetchAll(db)    // [Player]\ntry request.fetchSet(db)    // Set<Player>\ntry request.fetchOne(db)    // Player?\ntry request.fetchCount(db)  // Int\n```\n\n----------------------------------------\n\nTITLE: Using SQL Interpolation in GRDB with Swift\nDESCRIPTION: Examples of SQL interpolation in GRDB, allowing natural-looking SQL strings with variable substitution while preventing SQL injection. Includes a custom SQL request method for filtering players by name.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(literal: \"UPDATE player SET score = \\(score) WHERE id = \\(id)\")\n\nextension Player {\n    static func filter(name: String) -> SQLRequest<Player> {\n        \"SELECT * FROM player WHERE name = \\(name)\"\n    }\n}\n\nlet player = try Player.filter(name: \"Arthur O'Brien\").fetchOne(db)\n```\n\n----------------------------------------\n\nTITLE: Using Immediate Scheduling with ValueObservation in Swift\nDESCRIPTION: Demonstrates how to use immediate scheduling with ValueObservation to get the initial value synchronously when starting the observation, useful for UI applications to avoid loading states.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Immediate scheduling notifies\n// the initial value right on subscription.\nlet cancellable = observation\n    .start(in: dbQueue, scheduling: .immediate) { error in\n        // Called on the main actor\n    } onChange: { value in\n        // Called on the main actor\n        print(\"Fresh value\", value)\n    }\n// <- Here \"Fresh value\" has already been printed.\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Requests with GRDB in Swift\nDESCRIPTION: Creates a query interface request to filter players with non-null email addresses and orders them by name. Demonstrates fetching results and count from the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_119\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.filter(emailColumn != nil).order(nameColumn)\nlet players = try request.fetchAll(db)  // [Player]\nlet count = try request.fetchCount(db)  // Int\n```\n\n----------------------------------------\n\nTITLE: Using All and None Request Methods in GRDB\nDESCRIPTION: Demonstrates the basic all() method for retrieving all rows from a table. This is typically the starting point for building more complex queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_123\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player\nPlayer.all()\n```\n\n----------------------------------------\n\nTITLE: Creating Database Schema with GRDB Migrations\nDESCRIPTION: Demonstrates how to create a robust database schema for a library system with authors and books using GRDB migrations. Includes foreign key constraints and column definitions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nvar migrator = DatabaseMigrator()\n\nmigrator.registerMigration(\"createLibrary\") { db in\n    try db.create(table: \"author\") { t in             // (1)\n        t.autoIncrementedPrimaryKey(\"id\")             // (2)\n        t.column(\"name\", .text).notNull()             // (3)\n        t.column(\"countryCode\", .text)                // (4)\n    }\n    \n    try db.create(table: \"book\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.column(\"title\", .text).notNull()            // (5)\n        t.belongsTo(\"author\", onDelete: .cascade)     // (6)\n            .notNull()                                // (7)\n    }\n}\n\ntry migrator.migrate(dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Initializing DatabaseQueue and DatabasePool in Swift\nDESCRIPTION: Basic example showing how to create database connections using either DatabaseQueue or DatabasePool classes. Both options require a path to the SQLite database file.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseConnections.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport GRDB\n\n// Pick one:\nlet dbQueue = try DatabaseQueue(path: \"/path/to/database.sqlite\")\nlet dbPool = try DatabasePool(path: \"/path/to/database.sqlite\")\n```\n\n----------------------------------------\n\nTITLE: Fetching Books with Their Authors Using GRDB\nDESCRIPTION: Example showing how to fetch books along with their authors. An Authorship type models this relationship, and the including method ensures that each book comes with its author in a single query.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n// Fetch all Colombian books and their authors\nstruct Authorship: Decodable, FetchableRecord {\n    var book: Book\n    var author: Author\n}\nlet authorships: [Authorship] = try dbQueue.read { db in\n    try Book.all()\n        .including(required: Book.author.filter(countryCode: \"CO\"))\n        .asRequest(of: Authorship.self)\n        .fetchAll(db)\n    \n    // Equivalent alternative\n    try Book.all()\n        .filter(authorCountryCode: \"CO\")\n        .including(required: Book.author)\n        .asRequest(of: Authorship.self)\n        .fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering by Primary and Unique Keys in GRDB\nDESCRIPTION: Demonstrates filtering by both simple and compound primary keys, as well as by unique keys, using the filter(key:) and filter(keys:) methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_132\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE id = 1\nPlayer.filter(key: 1)\n\n// SELECT * FROM country WHERE isoCode IN ('FR', 'US')\nCountry.filter(keys: [\"FR\", \"US\"])\n\n// SELECT * FROM citizenship WHERE citizenId = 1 AND countryCode = 'FR'\nCitizenship.filter(key: [\"citizenId\": 1, \"countryCode\": \"FR\"])\n\n// SELECT * FROM player WHERE email = 'arthur@example.com'\nPlayer.filter(key: [\"email\": \"arthur@example.com\"])\n```\n\n----------------------------------------\n\nTITLE: Defining Migrations in GRDB.swift\nDESCRIPTION: This snippet demonstrates how to create a DatabaseMigrator instance and register multiple migrations. It shows the creation of tables and altering existing tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nvar migrator = DatabaseMigrator()\n\n// 1st migration\nmigrator.registerMigration(\"Create authors\") { db in\n    try db.create(table: \"author\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.column(\"creationDate\", .datetime)\n        t.column(\"name\", .text)\n    }\n}\n\n// 2nd migration\nmigrator.registerMigration(\"Add books and author.birthYear\") { db in\n    try db.create(table: \"book\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.belongsTo(\"author\").notNull()\n        t.column(\"title\", .text).notNull()\n    }\n\n    try db.alter(table: \"author\") { t in\n        t.add(column: \"birthYear\", .integer)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating or Opening Database with Directory Structure in Swift\nDESCRIPTION: Shows how to create a new database or open an existing one within a dedicated directory in the Application Support folder. Handles directory creation and file management.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseConnections.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n// HOW TO create an empty database, or open an existing database file\n\n// Create the \"Application Support/MyDatabase\" directory if needed\nlet fileManager = FileManager.default\nlet appSupportURL = try fileManager.url(\n    for: .applicationSupportDirectory, in: .userDomainMask,\n    appropriateFor: nil, create: true) \nlet directoryURL = appSupportURL.appendingPathComponent(\"MyDatabase\", isDirectory: true)\ntry fileManager.createDirectory(at: directoryURL, withIntermediateDirectories: true)\n\n// Open or create the database\nlet databaseURL = directoryURL.appendingPathComponent(\"db.sqlite\")\nlet dbQueue = try DatabaseQueue(path: databaseURL.path)\n```\n\n----------------------------------------\n\nTITLE: Applying Migrations in GRDB.swift\nDESCRIPTION: This snippet shows how to apply migrations to a database using the DatabaseMigrator. It demonstrates migrating to the latest version and migrating up to a specific version.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet dbQueue = try DatabaseQueue(path: \"/path/to/database.sqlite\")\n\n// Migrate the database up to the latest version\ntry migrator.migrate(dbQueue)\n\n// Migrate the database up to a specific version\ntry migrator.migrate(dbQueue, upTo: \"v2\")\n\n// Migrations can only run forward:\ntry migrator.migrate(dbQueue, upTo: \"v2\")\ntry migrator.migrate(dbQueue, upTo: \"v1\")\n// ^ fatal error: database is already migrated beyond migration \"v1\"\n```\n\n----------------------------------------\n\nTITLE: Testing for Record Existence in Swift using GRDB\nDESCRIPTION: This snippet demonstrates how to check for the existence of records in the database using GRDB. It shows the use of isEmpty and exists methods for different scenarios.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_180\n\nLANGUAGE: swift\nCODE:\n```\n// Some request based on `Player`\nlet request = Player.filter(...)...\n\n// Check for player existence:\nlet noSuchPlayer = try request.isEmpty(db) // Bool\n\ntry Player.exists(db, id: 1)\ntry Country.exists(db, id: \"FR\")\n\ntry Player.exists(db, key: 1)\ntry Country.exists(db, key: \"FR\")\ntry Player.exists(db, key: [\"email\": \"arthur@example.com\"])\ntry Citizenship.exists(db, key: [\"citizenId\": 1, \"countryCode\": \"FR\"])\n```\n\n----------------------------------------\n\nTITLE: Basic SQL Interpolation Usage in Swift\nDESCRIPTION: Example showing how to use SQL interpolation with the 'literal' parameter to safely embed values directly into a SQL query.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet name: String = ...\nlet id: Int64 = ...\ntry dbQueue.write { db in\n    try db.execute(literal: \"UPDATE player SET name = \\(name) WHERE id = \\(id)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Comparison Operators in Swift with GRDB\nDESCRIPTION: Examples of using Swift comparison operators (==, !=, <, <=, >, >=) that are translated to SQL comparison operators (=, <>, <, <=, >, >=, IS, IS NOT). This includes filtering records based on column values and subqueries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_152\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE (name = 'Arthur')\nPlayer.filter(nameColumn == \"Arthur\")\n\n// SELECT * FROM player WHERE (name IS NULL)\nPlayer.filter(nameColumn == nil)\n\n// SELECT * FROM player WHERE (score IS 1000)\nPlayer.filter(scoreColumn === 1000)\n\n// SELECT * FROM rectangle WHERE width < height\nRectangle.filter(widthColumn < heightColumn)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE score = (SELECT max(score) FROM player)\nlet maximumScore = Player.select(max(scoreColumn))\nPlayer.filter(scoreColumn == maximumScore)\n\n// SELECT * FROM player WHERE score = (SELECT max(score) FROM player)\nlet maximumScore = SQLRequest(\"SELECT max(score) FROM player\")\nPlayer.filter(scoreColumn == maximumScore)\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Columns in GRDB Queries\nDESCRIPTION: Shows how to select specific columns from a table using the select() method, which allows specifying both the columns to select and the expected return type.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_124\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT name FROM player\nPlayer.select(nameColumn, as: String.self)\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL Queries in GRDB with Swift\nDESCRIPTION: Examples of executing raw SQL statements in GRDB, including updates and queries with explicit parameters for safe execution without SQL injection risks.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(\n    sql: \"UPDATE player SET score = ? WHERE id = ?\",\n    arguments: [950, 42])\n\nlet bestPlayers: [Player] = try Player.fetchAll(db, sql: \"\"\"\n    SELECT * FROM player ORDER BY score DESC LIMIT 10\n    \"\"\")\n\nlet maximumScore: Int? = try Int.fetchOne(db, sql: \"\"\"\n    SELECT MAX(score) FROM player\n    \"\"\")\n```\n\n----------------------------------------\n\nTITLE: Observing Database Value Changes with ValueObservation and Combine\nDESCRIPTION: Creates publishers that deliver fresh values whenever tracked database values change. Examples show tracking Player records and SQL query results.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// A publisher with output [Player] and failure Error\nlet publisher = ValueObservation\n    .tracking { db in try Player.fetchAll(db) }\n    .publisher(in: dbQueue)\n\n// A publisher with output Int? and failure Error\nlet publisher = ValueObservation\n    .tracking { db in try Int.fetchOne(db, sql: \"SELECT MAX(score) FROM player\") }\n    .publisher(in: dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Creating Codable Records with GRDB.swift\nDESCRIPTION: Demonstrates how to use Swift's Codable protocol with GRDB.swift records. By adopting both Codable and the appropriate record protocols, types get automatic database encoding and decoding functionality.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_95\n\nLANGUAGE: swift\nCODE:\n```\n// Declare a record...\nstruct Player: Codable, FetchableRecord, PersistableRecord {\n    var name: String\n    var score: Int\n}\n\n// ...and there you go:\ntry dbQueue.write { db in\n    try Player(name: \"Arthur\", score: 100).insert(db)\n    let players = try Player.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Changed Record Columns by Comparing Two Records in Swift\nDESCRIPTION: Uses the updateChanges(_:from:) method to compare an old and new record, updating only the changed columns in the database. The method returns a boolean indicating if changes were made and the database was updated.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_106\n\nLANGUAGE: swift\nCODE:\n```\nif let oldPlayer = try Player.fetchOne(db, id: 42) {\n    var newPlayer = oldPlayer\n    newPlayer.score = 100\n    if try newPlayer.updateChanges(db, from: oldPlayer) {\n        print(\"player was modified, and updated in the database\")\n    } else {\n        print(\"player was not modified, and database was not hit\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Custom Record Objects in GRDB\nDESCRIPTION: Shows how to fetch application-specific model objects (records) that can initialize themselves from database rows, providing a convenient way to work with database data in an object-oriented manner.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nlet wines = try dbQueue.read { db in\n    try Wine.fetchAll(db, sql: \"SELECT * FROM wine\")\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Value Querying in Swift GRDB\nDESCRIPTION: Demonstrates how to fetch single values and collections from database using GRDB's value querying methods. Shows examples of fetching integers and strings using different fetch modes including cursors, arrays and single values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_33\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    try Int.fetchCursor(db, sql: \"SELECT ...\", arguments: ...) // A Cursor of Int\n    try Int.fetchAll(db, sql: \"SELECT ...\", arguments: ...)    // [Int]\n    try Int.fetchSet(db, sql: \"SELECT ...\", arguments: ...)    // Set<Int>\n    try Int.fetchOne(db, sql: \"SELECT ...\", arguments: ...)    // Int?\n    \n    let maxScore = try Int.fetchOne(db, sql: \"SELECT MAX(score) FROM player\") // Int?\n    let names = try String.fetchAll(db, sql: \"SELECT name FROM player\")       // [String]\n}\n```\n\n----------------------------------------\n\nTITLE: Handling SQLite Error 21 with LIKE Queries in Swift\nDESCRIPTION: This snippet demonstrates the incorrect and correct ways to handle LIKE queries in GRDB.swift to avoid the SQLite error 21 \"wrong number of statement arguments\".\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_236\n\nLANGUAGE: Swift\nCODE:\n```\nlet name = textField.text\nlet players = try dbQueue.read { db in\n    try Player.fetchAll(db, sql: \"SELECT * FROM player WHERE name LIKE '%?%'\", arguments: [name])\n}\n```\n\nLANGUAGE: Swift\nCODE:\n```\nlet name = textField.text\nlet players: [Player] = try dbQueue.read { db in\n    let pattern = \"%\\(name)%\"\n    return try Player.fetchAll(db, sql: \"SELECT * FROM player WHERE name LIKE ?\", arguments: [pattern])\n}\n```\n\n----------------------------------------\n\nTITLE: Efficiently Fetching Books with Authors Using GRDB Associations\nDESCRIPTION: Demonstrates how to efficiently fetch books along with their authors using GRDB associations, performing a single database query.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord, Decodable {\n    let book: Book\n    let author: Author?\n}\n\nlet request = Book.including(optional: Book.author)\nlet bookInfos = BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Ordering Query Results in GRDB\nDESCRIPTION: Shows various ways to order query results using the order() method, including ascending and descending orders, as well as ordering by multiple columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_137\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player ORDER BY name\nPlayer.order(nameColumn)\n\n// SELECT * FROM player ORDER BY score DESC, name\nPlayer.order(scoreColumn.desc, nameColumn)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player ORDER BY score ASC NULLS LAST\nPlayer.order(nameColumn.ascNullsLast)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player ORDER BY name\nPlayer.order(scoreColumn).order(nameColumn)\n```\n\n----------------------------------------\n\nTITLE: Adding Column Indices During Table Creation in GRDB.swift\nDESCRIPTION: Shows how to create columns with unique constraints and indices directly during table creation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"player\") { t in\n    t.column(\"email\", .text).unique()\n    t.column(\"score\", .integer).indexed()\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a DatabaseQueue with a File Path in Swift\nDESCRIPTION: Code showing how to initialize a DatabaseQueue with a path to an SQLite database file. SQLite will create the database if it doesn't exist.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseQueue.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport GRDB\n\nlet dbQueue = try DatabaseQueue(path: \"/path/to/database.sqlite\")\n```\n\n----------------------------------------\n\nTITLE: Basic Upsert Operation in Swift with GRDB\nDESCRIPTION: Demonstrates a basic upsert operation using the Player record. This operation inserts a new player or updates an existing one if the primary key already exists, overwriting all columns except the primary key.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_81\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: Encodable, PersistableRecord {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\n// INSERT INTO player (id, name, score)\n// VALUES (1, 'Arthur', 1000)\n// ON CONFLICT DO UPDATE SET\n//   name = excluded.name,\n//   score = excluded.score\nlet player = Player(id: 1, name: \"Arthur\", score: 1000)\ntry player.upsert(db)\n```\n\n----------------------------------------\n\nTITLE: Using Type-Safe Record Methods with Identifiable in GRDB.swift\nDESCRIPTION: Shows the various type-safe methods available for Identifiable records in GRDB.swift. These methods provide compile-time type checking for record operations involving primary keys.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_93\n\nLANGUAGE: swift\nCODE:\n```\nlet player = try Player.find(db, id: 1)               // Player\nlet player = try Player.fetchOne(db, id: 1)           // Player?\nlet players = try Player.fetchAll(db, ids: [1, 2, 3]) // [Player]\nlet players = try Player.fetchSet(db, ids: [1, 2, 3]) // Set<Player>\n\nlet request = Player.filter(id: 1)\nlet request = Player.filter(ids: [1, 2, 3])\n\ntry Player.deleteOne(db, id: 1)\ntry Player.deleteAll(db, ids: [1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Declaring Columns for Queries in GRDB\nDESCRIPTION: Shows two methods for declaring database columns for use in query interface requests - using individual Column instances and creating a column enum.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_122\n\nLANGUAGE: swift\nCODE:\n```\nlet idColumn = Column(\"id\")\nlet nameColumn = Column(\"name\")\n```\n\nLANGUAGE: swift\nCODE:\n```\n// Columns.id and Columns.name can be used just as\n// idColumn and nameColumn declared above.\nenum Columns: String, ColumnExpression {\n    case id\n    case name\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding Query Method Precedence in GRDB Swift\nDESCRIPTION: Explains how different query methods interact when chained together. Some methods replace previous constraints while others extend them, affecting the final SQL query generated.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_145\n\nLANGUAGE: swift\nCODE:\n```\nPlayer                          // SELECT * FROM player\n    .filter(nameColumn != nil)  // WHERE (name IS NOT NULL)\n    .filter(emailColumn != nil) //        AND (email IS NOT NULL)\n    .order(nameColumn)          // - ignored -\n    .reversed()                 // - ignored -\n    .order(scoreColumn)         // ORDER BY score\n    .limit(20, offset: 40)      // - ignored -\n    .limit(10)                  // LIMIT 10\n```\n\n----------------------------------------\n\nTITLE: Returning Values from DatabaseQueue Operations in Swift\nDESCRIPTION: Examples showing how to return values from database read and write operations. This demonstrates capturing query results or counts after performing database operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseQueue.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet playerCount = try dbQueue.read { db in\n    try Place.fetchCount(db)\n}\n\nlet newPlayerCount = try dbQueue.write { db -> Int in\n    try Player(name: \"Arthur\").insert(db)\n    return try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Record in Swift using GRDB\nDESCRIPTION: Deletes a specific record from the database using the 'delete' method. This requires the type to adopt the PersistableRecord protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_65\n\nLANGUAGE: swift\nCODE:\n```\nlet player: Player = ...\ntry player.delete(db)\n```\n\n----------------------------------------\n\nTITLE: Database Observation Method Reference in Swift\nDESCRIPTION: Reference signatures for various database observation methods including ValueObservation, DatabaseRegionObservation, transaction handling, and TransactionObserver protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseObservation.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nDatabase/afterNextTransaction(onCommit:onRollback:)\nDatabase/registerAccess(to:)\nDatabase/add(transactionObserver:extent:)\nDatabase/remove(transactionObserver:)\nDatabaseWriter/add(transactionObserver:extent:)\nDatabaseWriter/remove(transactionObserver:)\n```\n\n----------------------------------------\n\nTITLE: Implementing didInsert Callback for Auto-Incremented IDs in GRDB.swift\nDESCRIPTION: Shows how to implement the didInsert persistence callback to update a record's auto-incremented ID after successful insertion. The callback receives an InsertionSuccess object containing the new rowID.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_89\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: MutablePersistableRecord {\n    var id: Int64?\n    \n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n\ntry dbQueue.write { db in\n    var player = Player(id: nil, ...)\n    try player.insert(db)\n    print(player.id) // didInsert was called: prints some non-nil id\n}\n```\n\n----------------------------------------\n\nTITLE: Using Associations in GRDB with Swift\nDESCRIPTION: Example of using GRDB's associations to perform a LEFT JOIN between books and authors, automatically generating the appropriate SQL and fetching related records together.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, author.*\n// FROM book\n// LEFT JOIN author ON author.id = book.authorId\nlet request = Book.including(optional: Book.author)\nlet bookInfos: [BookInfo] = BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Querying Records with GRDB's Query Interface in Swift\nDESCRIPTION: Examples of using GRDB's query interface to fetch data, including getting top players by score and calculating a maximum score value. The query interface generates the SQL automatically.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player ORDER BY score DESC LIMIT 10\nlet bestPlayers: [Player] = try Player\n    .order(scoreColumn.desc)\n    .limit(10)\n    .fetchAll(db)\n\n// SELECT MAX(score) FROM player\nlet maximumScore: Int? = try Player\n    .select(max(scoreColumn))\n    .asRequestOf(Int.self)\n    .fetchOne(db)\n```\n\n----------------------------------------\n\nTITLE: Defining a HasMany Association in GRDB Swift\nDESCRIPTION: Shows how to define a HasMany relationship from Author to Book models. This allows retrieving all books belonging to an author.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\nextension Author: TableRecord {\n    static let books = hasMany(Book.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Database Capabilities to Record Types\nDESCRIPTION: Extends the record types with GRDB protocols for database operations and handling auto-incremented IDs.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nextension Author: FetchableRecord, MutablePersistableRecord {\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n\nextension Book: FetchableRecord, MutablePersistableRecord {\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Authors with All Books using including(all:)\nDESCRIPTION: Shows how to fetch authors along with all their associated books using a to-many relationship.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_38\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT author.* FROM author\n// SELECT book.* FROM book WHERE authorId IN (...)\nlet request = Author.including(all: Author.books)\n```\n\n----------------------------------------\n\nTITLE: Using Combine with Shared ValueObservation in Swift\nDESCRIPTION: Demonstrates how to use Combine operators with a SharedValueObservation by first converting it to a Combine Publisher, then applying operators like map.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nlet cancellable = try sharedObservation\n    .publisher() // Turn shared observation into a Combine Publisher\n    .map { ... } // The map operator from Combine\n    .sink(...)\n```\n\n----------------------------------------\n\nTITLE: Interpolating TableRecord and Table Instances in SQL Queries (Swift)\nDESCRIPTION: This snippet demonstrates how to interpolate TableRecord protocol adopters and Table instances into SQL queries. It shows three different ways to reference a table in a SELECT statement.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_18\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Player: TableRecord { ... }\n\n// SELECT * FROM player\n\"SELECT * FROM \\(Player.self)\"\n\n// SELECT * FROM player\nlet player: Player = ...\n\"SELECT * FROM \\(tableOf: player) ...\"\n\n// SELECT * FROM player\nlet playerTable = Table(\"player\")\n\"SELECT * FROM \\(playerTable)\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating SQL Injection Vulnerability in Swift GRDB Application\nDESCRIPTION: Example of code vulnerable to SQL injection attacks, where user input is directly embedded into SQL queries without proper sanitization.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_201\n\nLANGUAGE: swift\nCODE:\n```\n// BAD BAD BAD\nlet id = 1\nlet name = textField.text\ntry dbQueue.write { db in\n    try db.execute(sql: \"UPDATE students SET name = '\\(name)' WHERE id = \\(id)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Observation in GRDB\nDESCRIPTION: This example shows how to observe database changes using ValueObservation, with both basic usage and integration with reactive frameworks like Combine and RxSwift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Define the observed value\nlet observation = ValueObservation.tracking { db in\n    try Place.fetchAll(db)\n}\n\n// Start observation\nlet cancellable = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { (places: [Place]) in print(\"Fresh places: \\(places)\") })\n```\n\n----------------------------------------\n\nTITLE: Interpolating Expressions and Values in SQL Queries (Swift)\nDESCRIPTION: This snippet demonstrates how to interpolate expressions and values into SQL queries. It shows examples of selecting columns, performing arithmetic operations, and using variables in queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_20\n\nLANGUAGE: Swift\nCODE:\n```\n// SELECT name FROM player\n\"SELECT \\(Column(\"name\")) FROM player\"\n\n// SELECT (score + 100) AS points FROM player\nlet bonus = 100\n\"SELECT \\(Column(\"score\") + bonus) AS points FROM player\"\n\n// SELECT (score + 100) AS points FROM player\n\"SELECT (score + \\(bonus)) AS points FROM player\"\n```\n\n----------------------------------------\n\nTITLE: Fetching Array Data with GRDB.swift\nDESCRIPTION: Demonstrates how to fetch and iterate over an array of Player objects from the database using fetchAll method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    // [Player]\n    let players = try Player.fetchAll(db, sql: \"SELECT ...\")\n    for player in players {\n        // use player\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Multiple SQL Statements in GRDB\nDESCRIPTION: Demonstrates how to join multiple SQL statements with semicolons, executing them in sequence either using traditional argument arrays or SQL interpolation with the literal method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(sql: \"\"\"\n    INSERT INTO player (name, score) VALUES (?, ?);\n    INSERT INTO player (name, score) VALUES (?, ?);\n    \"\"\", arguments: [\"Arthur\", 750, \"Barbara\", 1000])\n\ntry db.execute(literal: \"\"\"\n    INSERT INTO player (name, score) VALUES (\\(\"Arthur\"), \\(750));\n    INSERT INTO player (name, score) VALUES (\\(\"Barbara\"), \\(1000));\n    \"\"\")\n```\n\n----------------------------------------\n\nTITLE: Using Table Class for Requests in GRDB\nDESCRIPTION: Shows how to create database requests when you can't use a record type by using the Table class. Demonstrates fetching both generic rows and typed results.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_121\n\nLANGUAGE: swift\nCODE:\n```\n// The request for all rows from the player table:\nlet table = Table(\"player\")\nlet request = table.all()\nlet rows = try request.fetchAll(db)    // [Row]\n\n// The request for all players from the player table:\nlet table = Table<Player>(\"player\")\nlet request = table.all()\nlet players = try request.fetchAll(db) // [Player]\n```\n\n----------------------------------------\n\nTITLE: Limiting and Paging Results in GRDB\nDESCRIPTION: Shows how to use the limit() method to restrict the number of results returned and implement pagination with the offset parameter.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_139\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player LIMIT 5\nPlayer.limit(5)\n\n// SELECT * FROM player LIMIT 5 OFFSET 10\nPlayer.limit(5, offset: 10)\n```\n\n----------------------------------------\n\nTITLE: Filtering with Association Aggregates in GRDB\nDESCRIPTION: Demonstrates using having() with association aggregates to filter grouped results based on properties of related records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_136\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT team.*\n// FROM team\n// LEFT JOIN player ON player.teamId = team.id\n// GROUP BY team.id\n// HAVING COUNT(DISTINCT player.id) >= 5\nTeam.having(Team.players.count >= 5)\n```\n\n----------------------------------------\n\nTITLE: Creating a Shared ValueObservation in Swift\nDESCRIPTION: Shows how to create a shared ValueObservation that fetches values once per database change and notifies all subscribers, optimizing database resource usage.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// SharedValueObservation<[Player]>\nlet sharedObservation = ValueObservation\n    .tracking { db in try Player.fetchAll(db) }\n    .shared(in: dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Updating Only Changed Fields with updateChanges in Swift using GRDB\nDESCRIPTION: Updates only modified fields using the 'updateChanges' method. This approach avoids unnecessary database operations by comparing the record before and after changes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_63\n\nLANGUAGE: swift\nCODE:\n```\n// does not hit the database if score has not changed\ntry player.updateChanges(db) {\n    $0.score = 1000\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Inserted Row ID in GRDB\nDESCRIPTION: Shows how to get the row ID of the last inserted row using the lastInsertedRowID property after executing an INSERT statement, which is useful for tracking newly created records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(\n    sql: \"INSERT INTO player (name, score) VALUES (?, ?)\",\n    arguments: [\"Arthur\", 1000])\nlet playerId = db.lastInsertedRowID\n```\n\n----------------------------------------\n\nTITLE: Using Query Interface with TableRecord and FetchableRecord in Swift using GRDB\nDESCRIPTION: Shows how to use the query interface to fetch records from types that adopt both TableRecord and FetchableRecord protocols, enabling type-safe filtering and querying.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_74\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM place WHERE name = 'Paris'\nlet paris = try Place.filter(nameColumn == \"Paris\").fetchOne(db)\n```\n\n----------------------------------------\n\nTITLE: Batch Updating Records with Query Interface in Swift using GRDB\nDESCRIPTION: Performs a batch update on multiple records that match a specific condition. This example increments the score of all players on the 'red' team by 1.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_64\n\nLANGUAGE: swift\nCODE:\n```\ntry Player\n    .filter(Column(\"team\") == \"red\")\n    .updateAll(db, Column(\"score\") += 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Columns for a Codable Record in GRDB\nDESCRIPTION: Example showing how to define columns for a Codable record type by extending the record and creating a Columns enumeration that uses the CodingKeys. This approach enables type-safe column references in database queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// HOW TO define columns for a Codable record\nextension Author {\n    enum Columns {\n        static let id = Column(CodingKeys.id)\n        static let name = Column(CodingKeys.name)\n        static let countryCode = Column(CodingKeys.countryCode)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Record Changes In-Place with a Closure in Swift\nDESCRIPTION: Uses the updateChanges(_:modify:) method to update a record in place using a closure. The method modifies the record and updates only changed columns in the database, returning a boolean that indicates if changes were made.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_107\n\nLANGUAGE: swift\nCODE:\n```\nif var player = try Player.fetchOne(db, id: 42) {\n    let modified = try player.updateChanges(db) {\n        $0.score = 100\n    }\n    if modified {\n        print(\"player was modified, and updated in the database\")\n    } else {\n        print(\"player was not modified, and database was not hit\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Database Changes with ValueObservation in GRDB with Swift\nDESCRIPTION: Example of using GRDB's ValueObservation to track changes to database records. Shows integration with Combine for reactive database access using a custom SQL request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nlet playerObservation = ValueObservation.tracking { db in\n    try Player.filter(name: \"Arthur O'Brien\").fetchOne(db)\n}\n\n// Observe the SQL request with Combine\nlet cancellable = playerObservation.publisher(in: dbQueue).sink(\n    receiveCompletion: { completion in ... },\n    receiveValue: { (player: Player?) in print(\"Player has changed\") })\n```\n\n----------------------------------------\n\nTITLE: Handling Conflicts at Query Level with SQLite in Swift\nDESCRIPTION: Shows how to handle conflicts at the individual query level using SQLite's OR REPLACE syntax. This approach allows for conflict resolution on specific queries rather than at the table definition level.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_111\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE TABLE player (\n//     id INTEGER PRIMARY KEY AUTOINCREMENT,\n//     email TEXT UNIQUE\n// )\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"email\", .text).unique()\n}\n\n// Again, despite the unique index on email, both inserts succeed.\ntry db.execute(sql: \"INSERT OR REPLACE INTO player (email) VALUES (?)\", arguments: [\"arthur@example.com\"])\ntry db.execute(sql: \"INSERT OR REPLACE INTO player (email) VALUES (?)\", arguments: [\"arthur@example.com\"])\n```\n\n----------------------------------------\n\nTITLE: SQL Injection Attack Result\nDESCRIPTION: Example of what happens when malicious input is used with vulnerable code, showing how the database could be compromised.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_202\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE students SET name = 'Robert';\nDROP TABLE students;\n--' WHERE id = 1\n```\n\n----------------------------------------\n\nTITLE: Creating Tables with Explicit Primary Keys in Swift\nDESCRIPTION: Demonstrates different approaches to creating explicit primary keys in database tables. Includes examples of auto-incremented, single-column, and composite primary keys.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// RECOMMENDED\ntry db.create(table: \"player\") { t in\n    // Auto-incremented primary key\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"name\", .text).notNull()\n}\n\ntry db.create(table: \"team\") { t in\n    // Single-column primary key\n    t.primaryKey(\"id\", .text)\n    t.column(\"name\", .text).notNull()\n}\n\ntry db.create(table: \"membership\") { t in\n    // Composite primary key\n    t.primaryKey {\n        t.belongsTo(\"player\")\n        t.belongsTo(\"team\")\n    }\n    t.column(\"role\", .text).notNull()\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Synchronous and Asynchronous Database Access\nDESCRIPTION: Shows the two ways to access the database with GRDB: synchronous and asynchronous. This example demonstrates syntax differences and explains when to use each approach based on performance considerations and Swift concurrency requirements.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Synchronous database access\ntry writer.write { ... }\n\n// Asynchronous database access\nawait try writer.write { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing HasMany Association with TableRecord in GRDB Swift\nDESCRIPTION: Shows the basic implementation of related Book and Author models with a HasMany relationship following GRDB's conventions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_23\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n}\n\nstruct Author: TableRecord {\n    static let books = hasMany(Book.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Records by Keys or Conditions in Swift using GRDB\nDESCRIPTION: Demonstrates various ways to delete records: by primary key, unique key, multiple IDs, or using filter conditions. These methods are available on types that adopt the TableRecord protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_66\n\nLANGUAGE: swift\nCODE:\n```\ntry Player.deleteOne(db, id: 1)\ntry Player.deleteOne(db, key: [\"email\": \"arthur@example.com\"])\ntry Country.deleteAll(db, ids: [\"FR\", \"US\"])\ntry Player\n    .filter(Column(\"email\") == nil)\n    .deleteAll(db)\n```\n\n----------------------------------------\n\nTITLE: Using SQL Interpolation in GRDB WHERE Clauses\nDESCRIPTION: Example of using SQL Interpolation in GRDB's WHERE clause. This provides a type-safe way to include dynamic values in SQL filtering conditions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_173\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE score >= 1000\nlet minScore = 1000\nlet request = Player.filter(literal: \"score >= \\(minScore)\")\n```\n\n----------------------------------------\n\nTITLE: Extending Default Column Selection in GRDB Swift\nDESCRIPTION: Demonstrates how to select all columns plus additional values like the rowID. This technique allows including metadata or computed columns in query results.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_151\n\nLANGUAGE: swift\nCODE:\n```\n// Select all columns are more\nstruct ExtendedPlayer : TableRecord {\n    static let databaseTableName = \"player\"\n    static var databaseSelection: [any SQLSelectable] {\n        [.allColumns, .rowID]\n    }\n}\n\n// SELECT *, rowid FROM player\nlet request = ExtendedPlayer.all()\n```\n\n----------------------------------------\n\nTITLE: Creating Database Table in GRDB.swift\nDESCRIPTION: Demonstrates how to create a new database table named 'player' with an auto-incremented primary key and additional columns for name and score. The example shows the basic table creation syntax using GRDB's schema modification methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchema.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"name\", .text).notNull()\n    t.column(\"score\", .integer).notNull()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Task Scheduling with ValueObservation in Swift\nDESCRIPTION: Demonstrates how to use the task scheduler with ValueObservation to receive updates on the cooperative thread pool, including with shared observations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    for try await players in observation.values(in: dbQueue) {\n        // Called on the cooperative thread pool\n        print(\"Fresh players\", players)\n    }\n} catch {\n    // Handle error\n}\n\nlet sharedObservation = observation.shared(in: dbQueue, scheduling: .task)\ndo {\n    for try await players in sharedObservation.values() {\n        // Called on the cooperative thread pool\n        print(\"Fresh players\", players)\n    }\n} catch {\n    // Handle error\n}\n\n```\n\n----------------------------------------\n\nTITLE: Batch Operations with RETURNING Clause\nDESCRIPTION: Demonstrates various batch operations with the RETURNING clause, including deleting records and fetching the deleted data, updating records and fetching selected columns from the updated rows.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_88\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.filter(...)...\n\n// Fetch all deleted players\n// DELETE FROM player RETURNING *\nlet deletedPlayers = try request.deleteAndFetchAll(db) // [Player]\n\n// Fetch a selection of columns from the deleted rows\n// DELETE FROM player RETURNING name\nlet statement = try request.deleteAndFetchStatement(db, selection: [Column(\"name\")])\nlet deletedNames = try String.fetchSet(statement)\n\n// Fetch all updated players\n// UPDATE player SET score = score + 10 RETURNING *\nlet updatedPlayers = try request.updateAndFetchAll(db, [Column(\"score\") += 10]) // [Player]\n\n// Fetch a selection of columns from the updated rows\n// UPDATE player SET score = score + 10 RETURNING score\nlet statement = try request.updateAndFetchStatement(\n    db, [Column(\"score\") += 10],\n    select: [Column(\"score\")])\nlet updatedScores = try Int.fetchAll(statement)\n```\n\n----------------------------------------\n\nTITLE: Fetching a Single Place by Key using GRDB in Swift\nDESCRIPTION: This code extends Place to conform to TableRecord protocol, enabling easy fetching of a single place by its key.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nextension Place: TableRecord { ... }\nlet place = try Place.fetchOne(db, key: 1) // Place?\n```\n\n----------------------------------------\n\nTITLE: Basic Association Definition in Swift using GRDB\nDESCRIPTION: Demonstrates basic association setup between Book and Author models using GRDB's belongsTo and hasMany relationships.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_29\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n    static let author = belongsTo(Author.self)\n}\n\nstruct Author: TableRecord {\n    static let books = hasMany(Book.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Querying Full-Text Tables in Swift with GRDB\nDESCRIPTION: This snippet demonstrates the basic workflow for creating FTS tables, populating them with data, building search patterns, and performing searches using both the query interface and raw SQL.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// Create full-text tables\ntry db.create(virtualTable: \"book\", using: FTS4()) { t in // or FTS3(), or FTS5()\n    t.column(\"author\")\n    t.column(\"title\")\n    t.column(\"body\")\n}\n\n// Populate full-text table with records or SQL\ntry Book(...).insert(db)\ntry db.execute(\n    sql: \"INSERT INTO book (author, title, body) VALUES (?, ?, ?)\",\n    arguments: [...])\n\n// Build search patterns\nlet pattern = FTS3Pattern(matchingPhrase: \"Moby-Dick\")\n\n// Search with the query interface or SQL\nlet books = try Book.matching(pattern).fetchAll(db)\nlet books = try Book.fetchAll(db,\n    sql: \"SELECT * FROM book WHERE book MATCH ?\",\n    arguments: [pattern])\n```\n\n----------------------------------------\n\nTITLE: Fetching Places from Database using GRDB in Swift\nDESCRIPTION: This snippet shows how to extend the Place struct to conform to FetchableRecord protocol and use it to fetch all places from the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nextension Place: FetchableRecord { ... }\nlet places = try Place.fetchAll(db, sql: \"SELECT * FROM place\") // [Place]\n```\n\n----------------------------------------\n\nTITLE: Selecting Single Column from Associated Record in GRDB.swift\nDESCRIPTION: Shows how to fetch books with only the author name from associated author records using annotations and custom decodable types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_228\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book\n    var authorName: String? // nil when the book is anonymous\n    \n    static func all() -> QueryInterfaceRequest<BookInfo> {\n        // SELECT book.*, author.name AS authorName\n        // FROM book\n        // LEFT JOIN author ON author.id = book.authorID\n        let authorName = Author.Columns.name.forKey(CodingKeys.authorName)\n        return Book\n            .annotated(withOptional: Book.author.select(authorName))\n            .asRequest(of: BookInfo.self)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Notifying Undetected Changes to Transaction Observers in Swift\nDESCRIPTION: This Swift code snippet shows how to explicitly notify transaction observers of changes that are not automatically detected. It demonstrates notifying changes for the entire database, a specific table, and the database schema.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Notify observers that some changes were performed in the database\n    try db.notifyChanges(in: .fullDatabase)\n\n    // Notify observers that some changes were performed in the player table\n    try db.notifyChanges(in: Player.all())\n\n    // Equivalent alternative\n    try db.notifyChanges(in: Table(\"player\"))\n}\n\ntry dbQueue.write { db in\n    // Notify all observers of the sqlite_master table\n    try db.notifyChanges(in: Table(\"sqlite_master\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating In-Memory Databases with DatabaseQueue in Swift\nDESCRIPTION: Code demonstrating how to create in-memory SQLite databases, which are useful for testing and SwiftUI previews as they don't require file system cleanup.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseQueue.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nlet dbQueue = try DatabaseQueue()\n```\n\n----------------------------------------\n\nTITLE: Defining GRDB Associations for Authors and Books\nDESCRIPTION: Demonstrates how to define GRDB associations between Author and Book records, including properties to access the associations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nextension Author {\n    static let books = hasMany(Book.self)\n    var books: QueryInterfaceRequest<Book> {\n        request(for: Author.books)\n    }\n}\n\nextension Book {\n    static let author = belongsTo(Author.self)\n    var author: QueryInterfaceRequest<Author> {\n        request(for: Book.author)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Index on JSON Column in SQLite with Swift\nDESCRIPTION: This code creates an index on a specific key within a JSON column to improve query performance. It indexes the 'country' field of the 'address' JSON column in the 'player' table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/JSON.md#2025-04-22_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\ntry db.create(\n    index: \"player_on_country\",\n    on: \"player\",\n    expressions: [\n        JSONColumn(\"address\")[\"country\"],\n    ])\n```\n\n----------------------------------------\n\nTITLE: Defining Strict JSON Schema with Codable in Swift\nDESCRIPTION: This code defines a strict JSON schema using Codable structs in Swift. It creates an Address struct and a Player struct with a Codable Address property, which will be stored as a JSON string in the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/JSON.md#2025-04-22_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Address: Codable {\n    var street: String\n    var city: String\n    var country: String\n}\n\nstruct Player: Codable {\n    var id: String\n    var name: String\n\n    // Stored as a JSON string\n    // {\"street\": \"...\", \"city\": \"...\",  \"country\": \"...\"} \n    var address: Address\n}\n\nextension Player: FetchableRecord, PersistableRecord { }\n```\n\n----------------------------------------\n\nTITLE: Optional Value Querying in GRDB\nDESCRIPTION: Demonstrates how to fetch optional values from database using GRDB's Optional type wrapper.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_35\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    try Optional<Int>.fetchCursor(db, sql: \"SELECT ...\", arguments: ...) // A Cursor of Int?\n    try Optional<Int>.fetchAll(db, sql: \"SELECT ...\", arguments: ...)    // [Int?]\n    try Optional<Int>.fetchSet(db, sql: \"SELECT ...\", arguments: ...)    // Set<Int?>\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Records in Swift using GRDB\nDESCRIPTION: This snippet demonstrates how to delete records from the database using GRDB. It shows various ways to delete records including deleteAll, deleteOne, and filtered deletions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_182\n\nLANGUAGE: swift\nCODE:\n```\n// DELETE FROM player\ntry Player.deleteAll(db)\n\n// DELETE FROM player WHERE team = 'red'\ntry Player\n    .filter(teamColumn == \"red\")\n    .deleteAll(db)\n\n// DELETE FROM player ORDER BY score LIMIT 10\ntry Player\n    .order(scoreColumn)\n    .limit(10)\n    .deleteAll(db)\n\ntry Player.deleteOne(db, id: 1)\ntry Country.deleteAll(db, ids: [\"FR\", \"US\"])\n\ntry Player.deleteOne(db, key: 1)\ntry Country.deleteAll(db, keys: [\"FR\", \"US\"])\ntry Player.deleteOne(db, key: [\"email\": \"arthur@example.com\"])\ntry Citizenship.deleteOne(db, key: [\"citizenId\": 1, \"countryCode\": \"FR\"])\n\n// DELETE FROM document WHERE rowid = 1\ntry Document.deleteOne(db, id: 1)             // Document?\n```\n\n----------------------------------------\n\nTITLE: Working with Values in GRDB\nDESCRIPTION: Examples of using various value types as statement arguments and extracting values from database rows.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_37\n\nLANGUAGE: swift\nCODE:\n```\nlet url: URL = ...\nlet verified: Bool = ...\ntry db.execute(\n    sql: \"INSERT INTO link (url, verified) VALUES (?, ?)\",\n    arguments: [url, verified])\n```\n\n----------------------------------------\n\nTITLE: Fetching Aggregated Values in Swift using GRDB\nDESCRIPTION: This snippet shows how to fetch aggregated values like count, max, and min from the database using GRDB. It demonstrates the use of fetchCount and custom aggregation queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_181\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT COUNT(*) FROM player\nlet count = try Player.fetchCount(db) // Int\n\n// SELECT COUNT(*) FROM player WHERE email IS NOT NULL\nlet count = try Player.filter(emailColumn != nil).fetchCount(db)\n\n// SELECT COUNT(DISTINCT name) FROM player\nlet count = try Player.select(nameColumn).distinct().fetchCount(db)\n\n// SELECT COUNT(*) FROM (SELECT DISTINCT name, score FROM player)\nlet count = try Player.select(nameColumn, scoreColumn).distinct().fetchCount(db)\n\nlet request = Player.select(max(scoreColumn))\nlet maxScore = try Int.fetchOne(db, request) // Int?\n\nlet request = Player.select(min(scoreColumn), max(scoreColumn))\nlet row = try Row.fetchOne(db, request)!     // Row\nlet minScore = row[0] as Int?\nlet maxScore = row[1] as Int?\n```\n\n----------------------------------------\n\nTITLE: Starting Database Region Observation with Error Handling in Swift\nDESCRIPTION: This snippet shows how to start a DatabaseRegionObservation using a DatabaseQueue or DatabasePool. It includes handling of potential errors and defines a callback that executes whenever changes are detected in the observed region.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseRegionObservation.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet cancellable = try observation.start(in: dbQueue) { error in\n    // Handle error\n} onChange: { (db: Database) in\n    print(\"Players were changed\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Table with Various Column Types in Swift\nDESCRIPTION: Demonstrates how to create a table with an auto-incremented primary key and various column types including text, boolean, and double. Shows basic column creation and constraint definition.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE TABLE place (\n//   id INTEGER PRIMARY KEY AUTOINCREMENT,\n//   title TEXT,\n//   favorite BOOLEAN NOT NULL DEFAULT 0,\n//   latitude DOUBLE NOT NULL,\n//   longitude DOUBLE NOT NULL\n// )\ntry db.create(table: \"place\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"title\", .text)\n    t.column(\"favorite\", .boolean).notNull().defaults(to: false)\n    t.column(\"longitude\", .double).notNull()\n    t.column(\"latitude\", .double).notNull()\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Prepared Statements and Fetching Data in Swift\nDESCRIPTION: Demonstrates different ways to execute prepared statements and fetch data, including cursor-based fetching, arrays, and single record retrieval.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Statement.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ntry insertStatement.execute()\n\nlet players = try Player.fetchCursor(selectStatement) // A Cursor of Player\nlet players = try Player.fetchAll(selectStatement)    // [Player]\nlet players = try Player.fetchSet(selectStatement)    // Set<Player>\nlet player =  try Player.fetchOne(selectStatement)     // Player?\n```\n\n----------------------------------------\n\nTITLE: Explicit Transaction Management in GRDB\nDESCRIPTION: Demonstrates explicit transaction handling using inTransaction and manual transaction control methods. Shows both high-level and low-level transaction management approaches.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Transactions.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.inTransaction { db in\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n    return .commit\n}\n\ntry dbQueue.writeWithoutTransaction { db in\n    try db.beginTransaction()\n    ...\n    try db.commit()\n    \n    try db.execute(sql: \"BEGIN TRANSACTION\")\n    ...\n    try db.execute(sql: \"ROLLBACK\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Automatic Timestamps with MutablePersistableRecord in Swift\nDESCRIPTION: Extends the Player model to implement MutablePersistableRecord with willInsert callback that automatically sets both creation and modification dates using the database transaction date. Also updates the id after insertion.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: Encodable, MutablePersistableRecord {\n    /// Sets both `creationDate` and `modificationDate` to the\n    /// transaction date, if they are not set yet.\n    mutating func willInsert(_ db: Database) throws {\n        if creationDate == nil {\n            creationDate = try db.transactionDate\n        }\n        if modificationDate == nil {\n            modificationDate = try db.transactionDate\n        }\n    }\n    \n    /// Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Identifiable Protocol for Records in GRDB.swift\nDESCRIPTION: Demonstrates how to make a record type conform to Swift's Identifiable protocol. This enables type-safe record lookup methods like find(id:), fetchOne(id:), and filter(id:) with compile-time type checking.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_92\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: Identifiable, FetchableRecord, PersistableRecord {\n    var id: Int64 // fulfills the Identifiable requirement\n    var name: String\n    var score: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FetchableRecord with SQL Requests in GRDB.swift\nDESCRIPTION: Demonstrates creating a Player struct that implements FetchableRecord protocol with SQL query methods. Shows how to define type-safe SQL requests and fetch results as strongly-typed objects.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SQLSupport.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: Decodable {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\nextension Player: FetchableRecord {\n    static func filter(name: String) -> SQLRequest<Player> {\n        \"SELECT * FROM player WHERE name = \\(name)\"\n    }\n\n    static func maximumScore() -> SQLRequest<Int> {\n        \"SELECT MAX(score) FROM player\"\n    }\n}\n\ntry dbQueue.read { db in\n    let players = try Player.filter(name: \"O'Reilly\").fetchAll(db) // [Player]\n    let maxScore = try Player.maximumScore().fetchOne(db)          // Int?\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Database Operations with DatabasePool\nDESCRIPTION: Demonstrates basic write and read operations using DatabasePool. Write operations are executed in a protected queue, while read operations can be performed concurrently.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabasePool.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// Modify the database:\ntry dbPool.write { db in\n    try Player(name: \"Arthur\").insert(db)\n}\n\n// Read values:\ntry dbPool.read { db in\n    let players = try Player.fetchAll(db)\n    let playerCount = try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: SQLCipher Database Configuration\nDESCRIPTION: Demonstrates how to configure and open an encrypted database using SQLCipher with custom preparation steps.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_187\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    try db.usePassphrase(\"secret\")\n    try db.execute(sql: \"PRAGMA cipher_page_size = ...\")\n    try db.execute(sql: \"PRAGMA kdf_iter = ...\")\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Setting Statement Arguments in Swift\nDESCRIPTION: Shows how to bind arguments to prepared statements using dictionaries for named parameters and arrays for positional parameters.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Statement.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ninsertStatement.arguments = [\"name\": \"Arthur\", \"score\": 1000]\nselectStatement.arguments = [\"Arthur\"]\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic ValueObservation in Swift\nDESCRIPTION: Creates a ValueObservation that tracks changes to values fetched from a database. Shows both the explicit closure syntax and the shorthand function reference notation for tracking Player records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nlet observation = ValueObservation.tracking { db in\n    // Fetch and return the observed value\n}\n\n// For example, an observation of [Player], which tracks all players:\nlet observation = ValueObservation.tracking { db in\n    try Player.fetchAll(db)\n}\n\n// The same observation, using shorthand notation:\nlet observation = ValueObservation.tracking(Player.fetchAll)\n```\n\n----------------------------------------\n\nTITLE: Mixing Swift Expressions with SQL Interpolation in GRDB\nDESCRIPTION: Example of combining Swift expressions with SQL Interpolation in GRDB queries. This allows mixing GRDB's query interface with custom SQL expressions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_169\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT IFNULL(name, 'O''Brien') AS displayName, score FROM player\nlet defaultName = \"O'Brien\"\nlet displayName: SQL = \"IFNULL(\\(Column(\"name\")), \\(defaultName)) AS displayName\"\nlet request = Player.select(displayName, Column(\"score\"))\n```\n\n----------------------------------------\n\nTITLE: Storing and Fetching Date in SQLite with GRDB.swift\nDESCRIPTION: Demonstrates how to insert and retrieve Date objects from a SQLite database using GRDB.swift. Dates are stored in \"YYYY-MM-DD HH:MM:SS.SSS\" format in UTC timezone with millisecond precision.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_39\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(\n    sql: \"INSERT INTO player (creationDate, ...) VALUES (?, ...)\",\n    arguments: [Date(), ...])\n\nlet row = try Row.fetchOne(db, ...)!\nlet creationDate: Date = row[\"creationDate\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing Place Record with MutablePersistableRecord in Swift\nDESCRIPTION: Example implementation of a Place record type conforming to MutablePersistableRecord protocol with encode method and auto-increment handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_76\n\nLANGUAGE: swift\nCODE:\n```\nextension Place : MutablePersistableRecord {\n    /// The values persisted in the database\n    func encode(to container: inout PersistenceContainer) {\n        container[\"id\"] = id\n        container[\"title\"] = title\n        container[\"latitude\"] = coordinate.latitude\n        container[\"longitude\"] = coordinate.longitude\n    }\n    \n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n\nvar paris = Place(\n    id: nil,\n    title: \"Paris\",\n    coordinate: CLLocationCoordinate2D(latitude: 48.8534100, longitude: 2.3488000))\n\ntry paris.insert(db)\nparis.id   // some value\n```\n\n----------------------------------------\n\nTITLE: Creating a Complex Hierarchical Request in GRDB.swift\nDESCRIPTION: Builds a complex joined request with nested associations. This example includes a book's cover image, author with country, and translator with country - demonstrating multi-level association joining.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_80\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Book\n    .including(optional: Book.coverImage)\n    .including(required: Book.author\n        .including(optional: Person.country))\n    .including(optional: Book.translator\n        .including(optional: Person.country))\n```\n\n----------------------------------------\n\nTITLE: Implementing DatabaseValueConvertible for Custom Types in Swift\nDESCRIPTION: This example demonstrates how to implement the DatabaseValueConvertible protocol for a custom EvenInteger type. It shows the implementation of the required databaseValue and fromDatabaseValue methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseValueConvertible.md#2025-04-22_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nstruct EvenInteger {\n    let value: Int // Guaranteed even\n\n    init?(_ value: Int) {\n        guard value.isMultiple(of: 2) else {\n            return nil // Not an even number\n        }\n        self.value = value\n    }\n}\n\nextension EvenInteger: DatabaseValueConvertible {\n    var databaseValue: DatabaseValue {\n        value.databaseValue\n    }\n\n    static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self? {\n        guard let value = Int.fromDatabaseValue(dbValue) else {\n            return nil // Not an integer\n        }\n        return EvenInteger(value) // Nil if not even\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Notifying Database Changes in Swift\nDESCRIPTION: This snippet shows how to explicitly notify observers about database changes that might not be automatically detected. It demonstrates notifying changes for the entire database or specific tables using the notifyChanges method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseRegionObservation.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Notify observations that some changes were performed in the database\n    try db.notifyChanges(in: .fullDatabase)\n\n    // Notify observations that some changes were performed in the player table\n    try db.notifyChanges(in: Player.all())\n\n    // Equivalent alternative\n    try db.notifyChanges(in: Table(\"player\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Counting Records in Swift using GRDB\nDESCRIPTION: Counts records in a table using the 'fetchCount' method, which can be used with or without filters. This method is available for types that adopt the TableRecord protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_67\n\nLANGUAGE: swift\nCODE:\n```\nlet playerCount: Int = try Player.fetchCount(db)\n\nlet playerWithEmailCount: Int = try Player\n    .filter(Column(\"email\") == nil)\n    .fetchCount(db)\n```\n\n----------------------------------------\n\nTITLE: GRDB Batch Operations with TableRecord in Swift\nDESCRIPTION: Examples of batch database operations for types conforming to TableRecord protocol, including mass updates and deletes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_80\n\nLANGUAGE: swift\nCODE:\n```\n// UPDATE\ntry Place.updateAll(db, ...)\n\n// DELETE\ntry Place.deleteAll(db)\ntry Place.deleteAll(db, ids:...)\ntry Place.deleteAll(db, keys:...)\ntry Place.deleteOne(db, id:...)\ntry Place.deleteOne(db, key:...)\n```\n\n----------------------------------------\n\nTITLE: Handling Untrusted Inputs with GRDB.swift\nDESCRIPTION: A comprehensive example showing how to safely handle untrusted inputs by explicitly managing argument parsing and database value conversion.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_209\n\nLANGUAGE: swift\nCODE:\n```\nlet sql = \"SELECT ...\"\n\n// Some untrusted arguments for the query\nlet arguments: [String: Any] = ...\nlet rows = try Row.fetchCursor(db, sql: sql, arguments: StatementArguments(arguments))\n\nwhile let row = try rows.next() {\n    // Some untrusted database value:\n    let date: Date? = row[0]\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// Untrusted arguments\nif let arguments = StatementArguments(arguments) {\n    let statement = try db.makeStatement(sql: sql)\n    try statement.setArguments(arguments)\n    \n    var cursor = try Row.fetchCursor(statement)\n    while let row = try iterator.next() {\n        // Untrusted database content\n        let dbValue: DatabaseValue = row[0]\n        if dbValue.isNull {\n            // Handle NULL\n        if let date = Date.fromDatabaseValue(dbValue) {\n            // Handle valid date\n        } else {\n            // Handle invalid date\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Identifiable with Custom Primary Key Column in GRDB.swift\nDESCRIPTION: Shows how to implement the Identifiable protocol when the database table has a primary key column that is not named 'id'. This example uses a computed property to map the database column to the required id property.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_94\n\nLANGUAGE: swift\nCODE:\n```\nstruct Country: Identifiable, FetchableRecord, PersistableRecord {\n    var isoCode: String\n    var name: String\n    var population: Int\n    \n    // Fulfill the Identifiable requirement\n    var id: String { isoCode }\n}\n\nlet france = try dbQueue.read { db in\n    try Country.fetchOne(db, id: \"FR\")\n}\n```\n\n----------------------------------------\n\nTITLE: Building Complex SQL Query with SQL Literal\nDESCRIPTION: Example of building a complex SQL query using SQL literals and string concatenation for multi-table joins and grouping.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: Decodable, FetchableRecord, TableRecord {\n    /// A complex request\n    static func complexRequest() -> SQLRequest<Player> {\n        let query: SQL = \"SELECT \\(columnsOf: self) \"\n        query += \"FROM \\(self) \"\n        query += \"JOIN \\(Team.self) ON ...\"\n        query += \"GROUP BY ...\"\n        return SQLRequest(literal: query)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modeling Money Amounts in Swift using GRDB\nDESCRIPTION: Implementation of a Product record that stores money amounts as integer cents in the database while exposing a Decimal property to the application. This approach ensures precise calculations in SQLite while providing a convenient interface for the Swift application.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"product\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"name\", .text).notNull()\n    t.column(\"priceCents\", .integer).notNull()\n}\n\nstruct Product: Codable {\n    var id: Int64?\n    var name: String\n    private var priceCents: Int\n    \n    var price: Decimal {\n        get {\n            Decimal(priceCents) / 100\n        }\n        set {\n            priceCents = Self.cents(for: newValue)\n        }\n    }\n\n    private static func cents(for value: Decimal) -> Int {\n        Int(Double(truncating: NSDecimalNumber(decimal: value * 100)))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Existing Tables in GRDB.swift\nDESCRIPTION: Demonstrates how to alter existing tables by renaming tables, adding columns, renaming columns, and dropping columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n// ALTER TABLE referer RENAME TO referrer\ntry db.rename(table: \"referer\", to: \"referrer\")\n\n// ALTER TABLE player ADD COLUMN hasBonus BOOLEAN\n// ALTER TABLE player RENAME COLUMN url TO homeURL\n// ALTER TABLE player DROP COLUMN score\ntry db.alter(table: \"player\") { t in\n    t.add(column: \"hasBonus\", .boolean)\n    t.rename(column: \"url\", to: \"homeURL\")\n    t.drop(column: \"score\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Synchronized External Content Full-Text Tables with FTS4/FTS5 in Swift\nDESCRIPTION: Creates a regular table and a synchronized full-text table that indexes content from the regular table. The synchronize(withTable:) method automatically keeps the full-text index up-to-date with changes to the content table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\n// A regular table\ntry db.create(table: \"book\") { t in\n    t.column(\"author\", .text)\n    t.column(\"title\", .text)\n    t.column(\"content\", .text)\n    ...\n}\n\n// A full-text table synchronized with the regular table\ntry db.create(virtualTable: \"book_ft\", using: FTS4()) { t in // or FTS5()\n    t.synchronize(withTable: \"book\")\n    t.column(\"author\")\n    t.column(\"title\")\n    t.column(\"content\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating JSON Column in SQLite Database with Swift\nDESCRIPTION: This snippet demonstrates how to create a table with a JSON column using GRDB.swift. It creates a 'player' table with an 'address' column of type 'jsonText'.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/JSON.md#2025-04-22_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\ntry db.create(table: \"player\") { t in\n    t.primaryKey(\"id\", .text)\n    t.column(\"name\", .text).notNull()\n    t.column(\"address\", .jsonText).notNull() // A JSON column\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom SQL Function in Swift\nDESCRIPTION: Creates a custom 'reverse' SQL function that takes a string input and returns its reversed version. The function is pure, taking one argument, and handles nil values properly.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_48\n\nLANGUAGE: swift\nCODE:\n```\nlet reverse = DatabaseFunction(\"reverse\", argumentCount: 1, pure: true) { (values: [DatabaseValue]) in\n    // Extract string value, if any...\n    guard let string = String.fromDatabaseValue(values[0]) else {\n        return nil\n    }\n    // ... and return reversed string:\n    return String(string.reversed())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SQL String Interpolation in Swift\nDESCRIPTION: Introduces SQL string interpolation capabilities with SQLLiteral and SQLInterpolation types. These provide type-safe SQL construction with proper argument handling, allowing for more readable and maintainable SQL code while preserving SQL injection protection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_33\n\nLANGUAGE: swift\nCODE:\n```\n+extension SQLRequest: ExpressibleByStringInterpolation {\n+    init(stringInterpolation sqlInterpolation: SQLInterpolation)\n+}\n \n+struct SQLLiteral: ExpressibleByStringInterpolation {\n+    var sql: String { get }\n+    var arguments: StatementArguments { get }\n+    init(stringInterpolation sqlInterpolation: SQLInterpolation)\n+    init(sql: String, arguments: StatementArguments = StatementArguments())\n+    func mapSQL(_ transform: (String) throws -> String) rethrows -> SQLLiteral\n+    mutating func append(sql: String, arguments: StatementArguments = StatementArguments())\n+    mutating func append(literal sqlLiteral: SQLLiteral)\n+    static func + (lhs: SQLLiteral, rhs: SQLLiteral) -> SQLLiteral\n+    static func += (lhs: inout SQLLiteral, rhs: SQLLiteral)\n+}\n\n+extension Sequence where Element == SQLLiteral {\n+    func joined(separator: String = \"\") -> SQLLiteral\n+}\n\n+struct SQLInterpolation: StringInterpolationProtocol {\n+    mutating func appendLiteral(_ sql: String)\n+    mutating func appendInterpolation(sql: String, arguments: StatementArguments = StatementArguments())\n+    mutating func appendInterpolation(literal sqlLiteral: SQLLiteral)\n+    mutating func appendInterpolation<T: TableRecord>(_ table: T.Type)\n+    mutating func appendInterpolation<T: TableRecord>(tableOf record: T)\n+    mutating func appendInterpolation(_ selection: SQLSelectable)\n+    mutating func appendInterpolation<T: SQLExpressible>(_ expressible: T?)\n+    mutating func appendInterpolation(_ codingKey: CodingKey)\n+    mutating func appendInterpolation<S>(_ sequence: S) where S: Sequence, S.Element: SQLExpressible\n+    mutating func appendInterpolation(_ ordering: SQLOrderingTerm)\n+    mutating func appendInterpolation<T>(_ request: SQLRequest<T>)\n+}\n```\n\n----------------------------------------\n\nTITLE: Creating a Data-Consistent HallOfFame Publisher in Swift\nDESCRIPTION: Demonstrates the correct approach to maintain data consistency by using a single ValueObservation that performs multiple database requests. This ensures that database invariants are preserved even when the database changes between operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nstruct HallOfFame {\n    // Invariant: bestPlayers.count <= totalPlayerCount\n    var totalPlayerCount: Int\n    var bestPlayers: [Player]\n}\n\n// CORRECT: DATA CONSISTENCY GUARANTEED\nlet hallOfFamePublisher = ValueObservation\n    .tracking { db -> HallOfFame in\n        // 1st request\n        let totalPlayerCount = try Player.fetchCount(db)\n        \n        // 2nd request\n        let bestPlayers = try Player\n            .order(Column(\"score\").desc)\n            .limit(10)\n            .fetchAll(db)\n        \n        // 100% guaranteed\n        assert(bestPlayers.count <= totalPlayerCount)\n        \n        // Merge results together\n        return HallOfFame(\n            totalPlayerCount: totalPlayerCount,\n            bestPlayers: bestPlayers)\n    }\n    .publisher(in: dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Combining SQL Interpolation with Swift Conditions in GRDB\nDESCRIPTION: Example of mixing SQL Interpolation with Swift conditions in GRDB queries. This allows combining custom SQL expressions with GRDB's query interface operators.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_174\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE (score >= 1000) AND (team = 'red')\nlet minScore = 1000\nlet scoreCondition: SQL = \"\\(Column(\"score\")) >= \\(minScore)\"\nlet request = Player.filter(scoreCondition && Column(\"team\") == \"red\")\n```\n\n----------------------------------------\n\nTITLE: Chaining Query Methods in GRDB Swift\nDESCRIPTION: Demonstrates how to refine requests by chaining multiple query methods. This example shows how to filter records and apply ordering in a single query.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_144\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE (email IS NOT NULL) ORDER BY name\nPlayer.order(nameColumn).filter(emailColumn != nil)\n```\n\n----------------------------------------\n\nTITLE: Fetching Books for an Author Using GRDB Associations\nDESCRIPTION: Shows how to fetch books for a specific author using GRDB associations, simplifying the query process.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet books = try author.books.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Creating Various Types of DatabaseRegionObservation in Swift\nDESCRIPTION: This code demonstrates different ways to create DatabaseRegionObservation objects that track specific columns, tables, or the entire database. Each example shows how to define a precise observation target.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseRegionObservation.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Observe the score column of the 'player' table\nlet observation = DatabaseRegionObservation(\n    tracking: Player.select(Column(\"score\")))\n\n// Observe the 'score' column of the 'player' table\nlet observation = DatabaseRegionObservation(\n    tracking: SQLRequest(\"SELECT score FROM player\"))\n\n// Observe both the 'player' and 'team' tables\nlet observation = DatabaseRegionObservation(\n    tracking: Table(\"player\"), Table(\"team\"))\n\n// Observe the full database\nlet observation = DatabaseRegionObservation(\n    tracking: .fullDatabase)\n```\n\n----------------------------------------\n\nTITLE: Annotating with Association Data in GRDB\nDESCRIPTION: Shows how to extend selections with data from associated records, using either required or optional joins to include columns from related tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_128\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT player.*, team.color\n// FROM player\n// JOIN team ON team.id = player.teamId\nPlayer.annotated(withRequired: Player.team.select(colorColumn))\n```\n\n----------------------------------------\n\nTITLE: Fetching Column Values with Cursors in GRDB\nDESCRIPTION: Demonstrates fetching values from specific columns using a cursor that allows iterating through results efficiently without loading everything into memory at once.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    let urls = try URL.fetchCursor(db, sql: \"SELECT url FROM wine\")\n    while let url = try urls.next() {\n        print(url)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FetchableRecord for Custom Types in Swift using GRDB\nDESCRIPTION: Shows how to implement the FetchableRecord protocol for a custom type. This implementation extracts values from database rows to initialize the struct properties.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_68\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place {\n    var id: Int64?\n    var title: String\n    var coordinate: CLLocationCoordinate2D\n}\n\nextension Place : FetchableRecord {\n    init(row: Row) {\n        id = row[\"id\"]\n        title = row[\"title\"]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[\"latitude\"],\n            longitude: row[\"longitude\"])\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Required Associated Records with including(required:) in Swift\nDESCRIPTION: This snippet demonstrates how to use the including(required:) method to fetch a book along with its associated author. It defines a BookInfo struct that includes both the Book and Author records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_42\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book     // The base record\n    var author: Author // The associated record\n}\n\nlet bookInfos = try Book\n    .including(required: Book.author)\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Using GRDB Records for SQL Injection Protection\nDESCRIPTION: Example of using GRDB's record objects and query interface to safely update records without risk of SQL injection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_204\n\nLANGUAGE: swift\nCODE:\n```\nlet id = 1\nlet name = textField.text\ntry dbQueue.write { db in\n    if var student = try Student.fetchOne(db, id: id) {\n        student.name = name\n        try student.update(db)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Associations Between Records in GRDB\nDESCRIPTION: Example showing how to define belongs-to and has-many associations between records. The code establishes that each book belongs to an author, and each author has many books based on the authorId column.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nextension Book {\n    static let author = belongsTo(Author.self)\n}\n\nextension Author {\n    static let books = hasMany(Book.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Database Support for Tagged Values in Swift\nDESCRIPTION: This snippet shows how to add GRDB database support for Tagged values, a popular library for enhancing type safety. It demonstrates retroactive conformance to various GRDB protocols.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseValueConvertible.md#2025-04-22_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nimport GRDB\nimport Tagged\n\n// Add database support to Tagged values\nextension Tagged: @retroactive SQLExpressible where RawValue: SQLExpressible { }\nextension Tagged: @retroactive StatementBinding where RawValue: StatementBinding { }\nextension Tagged: @retroactive StatementColumnConvertible where RawValue: StatementColumnConvertible { }\nextension Tagged: @retroactive DatabaseValueConvertible where RawValue: DatabaseValueConvertible { }\n```\n\n----------------------------------------\n\nTITLE: Handling Special Characters with SQL Interpolation in Swift\nDESCRIPTION: Example demonstrating how SQL interpolation automatically handles special characters like single quotes in string values to prevent SQL injection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet name = \"O'Brien\"\nlet id = 42\ntry dbQueue.write { db in\n    // Executes `UPDATE player SET name = 'O''Brien' WHERE id = 42`\n    try db.execute(literal: \"UPDATE player SET name = \\(name) WHERE id = \\(id)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BelongsTo and HasOne Relationships Between Records in Swift\nDESCRIPTION: Demonstrates the proper way to establish a one-to-one relationship between two record types using complementary BelongsTo and HasOne associations. Shows how to determine which association type to use based on foreign key placement.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nstruct Country: TableRecord {\n    static let demographics = hasOne(Demographics.self)\n    ...\n}\n\nstruct Demographics: TableRecord {\n    static let country = belongsTo(Country.self)\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Including Associated Records in Swift using GRDB\nDESCRIPTION: Demonstrates how to fetch player records along with their associated team records through a required association. This creates a JOIN query that includes columns from both tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_140\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT player.*, team.*\n// FROM player\n// JOIN team ON team.id = player.teamId\nPlayer.including(required: Player.team)\n```\n\n----------------------------------------\n\nTITLE: Fetching Aggregate Values from a Single Record in Swift\nDESCRIPTION: Example of how to compute aggregates from a single record using regular aggregating methods on requests for associated records. This shows how to count books and find the maximum year for an author.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_88\n\nLANGUAGE: swift\nCODE:\n```\nstruct Author: TableRecord, EncodableRecord {\n    static let books = hasMany(Book.self)\n    var books: QueryInterfaceRequest<Book> {\n        request(for: Author.books)\n    }\n}\n\nlet author: Author = ...\n\n// The number of books by this author\nlet bookCount = try author.books.fetchCount(db)  // Int\n\n// The year of the most recent book by this author\nlet request = author.books.select(max(yearColumn))\nlet maxBookYear = try Int.fetchOne(db, request)  // Int?\n```\n\n----------------------------------------\n\nTITLE: Creating FTS3/FTS4 Virtual Tables in Swift with GRDB\nDESCRIPTION: This snippet demonstrates how to create FTS3 and FTS4 virtual tables for full-text search. These tables store and index textual content for efficient searching.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE VIRTUAL TABLE document USING fts3(content)\ntry db.create(virtualTable: \"document\", using: FTS3()) { t in\n    t.column(\"content\")\n}\n\n// CREATE VIRTUAL TABLE document USING fts4(content)\ntry db.create(virtualTable: \"document\", using: FTS4()) { t in\n    t.column(\"content\")\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Results in GRDB Queries\nDESCRIPTION: Demonstrates the group() method which allows for aggregating results by specific columns. This example groups players by name and selects the maximum score for each group.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_134\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT name, MAX(score) FROM player GROUP BY name\nPlayer\n    .select(nameColumn, max(scoreColumn))\n    .group(nameColumn)\n```\n\n----------------------------------------\n\nTITLE: Default Column Selection in GRDB Swift\nDESCRIPTION: Demonstrates the default SELECT * behavior for table record types. These examples show how queries are constructed to select all columns from a table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_147\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player\nstruct Player: TableRecord { ... }\nlet request = Player.all()\n\n// SELECT * FROM player\nlet table = Table(\"player\")\nlet request = table.all()\n```\n\n----------------------------------------\n\nTITLE: Using Swift Enums with GRDB.swift for Database Storage\nDESCRIPTION: Shows how to use Swift enums with RawRepresentable conformance for database storage and retrieval. Integer and string-backed enums can be stored directly in SQLite columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_46\n\nLANGUAGE: swift\nCODE:\n```\nenum Color : Int {\n    case red, white, rose\n}\n\nenum Grape : String {\n    case chardonnay, merlot, riesling\n}\n\n// Declare empty DatabaseValueConvertible adoption\nextension Color : DatabaseValueConvertible { }\nextension Grape : DatabaseValueConvertible { }\n\n// Store\ntry db.execute(\n    sql: \"INSERT INTO wine (grape, color) VALUES (?, ?)\",\n    arguments: [Grape.merlot, Color.red])\n\n// Read\nlet rows = try Row.fetchCursor(db, sql: \"SELECT * FROM wine\")\nwhile let row = try rows.next() {\n    let grape: Grape = row[\"grape\"]\n    let color: Color = row[\"color\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Canceling Database Observation in Swift\nDESCRIPTION: This code demonstrates how to manually cancel an active database observation by calling the cancel() method on the DatabaseCancellable object returned when starting the observation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseRegionObservation.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ncancellable.cancel()\n```\n\n----------------------------------------\n\nTITLE: Implementing TableRecord in Swift using GRDB\nDESCRIPTION: Shows how to implement the TableRecord protocol, which automatically derives the database table name from the type name, or allows specifying a custom table name.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_72\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place: TableRecord { }\n\nprint(Place.databaseTableName) // prints \"place\"\n```\n\n----------------------------------------\n\nTITLE: Opening Read-Only Database Connection in Swift\nDESCRIPTION: Demonstrates how to establish a read-only connection to a database resource bundled with the application. Uses Configuration to set readonly mode and handles cases where the database resource cannot be found.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseConnections.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// HOW TO open a read-only connection to a database resource\n\n// Get the path to the database resource.\n// Replace `Bundle.main` with `Bundle.module` when you write a Swift Package.\nif let dbPath = Bundle.main.path(forResource: \"db\", ofType: \"sqlite\")\n\nif let dbPath {\n    // If the resource exists, open a read-only connection.\n    // Writes are disallowed because resources can not be modified. \n    var config = Configuration()\n    config.readonly = true\n    let dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n} else {\n    // The database resource can not be found.\n    // Fix your setup, or report the problem to the user. \n}\n```\n\n----------------------------------------\n\nTITLE: Defining Core GRDB Persistence Protocols in Swift\nDESCRIPTION: Core protocol definitions for database record persistence including EncodableRecord, MutablePersistableRecord, and PersistableRecord. These protocols enable database encoding and persistence operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_75\n\nLANGUAGE: swift\nCODE:\n```\n// Defines how a record encodes itself into the database\nprotocol EncodableRecord {\n    /// Defines the values persisted in the database\n    func encode(to container: inout PersistenceContainer) throws\n}\n\n// Adds persistence methods\nprotocol MutablePersistableRecord: TableRecord, EncodableRecord {\n    /// Optional method that lets your adopting type store its rowID upon\n    /// successful insertion. Don't call it directly: it is called for you.\n    mutating func didInsert(_ inserted: InsertionSuccess)\n}\n\n// Adds immutability\nprotocol PersistableRecord: MutablePersistableRecord {\n    /// Non-mutating version of the optional didInsert(_:)\n    func didInsert(_ inserted: InsertionSuccess)\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering by ID for Identifiable Records in GRDB\nDESCRIPTION: Shows type-safe filtering methods available on Identifiable Records to retrieve records by their ID or IDs, making common queries more concise.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_131\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE id = 1\nPlayer.filter(id: 1)\n\n// SELECT * FROM country WHERE isoCode IN ('FR', 'US')\nCountry.filter(ids: [\"FR\", \"US\"])\n```\n\n----------------------------------------\n\nTITLE: SQL Interpolation with Associations in Swift\nDESCRIPTION: Example showing how SQL literals work with query interface associations and automatic table disambiguation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT player.*, team.*\n// FROM player\n// JOIN team ON team.id = player.teamID\n// WHERE DATE(player.createdAt) = '2020-01-23'\n//       ~~~~~~~~~~~~~~~~~~~~~~\n//       automatic table disambiguation\nlet request = Player\n    .filter(creationDay == \"2020-01-23\")\n    .including(required: Player.team)\n```\n\n----------------------------------------\n\nTITLE: Filtering Grouped Results with Having in GRDB\nDESCRIPTION: Shows using the having() method to filter grouped results based on aggregate conditions, allowing for queries that filter based on group properties.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_135\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT team, MAX(score) FROM player GROUP BY team HAVING MIN(score) >= 1000\nPlayer\n    .select(teamColumn, max(scoreColumn))\n    .group(teamColumn)\n    .having(min(scoreColumn) >= 1000)\n```\n\n----------------------------------------\n\nTITLE: Defining Type-Safe Columns Using CodingKeys\nDESCRIPTION: Shows a pattern for creating type-safe column references based on a record's CodingKeys. This approach helps prevent typos in column names and maintains consistency between the Swift model and database schema.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_105\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: Codable {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\nextension Player: FetchableRecord, PersistableRecord {\n    enum Columns {\n        static let id = Column(CodingKeys.id)\n        static let name = Column(CodingKeys.name)\n        static let score = Column(CodingKeys.score)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Non-Associated Records in GRDB.swift\nDESCRIPTION: Demonstrates how to filter and fetch books that do not have any associated authors using left joins and exists conditions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_227\n\nLANGUAGE: swift\nCODE:\n```\nlet books: [Book] = try dbQueue.read { db in\n    // SELECT book.* FROM book\n    // LEFT JOIN author ON author.id = book.authorID\n    // WHERE author.id IS NULL\n    let authorAlias = TableAlias()\n    let request = Book\n        .joining(optional: Book.author.aliased(authorAlias))\n        .filter(!authorAlias.exists)\n    return try request.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Query Arguments in GRDB.swift\nDESCRIPTION: Shows how to use positional and named arguments in SQL queries with GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\nlet rows = try Row.fetchAll(db,\n    sql: \"SELECT * FROM player WHERE name = ?\",\n    arguments: [\"Arthur\"])\n\nlet rows = try Row.fetchAll(db,\n    sql: \"SELECT * FROM player WHERE name = :name\",\n    arguments: [\"name\": \"Arthur\"])\n```\n\n----------------------------------------\n\nTITLE: Using LIKE Operator in GRDB Query Interface with Swift\nDESCRIPTION: Shows how to use the newly supported LIKE operator in a GRDB query to filter records based on a pattern match.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_99\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM persons WHERE email LIKE '%@example.com'\nPerson.filter(Column(\"email\").like(\"%@example.com\")).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Memory-Efficient Data Handling in GRDB\nDESCRIPTION: Shows how to work with BLOB data efficiently by avoiding unnecessary copies during data fetching.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_38\n\nLANGUAGE: swift\nCODE:\n```\nlet rows = try Row.fetchCursor(db, sql: \"SELECT data, ...\")\nwhile let row = try rows.next() {\n    try row.withUnsafeData(name: \"data\") { (data: Data?) in\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Logical Operators in GRDB.swift\nDESCRIPTION: Examples of using logical operators (AND, OR, NOT) in GRDB queries, which are derived from Swift's &&, || and ! operators. Also demonstrates joining a sequence of expressions with logical operators.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_156\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE ((NOT verified) OR (score < 1000))\nPlayer.filter(!verifiedColumn || scoreColumn < 1000)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE (verified AND (score >= 1000) AND (name IS NOT NULL))\nlet conditions = [\n    verifiedColumn,\n    scoreColumn >= 1000,\n    nameColumn != nil]\nPlayer.filter(conditions.joined(operator: .and))\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE 1\nPlayer.filter([].joined(operator: .and))\n\n// SELECT * FROM player WHERE 0\nPlayer.filter([].joined(operator: .or))\n```\n\n----------------------------------------\n\nTITLE: Filtering Associated Records in GRDB.swift\nDESCRIPTION: This example demonstrates how to filter associated records using the filter method. It fetches books written by French authors.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_55\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*\n// FROM book\n// JOIN person ON person.id = book.authorId\n//            AND person.countryCode = 'FR'\nlet frenchAuthor = Book.author.filter(Column(\"countryCode\") == \"FR\")\nlet request = Book.joining(required: frenchAuthor)\n\n// This request feeds the Book record:\nlet books: [Book] = try request.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Tracking Database Objects with ValueObservation in Swift\nDESCRIPTION: Example of using ValueObservation to track changes to a specific player record. This code starts an observer that will notify whenever the player with ID 42 changes in the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_40\n\nLANGUAGE: swift\nCODE:\n```\nlet observer = ValueObversation\n    .trackingOne(Player.filter(key: 42))\n    .start(in: dbQueue) { player: Player? in\n        print(\"Player has changed\")\n    }\n```\n\n----------------------------------------\n\nTITLE: Full-Text Search with Matching in GRDB\nDESCRIPTION: Shows how to use the matching() method for performing full-text search on FTS3 or FTS5 tables, allowing for efficient text search capabilities.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_133\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM document WHERE document MATCH 'sqlite database'\nlet pattern = FTS3Pattern(matchingAllTokensIn: \"SQLite database\")\nDocument.matching(pattern)\n```\n\n----------------------------------------\n\nTITLE: Transaction Notification Flow in GRDB\nDESCRIPTION: Demonstrates the sequence of notifications during database writes and transactions, including commit and rollback scenarios.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.execute(sql: \"INSERT ...\") // 1. didChange\n    try db.execute(sql: \"UPDATE ...\") // 2. didChange\n}                                     // 3. willCommit, 4. didCommit\n\ntry dbQueue.inTransaction { db in\n    try db.execute(sql: \"INSERT ...\") // 1. didChange\n    try db.execute(sql: \"UPDATE ...\") // 2. didChange\n    return .rollback                  // 3. didRollback\n}\n\ntry dbQueue.write { db in\n    try db.execute(sql: \"INSERT ...\") // 1. didChange\n    throw SomeError()\n}                                     // 2. didRollback\n```\n\n----------------------------------------\n\nTITLE: Using Cursors for Lazy Loading in GRDB.swift\nDESCRIPTION: Shows how to use cursors for step-by-step loading of database results, which is memory efficient for large datasets.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    // Cursor of Player\n    let players = try Player.fetchCursor(db, sql: \"SELECT ...\")\n    while let player = try players.next() {\n        // use player\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Place from Database using GRDB in Swift\nDESCRIPTION: This snippet demonstrates how to make Place conform to PersistableRecord protocol, allowing it to delete itself from the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nextension Place: PersistableRecord { ... }\ntry place.delete(db)\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Migration for HasMany Association in GRDB Swift\nDESCRIPTION: Demonstrates the recommended database migration for setting up tables with a HasMany relationship. Creates author and book tables with proper foreign key constraints and indexing.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"Books and Authors\") { db in\n    try db.create(table: \"author\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")             // (1)\n        t.column(\"name\", .text)\n    }\n    try db.create(table: \"book\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.belongsTo(\"author\", onDelete: .cascade)     // (2)\n            .notNull()                                // (3)\n        t.column(\"title\", .text)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Through Associations for Indirect Relationships in Swift\nDESCRIPTION: Adds HasManyThroughAssociation and HasOneThroughAssociation types for creating indirect associations through intermediate models. These types support many-to-many and one-to-one relationships that pass through a pivot table or model.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_30\n\nLANGUAGE: swift\nCODE:\n```\n+struct HasManyThroughAssociation<Origin, Destination>: AssociationToMany { }\n+extension HasManyThroughAssociation: TableRequest where Destination: TableRecord { }\n+struct HasOneThroughAssociation<Origin, Destination>: AssociationToOne { }\n+extension HasOneThroughAssociation: TableRequest where Destination: TableRecord { }\n \n extension TableRecord {\n+    static func hasMany<Pivot, Target>(_ destination: Target.RowDecoder.Type, through pivot: Pivot, using target: Target, key: String? = nil) -> HasManyThroughAssociation<Self, Target.RowDecoder> where Pivot: Association, Target: Association, Pivot.OriginRowDecoder == Self, Pivot.RowDecoder == Target.OriginRowDecoder\n+    static func hasOne<Pivot, Target>(_ destination: Target.RowDecoder.Type, through pivot: Pivot, using target: Target, key: String? = nil) -> HasOneThroughAssociation<Self, Target.RowDecoder> where Pivot: AssociationToOne, Target: AssociationToOne, Pivot.OriginRowDecoder == Self, Pivot.RowDecoder == Target.OriginRowDecoder\n }\n```\n\n----------------------------------------\n\nTITLE: Savepoint Operations in GRDB\nDESCRIPTION: Examples of using savepoints for nested transaction-like operations. Shows how to implement rollback points within larger transactions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Transactions.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.inSavepoint {\n        try Credit(destinationAccount, amount).insert(db)\n        try Debit(sourceAccount, amount).insert(db)\n        return .commit\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Records with FetchableRecord in Swift using GRDB\nDESCRIPTION: Shows the different methods available for fetching records that adopt the FetchableRecord protocol, including fetchCursor, fetchAll, fetchSet, and fetchOne.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_71\n\nLANGUAGE: swift\nCODE:\n```\ntry Place.fetchCursor(db, sql: \"SELECT ...\", arguments:...) // A Cursor of Place\ntry Place.fetchAll(db, sql: \"SELECT ...\", arguments:...)    // [Place]\ntry Place.fetchSet(db, sql: \"SELECT ...\", arguments:...)    // Set<Place>\ntry Place.fetchOne(db, sql: \"SELECT ...\", arguments:...)    // Place?\n```\n\n----------------------------------------\n\nTITLE: Handling NULL Values in GRDB.swift\nDESCRIPTION: Shows how to handle NULL values from database rows by using optional types. This ensures type safety when working with columns that may contain NULL.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_23\n\nLANGUAGE: swift\nCODE:\n```\nlet name: String? = row[\"name\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing DatabaseValueConvertible for Codable Types in Swift\nDESCRIPTION: This example demonstrates how to implement DatabaseValueConvertible for Codable types, which are automatically encoded and decoded as JSON objects in the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseValueConvertible.md#2025-04-22_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Color: Codable {\n    var red: Double\n    var green: Double\n    var blue: Double\n}\n\n// Encodes and decodes `Color` as a JSON object in the database:\nextension Color: DatabaseValueConvertible { }\n```\n\n----------------------------------------\n\nTITLE: Tracing SQL Statements in GRDB Swift\nDESCRIPTION: This snippet shows how to configure SQL statement tracing using the prepareDatabase method. It sets up a trace function that prints all executed SQL requests, making it useful for debugging database operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Configuration.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.trace { print(\"SQL> \\($0)\") }\n}\n\nlet dbQueue = try DatabaseQueue(\n    path: \"/path/to/database.sqlite\",\n    configuration: config)\n\n// Prints \"SQL> SELECT COUNT(*) FROM player\"\nlet playerCount = dbQueue.read { db in\n    try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Books with Optional Author using including(optional:)\nDESCRIPTION: Demonstrates how to fetch books along with their optional authors using LEFT JOIN.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_34\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, author.* \n// FROM book\n// LEFT JOIN author ON author.id = book.authorId\nlet request = Book.including(optional: Book.author)\n```\n\n----------------------------------------\n\nTITLE: Using SQLSubqueryable for Average Score Comparison\nDESCRIPTION: Example demonstrating how to use SQLSubqueryable to create a subquery that compares player scores against the average score.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_24\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player\n// WHERE score >= (SELECT AVG(score) FROM player)\nlet averageScore = Player.select(average(Column(\"score\")))\nPlayer.filter(Column(\"score\") >= averageScore)\n```\n\n----------------------------------------\n\nTITLE: MATCH Operator for Full-Text Search in GRDB.swift\nDESCRIPTION: Examples of using the MATCH operator for full-text search with FTS3, FTS4, and FTS5 tables through pattern matching classes provided by GRDB.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_160\n\nLANGUAGE: swift\nCODE:\n```\nlet pattern = FTS3Pattern(matchingAllTokensIn: \"SQLite database\")\n\n// SELECT * FROM document WHERE document MATCH 'sqlite database'\nDocument.matching(pattern)\n\n// SELECT * FROM document WHERE content MATCH 'sqlite database'\nDocument.filter(contentColumn.match(pattern))\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet pattern = FTS5Pattern(matchingAllTokensIn: \"SQLite database\")\n\n// SELECT * FROM document WHERE document MATCH 'sqlite database'\nDocument.matching(pattern)\n```\n\n----------------------------------------\n\nTITLE: Fetching Books with Required Author Columns\nDESCRIPTION: Demonstrates how to fetch books with required author columns using an INNER JOIN.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_39\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, author.name, author.country\n// FROM book\n// JOIN author ON author.id = book.authorId\nlet request = Book.annotated(withRequired: Book.author.select(Column(\"name\"), Column(\"country\")))\n```\n\n----------------------------------------\n\nTITLE: Advanced Passphrase Management with SQLCipher in Swift\nDESCRIPTION: Shows how to directly use SQLCipher's C functions for precise control over passphrase bytes in memory. This approach gives the maximum control over the lifetime of sensitive passphrase data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_192\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    ... // Carefully load passphrase bytes\n    let code = sqlite3_key(db.sqliteConnection, /* passphrase bytes */)\n    ... // Carefully dispose passphrase bytes\n    guard code == SQLITE_OK else {\n        throw DatabaseError(\n            resultCode: ResultCode(rawValue: code), \n            message: db.lastErrorMessage)\n    }\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Database Access with Swift Concurrency in GRDB\nDESCRIPTION: Demonstrates async/await pattern for database access that doesn't block the current thread. Shows both read and write operations with async functions that support cancellation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nlet playerCount = try await dbQueue.read { db in\n    try Player.fetchCount(db)\n}\n\nlet newPlayerCount = try await dbQueue.write { db -> Int in\n    try Player(name: \"Arthur\").insert(db)\n    return try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Savepoint Handling in GRDB Transactions\nDESCRIPTION: Illustrates how changes within savepoints are notified only after the savepoint is released, ensuring notifications only occur for committable changes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.inTransaction { db in\n    try db.execute(sql: \"INSERT ...\")            // 1. didChange\n\n    try db.execute(sql: \"SAVEPOINT foo\")\n    try db.execute(sql: \"UPDATE ...\")            // delayed\n    try db.execute(sql: \"UPDATE ...\")            // delayed\n    try db.execute(sql: \"RELEASE SAVEPOINT foo\") // 2. didChange, 3. didChange\n\n    try db.execute(sql: \"SAVEPOINT bar\")\n    try db.execute(sql: \"UPDATE ...\")            // not notified\n    try db.execute(sql: \"ROLLBACK TO SAVEPOINT bar\")\n    try db.execute(sql: \"RELEASE SAVEPOINT bar\")\n\n    return .commit                               // 4. willCommit, 5. didCommit\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Single-Row Table Implementation in Swift\nDESCRIPTION: Full implementation template combining table creation, record structure, default values, and database access functionality.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SingleRowTables.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"appConfiguration\") { t in\n    t.primaryKey(\"id\", .integer, onConflict: .replace)\n        .check { $0 == 1 }\n    \n    t.column(\"storedFlag\", .boolean)\n}\n\nstruct AppConfiguration: Codable {\n    private var id = 1\n    private var storedFlag: Bool?\n}\n\nextension AppConfiguration {\n    var flag: Bool {\n        get { storedFlag ?? true }\n        set { storedFlag = newValue }\n    }\n\n    mutating func resetFlag() {\n        storedFlag = nil\n    }\n}\n\nextension AppConfiguration {\n    static let `default` = AppConfiguration(storedFlag: nil)\n}\n\nextension AppConfiguration: FetchableRecord, PersistableRecord {\n    func willUpdate(_ db: Database, columns: Set<String>) throws {\n        if try !exists(db) {\n            try AppConfiguration.default.insert(db)\n        }\n    }\n    \n    static func find(_ db: Database) throws -> AppConfiguration {\n        try fetchOne(db) ?? .default\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Values from Database Operations\nDESCRIPTION: Shows how to return values from database read and write operations. Both methods can return values through closure return statements.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabasePool.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet playerCount = try dbPool.read { db in\n    try Place.fetchCount(db)\n}\n\nlet newPlayerCount = try dbPool.write { db -> Int in\n    try Player(name: \"Arthur\").insert(db)\n    return try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Records with update Method in Swift using GRDB\nDESCRIPTION: Updates a record in the database using the 'update' method. This requires the type to adopt the PersistableRecord protocol and will save all fields to the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_62\n\nLANGUAGE: swift\nCODE:\n```\nvar player: Player = ...\nplayer.score = 1000\ntry player.update(db)\n```\n\n----------------------------------------\n\nTITLE: Filtering Authors with No Books in Swift\nDESCRIPTION: Shows how to filter a request to find authors who didn't write any books using the isEmpty aggregate with the having method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_94\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author.having(Author.books.isEmpty)\n```\n\n----------------------------------------\n\nTITLE: Selecting Primary Keys with GRDB in Swift\nDESCRIPTION: Demonstrates how to select only the primary key column(s) from different tables. The examples show single-column and composite primary keys with appropriate return types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_142\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT id FROM player\nPlayer.selectPrimaryKey(as: Int64.self)    // QueryInterfaceRequest<Int64>\n\n// SELECT code FROM country\nCountry.selectPrimaryKey(as: String.self)  // QueryInterfaceRequest<String>\n\n// SELECT citizenId, countryCode FROM citizenship\nCitizenship.selectPrimaryKey(as: Row.self) // QueryInterfaceRequest<Row>\n```\n\n----------------------------------------\n\nTITLE: Fetching Joined Records with a Decodable Record in GRDB.swift\nDESCRIPTION: Demonstrates how to define a Decodable record structure that matches the association keys in a joined request, then fetches all matching records. The BookInfo struct's properties correspond to the association keys in the request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_76\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var author: Author\n    var country: Country?\n    var coverImage: CoverImage?\n}\n\nlet bookInfos: [BookInfo] = try BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Table with Conflict Resolution Policy in Swift\nDESCRIPTION: Demonstrates how to define conflict resolution policies at the table level using the SQLite CREATE TABLE statement. This example creates a unique column with REPLACE conflict policy to handle duplicate values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_110\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE TABLE player (\n//     id INTEGER PRIMARY KEY AUTOINCREMENT,\n//     email TEXT UNIQUE ON CONFLICT REPLACE\n// )\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"email\", .text).unique(onConflict: .replace) // <--\n}\n\n// Despite the unique index on email, both inserts succeed.\n// The second insert replaces the first row:\ntry db.execute(sql: \"INSERT INTO player (email) VALUES (?)\", arguments: [\"arthur@example.com\"])\ntry db.execute(sql: \"INSERT INTO player (email) VALUES (?)\", arguments: [\"arthur@example.com\"])\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Migration for HasOne Association in GRDB Swift\nDESCRIPTION: Demonstrates the recommended database migration for setting up tables with a HasOne relationship. Creates country and demographics tables with proper foreign key constraints, indexing, and uniqueness.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_26\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"Countries\") { db in\n    try db.create(table: \"country\") { t in\n        t.primaryKey(\"code\", .text)                    // (1)\n        t.column(\"name\", .text)\n    }\n    try db.create(table: \"demographics\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.belongsTo(\"country\", onDelete: .cascade)     // (2)\n            .notNull()                                 // (3)\n            .unique()                                  // (4)\n        t.column(\"population\", .integer)\n        t.column(\"density\", .double)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Transaction Operations in GRDB Swift\nDESCRIPTION: Example showing basic write and read transactions using dbQueue. Demonstrates how to group related database operations within a transaction for data consistency.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Transactions.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n}\n\nlet (credits, debits) = try dbQueue.read { db in\n    let credits = try Credit.fetchAll(db)\n    let debits = try Debit.fetchAll(db)\n    return (credits, debits)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a BelongsTo Association in GRDB Swift\nDESCRIPTION: Shows how to define a BelongsTo relationship between Book and Author models. This relationship indicates that a book belongs to a single author.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\nextension Book: TableRecord {\n    static let author = belongsTo(Author.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Book-Author Association Definition in GRDB.swift\nDESCRIPTION: Demonstrates how to define associations between Book and Author records using GRDB's relationship APIs.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_225\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n    ...\n    static let author = belongsTo(Author.self)\n}\n\nstruct Author: TableRecord {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FetchableRecord for Custom Row Decoding in GRDB.swift\nDESCRIPTION: Shows how to manually decode a joined request using FetchableRecord's init(row:) initializer. This gives more control over how associated records are extracted from the row, using direct subscript access.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_83\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord {\n    var book: Book\n    var author: Author\n    var country: Country?\n    var coverImage: CoverImage?\n    \n    init(row: Row) throws {\n        book = try Book(row: row)\n        author = row[\"author\"]\n        country = row[\"country\"]\n        coverImage = row[\"coverImage\"]\n    }\n}\n\nlet bookInfos: [BookInfo] = try BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Using SQL Interpolation in GRDB SELECT Queries\nDESCRIPTION: Examples of using SQL Interpolation to safely embed values in GRDB SELECT queries. This provides type-safe SQL construction with proper escaping of values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_168\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT IFNULL(name, 'O''Brien'), score FROM player\nlet defaultName = \"O'Brien\"\nlet request = Player.select(literal: \"IFNULL(name, \\(defaultName)), score\")\n```\n\n----------------------------------------\n\nTITLE: Using HasOneThrough Association in GRDB.swift\nDESCRIPTION: This snippet shows how to use HasOneThrough association to directly fetch a book's country through its author, skipping the intermediate author table in the result.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_54\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, country.*\n// FROM book\n// LEFT JOIN person ON person.id = book.authorId\n// LEFT JOIN country ON country.code = person.countryCode\nlet request = Book.including(optional: Book.country)\n\n// This request can feed the following record:\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var country: Country?\n}\nlet bookInfos: [BookInfo] = try BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Using afterNextTransactionCommit Hook\nDESCRIPTION: Shows how to register code that executes only after database changes have been successfully committed, useful for synchronizing the database with external resources.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_84\n\nLANGUAGE: swift\nCODE:\n```\n// Make sure the database is inside a transaction\ndb.inSavepoint {\n    // Perform some database job\n    try ...\n    \n    // Register extra job that is only executed after database changes\n    // have been committed and written to disk.\n    db.afterNextTransactionCommit { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Ordered HasManyThrough Associations in GRDB.swift\nDESCRIPTION: Demonstrates how to define an ordered HasManyThrough association that automatically sorts related records. This creates a Team.players association that inherits ordering from the intermediate PlayerRole table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_62\n\nLANGUAGE: swift\nCODE:\n```\nextension Team {\n    static let playerRoles = hasMany(PlayerRole.self).order(Column(\"position\"))\n    \n    static let players = hasMany(Player.self, through: playerRoles, using: PlayerRole.player)\n    \n    var players: QueryInterfaceRequest<Player> {\n        request(for: Team.players)\n    }\n}\n\nextension PlayerRole {\n    static let player = belongsTo(Player.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling DatabaseError in GRDB.swift\nDESCRIPTION: Example showing how to catch and inspect DatabaseError objects thrown by SQLite operations, including accessing error codes and details.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_205\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try Pet(masterId: 1, name: \"Bobby\").insert(db)\n} catch let error as DatabaseError {\n    // The SQLite error code: 19 (SQLITE_CONSTRAINT)\n    error.resultCode\n    \n    // The extended error code: 787 (SQLITE_CONSTRAINT_FOREIGNKEY)\n    error.extendedResultCode\n    \n    // The eventual SQLite message: FOREIGN KEY constraint failed\n    error.message\n    \n    // The eventual erroneous SQL query\n    // \"INSERT INTO pet (masterId, name) VALUES (?, ?)\"\n    error.sql\n    \n    // The eventual SQL arguments\n    // [1, \"Bobby\"]\n    error.arguments\n    \n    // Full error description\n    // > SQLite error 19: FOREIGN KEY constraint failed -\n    // > while executing `INSERT INTO pet (masterId, name) VALUES (?, ?)`\n    error.description\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Primary, Unique, and Foreign Keys in GRDB.swift\nDESCRIPTION: Demonstrates different ways to define primary keys, unique constraints, and foreign key relationships in table creation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n    // id INTEGER PRIMARY KEY AUTOINCREMENT,\n    t.autoIncrementedPrimaryKey(\"id\")\n\n    // uuid TEXT PRIMARY KEY NOT NULL,\n    t.primaryKey(\"uuid\", .text)\n\n    // teamName TEXT NOT NULL,\n    // position INTEGER NOT NULL,\n    // PRIMARY KEY (teamName, position),\n    t.primaryKey {\n        t.column(\"teamName\", .text)\n        t.column(\"position\", .integer)\n    }\n\n    // email TEXT UNIQUE,\n    t.column(\"email\", .text).unique()\n\n    // teamId TEXT REFERENCES team(id) ON DELETE CASCADE,\n    // countryCode TEXT REFERENCES country(code) NOT NULL,\n    t.belongsTo(\"team\", onDelete: .cascade)\n    t.belongsTo(\"country\").notNull()\n```\n\n----------------------------------------\n\nTITLE: SQL Query for Retrieving Latest Messages from All Chats\nDESCRIPTION: The raw SQL query that uses a Common Table Expression (CTE) to retrieve all chats along with their latest messages, ordered by message date.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_7\n\nLANGUAGE: sql\nCODE:\n```\nWITH latestMessage AS\n  (SELECT *, MAX(date) FROM message GROUP BY chatID)\nSELECT chat.*, latestMessage.*\nFROM chat\nLEFT JOIN latestMessage ON chat.id = latestMessage.chatID\nORDER BY latestMessage.date DESC\n```\n\n----------------------------------------\n\nTITLE: Updating Records with GRDB's Record API in Swift\nDESCRIPTION: Example showing how to update a player's score by 10 points using GRDB's record API. This approach generates the appropriate SQL statement automatically.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// UPDATE player SET score = 950 WHERE id = 42\ntry player.updateChanges {\n    $0.score += 10\n}\n```\n\n----------------------------------------\n\nTITLE: Type Conversions for Row Values in GRDB.swift\nDESCRIPTION: Demonstrates how GRDB.swift automatically converts database values to appropriate Swift types. This includes numeric conversions, date handling, and boolean interpretation based on the requested Swift type.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_24\n\nLANGUAGE: swift\nCODE:\n```\nlet bookCount: Int     = row[\"bookCount\"]\nlet bookCount64: Int64 = row[\"bookCount\"]\nlet hasBooks: Bool     = row[\"bookCount\"] // false when 0\n\nlet string: String     = row[\"date\"]      // \"2015-09-11 18:14:15.123\"\nlet date: Date         = row[\"date\"]      // Date\nself.date = row[\"date\"] // Depends on the type of the property.\n```\n\n----------------------------------------\n\nTITLE: Grouping Synchronous Operations in an Asynchronous Write Transaction\nDESCRIPTION: Example showing how multiple database operations are performed synchronously within a single asynchronous write transaction, ensuring all operations complete together without interleaving with other accesses.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// One asynchronous access...\ntry await dbQueue.write { db in\n    // ... always performs synchronous database operations:\n    try Player(...).insert(db)\n    try Player(...).insert(db)\n    let players = try Player.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Place Table with GPS Coordinates in Swift using GRDB\nDESCRIPTION: Example showing how to create a database table for places with latitude and longitude columns, and a corresponding Swift struct that encapsulates these columns in a CLLocationCoordinate2D property. Private properties are used to hide raw columns from the application.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"place\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"name\", .text).notNull()\n    t.column(\"latitude\", .double).notNull()\n    t.column(\"longitude\", .double).notNull()\n}\n\nstruct Place: Codable {\n    var id: Int64?\n    var name: String\n    private var latitude: CLLocationDegrees\n    private var longitude: CLLocationDegrees\n    \n    var coordinate: CLLocationCoordinate2D {\n        get {\n            CLLocationCoordinate2D(\n                latitude: latitude, \n                longitude: longitude)\n        }\n        set {\n            latitude = newValue.latitude\n            longitude = newValue.longitude\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Fetching Player Objects in Swift\nDESCRIPTION: This snippet illustrates creating a Player object manually and fetching all players from the database, demonstrating how GRDB treats records as plain values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nlet player = Player(name: \"arthur\", score: 1000)\nlet players = try Player.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Converting Record Types to Sendable Structs\nDESCRIPTION: Demonstrates how to refactor a non-Sendable class-based record type into a Sendable struct. This approach addresses Swift 6 concurrency safety requirements by making record types automatically Sendable when they only contain Sendable properties.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// This struct is Sendable\nstruct Player: Codable, Identifiable {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\nextension Player: FetchableRecord, PersistableRecord { }\n```\n\n----------------------------------------\n\nTITLE: Configuring Database Erasure on Schema Change in GRDB.swift\nDESCRIPTION: This snippet shows how to configure the DatabaseMigrator to automatically wipe and recreate the database when schema changes are detected, which is useful during development.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nvar migrator = DatabaseMigrator()\n#if DEBUG\n// Speed up development by nuking the database when migrations change\nmigrator.eraseDatabaseOnSchemaChange = true\n#endif\n```\n\n----------------------------------------\n\nTITLE: Defining the Latest Message Request in GRDB.swift\nDESCRIPTION: Creates a query that selects the latest message for each chat by using MAX(date) and grouping by chatID.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT *, MAX(date) FROM message GROUP BY chatID\nlet latestMessageRequest = Message\n    .annotated(with: max(Column(\"date\")))\n    .group(Column(\"chatID\"))\n```\n\n----------------------------------------\n\nTITLE: Fetching Custom Types with Associations in Swift using GRDB\nDESCRIPTION: This snippet demonstrates how to fetch custom types (BookInfo) that include associations between different tables (Book and Author) using GRDB's asRequest(of:) method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_178\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var author: Author\n}\n\n// A request of BookInfo\nlet request = Book\n    .including(required: Book.author)\n    .asRequest(of: BookInfo.self)\n\nlet bookInfos = try dbQueue.read { db in\n    try request.fetchAll(db) // [BookInfo]\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing ORDER BY Clause in GRDB Queries\nDESCRIPTION: Example of using SQL expressions in GRDB's ORDER BY clause with support for ascending/descending and reversal operations. This demonstrates creating complex sorting conditions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_175\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM \"player\" \n// ORDER BY (score + bonus) ASC, name DESC\nlet total = SQL(\"(score + bonus)\").sqlExpression\nlet request = Player\n    .order(total.desc, Column(\"name\"))\n    .reversed()\n```\n\n----------------------------------------\n\nTITLE: Database Backup in Swift with GRDB\nDESCRIPTION: Shows how to create a backup (copy) of a database using GRDB. This example demonstrates backing up from one DatabaseQueue or DatabasePool to another, which is useful for operations like copying an in-memory database to a file.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_195\n\nLANGUAGE: swift\nCODE:\n```\nlet source: DatabaseQueue = ...      // or DatabasePool\nlet destination: DatabaseQueue = ... // or DatabasePool\ntry source.backup(to: destination)\n```\n\n----------------------------------------\n\nTITLE: Updating didInsert method signature in Swift\nDESCRIPTION: This example shows how to update the didInsert method signature for both structs implementing MutablePersistableRecord and classes subclassing Record. The new signature uses an InsertionSuccess parameter instead of separate rowID and column parameters.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n struct Player: MutablePersistableRecord {\n     var id: Int64?\n \n     // Update auto-incremented id upon successful insertion\n-    mutating func didInsert(with rowID: Int64, for column: String?) {\n-        id = rowID\n+    mutating func didInsert(_ inserted: InsertionSuccess) {\n+        id = inserted.rowID\n     }\n }\n```\n\nLANGUAGE: diff\nCODE:\n```\n class Player: Record {\n     var id: Int64?\n \n     // Update auto-incremented id upon successful insertion\n-    override func didInsert(with rowID: Int64, for column: String?) {\n-        id = rowID\n+    override func didInsert(_ inserted: InsertionSuccess) {\n+        super.didInsert(inserted)\n+        id = inserted.rowID\n     }\n }\n```\n\n----------------------------------------\n\nTITLE: Database Migration with Multiple Foreign Keys in GRDB\nDESCRIPTION: Shows how to create database tables with multiple foreign key relationships using GRDB's migration system.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_30\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"Library\") { db in\n    try db.create(table: \"person\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.column(\"name\", .text)\n    }\n    try db.create(table: \"book\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.belongsTo(\"author\", inTable: \"person\")\n        t.belongsTo(\"translator\", inTable: \"person\")\n        t.column(\"title\", .text)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Public Statement Arguments for Debugging in GRDB Swift\nDESCRIPTION: This snippet demonstrates how to enable public statement arguments in debug builds for better error reporting. This setting displays values sent to the database in errors and logs, which may contain sensitive information, so it's only enabled in debug builds.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Configuration.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\n#if DEBUG\n// Protect sensitive information by enabling\n// verbose debugging in DEBUG builds only.\nconfig.publicStatementArguments = true\n#endif\n\nlet dbQueue = try DatabaseQueue(\n    path: \"/path/to/database.sqlite\",\n    configuration: config)\n\ndo {\n    try dbQueue.write { db in\n        user.name = ...\n        user.location = ...\n        user.address = ...\n        user.phoneNumber = ...\n        try user.save(db)\n    }\n} catch {\n    // Prints sensitive information in debug builds only\n    print(error)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Joined Request with Multiple Associations in Swift\nDESCRIPTION: Creates a joined request that includes required and optional associations, demonstrating how to build a tree of association keys. This example joins a book with its author (required), the author's country (optional), and the book's cover image (optional).\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_75\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Book\n    .including(required: Book.author\n        .including(optional: Author.country))\n    .including(optional: Book.coverImage)\n```\n\n----------------------------------------\n\nTITLE: Selecting IDs from Identifiable Records in GRDB\nDESCRIPTION: Demonstrates the selectID() method which is available on Identifiable Records, making it easy to retrieve just the primary key values from tables with a single-column primary key.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_125\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT id FROM player\nPlayer.selectID()\n\n// SELECT id FROM player WHERE name IS NOT NULL\nPlayer.filter(nameColumn != nil).selectID()\n```\n\n----------------------------------------\n\nTITLE: Filtering Requests with Expressions in GRDB\nDESCRIPTION: Demonstrates using the filter() method with expressions to apply WHERE conditions to queries. Shows both simple conditions and complex combined conditions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_130\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE id IN (1, 2, 3)\nPlayer.filter([1,2,3].contains(idColumn))\n\n// SELECT * FROM player WHERE (name IS NOT NULL) AND (height > 1.75)\nPlayer.filter(nameColumn != nil && heightColumn > 1.75)\n```\n\n----------------------------------------\n\nTITLE: Implementing Configurable Wrapped Tokenizer in Swift\nDESCRIPTION: This example shows how to create a custom tokenizer that can wrap different tokenizers based on provided arguments, defaulting to unicode61 if no arguments are given.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nfinal class MyTokenizer : FTS5WrapperTokenizer {\n    static let name = \"custom\"\n    let wrappedTokenizer: any FTS5Tokenizer\n    \n    init(db: Database, arguments: [String]) throws {\n        if arguments.isEmpty {\n            wrappedTokenizer = try db.makeTokenizer(.unicode61())\n        } else {\n            let descriptor = FTS5TokenizerDescriptor(components: arguments)\n            wrappedTokenizer = try db.makeTokenizer(descriptor)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Prepared Statements with SQL Interpolation\nDESCRIPTION: Shows how to create prepared statements using SQL interpolation, which provides type safety and protection against SQL injection while maintaining the performance benefits of prepared statements.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nlet updateStatement = try db.makeUpdateStatement(literal: \"INSERT ...\")\nlet selectStatement = try db.makeSelectStatement(literal: \"SELECT ...\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Persistence Conflict Policy for a Record Type in Swift\nDESCRIPTION: Defines a custom persistenceConflictPolicy for a record type that implements MutablePersistableRecord. This policy affects how INSERT and UPDATE queries handle conflicts when using the record's persistence methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_112\n\nLANGUAGE: swift\nCODE:\n```\nprotocol MutablePersistableRecord {\n    /// The policy that handles SQLite conflicts when records are\n    /// inserted or updated.\n    ///\n    /// This property is optional: its default value uses the ABORT\n    /// policy for both insertions and updates, so that GRDB generate\n    /// regular INSERT and UPDATE queries.\n    static var persistenceConflictPolicy: PersistenceConflictPolicy { get }\n}\n\nstruct Player : MutablePersistableRecord {\n    static let persistenceConflictPolicy = PersistenceConflictPolicy(\n        insert: .replace,\n        update: .replace)\n}\n\n// INSERT OR REPLACE INTO player (...) VALUES (...)\ntry player.insert(db)\n```\n\n----------------------------------------\n\nTITLE: Using Immediate Scheduling with ValueObservation Publishers\nDESCRIPTION: Demonstrates how to configure a ValueObservation publisher to notify its initial value immediately using the immediate scheduler. This helps update UI without waiting for asynchronous notifications.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// Immediate notification of the initial value\nlet cancellable = observation\n    .publisher(\n        in: dbQueue,\n        scheduling: .immediate) // <-\n    .sink(\n        receiveCompletion: { completion in ... },\n        receiveValue: { (players: [Player]) in print(\"Fresh players: \\(players)\") })\n// <- here \"fresh players\" is already printed.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Database Change Notifications in Swift\nDESCRIPTION: This example shows how a database write operation triggers the observation callback. When a new Player is inserted into the database, the observation detects the change and executes the onChange handler.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseRegionObservation.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try Player(name: \"Arthur\").insert(db)\n}\n// Prints \"Players were changed\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Record Type with Protocols\nDESCRIPTION: Demonstrates how to define a record struct with id and properties, and extend it with protocols to enable database operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_59\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\n// Players can be fetched from the database.\nextension Player: FetchableRecord { ... }\n\n// Players can be saved into the database.\nextension Player: PersistableRecord { ... }\n```\n\n----------------------------------------\n\nTITLE: Dropping Tables in GRDB.swift\nDESCRIPTION: Demonstrates how to drop a table from the database schema.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ntry db.drop(table: \"obsolete\")\n```\n\n----------------------------------------\n\nTITLE: Checking Table Existence in GRDB.swift\nDESCRIPTION: This method checks if a specific table exists in the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/tableExists(_:in:)\n```\n\n----------------------------------------\n\nTITLE: Storing Complex Data in JSON Columns with Codable Records in Swift\nDESCRIPTION: Demonstrates how nested Codable types are automatically encoded as JSON strings in database columns. This example shows a Player record with an array of Achievement objects that gets serialized to JSON when inserted into the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_96\n\nLANGUAGE: swift\nCODE:\n```\nenum AchievementColor: String, Codable {\n    case bronze, silver, gold\n}\n\nstruct Achievement: Codable {\n    var name: String\n    var color: AchievementColor\n}\n\nstruct Player: Codable, FetchableRecord, PersistableRecord {\n    var name: String\n    var score: Int\n    var achievements: [Achievement] // stored in a JSON column\n}\n\ntry dbQueue.write { db in\n    // INSERT INTO player (name, score, achievements)\n    // VALUES (\n    //   'Arthur',\n    //   100,\n    //   '[{\"color\":\"gold\",\"name\":\"Use Codable Records\"}]')\n    let achievement = Achievement(name: \"Use Codable Records\", color: .gold)\n    let player = Player(name: \"Arthur\", score: 100, achievements: [achievement])\n    try player.insert(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Player Filter by Multiple IDs\nDESCRIPTION: Methods to filter players by an array of IDs using IN clause, with both simple and future-proof versions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: Decodable, FetchableRecord, TableRecord {\n    /// \"Simple\" version\n    static func filter(ids: [Int64]) -> SQLRequest<Player> {\n        \"SELECT * FROM player WHERE id IN \\(ids)\"\n    }\n    \n    /// \"Future-proof\" version\n    static func filter(ids: [Int64]) -> SQLRequest<Player> {\n        \"\"\"\n        SELECT \\(columnsOf: self)\n        FROM \\(self)\n        WHERE \\(CodingKeys.id) IN \\(ids)\n        \"\"\"\n    }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet players = try dbQueue.read { db in\n    // SELECT * FROM player WHERE id IN (1, 2, 3)\n    try Player.filter(ids: [1, 2, 3]).fetchAll(db) // [Player]\n}\n```\n\n----------------------------------------\n\nTITLE: Using insertAndFetch with Specific Column Selection\nDESCRIPTION: Shows how to insert a record and fetch only specific columns using the RETURNING clause with a custom selection. This approach provides more control over the returned data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_87\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    let partialPlayer = PartialPlayer(name: \"Alice\")\n    \n    // INSERT INTO player (name) VALUES ('Alice') RETURNING score\n    let score = try partialPlayer.insertAndFetch(db, selection: [Column(\"score\")]) { statement in\n        try Int.fetchOne(statement)\n    }\n    print(score) // Prints 1000, the default score\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Transaction Kind for Shared Databases in Swift\nDESCRIPTION: Code snippet showing how to set immediate transaction mode as default for databases shared between multiple processes to avoid SQLITE_BUSY errors when transactions overlap.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nconfiguration.defaultTransactionKind = .immediate\n```\n\n----------------------------------------\n\nTITLE: Creating a table with custom collations for string comparison\nDESCRIPTION: This example shows how to apply collations to table columns during table creation, ensuring case-insensitive email uniqueness and localized case-insensitive name sorting.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_214\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"player\") { t in\n    // Guarantees case-insensitive email unicity\n    t.column(\"email\", .text).unique().collate(.nocase)\n    \n    // Sort names in a localized case insensitive way\n    t.column(\"name\", .text).collate(.localizedCaseInsensitiveCompare)\n}\n\n// Players are sorted in a localized case insensitive way:\nlet players = try Player.order(nameColumn).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Implementing persistence callbacks in Swift\nDESCRIPTION: This snippet demonstrates how to implement persistence callbacks, such as willSave, which replace the previous method of overriding persistence methods. It shows examples for both structs and classes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 6\nstruct Link: PersistableRecord {\n    var url: URL\n    \n    func willSave(_ db: Database) throws {\n        if url.host == nil {\n            throw ValidationError(\"url must be absolute.\")\n        }\n    }\n}\n\ntry link.insert(db) // Calls the willSave callback\ntry link.update(db) // Calls the willSave callback\ntry link.save(db)   // Calls the willSave callback\ntry link.upsert(db) // Calls the willSave callback\n```\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 6\nclass Link: Record {\n    var url: URL\n    \n    override func willSave(_ db: Database) throws {\n        try super.willSave(db)\n        if url.host == nil {\n            throw ValidationError(\"url must be absolute.\")\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting Associated Records in GRDB.swift\nDESCRIPTION: Demonstrates how to sort records based on associated records by using the order() method. This example shows how to sort books by their author's name.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_57\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, person.*\n// FROM book\n// JOIN person ON person.id = book.authorId\n// ORDER BY person.name\nlet sortedAuthor = Book.author.order(Column(\"name\"))\nlet request = Book.including(required: sortedAuthor)\n```\n\n----------------------------------------\n\nTITLE: UPSERT Example in Swift\nDESCRIPTION: Example showing the new UPSERT functionality for persisting records\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nplayer.upsert(db)\n```\n\n----------------------------------------\n\nTITLE: Upsert with Maximum Value Computation in Swift\nDESCRIPTION: Demonstrates an upsert that computes values during conflict resolution. This example keeps the maximum date value between the existing and new records when a conflict occurs.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_83\n\nLANGUAGE: swift\nCODE:\n```\n// INSERT INTO message(id, text, date)\n// VALUES(...)\n// ON CONFLICT DO UPDATE SET \\\n//   text = excluded.text,\n//   date = MAX(date, excluded.date)\n// RETURNING *\nlet upserted = try message.upsertAndFetch(doUpdate: { excluded in\n    // keep the maximum date in case of conflict\n    [Column(\"date\").set(to: max(Column(\"date\"), excluded[\"date\"]))]\n})\n```\n\n----------------------------------------\n\nTITLE: Starting a ValueObservation with Callbacks in Swift\nDESCRIPTION: Demonstrates how to start a ValueObservation with error and value change callbacks. The observation returns a cancellable that can be used to stop the observation when no longer needed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet cancellable = observation.start(in: dbQueue) { error in\n    // Handle error\n} onChange: { (players: [Player]) in\n    print(\"Fresh players\", players)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using SQL Interpolation with Cached Prepared Statements\nDESCRIPTION: Demonstrates how to use SQL interpolation with cached prepared statements, allowing for better performance while maintaining the safety and convenience of SQL interpolation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nlet updateStatement = try db.cachedStatement(literal: \"INSERT ...\")\n```\n\n----------------------------------------\n\nTITLE: Mixing Query Interface with Raw SQL in GRDB.swift\nDESCRIPTION: Examples of how to mix GRDB's query interface with raw SQL for operations that require custom SQL queries or when SQL is preferred for specific use cases.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_118\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Update database schema (with SQL)\n    try db.execute(sql: \"CREATE TABLE wine (...)\")\n    \n    // Fetch records (with SQL)\n    let wines = try Wine.fetchAll(db,\n        sql: \"SELECT * FROM wine WHERE origin = ? ORDER BY price\",\n        arguments: [\"Burgundy\"])\n    \n    // Count (with an SQL snippet)\n    let count = try Wine\n        .filter(sql: \"color = ?\", arguments: [Color.red])\n        .fetchCount(db)\n    \n    // Update (with SQL)\n    try db.execute(sql: \"UPDATE wine SET price = price * 0.75 WHERE origin = 'Burgundy'\")\n    \n    // Delete (with SQL)\n    try db.execute(sql: \"DELETE FROM wine WHERE corked\")\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling for SQLite Foreign Key Constraints in Swift\nDESCRIPTION: This snippet demonstrates how to handle specific SQLite errors using the DatabaseError type. It shows checking for foreign key constraint violations using the extendedResultCode property.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_87\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    ...\n} catch let error as DatabaseError where error.extendedResultCode == .SQLITE_CONSTRAINT_FOREIGNKEY {\n    // handle foreign key constraint error\n} catch let error as DatabaseError where error.resultCode == .SQLITE_CONSTRAINT {\n    // handle any other constraint error\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Foreign Key for HasMany Association in GRDB Swift\nDESCRIPTION: Shows how to define a HasMany association when the database schema doesn't follow GRDB conventions. Requires manually specifying the foreign key relationship.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_24\n\nLANGUAGE: swift\nCODE:\n```\nstruct Author: TableRecord {\n    static let books = hasMany(Book.self, using: ForeignKey(...))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating FTS5 Virtual Tables\nDESCRIPTION: Demonstrates the creation of FTS5 virtual tables with various configuration options including tokenizers and column settings.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"document\", using: FTS5()) { t in\n    t.column(\"content\")\n}\n\ntry db.create(virtualTable: \"document\", using: FTS5()) { t in\n    t.column(\"content\")\n    t.column(\"uuid\").notIndexed()\n    t.content = \"table\"\n    t.contentRowID = \"id\"\n    t.prefixes = [2, 4]\n    t.columnSize = 0\n    t.detail = \"column\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HasOne Association with TableRecord in GRDB Swift\nDESCRIPTION: Shows the basic implementation of related Country and Demographics models with a HasOne relationship following GRDB's conventions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_27\n\nLANGUAGE: swift\nCODE:\n```\nstruct Country: TableRecord {\n    static let demographics = hasOne(Demographics.self)\n}\n\nstruct Demographics: TableRecord {\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting FTS5 Results by Relevance in Swift\nDESCRIPTION: Demonstrates how to sort FTS5 search results by relevance using both SQL and the query interface in GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n// SQL\nlet documents = try Document.fetchAll(db,\n    sql: \"SELECT * FROM document WHERE document MATCH ? ORDER BY rank\",\n    arguments: [pattern])\n\n// Query Interface\nlet documents = try Document.matching(pattern).order(Column.rank).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Configuring Record Types for Tables Without Explicit Primary Keys in Swift\nDESCRIPTION: Shows how to configure record types for tables that don't have explicit primary keys. This requires explicit support for SQLite's hidden rowid column in the record types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// A table without any explicit primary key\ntry db.create(table: \"player\") { t in\n    t.column(\"name\", .text).notNull()\n    t.column(\"score\", .integer).notNull()\n}\n\n// The record type for the 'player' table'\nstruct Player: Codable {\n    // Uniquely identifies a player.\n    var rowid: Int64?\n    var name: String\n    var score: Int\n}\n\nextension Player: FetchableRecord, MutablePersistableRecord {\n    // Required because the primary key\n    // is the hidden rowid column.\n    static var databaseSelection: [any SQLSelectable] {\n        [.allColumns, .rowID]\n    }\n\n    // Update id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        rowid = inserted.rowID\n    }\n}\n\ntry dbQueue.read { db in\n    // SELECT *, rowid FROM player WHERE rowid = 1\n    if let player = try Player.fetchOne(db, id: 1) {\n        // DELETE FROM player WHERE rowid = 1\n        let deleted = try player.delete(db)\n        print(deleted) // true\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interpolating Columns Selected by TableRecord in SQL Queries (Swift)\nDESCRIPTION: This snippet shows how to interpolate columns selected by TableRecord into SQL queries. It demonstrates different ways to select columns, including custom database selections.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_19\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Player: TableRecord { ... }\n\n// SELECT player.* FROM player\n\"SELECT \\(columnsOf: Player.self) FROM player\"\n\n// SELECT p.* FROM player p\n\"SELECT \\(columnsOf: Player.self, tableAlias: \"p\") FROM player p\"\n\nstruct AltPlayer: TableRecord {\n    static let databaseTableName = \"player\"\n    static var databaseSelection: [any SQLSelectable] {\n        [Column(\"id\"), Column(\"name\")]\n    }\n}\n\n// SELECT player.id, player.name FROM player\n\"SELECT \\(columnsOf: AltPlayer.self) FROM player\"\n```\n\n----------------------------------------\n\nTITLE: Defining Record Types for Chat Application in Swift\nDESCRIPTION: Defines the core database record types for a chat application: Chat, Message, and ChatInfo. ChatInfo is a composite record that combines a chat with its latest message.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nstruct Chat: Codable, FetchableRecord, PersistableRecord {\n    var id: Int64\n    ...\n}\n\nstruct Message: Codable, FetchableRecord, PersistableRecord {\n    var chatID: Int64\n    var date: Date\n    ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nstruct ChatInfo: Decodable, FetchableRecord {\n    /// The chat\n    var chat: Chat\n    \n    /// The latest chat message, if any\n    var latestMessage: Message?\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Latin Script Tokenizer in Swift\nDESCRIPTION: This example demonstrates a custom tokenizer for handling Latin script languages, providing fuzzy matching by transforming tokens into their bare lowercase ASCII form.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nfinal class LatinAsciiTokenizer : FTS5WrapperTokenizer {\n    static let name = \"latinascii\"\n    let wrappedTokenizer: any FTS5Tokenizer\n    \n    init(db: Database, arguments: [String]) throws {\n        wrappedTokenizer = try db.makeTokenizer(.unicode61())\n    }\n    \n    func accept(token: String, flags: FTS5TokenFlags, for tokenization: FTS5Tokenization, tokenCallback: FTS5WrapperTokenCallback) throws {\n        if let token = token.applyingTransform(StringTransform(\"Latin-ASCII; Lower\"), reverse: false) {\n            try tokenCallback(token, flags)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Table Names and Association Keys in Swift for GRDB\nDESCRIPTION: Demonstrates how to handle database tables that don't follow GRDB's naming conventions by customizing the table name and association key. This is useful when working with existing databases that use underscore naming instead of camelCase.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\n// Setup for table names that does not follow the expected convention\n\nstruct PostalAddress: TableRecord {\n    // Customized table name\n    static let databaseTableName = \"postal_address\"\n}\n\nextension Author {\n    // Customized association key\n    static let postalAddress = belongsTo(PostalAddress.self, key: \"postalAddress\")\n}\n```\n\n----------------------------------------\n\nTITLE: Handling IGNORE conflict policy in Swift\nDESCRIPTION: This example shows how to handle the IGNORE conflict policy in the new version of GRDB.swift, including how to detect failed INSERT OR IGNORE operations using the new insertAndFetch method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// Given a record with ignore conflict policy for inserts...\nstruct Player: TableRecord, FetchableRecord {\n    static let persistenceConflictPolicy = PersistenceConflictPolicy(insert: .ignore)\n}\n\n// GRDB 5: Does not call didInsert\n// GRDB 6: Calls didInsert\ntry player.insert(db)\n\n// How to detect failed `INSERT OR IGNORE`:\n// INSERT OR IGNORE INTO player ... RETURNING *\nif let insertedPlayer = try player.insertAndFetch(db) {\n    // Succesful insertion\n} else {\n    // Ignored failure\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating with Required Associated Columns using annotated(withRequired:) in Swift\nDESCRIPTION: This snippet demonstrates how to use annotated(withRequired:) to fetch a book with specific columns from the associated author record. It allows for more granular control over the fetched data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_44\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book         // The base record\n    var authorName: String // A column of the associated record\n    var country: String    // A column of the associated record\n}\n\nlet bookInfos = try Book\n    .annotated(withRequired: Book.author.select(\n        Column(\"name\").forKey(\"authorName\"), \n        Column(\"country\")))\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Custom Conflict Policy Example\nDESCRIPTION: Shows how to specify an explicit conflict policy during record insertion\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nplayer.insert(db, onConflict: .replace)\n```\n\n----------------------------------------\n\nTITLE: Implementing Self-Join Associations in Swift with GRDB\nDESCRIPTION: Creates relationships between records of the same type, allowing hierarchical structures like employee-manager relationships to be modeled. Uses custom association keys to disambiguate the relationships.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nstruct Employee {\n    static let subordinates = hasMany(Employee.self, key: \"subordinates\")\n    static let manager = belongsTo(Employee.self, key: \"manager\")\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FTS4 Table Tokenizers in Swift\nDESCRIPTION: Creates a virtual FTS4 table with different tokenizer options including simple, porter and unicode61. Each tokenizer provides different text matching capabilities for case sensitivity, stemming and diacritic handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS4()) { t in\n    // Pick one:\n    t.tokenizer = .simple // default\n    t.tokenizer = .porter\n    t.tokenizer = .unicode61(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Initialization from Cursors in GRDB.swift\nDESCRIPTION: Examples of initializing various Swift collections (Array, Set, Dictionary) from database cursors.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\n// [String]\nlet cursor = try String.fetchCursor(db, ...)\nlet array = try Array(cursor)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// Set<Int>\nlet cursor = try Int.fetchCursor(db, ...)\nlet set = try Set(cursor)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// [Int64: [Player]]\nlet cursor = try Player.fetchCursor(db)\nlet dictionary = try Dictionary(grouping: cursor, by: { $0.teamID })\n\n// [Int64: Player]\nlet cursor = try Player.fetchCursor(db).map { ($0.id, $0) }\nlet dictionary = try Dictionary(uniqueKeysWithValues: cursor)\n```\n\n----------------------------------------\n\nTITLE: Using Columns in QueryInterfaceRequest with GRDB\nDESCRIPTION: Example showing how to use defined columns to create and execute database queries. The examples demonstrate sorting authors by name and counting French authors using QueryInterfaceRequest.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    // Fetch all authors, ordered by name,\n    // in a localized case-insensitive fashion\n    let sortedAuthors: [Author] = try Author.all()\n        .order(Author.Columns.name.collating(.localizedCaseInsensitiveCompare))\n        .fetchAll(db)\n    \n    // Count French authors\n    let frenchAuthorCount: Int = try Author.all()\n        .filter(Author.Columns.countryCode == \"FR\")\n        .fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Cancelling a ValueObservation in Swift\nDESCRIPTION: Shows how to explicitly cancel an active ValueObservation by calling the cancel method on the returned cancellable object.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ncancellable.cancel()\n```\n\n----------------------------------------\n\nTITLE: Using SQL Literals with SQL Type\nDESCRIPTION: Shows how to use the SQL type for raw SQL literals with support for SQL interpolation. Includes examples of using SQL literals in requests and as SQLite expressions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\nlet literal: SQL = \"SELECT * FROM player\"\nlet request = SQLRequest<Player>(literal: literal)\nlet players: [Player] = try request.fetchAll(db)\n\nlet literal: SQL = \"name = \\(\"O'Brien\")\"\nlet request = Player.filter(literal)\nlet players: [Player] = try request.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Advanced Upsert with Custom Conflict Resolution in Swift\nDESCRIPTION: Shows how to use upsertAndFetch with custom conflict resolution for a vocabulary database. This example demonstrates selective column updates during conflicts and retrieves the resulting record.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_82\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE TABLE vocabulary(\n//   word TEXT NOT NULL PRIMARY KEY,\n//   kind TEXT NOT NULL,\n//   isTainted BOOLEAN DEFAULT 0,\n//   count INT DEFAULT 1))\nstruct Vocabulary: Encodable, PersistableRecord {\n    var word: String\n    var kind: String\n    var isTainted: Bool\n}\n\n// INSERT INTO vocabulary(word, kind, isTainted)\n// VALUES('jovial', 'adjective', 0)\n// ON CONFLICT(word) DO UPDATE SET \\\n//   count = count + 1,   -- on conflict, count is incremented\n//   kind = excluded.kind -- on conflict, kind is overwritten\n// RETURNING *\nlet vocabulary = Vocabulary(word: \"jovial\", kind: \"adjective\", isTainted: false)\nlet upserted = try vocabulary.upsertAndFetch(\n    db, onConflict: [\"word\"],\n    doUpdate: { _ in\n        [Column(\"count\") += 1,            // on conflict, count is incremented\n         Column(\"isTainted\").noOverwrite] // on conflict, isTainted is NOT overwritten\n    })\n```\n\n----------------------------------------\n\nTITLE: Querying JSON Column in SQLite with Swift\nDESCRIPTION: This snippet shows how to query a JSON column using GRDB.swift. It filters players based on the 'country' field in the 'address' JSON column.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/JSON.md#2025-04-22_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nlet germanPlayers = try Player\n    .filter(JSONColumn(\"address\")[\"country\"] == \"DE\")\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Recreating Database Tables in GRDB.swift Migrations\nDESCRIPTION: This snippet demonstrates how to recreate a database table within a migration when SQLite doesn't directly support the desired modification.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"Add NOT NULL check on author.name\") { db in\n    try db.create(table: \"new_author\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.column(\"creationDate\", .datetime)\n        t.column(\"name\", .text).notNull()\n    }\n    try db.execute(sql: \"INSERT INTO new_author SELECT * FROM author\")\n    try db.drop(table: \"author\")\n    try db.rename(table: \"new_author\", to: \"author\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DatabaseValueConvertible for RawRepresentable Types in Swift\nDESCRIPTION: This snippet shows how to easily implement DatabaseValueConvertible for RawRepresentable types, such as enums, whose raw value is already DatabaseValueConvertible.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseValueConvertible.md#2025-04-22_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nenum Grape: String {\n    case chardonnay, merlot, riesling\n}\n\n// Encodes and decodes `Grape` as a string in the database:\nextension Grape: DatabaseValueConvertible { }\n```\n\n----------------------------------------\n\nTITLE: Interpolating Database Collations in SQL Queries (Swift)\nDESCRIPTION: This snippet demonstrates how to interpolate database collations into SQL queries. It shows examples of using case-insensitive and localized comparison collations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_24\n\nLANGUAGE: Swift\nCODE:\n```\n\"SELECT * FROM player ORDER BY email COLLATING \\(.nocase)\"\n\"SELECT * FROM player ORDER BY email COLLATING \\(.localizedCompare)\"\n```\n\n----------------------------------------\n\nTITLE: Using Column Enums with Persistable Records\nDESCRIPTION: Demonstrates a pattern for declaring column names as enum values and using them consistently in both row initialization and persistence methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_83\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player : RowConvertible, Persistable {\n    let name: String\n    let score: Int\n    \n    static let databaseTableName = \"players\"\n    \n    // Declare Player columns\n    enum Columns {\n        static let name = Column(\"name\")\n        static let score = Column(\"score\")\n    }\n    \n    // Use columns in `init(row:)`\n    init(row: Row) {\n        name = row.value(Columns.name)\n        score = row.value(Columns.score)\n    }\n    \n    // Use columns in the new `encode(to:)` method:\n    func encode(to container: inout PersistenceContainer) {\n        container[Columns.name] = name\n        container[Columns.score] = score\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Database Migration for Self-Join Relationships in Swift\nDESCRIPTION: Shows how to define the database schema for a self-join relationship using GRDB migrations. Creates a table with a foreign key that references the same table, establishing a hierarchical structure.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"Employees\") { db in\n    try db.create(table: \"employee\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.belongsTo(\"manager\", inTable: \"employee\", onDelete: .setNull)\n        t.column(\"name\", .text)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing DatabaseValue from Row in GRDB.swift\nDESCRIPTION: Demonstrates how to access the raw DatabaseValue type from a row, which provides more information about the database value including its storage type and nullability.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_27\n\nLANGUAGE: swift\nCODE:\n```\nlet dbValue: DatabaseValue = row[0]\nlet dbValue: DatabaseValue? = row[\"name\"] // nil if and only if column does not exist\n\n// Check for NULL:\ndbValue.isNull // Bool\n\n// The stored value:\ndbValue.storage.value // Int64, Double, String, Data, or nil\n\n// All the five storage classes supported by SQLite:\nswitch dbValue.storage {\ncase .null:                 print(\"NULL\")\ncase .int64(let int64):     print(\"Int64: \\(int64)\")\ncase .double(let double):   print(\"Double: \\(double)\")\ncase .string(let string):   print(\"String: \\(string)\")\ncase .blob(let data):       print(\"Data: \\(data)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Data Asynchronously with GRDB and Combine\nDESCRIPTION: Creates a publisher that performs database write operations and delivers a single value. The examples show inserting a Player and optionally returning the new count.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// DatabasePublishers.Write<Void>\nlet write = dbQueue.writePublisher { db in\n    try Player(...).insert(db)\n}\n\n// DatabasePublishers.Write<Int>\nlet newPlayerCount = dbQueue.writePublisher { db -> Int in\n    try Player(...).insert(db)\n    return try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Querying External Content Full-Text Tables with JOIN in Swift\nDESCRIPTION: Demonstrates how to perform a full-text search on a regular table by joining it with its external content full-text table using raw SQL in Swift. This approach allows accessing columns from the regular table while utilizing full-text search.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\nlet sql = \"\"\"\n    SELECT book.*\n    FROM book\n    JOIN book_ft\n        ON book_ft.rowid = book.rowid\n        AND book_ft MATCH ?\n    \"\"\"\nlet books = Book.fetchAll(db, sql: sql, arguments: [pattern])\n```\n\n----------------------------------------\n\nTITLE: Comparing Plain SQL vs SQL Interpolation in Swift\nDESCRIPTION: Examples showing the difference between using plain SQL with placeholders and arguments versus using SQL interpolation with the literal parameter.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(sql: \"UPDATE player SET name = ? WHERE id = ?\", arguments: [name, id])\n```\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(literal: \"UPDATE player SET name = \\(name) WHERE id = \\(id)\")\n```\n\n----------------------------------------\n\nTITLE: Fetching Associated Records in Self-Join Relationships with GRDB\nDESCRIPTION: Demonstrates how to query and fetch records with self-join associations. Creates a request that includes both the manager and subordinates of employees, mapping the results to a structured type.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nstruct EmployeeInfo: FetchableRecord, Decodable {\n    var employee: Employee\n    var manager: Employee?\n    var subordinates: Set<Employee>\n}\n\nlet request = Employee\n    .including(optional: Employee.manager)\n    .including(all: Employee.subordinates)\n\nlet employeeInfos: [EmployeeInfo] = try EmployeeInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Request Methods with GRDB\nDESCRIPTION: Definition of reusable request methods by extending the DerivableRequest protocol. These methods encapsulate common query patterns, facilitate code reuse, and improve readability by creating a fluent API that hides database details.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n// Author requests\nextension DerivableRequest<Author> {\n    /// Order authors by name, in a localized case-insensitive fashion\n    func orderByName() -> Self {\n        let name = Author.Columns.name\n        return order(name.collating(.localizedCaseInsensitiveCompare))\n    }\n    \n    /// Filters authors from a country\n    func filter(countryCode: String) -> Self {\n        filter(Author.Columns.countryCode == countryCode)\n    }\n}\n\n// Book requests\nextension DerivableRequest<Book> {\n    /// Order books by title, in a localized case-insensitive fashion\n    func orderByTitle() -> Self {\n        let title = Book.Columns.title\n        return order(title.collating(.localizedCaseInsensitiveCompare))\n    }\n    \n    /// Filters books by kind\n    func filter(kind: Book.Kind) -> Self {\n        filter(Book.Columns.kind == kind)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using SQL Interpolation with Query Interface in Swift\nDESCRIPTION: Examples showing how to embed raw SQL snippets in query interface requests using SQL interpolation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE name = 'O''Brien'\nlet request = Player.filter(literal: \"name = \\(\"O'Brien\")\")\n\n// SELECT * FROM player WHERE DATE(createdAt) = '2020-01-23'\nlet createdAt = Column(\"createdAt\")\nlet creationDay = SQL(\"DATE(\\(createdAt))\")\nlet request = Player.filter(creationDay == \"2020-01-23\")\n```\n\n----------------------------------------\n\nTITLE: Defining Columns for a Non-Codable Record in GRDB\nDESCRIPTION: Example showing how to define columns for a non-Codable record type by creating a String enum that conforms to the ColumnExpression protocol. This provides a type-safe way to reference columns in queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// HOW TO define columns for a non-Codable record\nextension Author {\n    enum Columns: String, ColumnExpression {\n        case id, name, countryCode\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom SQL Function Support in GRDB\nDESCRIPTION: Example of defining a custom Swift function that wraps an SQLite function. This creates a reusable DATE function that can be used in GRDB query interfaces.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_171\n\nLANGUAGE: swift\nCODE:\n```\nfunc date(_ value: some SQLSpecificExpressible) -> SQLExpression {\n    SQL(\"DATE(\\(value))\").sqlExpression\n}\n\n// SELECT * FROM \"player\" WHERE DATE(\"createdAt\") = '2020-01-23'\nlet request = Player.filter(date(Column(\"createdAt\")) == \"2020-01-23\")\n```\n\n----------------------------------------\n\nTITLE: Debugging ValueObservation in GRDB.swift\nDESCRIPTION: Enables tracing on a ValueObservation to debug issues where changes aren't being published. This prints events including region tracking, value changes, and cancellation, helping identify why notifications aren't occurring.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_230\n\nLANGUAGE: swift\nCODE:\n```\nlet observation = ValueObservation\n    .tracking { db in ... }\n    .print() // <- trace observation events\nlet cancellable = observation.start(...)\n```\n\n----------------------------------------\n\nTITLE: Implementing Record Validation with willSave Callback in GRDB.swift\nDESCRIPTION: Demonstrates how to use the willSave callback for validating records before they are saved to the database. This example validates that a URL is absolute before allowing insertion or update operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_90\n\nLANGUAGE: swift\nCODE:\n```\nstruct Link: PersistableRecord {\n    var url: URL\n    \n    func willSave(_ db: Database) throws {\n        if url.host == nil {\n            throw ValidationError(\"url must be absolute.\")\n        }\n    }\n}\n\ntry link.insert(db) // Calls the willSave callback\ntry link.update(db) // Calls the willSave callback\ntry link.save(db)   // Calls the willSave callback\ntry link.upsert(db) // Calls the willSave callback\n```\n\n----------------------------------------\n\nTITLE: Defining a HasOne Association in GRDB Swift\nDESCRIPTION: Shows how to define a HasOne relationship between Country and Demographics models. This relationship indicates that a country has exactly one demographics profile.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_25\n\nLANGUAGE: swift\nCODE:\n```\nextension Country: TableRecord {\n    static let demographics = hasOne(Demographics.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Enum Values with DatabaseValue in GRDB.swift\nDESCRIPTION: Shows how to safely handle database values that don't match any enum case using DatabaseValue to avoid fatal errors when unexpected values are encountered.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_47\n\nLANGUAGE: swift\nCODE:\n```\nlet row = try Row.fetchOne(db, sql: \"SELECT 'syrah'\")!\n\nrow[0] as String  // \"syrah\"\nrow[0] as Grape?  // fatal error: could not convert \"syrah\" to Grape.\nrow[0] as Grape   // fatal error: could not convert \"syrah\" to Grape.\n\nlet dbValue: DatabaseValue = row[0]\nif dbValue.isNull {\n    // Handle NULL\n} else if let grape = Grape.fromDatabaseValue(dbValue) {\n    // Handle valid grape\n} else {\n    // Handle unknown grape\n}\n```\n\n----------------------------------------\n\nTITLE: Using ValueObservation with MainActor in GRDB 7\nDESCRIPTION: GRDB 7 fosters the main actor for ValueObservation, with callbacks running on the main actor by default. This example shows how to start an observation and opt out of main actor isolation when needed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB7MigrationGuide.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 7\n@MainActor func startObservation() {\n    let observation = ValueObservation.tracking { ... }\n    \n    let cancellable = observation.start(in: dbQueue) { error in\n        // This closure is MainActor-isolated.\n    } onChange: { value in\n        // This closure is MainActor-isolated.\n        print(\"Fresh value\", value)\n    }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nfunc startObservation() {\n    let observation = ValueObservation.tracking { ... }\n    \n    let cancellable = observation.start(\n        in: dbQueue,\n        scheduling: .async(onQueue: .main))\n    { error in\n        // Called on the specified dispatch queue.\n    } onChange: { value in\n        // Called on the specified dispatch queue.\n        print(\"Fresh value\", value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing FTS5 Queries in Swift\nDESCRIPTION: Shows how to use FTS5 patterns in SQL queries and with the query interface in GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\nlet documents = try Document.fetchAll(db,\n    sql: \"SELECT * FROM document WHERE document MATCH ?\",\n    arguments: [pattern])\n\n// Search in all columns\nlet documents = try Document.matching(pattern).fetchAll(db)\n\n// Search in a specific column:\nlet documents = try Document.filter(Column(\"content\").match(pattern)).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Opening a Shared Writable Database with WAL Mode in Swift\nDESCRIPTION: This function opens a shared database with write access using WAL mode. It uses NSFileCoordinator for file coordination and sets up the persistent WAL mode to ensure compatibility with read-only processes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nfunc openSharedDatabase(at databaseURL: URL) throws -> DatabasePool {\n    let coordinator = NSFileCoordinator(filePresenter: nil)\n    var coordinatorError: NSError?\n    var dbPool: DatabasePool?\n    var dbError: Error?\n    coordinator.coordinate(writingItemAt: databaseURL, options: .forMerging, error: &coordinatorError) { url in\n        do {\n            dbPool = try openDatabase(at: url)\n        } catch {\n            dbError = error\n        }\n    }\n    if let error = dbError ?? coordinatorError {\n        throw error\n    }\n    return dbPool!\n}\n\nprivate func openDatabase(at databaseURL: URL) throws -> DatabasePool {\n    var configuration = Configuration()\n    configuration.prepareDatabase { db in\n        if db.configuration.readonly == false {\n            var flag: CInt = 1\n            let code = withUnsafeMutablePointer(to: &flag) { flagP in\n                sqlite3_file_control(db.sqliteConnection, nil, SQLITE_FCNTL_PERSIST_WAL, flagP)\n            }\n            guard code == SQLITE_OK else {\n                throw DatabaseError(resultCode: ResultCode(rawValue: code))\n            }\n        }\n    }\n    let dbPool = try DatabasePool(path: databaseURL.path, configuration: configuration)\n    \n    try migrator.migrate(dbPool)\n    if try dbPool.read(migrator.hasBeenSuperseded) {\n        throw /* some error */\n    }\n    \n    return dbPool\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Decimal Values in SQLite with GRDB.swift\nDESCRIPTION: Demonstrates how Decimal values are stored in the database as strings, which preserves exact decimal representation without floating-point precision issues.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_45\n\nLANGUAGE: swift\nCODE:\n```\n// INSERT INTO transfer VALUES ('10')\ntry db.execute(sql: \"INSERT INTO transfer VALUES (?)\", arguments: [Decimal(10)])\n\n// INSERT INTO transfer VALUES ('10.5')\ntry db.execute(sql: \"INSERT INTO transfer VALUES (?)\", arguments: [Decimal(string: \"10.5\")!])\n```\n\n----------------------------------------\n\nTITLE: Accessing SQLite C Interface in GRDB 5\nDESCRIPTION: Demonstrates how GRDB 5 provides direct access to the SQLite C interface without needing to import additional SQLite modules. This simplifies code that uses low-level SQLite functionality.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nimport CSQLite   // When GRDB is included with the Swift Package Manager\nimport SQLCipher // When GRDB is linked to SQLCipher\nimport SQLite3   // When GRDB is linked to System SQLite\nlet sqliteVersion = String(cString: sqlite3_libversion())\n\n// NEW: GRDB 5\nimport GRDB\nlet sqliteVersion = String(cString: sqlite3_libversion())\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Interpolated Statements in Swift\nDESCRIPTION: Examples of creating prepared statements using SQL interpolation syntax for more dynamic query construction.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Statement.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet insertStatement = try db.makeStatement(literal: \"INSERT ...\")\nlet selectStatement = try db.makeStatement(literal: \"SELECT ...\")\n```\n\n----------------------------------------\n\nTITLE: Creating FTS5 Virtual Table with Custom Tokenizer\nDESCRIPTION: Demonstrates how to create a full-text virtual table that uses a custom tokenizer for text processing.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"documents\", using: FTS5()) { t in\n    t.tokenizer = MyTokenizer.tokenizerDescriptor()\n    t.column(\"content\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Table with Timestamp Columns in Swift\nDESCRIPTION: Creates a 'player' table with autoincremented primary key, creation and modification date columns, and other required fields. This sets up the database structure needed for timestamp tracking.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"creationDate\", .datetime).notNull()\n    t.column(\"modificationDate\", .datetime).notNull()\n    t.column(\"name\", .text).notNull()\n    t.column(\"score\", .integer).notNull()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Common Table Expressions in GRDB Swift Queries\nDESCRIPTION: Shows how to embed a common table expression (CTE) in a query using the with() method. This allows for creating more complex queries with temporary result sets.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_141\n\nLANGUAGE: swift\nCODE:\n```\n// WITH ... SELECT * FROM player\nlet cte = CommonTableExpression(...)\nPlayer.with(cte)\n```\n\n----------------------------------------\n\nTITLE: Using Column Enums with PersistenceContainer in Swift\nDESCRIPTION: Example showing how to use column enums with persistence containers for type-safe column references.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_77\n\nLANGUAGE: swift\nCODE:\n```\nextension Place : MutablePersistableRecord {\n    enum Columns: String, ColumnExpression {\n        case id, title, latitude, longitude\n    }\n    \n    func encode(to container: inout PersistenceContainer) {\n        container[Columns.id] = id\n        container[Columns.title] = title\n        container[Columns.latitude] = coordinate.latitude\n        container[Columns.longitude] = coordinate.longitude\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Database Observation with Combine and RxSwift in GRDB\nDESCRIPTION: Shows how to integrate GRDB's database observation with reactive frameworks like Combine and RxSwift for reactive database updates.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// Combine\nlet cancellable = observation.publisher(in: dbQueue).sink(\n    receiveCompletion: { completion in ... },\n    receiveValue: { (places: [Place]) in print(\"Fresh places: \\(places)\") })\n\n// RxSwift\nlet disposable = observation.rx.observe(in: dbQueue).subscribe(\n    onNext: { (places: [Place]) in print(\"Fresh places: \\(places)\") },\n    onError: { error in ... })\n```\n\n----------------------------------------\n\nTITLE: Creating FTS5 Search Patterns in Swift\nDESCRIPTION: Demonstrates various ways to create FTS5 search patterns from user input using GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nlet query = \"SQLite database\"\n\n// Matches documents that contain \"SQLite\" or \"database\"\nlet pattern = FTS5Pattern(matchingAnyTokenIn: query)\n\n// Matches documents that contain \"SQLite\" and \"database\"\nlet pattern = FTS5Pattern(matchingAllTokensIn: query)\n\n// Matches documents that contain words that start with \"SQLite\" and words that start with \"database\"\nlet pattern = FTS5Pattern(matchingAllPrefixesIn: query)\n\n// Matches documents that contain \"SQLite database\"\nlet pattern = FTS5Pattern(matchingPhrase: query)\n\n// Matches documents that start with \"SQLite database\"\nlet pattern = FTS5Pattern(matchingPrefixPhrase: query)\n```\n\n----------------------------------------\n\nTITLE: Creating a Variable-Argument Custom SQL Function\nDESCRIPTION: Implements an 'averageOf' function that can take any number of arguments and calculates their average. Shows how to create a function without specifying a fixed argument count.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_50\n\nLANGUAGE: swift\nCODE:\n```\nlet averageOf = DatabaseFunction(\"averageOf\", pure: true) { (values: [DatabaseValue]) in\n    let doubles = values.compactMap { Double.fromDatabaseValue($0) }\n    return doubles.reduce(0, +) / Double(doubles.count)\n}\ndb.add(function: averageOf)\n\n// 2.0\ntry Double.fetchOne(db, sql: \"SELECT averageOf(1, 2, 3)\")!\n```\n\n----------------------------------------\n\nTITLE: Interpolating Sequences in SQL Queries (Swift)\nDESCRIPTION: This snippet demonstrates how to interpolate sequences into SQL queries. It shows an example of using an array in an IN clause.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_22\n\nLANGUAGE: Swift\nCODE:\n```\n// SELECT * FROM player WHERE id IN (1, 2, 3)\nlet ids = [1, 2, 3]\n\"SELECT * FROM player WHERE id IN \\(ids)\"\n```\n\n----------------------------------------\n\nTITLE: Registering Custom FTS5 Tokenizer in GRDB.swift\nDESCRIPTION: Shows how to register a custom tokenizer with the database configuration. The tokenizer must be added before creating the database connection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nclass MyTokenizer : FTS5CustomTokenizer { ... }\n\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.add(tokenizer: MyTokenizer.self)\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Implementing HasOne Association in Swift with GRDB\nDESCRIPTION: Defines a one-to-one connection from a Country record to a Demographics record. The association is established using the hasOne() method with an explicit key. This requires the demographics table to have a column pointing to the countries table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nstruct Country: TableRecord {\n    static let demographics = hasOne(Demographics.self, key: \"demographics\")\n    ...\n}\n\nstruct Demographics: TableRecord {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic SQL Prepared Statements in Swift\nDESCRIPTION: Demonstrates how to create prepared SQL statements for insert and select operations using the Database.makeStatement method. Shows usage of named parameters and positional parameters.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Statement.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    let insertStatement = try db.makeStatement(sql: \"\"\"\n        INSERT INTO player (name, score) VALUES (:name, :score)\n        \"\"\")\n    \n    let selectStatement = try db.makeStatement(sql: \"\"\"\n        SELECT * FROM player WHERE name = ?\n        \"\"\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using SQL Aggregate Functions in Swift with GRDB\nDESCRIPTION: Examples of using SQL aggregate functions like MIN, MAX, COUNT in GRDB's query interface. These functions map to Swift equivalents such as min(), max(), and count().\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_162\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT MIN(score), MAX(score) FROM player\nPlayer.select(min(scoreColumn), max(scoreColumn))\n\n// SELECT COUNT(name) FROM player\nPlayer.select(count(nameColumn))\n\n// SELECT COUNT(DISTINCT name) FROM player\nPlayer.select(count(distinct: nameColumn))\n\n// SELECT JULIANDAY(date, 'start of year') FROM game\nGame.select(julianDay(dateColumn, .startOfYear))\n```\n\n----------------------------------------\n\nTITLE: Using CAST Function in GRDB Swift Queries\nDESCRIPTION: Example of using the CAST SQL function via GRDB's Swift interface to convert column types. This demonstrates converting a wins column to REAL type for division operation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_163\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT (CAST(wins AS REAL) / games) AS successRate FROM player\nPlayer.select((cast(winsColumn, as: .real) / gamesColumn).forKey(\"successRate\"))\n```\n\n----------------------------------------\n\nTITLE: Joining and Prefetching Records in GRDB\nDESCRIPTION: Demonstrates how to fetch records along with their associated records using GRDB's including method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_33\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book\n    var author: Author\n}\nlet bookInfos = try Book\n    .including(required: Book.author)\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Exporting Persistable Records as Dictionaries in Swift\nDESCRIPTION: Demonstrates how to export a database record as a dictionary containing column names and values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_60\n\nLANGUAGE: swift\nCODE:\n```\nlet player = try Player.fetchOne(db, key: 1)\nlet dict = player.databaseDictionary // [String: DatabaseValue]\nprint(dict)\n// Prints {\"id\": 1, \"name\": \"Arthur\", \"score\": 1000}\n```\n\n----------------------------------------\n\nTITLE: Comparing Record Database Representation with databaseEquals in Swift\nDESCRIPTION: Uses the databaseEquals method to check if two records have the same database representation. This method compares the database values rather than checking Swift equality, making it useful for determining if a record needs to be saved.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_108\n\nLANGUAGE: swift\nCODE:\n```\nlet oldPlayer: Player = ...\nvar newPlayer: Player = ...\nif newPlayer.databaseEquals(oldPlayer) == false {\n    try newPlayer.save(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Common Table Expressions with Associations in GRDB.swift\nDESCRIPTION: Demonstrates how to use Common Table Expressions (CTEs) with associations to create more complex queries. Associations can have their own CTEs for advanced querying needs.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_68\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: FetchableRecord, Decodable {\n    var author: Author\n    var specialBooks: [Book]\n}\n\nlet specialCTE = CommonTableExpression(...)\nlet specialBooks = Author.books\n    .with(specialCTE)\n    ... // use the CTE in the book association\n    .forKey(\"specialBooks\")\n\nlet authorInfos = try Author\n    .including(all: specialBooks)\n    .asRequest(of: AuthorInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Defining Not Null Columns and Default Values in GRDB.swift\nDESCRIPTION: Shows how to add NOT NULL constraints and default values to columns when creating tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n    // email TEXT NOT NULL,\n    t.column(\"email\", .text).notNull()\n    \n    // name TEXT NOT NULL DEFAULT 'Anonymous',\n    t.column(\"name\", .text).notNull().defaults(to: \"Anonymous\")\n```\n\n----------------------------------------\n\nTITLE: Filtering Authors with At Least One Book in Swift\nDESCRIPTION: Demonstrates how to filter a request to find authors who wrote at least one book by negating the isEmpty aggregate.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_95\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author.having(Author.books.isEmpty == false)\n```\n\n----------------------------------------\n\nTITLE: Annotating with Association Aggregates in GRDB\nDESCRIPTION: Demonstrates extending selection with association aggregates, which allows counting or otherwise aggregating related records in a single query using joins.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_127\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT team.*, COUNT(DISTINCT player.id) AS playerCount\n// FROM team\n// LEFT JOIN player ON player.teamId = team.id\n// GROUP BY team.id\nTeam.annotated(with: Team.players.count)\n```\n\n----------------------------------------\n\nTITLE: Debugging Joined Request Decoding in GRDB.swift\nDESCRIPTION: Shows how to debug request decoding by fetching and inspecting raw database rows. The debugDescription output reveals the structure of association keys and their corresponding values, helpful for troubleshooting.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_85\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Book\n    .including(required: Book.author\n        .including(optional: Author.country))\n    .including(optional: Book.coverImage)\n    .including(all: Book.prizes)\n\nlet rows = try Row.fetchAll(db, request)\nprint(rows[0].debugDescription)\n// Prints:\n// ▿ [id:1, authorId:2, title:\"Moby-Dick\"]\n//   unadapted: [id:1, authorId:2, title:\"Moby-Dick\", id:2, name:\"Herman Melville\", countryCode:\"US\", code:\"US\", name:\"United States of America\", id:NULL, imageId:NULL, path:NULL]\n//   - author: [id:2, name:\"Herman Melville\", countryCode:\"US\"]\n//     - country: [code:\"US\", name:\"United States of America\"]\n//   - coverImage: [id:NULL, imageId:NULL, path:NULL]\n//   + prizes: 3 rows\n```\n\n----------------------------------------\n\nTITLE: Implementing HasManyThrough Association for Many-to-Many Relationships in Swift\nDESCRIPTION: Sets up a many-to-many connection between Country and Citizen records through Passport records. This enables querying relationships that pass through intermediate tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nstruct Country: TableRecord {\n    static let passports = hasMany(Passport.self)\n    static let citizens = hasMany(Citizen.self, through: passports, using: Passport.citizen)\n    ...\n}\n\nstruct Passport: TableRecord {\n    static let country = belongsTo(Country.self)\n    static let citizen = belongsTo(Citizen.self)\n}\n \nstruct Citizen: TableRecord {\n    static let passports = hasMany(Passport.self)\n    static let countries = hasMany(Country.self, through: passports, using: Passport.country)\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Specific Values and Rows in Swift using GRDB\nDESCRIPTION: This snippet shows how to fetch specific values (like Int) or Rows from a database using GRDB. It demonstrates selecting maximum score and fetching minimum and maximum scores as a Row.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_177\n\nLANGUAGE: swift\nCODE:\n```\n// Fetch an Int\nlet request = Player.select(max(scoreColumn))\nlet maxScore = try Int.fetchOne(db, request) // Int?\n\n// Fetch a Row\nlet request = Player.select(min(scoreColumn), max(scoreColumn))\nlet row = try Row.fetchOne(db, request)!     // Row\nlet minScore = row[0] as Int?\nlet maxScore = row[1] as Int?\n```\n\n----------------------------------------\n\nTITLE: Using Custom Request Methods in GRDB Queries\nDESCRIPTION: Example demonstrating the use of custom request methods to create concise and readable database queries. The code shows how to fetch sorted Spanish authors and count novels using the fluent API defined in previous extensions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    let sortedSpanishAuthors: [Author] = try Author.all()\n        .filter(countryCode: \"ES\")\n        .orderByName()\n        .fetchAll(db)\n    \n    let novelCount: Int = try Book.all()\n        .filter(kind: .novel)\n        .fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Custom SQL Functions in GRDB Queries\nDESCRIPTION: Example of applying user-defined SQL functions in GRDB queries. This demonstrates how to use custom functions that have been registered with the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_166\n\nLANGUAGE: swift\nCODE:\n```\nlet f = DatabaseFunction(\"f\", ...)\n\n// SELECT f(name) FROM player\nPlayer.select(f.apply(nameColumn))\n```\n\n----------------------------------------\n\nTITLE: Implementing BelongsTo Association with TableRecord in GRDB Swift\nDESCRIPTION: Shows the basic implementation of related Book and Author models with a BelongsTo relationship following GRDB's conventions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n    static let author = belongsTo(Author.self)\n}\n\nstruct Author: TableRecord {\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing ValueObservation with Map Operator in GRDB\nDESCRIPTION: Demonstrates how to optimize ValueObservation by using the map operator to process raw fetched values without blocking database access or the main thread.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\n// Plain observation\nlet observation = ValueObservation.tracking { db -> MyValue in\n    let players = try Player.fetchAll(db)\n    return computeMyValue(players)\n}\n\n// Optimized observation\nlet observation = ValueObservation\n    .tracking { db try Player.fetchAll(db) }\n    .map { players in computeMyValue(players) }\n```\n\n----------------------------------------\n\nTITLE: Using SQL Literal in Query Interface\nDESCRIPTION: Demonstrates how SQL literals can be used directly as expressions, ordering terms, or selection items in the query interface, providing flexibility for complex queries while maintaining SQL injection protection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nlet name = \"O'Brien\"\nlet request = Player\n    .select(SQL(\"id, score\"), ...)\n    .filter(SQL(\"name = \\(name)\") && ...)\n    .order(SQL(\"score DESC\"), ...)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Queue Scheduling with ValueObservation in Swift\nDESCRIPTION: Shows how to configure a ValueObservation to deliver updates on a specific dispatch queue instead of the main actor, using the async scheduling option.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// Async scheduling notifies all values\n// on the specified dispatch queue.\nlet myQueue: DispatchQueue\nlet cancellable = observation\n    .start(in: dbQueue, scheduling: .async(myQueue)) { error in\n        // Called asynchronously on myQueue\n    } onChange: { value in\n        // Called asynchronously on myQueue\n        print(\"Fresh value\", value)\n    }\n```\n\n----------------------------------------\n\nTITLE: String Concatenation with || Operator in GRDB.swift\nDESCRIPTION: Example of concatenating strings using the SQL || operator through the .concat operator in GRDB, which joins multiple string values together in a query.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_155\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT firstName || ' ' || lastName FROM player\nPlayer.select([firstNameColumn, \" \".databaseValue, lastNameColumn].joined(operator: .concat))\n```\n\n----------------------------------------\n\nTITLE: Initializing QueryInterfaceRequest with Different Return Types\nDESCRIPTION: Demonstrates how to create and use QueryInterfaceRequest with various return types including custom types, strings, and related records. Shows fetching capabilities for different data structures.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\nstruct PlayerInfo: Decodable, FetchableRecord {\n    var player: Player\n    var awards: [Award]\n}\n\n// QueryInterfaceRequest<Player>\nlet playerRequest = Player.all()\n\n// QueryInterfaceRequest<String>\nlet nameRequest = Player.select(Column(\"name\"), as: String.self)\n\n// QueryInterfaceRequest<PlayerInfo>\nlet playerInfoRequest = Player\n    .including(all: Player.awards)\n    .asRequest(of: PlayerInfo.self)\n\ntry playerRequest.fetchAll(db)     // [Player]\ntry nameRequest.fetchAll(db)       // [String]\ntry playerInfoRequest.fetchAll(db) // [PlayerInfo]\n```\n\n----------------------------------------\n\nTITLE: Problematic Raw SQL Query Example in Swift\nDESCRIPTION: Example of a raw SQL query with parameter binding that contains a bug where the number of placeholders doesn't match the number of arguments.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.execute(\n        sql: \"\"\"\n            UPDATE student\n            SET firstName = ?, lastName = ?, department = ?, birthDate = ?,\n                registrationDate = ?, mainTeacherId = ?\n            WHERE id = ?\n            \"\"\",\n        arguments: [firstName, lastName, department, birthDate,\n                    registrationDate, mainTeacherId])\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CTEs with Raw SQL\nDESCRIPTION: Shows multiple ways to create CTEs using raw SQL, including parameter binding and SQL interpolation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet name = \"O'Brien\"\n\n// WITH playerName AS (SELECT 'O''Brien') ...\nlet playerNameCTE = CommonTableExpression(\n    named: \"playerName\",\n    sql: \"SELECT ?\", arguments: [name])\n\n// WITH playerName AS (SELECT 'O''Brien') ...\nlet playerNameCTE = CommonTableExpression(\n    named: \"playerName\",\n    literal: \"SELECT \\(name)\")\n\n// WITH playerName AS (SELECT 'O''Brien') ...\nlet request = SQLRequest(\"SELECT \\(name)\")\nlet playerNameCTE = CommonTableExpression(\n    named: \"playerName\",\n    request: request)\n```\n\n----------------------------------------\n\nTITLE: Using Association Aggregates in GRDB.swift\nDESCRIPTION: Shows how to use association aggregates to filter records based on associated records. This example fetches authors with their awarded books using the having clause.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_67\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: FetchableRecord, Decodable {\n    var author: Author\n    var awardedBooks: [Book]\n}\n\nlet awardedBooks = Author.books\n    .having(Book.awards.isEmpty == false)\n    .forKey(\"awardedBooks\")\n\nlet authorInfos: [AuthorInfo] = try Author\n    .including(all: awardedBooks)\n    .asRequest(of: AuthorInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Implementing Synonyms Tokenizer in Swift\nDESCRIPTION: This example shows how to create a custom tokenizer that handles synonyms, adding multiple synonyms for a single term to the FTS index when tokenizing document text.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nfinal class SynonymsTokenizer : FTS5WrapperTokenizer {\n    static let name = \"synonyms\"\n    let wrappedTokenizer: any FTS5Tokenizer\n    let synonyms: [Set<String>] = [[\"first\", \"1st\"]]\n    \n    init(db: Database, arguments: [String]) throws {\n        wrappedTokenizer = try db.makeTokenizer(.unicode61())\n    }\n    \n    func synonyms(for token: String) -> Set<String>? {\n        synonyms.first { $0.contains(token) }\n    }\n    \n    func accept(token: String, flags: FTS5TokenFlags, for tokenization: FTS5Tokenization, tokenCallback: FTS5WrapperTokenCallback) throws {\n        if tokenization.contains(.query) {\n            // Don't look for synonyms when tokenizing queries\n            try tokenCallback(token, flags)\n            return\n        }\n        \n        guard let synonyms = synonyms(for: token) else {\n            // Token has no synonym\n            try tokenCallback(token, flags)\n            return\n        }\n        \n        for (index, synonym) in synonyms.enumerated() {\n            // Notify each synonym, and set the colocated flag for all but the first\n            let synonymFlags = (index == 0) ? flags : flags.union(.colocated)\n            try tokenCallback(synonym, synonymFlags)\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Rows to Dictionaries in GRDB.swift\nDESCRIPTION: Shows how to convert a Row to different dictionary formats, handling duplicate column names and value representation. This is useful for integrating with other systems or APIs that expect dictionary data structures.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_32\n\nLANGUAGE: swift\nCODE:\n```\n// A `[String: DatabaseValue]` dictionary that keeps leftmost value in case of duplicated column name:\nlet dict = Dictionary(row, uniquingKeysWith: { (left, _) in left })\n\n// A `[String: AnyObject]` dictionary which keeps rightmost value in case of duplicated column name.\n// This dictionary is identical to FMResultSet's resultDictionary from FMDB.\n// It contains NSNull values for null columns, and can be shared with Objective-C:\nlet dict = Dictionary(\n    row.map { (column, dbValue) in\n        (column, dbValue.storage.value as AnyObject)\n    },\n    uniquingKeysWith: { (_, right) in right })\n\n// A `[String: Any]` dictionary that can feed, for example, JSONSerialization:\nlet dict = Dictionary(\n    row.map { (column, dbValue) in\n        (column, dbValue.storage.value)\n    },\n    uniquingKeysWith: { (left, _) in left })\n```\n\n----------------------------------------\n\nTITLE: Creating Indices on Existing Tables in GRDB.swift\nDESCRIPTION: Demonstrates how to create various types of indices on existing tables, including regular and unique indices.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE INDEX index_player_on_email ON player(email)\ntry db.create(indexOn: \"player\", columns: [\"email\"])\n\n// CREATE UNIQUE INDEX index_player_on_email ON player(email)\ntry db.create(indexOn: \"player\", columns: [\"email\"], options: .unique)\n```\n\n----------------------------------------\n\nTITLE: Printing SQL Queries with Statement in GRDB.swift\nDESCRIPTION: Shows how to print the SQL and arguments of a database request using the Statement object for debugging purposes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_222\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    let request = Player.filter(Column(\"email\") == \"arthur@example.com\")\n    let statement = try request.makePreparedRequest(db).statement\n    print(statement) // SELECT * FROM player WHERE email = ?\n    print(statement.arguments) // [\"arthur@example.com\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Performance-Optimized Record in GRDB.swift\nDESCRIPTION: A performance-optimized implementation of a Place record that uses numeric indexes for column access instead of string-based lookup. This approach leverages Encodable for persistence while optimizing the fetch performance.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_116\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place: Encodable {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    private var latitude: CLLocationDegrees\n    private var longitude: CLLocationDegrees\n    \n    var coordinate: CLLocationCoordinate2D {\n        get {\n            CLLocationCoordinate2D(\n                latitude: latitude,\n                longitude: longitude)\n        }\n        set {\n            latitude = newValue.latitude\n            longitude = newValue.longitude\n        }\n    }\n}\n\n// SQL generation\nextension Place: TableRecord {\n    /// The table columns\n    enum Columns {\n        static let id = Column(CodingKeys.id)\n        static let title = Column(CodingKeys.title)\n        static let isFavorite = Column(CodingKeys.isFavorite)\n        static let latitude = Column(CodingKeys.latitude)\n        static let longitude = Column(CodingKeys.longitude)\n    }\n    \n    /// Arrange the selected columns and lock their order\n    static var databaseSelection: [any SQLSelectable] {\n        [\n            Columns.id,\n            Columns.title,\n            Columns.favorite,\n            Columns.latitude,\n            Columns.longitude,\n        ]\n    }\n}\n\n// Fetching methods\nextension Place: FetchableRecord {\n    /// Creates a record from a database row\n    init(row: Row) {\n        // For high performance, use numeric indexes that match the\n        // order of Place.databaseSelection\n        id = row[0]\n        title = row[1]\n        isFavorite = row[2]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[3],\n            longitude: row[4])\n    }\n}\n\n// Persistence methods\nextension Place: MutablePersistableRecord {\n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Group and Having with Associations in GRDB.swift\nDESCRIPTION: Demonstrates how to use group() and having() methods with associations to perform aggregation. This example fetches authors with the latest book year for each kind of book they've written.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_66\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookKindInfo: Decodable {\n    var kind: Book.Kind\n    var maxYear: Int\n}\n\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var bookKindInfos: [BookKindInfo]\n}\n\nlet bookKindInfos = Author.books\n    .select(\n        Column(\"kind\"),\n        max(Column(\"year\")).forKey(\"maxYear\"))\n    .group(Column(\"kind\"))\n    .forKey(\"bookKindInfos\")\n\nlet authorInfos: [AuthorInfo] = try Author\n    .including(all: bookKindInfos)\n    .asRequest(of: AuthorInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Setting a Global Error Logging Function in Swift with GRDB\nDESCRIPTION: This snippet shows how to register a global error logging function for SQLite operations using the Database.logError property. The function receives SQLite result codes and error messages.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_85\n\nLANGUAGE: swift\nCODE:\n```\nDatabase.logError = { resultCode, message in\n    NSLog(\"%@\", \"SQLite error \\(resultCode): \\(message)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Ensuring Type Safety with Tagged Common Table Expressions\nDESCRIPTION: Demonstrates a technique for improving type safety when working with multiple CTEs by explicitly tagging them with specific types, allowing the compiler to verify correct association usage.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nenum CTE1 { }\nlet cte1 = CommonTableExpression<CTE1>(...)\n\nenum CTE2 { }\nlet cte2 = CommonTableExpression<CTE2>(...)\n\nlet assoc1 = BaseRecord.association(to: cte1, on: ...)     // from BaseRecord to CTE1\nlet assoc2 = cte1.association(to: cte2, on: ...)           // from CTE1 to CTE2\nlet assoc3 = cte2.association(to: FarRecord.self, on: ...) // from CTE2 to FarRecord\n\n// WITH ...\n// SELECT base.* FROM base\n// JOIN cte1 ON ...\n// JOIN cte2 ON ...\n// JOIN far ON ...\nlet request = BaseRecord\n    .with(cte1).with(cte2)\n    .joining(required: assoc1.                     // OK\n        .joining(required: assoc2.                 // OK\n            .joining(required: assoc3)))           // OK\n\n// Compiler error\nlet request = BaseRecord\n    .joining(required: assoc2)                     // Not OK\n    .joining(required: assoc3)                     // Not OK\n```\n\n----------------------------------------\n\nTITLE: Using IFNULL Function with Swift Nil-Coalescing Operator in GRDB\nDESCRIPTION: Examples of using SQLite's IFNULL function via Swift's nil-coalescing operator (??) in GRDB queries. This allows providing default values for potentially NULL columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_164\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT IFNULL(name, 'Anonymous') FROM player\nPlayer.select(nameColumn ?? \"Anonymous\")\n\n// SELECT IFNULL(name, email) FROM player\nPlayer.select(nameColumn ?? emailColumn)\n```\n\n----------------------------------------\n\nTITLE: Implementing HasOneThrough Association in Swift with GRDB\nDESCRIPTION: Establishes a one-to-one connection between records through an intermediate record. In this example, a Book can access an Address through its Library association, which has a direct relationship to Address.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n    static let library = belongsTo(Library.self)\n    static let returnAddress = hasOne(Address.self, through: library, using: Library.address)\n    ...\n}\n\nstruct Library: TableRecord {\n    static let address = hasOne(Address.self)\n    ...\n}\n \nstruct Address: TableRecord {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Partial Foreign Key Checks in Migration in Swift\nDESCRIPTION: Shows how to perform targeted foreign key checks on specific tables within a migration after disabling deferred checks, allowing faster migrations while still ensuring integrity of critical tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nmigrator = migrator.disablingDeferredForeignKeyChecks()\nmigrator.registerMigration(\"Partially checked\") { db in\n    ...\n    \n    // Throws an error and stops migrations if there exists a\n    // foreign key violation in the 'book' table.\n    try db.checkForeignKeys(in: \"book\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Raw SQL in GRDB WHERE Clauses\nDESCRIPTION: Examples of embedding raw SQL in GRDB's WHERE clause. This demonstrates how to add filtering conditions using SQL syntax when the query interface doesn't provide the needed functionality.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_172\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE score >= 1000\nlet request = Player.filter(sql: \"score >= 1000\")\n\n// SELECT * FROM player WHERE score >= 1000\nlet minScore = 1000\nlet request = Player.filter(sql: \"score >= ?\", arguments: [minScore])\n```\n\n----------------------------------------\n\nTITLE: Using GRDB's query interface with uppercase function\nDESCRIPTION: This example demonstrates how to use GRDB's unicode-aware uppercase function in the query interface, providing a more concise syntax for column transformations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_213\n\nLANGUAGE: swift\nCODE:\n```\nPlayer.select(nameColumn.uppercased)\n```\n\n----------------------------------------\n\nTITLE: Defining Models for Ordered HasManyThrough Associations\nDESCRIPTION: Sets up models for a more complex relationship between teams and players using an intermediate PlayerRole model, preparing for an ordered HasManyThrough association.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_61\n\nLANGUAGE: swift\nCODE:\n```\nstruct Team: FetchableRecord, TableRecord {\n    var id: Int64\n    var name: String\n}\n\nstruct PlayerRole: FetchableRecord, TableRecord {\n    var teamId: Int64\n    var playerId: Int64\n    var position: Int\n}\n\nstruct Player: FetchableRecord, TableRecord {\n    var id: Int64\n    var name: String\n}\n```\n\n----------------------------------------\n\nTITLE: Using Type Casting with Row Values in GRDB.swift\nDESCRIPTION: Shows how to use Swift's 'as' type casting operator with row values. This approach provides an alternative syntax for value extraction with type conversion.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_25\n\nLANGUAGE: swift\nCODE:\n```\nrow[...] as Int\nrow[...] as Int?\n```\n\n----------------------------------------\n\nTITLE: Adding Required Parentheses for Subqueries in SQL Interpolation\nDESCRIPTION: Shows the new requirement in GRDB 5 to manually add parentheses around subqueries in SQL interpolation. This change enables concatenation of subqueries with the UNION operator.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nlet maximumScore: SQLRequest<Int> = \"SELECT MAX(score) FROM player\"\nlet bestPlayers: SQLRequest<Player> = \"SELECT * FROM player WHERE score = \\(maximumScore)\"\n \n// NEW: GRDB 5\nlet maximumScore: SQLRequest<Int> = \"SELECT MAX(score) FROM player\"\nlet bestPlayers: SQLRequest<Player> = \"SELECT * FROM player WHERE score = (\\(maximumScore))\"\n//                                            extra parenthesis required: ^               ^\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Associations in GRDB.swift\nDESCRIPTION: This example demonstrates how to combine multiple associations in a single request. It fetches books along with their required author and optional translator.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_51\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, person1.*, person2.*\n// FROM book\n// JOIN person person1 ON person1.id = book.authorId\n// LEFT JOIN person person2 ON person2.id = book.translatorId\nlet request = Book\n    .including(required: Book.author)\n    .including(optional: Book.translator)\n\n// This request can feed the following record:\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var author: Person\n    var translator: Person?\n}\nlet bookInfos: [BookInfo] = try BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Configuring userInfo Dictionary for Contextual Decoding\nDESCRIPTION: Shows how to implement and use the userInfo dictionary to provide context during encoding and decoding operations. This allows records to adjust their behavior based on whether they're being encoded/decoded for database storage or other purposes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_101\n\nLANGUAGE: swift\nCODE:\n```\nprotocol FetchableRecord {\n    static var databaseDecodingUserInfo: [CodingUserInfoKey: Any] { get }\n}\n\nprotocol EncodableRecord {\n    static var databaseEncodingUserInfo: [CodingUserInfoKey: Any] { get }\n}\n```\n\n----------------------------------------\n\nTITLE: EXISTS and NOT EXISTS Operators in GRDB.swift\nDESCRIPTION: Examples of checking if a subquery would return rows using the exists method, which translates to SQL EXISTS and NOT EXISTS operators. Demonstrates usage with table aliases for self-referencing queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_158\n\nLANGUAGE: swift\nCODE:\n```\n// Teams that have at least one other player\n//\n//  SELECT * FROM team\n//  WHERE EXISTS (SELECT * FROM player WHERE teamID = team.id)\nlet teamAlias = TableAlias()\nlet player = Player.filter(Column(\"teamID\") == teamAlias[Column(\"id\")])\nlet teams = Team.aliased(teamAlias).filter(player.exists())\n\n// Teams that have no player\n//\n//  SELECT * FROM team\n//  WHERE NOT EXISTS (SELECT * FROM player WHERE teamID = team.id)\nlet teams = Team.aliased(teamAlias).filter(!player.exists())\n```\n\nLANGUAGE: swift\nCODE:\n```\n// Players who coach at least one other player\n//\n//  SELECT coach.* FROM player coach\n//  WHERE EXISTS (SELECT * FROM player WHERE coachId = coach.id)\nlet coachAlias = TableAlias(name: \"coach\")\nlet coachedPlayer = Player.filter(Column(\"coachId\") == coachAlias[Column(\"id\")])\nlet coaches = Player.aliased(coachAlias).filter(coachedPlayer.exists())\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT coach.* FROM player coach\n// WHERE EXISTS (SELECT * FROM player WHERE coachId = coach.id)\nlet coachedPlayer = SQLRequest(\"SELECT * FROM player WHERE coachId = \\(coachAlias[Column(\"id\")])\")\nlet coaches = Player.aliased(coachAlias).filter(coachedPlayer.exists())\n```\n\n----------------------------------------\n\nTITLE: Creating a DatabaseQueue with Custom Configuration in Swift\nDESCRIPTION: This snippet demonstrates how to create a Configuration object with custom settings and use it to initialize a DatabaseQueue or DatabasePool. It shows how to set the readonly mode and configure the maximum reader count.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Configuration.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.readonly = true\nconfig.maximumReaderCount = 2  // (DatabasePool only) The default is 5\n\nlet dbQueue = try DatabaseQueue( // or DatabasePool\n    path: \"/path/to/database.sqlite\",\n    configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Configuring Associations with Non-Conventional Table Names in Swift\nDESCRIPTION: Demonstrates how to configure associations when table names don't follow the recommended naming conventions. This requires explicit association keys in record type extensions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: TableRecord {\n    // Explicit association key because the table name is not 'postalAddress'   \n    static let postalAddress = belongsTo(PostalAddress.self, key: \"postalAddress\")\n\n    // Explicit association key because the table name is not 'award'\n    static let awards = hasMany(Award.self, key: \"awards\")\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Associations in GRDB.swift\nDESCRIPTION: This snippet shows how to chain associations to fetch nested related data. It retrieves books with their authors and the authors' countries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_52\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, person.*, country.*\n// FROM book\n// JOIN person ON person.id = book.authorId\n// LEFT JOIN country ON country.code = person.countryCode\nlet request = Book\n    .including(required: Book.author\n        .including(optional: Person.country))\n\n// This request can feed the following record:\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var author: Author\n    var country: Country?\n}\nlet bookInfos: [BookInfo] = try BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Implementing Player Filter by ID Query\nDESCRIPTION: Two versions of a method to filter players by ID - a simple version and a future-proof version with full column specification.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nextension Player {\n    /// \"Simple\" version\n    static func filter(id: Int64) -> SQLRequest<Player> {\n        \"SELECT * FROM player WHERE id = \\(id)\"\n    }\n    \n    /// \"Future-proof\" version\n    static func filter(id: Int64) -> SQLRequest<Player> {\n        \"\"\"\n        SELECT \\(columnsOf: self)\n        FROM \\(self)\n        WHERE \\(CodingKeys.id) = \\(id)\n        \"\"\"\n    }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet player = try dbQueue.read { db in\n    // SELECT * player WHERE id = 42\n    try Player.filter(id: 42).fetchOne(db) // Player?\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Table Alias\nDESCRIPTION: Proper implementation of table alias to filter books published after author's death\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_70\n\nLANGUAGE: swift\nCODE:\n```\nlet authorAlias = TableAlias()\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Book\n    .joining(required: Book.author.aliased(authorAlias))\n    .filter(Column(\"publishDate\") >= authorAlias[Column(\"deathDate\")])\n```\n\n----------------------------------------\n\nTITLE: API Changes in GRDB.swift 3.3.0\nDESCRIPTION: Shows API changes in version 3.3.0, including the new DatabaseWriter.concurrentRead method for concurrent database reads and cursor enhancements.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_42\n\nLANGUAGE: diff\nCODE:\n```\n protocol DatabaseWriter : DatabaseReader {\n+    func concurrentRead<T>(_ block: @escaping (Database) throws -> T) -> Future<T>\n+    @available(*, deprecated)\n     func readFromCurrentState(_ block: @escaping (Database) -> Void) throws\n }\n\n+class Future<Value> {\n+    func wait() throws -> Value\n+}\n\n extension Cursor {\n+    func isEmpty() throws -> Bool\n }\n```\n\n----------------------------------------\n\nTITLE: Using Raw SQL in GRDB SELECT Queries\nDESCRIPTION: Examples of embedding raw SQL in GRDB's SELECT clause. This shows how to use SQL functions or expressions not directly supported by GRDB's Swift interface.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_167\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT IFNULL(name, 'O''Brien'), score FROM player\nlet request = Player.select(sql: \"IFNULL(name, 'O''Brien'), score\")\n\n// SELECT IFNULL(name, 'O''Brien'), score FROM player\nlet defaultName = \"O'Brien\"\nlet request = Player.select(sql: \"IFNULL(name, ?), score\", arguments: [suffix])\n```\n\n----------------------------------------\n\nTITLE: Creating Column Objects in Swift\nDESCRIPTION: Examples of creating Column objects which represent database columns. Shows standard column creation with column names and special rowID column access.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nColumn(\"name\")\nColumn(\"id\")\nColumn.rowID\n```\n\n----------------------------------------\n\nTITLE: Implementing Best Players Query\nDESCRIPTION: Methods to find players with the maximum score using a subquery, with both simple and future-proof versions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: Decodable, FetchableRecord, TableRecord {\n    /// \"Simple\" version\n    static func bestPlayers() -> SQLRequest<Player> {\n        \"SELECT * FROM player WHERE score = (\\(maximumScore()))\"\n    }\n    \n    /// \"Future-proof\" version\n    static func bestPlayers() -> SQLRequest<Player> {\n        \"\"\"\n        SELECT \\(columnsOf: self)\n        FROM \\(self)\n        WHERE \\(CodingKeys.score) = (\\(maximumScore()))\n        \"\"\"\n    }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet bestPlayers = try dbQueue.read { db in\n    // SELECT * FROM player WHERE score = (SELECT MAX(score) FROM player)\n    try Player.bestPlayers().fetchAll(db) // [Player]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Specialized Request Method with Custom Association Keys in GRDB.swift\nDESCRIPTION: Defines a static method that builds a request with customized association keys to match the coding keys of a Decodable record. Uses forKey() to ensure proper mapping between the database and the record structure.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_82\n\nLANGUAGE: swift\nCODE:\n```\nextension BookInfo {\n    static func all() -> QueryInterfaceRequest<BookInfo> {\n        Book.including(optional: Book.coverImage)\n            .including(required: Book.author\n                .forKey(CodingKeys.authorInfo)        // (1)\n                .including(optional: Person.country))\n            .including(optional: Book.translator\n                .forKey(CodingKeys.translatorInfo)    // (1)\n                .including(optional: Person.country))\n            .asRequest(of: BookInfo.self)             // (2)\n    }\n}\n\nlet bookInfos = try BookInfo.all().fetchAll(db, request) // [BookInfo]\n```\n\n----------------------------------------\n\nTITLE: Logical Operators with Aggregates in GRDB.swift\nDESCRIPTION: Demonstrates how to use logical operators (&&, ||, !) with aggregates to create complex conditions in GRDB queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_101\n\nLANGUAGE: sql\nCODE:\n```\nSELECT author.*\nFROM author\nLEFT JOIN book ON book.authorId = author.id\nLEFT JOIN painting ON painting.authorId = author.id\nGROUP BY author.id\nHAVING ((COUNT(DISTINCT book.id) = 0) AND (COUNT(DISTINCT painting.id) = 0))\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet condition = Author.books.isEmpty && Author.paintings.isEmpty\nlet request = Author.having(condition)\n```\n\n----------------------------------------\n\nTITLE: Querying Migration Status with DatabaseMigrator\nDESCRIPTION: Shows new methods for checking migration status in GRDB, including checking if migrations are completed, listing completed migrations, and accessing the most recent migration.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_19\n\nLANGUAGE: swift\nCODE:\n```\n// New\ndbQueue.read(migrator.hasCompletedMigrations)\ndbQueue.read(migrator.completedMigrations).contains(\"v2\")\ndbQueue.read(migrator.completedMigrations).last == \"v2\"\ndbQueue.read(migrator.appliedMigrations)\n\n// Deprecated\nmigrator.hasCompletedMigrations(in: dbQueue)\nmigrator.hasCompletedMigrations(in: dbQueue, through: \"v2\")\nmigrator.lastCompletedMigration(in: dbQueue) == \"v2\"\nmigrator.appliedMigrations(in: dbQueue)\n```\n\n----------------------------------------\n\nTITLE: SQLite Error Handling in Swift\nDESCRIPTION: Shows the simplified approach to catching specific SQLite error codes in GRDB 5.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_16\n\nLANGUAGE: Swift\nCODE:\n```\ndo {\n    try ...\n} catch DatabaseError.SQLITE_CONSTRAINT_FOREIGNKEY {\n    // foreign key constraint error\n} catch DatabaseError.SQLITE_CONSTRAINT {\n    // any other constraint error\n} catch {\n    // any other database error\n}\n```\n\n----------------------------------------\n\nTITLE: Using DatabaseRegionObservation Publisher with Sink in Swift\nDESCRIPTION: Demonstrates subscribing to a DatabaseRegionObservation publisher using sink() to receive notifications when player records change. The example shows how the publisher emits values when players are inserted or deleted.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.all()\nlet cancellable = DatabaseRegionObservation\n    .tracking(request)\n    .publisher(in: dbQueue)\n    .sink(\n        receiveCompletion: { completion in ... },\n        receiveValue: { (db: Database) in\n            print(\"Players have changed.\")\n        })\n\ntry dbQueue.write { db in\n    try Player(name: \"Arthur\").insert(db)\n    try Player(name: \"Barbara\").insert(db)\n} \n// Prints \"Players have changed.\"\n\ntry dbQueue.write { db in\n    try Player.deleteAll(db)\n}\n// Prints \"Players have changed.\"\n```\n\n----------------------------------------\n\nTITLE: Skipping Intermediate Tables with joining Method in GRDB.swift\nDESCRIPTION: This example demonstrates how to use the joining method to fetch related data while skipping intermediate tables. It retrieves books with their authors' countries without including the authors themselves.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_53\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, country.*\n// FROM book\n// LEFT JOIN person ON person.id = book.authorId\n// LEFT JOIN country ON country.code = person.countryCode\nlet request = Book\n    .joining(optional: Book.author\n        .including(optional: Person.country))\n\n// This request can feed the following record:\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var country: Country?\n}\nlet bookInfos: [BookInfo] = try BookInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Customizing Date Storage Format in GRDB.swift\nDESCRIPTION: Shows how to customize the date storage format by explicitly storing TimeInterval instead of Date. This approach allows for custom date representation in the database when the default format is not suitable.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_40\n\nLANGUAGE: swift\nCODE:\n```\nlet date = Date()\nlet timeInterval = date.timeIntervalSinceReferenceDate\ntry db.execute(\n    sql: \"INSERT INTO player (creationDate, ...) VALUES (?, ...)\",\n    arguments: [timeInterval, ...])\n\nif let row = try Row.fetchOne(db, ...) {\n    let timeInterval: TimeInterval = row[\"creationDate\"]\n    let creationDate = Date(timeIntervalSinceReferenceDate: timeInterval)\n}\n```\n\n----------------------------------------\n\nTITLE: LIKE Operator in GRDB.swift\nDESCRIPTION: Examples of using the LIKE operator through the like method in GRDB, which allows for pattern matching in strings with wildcard characters. Includes example with escape character.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_159\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE (email LIKE '%@example.com')\nPlayer.filter(emailColumn.like(\"%@example.com\"))\n\n// SELECT * FROM book WHERE (title LIKE '%10\\%%' ESCAPE '\\')\nPlayer.filter(emailColumn.like(\"%10\\\\%%\", escape: \"\\\\\"))\n```\n\n----------------------------------------\n\nTITLE: Interpolating Plain SQL Strings and Arguments in SQL Queries (Swift)\nDESCRIPTION: This snippet demonstrates how to interpolate plain SQL strings and arguments into SQL queries. It shows both a simple table name interpolation and a parameterized query.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_28\n\nLANGUAGE: Swift\nCODE:\n```\n// SELECT * FROM player\n\"SELECT * FROM \\(sql: \"player\")\"\n\n// SELECT * FROM player WHERE name = 'O''Brien'\n\"SELECT * FROM player WHERE \\(sql: \"name = ?\", arguments: [\"O'Brien\"])\"\n```\n\n----------------------------------------\n\nTITLE: Building SQL Queries Incrementally in Swift\nDESCRIPTION: Examples showing how to build SQL queries step by step using operators and methods like +, +=, append, and joined() with the SQL type.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// +, +=, append\nvar query: SQL = \"UPDATE player \"\nquery += \"SET name = \\(name) \"\nquery.append(literal: \"WHERE id = \\(id)\")\n\n// joined(), joined(separator:)\nlet components: [SQL] = [\n    \"UPDATE player\",\n    \"SET name = \\(name)\",\n    \"WHERE id = \\(id)\"\n]\nlet query = components.joined(separator: \" \")\n```\n\n----------------------------------------\n\nTITLE: Registering and Using Custom Tokenizer in Swift\nDESCRIPTION: This snippet shows how to register a custom tokenizer (LatinAsciiTokenizer in this case) and use it when creating an FTS5 virtual table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ndbQueue.add(tokenizer: LatinAsciiTokenizer.self) // or dbPool.add\n\ndbQueue.inDatabase { db in\n    try db.create(virtualTable: \"documents\", using: FTS5()) { t in\n        t.tokenizer = LatinAsciiTokenizer.tokenizerDescriptor()\n        t.column(\"authors\")\n        t.column(\"title\")\n        t.column(\"body\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Player Records with NULL Values in Swift\nDESCRIPTION: Demonstrates how to perform a batch update in GRDB that sets a column value to NULL. This is performed using the assignment operator with a nil value.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n// UPDATE player SET score = NULL\ntry Player.updateAll(db, scoreColumn <- nil)\n```\n\n----------------------------------------\n\nTITLE: Explicit Definition of HasOneThrough Association in Swift\nDESCRIPTION: Shows a more explicit way to define a HasOneThrough association by directly referencing the through and using associations. This approach provides clearer understanding of the relationship chain.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n    static let returnAddress = hasOne(\n        Address.self,\n        through: Book.belongsTo(Library.self),\n        using: Library.hasOne(Address.self))\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Throwing Custom SQL Function\nDESCRIPTION: Creates a custom 'sqrt' function that validates its input and throws a database error for negative numbers, demonstrating error handling in custom SQL functions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_51\n\nLANGUAGE: swift\nCODE:\n```\nlet sqrt = DatabaseFunction(\"sqrt\", argumentCount: 1, pure: true) { (values: [DatabaseValue]) in\n    guard let double = Double.fromDatabaseValue(values[0]) else {\n        return nil\n    }\n    guard double >= 0 else {\n        throw DatabaseError(message: \"invalid negative number\")\n    }\n    return sqrt(double)\n}\ndb.add(function: sqrt)\n\n// SQLite error 1 with statement `SELECT sqrt(-1)`: invalid negative number\ntry Double.fetchOne(db, sql: \"SELECT sqrt(-1)\")!\n```\n\n----------------------------------------\n\nTITLE: Configuring FTS4 Tables with Advanced Options in Swift\nDESCRIPTION: This snippet demonstrates how to create an FTS4 table with advanced options including content configuration, compression, prefix indexing, and specialized column settings like notIndexed and languageId.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE VIRTUAL TABLE book USING fts4(\n//   content,\n//   uuid,\n//   content=\"\",\n//   compress=zip,\n//   uncompress=unzip,\n//   prefix=\"2,4\",\n//   notindexed=uuid,\n//   languageid=lid\n// )\ntry db.create(virtualTable: \"document\", using: FTS4()) { t in\n    t.content = \"\"\n    t.compress = \"zip\"\n    t.uncompress = \"unzip\"\n    t.prefixes = [2, 4]\n    t.column(\"content\")\n    t.column(\"uuid\").notIndexed()\n    t.column(\"lid\").asLanguageId()\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Foreign Keys in GRDB.swift\nDESCRIPTION: This method retrieves information about foreign keys on a specific table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_5\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/foreignKeys(on:in:)\n```\n\n----------------------------------------\n\nTITLE: Opening a Shared Read-Only Database in Swift\nDESCRIPTION: This function attempts to open a shared database in read-only mode. It uses NSFileCoordinator for file coordination and checks if the database exists and has the required schema version before returning the database pool.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nfunc openSharedReadOnlyDatabase(at databaseURL: URL) throws -> DatabasePool? {\n    let coordinator = NSFileCoordinator(filePresenter: nil)\n    var coordinatorError: NSError?\n    var dbPool: DatabasePool?\n    var dbError: Error?\n    coordinator.coordinate(readingItemAt: databaseURL, options: .withoutChanges, error: &coordinatorError) { url in\n        do {\n            dbPool = try openReadOnlyDatabase(at: url)\n        } catch {\n            dbError = error\n        }\n    }\n    if let error = dbError ?? coordinatorError {\n        throw error\n    }\n    return dbPool\n}\n\nprivate func openReadOnlyDatabase(at databaseURL: URL) throws -> DatabasePool? {\n    do {\n        var configuration = Configuration()\n        configuration.readonly = true\n        let dbPool = try DatabasePool(path: databaseURL.path, configuration: configuration)\n        \n        return try dbPool.read { db in\n            if try migrator.hasBeenSuperseded(db) {\n                return nil\n            } else if try migrator.hasCompletedMigrations(db) == false {\n                return nil\n            }\n            return dbPool\n        }\n    } catch {\n        if FileManager.default.fileExists(atPath: databaseURL.path) {\n            throw error\n        } else {\n            return nil\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Expression Literals in GRDB\nDESCRIPTION: Example of creating SQL expression literals that support GRDB operators and methods. This technique allows building reusable SQL expressions that integrate with GRDB's query interface.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_170\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT IFNULL(name, 'O''Brien') AS displayName, score FROM player\nlet defaultName = \"O'Brien\"\nlet displayName = SQL(\"IFNULL(\\(Column(\"name\")), \\(defaultName))\").sqlExpression\nlet request = Player.select(displayName.forKey(\"displayName\"), Column(\"score\"))\n```\n\n----------------------------------------\n\nTITLE: Filtering Books by Author Country\nDESCRIPTION: Shows how to filter books by joining with authors and applying conditions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_40\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*\n// FROM book\n// JOIN author ON author.id = book.authorId\n//            AND author.country = 'France'\nlet request = Book.joining(required: Book.author.filter(Column(\"country\") == \"France\"))\n```\n\n----------------------------------------\n\nTITLE: Selecting Specific Columns in GRDB.swift Associations\nDESCRIPTION: Demonstrates how to select specific columns from associated records rather than retrieving all columns. This can optimize queries by reducing the amount of data transferred.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_64\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, author.id, author.name\n// FROM book\n// JOIN author ON author.id = book.authorId\nlet restrictedAuthor = Book.author.select(Column(\"id\"), Column(\"name\"))\nlet request = Book.including(required: restrictedAuthor)\n```\n\n----------------------------------------\n\nTITLE: Database Access Implementation in Swift\nDESCRIPTION: Extends the configuration type with database access capabilities using GRDB's FetchableRecord and PersistableRecord protocols.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SingleRowTables.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nextension AppConfiguration: FetchableRecord, PersistableRecord {\n    func willUpdate(_ db: Database, columns: Set<String>) throws {\n        if try !exists(db) {\n            try AppConfiguration.default.insert(db)\n        }\n    }\n    \n    static func find(_ db: Database) throws -> AppConfiguration {\n        try fetchOne(db) ?? .default\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Observing Database Transactions with DatabaseRegionObservation and Combine\nDESCRIPTION: Creates publishers that deliver database connections whenever transactions impact observed regions. Examples show tracking Player table and maximum score changes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// A publisher with output Database and failure Error\nlet publisher = DatabaseRegionObservation\n    .tracking(Player.all())\n    .publisher(in: dbQueue)\n\nlet cancellable = publisher.sink(\n    receiveCompletion: { completion in ... },\n    receiveValue: { (db: Database) in\n        print(\"Exclusive write access to the database after players have been impacted\")\n    })\n\n// A publisher with output Database and failure Error\nlet publisher = DatabaseRegionObservation\n    .tracking(SQLRequest<Int>(sql: \"SELECT MAX(score) FROM player\"))\n    .publisher(in: dbQueue)\n\nlet cancellable = publisher.sink(\n    receiveCompletion: { completion in ... },\n    receiveValue: { (db: Database) in\n        print(\"Exclusive write access to the database after maximum score has been impacted\")\n    })\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Sorting Criteria in GRDB.swift\nDESCRIPTION: Shows how to apply multiple sorting criteria by sorting both the base record and associated records. The request is sorted on the base record first, then on the associated record.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_58\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*, person.*\n// FROM book\n// JOIN person ON person.id = book.authorId\n// ORDER BY book.publishDate DESC, person.name\nlet sortedAuthor = Book.author.order(Column(\"name\"))\nlet request = Book\n    .including(required: sortedAuthor)\n    .order(Column(\"publishDate\").desc)\n```\n\n----------------------------------------\n\nTITLE: Working with DateComponents using DatabaseDateComponents in GRDB.swift\nDESCRIPTION: Demonstrates storing and retrieving DateComponents using the DatabaseDateComponents helper type. This allows control over the date format and supports reading from all SQLite date formats.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_41\n\nLANGUAGE: swift\nCODE:\n```\nlet components = DateComponents()\ncomponents.year = 1973\ncomponents.month = 9\ncomponents.day = 18\n\n// Store \"1973-09-18\"\nlet dbComponents = DatabaseDateComponents(components, format: .YMD)\ntry db.execute(\n    sql: \"INSERT INTO player (birthDate, ...) VALUES (?, ...)\",\n    arguments: [dbComponents, ...])\n\n// Read \"1973-09-18\"\nlet row = try Row.fetchOne(db, sql: \"SELECT birthDate ...\")!\nlet dbComponents: DatabaseDateComponents = row[\"birthDate\"]\ndbComponents.format         // .YMD (the actual format found in the database)\ndbComponents.dateComponents // DateComponents\n```\n\n----------------------------------------\n\nTITLE: Handling RecordError in GRDB.swift\nDESCRIPTION: Example showing how to catch a RecordError that occurs when trying to update or find a non-existent record in the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_208\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try player.update(db)\n} catch let RecordError.recordNotFound(databaseTableName: table, key: key) {\n    print(\"Key \\(key) was not found in table \\(table).\")\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    let player = try Player.find(db, id: 42)\n} catch let RecordError.recordNotFound(databaseTableName: table, key: key) {\n    print(\"Key \\(key) was not found in table \\(table).\")\n}\n```\n\n----------------------------------------\n\nTITLE: Restricting Default Column Selection for Record Types in GRDB Swift\nDESCRIPTION: Demonstrates how to customize the default column selection for all queries of a specific record type by implementing the databaseSelection property. This example selects only specific columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_149\n\nLANGUAGE: swift\nCODE:\n```\n// Select a limited set of columns\nstruct RestrictedPlayer : TableRecord {\n    static let databaseTableName = \"player\"\n    static var databaseSelection: [any SQLSelectable] {\n        [Column(\"id\"), Column(\"name\")]\n    }\n}\n\n// SELECT id, name FROM player\nlet request = RestrictedPlayer.all()\n```\n\n----------------------------------------\n\nTITLE: Fetching and Using Player Data Across Threads in Swift\nDESCRIPTION: This code shows how to fetch a player from the database and safely use its data in a different thread (main queue in this case).\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nif let player = try Player.fetchOne(db, key: 1) {\n    DispatchQueue.main.async {\n        nameField.text = player.name\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Synchronized Full-Text Tables and Their Triggers in Swift\nDESCRIPTION: Demonstrates how to properly drop a full-text table and its associated synchronization triggers. If these triggers aren't removed, they will prevent future operations on the content table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\n// Create tables\ntry db.create(table: \"book\") { t in\n    ...\n}\ntry db.create(virtualTable: \"book_ft\", using: FTS4()) { t in\n    t.synchronize(withTable: \"book\")\n    ...\n}\n\n// Drop full-text table\ntry db.drop(table: \"book_ft\")\ntry db.dropFTS4SynchronizationTriggers(forTable: \"book_ft\")\n```\n\n----------------------------------------\n\nTITLE: Updating Changed Fields with Timestamp\nDESCRIPTION: Shows how to selectively update only changed fields while managing modification timestamps.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// Only bump the modification date if record is changed, and only\n// update the changed columns.\ntry player.updateChangesWithTimestamp(db) {\n    $0.score = 1000\n}\n\n// Prefer updateChanges() if the modification date should always be\n// updated, even if other columns are not changed.\ntry player.updateChanges(db) {\n    $0.score = 1000\n    $0.modificationDate = try db.transactionDate\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Associations with Foreign Keys in GRDB Swift\nDESCRIPTION: This snippet shows how to configure associations between Player and Team records in GRDB.swift when foreign keys are properly declared in the database schema. The associations are automatically set up based on the schema's foreign key definitions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: TableRecord {\n    static let team = belongsTo(Team.self)\n}\n\nextension Team: TableRecord {\n    static let players = hasMany(Player.self)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Functions with the Query Interface\nDESCRIPTION: Shows how to use custom functions in the query interface, enabling type-safe SQL generation with custom function calls.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_52\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT reverseString(\"name\") FROM player\nPlayer.select(reverseString(nameColumn))\n```\n\n----------------------------------------\n\nTITLE: Tracking Specific Database Region Changes in Swift with GRDB\nDESCRIPTION: Example showing how to track changes to a specific column for a player with ID 1 using ValueObservation.tracking. Demonstrates separating the tracked region from the fetched value.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nlet observation = ValueObservation.tracking(\n    // Define the tracked database region\n    // (the score column of the player with id 1)\n    region: Player.select(Column(\"score\")).filter(id: 1),\n    // Define what to fetch upon such change to the tracked region\n    // (the player with id 1)\n    fetch: { db in try Player.fetchOne(db, id: 1) }\n)\n```\n\n----------------------------------------\n\nTITLE: Custom Foreign Key for HasOne Association in GRDB Swift\nDESCRIPTION: Shows how to define a HasOne association when the database schema doesn't follow GRDB conventions. Requires manually specifying the foreign key relationship.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_28\n\nLANGUAGE: swift\nCODE:\n```\nstruct Country: TableRecord {\n    static let demographics = hasOne(Demographics.self, using: ForeignKey(...))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Transaction Observer in Swift GRDB\nDESCRIPTION: Example showing how to add a transaction observer to a database queue. The observer starts receiving change notifications after being added to the database connection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nlet observer = MyObserver()\ndbQueue.add(transactionObserver: observer)\n```\n\n----------------------------------------\n\nTITLE: Transaction Type Specification in GRDB\nDESCRIPTION: Example showing how to specify different transaction types (deferred, immediate, exclusive) when starting a transaction.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Transactions.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet dbQueue = try DatabaseQueue(path: \"/path/to/database.sqlite\")\n\ntry dbQueue.inTransaction(.exclusive) { db in ... }\n```\n\n----------------------------------------\n\nTITLE: Customizing Association Keys with forKey Method in GRDB.swift\nDESCRIPTION: Shows how to use the forKey method to customize association keys for a filtered association. This example creates a 'novels' association that is actually a filtered subset of books.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_79\n\nLANGUAGE: swift\nCODE:\n```\nextension Author {\n    static let novels = books\n        .filter(Column(\"kind\") == \"novel\")\n        .forKey(\"novels\")\n}\nAuthor.including(all: Author.novels)           // association key \"novels\"\n```\n\n----------------------------------------\n\nTITLE: Implementing FetchableRecord with error handling in Swift\nDESCRIPTION: This example demonstrates how to implement the FetchableRecord protocol with proper error handling for untrusted input, showing how to handle null values and invalid dates.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nstruct LogEntry: FetchableRecord {\n    var date: Date\n    \n    init(row: Row) throws {\n        let dbValue: DatabaseValue = row[\"date\"]\n        if dbValue.isNull {\n            // Handle NULL\n            throw ...\n        } else if let date = Date.fromDatabaseValue(dbValue) {\n            self.date = date\n        } else {\n            // Handle invalid date\n            throw ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Query Interface Method Updates in Swift\nDESCRIPTION: Changes to query interface methods introducing SQLLiteral support and making StatementArguments non-optional with default values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_35\n\nLANGUAGE: swift\nCODE:\n```\nstatic func select<RowDecoder>(literal sqlLiteral: SQLLiteral, as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\nstatic func filter(sql: String, arguments: StatementArguments = StatementArguments()) -> QueryInterfaceRequest<Self>\nstatic func filter(literal sqlLiteral: SQLLiteral) -> QueryInterfaceRequest<Self>\n```\n\n----------------------------------------\n\nTITLE: Implementing Cross-Process Database Observation with GRDB.swift\nDESCRIPTION: Sets up DatabaseRegionObservation to track changes to the database and trigger notifications to other processes. Shows examples for tracking the entire database or specific tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// Notify all changes made to the database\nlet observation = DatabaseRegionObservation(tracking: .fullDatabase)\nlet observer = try observation.start(in: dbPool) { db in\n    // Notify other processes\n}\n\n// Notify changes made to the \"player\" and \"team\" tables only\nlet observation = DatabaseRegionObservation(tracking: Player.all(), Team.all())\nlet observer = try observation.start(in: dbPool) { db in\n    // Notify other processes\n}\n```\n\n----------------------------------------\n\nTITLE: Using Distinct with Associations in GRDB.swift\nDESCRIPTION: Shows how to use the distinct() method with associations to fetch unique values. This example fetches all authors with the distinct kinds of books they write.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_65\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var bookKinds: Set<Book.Kind>\n}\n\nlet distinctBookKinds = Author.books\n    .select(Column(\"kind\"))\n    .distinct()\n    .forKey(\"bookKinds\")\n\nlet authorInfos: [AuthorInfo] = try Author\n    .including(all: distinctBookKinds)\n    .asRequest(of: AuthorInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Defining Basic CTE with Query Interface\nDESCRIPTION: Creates a Common Table Expression named 'playerName' that selects the name column from the player table using GRDB's query interface.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nlet playerNameCTE = CommonTableExpression(\n    named: \"playerName\", \n    request: Player.select(Column(\"name\")))\n```\n\n----------------------------------------\n\nTITLE: Handling Database Interruption Errors in Swift\nDESCRIPTION: Demonstrates the flow control and error handling when a database operation is interrupted. Shows examples of how SQLITE_INTERRUPT and SQLITE_ABORT errors propagate through transaction blocks.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_199\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try Player(...).insert(db)     // throws SQLITE_INTERRUPT\n    try Player(...).insert(db)     // not executed\n}                                  // throws SQLITE_INTERRUPT\n\ntry dbQueue.write { db in\n    do {\n        try Player(...).insert(db) // throws SQLITE_INTERRUPT\n    } catch { }\n}                                  // throws SQLITE_ABORT\n\ntry dbQueue.write { db in\n    do {\n        try Player(...).insert(db) // throws SQLITE_INTERRUPT\n    } catch { }\n    try Player(...).insert(db)     // throws SQLITE_ABORT\n}                                  // throws SQLITE_ABORT\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific Columns from Selection in GRDB Swift\nDESCRIPTION: Shows how to select all columns except for specific ones using the allColumns(excluding:) selector. This is useful when you want to omit generated or computed columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_150\n\nLANGUAGE: swift\nCODE:\n```\n// Select all but a few columns\nstruct Player : TableRecord {\n    static var databaseSelection: [any SQLSelectable] { \n        [.allColumns(excluding: [\"generatedColumn\"])]\n    }\n}\n\n// SELECT id, name FROM player\nlet request = RestrictedPlayer.all()\n```\n\n----------------------------------------\n\nTITLE: Initializing DatabasePool in Swift\nDESCRIPTION: Creates a new DatabasePool instance with a path to an SQLite database file. The database file will be created if it doesn't exist.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabasePool.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport GRDB\n\nlet dbPool = try DatabasePool(path: \"/path/to/database.sqlite\")\n```\n\n----------------------------------------\n\nTITLE: Creating Request Methods that Use Associations in GRDB\nDESCRIPTION: Example showing how to define request methods that leverage associations. The method filters books by the country code of their authors, demonstrating how to join tables in a type-safe manner.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nextension DerivableRequest<Book> {\n    /// Filters books from a country\n    func filter(authorCountryCode countryCode: String) -> Self {\n        // Books do not have any country column. But their author has one!\n        // Return books that can be joined to an author from this country:\n        joining(required: Book.author.filter(countryCode: countryCode))\n    }\n}\n\n// Fetch all Italian novels\ntry dbQueue.read { db in\n    let italianNovels: [Book] = try Book.all()\n        .filter(kind: .novel)\n        .filter(authorCountryCode: \"IT\")\n        .fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Monitoring SQL Statement Duration in GRDB.swift\nDESCRIPTION: Shows how to track and monitor the execution duration of SQL statements using the trace method with profile option.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_224\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.trace(options: .profile) { event in\n        // Prints all SQL statements with their duration\n        print(event)\n        \n        // Access to detailed profiling information\n        if case let .profile(statement, duration) = event, duration > 0.5 {\n            print(\"Slow query: \\(statement.sql)\")\n        }\n    }\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n\ntry dbQueue.read { db in\n    let players = try Player.filter(Column(\"email\") == \"arthur@example.com\").fetchAll(db)\n    // Prints \"0.003s SELECT * FROM player WHERE email = ?\"\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Row Columns in GRDB.swift\nDESCRIPTION: Shows how to iterate through all columns and values in a row using standard Swift collection iteration. This treats the row as a collection of column name and value pairs.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_30\n\nLANGUAGE: swift\nCODE:\n```\n// All the (columnName, dbValue) tuples, from left to right:\nfor (columnName, dbValue) in row {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Interpolating SQL Literals in SQL Queries (Swift)\nDESCRIPTION: This snippet shows how to interpolate SQL literals into SQL queries. It demonstrates using a condition as a SQL literal.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_27\n\nLANGUAGE: Swift\nCODE:\n```\n// SELECT * FROM player WHERE name = 'O''Brien'\nlet condition: SQL = \"name = \\(\"O'Brien\")\"\n\"SELECT * FROM player WHERE \\(literal: condition)\"\n```\n\n----------------------------------------\n\nTITLE: Starting Requests from TableRecord Types in GRDB\nDESCRIPTION: Demonstrates creating a request from a type that adopts the TableRecord protocol. Shows how to fetch all players from the database using the record type's all() method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_120\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: TableRecord { ... }\n\n// The request for all players:\nlet request = Player.all()\nlet players = try request.fetchAll(db) // [Player]\n```\n\n----------------------------------------\n\nTITLE: Configuring Identifiable Record Types with Non-Conventional Primary Key Names in Swift\nDESCRIPTION: Shows how to configure Identifiable record types when primary key columns don't follow the recommended 'id' naming convention. Provides two approaches: custom CodingKeys or an extra computed property.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// Custom coding keys\nstruct Player: Codable, Identifiable {\n    var id: String\n    var name: String\n\n    // Required CodingKeys customization because \n    // columns are not named like Swift properties\n    enum CodingKeys: String, CodingKey {\n        case id = \"uuid\", name\n    }\n}\n\n// Extra property\nstruct Player: Identifiable {\n    var uuid: String\n    var name: String\n    \n    // Required because the primary key column is not 'id'\n    var id: String { uuid }\n}\n```\n\n----------------------------------------\n\nTITLE: Using annotated(withOptional:) for Simple Joins\nDESCRIPTION: Demonstrates a simpler way to fetch books with specific author columns without creating partial types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_37\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book\n    var country: String?\n}\nlet bookInfos = try Book\n    .annotated(withOptional: Book.author.select(Column(\"country\")))\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: SQL Subquery Example in Swift\nDESCRIPTION: Demonstrates how to use requests as subqueries both with the query interface and raw SQL in GRDB.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_15\n\nLANGUAGE: Swift\nCODE:\n```\n// Define a request with the query interface or raw SQL\nlet maximumScore = Player.select(max(Column(\"score\")))\nlet maximumScore: SQLRequest<Int> = \"SELECT MAX(score) FROM player\"\n\n// Use the request as a subquery in the query interface\nlet request = Player.filter(Column(\"score\") == maximumScore)\nlet bestPlayers = try request.fetchAll(db)\n\n// Use the request as a subquery in SQL requests\nlet request: SQLRequest<Player> = \"SELECT * FROM player WHERE score = (\\(maximumScore))\"\nlet bestPlayers = try request.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Incrementing Player Count with DatabasePool Write in Swift\nDESCRIPTION: This example shows how to increment the number of players and then read the updated count within a write operation. It demonstrates that this approach blocks concurrent writes during the read operation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nlet newPlayerCount = try dbPool.write { db in\n    // Increment the number of players\n    try Player(...).insert(db)\n    \n    // Read the number of players. Concurrent writes are blocked :-(\n    return try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Read and Write Operations with DatabaseQueue in Swift\nDESCRIPTION: Examples of how to read from and write to a database using the synchronous read and write methods. These methods block the current thread until database statements are executed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseQueue.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// Modify the database:\ntry dbQueue.write { db in\n    try Player(name: \"Arthur\").insert(db)\n}\n\n// Read values:\ntry dbQueue.read { db in\n    let players = try Player.fetchAll(db)\n    let playerCount = try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Table Creation Options in GRDB.swift\nDESCRIPTION: Shows how to create tables with additional options like temporary tables and conditional creation using IF NOT EXISTS.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE TABLE player ( ... )\ntry db.create(table: \"player\") { t in ... }\n    \n// CREATE TEMPORARY TABLE player IF NOT EXISTS (\ntry db.create(table: \"player\", options: [.temporary, .ifNotExists]) { t in ... }\n```\n\n----------------------------------------\n\nTITLE: Creating Rows from Dictionaries in GRDB.swift\nDESCRIPTION: Demonstrates how to create Row instances from Swift dictionaries. This allows for constructing custom rows for testing or data manipulation purposes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_31\n\nLANGUAGE: swift\nCODE:\n```\nlet row: Row = [\"name\": \"foo\", \"date\": nil]\nlet row = Row([\"name\": \"foo\", \"date\": nil])\nlet row = Row(/* [AnyHashable: Any] */) // nil if invalid dictionary\n```\n\n----------------------------------------\n\nTITLE: Fetching Optional Partial Associated Records with including(optional:) in Swift\nDESCRIPTION: This snippet demonstrates fetching a book with an optional partial associated author record. It uses a nested PartialAuthor struct to define specific author fields to be optionally fetched.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_46\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    struct PartialAuthor: Decodable {\n        var name: String\n        var country: String\n    }\n    var book: Book             // The base record\n    var author: PartialAuthor? // The eventual partial associated record\n}\n\nlet bookInfos = try Book\n    .including(optional: Book.author.select(Column(\"name\"), Column(\"country\")))\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Deleting All Records Using TableMapping Protocol in Swift\nDESCRIPTION: Demonstrates how to delete all records of a type conforming to TableMapping protocol using the new deleteAll method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_98\n\nLANGUAGE: swift\nCODE:\n```\ntry Person.deleteAll(db)\n```\n\n----------------------------------------\n\nTITLE: Catching Database Interruption Errors in Swift\nDESCRIPTION: Shows how to properly catch both SQLITE_INTERRUPT and SQLITE_ABORT errors that can result from interrupting database operations. This pattern helps handle database interruptions gracefully.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_200\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try dbPool.write { db in ... }\n} catch DatabaseError.SQLITE_INTERRUPT, DatabaseError.SQLITE_ABORT {\n    // Oops, the database was interrupted.\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Authors Based on Book Existence in Swift\nDESCRIPTION: Demonstrates how to use the isEmpty aggregate to filter authors based on whether they have written books or not. The examples show fetching authors with no books and authors with at least one book.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_89\n\nLANGUAGE: swift\nCODE:\n```\nlet lazyAuthors = try Author\n    .having(Author.books.isEmpty)\n    .fetchAll(db) // [Author]\n\nlet productiveAuthors: [Author] = try Author\n    .having(Author.books.isEmpty == false)\n    .fetchAll(db) // [Author]\n```\n\n----------------------------------------\n\nTITLE: Optimizing DatabaseValueConvertible with StatementColumnConvertible in Swift\nDESCRIPTION: This example shows how to optimize performance by conforming to both DatabaseValueConvertible and StatementColumnConvertible. It provides raw access to the low-level C SQLite interface for decoding values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseValueConvertible.md#2025-04-22_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\nextension EvenInteger: StatementColumnConvertible {\n    init?(sqliteStatement: SQLiteStatement, index: CInt) {\n        let int64 = sqlite3_column_int64(sqliteStatement, index)\n        guard let value = Int(exactly: int64) else {\n            return nil // Does not fit Int (probably a 32-bit architecture)\n        }\n        self.init(value) // Nil if not even\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Literary Careers with Included Books Using GRDB\nDESCRIPTION: Example showing how to fetch authors with all their books in a single query. A LiteraryCareer type models this graph of objects, and the including method is used to eagerly load the books for each author.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n// Fetch the literary careers of German authors, sorted by name\nstruct LiteraryCareer: Codable, FetchableRecord {\n    var author: Author\n    var books: [Book]\n}\nlet careers: [LiteraryCareer] = try dbQueue.read { db in\n    try Author\n        .filter(countryCode: \"DE\")\n        .orderByName()\n        .including(all: Author.books)\n        .asRequest(of: LiteraryCareer.self)\n        .fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Foreign Key Definition in GRDB\nDESCRIPTION: Demonstrates how to manually define foreign keys when automatic inference is not possible or ambiguous.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_31\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n    static let authorForeignKey = ForeignKey([\"authorId\"])\n    static let translatorForeignKey = ForeignKey([\"translatorId\"])\n    \n    static let author = belongsTo(Person.self, using: authorForeignKey)\n    static let translator = belongsTo(Person.self, using: translatorForeignKey)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking View Existence in GRDB.swift\nDESCRIPTION: This method checks if a specific view exists in the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_3\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/viewExists(_:in:)\n```\n\n----------------------------------------\n\nTITLE: Printing SQL Query from Request in GRDB\nDESCRIPTION: Demonstrates how to inspect the SQL query and arguments of any GRDB request using the asSQLRequest method. This feature was introduced in version 2.1.0.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_57\n\nLANGUAGE: Swift\nCODE:\n```\nlet request = Player.all()\nlet sql = try request.asSQLRequest(db).sql\nprint(sql) // Prints \"SELECT * FROM players\"\n```\n\n----------------------------------------\n\nTITLE: BETWEEN, IN, NOT IN Operators in GRDB.swift\nDESCRIPTION: Examples of checking inclusion in a Swift sequence (array, set, range) and in subqueries using the contains method, which translates to SQL BETWEEN, IN, and NOT IN operators.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_157\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE id IN (1, 2, 3)\nPlayer.filter([1, 2, 3].contains(idColumn))\n\n// SELECT * FROM player WHERE id NOT IN (1, 2, 3)\nPlayer.filter(![1, 2, 3].contains(idColumn))\n\n// SELECT * FROM player WHERE score BETWEEN 0 AND 1000\nPlayer.filter((0...1000).contains(scoreColumn))\n\n// SELECT * FROM player WHERE (score >= 0) AND (score < 1000)\nPlayer.filter((0..<1000).contains(scoreColumn))\n\n// SELECT * FROM player WHERE initial BETWEEN 'A' AND 'N'\nPlayer.filter((\"A\"...\"N\").contains(initialColumn))\n\n// SELECT * FROM player WHERE (initial >= 'A') AND (initial < 'N')\nPlayer.filter((\"A\"...<\"N\").contains(initialColumn))\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE id IN (SELECT playerId FROM playerSelection)\nlet selectedPlayerIds = PlayerSelection.select(playerIdColumn)\nPlayer.filter(selectedPlayerIds.contains(idColumn))\n\n// SELECT * FROM player WHERE id IN (SELECT playerId FROM playerSelection)\nlet selectedPlayerIds = SQLRequest(\"SELECT playerId FROM playerSelection\")\nPlayer.filter(selectedPlayerIds.contains(idColumn))\n```\n\nLANGUAGE: swift\nCODE:\n```\n// WITH selectedName AS (...)\n// SELECT * FROM player WHERE name IN selectedName\nlet cte = CommonTableExpression(named: \"selectedName\", ...)\nPlayer\n    .with(cte)\n    .filter(cte.contains(nameColumn))\n```\n\n----------------------------------------\n\nTITLE: Checking Unique Key in GRDB.swift\nDESCRIPTION: This method checks if a table has a unique key with specified columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_8\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/table(_:hasUniqueKey:)\n```\n\n----------------------------------------\n\nTITLE: Defining Flexible JSON Schema with String in Swift\nDESCRIPTION: This snippet demonstrates how to define a flexible JSON schema using a String property in Swift. The 'address' property is defined as a String, which can contain any valid JSON.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/JSON.md#2025-04-22_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Player: Codable {\n    var id: String\n    var name: String\n    var address: String // JSON string\n}\n\nextension Player: FetchableRecord, PersistableRecord { }\n```\n\n----------------------------------------\n\nTITLE: Defining BookInfo Record Type for Optional Author\nDESCRIPTION: Shows how to define a record type to decode books with their optional authors.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_35\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book      // The base record\n    var author: Author? // The optional associated record\n}\nlet bookInfos = try Book\n    .including(optional: Book.author)\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Synchronous Database Access with GRDB in Swift\nDESCRIPTION: Demonstrates synchronous database access that blocks the current thread until completion. The example shows how to count players and insert a new player in a write transaction.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet playerCount = try dbQueue.read { db in\n    try Player.fetchCount(db)\n}\n\nlet newPlayerCount = try dbQueue.write { db -> Int in\n    try Player(name: \"Arthur\").insert(db)\n    return try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operations in GRDB.swift\nDESCRIPTION: Example of using bitwise operators (&, |, ~, <<, >>) in GRDB, which are derived from their Swift equivalents for performing bitwise operations in SQL queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_154\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT mask & 2 AS isRocky FROM planet\nPlanet.select((Column(\"mask\") & 2).forKey(\"isRocky\"))\n```\n\n----------------------------------------\n\nTITLE: Updating EncodableRecord.encode(to:) to throw errors in Swift\nDESCRIPTION: This snippet illustrates how to update the EncodableRecord encode method to throw errors, which is now required in the new version of GRDB.swift. It also shows changes to related APIs that now throw errors.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n class Player: Record {\n-    override func encode(to container: inout PersistenceContainer) {\n+    override func encode(to container: inout PersistenceContainer) throws {\n         container[\"id\"] = id\n         container[\"name\"] = name\n     }\n }\n```\n\nLANGUAGE: diff\nCODE:\n```\n-let dictionary = player.databaseDictionary\n-let changes = newPlayer.databaseChanges(from: oldPlayer)\n-let changes = player.databaseChanges // Record class only\n+let dictionary = try player.databaseDictionary\n+let changes = try newPlayer.databaseChanges(from: oldPlayer)\n+let changes = try player.databaseChanges // Record class only\n```\n\n----------------------------------------\n\nTITLE: Request Type Conversion Example\nDESCRIPTION: Shows how to convert request types using asRequest(of:) method, particularly useful when working with associations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_186\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var author: Author\n}\n\nlet request = Book\n    .including(required: Book.author)\n    .asRequest(of: BookInfo.self)\n\n// [BookInfo]\ntry request.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Fetching Optional Associated Records with including(optional:) in Swift\nDESCRIPTION: This example shows how to use including(optional:) to fetch a book with its optional associated author. The Author property is declared as optional to handle cases where a book might not have an author.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_45\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book      // The base record\n    var author: Author? // The eventual associated record\n}\n\nlet bookInfos = try Book\n    .including(optional: Book.author)\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Converting ValueObservation to Combine Publisher in Swift\nDESCRIPTION: Shows how to convert a ValueObservation to a Combine Publisher for integration with Combine-based reactive code, using the publisher method and sink to receive values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet cancellable = observation.publisher(in: dbQueue).sink { completion in\n    // Handle completion\n} receiveValue: { (players: [Player]) in\n    print(\"Fresh players\", players)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Specific Columns from All Associated Records with including(all:) in Swift\nDESCRIPTION: This snippet shows how to fetch an author with a specific column (title) from all associated books. It demonstrates how to fetch a collection of a single column from associated records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_50\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author       // The base record\n    var bookTitles: [String] // A collection of one column of the associated records\n}\n\nlet authorInfos = try Author\n    .including(all: Author.books\n        .select(Column(\"title\"))\n        .forKey(\"bookTitles\"))\n    .asRequest(of: AuthorInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite Error Logging in GRDB.swift\nDESCRIPTION: Shows how to set up a global error callback function for SQLite that gets called whenever database anomalies occur.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_210\n\nLANGUAGE: swift\nCODE:\n```\nDatabase.logError = { (resultCode, message) in\n    NSLog(\"%@\", \"SQLite error \\(resultCode): \\(message)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Interpolating Subqueries in SQL Queries (Swift)\nDESCRIPTION: This snippet shows how to interpolate subqueries into SQL queries. It demonstrates using both raw SQL and query interface subqueries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_25\n\nLANGUAGE: Swift\nCODE:\n```\n// SELECT * FROM player WHERE score = (SELECT MAX(score) FROM player)\nlet subquery = SQLRequest(\"SELECT MAX(score) FROM player\")\n\"SELECT * FROM player WHERE score = (\\(subquery))\"\n\n// SELECT * FROM player WHERE score = (SELECT MAX(score) FROM player)\nlet subquery = Player.select(max(Column(\"score\")))\n\"SELECT * FROM player WHERE score = (\\(subquery))\"\n```\n\n----------------------------------------\n\nTITLE: Annotating Selections with Expressions in GRDB\nDESCRIPTION: Shows how to extend a selection with computed expressions using the annotated(with:) method. This example adds a calculated 'total' column that combines score and bonus values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_126\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT *, (score + bonus) AS total FROM player\nPlayer.annotated(with: (scoreColumn + bonusColumn).forKey(\"total\"))\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching DatabaseError by Result Code\nDESCRIPTION: Techniques for catching specific SQLite error types by matching on result codes using Swift pattern matching.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_206\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try ...\n} catch let error as DatabaseError {\n    switch error {\n    case DatabaseError.SQLITE_CONSTRAINT_FOREIGNKEY:\n        // foreign key constraint error\n    case DatabaseError.SQLITE_CONSTRAINT:\n        // any other constraint error\n    default:\n        // any other database error\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Place Struct in Swift\nDESCRIPTION: This code snippet demonstrates how to define a basic struct representing a Place with properties for id, title, and coordinate.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place {\n    var id: Int64?\n    let title: String\n    let coordinate: CLLocationCoordinate2D\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Indices on Expressions in GRDB.swift\nDESCRIPTION: Demonstrates creating indices on expressions, including arithmetic operations and JSON extraction, which can improve performance for complex queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE INDEX index_player_on_total_score ON player(score+bonus)\ntry db.create(\n    index: \"index_player_on_total_score\",\n    on: \"player\",\n    expressions: [Column(\"score\") + Column(\"bonus\")])\n\n// CREATE INDEX index_player_on_country ON player(address ->> 'country')\ntry db.create(\n    index: \"index_player_on_country\",\n    on: \"player\",\n    expressions: [\n        JSONColumn(\"address\")[\"country\"],\n    ])\n```\n\n----------------------------------------\n\nTITLE: Filtering Multiple Associations in GRDB.swift\nDESCRIPTION: This snippet shows how to filter multiple associations to fetch authors along with their novels and poems separately.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_56\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author\n    .including(all: Author.book\n        .filter(Column(\"kind\") == \"novel\")\n        .forKey(\"novels\"))\n    .including(all: Author.book\n        .filter(Column(\"kind\") == \"poems\")\n        .forKey(\"poems\"))\n\n// This request can feed the following record:\nstruct AuthorInfo: FetchableRecord, Decodable {\n    var author: Author\n    var novels: [Book]\n    var poems: [Book]\n}\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Configuring Record Types with Non-Conventional Table Names in Swift\nDESCRIPTION: Shows how to configure record types when table names don't follow the recommended naming conventions. This requires explicit table name declarations in record type extensions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: TableRecord {\n    // Required because table name is not 'player'\n    static let databaseTableName = \"players\"\n}\n\nextension PostalAddress: TableRecord {\n    // Required because table name is not 'postalAddress'\n    static let databaseTableName = \"postal_address\"\n}\n\nextension Award: TableRecord {\n    // Required because table name is not 'award'\n    static let databaseTableName = \"Auszeichnung\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Publishers from SharedValueObservation\nDESCRIPTION: Creates a publisher from a SharedValueObservation that tracks database value changes. This approach allows multiple subscribers to share the same observation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nlet sharedObservation = ValueObservation\n    .tracking { db in try Player.fetchAll(db) }\n    .shared(in: dbQueue)\n\n// A publisher with output [Player] and failure Error\nlet publisher = sharedObservation.publisher()\n```\n\n----------------------------------------\n\nTITLE: Filtering Authors with Multiple Books in Swift\nDESCRIPTION: Shows how to filter authors based on book count thresholds, specifically finding authors who wrote at least two books.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_96\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author.having(Author.books.count >= 2)\n```\n\n----------------------------------------\n\nTITLE: Adding Table Constraints in GRDB.swift\nDESCRIPTION: Demonstrates how to add various table-level constraints including primary keys, unique keys, foreign keys, and check constraints across multiple columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n    // PRIMARY KEY (a, b),\n    t.primaryKey([\"a\", \"b\"])\n    \n    // UNIQUE (a, b) ON CONFLICT REPLACE,\n    t.uniqueKey([\"a\", \"b\"], onConflict: .replace)\n    \n    // FOREIGN KEY (a, b) REFERENCES parents(c, d),\n    t.foreignKey([\"a\", \"b\"], references: \"parents\")\n    \n    // CHECK (a + b < 10),\n    t.check(Column(\"a\") + Column(\"b\") < 10)\n    \n    // CHECK (a + b < 10)\n    t.check(sql: \"a + b < 10\")\n    \n    // Raw SQL constraints\n    t.constraint(sql: \"CHECK (a + b < 10)\")\n    t.constraint(literal: \"CHECK (a + b < \\(10))\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor Protocol and Related Classes in Swift\nDESCRIPTION: Introduces the Cursor protocol and related classes to replace DatabaseSequence. Adds extensions to Array and various cursor types. Implements methods for cursor manipulation like filtering, mapping, and flattening.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_97\n\nLANGUAGE: Swift\nCODE:\n```\n-struct DatabaseSequence<Element>: Sequence\n-final class DatabaseIterator<Element>: IteratorProtocol\n\n+extension Array {\n+    init<C : Cursor>(_ cursor: C) throws where C.Element == Element\n+}\n\n+class AnyCursor<Element> : Cursor {\n+    init<C : Cursor>(_ base: C) where C.Element == Element\n+    init(_ body: @escaping () throws -> Element?)\n+}\n\n+protocol Cursor : class {\n+    associatedtype Element\n+    func next() throws -> Element?\n+}\n\n+extension Cursor {\n+    func contains(where predicate: (Element) throws -> Bool) throws -> Bool\n+    func enumerated() -> EnumeratedCursor<Self>\n+    func filter(_ isIncluded: @escaping (Element) throws -> Bool) -> FilterCursor<Self>\n+    func first(where predicate: (Element) throws -> Bool) throws -> Element?\n+    func flatMap<ElementOfResult>(_ transform: @escaping (Element) throws -> ElementOfResult?) -> MapCursor<FilterCursor<MapCursor<Self, ElementOfResult?>>, ElementOfResult>\n+    func flatMap<SegmentOfResult : Sequence>(_ transform: @escaping (Element) throws -> SegmentOfResult) -> FlattenCursor<MapCursor<Self, IteratorCursor<SegmentOfResult.Iterator>>>\n+    func flatMap<SegmentOfResult : Cursor>(_ transform: @escaping (Element) throws -> SegmentOfResult) -> FlattenCursor<MapCursor<Self, SegmentOfResult>>\n+    func forEach(_ body: (Element) throws -> Void) throws\n+    func map<T>(_ transform: @escaping (Element) throws -> T) -> MapCursor<Self, T>\n+    func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) throws -> Result\n+}\n\n+extension Cursor where Element: Equatable {\n+    func contains(_ element: Element) throws -> Bool\n+}\n\n+extension Cursor where Element: Cursor {\n+    func joined() -> FlattenCursor<Self>\n+}\n\n+extension Cursor where Element: Sequence {\n+    func joined() -> FlattenCursor<MapCursor<Self, IteratorCursor<Self.Element.Iterator>>>\n+}\n\n+final class DatabaseCursor<Element> : Cursor\n+final class EnumeratedCursor<Base : Cursor> : Cursor\n+final class FilterCursor<Base : Cursor> : Cursor\n+final class FlattenCursor<Base: Cursor> : Cursor where Base.Element: Cursor\n+final class MapCursor<Base : Cursor, Element> : Cursor\n+final class IteratorCursor<Base : IteratorProtocol> : Cursor {\n+    init(_ base: Base)\n+    init<S : Sequence>(_ s: S) where S.Iterator == Base\n+}\n\n+extension Sequence {\n+    func flatMap<SegmentOfResult : Cursor>(_ transform: @escaping (Iterator.Element) throws -> SegmentOfResult) -> FlattenCursor<MapCursor<IteratorCursor<Self.Iterator>, SegmentOfResult>>\n+}\n```\n\n----------------------------------------\n\nTITLE: Fetching All Associated Records with including(all:) in Swift\nDESCRIPTION: This snippet demonstrates how to use including(all:) to fetch an author along with all of their associated books. It's useful for one-to-many relationships.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_48\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author // The base record\n    var books: [Book]  // A collection of associated records\n}\n\nlet authorInfos = try Author\n    .including(all: Author.books)\n    .asRequest(of: AuthorInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Using Identifiable Protocol with Record Types\nDESCRIPTION: Demonstrates how record types that adopt Swift's Identifiable protocol can use type-safe methods for interacting with the database using their primary key, simplifying common database operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nlet player = try Player.fetchOne(db, id: 42)\ntry Player.deleteAll(db, ids: [1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Fetching Partial Associated Records with including(required:) in Swift\nDESCRIPTION: This example shows how to fetch a book with a partial associated author record. It uses a nested PartialAuthor struct to define the specific author fields to be fetched.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_43\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    struct PartialAuthor: Decodable {\n        var name: String\n        var country: String\n    }\n    var book: Book            // The base record\n    var author: PartialAuthor // The partial associated record\n}\n\nlet bookInfos = try Book\n    .including(required: Book.author.select(Column(\"name\"), Column(\"country\")))\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom SQL Function with Database Configuration\nDESCRIPTION: Shows how to register a custom function with a database connection through the configuration object, making it available for use in SQL queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_49\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.add(function: reverse)\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n\ntry dbQueue.read { db in\n    // \"oof\"\n    try String.fetchOne(db, sql: \"SELECT reverse('foo')\")!\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Generated Columns in GRDB.swift\nDESCRIPTION: Shows how to create generated columns that compute values based on other columns, using both raw SQL expressions and Swift column references.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n    t.column(\"totalScore\", .integer).generatedAs(sql: \"score + bonus\")\n    t.column(\"totalScore\", .integer).generatedAs(Column(\"score\") + Column(\"bonus\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Coalesce Method for Fallback Values in GRDB.swift\nDESCRIPTION: Shows how to properly handle fallback values when a column might be missing. The coalesce method attempts to read from columns in order until it finds a non-nil value.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_26\n\nLANGUAGE: swift\nCODE:\n```\nlet name: String? = row.coalesce([\"nickname\", \"name\"]) // GOOD\n```\n\n----------------------------------------\n\nTITLE: Creating a Record Structure for Joined Request with Optional Associations in GRDB.swift\nDESCRIPTION: Demonstrates how to define a record structure that properly handles null values from optional associations. This example shows how nullable database values map to Swift optionals.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_86\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var author: Author          // .including(required: Book.author)\n    var country: Country?       // .including(optional: Author.country)\n    var coverImage: CoverImage? // .including(optional: Book.coverImage)\n    var prizes: [Prize]         // .including(all: Book.prizes)\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Foreign Key Constraints in GRDB Migrations\nDESCRIPTION: Demonstrates a migration pattern that temporarily violates foreign key constraints before fixing them. In GRDB 4.11.0, foreign key checks are deferred until the end of each migration.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\n// Used to fail, now succeeds\nmigrator.registerMigration(...) { db in\n    try violateForeignKeyConstraint(db)\n    try fixForeignKeyConstraint(db)\n}\n\n// The catch clause is no longer called\nmigrator.registerMigration(...) { db in\n    do {\n        try performChanges(db)\n    } catch let error as DatabaseError where error.resultCode == .SQL_CONSTRAINT {\n        // Handle foreign key error\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Data Protection Errors in GRDB.swift\nDESCRIPTION: Shows how to catch and handle SQLite disk I/O or authorization errors that may occur due to iOS data protection when the device is locked. This pattern allows graceful recovery when database access is restricted.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_235\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try ...\n} catch DatabaseError.SQLITE_IOERR, DatabaseError.SQLITE_AUTH {\n    // Handle possible data protection error\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom SQLite Aggregate Functions\nDESCRIPTION: Demonstrates how to create a custom aggregate function using the DatabaseAggregate protocol which can calculate a sum of integers.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_81\n\nLANGUAGE: swift\nCODE:\n```\nstruct MySum : DatabaseAggregate {\n    var sum: Int = 0\n    \n    mutating func step(_ dbValues: [DatabaseValue]) {\n        if let int = Int.fromDatabaseValue(dbValues[0]) {\n            sum += int\n        }\n    }\n    \n    func finalize() -> DatabaseValueConvertible? {\n        return sum\n    }\n}\n\nlet dbQueue = DatabaseQueue()\nlet fn = DatabaseFunction(\"mysum\", argumentCount: 1, aggregate: MySum.self)\ndbQueue.add(function: fn)\ntry dbQueue.inDatabase { db in\n    try db.execute(\"CREATE TABLE test(i)\")\n    try db.execute(\"INSERT INTO test(i) VALUES (1)\")\n    try db.execute(\"INSERT INTO test(i) VALUES (2)\")\n    try Int.fetchOne(db, \"SELECT mysum(i) FROM test\")! // 3\n}\n```\n\n----------------------------------------\n\nTITLE: Using Raw SQL in Table Creation DSL\nDESCRIPTION: Shows how to use raw SQL strings or SQL literals when defining columns and constraints in the table creation DSL, allowing for more complex column definitions and constraints.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"player\") do { t in\n    t.column(sql: \"id INTEGER PRIMARY KEY AUTOINCREMENT\")\n    t.column(literal: \"name TEXT DEFAULT \\(\"Anonymous\")\")\n    t.constraint(sql: \"CHECK (LENGTH(name) > 0)\")\n    t.constraint(literal: \"CHECK (LENGTH(name) <= \\(100))\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Distinct for Unique Results in GRDB\nDESCRIPTION: Shows how to use the distinct() method to eliminate duplicate values from query results, returning only unique values for the selected columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_129\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT DISTINCT name FROM player\nPlayer.select(nameColumn, as: String.self).distinct()\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple SQL Statements in Swift\nDESCRIPTION: Shows how to handle multiple SQL statements in a single string, including execution and cursor-based result processing.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/Statement.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet statements = try db.allStatements(sql: \"\"\"\n    INSERT INTO player (name, score) VALUES (?, ?);\n    INSERT INTO player (name, score) VALUES (?, ?);\n    \"\"\", arguments: [\"Arthur\", 100, \"O'Brien\", 1000])\nwhile let statement = try statements.next() {\n    try statement.execute()\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Foreign Keys with Detailed Error Reporting in Swift\nDESCRIPTION: Demonstrates how to check for foreign key violations with the Database.checkForeignKeys method, which throws a detailed DatabaseError containing debugging information about any violations found.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n// SQLite error 19: FOREIGN KEY constraint violation - from book(authorId) to author(id),\n// in [id:1 authorId:2 name:\"Moby-Dick\"]\ntry db.checkForeignKeys(in: \"book\")\n```\n\n----------------------------------------\n\nTITLE: Creating Ordered HasMany Associations in GRDB.swift\nDESCRIPTION: Shows how to define a HasMany association that is ordered by default. This example creates a Team.players association that automatically orders players by their position field.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_60\n\nLANGUAGE: swift\nCODE:\n```\nextension Team {\n    static let players = hasMany(Player.self).order(Column(\"position\"))\n    \n    var players: QueryInterfaceRequest<Player> {\n        request(for: Team.players)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Tables with Unique Constraints and Indexes in Swift\nDESCRIPTION: Demonstrates how to implement unique constraints on columns via unique indexes, which allow SQLite to prevent insertion of conflicting rows. Shows both inline unique constraints and separate unique indexes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n// RECOMMENDED\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.belongsTo(\"team\").notNull()\n    t.column(\"position\", .integer).notNull()\n    // Players must have distinct names\n    t.column(\"name\", .text).unique()\n}\n\n// One single player at any given position in a team\ntry db.create(\n    indexOn: \"player\",\n    columns: [\"teamId\", \"position\"],\n    options: .unique)\n```\n\n----------------------------------------\n\nTITLE: Defining FetchRequest Protocol in Swift\nDESCRIPTION: Protocol definition for FetchRequest which enables database fetching operations with associated RowDecoder types for interpreting results.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nprotocol FetchRequest<RowDecoder>: SQLSubqueryable, DatabaseRegionConvertible {\n    /// The type that tells how fetched database rows should be interpreted.\n    associatedtype RowDecoder\n    \n    /// Returns a PreparedRequest that is ready to be executed.\n    func makePreparedRequest(_ db: Database, forSingleResult singleResult: Bool) throws -> PreparedRequest\n    \n    /// Returns the number of rows fetched by the request.\n    func fetchCount(_ db: Database) throws -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Database with GRDB and Combine\nDESCRIPTION: Creates a publisher that performs database migration operations. This example uses a DatabaseMigrator to migrate the database through a publisher.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n// DatabasePublishers.Migrate\nlet migrator: DatabaseMigrator = ...\nlet publisher = migrator.migratePublisher(dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Specifying Database Column Selection for Records in GRDB\nDESCRIPTION: Demonstrates how to specify which columns a record type selects from the database using the databaseSelection property. This allows more precise control over SQL queries compared to using SELECT *.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_59\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Player : RowConvertible, TableMapping {\n    let id: Int64\n    let name: String\n    \n    enum Columns {\n        static let id = Column(\"id\")\n        static let name = Column(\"name\")\n    }\n    \n    init(row: Row) {\n        id = row[Columns.id]\n        name = row[Columns.name]\n    }\n    \n    static let databaseTableName = \"players\"\n    static let databaseSelection: [SQLSelectable] = [Columns.id, Columns.name]\n}\n\n// SELECT id, name FROM players\nlet players = Player.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Fetching Books with Partial Author Data\nDESCRIPTION: Shows how to fetch books with selected columns from the optional author record.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_36\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    struct PartialAuthor: Decodable {\n        var name: String\n        var country: String\n    }\n    var book: Book\n    var author: PartialAuthor?\n}\nlet bookInfos = try Book\n    .including(optional: Book.author.select(Column(\"name\"), Column(\"country\")))\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Accessing SQL in PreparedRequest in Swift\nDESCRIPTION: Demonstrates how to access the SQL statement from a PreparedRequest generated by a FetchRequest.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.all()\nlet preparedRequest = try request.makePreparedRequest(db)\nprint(preparedRequest.statement.sql) // SELECT * FROM player\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operators in GRDB.swift\nDESCRIPTION: Examples of using arithmetic operators (*, /, +, -) with GRDB, including how to perform calculations on columns and join a sequence of expressions with the + or * operator.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_153\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT ((temperature * 1.8) + 32) AS fahrenheit FROM planet\nPlanet.select((temperatureColumn * 1.8 + 32).forKey(\"fahrenheit\"))\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT score + bonus + 1000 FROM player\nlet values = [\n    scoreColumn,\n    bonusColumn,\n    1000.databaseValue]\nPlayer.select(values.joined(operator: .add))\n```\n\n----------------------------------------\n\nTITLE: Implementing Association Protocols and Extending Association Capabilities in Swift\nDESCRIPTION: Introduces new AssociationToOne and AssociationToMany protocols with support for aggregation functions. These protocols enhance the association system by providing specialized functionality for different association types and extending existing association classes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_29\n\nLANGUAGE: swift\nCODE:\n```\n+protocol AssociationToOne: Association { }\n+protocol AssociationToMany: Association { }\n+extension AssociationToMany {\n+    var count: AssociationAggregate<OriginRowDecoder> { get }\n+    var isEmpty: AssociationAggregate<OriginRowDecoder> { get }\n+    func average(_ expression: SQLExpressible) -> AssociationAggregate<OriginRowDecoder>\n+    func max(_ expression: SQLExpressible) -> AssociationAggregate<OriginRowDecoder>\n+    func min(_ expression: SQLExpressible) -> AssociationAggregate<OriginRowDecoder>\n+    func sum(_ expression: SQLExpressible) -> AssociationAggregate<OriginRowDecoder>\n+}\n\n+extension BelongsToAssociation: AssociationToOne { }\n+extension HasManyAssociation: AssociationToMany { }\n+extension HasOneAssociation: AssociationToOne { }\n```\n\n----------------------------------------\n\nTITLE: Fixing Generic Parameter Inference Error with Database Reads\nDESCRIPTION: Demonstrates how to work around Swift compiler limitations when using database read operations. Shows solutions for the \"Generic parameter 'T' could not be inferred\" error by explicitly declaring return types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_231\n\nLANGUAGE: swift\nCODE:\n```\n// Generic parameter 'T' could not be inferred\nlet string = try dbQueue.read { db in\n    let result = try String.fetchOne(db, ...)\n    return result\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Record Type with encode(to:) Method\nDESCRIPTION: Shows how to implement a Persistable record type using the encode(to:) method, which replaced the persistentDictionary property in GRDB 1.0.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_82\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player : Persistable {\n    let name: String\n    let score: Int\n\n    // Old\n//    var persistentDictionary: [String: DatabaseValueConvertible?] {\n//        return [\n//            \"name\": name,\n//            \"score\": score,\n//        ]\n//    }\n\n    // New\n    func encode(to container: inout PersistenceContainer) {\n        container[\"name\"] = name\n        container[\"score\"] = score\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending QueryInterfaceRequest to Transform Results in GRDB\nDESCRIPTION: Example showing how to extend QueryInterfaceRequest to change the type of returned values. The extension adds a selectName method that returns a request of strings instead of Author records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nextension QueryInterfaceRequest<Author> {\n    // Selects authors' name\n    func selectName() -> QueryInterfaceRequest<String> {\n        select(Author.Columns.name)\n    }\n}\n\n// The names of Japanese authors\nlet names: Set<String> = try Author.all()\n    .filter(countryCode: \"JP\")\n    .selectName()\n    .fetchSet(db)\n```\n\n----------------------------------------\n\nTITLE: Creating Untyped Columns in SQLite Tables\nDESCRIPTION: Demonstrates how to create tables with untyped columns using the enhanced table creation API. Untyped columns behave like columns with NUMERIC type affinity.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_77\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.inDatabase { db in\n    // CREATE TABLE t(a, b)\n    try db.create(table: \"t\") { t in\n        t.column(\"a\")\n        t.column(\"b\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Untyped SQLRequest\nDESCRIPTION: Shows how to create an SQLRequest without specifying a generic qualifier, which defaults to Row as the fetched type, simplifying code for basic SQL queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nlet request = SQLRequest(\"SELECT ...\")\n```\n\n----------------------------------------\n\nTITLE: Getting Database Changes Between Records with databaseChanges in Swift\nDESCRIPTION: Uses the databaseChanges(from:) method to identify differences between two records, returning a dictionary of column names and their previous values. This is useful for tracking specific field changes between record versions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_109\n\nLANGUAGE: swift\nCODE:\n```\nlet oldPlayer = Player(id: 1, name: \"Arthur\", score: 100)\nlet newPlayer = Player(id: 1, name: \"Arthur\", score: 1000)\nfor (column, oldValue) in try newPlayer.databaseChanges(from: oldPlayer) {\n    print(\"\\(column) was \\(oldValue)\")\n}\n// prints \"score was 100\"\n```\n\n----------------------------------------\n\nTITLE: Defining Record Types for Full and Partial Database Interaction\nDESCRIPTION: Shows how to define two record types: one with full database information and another with partial information. This setup enables inserting partial records and retrieving complete records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_85\n\nLANGUAGE: swift\nCODE:\n```\n// A player with full database information\nstruct Player: Codable, PersistableRecord, FetchableRecord {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\n// A partial player\nstruct PartialPlayer: Encodable, PersistableRecord {\n    static let databaseTableName = \"player\"\n    var name: String\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Different Association Counts in Swift\nDESCRIPTION: Demonstrates comparing counts from different associations, specifically finding authors who wrote more books than they made paintings.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_99\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author.having(Author.books.count > Author.paintings.count)\n```\n\n----------------------------------------\n\nTITLE: Creating and Tracking Database Regions with DatabaseRegionObservation in Swift\nDESCRIPTION: This code demonstrates how to create a DatabaseRegionObservation that tracks all changes to the Player table. The observation will monitor any insertions, updates, or deletions affecting the specified region.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseRegionObservation.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// Tracks the full player table\nlet observation = DatabaseRegionObservation(tracking: Player.all())\n```\n\n----------------------------------------\n\nTITLE: Creating Tables with Conventionally Named Primary Keys in Swift\nDESCRIPTION: Demonstrates the recommended convention of naming single-column primary keys as 'id' to simplify integration with Swift's Identifiable protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// RECOMMENDED\ntry db.create(table: \"player\") { t in\n    t.primaryKey(\"id\", .text)\n    t.column(\"name\", .text).notNull()\n}\n\n// REQUIRES EXTRA CONFIGURATION\ntry db.create(table: \"player\") { t in\n    t.primaryKey(\"uuid\", .text)\n    t.column(\"name\", .text).notNull()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Record Subclass from Dictionary in Swift\nDESCRIPTION: Shows how to initialize a Record subclass using a dictionary, a feature added in version 0.21.0 for types conforming to RowConvertible and Record protocols.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_123\n\nLANGUAGE: Swift\nCODE:\n```\nclass Person: Record { ... }\nlet person = Person(dictionary: [\"name\": \"Arthur\", \"birthDate\": nil])\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Transaction Observer\nDESCRIPTION: Demonstrates error propagation when errors are thrown from databaseWillCommit callback.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try dbQueue.inTransaction { db in\n        ...\n        return .commit // 1. willCommit (throws), 2. didRollback\n    }\n} catch {\n    // 3. The error thrown by the transaction observer.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Team and Player Models for Ordered Associations\nDESCRIPTION: Demonstrates how to define models for soccer teams and players, setting up the foundation for ordered HasMany associations where players have a position number in their team.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_59\n\nLANGUAGE: swift\nCODE:\n```\nstruct Team: FetchableRecord, TableRecord {\n    var id: Int64\n    var name: String\n}\n\nstruct Player: FetchableRecord, TableRecord {\n    var id: Int64\n    var teamId: Int64\n    var name: String\n    var position: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Association Keys at Definition in GRDB.swift\nDESCRIPTION: Demonstrates how to customize an association key when defining the association. This example shows a self-referential relationship where an Employee can have another Employee as a manager.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_78\n\nLANGUAGE: swift\nCODE:\n```\nextension Employee {\n    static let manager = belongsTo(Employee.self, key: \"manager\")\n}\nEmployee.including(optional: Employee.manager) // association key \"manager\"\n```\n\n----------------------------------------\n\nTITLE: Optimizing Database Observations with Columns in Swift\nDESCRIPTION: Shows how using Column expressions enables optimized database observations compared to raw SQL queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Optimized Observations\nValueObservation.tracking { db in\n    try Player.fetchOne(db, id: 1)\n    // or\n    try Player.filter(Column(\"id\") == 1).fetchOne(db)\n}\n\n// Non-optimized observations\nValueObservation.tracking { db in\n    try SQLRequest<Player>(\"SELECT * FROM player WHERE id = 1\").fetchOne(db)\n    // or\n    try Player.filter(sql: \"id = 1\").fetchOne(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Data Asynchronously with GRDB and Combine\nDESCRIPTION: Creates a publisher that reads data from the database asynchronously and delivers it as a single value. This example fetches all Player records from the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// DatabasePublishers.Read<[Player]>\nlet players = dbQueue.readPublisher { db in\n    try Player.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: JoinableRequest Protocol and Extensions in GRDB.swift 4.1.0\nDESCRIPTION: Defines a new JoinableRequest protocol that allows both requests and associations to use joining methods, enabling more flexible query construction for associated records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_27\n\nLANGUAGE: swift\nCODE:\n```\n+protocol JoinableRequest {\n+    associatedtype RowDecoder\n+}\n+\n+extension JoinableRequest {\n+    func including<A: AssociationToMany>(all association: A) -> Self where A.OriginRowDecoder == RowDecoder\n+    func including<A: Association>(optional association: A) -> Self where A.OriginRowDecoder == RowDecoder\n+    func including<A: Association>(required association: A) -> Self where A.OriginRowDecoder == RowDecoder\n+    func joining<A: Association>(optional association: A) -> Self where A.OriginRowDecoder == RowDecoder\n+    func joining<A: Association>(required association: A) -> Self where A.OriginRowDecoder == RowDecoder\n+}\n\n-protocol DerivableRequest: SelectionRequest, FilteredRequest, OrderedRequest { }\n+protocol DerivableRequest: SelectionRequest, FilteredRequest, OrderedRequest, JoinableRequest { }\n```\n\n----------------------------------------\n\nTITLE: Save with Timestamp Extension Implementation\nDESCRIPTION: Custom extension implementation for saving records with proper timestamp handling for both insert and update operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nextension Player {\n    /// If the player has a non-nil primary key and a matching row in\n    /// the database, the player is updated. Otherwise, it is inserted.\n    mutating func saveWithTimestamp(_ db: Database) throws {\n        // Test the presence of id first, so that we don't perform an\n        // update that would surely throw RecordError.recordNotFound.\n        if id == nil {\n            try insert(db)\n        } else {\n            do {\n                try updateWithTimestamp(db)\n            } catch RecordError.recordNotFound {\n                // Primary key is set, but no row was updated.\n                try insert(db)\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FTS3Pattern Usage Examples\nDESCRIPTION: Shows how to create and validate FTS3 search patterns with different matching strategies.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nlet documents = try Document.fetchAll(db,\n    sql: \"SELECT * FROM document WHERE content MATCH ?\",\n    arguments: [pattern])\n\n// Search in all columns\nlet documents = try Document.matching(pattern).fetchAll(db)\n\n// Search in a specific column:\nlet documents = try Document.filter(Column(\"content\").match(pattern)).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Fetching Rows in Swift using GRDB\nDESCRIPTION: Demonstrates how to fetch rows from a database using GRDB.swift. This snippet shows various methods for fetching single rows, all rows, or sequences of rows using different return types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_124\n\nLANGUAGE: Swift\nCODE:\n```\ndbQueue.inDatabase { db in\n    Row.fetch(db, \"SELECT ...\", arguments: ...)        // AnySequence<Row>\n    Row.fetchAll(db, \"SELECT ...\", arguments: ...)     // [Row]\n    Row.fetchOne(db, \"SELECT ...\", arguments: ...)     // Row?\n    \n    String.fetch(db, \"SELECT ...\", arguments: ...)     // AnySequence<String?>\n    String.fetchAll(db, \"SELECT ...\", arguments: ...)  // [String?]\n    String.fetchOne(db, \"SELECT ...\", arguments: ...)  // String?\n    \n    Person.fetch(db, \"SELECT ...\", arguments: ...)     // AnySequence<Person>\n    Person.fetchAll(db, \"SELECT ...\", arguments: ...)  // [Person]\n    Person.fetchOne(db, \"SELECT ...\", arguments: ...)  // Person?\n}\n```\n\n----------------------------------------\n\nTITLE: Using GRDB's unicode-aware uppercase function in SQL\nDESCRIPTION: This snippet shows how to use GRDB's unicode-aware uppercase function which properly handles accented characters, returning the correct uppercase version of the string.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_212\n\nLANGUAGE: swift\nCODE:\n```\n// \"JÉRÔME\"\nlet uppercased = DatabaseFunction.uppercase\ntry String.fetchOne(db, sql: \"SELECT \\(uppercased.name)('Jérôme')\")\n```\n\n----------------------------------------\n\nTITLE: Reversing Result Order in GRDB\nDESCRIPTION: Demonstrates using the reversed() method to invert the ordering of results, which is useful for switching between ascending and descending order without rewriting the entire ordering clause.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_138\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player ORDER BY score ASC, name DESC\nPlayer.order(scoreColumn.desc, nameColumn).reversed()\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player\nPlayer.all().reversed()\n```\n\n----------------------------------------\n\nTITLE: Ordering by Primary Key in GRDB Swift Queries\nDESCRIPTION: Shows how to sort query results by primary key columns. The examples demonstrate ordering for tables with single-column and composite primary keys.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_143\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player ORDER BY id\nPlayer.orderByPrimaryKey()\n\n// SELECT * FROM country ORDER BY code\nCountry.orderByPrimaryKey()\n\n// SELECT * FROM citizenship ORDER BY citizenId, countryCode\nCitizenship.orderByPrimaryKey()\n```\n\n----------------------------------------\n\nTITLE: Filtering Authors by Book Type in Swift\nDESCRIPTION: Shows how to filter authors based on specific attributes of associated records, finding authors who wrote at least one novel by first filtering the association.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_98\n\nLANGUAGE: swift\nCODE:\n```\nlet novels = Author.books.filter(Column(\"kind\") == \"novel\")\nlet request = Author.having(novels.isEmpty == false)\n```\n\n----------------------------------------\n\nTITLE: Managing File Resources with Transaction Callbacks in GRDB.swift\nDESCRIPTION: Shows how to safely handle external resources (like files) by using the afterNextTransaction method to ensure cleanup operations happen only when the transaction is actually committed to the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_91\n\nLANGUAGE: swift\nCODE:\n```\nstruct PictureFile: PersistableRecord {\n    var path: String\n    \n    func willDelete(_ db: Database) {\n        db.afterNextTransaction { _ in\n            try? deleteFileOnDisk()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Column Enums with FetchableRecord in Swift using GRDB\nDESCRIPTION: Demonstrates how to use a column enum to provide type-safe access to database columns when implementing the FetchableRecord protocol init method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_69\n\nLANGUAGE: swift\nCODE:\n```\nextension Place : FetchableRecord {\n    enum Columns: String, ColumnExpression {\n        case id, title, latitude, longitude\n    }\n    \n    init(row: Row) {\n        id = row[Columns.id]\n        title = row[Columns.title]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[Columns.latitude],\n            longitude: row[Columns.longitude])\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Chat Info Records from the Database\nDESCRIPTION: Executes the final request in a database read transaction to fetch all ChatInfo objects that will feed the application's UI.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nlet chatInfos: [ChatInfos] = try dbQueue.read { db in\n    try request.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Database Access Methods API Diff in GRDB.swift 4.1.0\nDESCRIPTION: Shows API changes that add asynchronous database access methods to DatabaseReader and DatabaseWriter protocols, enabling background operations without blocking the main thread.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_25\n\nLANGUAGE: swift\nCODE:\n```\n protocol DatabaseReader {\n+    var configuration: Configuration { get }\n+\n+    #if compiler(>=5.0)\n+    func asyncRead(_ block: @escaping (Result<Database, Error>) -> Void)\n+    #endif\n }\n \n protocol DatabaseWriter {\n+    func asyncWriteWithoutTransaction(_ updates: @escaping (Database) -> Void)\n+\n+    #if compiler(>=5.0)\n+    func asyncWrite<T>(_ updates: @escaping (Database) throws -> T, completion: @escaping (Database, Result<T, Error>) -> Void)\n+    #endif\n }\n```\n\n----------------------------------------\n\nTITLE: Implementing App Suspension Notification in UIApplicationDelegate\nDESCRIPTION: Posts the Database.suspendNotification when the app enters background, signaling database operations to stop acquiring new locks to prevent potential deadlocks.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func applicationDidEnterBackground(_ application: UIApplication) {\n        NotificationCenter.default.post(name: Database.suspendNotification, object: self)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Storing NSNumber and NSDecimalNumber in SQLite with GRDB.swift\nDESCRIPTION: Shows how NSNumber and NSDecimalNumber are stored in the database. Both types send 64-bit signed integers and doubles to SQLite, which can potentially cause precision loss for decimal numbers.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_44\n\nLANGUAGE: swift\nCODE:\n```\n// INSERT INTO transfer VALUES (10)\ntry db.execute(sql: \"INSERT INTO transfer VALUES (?)\", arguments: [NSNumber(value: 10)])\n\n// INSERT INTO transfer VALUES (10.0)\ntry db.execute(sql: \"INSERT INTO transfer VALUES (?)\", arguments: [NSNumber(value: 10.0)])\n\n// INSERT INTO transfer VALUES (10)\ntry db.execute(sql: \"INSERT INTO transfer VALUES (?)\", arguments: [NSDecimalNumber(string: \"10.0\")])\n\n// INSERT INTO transfer VALUES (10.5)\ntry db.execute(sql: \"INSERT INTO transfer VALUES (?)\", arguments: [NSDecimalNumber(string: \"10.5\")])\n```\n\n----------------------------------------\n\nTITLE: Defining Associations with Default and Custom Keys in GRDB.swift\nDESCRIPTION: Shows how association keys are automatically derived from table names and how they can be customized. Demonstrates both hasMany and belongsTo relationships with default and custom keys.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_77\n\nLANGUAGE: swift\nCODE:\n```\nextension Author {\n    static let books = hasMany(Book.self)\n}\nAuthor.including(all: Author.books)            // association key \"books\"\n\nextension Book {\n    static let author = belongsTo(Author.self)\n}\nBook.including(required: Book.author)          // association key \"author\"\n```\n\n----------------------------------------\n\nTITLE: Configuring File Attributes for DatabasePool in Swift\nDESCRIPTION: Sets up file protection attributes for a database file. The configuration applies these attributes to the database file and all its derivatives (WAL mode files and temporary files).\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_116\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.fileAttributes = [NSFileProtectionKey: NSFileProtectionComplete]\nlet dbPool = DatabasePool(path: \".../db.sqlite\", configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Handling NULL Values in GRDB Queries\nDESCRIPTION: Shows different scenarios for handling NULL values in database queries and their corresponding Swift optional results.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_34\n\nLANGUAGE: swift\nCODE:\n```\n// No row:\ntry Int.fetchOne(db, sql: \"SELECT 42 WHERE FALSE\") // nil\n\n// One row with a NULL value:\ntry Int.fetchOne(db, sql: \"SELECT NULL\")           // nil\n\n// One row with a non-NULL value:\ntry Int.fetchOne(db, sql: \"SELECT 42\")             // 42\n```\n\n----------------------------------------\n\nTITLE: Defining Codable Record Type in GRDB\nDESCRIPTION: Shows how to define a record type using Swift's Codable protocol to automatically implement GRDB's record protocols. This eliminates the need for boilerplate code by automatically deriving row initialization and persistence methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_58\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Player : RowConvertible, Persistable, Codable {\n    static let databaseTableName = \"players\"\n    let name: String\n    let score: Int\n}\n\n// Automatically derived:\n//\n// extension Player {\n//     init(row: Row) {\n//         name = row[\"name\"]\n//         score = row[\"score\"]\n//     }\n//     \n//     func encode(to container: inout PersistenceContainer) {\n//         container[\"name\"] = name\n//         container[\"score\"] = score\n//     }\n// }\n\ntry dbQueue.inDatabase { db in\n    let arthur = Player(name: \"Arthur\", score: 100)\n    try arthur.insert(db)\n    let players = try Player.fetchAll(db) // [Players]\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom SQL Aggregate\nDESCRIPTION: Shows how to register a custom aggregate function with a database connection through configuration, making it available for SQL queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_54\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.add(function: maxLength)\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n\ntry dbQueue.read { db in\n    // Some Int\n    try Int.fetchOne(db, sql: \"SELECT maxLength(name) FROM player\")!\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Flexible JSON Schema with Data in Swift\nDESCRIPTION: This code shows how to define a flexible JSON schema using a Data property in Swift. It also demonstrates how to ensure the JSON data is stored as text in the database using DatabaseDataEncodingStrategy.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/JSON.md#2025-04-22_snippet_5\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Team: Codable {\n    var id: String\n    var color: String\n    var info: Data // JSON UTF8 data\n}\n\nextension Team: FetchableRecord, PersistableRecord {\n    // Support SQLite JSON functions and operators\n    // by storing JSON data as database text:\n    static func databaseDataEncodingStrategy(for column: String) -> DatabaseDataEncodingStrategy {\n        .text\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Record Subclass to Swift Struct in GRDB 7\nDESCRIPTION: Shows how to refactor a Player class from inheriting Record to a Swift struct implementing Codable. The example demonstrates the recommended approach for GRDB 7 that better supports Swift concurrency and Swift 6 language mode.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB7MigrationGuide.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 6\nclass Player: Record {\n    var id: UUID\n    var name: String\n    var score: Int\n    \n    override class var databaseTableName: String { \"player\" }\n    \n    init(id: UUID, name: String, score: Int) { ... }\n    required init(row: Row) throws { ... }\n    override func encode(to container: inout PersistenceContainer) throws { ...}\n}\n\n// GRDB 7\nstruct Player: Codable {\n    var id: UUID\n    var name: String\n    var score: Int\n}\n\nextension Player: FetchableRecord, PersistableRecord { }\n```\n\n----------------------------------------\n\nTITLE: Using DatabaseValueConvertible Types in Filters in Swift\nDESCRIPTION: Demonstrates how basic value types that conform to DatabaseValueConvertible can be used in database query filters.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player WHERE name = 'O''Brien'\n//                                   ~~~~~~~~~~\nPlayer.filter(Column(\"name\") == \"O'Brien\")\n```\n\n----------------------------------------\n\nTITLE: GRDB SQLCipher Pod Configuration\nDESCRIPTION: Shows how to configure CocoaPods for using GRDB with SQLCipher encryption support.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_188\n\nLANGUAGE: ruby\nCODE:\n```\n# GRDB with SQLCipher 4\npod 'GRDB.swift/SQLCipher'\npod 'SQLCipher', '~> 4.0'\n\n# GRDB with SQLCipher 3\npod 'GRDB.swift/SQLCipher'\npod 'SQLCipher', '~> 3.4'\n```\n\n----------------------------------------\n\nTITLE: Requesting Associated Records in GRDB\nDESCRIPTION: Shows how to build and execute requests for associated records using GRDB's association methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_32\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord, EncodableRecord {\n    static let author = belongsTo(Author.self)\n    \n    var author: QueryInterfaceRequest<Author> {\n        request(for: Book.author)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Tables Missing Unique Indexes in Swift\nDESCRIPTION: Shows the limitations when working with tables that don't have unique indexes and the alternative approaches required. Certain GRDB methods will raise fatal errors without proper unique indexes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Fatal error: table player has no unique index on columns ...\n    let player = try Player.fetchOne(db, key: [\"teamId\": 42, \"position\": 1])\n    try Player.deleteOne(db, key: [\"name\": \"Arthur\"])\n    \n    // Use instead:\n    let player = try Player\n        .filter(Column(\"teamId\") == 42 && Column(\"position\") == 1)\n        .fetchOne(db)\n\n    try Player\n        .filter(Column(\"name\") == \"Arthur\")\n        .deleteAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Count from a Custom Request in GRDB\nDESCRIPTION: This code shows how to fetch the count of records from a custom request that conforms to the Request protocol. The fetchCount method returns the number of records that would be returned by the request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_88\n\nLANGUAGE: swift\nCODE:\n```\nlet request: Request = ...\nlet count = try request.fetchCount(db) // Int\n```\n\n----------------------------------------\n\nTITLE: SQL Collation API Updates\nDESCRIPTION: Changes to collation management methods across Database, DatabasePool, DatabaseQueue, and DatabaseReader classes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_105\n\nLANGUAGE: diff\nCODE:\n```\n class Database {\n-    func addCollation(collation: DatabaseCollation)\n-    func removeCollation(collation: DatabaseCollation)\n+    func add(collation: DatabaseCollation)\n+    func remove(collation: DatabaseCollation)\n }\n```\n\n----------------------------------------\n\nTITLE: Creating a DatabaseRegionObservation Combine Publisher in Swift\nDESCRIPTION: Demonstrates how to create a Combine publisher from a DatabaseRegionObservation that tracks changes to a specific database region. This publisher notifies subscribers whenever changes occur in the tracked region.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.all()\nlet observation = DatabaseRegionObservation.tracking(request)\n\n// A publisher with output Database and failure Error\nlet publisher = observation.publisher(in: dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Replacing Static Column Coding Strategy Properties with Methods in Swift\nDESCRIPTION: GRDB 7 replaces static properties for column coding strategies with methods that accept column names. This allows for more flexible per-column configuration of data encoding and decoding strategies.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB7MigrationGuide.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 6\nstruct Player {\n    static let databaseDataDecodingStrategy = ...\n    static let databaseDateDecodingStrategy = ...\n    static let databaseDataEncodingStrategy = ...\n    static let databaseDateEncodingStrategy = ...\n    static let databaseUUIDEncodingStrategy = ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 7\nstruct Player {\n    static func databaseDataDecodingStrategy(for column: String) -> DatabaseDataDecodingStrategy { ... }\n    static func databaseDateDecodingStrategy(for column: String) -> DatabaseDateDecodingStrategy { ...}\n    static func databaseDataEncodingStrategy(for column: String) -> DatabaseDataEncodingStrategy { ... }\n    static func databaseDateEncodingStrategy(for column: String) -> DatabaseDateEncodingStrategy { ... }\n    static func databaseUUIDEncodingStrategy(for column: String) -> DatabaseUUIDEncodingStrategy { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Numeric String Values with GRDB.swift\nDESCRIPTION: Demonstrates how numeric types can decode string values from the database as decimal numbers. NSNumber, NSDecimalNumber, and Decimal can all interpret string representations of numbers.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_43\n\nLANGUAGE: swift\nCODE:\n```\nlet number = try NSNumber.fetchOne(db, sql: \"SELECT '10'\")          // NSDecimalNumber (sic)\nlet number = try NSDecimalNumber.fetchOne(db, sql: \"SELECT '1.23'\") // NSDecimalNumber\nlet number = try Decimal.fetchOne(db, sql: \"SELECT '-100'\")         // Decimal\n```\n\n----------------------------------------\n\nTITLE: Implementing Eager Loading for HasMany Associations in Swift\nDESCRIPTION: Adds support for eager loading HasMany associations to improve performance by reducing database queries. These methods allow including related records in a single query, extending TableRecord, Association, and QueryInterfaceRequest types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_31\n\nLANGUAGE: swift\nCODE:\n```\n extension TableRecord {\n+    static func including<A: AssociationToMany>(all association: A) -> QueryInterfaceRequest<Self> where A.OriginRowDecoder == Self\n }\n \n extension Association {\n+    func including<A: AssociationToMany>(all association: A) -> Self where A.OriginRowDecoder == RowDecoder\n }\n \n extension QueryInterfaceRequest {\n+    func including<A: AssociationToMany>(all association: A) -> QueryInterfaceRequest where A.OriginRowDecoder == RowDecoder\n }\n```\n\n----------------------------------------\n\nTITLE: Decoding Arrays of Associated Records with FetchableRecord in GRDB.swift\nDESCRIPTION: Demonstrates how to decode a one-to-many relationship using FetchableRecord. This example shows how to extract an array of books associated with an author from a joined request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_84\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author.including(all: Author.books)\n\nstruct AuthorInfo: FetchableRecord {\n    var author: Author\n    var books: [Book]\n    \n    init(row: Row) throws {\n        author = try Author(row: row)\n        books = row[\"books\"]\n    }\n}\n\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Implementing RowConvertible Protocol in Swift\nDESCRIPTION: Demonstrates the new required factory method for the RowConvertible protocol introduced in version 0.34.0, replacing the previous initializer requirement.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_122\n\nLANGUAGE: Swift\nCODE:\n```\nstatic func fromRow(_:Row) -> Self\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable SQL Functions in Swift\nDESCRIPTION: Example showing how to define Swift functions that can be used with SQL interpolation in all query contexts.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nfunc date(_ expression: SQLExpressible) -> SQLExpression {\n    SQL(\"DATE(\\(expression))\").sqlExpression\n}\n\nlet request = Player.filter(date(Column(\"createdAt\")) == \"2020-01-23\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Codable Record Types with Non-Conventional Column Names in Swift\nDESCRIPTION: Shows how to configure Codable record types when column names don't follow camelCase convention. This requires explicit CodingKeys enumeration to map between database columns and Swift properties.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: Decodable, FetchableRecord {\n    var id: Int64\n    var fullName: String\n    var score: Int\n    var creationDate: Date\n\n    // Required CodingKeys customization because \n    // columns are not named like Swift properties\n    enum CodingKeys: String, CodingKey {\n        case id, fullName = \"full_name\", score, creationDate = \"creation_date\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Raw Rows with Cursors in GRDB with Swift\nDESCRIPTION: Example of using GRDB's cursor API for low-level, performance-critical access to database rows. This approach minimizes memory usage by fetching rows one at a time instead of loading everything into memory.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n// As close to SQLite metal as possible\nlet rows = try Row.fetchCursor(db, sql: \"SELECT id, name, score FROM player\")\nwhile let row = try rows.next() {\n    let id: Int64 = row[0]\n    let name: String = row[1]\n    let score: Int = row[2]\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering on JSON Column with Custom Type in Swift\nDESCRIPTION: This snippet demonstrates how to filter records based on a JSON column that contains a custom type. It requires the custom type to conform to DatabaseValueConvertible.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/JSON.md#2025-04-22_snippet_6\n\nLANGUAGE: Swift\nCODE:\n```\nstruct Address: Codable { ... }\nextension Address: DatabaseValueConvertible {}\n\n// SELECT * FROM player\n// WHERE address = '{\"street\": \"...\", \"city\": \"...\", \"country\": \"...\"}'\nlet players = try Player\n    .filter(JSONColumn(\"address\") == Address(...))\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: EncodableRecord Protocol Definition in Swift\nDESCRIPTION: New protocol definition for EncodableRecord with methods for database encoding and value comparison.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_36\n\nLANGUAGE: swift\nCODE:\n```\nprotocol EncodableRecord {\n    func encode(to container: inout PersistenceContainer)\n    static var databaseEncodingUserInfo: [CodingUserInfoKey: Any] { get }\n    static func databaseJSONEncoder(for column: String) -> JSONEncoder\n    static var databaseDateEncodingStrategy: DatabaseDateEncodingStrategy { get }\n    static var databaseUUIDEncodingStrategy: DatabaseUUIDEncodingStrategy { get }\n}\n```\n\n----------------------------------------\n\nTITLE: Using DatabaseValue in SQL Expressions in Swift\nDESCRIPTION: Demonstrates how to use DatabaseValue objects in SQL expressions when raw values are not accepted, such as in string concatenation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n// SQL: firstName || ' ' || lastName\nlet fullname = [\n    Column(\"firstName\"), \n    \" \".databaseValue,\n    Column(\"lastName\"),\n    ].joined(operator: .concat)\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Filtering in TransactionObserver\nDESCRIPTION: Shows how to implement the observes(eventsOfKind:) method to filter database events based on table name.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nclass PlayerObserver: TransactionObserver {\n    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {\n        // Only observe changes to the \"player\" table.\n        eventKind.tableName == \"player\"\n    }\n\n    func databaseDidChange(with event: DatabaseEvent) {\n        // This method is only called for changes that happen to\n        // the \"player\" table.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Data with Optimized Reading with GRDB and Combine\nDESCRIPTION: Creates a publisher that performs database updates and then reads data with optimized scheduling. This approach can reduce database write contention with database pools.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// DatabasePublishers.Write<Int>\nlet newPlayerCount = dbQueue.writePublisher(\n    updates: { db in try Player(...).insert(db) }\n    thenRead: { db, _ in try Player.fetchCount(db) })\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced NULL Handling with Double Optionals\nDESCRIPTION: Shows how to distinguish between no results and NULL values using double optional return types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_36\n\nLANGUAGE: swift\nCODE:\n```\n// No row:\ntry Optional<Int>.fetchOne(db, sql: \"SELECT 42 WHERE FALSE\") // .none\n// One row with a NULL value:\ntry Optional<Int>.fetchOne(db, sql: \"SELECT NULL\")           // .some(.none)\n// One row with a non-NULL value:\ntry Optional<Int>.fetchOne(db, sql: \"SELECT 42\")             // .some(.some(42))\n```\n\n----------------------------------------\n\nTITLE: Defining a Plain Struct Record in GRDB.swift\nDESCRIPTION: Implementation of a Place record using a plain struct with explicit TableRecord, FetchableRecord, and MutablePersistableRecord protocol conformances. This approach provides more control over database column mapping.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_115\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place {\n    var id: Int64?\n    var title: String\n    var isFavorite: Bool\n    var coordinate: CLLocationCoordinate2D\n}\n\n// SQL generation\nextension Place: TableRecord {\n    /// The table columns\n    enum Columns: String, ColumnExpression {\n        case id, title, isFavorite, latitude, longitude\n    }\n}\n\n// Fetching methods\nextension Place: FetchableRecord {\n    /// Creates a record from a database row\n    init(row: Row) {\n        id = row[Columns.id]\n        title = row[Columns.title]\n        isFavorite = row[Columns.isFavorite]\n        coordinate = CLLocationCoordinate2D(\n            latitude: row[Columns.latitude],\n            longitude: row[Columns.longitude])\n    }\n}\n\n// Persistence methods\nextension Place: MutablePersistableRecord {\n    /// The values persisted in the database\n    func encode(to container: inout PersistenceContainer) {\n        container[Columns.id] = id\n        container[Columns.title] = title\n        container[Columns.isFavorite] = isFavorite\n        container[Columns.latitude] = coordinate.latitude\n        container[Columns.longitude] = coordinate.longitude\n    }\n    \n    // Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Configuring Associations without Schema Foreign Keys in GRDB Swift\nDESCRIPTION: This snippet demonstrates how to manually configure associations between Player and Team records when foreign keys are not declared in the database schema. It requires explicit definition of the foreign key relationship.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: TableRecord {\n    // Required configuration because the database does\n    // not declare any foreign key from players to their team.\n    static let teamForeignKey = ForeignKey([\"teamId\"])\n    static let team = belongsTo(Team.self,\n                                using: teamForeignKey)\n}\n\nextension Team: TableRecord {\n    // Required configuration because the database does\n    // not declare any foreign key from players to their team.\n    static let players = hasMany(Player.self,\n                                 using: Player.teamForeignKey)\n}\n```\n\n----------------------------------------\n\nTITLE: Notifying Database Changes Explicitly in GRDB\nDESCRIPTION: Shows how to explicitly notify observations about database changes using the notifyChanges method, useful for handling undetected changes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/ValueObservation.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Notify observations that some changes were performed in the database\n    try db.notifyChanges(in: .fullDatabase)\n\n    // Notify observations that some changes were performed in the player table\n    try db.notifyChanges(in: Player.all())\n\n    // Equivalent alternative\n    try db.notifyChanges(in: Table(\"player\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using FTS5 Table with Custom Tokenizer\nDESCRIPTION: Shows how to insert data into and query from an FTS5 table using custom tokenizer. Demonstrates both raw SQL and Swift API approaches.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ntry db.execute(sql: \"INSERT INTO documents VALUES (?)\", arguments: [\"...\"])\ntry Document(content: \"...\").insert(db)\n\nlet pattern = FTS5Pattern(matchingAnyTokenIn:\"...\")\nlet documents = try Document.matching(pattern).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: RETURNING Clause Usage in Swift\nDESCRIPTION: Examples of using the RETURNING clause with insert and delete operations\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nplayer.insertAndFetch(db)\nPlayer.deleteAndFetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Database Change Observation with GRDB in Swift\nDESCRIPTION: This code demonstrates how to set up a ValueObservation to track changes in Player records, with examples for vanilla GRDB, Combine, and RxSwift integrations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/WhyAdoptGRDB.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n/// An observation of [Player]\nlet observation = ValueObservation.tracking { db in\n    try Player.fetchAll(db)\n}\n\n// Vanilla GRDB\nlet cancellable = observation.start(in: dbQueue,\n    onError: { error in ... },\n    onChange: { (players: [Player]) in print(\"Fresh players\") })\n\n// GRDB + Combine\nlet cancellable = observation.publisher(in: dbQueue).sink(\n    receiveCompletion: { completion in ... },\n    receiveValue: { (players: [Player]) in print(\"Fresh players\") })\n    \n// RxGRDB\nlet disposable = observation.rx.observe(in: dbQueue).subscribe(\n    onNext: { (players: [Player]) in print(\"Fresh playerss\") },\n    onError: { error in ... })\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Migration for BelongsTo Association in GRDB Swift\nDESCRIPTION: Demonstrates the recommended database migration for setting up tables with a BelongsTo relationship. Creates author and book tables with proper foreign key constraints and indexing.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"Books and Authors\") { db in\n    try db.create(table: \"author\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")             // (1)\n        t.column(\"name\", .text)\n    }\n    try db.create(table: \"book\") { t in\n        t.autoIncrementedPrimaryKey(\"id\")\n        t.belongsTo(\"author\", onDelete: .cascade)     // (2)\n            .notNull()                                // (3)\n        t.column(\"title\", .text)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using CodingKeys with Aggregates in Swift\nDESCRIPTION: Demonstrates how to use CodingKeys with the forKey method for type-safe property naming in aggregates. This approach integrates well with Swift's Codable system.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_93\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var numberOfBooks: Int\n    \n    static func all() -> QueryInterfaceRequest<AuthorInfo> {\n        let numberOfBooks = Author.books.count.forKey(CodingKey.numberOfBooks)    // <--\n        return Author\n            .annotated(with: numberOfBooks)\n            .asRequest(of: AuthorInfo.self)\n    }\n}\nlet authorInfos: [AuthorInfo] = try AuthorInfo.all().fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Filtering Associated Records in GRDB.swift\nDESCRIPTION: Shows how to filter and fetch only books that have associated authors using join operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_226\n\nLANGUAGE: swift\nCODE:\n```\nlet books: [Book] = try dbQueue.read { db in\n    // SELECT book.* FROM book \n    // JOIN author ON author.id = book.authorID\n    let request = Book.joining(required: Book.author)\n    return try request.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a read-only database from application resources\nDESCRIPTION: This example shows how to open a read-only connection to a database file stored as a resource in the application bundle, ensuring writes are disallowed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_221\n\nLANGUAGE: swift\nCODE:\n```\n// HOW TO open a read-only connection to a database resource\n\n// Get the path to the database resource.\nif let dbPath = Bundle.main.path(forResource: \"db\", ofType: \"sqlite\") {\n    // If the resource exists, open a read-only connection.\n    // Writes are disallowed because resources can not be modified. \n    var config = Configuration()\n    config.readonly = true\n    let dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n} else {\n    // The database resource can not be found.\n    // Fix your setup, or report the problem to the user. \n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Non-Sendable DatabaseSelection Issue in Record Types\nDESCRIPTION: Demonstrates how to properly define the databaseSelection property for record types to avoid concurrency issues. The solution is to replace a stored property with a computed property to satisfy Swift 6's Sendable requirements.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: FetchableRecord, PersistableRecord {\n    // ❌ Static property 'databaseSelection' is not concurrency-safe\n    // because non-'Sendable' type '[any SQLSelectable]'\n    // may have shared mutable state\n    static let databaseSelection: [any SQLSelectable] = [\n        Column(\"id\"), Column(\"name\"), Column(\"score\")\n    ]\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: FetchableRecord, PersistableRecord {\n    static var databaseSelection: [any SQLSelectable] {\n        [Column(\"id\"), Column(\"name\"), Column(\"score\")]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Default and Custom Ordering in GRDB.swift Associations\nDESCRIPTION: Shows how to use the default ordering defined in an association and how to override it with custom ordering when needed. This provides flexibility while maintaining convenient defaults.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_63\n\nLANGUAGE: swift\nCODE:\n```\nstruct TeamInfo: Decodable, FetchableRecord {\n    var team: Team\n    var players: [Player]\n}\n\n// Default ordering by position\nlet team: Team = ...\nlet players = try team.players.fetchAll(db)\nlet teamInfos = try Team\n    .including(all: Team.players)\n    .asRequest(of: TeamInfo.self)\n    .fetchAll(db)\n\n// Custom ordering\nlet team: Team = ...\nlet players = try team.players.order(Column(\"name\")).fetchAll(db)\nlet teamInfos = try Team\n    .including(all: Team.players.order(Column(\"name\")))\n    .asRequest(of: TeamInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Defining a Hierarchical Decodable Record in GRDB.swift\nDESCRIPTION: Creates a nested Decodable record structure that reflects the hierarchical nature of the joined request. This structure contains a nested PersonInfo struct to represent both authors and translators.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_81\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord, Decodable {\n    struct PersonInfo: Decodable {\n        var person: Person\n        var country: Country?\n    }\n    var book: Book\n    var authorInfo: PersonInfo\n    var translatorInfo: PersonInfo?\n    var coverImage: CoverImage?\n}\n```\n\n----------------------------------------\n\nTITLE: Changes to Database Class and PrimaryKeyInfo\nDESCRIPTION: Updates the Database primaryKey method to always return a non-optional PrimaryKeyInfo and adds an isRowID property to PrimaryKeyInfo.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_70\n\nLANGUAGE: diff\nCODE:\n```\n class Database {\n-    func primaryKey(_ tableName: String) throws -> PrimaryKeyInfo?\n+    func primaryKey(_ tableName: String) throws -> PrimaryKeyInfo\n }\n struct PrimaryKeyInfo {\n+    var isRowID: Bool { get }\n }\n```\n\n----------------------------------------\n\nTITLE: CTE Associations Example\nDESCRIPTION: Shows how to create associations between database tables and CTEs using the association builder method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nlet association = LeftRecord.association(\n    to: rightCTE, \n    on: { left, right in\n        left[Column(\"x\")] == right[Column(\"y\")]\n    })\n```\n\n----------------------------------------\n\nTITLE: Advanced Annotation with Multiple Aggregates in Swift\nDESCRIPTION: Demonstrates how to annotate a request with multiple aggregate values from associations. This example fetches authors with both their book count and the maximum book year.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_91\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var bookCount: Int\n    var maxBookYear: Int?\n}\n\n// SELECT author.*,\n//        COUNT(DISTINCT book.id) AS bookCount,\n//        MAX(book.year) AS maxBookYear,\n// FROM author\n// LEFT JOIN book ON book.authorId = author.id\n// GROUP BY author.id\nlet request = Author.annotated(with:\n    Author.books.count,\n    Author.books.max(Column(\"year\")))\n\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n\nfor info in authorInfos {\n    print(info.author.name)\n    print(\"- number of books: \\(info.bookCount)\")\n    print(\"- last book published on: \\(info.maxBookYear)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Data Type Coding Strategies\nDESCRIPTION: Shows protocol methods to customize how Data, Date, and UUID types are encoded to and decoded from database columns. These methods allow fine-grained control over type conversion on a per-column basis.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_99\n\nLANGUAGE: swift\nCODE:\n```\nprotocol FetchableRecord {\n    static func databaseDataDecodingStrategy(for column: String) -> DatabaseDataDecodingStrategy\n    static func databaseDateDecodingStrategy(for column: String) -> DatabaseDateDecodingStrategy\n}\n\nprotocol EncodableRecord {\n    static func databaseDataEncodingStrategy(for column: String) -> DatabaseDataEncodingStrategy\n    static func databaseDateEncodingStrategy(for column: String) -> DatabaseDateEncodingStrategy\n    static func databaseUUIDEncodingStrategy(for column: String) -> DatabaseUUIDEncodingStrategy\n}\n```\n\n----------------------------------------\n\nTITLE: Working with SQL Literal Type in Swift\nDESCRIPTION: Example showing how to use the SQL type for SQL interpolation, demonstrating that SQL is a distinct type from String.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    let query: SQL = \"UPDATE player SET name = \\(name) WHERE id = \\(id)\"\n    try db.execute(literal: query)\n}\n```\n\n----------------------------------------\n\nTITLE: Custom SQL Request Implementation\nDESCRIPTION: Demonstrates how to create custom SQL requests using SQLRequest type with both raw SQL and SQL interpolation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_185\n\nLANGUAGE: swift\nCODE:\n```\nextension Player {\n    static func filter(color: Color) -> SQLRequest<Player> {\n        SQLRequest<Player>(\n            sql: \"SELECT * FROM player WHERE color = ?\"\n            arguments: [color])\n    }\n}\n\n// [Player]\ntry Player.filter(color: .red).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Handling Database Suspension Errors in GRDB.swift\nDESCRIPTION: Catches SQLITE_INTERRUPT or SQLITE_ABORT errors that occur when attempting database operations while the database is suspended, allowing for graceful error handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try dbPool.write { db in ... }\n} catch DatabaseError.SQLITE_INTERRUPT, DatabaseError.SQLITE_ABORT {\n    // Oops, the database is suspended.\n    // Maybe try again after database is resumed?\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing JSON Encoding/Decoding in GRDB Records\nDESCRIPTION: Shows the protocol methods that can be implemented to customize the JSON encoding and decoding process for Codable records. These methods allow configuration of JSONEncoder and JSONDecoder used by GRDB when serializing complex properties.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_97\n\nLANGUAGE: swift\nCODE:\n```\nprotocol FetchableRecord {\n    static func databaseJSONDecoder(for column: String) -> JSONDecoder\n}\n\nprotocol EncodableRecord {\n    static func databaseJSONEncoder(for column: String) -> JSONEncoder\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Context-Aware Decodable Records with userInfo\nDESCRIPTION: Demonstrates a practical example of using the userInfo dictionary to make records aware of their decoding context. The Player type can determine if it's being decoded from JSON or from a database row.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_102\n\nLANGUAGE: swift\nCODE:\n```\n// A key that holds a decoder's name\nlet decoderName = CodingUserInfoKey(rawValue: \"decoderName\")!\n\nstruct Player: FetchableRecord, Decodable {\n    init(from decoder: Decoder) throws {\n        // Print the decoder name\n        let decoderName = decoder.userInfo[decoderName] as? String\n        print(\"Decoded from \\(decoderName ?? \"unknown decoder\")\")\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Result Code Matching with DatabaseError\nDESCRIPTION: Alternative approach to catch specific SQLite errors by directly matching error cases against result codes in the catch statement.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_207\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try ...\n} catch DatabaseError.SQLITE_CONSTRAINT_FOREIGNKEY {\n    // foreign key constraint error\n} catch DatabaseError.SQLITE_CONSTRAINT {\n    // any other constraint error\n} catch {\n    // any other database error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Association from Chat to Latest Message\nDESCRIPTION: Creates an association between a chat and its latest message by joining on chat.id = latestMessage.chatID, with results ordered by descending date.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n// ... JOIN latestMessage ON chat.id = latestMessage.chatID\nlet latestMessage = Chat.association(\n    to: latestMessageCTE,\n    on: { chat, latestMessage in\n        chat[Column(\"id\")] == latestMessage[Column(\"chatID\")]\n    })\n    .order(Column(\"date\").desc)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Row Initialization with Dictionary Literal in Swift\nDESCRIPTION: Shows how to create a Row object using a dictionary literal, preserving column order and allowing duplicate column names.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_93\n\nLANGUAGE: Swift\nCODE:\n```\nlet row: Row = [\"foo\": 1, \"foo\": Date(), \"baz\": nil]\nprint(row)\n// Prints <Row foo:1 foo:\"2016-12-16 13:19:49.230\" baz:NULL>\n```\n\n----------------------------------------\n\nTITLE: Customizing Requests with DerivableRequest Protocol\nDESCRIPTION: Example of extending GRDB's query capabilities by implementing custom filtering and ordering methods using the DerivableRequest protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_103\n\nLANGUAGE: swift\nCODE:\n```\nextension DerivableRequest<Author> {\n    func filter(country: String) -> Self {\n        filter(Column(\"country\") == country)\n    }\n    \n    func orderedByName() -> Self {\n        order(Column(\"name\").collating(.localizedCaseInsensitiveCompare))\n    }\n}\n\nextension DerivableRequest<Book> {\n    func filter(country: String) -> Self {\n        joining(required: Book.author.filter(country: country))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Capture Mutation Errors in Async Contexts\nDESCRIPTION: Shows how to handle Swift's \"mutation of captured var in concurrently-executing code\" error that occurs when using insert/save methods in async database operations by using the inserted/saved alternatives.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_233\n\nLANGUAGE: swift\nCODE:\n```\nvar player = Player(id: nil, name: \"Arthur\")\ntry await dbWriter.write { db in\n    // Error: Mutation of captured var 'player' in concurrently-executing code\n    try player.insert(db)\n}\nprint(player.id) // A non-nil id\n```\n\nLANGUAGE: swift\nCODE:\n```\n// OK\nvar player = Player(id: nil, name: \"Arthur\")\nplayer = try await dbWriter.write { [player] db in\n    return try player.inserted(db)\n}\nprint(player.id) // A non-nil id\n```\n\n----------------------------------------\n\nTITLE: Implementing Maximum Score Query\nDESCRIPTION: Method to retrieve the maximum score from the players table using SQL aggregation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: Decodable, FetchableRecord, TableRecord {\n    /// The maximum score\n    static func maximumScore() -> SQLRequest<Int> {\n        \"SELECT MAX(\\(CodingKeys.score)) FROM \\(self)\"\n    }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet maximumScore = try dbQueue.read { db in\n    // SELECT MAX(score) FROM player\n    try Player.maximumScore().fetchOne(db) // Int?\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SQL Literal from Plain SQL String in Swift\nDESCRIPTION: Example showing how to create a SQL literal from a plain SQL string with separate arguments.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nlet query = SQL(\n    sql: \"UPDATE player SET name = ? WHERE id = ?\",\n    arguments: [name, id])\n```\n\n----------------------------------------\n\nTITLE: Using Record Types for Database Operations\nDESCRIPTION: Demonstrates basic database operations using the implemented record types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    var author = Author(name: \"Herman Melville\", countryCode: \"US\")\n    try author.insert(db)\n\n    var book = Book(authorId: author.id!, title: \"Moby-Dick\")\n    try book.insert(db)\n}\n\nlet books = try dbQueue.read { db in\n    try Book.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Cancelling ValueObservation in GRDB 4 vs 5\nDESCRIPTION: Compares how to stop observations between GRDB 4 and 5, with GRDB 5 introducing a more explicit cancellation model using a DatabaseCancellable object.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nlet observer: TransactionObserver?\nobserver = observation.start(...)\nobserver = nil       // Stop the observation\n\n// NEW: GRDB 5\nlet cancellable: DatabaseCancellable\ncancellable = observation.start(...)\ncancellable.cancel() // Stop the observation\n```\n\n----------------------------------------\n\nTITLE: Implementing Unicode61 Tokenizer in FTS4\nDESCRIPTION: Configures the unicode61 tokenizer with options for handling diacritics in Unicode text matching.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS4()) { t in\n    t.tokenizer = .unicode61()\n    t.tokenizer = .unicode61(diacritics: .keep)\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating Authors with Book Count in Swift\nDESCRIPTION: Shows how to fetch authors along with their book counts using the count aggregate. This example demonstrates creating a dedicated struct to hold both the author data and the aggregate count value.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_90\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var bookCount: Int\n}\n\nlet request = Author.annotated(with: Author.books.count)\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n\nfor info in authorInfos {\n    print(\"\\(info.author.name) wrote \\(info.bookCount) book(s).\")\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Protocol Methods for Record Persistence in Swift\nDESCRIPTION: This snippet shows the addition of various persistence methods to a protocol, including update, insert, save, and delete operations that all accept a Database parameter.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_108\n\nLANGUAGE: swift\nCODE:\n```\nfunc update(_ db: Database, columns: Set<String>) throws\nfunc insert(_ db: Database) throws\nfunc save(_ db: Database) throws\n@discardableResult func delete(_ db: Database) throws -> Bool\n```\n\n----------------------------------------\n\nTITLE: Using SQLRequest with Cached Prepared Statements in Swift\nDESCRIPTION: This code demonstrates how to create an SQLRequest that reuses cached prepared statements for better performance. The cached parameter enables statement reuse.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_86\n\nLANGUAGE: swift\nCODE:\n```\nSQLRequest(\"SELECT ...\", cached: true)\n```\n\n----------------------------------------\n\nTITLE: Updating FetchableRecord.init(row:) to throw errors in Swift\nDESCRIPTION: This snippet shows how to update the FetchableRecord initializer to throw errors, which is now required in the new version of GRDB.swift. It includes changes for both standalone structs and subclasses of Record.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-let player = Player(row: row)\n+let player = try Player(row: row)\n```\n\nLANGUAGE: diff\nCODE:\n```\n class Player: Record {\n-    required init(row: Row) {\n+    required init(row: Row) throws {\n         self.id = row[\"id\"]\n         self.name = row[\"name\"]\n-        super.init(row: row)\n+        try super.init(row: row)\n     }\n }\n```\n\n----------------------------------------\n\nTITLE: Creating FTS5 Virtual Table with Custom Tokenizer in Swift\nDESCRIPTION: This snippet demonstrates how to create an FTS5 virtual table using a custom tokenizer, both with default settings and with specific arguments.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"documents\", using: FTS5()) { t in\n    // Wraps the default unicode61\n    t.tokenizer = MyTokenizer.tokenizerDescriptor()\n    t.column(\"content\")\n}\n\ntry db.create(virtualTable: \"documents\", using: FTS5()) { t in\n    // Wraps ascii\n    let ascii = FTS5TokenizerDescriptor.ascii()\n    t.tokenizer = MyTokenizer.tokenizerDescriptor(arguments: ascii.components)\n    t.column(\"content\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using HasManyThrough for Nested Associations in Swift\nDESCRIPTION: Demonstrates how to create shortcuts through nested associations, allowing a Document to directly access all Paragraphs through Section records. This simplifies data access across multiple levels of relationships.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nstruct Document: TableRecord {\n    static let sections = hasMany(Section.self)\n    static let paragraphs = hasMany(Paragraph.self, through: sections, using: Section.paragraphs)\n    ...\n}\n\nstruct Section: TableRecord {\n    static let paragraphs = hasMany(Paragraph.self)\n    ...\n}\n \nstruct Paragraph: TableRecord {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FTS4 Tables with Tokenizers in Swift\nDESCRIPTION: This snippet shows how to create an FTS4 table with a specific tokenizer. In this case, the Porter tokenizer is used which enables English stemming (matching related word forms).\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE VIRTUAL TABLE book USING fts4(\n//   tokenize=porter,\n//   author,\n//   title,\n//   body\n// )\ntry db.create(virtualTable: \"book\", using: FTS4()) { t in\n    t.tokenizer = .porter\n    t.column(\"author\")\n    t.column(\"title\")\n    t.column(\"body\")\n}\n```\n\n----------------------------------------\n\nTITLE: Full Text Search Configuration in Swift\nDESCRIPTION: Updates to FTS3 and FTS5 tokenizer configuration adding support for diacritic handling options.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_38\n\nLANGUAGE: swift\nCODE:\n```\nstruct FTS3 {\n    enum Diacritics {\n        case keep\n        case removeLegacy\n        #if GRDBCUSTOMSQLITE\n        case remove\n        #endif\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Column Integrity Checks in GRDB.swift\nDESCRIPTION: Demonstrates how to add CHECK constraints on columns to enforce data integrity rules using both Swift expressions and raw SQL.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n    // name TEXT CHECK (LENGTH(name) > 0)\n    // score INTEGER CHECK (score > 0)\n    t.column(\"name\", .text).check { length($0) > 0 }\n    t.column(\"score\", .integer).check(sql: \"score > 0\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Porter Tokenizer for FTS4\nDESCRIPTION: Sets up the Porter tokenizer which provides English word stemming capabilities to match different forms of words.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS4()) { t in\n    t.tokenizer = .porter\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom SQL Aggregate\nDESCRIPTION: Defines a 'MaxLength' aggregate that computes the maximum string length. Demonstrates the DatabaseAggregate protocol implementation with step and finalize methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_53\n\nLANGUAGE: swift\nCODE:\n```\nstruct MaxLength : DatabaseAggregate {\n    var maxLength: Int = 0\n    \n    mutating func step(_ dbValues: [DatabaseValue]) {\n        // At each step, extract string value, if any...\n        guard let string = String.fromDatabaseValue(dbValues[0]) else {\n            return\n        }\n        // ... and update the result\n        let length = string.count\n        if length > maxLength {\n            maxLength = length\n        }\n    }\n    \n    func finalize() -> DatabaseValueConvertible? {\n        maxLength\n    }\n}\n\nlet maxLength = DatabaseFunction(\n    \"maxLength\",\n    argumentCount: 1,\n    pure: true,\n    aggregate: MaxLength.self)\n```\n\n----------------------------------------\n\nTITLE: Registering Migration with Immediate Foreign Key Checks in Swift\nDESCRIPTION: Registers a database migration with immediate foreign key checks, which avoids temporarily disabling foreign keys and performs checks during the migration rather than afterward. This approach is faster but must only be used with schema alterations directly supported by SQLite.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"Fast migration\", foreignKeyChecks: .immediate) { db in ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Base Player Structure with Timestamps\nDESCRIPTION: Basic implementation of a Player structure that conforms to TimestampedRecord protocol, including properties for ID, timestamps, and player data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// The base Player type\nstruct Player {\n    var id: Int64?\n    var creationDate: Date?\n    var modificationDate: Date?\n    var name: String\n    var score: Int\n}\n\n// Add database powers (read, write, timestamps)\nextension Player: Codable, TimestampedRecord, FetchableRecord {\n    /// Update auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using AsyncConcurrentRead with DatabasePool in Swift\nDESCRIPTION: This snippet illustrates the use of asyncConcurrentRead to perform a non-blocking read operation after a write transaction. It allows other threads to write to the database while the read operation is being prepared.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\ntry dbPool.writeWithoutTransaction { db in\n    // Increment the number of players\n    try db.inTransaction {\n        try Player(...).insert(db)\n        return .commit\n    }\n    \n    // <- Not in a transaction here\n    dbPool.asyncConcurrentRead { dbResult in\n        do {\n            // Handle the new player count - guaranteed greater than zero\n            let db = try dbResult.get()\n            let newPlayerCount = try Player.fetchCount(db)\n        } catch {\n            // Handle error\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Definition of HasManyThrough Association in Swift\nDESCRIPTION: Shows a more explicit way to define a HasManyThrough association by directly referencing the associations used in the through and using parameters. This approach offers more clarity in complex relationship hierarchies.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nstruct Document: TableRecord {\n    static let paragraphs = hasMany(\n        Paragraph.self,\n        through: Document.hasMany(Section.self),\n        using: Section.hasMany(Paragraph.self))\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Database in GRDB 5\nDESCRIPTION: Demonstrates how the database configuration pattern has changed in GRDB 5, moving more functionality into the prepareDatabase method rather than setting properties and calling methods on the database queue.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nvar config = Configuration()\nconfig.trace = { ... }              // Tracing SQL statements\nconfig.prepareDatabase = { db in    // prepareDatabase was a property\n    ...                             // Custom setup\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\ndbQueue.add(function: ...)          // Custom SQL function\ndbQueue.add(collation: ...)         // Custom collation\ndbQueue.add(tokenizer: ...)         // Custom FTS5 tokenizer\n\n// NEW: GRDB 5\nvar config = Configuration()\nconfig.prepareDatabase { db in      // prepareDatabase is now a method\n    db.trace { ... }\n    db.add(function: ...)\n    db.add(collation: ...)\n    db.add(tokenizer: ...)\n    ...\n}\nlet dbQueue = try DatabaseQueue(dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: FetchRequest Interface Changes in GRDB.swift 4.1.0\nDESCRIPTION: Introduces a new PreparedRequest struct and updates the FetchRequest protocol to use makePreparedRequest instead of the deprecated prepare method, improving the API for preparing database queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_28\n\nLANGUAGE: swift\nCODE:\n```\n+struct PreparedRequest {\n+    var statement: SelectStatement\n+    var adapter: RowAdapter?\n+    init(statement: SelectStatement, adapter: RowAdapter? = nil)\n+}\n\n protocol FetchRequest {\n+    // deprecated\n     func prepare(_ db: Database, forSingleResult singleResult: Bool) throws -> (SelectStatement, RowAdapter?)\n+    func makePreparedRequest(_ db: Database, forSingleResult singleResult: Bool) throws -> PreparedRequest\n }\n```\n\n----------------------------------------\n\nTITLE: Fetching All Partial Associated Records with including(all:) in Swift\nDESCRIPTION: This example shows how to fetch an author with all associated books, but only including specific fields from the books. It uses a nested PartialBook struct to define the book fields to be fetched.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_49\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    struct PartialBook: Decodable {\n        var title: String\n        var year: Int\n    }\n    var author: Author       // The base record\n    var books: [PartialBook] // A collection of partial associated records\n}\n\nlet authorInfos = try Author\n    .including(all: Author.books.select(Column(\"title\"), Column(\"year\")))\n    .asRequest(of: AuthorInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Record Insertion with Timestamps\nDESCRIPTION: Example showing how timestamps are automatically set during record insertion.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // An inserted record has both a creation and a modification date.\n    var player = Player(name: \"Arthur\", score: 1000)\n    try player.insert(db)\n    player.creationDate     // not nil\n    player.modificationDate // not nil\n}\n```\n\n----------------------------------------\n\nTITLE: Complete TimestampedRecord Protocol Implementation\nDESCRIPTION: Full implementation of the TimestampedRecord protocol including all required methods and functionality for timestamp management.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n/// A record type that tracks its creation and modification dates. See\n/// <https://swiftpackageindex.com/groue/GRDB.swift/documentation/grdb/recordtimestamps>\nprotocol TimestampedRecord: MutablePersistableRecord {\n    var creationDate: Date? { get set }\n    var modificationDate: Date? { get set }\n}\n\nextension TimestampedRecord {\n    /// By default, `TimestampedRecord` types set `creationDate` and\n    /// `modificationDate` to the transaction date, if they are nil,\n    /// before insertion.\n    ///\n    /// `TimestampedRecord` types that customize the `willInsert`\n    /// persistence callback should call `initializeTimestamps` from\n    /// their implementation.\n    mutating func willInsert(_ db: Database) throws {\n        try initializeTimestamps(db)\n    }\n    \n    /// Sets `creationDate` and `modificationDate` to the transaction date,\n    /// if they are nil.\n    ///\n    /// It is called automatically before insertion, if your type does not\n    /// customize the `willInsert` persistence callback. If you customize\n    /// this callback, call `initializeTimestamps` from your implementation.\n    mutating func initializeTimestamps(_ db: Database) throws {\n        if creationDate == nil {\n            creationDate = try db.transactionDate\n        }\n        if modificationDate == nil {\n            modificationDate = try db.transactionDate\n        }\n    }\n    \n    /// Sets `modificationDate`, and executes an `UPDATE` statement\n    /// on all columns.\n    ///\n    /// - parameter modificationDate: The modification date. If nil, the\n    ///   transaction date is used.\n    mutating func updateWithTimestamp(_ db: Database, modificationDate: Date? = nil) throws {\n        self.modificationDate = try modificationDate ?? db.transactionDate\n        try update(db)\n    }\n    \n    /// Modifies the record according to the provided `modify` closure, and,\n    /// if and only if the record was modified, sets `modificationDate` and\n    /// executes an `UPDATE` statement that updates the modified columns.\n    ///\n    /// For example:\n    ///\n    /// ```swift\n    /// try dbQueue.write { db in\n    ///     var player = Player.find(db, id: 1)\n    ///     let modified = try player.updateChangesWithTimestamp(db) {\n    ///         $0.score = 1000\n    ///     }\n    ///     if modified {\n    ///         print(\"player was modified\")\n    ///     } else {\n    ///         print(\"player was not modified\")\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// - parameters:\n    ///     - db: A database connection.\n    ///     - modificationDate: The modification date. If nil, the\n    ///       transaction date is used.\n    ///     - modify: A closure that modifies the record.\n    /// - returns: Whether the record was changed and updated.\n    @discardableResult\n    mutating func updateChangesWithTimestamp(\n        _ db: Database,\n        modificationDate: Date? = nil,\n        modify: (inout Self) -> Void)\n    throws -> Bool\n    {\n        // Grab the changes performed by `modify`\n        let initialChanges = try databaseChanges(modify: modify)\n        if initialChanges.isEmpty {\n            return false\n        }\n        \n        // Update modification date and grab its column name\n        let dateChanges = try databaseChanges(modify: {\n            $0.modificationDate = try modificationDate ?? db.transactionDate\n        })\n        \n        // Update the modified columns\n        let modifiedColumns = Set(initialChanges.keys).union(dateChanges.keys)\n        try update(db, columns: modifiedColumns)\n        return true\n    }\n    \n    /// Sets `modificationDate`, and executes an `UPDATE` statement that\n    /// updates the `modificationDate` column, if and only if the record\n    /// was modified.\n    ///\n    /// - parameter modificationDate: The modification date. If nil, the\n    ///   transaction date is used.\n    mutating func touch(_ db: Database, modificationDate: Date? = nil) throws {\n        try updateChanges(db) {\n            $0.modificationDate = try modificationDate ?? db.transactionDate\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Limiting Deleted Rows in Query Interface\nDESCRIPTION: Shows how to limit the number of rows deleted using the query interface with ORDER BY and LIMIT clauses.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_61\n\nLANGUAGE: swift\nCODE:\n```\n// Delete the last ten players:\n// DELETE FROM players ORDER BY score LIMIT 10\nlet request = Player.order(scoreColumn).limit(10)\ntry request.deleteAll(db)\n```\n\n----------------------------------------\n\nTITLE: Defining FTS5WrapperTokenizer Protocol in Swift\nDESCRIPTION: This snippet defines the FTS5WrapperTokenizer protocol, which provides a high-level interface for custom tokenizers. It includes properties and methods that need to be implemented by conforming types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nprotocol FTS5WrapperTokenizer : FTS5CustomTokenizer {\n    var wrappedTokenizer: any FTS5Tokenizer { get }\n    func accept(\n        token: String,\n        flags: FTS5TokenFlags,\n        for tokenization: FTS5Tokenization,\n        tokenCallback: FTS5WrapperTokenCallback) throws\n}\n```\n\n----------------------------------------\n\nTITLE: Working with SQLExpression Type\nDESCRIPTION: Shows how to use SQLExpression for building complex SQLite expressions with proper type safety and composability.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\nfunc date(_ value: SQLSpecificExpressible) -> SQLExpression {\n    SQL(\"DATE(\\(value))\").sqlExpression\n}\n\n// SELECT * FROM player WHERE DATE(createdAt) = '2020-01-23'\nlet request = Player.filter(date(Column(\"createdAt\")) == \"2020-01-23\")\n\n// SELECT player.*, team.* FROM player\n// JOIN team ON team.id = player.teamId\n// WHERE DATE(player.createdAt) = '2020-01-23'\nlet request = Player\n    .filter(date(Column(\"createdAt\")) == \"2020-01-23\")\n    .including(required: Player.team)\n```\n\n----------------------------------------\n\nTITLE: Using Task to Ignore Cancellation in Async Database Operations\nDESCRIPTION: In GRDB 7, async database operations respect task cancellation. This snippet demonstrates how to ensure a database write completes regardless of task cancellation by wrapping it in an unstructured Task.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB7MigrationGuide.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// Create a new Task in order to ignore\n// cancellation of the current task, and\n// make sure database changes are always\n// committed to disk.\nlet task = Task {\n    try await writer.write { ... }\n}\n// If needed, wait for the database job to complete:\ntry await task.value\n```\n\n----------------------------------------\n\nTITLE: Creating Foreign Key References to Tables without Explicit Primary Keys\nDESCRIPTION: Demonstrates how to define references to tables without any explicit primary key by using the SQLite rowid hidden primary key column.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_79\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.inDatabase { db in\n    // CREATE TABLE nodes(\n    //   name TEXT,\n    //   parentId INTEGER REFERENCES nodes(rowid)\n    // )\n    try db.create(table: \"nodes\") { t in\n        t.column(\"name\", .text)\n        t.column(\"parentId\", .integer).references(\"nodes\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Indices with Collation in GRDB.swift\nDESCRIPTION: Shows how to create indices with specific collation options to control string comparison behavior.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE INDEX index_player_on_email ON player(email COLLATE NOCASE)\ntry db.create(\n    index: \"index_player_on_email\",\n    on: \"player\",\n    expressions: [Column(\"email\").collating(.nocase)])\n```\n\n----------------------------------------\n\nTITLE: Configuring ASCII Tokenizer in Swift\nDESCRIPTION: Demonstrates how to set up the ASCII tokenizer for FTS5 in GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS5()) { t in\n    t.tokenizer = .ascii()\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Fetching From DatabaseQueue in Swift\nDESCRIPTION: Demonstrates the simplified API for fetching data directly from database queues and pools without using an explicit closure. This makes database access code more concise.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_119\n\nLANGUAGE: swift\nCODE:\n```\n// Before:\nlet persons = dbQueue.inDatabase { db in\n    Person.fetchAll(db)\n}\n\n// New:\nlet persons = Person.fetchAll(dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Creating Shared In-Memory Databases with DatabaseQueue in Swift\nDESCRIPTION: Examples showing how to create multiple connections to the same in-memory database by providing a name for the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseQueue.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// A shared in-memory database\nlet dbQueue1 = try DatabaseQueue(named: \"myDatabase\")\n\n// Another connection to the same database\nlet dbQueue2 = try DatabaseQueue(named: \"myDatabase\")\n```\n\n----------------------------------------\n\nTITLE: Custom Ordering with Table Alias\nDESCRIPTION: Using table alias to control result ordering by author name and book publication date\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_71\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Book\n    .joining(required: Book.author.aliased(authorAlias))\n    .order(authorAlias[Column(\"name\")], Column(\"publishDate\"))\n```\n\n----------------------------------------\n\nTITLE: Interpolating Coding Keys in SQL Queries (Swift)\nDESCRIPTION: This snippet shows how to interpolate coding keys into SQL queries. It demonstrates selecting a column using a CodingKey.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_21\n\nLANGUAGE: Swift\nCODE:\n```\n// SELECT name FROM player\n\"SELECT \\(CodingKeys.name) FROM player\"\n```\n\n----------------------------------------\n\nTITLE: Creating Tables with Recommended Naming Conventions in Swift\nDESCRIPTION: Demonstrates how to create a database table with the recommended singular, camelCased naming convention. Following this pattern simplifies integration with GRDB by avoiding the need for explicit table name configurations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// RECOMMENDED\ntry db.create(table: \"player\") { t in\n    // table columns and constraints\n}\n\n// REQUIRES EXTRA CONFIGURATION\ntry db.create(table: \"players\") { t in\n    // table columns and constraints\n}\n```\n\n----------------------------------------\n\nTITLE: Updating DatabaseRegionObservation Start Method Implementation in Swift\nDESCRIPTION: Shows the migration from GRDB 5 to GRDB 6 for the DatabaseRegionObservation.start method, which now returns a cancellable object and handles errors through an onError parameter rather than throwing.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nlet observation = DatabaseRegionObservation.tracking(Player.all())\n\n// GRDB 5\ndo {\n    let observer = try observation.start(in: dbQueue) { db in\n        print(\"Players were modified\")\n    }\n} catch {\n    // handle error\n}\n\n// GRDB 6\nlet cancellable = observation.start(\n    in: dbQueue,\n    onError: { error in /* handle error */ },\n    onChange: { db in\n        print(\"Players were modified\")\n    })\n```\n\n----------------------------------------\n\nTITLE: Adding DatabaseReader and DatabaseWriter Type Erasure\nDESCRIPTION: Adds AnyDatabaseReader and AnyDatabaseWriter classes for type erasure of DatabaseReader and DatabaseWriter protocols.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_74\n\nLANGUAGE: diff\nCODE:\n```\n+final class AnyDatabaseReader : DatabaseReader {\n+     init(_ base: DatabaseReader)\n+}\n+final class AnyDatabaseWriter : DatabaseWriter {\n+     init(_ base: DatabaseWriter)\n+}\n```\n\n----------------------------------------\n\nTITLE: Annotating with Optional Associated Columns using annotated(withOptional:) in Swift\nDESCRIPTION: This example shows how to use annotated(withOptional:) to fetch a book with optional specific columns from the associated author record. It allows for more granular control over optionally fetched data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_47\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: Decodable, FetchableRecord {\n    var book: Book          // The base record\n    var authorName: String? // A column of the eventual associated record\n    var country: String?    // A column of the eventual associated record\n}\n\nlet bookInfos = try Book\n    .annotated(withOptional: Book.author.select(\n        Column(\"name\").forKey(\"authorName\"), \n        Column(\"country\")))\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Configuring GRDB Database for Suspension Notifications in Swift\nDESCRIPTION: Sets up a DatabasePool with observesSuspensionNotifications flag enabled, which allows the database to respond to app suspension events and prevent 0xDEAD10CC exceptions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nvar configuration = Configuration()\nconfiguration.observesSuspensionNotifications = true\nlet dbPool = try DatabasePool(path: ..., configuration: configuration)\n```\n\n----------------------------------------\n\nTITLE: Author Info Request with Multiple Aggregates\nDESCRIPTION: Shows how to compute multiple aggregates from the same association using shared association keys.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_102\n\nLANGUAGE: sql\nCODE:\n```\nSELECT author.*,\n       MIN(book.year) AS minBookYear,\n       MAX(book.year) AS maxBookYea\nFROM author\nLEFT JOIN book ON book.authorId = author.id\nGROUP BY author.id\n```\n\nLANGUAGE: swift\nCODE:\n```\nstruct Author: TableRecord {\n    static let books = hasMany(Book.self) // association key \"books\"\n}\n\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var minBookYear: Int?\n    var maxBookYear: Int?\n}\n\nlet request = Author.annotated(with:\n    Author.books.min(Column(\"year\")), // association key \"books\"\n    Author.books.max(Column(\"year\"))) // association key \"books\"\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Value Support in Swift\nDESCRIPTION: Adds extension methods to handle default values for configuration properties when stored values are null.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SingleRowTables.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nextension AppConfiguration {\n    var flag: Bool {\n        get { storedFlag ?? true /* the default value */ }\n        set { storedFlag = newValue }\n    }\n\n    mutating func resetFlag() {\n        storedFlag = nil\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Porter Tokenizer in Swift\nDESCRIPTION: Illustrates various configurations of the Porter tokenizer, including wrapping other tokenizers, in GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS5()) { t in\n    t.tokenizer = .porter()         // porter wrapping unicode61 (the default)\n    t.tokenizer = .porter(.ascii()) // porter wrapping ascii\n    t.tokenizer = .porter(.unicode61(diacritics: .keep)) // porter wrapping unicode61 without diacritics stripping\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Table Inflection for Special Record Types\nDESCRIPTION: GRDB 7 fixes inflection rules for tables named 'bias', 'focus', 'gas', and 'lens'. This example shows how to adjust associations to these record types when migrating to GRDB 7.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB7MigrationGuide.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nstruct Camera: TableRecord {\n    // GRDB 6: fix incorrect GRDB inflection\n    static let lenses = hasMany(Lens.self).forKey(\"lenses\")\n    // GRDB 7\n    static let lenses = hasMany(Lens.self)\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// Works in GRDB 6, breaks in GRDB 7\nstruct CameraWithLenses: Decodable, FetchableRecord {\n    var camera: Camera\n    var lens: [Lens] // <- incorrect pluralization\n}\nlet results = Camera\n    .including(all: Camera.lenses)\n    .asRequest(of: CameraWithLenses.self)\n    .fetchAll(db)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 7, alternative 1\nstruct CameraWithLenses: Decodable, FetchableRecord {\n    var camera: Camera\n    var lenses: [Lens] // <- fixed pluralization\n}\n\n// GRDB 7, alternative 2\nstruct Camera: TableRecord {\n    // Use \"lens\" instead of \"lenses\" for GRDB 6 compatibility.\n    static let lenses = hasMany(Lens.self).forKey(\"lens\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Tables with Foreign Key Relationships in GRDB Swift\nDESCRIPTION: This snippet demonstrates the recommended approach for creating database tables with proper foreign key constraints in GRDB.swift. It shows how to create a 'team' table and a 'player' table with a foreign key relationship using the belongsTo method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(table: \"team\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"color\", .text).notNull()\n}\n\n// RECOMMENDED\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"name\", .text).notNull()\n    // A player must refer to an existing team\n    t.belongsTo(\"team\").notNull()\n}\n\n// REQUIRES EXTRA CONFIGURATION\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"name\", .text).notNull()\n    // No foreign key\n    t.column(\"teamId\", .integer).notNull()\n}\n```\n\n----------------------------------------\n\nTITLE: Version 1.3.0 Integer Type Support\nDESCRIPTION: Adds support for all signed and unsigned integer types in version 1.3.0, allowing full range of integers to be stored and loaded from the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_76\n\nLANGUAGE: diff\nCODE:\n```\n+extension Int8: DatabaseValueConvertible, StatementColumnConvertible { }\n+extension Int16: DatabaseValueConvertible, StatementColumnConvertible { }\n+extension UInt8: DatabaseValueConvertible, StatementColumnConvertible { }\n+extension UInt16: DatabaseValueConvertible, StatementColumnConvertible { }\n+extension UInt32: DatabaseValueConvertible, StatementColumnConvertible { }\n+extension UInt64: DatabaseValueConvertible, StatementColumnConvertible { }\n+extension UInt: DatabaseValueConvertible, StatementColumnConvertible { }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Table Columns in GRDB.swift\nDESCRIPTION: This method retrieves information about columns in a specific table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_4\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/columns(in:in:)\n```\n\n----------------------------------------\n\nTITLE: Defining Columns with Raw SQL in GRDB.swift\nDESCRIPTION: Shows how to define columns using raw SQL strings and SQL literals, which allows safe embedding of raw values without risk of SQL injection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n    t.column(sql: \"name TEXT\")\n    \n    let defaultName: String = ...\n    t.column(literal: \"name TEXT DEFAULT \\(defaultName)\")\n```\n\n----------------------------------------\n\nTITLE: Checking and Saving RowModel Changes in Swift with GRDB\nDESCRIPTION: Shows how to check if a RowModel has been edited and save it to the database if changes are detected. This pattern helps prevent unnecessary database updates.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_125\n\nLANGUAGE: Swift\nCODE:\n```\nlet json = ...\n\n// Fetches or create a new person given its ID:\nlet person = Person.fetchOne(db, primaryKey: json[\"id\"]) ?? Person()\n\n// Apply json payload:\nperson.updateFromJSON(json)\n\n// Saves the person if it is edited (fetched then modified, or created):\nif person.isEdited {\n    person.save(db) // inserts or updates\n}\n```\n\n----------------------------------------\n\nTITLE: Creating FTS5 Virtual Table with Tokenizer in Swift\nDESCRIPTION: Demonstrates how to create a virtual table for full-text search using FTS5 with different tokenizer options in GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS5()) { t in\n    // Pick one:\n    t.tokenizer = .unicode61() // default\n    t.tokenizer = .unicode61(...)\n    t.tokenizer = .ascii\n    t.tokenizer = .porter(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Tracing SQL Statements in GRDB.swift\nDESCRIPTION: Sets up SQL statement tracing when opening a database connection. This helps debug issues where ValueObservation might not be detecting changes by showing all SQL statements executed against the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_229\n\nLANGUAGE: swift\nCODE:\n```\n// Prints all SQL statements\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.trace { print(\"SQL: \\($0)\") }\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Interpolating Orderings in SQL Queries (Swift)\nDESCRIPTION: This snippet shows how to interpolate orderings into SQL queries. It demonstrates ordering by a column in descending order.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_23\n\nLANGUAGE: Swift\nCODE:\n```\n// SELECT * FROM player ORDER BY name DESC\n\"SELECT * FROM player ORDER BY \\(Column(\"name\").desc)\"\n```\n\n----------------------------------------\n\nTITLE: Performing Unsafe Reentrant Database Reads\nDESCRIPTION: Shows how to perform unsafe reentrant reads with DatabasePool, which allows nested read operations within a read transaction.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_80\n\nLANGUAGE: swift\nCODE:\n```\ntry dbPool.read { db in\n    // This is allowed\n    try dbPool.unsafeReentrantRead { db in\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Request Extension Methods\nDESCRIPTION: Defining custom extension methods for DerivableRequest to create reusable query components\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_73\n\nLANGUAGE: swift\nCODE:\n```\nextension DerivableRequest<Author> {\n    func filter(country: String) -> Self {\n        filter(Column(\"country\") == country)\n    }\n}\n\nextension DerivableRequest<Book> {\n    func filter(authorCountry: String) -> Self {\n        joining(required: Book.author.filter(country: country))\n    }\n    \n    func orderedByAuthorNameAndYear() -> Self {\n        let authorAlias = TableAlias()\n        return self\n            .joining(optional: Book.author.aliased(authorAlias))\n            .order(\n                authorAlias[Column(\"name\")].collating(.localizedCaseInsensitiveCompare),\n                Column(\"year\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Complex Queries\nDESCRIPTION: Example of composing complex queries using the defined extension methods and association handling\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_74\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo: FetchableRecord, Decodable {\n    var book: Book\n    var author: Author\n}\n\nlet bookInfos = try Book.all()\n    .filter(authorCountry: \"FR\")\n    .orderedByAuthorNameAndYear()\n    .including(required: Book.author)\n    .asRequest(of: BookInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Query Interface Example in Swift\nDESCRIPTION: Illustrates the query interface that allows writing database queries in pure Swift instead of SQL. This example filters wines by origin and orders them by price.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_120\n\nLANGUAGE: swift\nCODE:\n```\nlet wines = Wine.filter(origin == \"Burgundy\").order(price).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Custom Request Function with SQLSubqueryable Parameter\nDESCRIPTION: Implementation of a custom request function that accepts a SQLSubqueryable parameter to create flexible query conditions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_25\n\nLANGUAGE: swift\nCODE:\n```\nfunc myRequest(_ nameSubquery: SQLSubqueryable) -> SQLRequest<Player> {\n    \"\"\"\n    SELECT * FROM player\n    WHERE name IN (\\(nameSubquery) UNION ...)\n    \"\"\"\n}\n\nmyRequest(SQLRequest(\"SELECT ...\"))\nmyRequest(Player.select(...).filter(...))\n```\n\n----------------------------------------\n\nTITLE: Catching SQLITE_BUSY Errors in Swift\nDESCRIPTION: This code snippet shows how to catch and handle SQLITE_BUSY errors that may occur when attempting to write to a shared database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ndo {\n    try dbPool.write { db in ... }\n} catch DatabaseError.SQLITE_BUSY {\n    // Another process won't let you write. Deal with it.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum-based Book Types\nDESCRIPTION: Shows how to use enums for book types with database integration.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: Codable {\n    enum Kind: String, Codable {\n        case essay, novel, poetry, theater\n    }\n    var id: Int64?\n    var authorId: Int64\n    var title: String\n    var kind: Kind\n}\n\nextension Book.Kind: DatabaseValueConvertible { }\n\n// Fetch all novels\nlet novels = try dbQueue.read { db in\n    try Book.filter(Column(\"kind\") == Book.Kind.novel).fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling NSNumber and Decimal Types in GRDB.swift\nDESCRIPTION: Shows examples of reading various numeric types from SQLite. This demonstrates how NSNumber, NSDecimalNumber, and Decimal can interpret integer, double, and string values from the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_42\n\nLANGUAGE: swift\nCODE:\n```\nlet number = try NSNumber.fetchOne(db, sql: \"SELECT 10\")            // NSNumber\nlet number = try NSDecimalNumber.fetchOne(db, sql: \"SELECT 1.23\")   // NSDecimalNumber\nlet number = try Decimal.fetchOne(db, sql: \"SELECT -100\")           // Decimal\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Record Structures in Swift\nDESCRIPTION: Defines simple Author and Book structs representing database records with basic properties.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nstruct Author {\n    var id: Int64\n    var name: String\n}\n\nstruct Book {\n    var id: Int64\n    var authorId: Int64?\n    var title: String\n}\n```\n\n----------------------------------------\n\nTITLE: Composing the Final Request with CTE and Association\nDESCRIPTION: Constructs the complete request that uses the CTE and association to retrieve ChatInfo objects containing chats with their optional latest messages.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n// WITH latestMessage AS\n//   (SELECT *, MAX(date) FROM message GROUP BY chatID)\n// SELECT chat.*, latestMessage.*\n// FROM chat\n// LEFT JOIN latestMessage ON chat.id = latestMessage.chatID\n// ORDER BY latestMessage.date DESC\nlet request = Chat\n    .with(latestMessageCTE)\n    .including(optional: latestMessage)\n    .asRequest(of: ChatInfo.self)\n```\n\n----------------------------------------\n\nTITLE: Managing Passphrase Lifetime in Swift with GRDB\nDESCRIPTION: Demonstrates recommended techniques for minimizing the time a database passphrase remains in memory. Shows both a non-recommended approach that keeps the passphrase in memory longer than necessary and the recommended approach that loads the passphrase only when needed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_190\n\nLANGUAGE: swift\nCODE:\n```\n// NOT RECOMMENDED: this keeps the passphrase in memory longer than necessary\nlet passphrase = try getPassphrase()\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    try db.usePassphrase(passphrase)\n}\n\n// RECOMMENDED: only load the passphrase when it is needed\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    let passphrase = try getPassphrase()\n    try db.usePassphrase(passphrase)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Trigger Existence in GRDB.swift\nDESCRIPTION: This method checks if a specific trigger exists in the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/triggerExists(_:in:)\n```\n\n----------------------------------------\n\nTITLE: Creating DatabaseValue Objects in Swift\nDESCRIPTION: Shows how to create DatabaseValue objects from various DatabaseValueConvertible types for use in SQL expressions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n1.databaseValue\n\"Hello\".databaseValue\nDatabaseValue.null\n```\n\n----------------------------------------\n\nTITLE: Optional Joining with Authors\nDESCRIPTION: Demonstrates how to create a LEFT JOIN with authors without including author data in results.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_41\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT book.*\n// FROM book \n// LEFT JOIN author ON author.id = book.authorId\nlet request = Book.joining(optional: Book.author)\n```\n\n----------------------------------------\n\nTITLE: Using Combine Publishers with GRDB for Asynchronous Database Access\nDESCRIPTION: Shows how to create Combine publishers for asynchronous database operations. These publishers don't access the database until subscribed and complete on the main dispatch queue by default.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet playerCountPublisher = dbQueue.readPublisher { db in\n    try Player.fetchCount(db)\n}\n\nlet newPlayerCountPublisher = dbQueue.writePublisher { db -> Int in\n    try Player(name: \"Arthur\").insert(db)\n    return try Player.fetchCount(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Database Table with Auto-increment and Default Values\nDESCRIPTION: Shows how to create a database table with an auto-incremented primary key and default values. This setup is used to demonstrate the RETURNING clause functionality.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_84\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    try db.execute(sql: \"\"\"\n        CREATE TABLE player(\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          name TEXT NOT NULL,\n          score INTEGER NOT NULL DEFAULT 1000)\n        \"\"\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using String Case Transformation Functions in GRDB\nDESCRIPTION: Example of using Swift's string case transformation functions in GRDB queries. GRDB extends SQLite with functions that map to Swift's string case methods like uppercased().\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_165\n\nLANGUAGE: swift\nCODE:\n```\nPlayer.select(nameColumn.uppercased())\n```\n\n----------------------------------------\n\nTITLE: Releasing memory in GRDB database connections\nDESCRIPTION: This example shows how to reclaim non-essential memory used by SQLite and GRDB for better performance, using the synchronous releaseMemory method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_217\n\nLANGUAGE: swift\nCODE:\n```\n// Release as much memory as possible.\ndbQueue.releaseMemory()\ndbPool.releaseMemory()\n```\n\n----------------------------------------\n\nTITLE: Configuration and Database Class API Changes\nDESCRIPTION: API diff showing additions to the Configuration struct and Database class, including new flags for notifications and string literals, as well as suspension-related notifications.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_22\n\nLANGUAGE: diff\nCODE:\n```\n struct Configuration {\n+    var observesSuspensionNotifications: Bool // Experimental\n+    var acceptsDoubleQuotedStringLiterals: Bool\n }\n\n class Database {\n+    static let suspendNotification: Notification.Name // Experimental\n+    static let resumeNotification: Notification.Name  // Experimental\n }\n```\n\n----------------------------------------\n\nTITLE: Improving SQL Generation with Columns in Swift\nDESCRIPTION: Demonstrates how using Column expressions enables GRDB to generate more efficient SQL by intelligently applying LIMIT clauses based on primary key usage.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// Nicer SQL\n// SELECT * FROM player WHERE id = 1\ntry Player.fetchOne(db, id: 1)\ntry Player.filter(Column(\"id\") == 1).fetchOne(db)\n\n// Less nice SQL\n// SELECT * FROM player WHERE id = 1 LIMIT 1\ntry Player.filter(sql: \"id = 1\").fetchOne(db)\n```\n\n----------------------------------------\n\nTITLE: Updating Records with Closure in Swift\nDESCRIPTION: A concise way to update a record in the database. The code does not hit the database if the player is not modified, making it more efficient than traditional update methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_39\n\nLANGUAGE: swift\nCODE:\n```\n// Does not hit the database if player is not modified\ntry player.update(db) {\n    $0.score = 1000\n    $0.hasAward = true\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Eager Loaded Rows with Enhanced Row Class in Swift\nDESCRIPTION: Adds functionality to the Row class for accessing eager loaded associated records. The new prefetchedRows property and subscript methods allow retrieving associated collections that were previously loaded through eager loading.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_32\n\nLANGUAGE: swift\nCODE:\n```\n class Row {\n+    var prefetchedRows: Row.PrefetchedRowsView { get }\n+    subscript<Collection>(_ key: String) -> Collection where Collection: RangeReplaceableCollection, Collection.Element: FetchableRecord { get }\n+    subscript<Record: FetchableRecord & Hashable>(_ key: String) -> Set<Record> { get }\n }\n\n extension Row {\n+    struct PrefetchedRowsView: Equatable {\n+       var isEmpty: Bool { get }\n+       var keys: Set<String> { get }\n+       subscript(_ key: String) -> [Row]? { get }\n+    }\n }\n```\n\n----------------------------------------\n\nTITLE: Fixing Type Inference in Query Interface after GRDB Refactoring\nDESCRIPTION: Shows how to fix code that no longer compiles due to type inference changes after the query interface refactoring in version 5.4.0, by adding explicit type annotations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n// No longer compiles\nlet values = [Column(\"score\"), Column(\"score\") + Column(\"bonus\")]\n```\n\nLANGUAGE: swift\nCODE:\n```\n// A possible fix\nlet values: [SQLExpressible] = [Column(\"score\"), Column(\"score\") + Column(\"bonus\")]\n```\n\n----------------------------------------\n\nTITLE: Using Custom UUID Encoding with Proper Query Techniques\nDESCRIPTION: Demonstrates how to implement and use custom UUID encoding strategies while ensuring queries are constructed correctly. Shows both correct and incorrect approaches to querying when UUIDs are stored as strings rather than blobs.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_100\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player: Codable, FetchableRecord, PersistableRecord, Identifiable {\n    // UUIDs are stored as strings\n    static func databaseUUIDEncodingStrategy(for column: String) -> DatabaseUUIDEncodingStrategy {\n        .uppercaseString\n    }\n    \n    var id: UUID\n    ...\n}\n\ntry dbQueue.write { db in\n    let uuid = UUID()\n    let player = Player(id: uuid, ...)\n    \n    // OK: inserts a player in the database, with a string uuid\n    try player.insert(db)\n    \n    // OK: performs a string-based query, finds the inserted player\n    _ = try Player.filter(id: uuid).fetchOne(db)\n\n    // NOT OK: performs a blob-based query, fails to find the inserted player\n    _ = try Player.filter(Column(\"id\") == uuid).fetchOne(db)\n    \n    // OK: performs a string-based query, finds the inserted player\n    _ = try Player.filter(Column(\"id\") == uuid.uuidString).fetchOne(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Raw Database and Statement Pointers\nDESCRIPTION: Demonstrates how to obtain the raw SQLite C pointers for database connections and prepared statements from GRDB objects.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_57\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    // The raw pointer to a database connection:\n    let sqliteConnection = db.sqliteConnection\n\n    // The raw pointer to a statement:\n    let statement = try db.makeStatement(sql: \"SELECT ...\")\n    let sqliteStatement = statement.sqliteStatement\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Authors by Book Publication Year in Swift\nDESCRIPTION: Demonstrates filtering authors based on the maximum value of a column in associated records, specifically finding authors who wrote books after 2010.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_97\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author.having(Author.books.max(Column(\"year\")) >= 2010)\n```\n\n----------------------------------------\n\nTITLE: Database Operations Without Closures in Swift\nDESCRIPTION: Shows the updated API for database operations that no longer require a closure. This example compares the older syntax that used closures with the newer, more direct approach.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_117\n\nLANGUAGE: swift\nCODE:\n```\n// Before:\ntry dbQueue.inDatabase { db in\n    try db.execute(\"CREATE TABLE ...\")\n    let person = Person(...)\n    try person.insert(db)\n}\n\n// New:\ntry dbQueue.execute(\"CREATE TABLE ...\")\nlet person = Person(...)\ntry person.insert(dbQueue)\n```\n\n----------------------------------------\n\nTITLE: Checking SQLite Internal Table in GRDB.swift\nDESCRIPTION: This method checks if a table is a SQLite internal table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_10\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/isSQLiteInternalTable(_:)\n```\n\n----------------------------------------\n\nTITLE: Defining Association Sub-protocols in Swift\nDESCRIPTION: Defines two specialized association sub-protocols: AssociationToOne and AssociationToMany, which are used for different types of relationships between database entities.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nprotocol AssociationToOne: Association { }\nprotocol AssociationToMany: Association { }\n```\n\n----------------------------------------\n\nTITLE: Using DatabaseRegionObservation in Swift\nDESCRIPTION: Demonstrates how to use DatabaseRegionObservation to track changes to a specific database region defined by a request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Player.all()\nlet observation = DatabaseRegionObservation(tracking: request)\nlet observer = try observation.start(in: dbQueue) { (db: Database) in\n    print(\"Players were changed\")\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Foreign Key for BelongsTo Association in GRDB Swift\nDESCRIPTION: Shows how to define a BelongsTo association when the database schema doesn't follow GRDB conventions. Requires manually specifying the foreign key relationship.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\nstruct Book: TableRecord {\n    static let author = belongsTo(Author.self, using: ForeignKey(...))\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Transactional Database Access in GRDB\nDESCRIPTION: Examples of database operations without transaction protection using writeWithoutTransaction and unsafeRead methods. Shows potential risks of operating without transaction safety.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Transactions.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.writeWithoutTransaction { db in\n    try Credit(destinationAccount, amount).insert(db)\n    try Debit(sourceAccount, amount).insert(db)\n}\n\nlet (credits, debits) = try dbPool.unsafeRead { db in\n    let credits = try Credit.fetchAll(db)\n    let debits = try Debit.fetchAll(db)\n    return (credits, debits)\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting SQL and Arguments from SQL Literal in Swift\nDESCRIPTION: Example showing how to extract the plain SQL string and its arguments from a SQL literal using the build method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    let query: SQL = \"UPDATE player SET name = \\(name) WHERE id = \\(id)\"\n    let (sql, arguments) = try query.build(db)\n    print(sql)       // prints \"UPDATE player SET name = ? WHERE id = ?\"\n    print(arguments) // prints [\"O'Brien\", 42]\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Deferred Foreign Key Checks for All Migrations in Swift\nDESCRIPTION: Configures the migrator to stop performing deferred foreign key checks for all newly registered migrations, which makes migrations run faster but requires the app to prevent foreign key violations manually.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nmigrator = migrator.disablingDeferredForeignKeyChecks()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Column.rowID Access with Swift 5.5+ Syntax\nDESCRIPTION: Shows how to access Column.rowID using enhanced subscript syntax available in Swift 5.5+, allowing for more concise code when accessing the rowID column in Row and PersistenceContainer objects.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nrow[.rowID]\n```\n\nLANGUAGE: swift\nCODE:\n```\ncontainer[.rowID]\n```\n\n----------------------------------------\n\nTITLE: Implementing Eager Loading with GRDB in Swift\nDESCRIPTION: This snippet demonstrates GRDB's approach to eager loading. It uses a dedicated record type (LiteraryCareer) to model the relationship between authors and books, providing runtime safety and explicit loading of relationships.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_22\n\nLANGUAGE: swift\nCODE:\n```\n// Eager loading with GRDB\nstruct LiteraryCareer: Codable, FetchableRecord {\n    var author: Author\n    var books: [Book]\n}\n\nlet request = Author.all()\n    .including(all: Author.books) // <- Explicit request for books\n    .asRequest(of: LiteraryCareer.self)\n\n// Fetch first author and its books in one stroke\nif let career = try request.fetchOne(db) {\n    print(career.author.name)\n    for book in career.books { print(book.title) } \n}\n```\n\n----------------------------------------\n\nTITLE: Converting DatabaseRegionObservation to a Combine Publisher in Swift\nDESCRIPTION: This example shows how to convert a DatabaseRegionObservation into a Combine publisher, which can be integrated with other Combine operations. The publisher emits the database instance whenever changes are detected.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/DatabaseRegionObservation.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet cancellable = observation.publisher(in: dbQueue).sink { completion in\n    // Handle completion\n} receiveValue: { (db: Database) in\n    print(\"Players were changed\")\n}\n```\n\n----------------------------------------\n\nTITLE: Tokenizing Strings with FTS5 in Swift\nDESCRIPTION: Shows how to tokenize queries and documents using a specified tokenizer in GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\nlet ascii = try db.makeTokenizer(.ascii())\n\n// Tokenize an FTS5 query\nfor (token, flags) in try ascii.tokenize(query: \"SQLite database\") {\n    print(token) // Prints \"sqlite\" then \"database\"\n}\n\n// Tokenize an FTS5 document\nfor (token, flags) in try ascii.tokenize(document: \"SQLite database\") {\n    print(token) // Prints \"sqlite\" then \"database\"\n}\n```\n\n----------------------------------------\n\nTITLE: Using explicit collations in SQL and query interface\nDESCRIPTION: This example demonstrates how to explicitly specify collations in both raw SQL queries and using the query interface, useful when column-level collations aren't defined.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_215\n\nLANGUAGE: swift\nCODE:\n```\nlet collation = DatabaseCollation.localizedCaseInsensitiveCompare\nlet players = try Player.fetchAll(db,\n    sql: \"SELECT * FROM player ORDER BY name COLLATE \\(collation.name))\")\nlet players = try Player.order(nameColumn.collating(collation)).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Embedding and Using CTEs in Queries\nDESCRIPTION: Demonstrates how to embed CTEs in queries and use them in filtering conditions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet name = \"O'Brien\"\nlet playerNameCTE = CommonTableExpression(\n    named: \"playerName\", \n    literal: \"SELECT \\(name)\")\n\nlet request = Player\n    .with(playerNameCTE)\n    .filter(Column(\"name\") == playerNameCTE.all())\n```\n\n----------------------------------------\n\nTITLE: Handling Passphrase Availability with System Keychain in Swift\nDESCRIPTION: Demonstrates how to access a passphrase from the system keychain and handle situations where the passphrase might not be available. This pattern is useful for implementing proper security with kSecAttrAccessible protection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_193\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    let passphrase = try loadPassphraseFromSystemKeychain()\n    try db.usePassphrase(passphrase)\n}\n\n// Success if and only if the passphrase is available\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Table Name with TableRecord in Swift using GRDB\nDESCRIPTION: Demonstrates how to provide a custom database table name when implementing the TableRecord protocol, instead of using the auto-derived name.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_73\n\nLANGUAGE: swift\nCODE:\n```\nstruct Place: TableRecord {\n    static let databaseTableName = \"location\"\n}\n\nprint(Place.databaseTableName) // prints \"location\"\n```\n\n----------------------------------------\n\nTITLE: Using Columns to Access Row Data in Swift\nDESCRIPTION: Demonstrates how to use Column objects to extract data from database rows after executing SQL queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nlet row = try Row.fetchOne(db, sql: \"SELECT 'Arthur' AS name\")!\nlet name: String = row[Column(\"name\")] // \"Arthur\"\n```\n\n----------------------------------------\n\nTITLE: Using SQL Interpolation for Record Columns in GRDB 5\nDESCRIPTION: Demonstrates how to migrate from the removed TableRecord.selectionSQL() method to the new SQL interpolation approach with columnsOf: parameter for embedding record columns in SQL requests.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nlet sql = \"SELECT \\(Player.selectionSQL()) FROM player\"\nlet players = try Player.fetchAll(db, sql: sql)\n \n// NEW: GRDB 5\nlet request: SQLRequest<Player> = \"SELECT \\(columnsOf: Player.self) FROM player\"\nlet players = try request.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Creating Tables with Recommended Column Naming in Swift\nDESCRIPTION: Demonstrates how to create a database table with camelCased column names that match Swift property names. Following this pattern simplifies Codable record type integration.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaRecommendations.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// RECOMMENDED\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"fullName\", .text).notNull()\n    t.column(\"score\", .integer).notNull()\n    t.column(\"creationDate\", .datetime).notNull()\n}\n\n// REQUIRES EXTRA CONFIGURATION\ntry db.create(table: \"player\") { t in\n    t.autoIncrementedPrimaryKey(\"id\")\n    t.column(\"full_name\", .text).notNull()\n    t.column(\"score\", .integer).notNull()\n    t.column(\"creation_date\", .datetime).notNull()\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing DatabaseValue from Row in Swift\nDESCRIPTION: Demonstrates the updated syntax for accessing DatabaseValue from a Row object after the removal of databaseValue methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_100\n\nLANGUAGE: swift\nCODE:\n```\nlet dbValue: DatabaseValue = row[0]\n```\n\n----------------------------------------\n\nTITLE: Creating Column Indexes in GRDB.swift\nDESCRIPTION: Shows how to create an index on a column inline during table creation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n    t.column(\"score\", .integer).indexed()\n```\n\n----------------------------------------\n\nTITLE: Extracting Raw SQL from Requests using makePreparedRequest in GRDB 5\nDESCRIPTION: Shows how to extract raw SQL and arguments from SQLRequest or QueryInterfaceRequest in GRDB 5 using the new makePreparedRequest method. This replaces the previous direct access to sql and arguments properties.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\ntry dbQueue.read { db in\n    let request = Player.filter(Column(\"name\") == \"O'Brien\")\n    let sqlRequest = try SQLRequest(db, request: request)\n    print(sqlRequest.sql)       // \"SELECT * FROM player WHERE name = ?\"\n    print(sqlRequest.arguments) // [\"O'Brien\"]\n}\n \n// NEW: GRDB 5\ntry dbQueue.read { db in\n    let request = Player.filter(Column(\"name\") == \"O'Brien\")\n    let statement = try request.makePreparedRequest(db, forSingleResult: false).statement\n    print(statement.sql)        // \"SELECT * FROM player WHERE name = ?\"\n    print(statement.arguments)  // [\"O'Brien\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Raw SQL from SQL Literals in GRDB 5\nDESCRIPTION: Illustrates how to extract raw SQL and arguments from an SQL literal in GRDB 5, which now requires a database connection. The SQL type replaces SQLLiteral, and extraction happens through the build method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nlet query: SQLLiteral = \"UPDATE player SET name = \\(name) WHERE id = \\(id)\"\nprint(query.sql)       // prints \"UPDATE player SET name = ? WHERE id = ?\"\nprint(query.arguments) // prints [\"O'Brien\", 42]\n \n// NEW: GRDB 5\nlet query: SQL = \"UPDATE player SET name = \\(name) WHERE id = \\(id)\"\nlet (sql, arguments) = try dbQueue.read { db in\n    try query.build(db)\n}\nprint(sql)             // prints \"UPDATE player SET name = ? WHERE id = ?\"\nprint(arguments)       // prints [\"O'Brien\", 42]\n```\n\n----------------------------------------\n\nTITLE: Fetching Cookie Count with DatabasePool in Swift\nDESCRIPTION: This snippet demonstrates how to read the count of cookies from a database using DatabasePool. It highlights that the fetched value should be considered stale immediately after retrieval due to potential concurrent modifications.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nlet cookieCount = dbPool.read { db in\n    try Cookie.fetchCount(db)\n}\n\n// At this point, the number of cookies on disk\n// may have already changed.\nprint(\"We have \\(cookieCount) cookies left\")\n```\n\n----------------------------------------\n\nTITLE: Registering Unchecked Migration After Disabling Deferred Checks in Swift\nDESCRIPTION: Shows how to register a migration after disabling deferred foreign key checks, which makes the migration faster but requires manual handling of potential foreign key violations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nmigrator = migrator.disablingDeferredForeignKeyChecks()\nmigrator.registerMigration(\"Fast but unchecked migration\") { db in ... }\n```\n\n----------------------------------------\n\nTITLE: DatabaseMigrator API Changes in Swift\nDESCRIPTION: Shows additions to DatabaseMigrator struct and DatabaseWriter extension including new eraseDatabaseOnSchemaChange property and erase/vacuum methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_47\n\nLANGUAGE: diff\nCODE:\n```\n struct DatabaseMigrator {\n+    var eraseDatabaseOnSchemaChange: Bool\n }\n \n extension DatabaseWriter {\n+    func erase() throws\n+    func vacuum() throws\n }\n```\n\n----------------------------------------\n\nTITLE: Interrupting Database Operations in Swift with GRDB\nDESCRIPTION: Shows how to interrupt ongoing database operations using the interrupt() method. This can be used to terminate long-running queries from any thread, with examples of handling the resulting errors.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_198\n\nLANGUAGE: swift\nCODE:\n```\ndbQueue.interrupt()\ndbPool.interrupt()\n```\n\n----------------------------------------\n\nTITLE: Adding Columns with Different Data Types in GRDB.swift\nDESCRIPTION: Examples of adding columns with various data types including text, datetime, and JSON. Shows the basic column definition syntax in table creation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaModifications.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n// CREATE TABLE player (\n//   score,\n//   name TEXT,\n//   creationDate DATETIME,\n//   address TEXT,\ntry db.create(table: \"player\") { t in\n    t.column(\"score\")\n    t.column(\"name\", .text)\n    t.column(\"creationDate\", .datetime)\n    t.column(\"address\", .json)\n```\n\n----------------------------------------\n\nTITLE: Registering Migration with Immediate Checks After Disabling Deferred Checks in Swift\nDESCRIPTION: Demonstrates how to register a migration with immediate foreign key checks after disabling deferred checks, which provides both performance benefits and maintains data integrity for supported schema alterations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nmigrator = migrator.disablingDeferredForeignKeyChecks()\nmigrator.registerMigration(\"Fast and checked migration\", foreignKeyChecks: .immediate) { db in ... }\n```\n\n----------------------------------------\n\nTITLE: SQL Function API Modernization\nDESCRIPTION: Updates to SQL function management API with renamed methods and property names following Swift 3 naming conventions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_104\n\nLANGUAGE: diff\nCODE:\n```\n class Database {\n-    func addFunction(function: DatabaseFunction)\n-    func removeFunction(function: DatabaseFunction)\n+    func add(function: DatabaseFunction)\n+    func remove(function: DatabaseFunction)\n }\n```\n\n----------------------------------------\n\nTITLE: Database Backup with Progress Reporting in Swift\nDESCRIPTION: Demonstrates how to implement progress reporting during database backup operations. This technique allows tracking backup progress and potentially aborting incomplete backups through step-by-step page copying.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_197\n\nLANGUAGE: swift\nCODE:\n```\ntry source.backup(\n    to: destination,\n    pagesPerStep: ...)\n    { backupProgress in\n       print(\"Database backup progress:\", backupProgress)\n    }\n```\n\n----------------------------------------\n\nTITLE: Customizing Association Keys for Debugging in GRDB.swift\nDESCRIPTION: Demonstrates how to customize association keys using the forKey method and inspect the resulting row structure. This is useful when troubleshooting association key mapping issues.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_87\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Book\n    .including(optional: Book.author.forKey(\"writer\")) // customized association key\n\nlet rows = try Row.fetchAll(db, request)\nprint(rows[0].debugDescription)\n// Prints:\n// ▿ [id:1, authorId:2, title:\"Moby-Dick\"]\n//   unadapted: [id:1, authorId:2, title:\"Moby-Dick\", id:2, name:\"Herman Melville\"]\n//   - writer: [id:2, name:\"Herman Melville\", countryCode:\"US\"]\n```\n\n----------------------------------------\n\nTITLE: Renaming Foreign Keys in GRDB.swift Migrations\nDESCRIPTION: This snippet shows how to rename a foreign key in a migration using immediate foreign key checks to maintain database integrity.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// IMPORTANT: rename foreign keys with immediate foreign key checks.\nmigrator.registerMigration(\"Guilds\", foreignKeyChecks: .immediate) { db in\n    try db.rename(table: \"team\", to: \"guild\")\n    \n    try db.alter(table: \"player\") { t in\n        // Rename a foreign key\n        t.rename(column: \"teamId\", to: \"guildId\")\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CTE with Explicit Columns\nDESCRIPTION: Creates a CTE with explicitly named columns 'a' and 'b'.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nlet pairCTE = CommonTableExpression(\n    named: \"pair\", \n    columns: [\"a\", \"b\"], \n    sql: \"SELECT 1, 2\")\n```\n\n----------------------------------------\n\nTITLE: Defining DatabaseValueConvertible Protocol in Swift\nDESCRIPTION: Protocol definition for DatabaseValueConvertible which enables types to be converted to and from DatabaseValue for database storage and retrieval.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nprotocol DatabaseValueConvertible: SQLExpressible {\n    /// Returns a value that can be stored in the database.\n    var databaseValue: DatabaseValue { get }\n    \n    /// Returns a value initialized from `dbValue`, if possible.\n    static func fromDatabaseValue(_ dbValue: DatabaseValue) -> Self?\n}\n```\n\n----------------------------------------\n\nTITLE: Database Value Conversion Updates\nDESCRIPTION: Changes to DatabaseValue protocol and value conversion methods, adding support for Data, Date, URL, and UUID types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_103\n\nLANGUAGE: diff\nCODE:\n```\n struct DatabaseValue {\n-    init?(object: AnyObject)\n-    func toAnyObject() -> AnyObject\n+    init?(value: Any)\n }\n protocol DatabaseValueConvertible {\n-    static func fromDatabaseValue(dbValue: DatabaseValue) -> DatabaseValue?\n+    static func fromDatabaseValue(_ dbValue: DatabaseValue) -> DatabaseValue?\n }\n+extension Data : DatabaseValueConvertible\n+extension Date : DatabaseValueConvertible\n+extension URL : DatabaseValueConvertible\n+extension UUID : DatabaseValueConvertible\n```\n\n----------------------------------------\n\nTITLE: Defining custom string collations in GRDB\nDESCRIPTION: This snippet shows how to create custom collations for string comparison and make them available to a database connection by configuring the database connection.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_216\n\nLANGUAGE: swift\nCODE:\n```\nlet collation = DatabaseCollation(\"customCollation\") { (lhs, rhs) -> NSComparisonResult in\n    // return the comparison of lhs and rhs strings.\n}\n\n// Make the collation available to a database connection\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.add(collation: collation)\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Adding Untyped Column to Table in Swift using GRDB's Alteration API\nDESCRIPTION: Demonstrates how to add an untyped column to an existing table using GRDB's table alteration API. This functionality was introduced in version 2.4.0.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_55\n\nLANGUAGE: Swift\nCODE:\n```\ntry db.alter(table: \"players\") { t in\n    t.add(column: \"score\")\n}\n```\n\n----------------------------------------\n\nTITLE: Starting ValueObservation in GRDB 5\nDESCRIPTION: Shows how the start method has changed in GRDB 5, returning a DatabaseCancellable object that allows explicit cancellation, and requiring an onError handler.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// Start observing the database\nlet cancellable = observation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { value in print(\"fresh value: \\(value)\") })\n```\n\n----------------------------------------\n\nTITLE: Query Interface Enhancements in GRDB.swift 3.3.0-beta1\nDESCRIPTION: New methods to set the selection and fetched type in a single call, allowing for more concise and type-safe query construction.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_45\n\nLANGUAGE: diff\nCODE:\n```\n extension QueryInterfaceRequest {\n+    func select<RowDecoder>(_ selection: [SQLSelectable], as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n+    func select<RowDecoder>(_ selection: SQLSelectable..., as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n+    func select<RowDecoder>(sql: String, arguments: StatementArguments? = nil, as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n }\n \n extension TableRecord {\n+    static func select<RowDecoder>(_ selection: [SQLSelectable], as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n+    static func select<RowDecoder>(_ selection: SQLSelectable..., as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n+    static func select<RowDecoder>(sql: String, arguments: StatementArguments? = nil, as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n }\n```\n\n----------------------------------------\n\nTITLE: Secure Passphrase Handling with Data in Swift\nDESCRIPTION: Demonstrates an improved approach to passphrase management using Swift's Data type, which provides the resetBytes function. This technique allows for explicit clearing of passphrase data from memory immediately after use.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_191\n\nLANGUAGE: swift\nCODE:\n```\n// RECOMMENDED: only load the passphrase when it is needed and reset its content immediately after use\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    var passphraseData = try getPassphraseData() // Data\n    defer {\n        passphraseData.resetBytes(in: 0..<passphraseData.count)\n    }\n    try db.usePassphrase(passphraseData)\n}\n```\n\n----------------------------------------\n\nTITLE: Adapting Requests with Row Adapters in Swift\nDESCRIPTION: Demonstrates how to use the adapted method to modify a request with a row adapter, mapping columns between different schemas.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_94\n\nLANGUAGE: Swift\nCODE:\n```\n// Person has `email` column, but User expects `identifier` column:\nPerson.all()\n    .adapted { _ in ColumnMapping([\"identifier\": \"email\"]) }\n    .bound(to: User.self)\n```\n\n----------------------------------------\n\nTITLE: Querying Schema Version in GRDB.swift\nDESCRIPTION: This method retrieves the current schema version of the database.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/schemaVersion()\n```\n\n----------------------------------------\n\nTITLE: Fetching Books for an Author Without Associations\nDESCRIPTION: Demonstrates how to fetch books for a specific author without using GRDB associations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nlet author: Author = ...\nlet books = try Book\n    .filter(Column(\"authorId\") == author.id)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Creating Indexed Columns in Tables\nDESCRIPTION: Shows how to create a non-unique index on a table column using the indexed() method during table creation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_78\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.inDatabase { db in\n    // CREATE TABLE rounds(score INTEGER)\n    // CREATE INDEX rounds_on_score ON rounds(score)\n    try db.create(table: \"rounds\") { t in\n        t.column(\"score\", .integer).indexed()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating String Manipulation Extensions in Swift\nDESCRIPTION: API changes to the _SpecificSQLExpressible extension, renaming string transformation properties to more Swift-idiomatic names by removing the 'String' suffix.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_112\n\nLANGUAGE: swift\nCODE:\n```\nextension _SpecificSQLExpressible {\n-    var capitalizedString: _SQLExpression { get }\n-    var lowercaseString: _SQLExpression { get }\n-    var uppercaseString: _SQLExpression { get }\n-    var localizedCapitalizedString: _SQLExpression { get }\n-    var localizedLowercaseString: _SQLExpression { get }\n-    var localizedUppercaseString: _SQLExpression { get }\n+    var capitalized: _SQLExpression { get }\n+    var lowercased: _SQLExpression { get }\n+    var uppercased: _SQLExpression { get }\n+    var localizedCapitalized: _SQLExpression { get }\n+    var localizedLowercased: _SQLExpression { get }\n+    var localizedUppercased: _SQLExpression { get }\n}\n```\n\n----------------------------------------\n\nTITLE: Working Around Type Inference Issues in GRDB.swift\nDESCRIPTION: Shows two solutions for the generic parameter inference error: using an explicit return type declaration or writing a single-line closure to help the Swift compiler with type inference.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_232\n\nLANGUAGE: swift\nCODE:\n```\n// General Workaround\nlet string = try dbQueue.read { db -> String? in\n    let result = try String.fetchOne(db, ...)\n    return result\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// Single-line closure workaround:\nlet string = try dbQueue.read { db in\n    try String.fetchOne(db, ...)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating In-Memory Database Initialization in Swift\nDESCRIPTION: Changes the in-memory database initializer to a throwing function. This requires adding a try keyword before creating a DatabaseQueue instance.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n-let dbQueue = DatabaseQueue()\n+let dbQueue = try DatabaseQueue()\n```\n\n----------------------------------------\n\nTITLE: Creating ValueObservation in GRDB 5\nDESCRIPTION: Shows how to create ValueObservation instances in GRDB 5, which now consistently requires a tracking function that fetches the observed value, replacing various specialized observation methods from GRDB 4.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 5\nlet observation = ValueObservation.tracking { db in\n    /* fetch and return the observed value */\n}\n\n// For example, an observation of [Player], which tracks all players:\nlet observation = ValueObservation.tracking { db in\n    try Player.fetchAll(db)\n}\n\n// The same observation, using shorthand notation:\nlet observation = ValueObservation.tracking(Player.fetchAll)\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive CTE\nDESCRIPTION: Creates a recursive CTE that generates a sequence of numbers from 1 to 1000.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nlet counterCTE = CommonTableExpression(\n    recursive: true,\n    named: \"counter\",\n    columns: [\"x\"],\n    sql: \"\"\"\n        VALUES(1)\n        UNION ALL\n        SELECT x+1 FROM counter WHERE x<1000\n        \"\"\")\n```\n\n----------------------------------------\n\nTITLE: Defining Association Protocol in Swift\nDESCRIPTION: Shows the protocol definition for Association which is used for all database associations. It conforms to DerivableRequest and includes associated types for row decoding.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nprotocol Association: DerivableRequest {\n    associatedtype OriginRowDecoder\n    func forKey(_ key: String) -> Self\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Transaction Callback Method in Swift\nDESCRIPTION: Shows the change from afterNextTransactionCommit to afterNextTransaction, which now supports both commit and rollback callbacks.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_14\n\nLANGUAGE: diff\nCODE:\n```\n-db.afterNextTransactionCommit { db in\n+db.afterNextTransaction { db in\n     print(\"Succesful commit\")\n }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Indexes in GRDB.swift\nDESCRIPTION: This method retrieves information about indexes on a specific table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_6\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/indexes(on:in:)\n```\n\n----------------------------------------\n\nTITLE: ValueObservation API Changes in GRDB.swift 4.1.0\nDESCRIPTION: Introduces new methods for creating and managing ValueObservation instances, including observation methods on FetchRequest and TableRecord, and improved handling of errors and value changes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_26\n\nLANGUAGE: swift\nCODE:\n```\n+extension FetchRequest {\n+    func observationForCount() -> ValueObservation<...>\n+}\n+extension FetchRequest where RowDecoder: ... {\n+    func observationForAll() -> ValueObservation<...>\n+    func observationForFirst() -> ValueObservation<...>\n+)\n+extension TableRecord {\n+    static func observationForCount() -> ValueObservation<...>\n+    static func observationForAll() -> ValueObservation<...>\n+    static func observationForFirst() -> ValueObservation<...>\n+}\n extension ValueObservation where ... {\n+    @available(*, deprecated)\n     static func trackingCount<Request: FetchRequest>(_ request: Request) -> ValueObservation<...>\n+    @available(*, deprecated)\n     static func trackingAll<Request: FetchRequest>(_ request: Request) -> ValueObservation<...>\n+    @available(*, deprecated)\n     static func trackingOne<Request: FetchRequest>(_ request: Request) -> ValueObservation<...>\n }\n extension ValueObservation where Reducer: ValueReducer {\n-    func start(in reader: DatabaseReader, onError: ((Error) -> Void)? = nil, onChange: @escaping (Reducer.Value) -> Void) throws -> TransactionObserver\n+    func start(in reader: DatabaseReader, onChange: @escaping (Reducer.Value) -> Void) throws -> TransactionObserver\n+    func start(in reader: DatabaseReader, onError: @escaping (Error) -> Void, onChange: @escaping (Reducer.Value) -> Void) -> TransactionObserver\n+    func combine<..., Combined>(..., transform: @escaping (...) -> Combined) -> ValueObservation<...>\n }\n extension ValueObservation where Reducer: ValueReducer, Reducer.Value: Equatable {\n+    @available(*, deprecated)\n     func distinctUntilChanged() -> ValueObservation<...>\n+    func removeDuplicates() -> ValueObservation<...>\n }\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Tokenizer Name in Swift\nDESCRIPTION: This snippet shows how to define a name for a custom tokenizer, which is required for all custom tokenizers.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nfinal class MyTokenizer : FTS5WrapperTokenizer {\n    static let name = \"custom\"\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Aggregate Names with forKey in Swift\nDESCRIPTION: Shows how to use the forKey method to provide custom names for aggregates. This is useful when the default naming doesn't match your struct properties or when combining multiple aggregates.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_92\n\nLANGUAGE: swift\nCODE:\n```\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var numberOfBooks: Int\n}\nlet numberOfBooks = Author.books.count.forKey(\"numberOfBooks\")                    // <--\nlet request = Author.annotated(with: numberOfBooks)\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var hasBooks: Bool\n}\nlet hasBooks = (Author.books.isEmpty == false).forKey(\"hasBooks\")                 // <--\nlet request = Author.annotated(with: hasBooks)\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n\nstruct AuthorInfo: Decodable, FetchableRecord {\n    var author: Author\n    var workCount: Int\n}\nlet workCount = (Author.books.count + Author.paintings.count).forKey(\"workCount\") // <--\nlet request = Author.annotated(with: workCount)\nlet authorInfos: [AuthorInfo] = try AuthorInfo.fetchAll(db, request)\n```\n\n----------------------------------------\n\nTITLE: Creating Common Table Expressions without Generic Qualifier in Swift\nDESCRIPTION: Shows how to define common table expressions without specifying a generic qualifier, which defaults to `Row`. This is part of the version 5.5.0 update.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nlet cte = CommonTableExpression(...)\n```\n\n----------------------------------------\n\nTITLE: Cross-Platform SQLite Version Check\nDESCRIPTION: Demonstrates how to get SQLite version information consistently across different GRDB flavors.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_17\n\nLANGUAGE: Swift\nCODE:\n```\n// Supported in all GRDB flavors\nimport GRDB\nlet sqliteVersion = String(cString: sqlite3_libversion())\n```\n\n----------------------------------------\n\nTITLE: Raw SQL Interface Changes in GRDB.swift\nDESCRIPTION: Updates the raw SQL interface with more consistent parameter naming and default argument values. These breaking changes improve parameter clarity by using labeled parameters and providing empty StatementArguments by default instead of optionals.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_34\n\nLANGUAGE: swift\nCODE:\n```\n class Database {\n-    func makeSelectStatement(_ sql: String) throws -> SelectStatement\n-    func makeUpdateStatement(_ sql: String) throws -> UpdateStatement\n+    func makeSelectStatement(sql: String) throws -> SelectStatement\n+    func makeUpdateStatement(sql: String) throws -> UpdateStatement\n\n-    func cachedSelectStatement(_ sql: String) throws -> SelectStatement\n-    func cachedUpdateStatement(_ sql: String) throws -> UpdateStatement\n+    func cachedSelectStatement(sql: String) throws -> SelectStatement\n+    func cachedUpdateStatement(sql: String) throws -> UpdateStatement\n\n-    func execute(_ sql: String, arguments: StatementArguments? = nil) throws\n+    func execute(sql: String, arguments: StatementArguments = StatementArguments()) throws\n }\n \n class Row {\n-    static func fetchCursor(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> RowCursor\n-    static func fetchAll(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> [Row]\n-    static func fetchOne(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> Row?\n+    static func fetchCursor(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> RowCursor\n+    static func fetchAll(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> [Row]\n+    static func fetchOne(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> Row?\n }\n \n extension FetchableRecord {\n-    static func fetchCursor(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> RecordCursor<Self>\n-    static func fetchAll(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> [Self]\n-    static func fetchOne(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> Self?\n+    static func fetchCursor(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> RecordCursor<Self>\n+    static func fetchAll(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> [Self]\n+    static func fetchOne(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> Self?\n }\n\n extension DatabaseValueConvertible {\n-    static func fetchCursor(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> DatabaseValueCursor<Self>\n-    static func fetchAll(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> [Self]\n-    static func fetchOne(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> Self?\n+    static func fetchCursor(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> DatabaseValueCursor<Self>\n+    static func fetchAll(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> [Self]\n+    static func fetchOne(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> Self?\n }\n \n extension Optional where Wrapped: DatabaseValueConvertible {\n-    static func fetchCursor(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> NullableDatabaseValueCursor<Wrapped>\n-    static func fetchAll(_ db: Database, _ sql: String, arguments: StatementArguments? = nil, adapter: RowAdapter? = nil) throws -> [Wrapped?]\n+    static func fetchCursor(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> NullableDatabaseValueCursor<Wrapped>\n+    static func fetchAll(_ db: Database, sql: String, arguments: StatementArguments = StatementArguments(), adapter: RowAdapter? = nil) throws -> [Wrapped?]\n }\n \n extension TableRecord {\n-    static func select(sql: String, arguments: StatementArguments? = nil) -> QueryInterfaceRequest<Self>\n+    static func select(sql: String, arguments: StatementArguments = StatementArguments()) -> QueryInterfaceRequest<Self>\n+    static func select(literal sqlLiteral: SQLLiteral) -> QueryInterfaceRequest<Self>\n-    static func select<RowDecoder>(sql: String, arguments: StatementArguments? = nil, as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n+    static func select<RowDecoder>(sql: String, arguments: StatementArguments = StatementArguments(), as type: RowDecoder.Type) -> QueryInterfaceRequest<RowDecoder>\n```\n\n----------------------------------------\n\nTITLE: Accessing Raw SQLite Pointers\nDESCRIPTION: Shows how to access and use raw SQLite C API pointers for database connections and statements when you need functionality not directly exposed by GRDB.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_56\n\nLANGUAGE: swift\nCODE:\n```\nimport SQLite3   // System SQLite\nimport SQLCipher // SQLCipher\n\nlet sqliteVersion = String(cString: sqlite3_libversion())\n```\n\n----------------------------------------\n\nTITLE: Using Custom Aggregates in the Query Interface\nDESCRIPTION: Demonstrates how to use custom aggregate functions in the query interface with type-safe SQL generation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_55\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT maxLength(\"name\") FROM player\nlet request = Player.select(maxLength.apply(nameColumn))\ntry Int.fetchOne(db, request) // Int?\n```\n\n----------------------------------------\n\nTITLE: Combining HasMany and HasManyThrough Associations\nDESCRIPTION: Example showing the unsupported case of using including(all:) with HasMany and HasManyThrough associations sharing the same base. A workaround using nested associations is provided.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_106\n\nLANGUAGE: swift\nCODE:\n```\n// NOT IMPLEMENTED\nlet request = Country\n    .including(all: Country.passports)\n    .including(all: Country.citizens)\n```\n\nLANGUAGE: swift\nCODE:\n```\n// Workaround\nlet request = Country\n    .including(all: Country.passports\n        .including(required: Passport.citizen))\n```\n\n----------------------------------------\n\nTITLE: Database Export with Encryption\nDESCRIPTION: Shows how to export an existing database to a new encrypted database using SQLCipher.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_189\n\nLANGUAGE: swift\nCODE:\n```\n// The existing database\nlet existingDBQueue = try DatabaseQueue(path: \"/path/to/existing.db\")\n\n// The new encrypted database, at some distinct location:\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    try db.usePassphrase(\"secret\")\n}\nlet newDBQueue = try DatabaseQueue(path: \"/path/to/new.db\", configuration: config)\n\ntry existingDBQueue.inDatabase { db in\n    try db.execute(\n        sql: \"\"\"\n            ATTACH DATABASE ? AS encrypted KEY ?;\n            SELECT sqlcipher_export('encrypted');\n            DETACH DATABASE encrypted;\n            \"\"\",\n        arguments: [newDBQueue.path, \"secret\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Single-Row Table Migration in Swift\nDESCRIPTION: Defines a database migration that creates a table guaranteed to have at most one row through SQLite constraints. Uses an integer primary key with a CHECK constraint to ensure the id is always 1.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SingleRowTables.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nmigrator.registerMigration(\"appConfiguration\") { db in\n    try db.create(table: \"appConfiguration\") { t in\n        t.primaryKey(\"id\", .integer, onConflict: .replace)\n            .check { $0 == 1 }\n        \n        t.column(\"storedFlag\", .boolean)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Record with Timestamp\nDESCRIPTION: Demonstrates how to update a record while automatically updating its modification timestamp.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// Bump the modification date and update all columns in the database.\nplayer.score += 1\ntry player.updateWithTimestamp(db)\n```\n\n----------------------------------------\n\nTITLE: Removing Default Transaction Kind Configuration\nDESCRIPTION: GRDB 7 removes the defaultTransactionKind property from Configuration as transactions are now automatically managed. This snippet shows the deprecated configuration and how transactions are now handled.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB7MigrationGuide.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 6\nvar config = Configuration()\nconfig.defaultTransactionKind = .immediate\n```\n\n----------------------------------------\n\nTITLE: SQL Statement Tracing Configuration in GRDB.swift\nDESCRIPTION: Demonstrates how to configure GRDB to trace and print all SQL statements during execution.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_223\n\nLANGUAGE: swift\nCODE:\n```\n// Prints all SQL statements\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.trace { print($0) }\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n\ntry dbQueue.read { db in\n    // Prints \"SELECT * FROM player WHERE email = ?\"\n    let players = try Player.filter(Column(\"email\") == \"arthur@example.com\").fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with FetchRequest in Swift\nDESCRIPTION: Demonstrates how to use FetchRequest to retrieve data from the database with different RowDecoder types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nlet row: Row? = try SQLRequest<Row>(\"SELECT * FROM player\").fetchOne(db)\nlet players: [Player] = try Player.all().fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Examples of Supported and Unsupported Query Limiting in Swift\nDESCRIPTION: Illustrates which types of query limiting operations are still supported after the removal of DerivableRequest.limit(_:offset_:) method. Direct limiting of requests is supported but limiting associations is no longer possible.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n// Still OK: a limited request of authors\nlet request = Author.limit(10)\n\n// Still OK: a limited request of books\nlet request = author.request(for: Author.books).limit(10)\n\n// No longer possible: including a limited association\nlet request = Author.including(all: Author.books.limit(10))\n```\n\n----------------------------------------\n\nTITLE: API Diff Overview in Swift and Diff Format\nDESCRIPTION: A comprehensive diff showing API changes including new structures, extensions to existing classes, and deprecated methods. It demonstrates additions to database functionality, transaction handling, and record management capabilities.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_48\n\nLANGUAGE: diff\nCODE:\n```\n+struct ColumnInfo {\n+    let name: String\n+    let type: String\n+    let isNotNull: Bool\n+    let defaultValueSQL: String?\n+    let primaryKeyIndex: Int\n+}\n\n struct Configuration {\n+    var allowsUnsafeTransactions: Bool\n }\n \n class Database {\n+     @available(*, deprecated, message: \"Use db.columns(in: tableName).count instead\")\n      func columnCount(in tableName: String) throws -> Int\n+     func columns(in tableName: String) throws -> [ColumnInfo]\n+     func beginTransaction(_ kind: TransactionKind? = nil) throws\n+     func rollback() throws\n+     func commit() throws\n }\n \n class DatabasePool {\n+    func makeSnapshot() throws -> DatabaseSnapshot\n }\n \n+class DatabaseSnapshot: DatabaseReader { }\n\n extension MutablePersistable {\n+    @discardableResult\n+    func updateChanges(_ db: Database, from record: MutablePersistable) throws -> Bool\n+    func databaseEqual(_ record: Self) -> Bool\n+    func databaseChanges(from record: MutablePersistable) -> [String: DatabaseValue]\n }\n class Record {\n-    final func updateChanges(_ db: Database) throws\n+    @discardableResult\n+    final func updateChanges(_ db: Database) throws -> Bool\n }\n \n+@available(*, deprecated, message: \"Prefer changes methods defined on the MutablePersistable protocol: databaseEqual(_:), databaseChanges(from:), updateChanges(from:)\")\n class RecordBox: Record { }\n\n class Row {\n+    var unscoped: Row\n+    var containsNonNullValue: Bool\n+    func hasNull(atIndex index: Int) -> Bool\n+    subscript<Record: RowConvertible>(_ scope: String) -> Record\n+    subscript<Record: RowConvertible>(_ scope: String) -> Record?\n }\n\n extension TableMapping {\n+    static func selectionSQL(alias: String? = nil) -> String\n+    static func numberOfSelectedColumns(_ db: Database) throws -> Int\n }\n\n+struct EmptyRowAdapter: RowAdapter { }\n\n struct ScopeAdapter {\n+    init(base: RowAdapter, scopes: [String: RowAdapter])\n }\n\n+func splittingRowAdapters(columnCounts: [Int]) -> [RowAdapter]\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Conversions with DatabaseValue in GRDB.swift\nDESCRIPTION: Demonstrates how DatabaseValue's fromDatabaseValue method safely handles invalid conversions by returning nil instead of causing fatal errors. This allows for more robust error handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_29\n\nLANGUAGE: swift\nCODE:\n```\nlet row = try Row.fetchOne(db, sql: \"SELECT 'Mom\\'s birthday'\")!\nlet dbValue: DatabaseValue = row[0]\nlet string = String.fromDatabaseValue(dbValue) // \"Mom's birthday\"\nlet int    = Int.fromDatabaseValue(dbValue)    // nil\nlet date   = Date.fromDatabaseValue(dbValue)   // nil\n```\n\n----------------------------------------\n\nTITLE: String Tokenization Examples\nDESCRIPTION: Demonstrates how to tokenize strings using different FTS3 tokenizers for text analysis and search.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// Default tokenization using the `simple` tokenizer:\nFTS3.tokenize(\"SQLite database\")  // [\"sqlite\", \"database\"]\nFTS3.tokenize(\"Gustave Doré\")     // [\"gustave\", \"doré\"])\n\n// Tokenization with an explicit tokenizer:\nFTS3.tokenize(\"SQLite database\", withTokenizer: .porter)   // [\"sqlite\", \"databas\"]\nFTS3.tokenize(\"Gustave Doré\", withTokenizer: .unicode61()) // [\"gustave\", \"dore\"])\n```\n\n----------------------------------------\n\nTITLE: Using Unsafe Database Access with Explicit Transaction in GRDB\nDESCRIPTION: Shows how to restore transaction safety when using unsafe database access methods. This example demonstrates writing outside of a transaction but explicitly creating one when needed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.writeWithoutTransaction { db in\n    try db.inTransaction { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Standard and Shorthand Closure Notation with Swift Concurrency\nDESCRIPTION: Shows the difference between standard closure syntax and shorthand notation when accessing a database with GRDB. The shorthand notation triggers a compiler warning about Sendable conformance that can be fixed by enabling the InferSendableFromCaptures feature.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// Standard closure:\nlet count = try await writer.read { db in\n    try Player.fetchCount(db)\n}\n\n// Shorthand notation:\n// ⚠️ Converting non-sendable function value to '@Sendable (Database) \n// throws -> Int' may introduce data races.\nlet count = try await writer.read(Player.fetchCount)\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Aggregate Conditions in Swift\nDESCRIPTION: Shows how to combine multiple aggregate conditions with logical operators, finding authors who wrote no books but made at least one painting.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_100\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Author.having(Author.books.isEmpty && !Author.paintings.isEmpty)\n```\n\n----------------------------------------\n\nTITLE: Database Transaction Hook\nDESCRIPTION: Example of using the new transaction hook API for commit/rollback handling\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nDatabase.afterNextTransaction(onCommit:onRollback:)\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLCipher for Shared Database Access in Swift\nDESCRIPTION: This code snippet demonstrates how to configure SQLCipher 4+ for shared database access, including setting the passphrase and configuring the cipher_plaintext_header_size to prevent 0xDEAD10CC exceptions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nvar configuration = Configuration()\nconfiguration.prepareDatabase { (db: Database) in\n    try db.usePassphrase(\"secret\")\n    try db.execute(sql: \"PRAGMA cipher_plaintext_header_size = 32\")\n}\nlet dbPool = try DatabasePool(path: ..., configuration: configuration)\n```\n\n----------------------------------------\n\nTITLE: Version 2.7.0 Release Notes in Markdown\nDESCRIPTION: Release notes for version 2.7.0 (January 21, 2018) introducing the new RecordBox class that brings changes tracking to any record type, allowing developers to track record modifications and perform conditional updates.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_50\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.7.0\n\nReleased January 21, 2018 &bull; [diff](https://github.com/groue/GRDB.swift/compare/v2.6.1...v2.7.0)\n\n**New**\n\n- The new RecordBox class brings changes tracking to any record type ([documentation](https://github.com/groue/GRDB.swift/blob/master/README.md#recordbox-class)):\n    \n    ```swift\n    // A regular record struct\n    struct Player: RowConvertible, MutablePersistable { ... }\n    \n    try dbQueue.inDatabase { db in\n        // Fetch a boxed player\n        if let boxedPlayer = try RecordBox<Player>.fetchOne(db, key: 1) {\n            // boxedPlayer.value is Player\n            boxedPlayer.value.score = 300\n            \n            if boxedPlayer.hasPersistentChangedValues {\n                print(\"player has been modified\")\n            }\n            \n            // Does nothing if player has not been modified:\n            try boxedPlayer.updateChanges(db)\n        }\n    }\n    ```\n```\n\n----------------------------------------\n\nTITLE: Configuring Database Row Decoder with Custom userInfo\nDESCRIPTION: Demonstrates how to provide custom userInfo values for database row decoding by implementing the databaseDecodingUserInfo property. This allows records to identify that they are being decoded from database rows.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_104\n\nLANGUAGE: swift\nCODE:\n```\nextension Player: FetchableRecord {\n    static var databaseDecodingUserInfo: [CodingUserInfoKey: Any] {\n        [decoderName: \"database row\"]\n    }\n}\n\n// prints \"Decoded from database row\"\nlet player = try Player.fetchOne(db, ...)\n```\n\n----------------------------------------\n\nTITLE: Defining Single-Row Record Structure in Swift\nDESCRIPTION: Implements a Codable struct representing the single-row configuration record with private properties and public accessors with default values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SingleRowTables.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nstruct AppConfiguration: Codable {\n    private var id = 1\n    \n    private var storedFlag: Bool?\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Decoder with Custom userInfo\nDESCRIPTION: Shows how to set up a JSONDecoder with custom userInfo values that will be accessible during the decoding process. This example configures the decoder to identify itself as 'JSON' to the Player record.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_103\n\nLANGUAGE: swift\nCODE:\n```\n// prints \"Decoded from JSON\"\nlet decoder = JSONDecoder()\ndecoder.userInfo = [decoderName: \"JSON\"]\nlet player = try decoder.decode(Player.self, from: jsonData)\n```\n\n----------------------------------------\n\nTITLE: Converting DatabaseValue to Swift Types in GRDB.swift\nDESCRIPTION: Shows how to extract Swift types from DatabaseValue instances using the fromDatabaseValue method. This approach provides more explicit control over the conversion process.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_28\n\nLANGUAGE: swift\nCODE:\n```\nlet dbValue: DatabaseValue = row[\"bookCount\"]\nlet bookCount   = Int.fromDatabaseValue(dbValue)   // Int?\nlet bookCount64 = Int64.fromDatabaseValue(dbValue) // Int64?\nlet hasBooks    = Bool.fromDatabaseValue(dbValue)  // Bool?, false when 0\n\nlet dbValue: DatabaseValue = row[\"date\"]\nlet string = String.fromDatabaseValue(dbValue)     // \"2015-09-11 18:14:15.123\"\nlet date   = Date.fromDatabaseValue(dbValue)       // Date?\n```\n\n----------------------------------------\n\nTITLE: Updating FetchedRecordsController and MutablePersistable in Swift\nDESCRIPTION: Changes to the FetchedRecordsController and MutablePersistable protocols, adding throwing capabilities to several methods. Also updates QueryInterfaceRequest and RowConvertible extensions to use throwing methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_96\n\nLANGUAGE: Swift\nCODE:\n```\nfinal class FetchedRecordsController<Record: RowConvertible> {\n-    init(...)\n-    func performFetch(...)\n-    func setRequest(...)\n+    init(...) throws\n+    func performFetch(...) throws\n+    func setRequest(...) throws\n}\n\nprotocol MutablePersistable : TableMapping {\n-    func exists(_ db: Database) -> Bool\n+    func exists(_ db: Database) throws -> Bool\n}\n\nextension MutablePersistable {\n-    func performExists(_ db: Database) -> Bool\n+    func performExists(_ db: Database) throws -> Bool\n}\n\nextension QueryInterfaceRequest {\n-    func fetchCount(...) -> Int\n+    func fetchCount(...) throws -> Int\n}\n\nextension QueryInterfaceRequest where T: RowConvertible {\n-    func fetch(...) -> DatabaseSequence<T>\n-    func fetchAll(...) -> [T]\n-    func fetchOne(...) -> T?\n+    func fetchCursor(...) throws -> DatabaseCursor<T>\n+    func fetchAll(...) throws -> [T]\n+    func fetchOne(...) throws -> T?\n}\n\nextension RowConvertible {\n-    static func fetch(...) -> DatabaseSequence<Self>\n-    static func fetchAll(...) -> [Self]\n-    static func fetchOne(...) -> Self?\n+    static func fetchCursor(...) throws -> DatabaseCursor<Self> {\n+    static func fetchAll(...) throws -> [Self] {\n+    static func fetchOne(...) throws -> Self?\n}\n\nextension TableMapping {\n-    static func fetchCount(_ db: Database) -> Int\n+    static func fetchCount(_ db: Database) throws -> Int\n}\n```\n\n----------------------------------------\n\nTITLE: TableMapping Protocol for Row Deletion in Swift\nDESCRIPTION: Demonstrates how to use the TableMapping protocol to delete rows identified by primary keys or unique index columns. This feature allows for concise deletion of records based on their identifiers.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_113\n\nLANGUAGE: swift\nCODE:\n```\ntry Person.deleteOne(db, key: 1)\ntry Person.deleteOne(db, key: [\"email\": \"arthur@example.com\"])\ntry Citizenship.deleteOne(db, key: [\"personID\": 1, \"countryCode\": \"FR\"])\ntry Country.deleteAll(db, keys: [\"FR\", \"US\"])\n```\n\n----------------------------------------\n\nTITLE: Updating Cursor.isEmpty from Method to Property in Swift\nDESCRIPTION: Shows the migration from Cursor.isEmpty() method to Cursor.isEmpty property. Both versions throw errors but the syntax has changed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_10\n\nLANGUAGE: diff\nCODE:\n```\n-if try cursor.isEmpty() { ... }\n+if try cursor.isEmpty { ... }\n```\n\n----------------------------------------\n\nTITLE: API Changes in GRDB.swift 3.3.0-beta1\nDESCRIPTION: Shows API changes from 3.2.0 to 3.3.0-beta1, including fixes to DatabaseQueue methods and enhancements to Codable record support with JSON handling, date formatting, and query interface improvements.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_43\n\nLANGUAGE: diff\nCODE:\n```\n class DatabaseQueue {\n-    func write<T>(_ block: (Database) throws -> T) rethrows -> T {\n+    func write<T>(_ block: (Database) throws -> T) throws -> T {\n-    func unsafeReentrantRead<T>(_ block: (Database) throws -> T) throws -> T {\n+    func unsafeReentrantRead<T>(_ block: (Database) throws -> T) rethrows -> T {\n }\n```\n\n----------------------------------------\n\nTITLE: Updating QueryInterfaceRequest Extension Syntax in Swift\nDESCRIPTION: Shows the streamlined syntax for QueryInterfaceRequest protocol extensions using SE-0361. Demonstrates how to select a Player's primary key ID and transform it into an Int64 request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n-extension QueryInterfaceRequest where RowDecoder == Player {\n+extension QueryInterfaceRequest<Player> {\n     func selectID() -> QueryInterfaceRequest<Int64> {\n         selectPrimaryKey()\n     }\n }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Eager Loading with Vapor's Fluent in Swift\nDESCRIPTION: This snippet demonstrates eager loading in Vapor's Fluent. It explicitly requests the books relationship when querying for an author, fetching both the author and their books in one operation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\n// Eager loading with Fluent\nlet query = Author.query(on: db)\n    .with(\\.$books) // <- Explicit request for books\n    .first()\n\n// Fetch first author and its books in one stroke\nif let author = query.get() {\n    print(author.name)\n    for book in author.books { print(book.title) } \n}\n```\n\n----------------------------------------\n\nTITLE: Handling Reentrant Database Access Errors in GRDB\nDESCRIPTION: Example showing how nested database access can lead to a fatal error. GRDB prevents reentrancy to avoid deadlocks and ensure clear transaction boundaries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Concurrency.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // Fatal Error: Database methods are not reentrant.\n    try dbQueue.write { db in ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Updates to TableMapping Protocol and Record Class\nDESCRIPTION: Changes the TableMapping protocol to use databaseSelection instead of selectsRowID, with corresponding changes to the Record class and addition of a new AllColumns struct.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_69\n\nLANGUAGE: diff\nCODE:\n```\n protocol TableMapping {\n-    static var selectsRowID: Bool { get }\n+    static var databaseSelection: [SQLSelectable] { get }\n }\n class Record {\n-    open class var selectsRowID: Bool\n+    open class var databaseSelection: [SQLSelectable]\n }\n+struct AllColumns {\n+    init()\n+}\n```\n\n----------------------------------------\n\nTITLE: Performing Migration Checks in GRDB.swift\nDESCRIPTION: This snippet demonstrates how to perform additional checks on the migration status of a database, such as checking for incomplete or unknown migrations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Migrations.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.read { db in\n    // Read-only apps or extensions may want to check if the database\n    // lacks expected migrations:\n    if try migrator.hasCompletedMigrations(db) == false {\n        // database too old\n    }\n    \n    // Some apps may want to check if the database\n    // contains unknown (future) migrations:\n    if try migrator.hasBeenSuperseded(db) {\n        // database too new\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling automatic memory management in GRDB\nDESCRIPTION: This example shows how to opt out of GRDB's automatic memory management that normally frees non-essential memory on iOS memory warnings or when entering background.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_219\n\nLANGUAGE: swift\nCODE:\n```\nvar config = Configuration()\nconfig.automaticMemoryManagement = false\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config) // or DatabasePool\n```\n\n----------------------------------------\n\nTITLE: Creating a Common Table Expression (CTE) for Latest Messages\nDESCRIPTION: Defines a CTE named 'latestMessage' using the previously created request that retrieves the latest messages for all chats.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CommonTableExpressions.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n// WITH latestMessage AS\n//   (SELECT *, MAX(date) FROM message GROUP BY chatID)\nlet latestMessageCTE = CommonTableExpression(\n    named: \"latestMessage\",\n    request: latestMessageRequest)\n```\n\n----------------------------------------\n\nTITLE: Defining ColumnExpression Protocol in Swift\nDESCRIPTION: Protocol definition for ColumnExpression which represents database columns. It conforms to SQLSpecificExpressible and requires a name property.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nprotocol ColumnExpression: SQLSpecificExpressible {\n    /// The name of a database column.\n    var name: String { get }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Full GRDB Swift Test Suite\nDESCRIPTION: Command to run the complete test suite for GRDB, including checks for XCFramework archiving, various installation methods, and demo apps. This should be run before a release.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CONTRIBUTING.md#2025-04-22_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nmake test\n```\n\n----------------------------------------\n\nTITLE: Advanced Database Backup with Direct Database Handles\nDESCRIPTION: Shows an alternative approach to database backup using direct Database handles. This method provides more control over the backup process by allowing explicit specification of source and destination Database objects.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_196\n\nLANGUAGE: swift\nCODE:\n```\nlet source: DatabaseQueue = ...      // or DatabasePool\nlet destination: DatabaseQueue = ... // or DatabasePool\ntry source.write { sourceDb in\n    try destination.barrierWriteWithoutTransaction { destDb in\n        try sourceDb.backup(to: destDb)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DELETE Query with SQL Interpolation\nDESCRIPTION: Method to delete all players without scores using SQL interpolation to safely reference table and column names.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nextension Player {\n    /// Deletes all player with no score\n    static func deleteAllWithoutScore(_ db: Database) throws {\n        try db.execute(literal: \"DELETE FROM \\(self) WHERE \\(CodingKeys.score) IS NULL\")\n    }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.write { db in\n    // DELETE FROM player WHERE score IS NULL\n    try Player.deleteAllWithoutScore(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Tokenizer in FTS4\nDESCRIPTION: Demonstrates setting up the default simple tokenizer which provides case-insensitive ASCII matching without stemming or diacritic stripping.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS4()) { t in\n    t.tokenizer = .simple   // default\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Busy Timeout for SQLITE_BUSY Error Handling in Swift\nDESCRIPTION: This code snippet demonstrates how to configure a database pool with a busy timeout to handle SQLITE_BUSY errors when multiple processes attempt to write to the database concurrently.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSharing.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nvar configuration = Configuration()\nconfiguration.busyMode = .timeout(/* a TimeInterval */)\nlet dbPool = try DatabasePool(path: ..., configuration: configuration)\n```\n\n----------------------------------------\n\nTITLE: Database Connections API Changes in Swift 3\nDESCRIPTION: Changes to database connection types and configurations, including modifications to BusyCallback, BusyMode, CheckpointMode, and TransactionKind implementations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_101\n\nLANGUAGE: diff\nCODE:\n```\n-typealias BusyCallback = (numberOfTries: Int) -> Bool\n-enum BusyMode\n-enum CheckpointMode\n-enum TransactionKind\n-enum TransactionCompletion\n struct Configuration {\n-    var fileAttributes: [String: AnyObject]?\n+    var fileAttributes: [FileAttributeKey: Any]\n }\n class Database {\n+    typealias BusyCallback = (_ numberOfTries: Int) -> Bool\n+    enum BusyMode {\n+        case immediateError\n+        case timeout(TimeInterval)\n+        case callback(BusyCallback)\n+    }\n+    enum CheckpointMode: Int32 {\n+        case passive\n+        case full\n+        case restart\n+        case truncate\n+    }\n+    enum TransactionKind {\n+        case deferred\n+        case immediate\n+        case exclusive\n+    }\n+    enum TransactionCompletion {\n+        case commit\n+        case rollback\n+    }\n }\n```\n\n----------------------------------------\n\nTITLE: Query Interface with SQL Arguments in Swift\nDESCRIPTION: Shows how to provide arguments to SQL snippets using the query interface. This allows for parameterized queries that safely handle user input.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_114\n\nLANGUAGE: swift\nCODE:\n```\nlet wines = Wine.filter(sql: \"origin = ?\", arguments: [\"Burgundy\"]).fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Updated Row Value Access Syntax\nDESCRIPTION: Shows the migration from deprecated value() methods to new subscript notation for accessing row values.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_65\n\nLANGUAGE: swift\nCODE:\n```\n-row.value(atIndex: 0)\n-row.value(named: \"id\")\n-row.value(Column(\"id\"))\n+row[0]\n+row[\"id\"]\n+row[Column(\"id\")]\n```\n\n----------------------------------------\n\nTITLE: Getting Column Index from Prepared Statement\nDESCRIPTION: Demonstrates how to get the index of a column from a prepared SQL statement.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_62\n\nLANGUAGE: swift\nCODE:\n```\nlet statement = try db.makeSelectStatement(\"SELECT a, b FROM t\")\nstatement.index(ofColumn: \"b\")  // 1\n```\n\n----------------------------------------\n\nTITLE: Executing SQL Queries with FetchRequest in Swift\nDESCRIPTION: Shows how FetchRequest typically executes a single SQL query and how to access the underlying SQL statement.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player\nlet request = Player.all()\ntry request.fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Defining Player Record Structure with GRDB Protocols\nDESCRIPTION: Basic record structure definition for a Player with ID, name and score fields that implements GRDB record protocols for database operations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player {\n    var id: Int64\n    var name: String\n    var score: Int?\n}\n\nextension Player: Decodable, TableRecord, FetchableRecord { }\n```\n\n----------------------------------------\n\nTITLE: Initializing Wrapped Tokenizer in Swift\nDESCRIPTION: This code demonstrates how to initialize the wrapped tokenizer property in a custom tokenizer's initializer. In this case, it's using the unicode61 tokenizer.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nfinal class MyTokenizer : FTS5WrapperTokenizer {\n    let wrappedTokenizer: any FTS5Tokenizer\n    \n    init(db: Database, arguments: [String]) throws {\n        // Wrap the unicode61 tokenizer\n        wrappedTokenizer = try db.makeTokenizer(.unicode61())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GRDB.swift CocoaPod for Pre-Update Hooks in Ruby\nDESCRIPTION: This Ruby code snippet demonstrates how to configure the GRDB.swift CocoaPod to enable extra GRDB and SQLite APIs, including the pre-update hook functionality. It modifies the pod's build settings to include necessary compiler flags and preprocessor definitions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_8\n\nLANGUAGE: ruby\nCODE:\n```\npod 'GRDB.swift'\n\npost_install do |installer|\n  installer.pods_project.targets.select { |target| target.name == \"GRDB.swift\" }.each do |target|\n    target.build_configurations.each do |config|\n      # Enable extra GRDB APIs\n      config.build_settings['OTHER_SWIFT_FLAGS'] = \"$(inherited) -D SQLITE_ENABLE_PREUPDATE_HOOK\"\n      # Enable extra SQLite APIs\n      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] = \"$(inherited) GRDB_SQLITE_ENABLE_PREUPDATE_HOOK=1\"\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Database Integrity Check Function References\nDESCRIPTION: List of database integrity check methods and types including foreign key validation functions and violation type definitions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntegrityChecks.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- ``Database/checkForeignKeys()``\n- ``Database/checkForeignKeys(in:in:)``\n- ``Database/foreignKeyViolations()``\n- ``Database/foreignKeyViolations(in:in:)``\n- ``ForeignKeyViolation``\n```\n\n----------------------------------------\n\nTITLE: Interpolating Common Table Expressions in SQL Queries (Swift)\nDESCRIPTION: This snippet demonstrates how to interpolate common table expressions (CTEs) into SQL queries. It shows how to define and use a CTE in a WITH clause.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/SQLInterpolation.md#2025-04-22_snippet_26\n\nLANGUAGE: Swift\nCODE:\n```\n// WITH name AS (SELECT 'O''Brien') SELECT * FROM name\nlet cte = CommonTableExpression<Void>(\n   named: \"name\",\n   literal: \"SELECT \\(\"O'Brien\")\")\n\"WITH \\(definitionFor: cte) SELECT * FROM \\(cte)\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling for FetchedRecordsController in Swift\nDESCRIPTION: Adds error handling capability to FetchedRecordsController, allowing custom error handling when changes can't be tracked.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_92\n\nLANGUAGE: Swift\nCODE:\n```\ncontroller.trackErrors { (controller, error) in\n    print(\"Missed a transaction because \\(error)\")\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite Compilation Options in SQLiteLib-USER.xcconfig\nDESCRIPTION: Configuration file that sets extra SQLite compilation flags using -D options for the C compiler. This example enables snapshot support and FTS5 full-text search.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CustomSQLiteBuilds.md#2025-04-22_snippet_1\n\nLANGUAGE: xcconfig\nCODE:\n```\n// As many -D options as there are custom SQLite compilation options\n// Note: there is no space between -D and the option name.\nCUSTOM_SQLLIBRARY_CFLAGS = -DSQLITE_ENABLE_SNAPSHOT -DSQLITE_ENABLE_FTS5\n```\n\n----------------------------------------\n\nTITLE: Running Test Suite and Cleanup in Bash\nDESCRIPTION: Command to clean the project directory and run the test suite to ensure everything is working correctly before release.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/ReleaseProcess.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake distclean test\n```\n\n----------------------------------------\n\nTITLE: Migrating Batch Updates from <- Operator to set(to:) Method in GRDB 5\nDESCRIPTION: Demonstrates how to migrate from the removed <- operator to the new set(to:) method for batch updates. This change was made to avoid conflicts with other libraries that might define the same operator.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\ntry Player.updateAll(db, Column(\"score\") <- 0)\n \n// NEW: GRDB 5\ntry Player.updateAll(db, Column(\"score\").set(to: 0))\n```\n\n----------------------------------------\n\nTITLE: Chaining Required Association on Optional Association\nDESCRIPTION: Example showing the unsupported case of chaining a required association on an optional association using Book.author.including(required: Person.country). This will result in a runtime fatal error.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_104\n\nLANGUAGE: swift\nCODE:\n```\n// NOT IMPLEMENTED\nlet request = Book\n    .joining(optional: Book.author\n        .including(required: Person.country))\n```\n\n----------------------------------------\n\nTITLE: Fetching Books with Authors Without Associations\nDESCRIPTION: Shows how to fetch books along with their authors without using GRDB associations, requiring multiple database queries.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nstruct BookInfo {\n    var book: Book\n    var author: Author?\n}\n\nlet books = try Book.fetchAll(db)\nlet bookInfos = books.map { book -> BookInfo in\n    let author = try Author.fetchOne(db, id: book.authorId)\n    return BookInfo(book: book, author: author)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Record Types with Codable\nDESCRIPTION: Shows the initial implementation of Author and Book record types using Codable for database row conversion.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nstruct Author: Codable {\n    var id: Int64?\n    var name: String\n    var countryCode: String?\n}\n\nstruct Book: Codable {\n    var id: Int64?\n    var authorId: Int64\n    var title: String\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Token Acceptance Method in Swift\nDESCRIPTION: This snippet shows a basic implementation of the accept method for a custom tokenizer that simply passes tokens through without modification.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FTS5Tokenizers.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nfinal class MyTokenizer : FTS5WrapperTokenizer {\n    func accept(\n        token: String,\n        flags: FTS5TokenFlags,\n        for tokenization: FTS5Tokenization,\n        tokenCallback: FTS5WrapperTokenCallback) throws\n    {\n        // pass through\n        try tokenCallback(token, flags)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Refactoring FetchedRecordsController Class in Swift\nDESCRIPTION: Shows the breaking changes made to FetchedRecordsController class in version 0.62.0. The changes include replacing delegate with callbacks and making UITableView features iOS-only.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_115\n\nLANGUAGE: diff\nCODE:\n```\n final class FetchedRecordsController<Record: RowConvertible> {\n-    weak var delegate: FetchedRecordsControllerDelegate?\n-    func recordAtIndexPath(indexPath: NSIndexPath) -> Record\n-    func indexPathForRecord(record: Record) -> NSIndexPath?\n-    var sections: [FetchedRecordsSectionInfo<Record>]\n+    #if os(iOS)\n+        typealias WillChangeCallback = FetchedRecordsController<Record> -> ()\n+        typealias DidChangeCallback = FetchedRecordsController<Record> -> ()\n+        typealias TableViewEventCallback = (controller: FetchedRecordsController<Record>, record: Record, event: TableViewEvent) -> ()\n+        func trackChanges(\n+            recordsWillChange willChangeCallback: WillChangeCallback? = nil,\n+            tableViewEvent tableViewEventCallback: TableViewEventCallback? = nil,\n+            recordsDidChange didChangeCallback: DidChangeCallback? = nil)\n+        func recordAtIndexPath(indexPath: NSIndexPath) -> Record\n+        func indexPathForRecord(record: Record) -> NSIndexPath?\n+        var sections: [FetchedRecordsSectionInfo<Record>]\n+    #else\n+        typealias WillChangeCallback = FetchedRecordsController<Record> -> ()\n+        typealias DidChangeCallback = FetchedRecordsController<Record> -> ()\n+        func trackChanges(\n+            recordsWillChange willChangeCallback: WillChangeCallback? = nil,\n+            recordsDidChange didChangeCallback: DidChangeCallback? = nil)\n+    #endif\n }\n-protocol FetchedRecordsControllerDelegate : class { }\n```\n\n----------------------------------------\n\nTITLE: Major API Changes in Row and Statement Classes\nDESCRIPTION: Shows the transition from method-based value access to subscript notation in the Row class, along with additions to the SelectStatement class and changes to MutablePersistable extension.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_67\n\nLANGUAGE: diff\nCODE:\n```\n class Row {\n-    func value(atIndex index: Int) -> DatabaseValueConvertible?\n-    func value<Value: DatabaseValueConvertible>(atIndex index: Int) -> Value?\n-    func value<Value: DatabaseValueConvertible>(atIndex index: Int) -> Value\n-    func value(named columnName: String) -> DatabaseValueConvertible?\n-    func value<Value: DatabaseValueConvertible>(named columnName: String) -> Value?\n-    func value<Value: DatabaseValueConvertible>(named columnName: String) -> Value\n-    func value(_ column: Column) -> DatabaseValueConvertible?\n-    func value<Value: DatabaseValueConvertible>(_ column: Column) -> Value?\n-    func value<Value: DatabaseValueConvertible>(_ column: Column) -> Value\n+    subscript(_ index: Int) -> DatabaseValueConvertible?\n+    subscript<Value: DatabaseValueConvertible>(_ index: Int) -> Value?\n+    subscript<Value: DatabaseValueConvertible>(_ index: Int) -> Value\n+    subscript(_ columnName: String) -> DatabaseValueConvertible?\n+    subscript<Value: DatabaseValueConvertible>(_ columnName: String) -> Value?\n+    subscript<Value: DatabaseValueConvertible>(_ columnName: String) -> Value\n+    subscript(_ column: Column) -> DatabaseValueConvertible?\n+    subscript<Value: DatabaseValueConvertible>(_ column: Column) -> Value?\n+    subscript<Value: DatabaseValueConvertible>(_ column: Column) -> Value\n }\n\n class SelectStatement {\n+    func index(ofColumn columnName: String) -> Int?\n }\n \n+extension MutablePersistable {\n+    var databaseDictionary: [String: DatabaseValue]\n+}\n```\n\n----------------------------------------\n\nTITLE: Installation Script for Custom SQLite Configuration in GRDBCustomSQLite-INSTALL.sh\nDESCRIPTION: Shell script that installs the custom SQLite configuration files by copying them to the appropriate locations in the GRDB source directory. This needs to be configured with correct project paths.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CustomSQLiteBuilds.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n# License: MIT License\n# https://github.com/swiftlyfalling/SQLiteLib/blob/master/LICENSE\n#\n#######################################################\n#                   PROJECT PATHS\n#  !! MODIFY THESE TO MATCH YOUR PROJECT HIERARCHY !!\n#######################################################\n\n# The path to the folder containing GRDBCustom.xcodeproj:\nGRDB_SOURCE_PATH=\"${PROJECT_DIR}/GRDB\"\n\n# The path to your custom \"SQLiteLib-USER.xcconfig\":\nSQLITELIB_XCCONFIG_USER_PATH=\"${PROJECT_DIR}/GRDBCustomSQLite/SQLiteLib-USER.xcconfig\"\n\n# The path to your custom \"GRDBCustomSQLite-USER.xcconfig\":\nCUSTOMSQLITE_XCCONFIG_USER_PATH=\"${PROJECT_DIR}/GRDBCustomSQLite/GRDBCustomSQLite-USER.xcconfig\"\n\n# The path to your custom \"GRDBCustomSQLite-USER.h\":\nCUSTOMSQLITE_H_USER_PATH=\"${PROJECT_DIR}/GRDBCustomSQLite/GRDBCustomSQLite-USER.h\"\n\n#######################################################\n#\n#######################################################\n\n\nif [ ! -d \"$GRDB_SOURCE_PATH\" ];\nthen\necho \"error: Path to GRDB source (GRDB_SOURCE_PATH) missing/incorrect: $GRDB_SOURCE_PATH\"\nexit 1\nfi\n\nSyncFileChanges () {\n    SOURCE=$1\n    DESTINATIONPATH=$2\n    DESTINATIONFILENAME=$3\n    DESTINATION=\"${DESTINATIONPATH}/${DESTINATIONFILENAME}\"\n    \n    if [ ! -f \"$SOURCE\" ];\n    then\n    echo \"error: Source file missing: $SOURCE\"\n    exit 1\n    fi\n    \n    rsync -a \"$SOURCE\" \"$DESTINATION\"\n}\n\nSyncFileChanges $SQLITELIB_XCCONFIG_USER_PATH \"${GRDB_SOURCE_PATH}/SQLiteCustom/src\" \"SQLiteLib-USER.xcconfig\"\nSyncFileChanges $CUSTOMSQLITE_XCCONFIG_USER_PATH \"${GRDB_SOURCE_PATH}/SQLiteCustom\" \"GRDBCustomSQLite-USER.xcconfig\"\nSyncFileChanges $CUSTOMSQLITE_H_USER_PATH \"${GRDB_SOURCE_PATH}/SQLiteCustom\" \"GRDBCustomSQLite-USER.h\"\n\necho \"Finished syncing\"\n```\n\n----------------------------------------\n\nTITLE: Version 2.6.0 Release Notes and API Changes in Markdown and Diff\nDESCRIPTION: Release notes for version 2.6.0 (January 18, 2018) documenting enhancements to database observation, introduction of DatabaseRegion type, and Row adopting RandomAccessCollection protocol. Includes both textual description and API diff.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_52\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.6.0\n\nReleased January 18, 2018 &bull; [diff](https://github.com/groue/GRDB.swift/compare/v2.5.0...v2.6.0)\n\n### New\n\n- Database observation has been enhanced:\n    \n    - `TransactionObserver.stopObservingDatabaseChangesUntilNextTransaction()` allows transaction observers to stop observing the database for the remaining extent of a transaction.\n    - GRDB no longer prevents the [truncate optimization](https://www.sqlite.org/lang_delete.html#truncateopt) when no transaction observers are interested in deleted rows.\n    - FetchedRecordsController now avoids checking for changes in untracked rowIds.\n    - `DatabaseRegion` is a new public type that helps transaction observers recognize impactful database changes. This type is not documented in the main documentation. For more information, see [DatabaseRegion reference](https://groue.github.io/GRDB.swift/docs/2.6/Structs/DatabaseRegion.html), and look at [FetchedRecordsController implementation](https://github.com/groue/GRDB.swift/blob/master/GRDB/Record/FetchedRecordsController.swift).\n    - `TransactionObserver` protocol provides default implementations for rarely used callbacks.\n    \n- `Row` adopts RandomAccessCollection\n```\n\nLANGUAGE: diff\nCODE:\n```\n### API diff\n\n```diff\n extension TransactionObserver {\n+    func stopObservingDatabaseChangesUntilNextTransaction()\n+\n+    // Default implementation\n+    func databaseWillCommit() throws\n+\n+    #if SQLITE_ENABLE_PREUPDATE_HOOK\n+    // Default implementation\n+    func databaseWillChange(with event: DatabasePreUpdateEvent)\n+    #endif\n }\n\n+struct DatabaseRegion: Equatable {\n+    var isEmpty: Bool\n+\n+    init()\n+\n+    func union(_ other: DatabaseRegion) -> DatabaseRegion\n+    mutating func formUnion(_ other: DatabaseRegion)\n+\n+    func isModified(byEventsOfKind eventKind: DatabaseEventKind) -> Bool\n+    func isModified(by event: DatabaseEvent) -> Bool\n+}\n\n class SelectStatement {\n+    var fetchedRegion: DatabaseRegion\n+\n+    @available(*, deprecated, renamed:\"DatabaseRegion\")\n+    typealias SelectionInfo = DatabaseRegion\n+    \n+    @available(*, deprecated, renamed:\"fetchedRegion\")\n+    var selectionInfo: DatabaseRegion\n }\n\n enum DatabaseEventKind {\n-    func impacts(_ selectionInfo: SelectStatement.SelectionInfo) -> Bool\n+    @available(*, deprecated, message: \"Use DatabaseRegion.isModified(byEventsOfKind:) instead\")\n+    func impacts(_ region: DatabaseRegion) -> Bool\n }\n \n protocol Request {\n+    // Default implementation\n+    func fetchedRegion(_ db: Database) throws -> DatabaseRegion\n }\n \n+extension Row: RandomAccessCollection {\n+}\n+extension RowIndex: Strideable {\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Moving Persistence Methods from TableMapping to MutablePersistable\nDESCRIPTION: Shows the migration of deletion methods from TableMapping to MutablePersistable, along with changes to QueryInterfaceRequest to require MutablePersistable conformance.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_68\n\nLANGUAGE: diff\nCODE:\n```\n-extension TableMapping {\n+extension MutablePersistable {\n     @discardableResult static func deleteAll(_ db: Database) throws -> Int\n     @discardableResult static func deleteAll<Sequence: Swift.Sequence>(_ db: Database, keys: Sequence) throws -> Int where Sequence.Element: DatabaseValueConvertible\n     @discardableResult static func deleteOne<PrimaryKeyType: DatabaseValueConvertible>(_ db: Database, key: PrimaryKeyType?) throws -> Bool\n     @discardableResult static func deleteAll(_ db: Database, keys: [[String: DatabaseValueConvertible?]]) throws -> Int\n     @discardableResult static func deleteOne(_ db: Database, key: [String: DatabaseValueConvertible?]) throws -> Bool\n }\n-extension QueryInterfaceRequest {\n+extension QueryInterfaceRequest where RowDecoder: MutablePersistable {\n     @discardableResult func deleteAll(_ db: Database) throws -> Int\n }\n```\n\n----------------------------------------\n\nTITLE: Transaction Observer Protocol Updates\nDESCRIPTION: Major changes to transaction observer implementation including new event filtering method and renamed protocol methods.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_107\n\nLANGUAGE: diff\nCODE:\n```\n-protocol TransactionObserverType : class {\n+protocol TransactionObserver : class {\n-    func databaseDidChangeWithEvent(event: DatabaseEvent)\n-    func databaseDidCommit(db: Database)\n-    func databaseDidRollback(db: Database)\n+    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool\n+    func databaseDidChange(with event: DatabaseEvent)\n+    func databaseDidCommit(_ db: Database)\n+    func databaseDidRollback(_ db: Database)\n```\n\n----------------------------------------\n\nTITLE: Defining SQLSubqueryable Protocol in Swift\nDESCRIPTION: Protocol definition for SQLSubqueryable that conforms to SQLSpecificExpressible and provides access to SQLSubquery functionality.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_23\n\nLANGUAGE: swift\nCODE:\n```\nprotocol SQLSubqueryable: SQLSpecificExpressible {\n    var sqlSubquery: SQLSubquery { get }\n}\n```\n\n----------------------------------------\n\nTITLE: Specialized Cursor Types Replacing Generic DatabaseCursor\nDESCRIPTION: Replaces the generic DatabaseCursor with specialized cursor types for different value types and adds appropriate extension methods for fetching these specialized cursors.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_72\n\nLANGUAGE: diff\nCODE:\n```\n-final class DatabaseCursor { }\n+final class ColumnCursor<Value: DatabaseValueConvertible & StatementColumnConvertible> : Cursor {\n+    typealias Element = Value\n+}\n+final class DatabaseValueCursor<Value: DatabaseValueConvertible> : Cursor  {\n+    typealias Element = Value\n+}\n+final class NullableColumnCursor<Value: DatabaseValueConvertible & StatementColumnConvertible> : Cursor  {\n+    typealias Element = Value?\n+}\n+final class NullableDatabaseValueCursor<Value: DatabaseValueConvertible> : Cursor  {\n+    typealias Element = Value?\n+}\n+final class RecordCursor<Record: RowConvertible> : Cursor  {\n+    typealias Element = Record\n+}\n+final class RowCursor : Cursor {\n+    typealias Element = Row\n+    let statement: SelectStatement\n+}\n extension DatabaseValueConvertible {\n-    static func fetchCursor(...) throws -> DatabaseCursor<Self>\n+    static func fetchCursor(...) throws -> DatabaseValueCursor<Self>\n }\n extension DatabaseValueConvertible where Self: StatementColumnConvertible {\n+    static func fetchCursor(...) throws -> ColumnCursor<Self>\n }\n extension Optional where Wrapped: DatabaseValueConvertible {\n-    static func fetchCursor(...) throws -> DatabaseCursor<Wrapped?>\n+    static func fetchCursor(...) throws -> NullableDatabaseValueCursor<Wrapped>\n }\n extension Optional where Wrapped: DatabaseValueConvertible & StatementColumnConvertible {\n+    static func fetchCursor(...) throws -> NullableColumnCursor<Wrapped>\n }\n extension Row {\n-    static func fetchCursor(...) throws -> DatabaseCursor<Row>\n+    static func fetchCursor(...) throws -> RowCursor\n }\n extension RowConvertible where Self: TableMapping {\n-    static func fetchCursor(...) throws -> DatabaseCursor<Self>?\n+    static func fetchCursor(...) throws -> RecordCursor<Self>\n }\n extension TypedRequest where RowDecoder: RowConvertible {\n-    func fetchCursor(_ db: Database) throws -> DatabaseCursor<RowDecoder>\n+    func fetchCursor(_ db: Database) throws -> RecordCursor<RowDecoder>\n }\n extension TypedRequest where RowDecoder: DatabaseValueConvertible {\n-    func fetchCursor(_ db: Database) throws -> DatabaseCursor<RowDecoder>\n+    func fetchCursor(_ db: Database) throws -> DatabaseValueCursor<RowDecoder>\n }\n extension TypedRequest where RowDecoder: DatabaseValueConvertible & StatementColumnConvertible {\n+    func fetchCursor(_ db: Database) throws -> ColumnCursor<RowDecoder>\n }\n extension TypedRequest where RowDecoder: _OptionalProtocol, RowDecoder._Wrapped: DatabaseValueConvertible {\n-    func fetchCursor(_ db: Database) throws -> DatabaseCursor<RowDecoder._Wrapped?>\n+    func fetchCursor(_ db: Database) throws -> NullableDatabaseValueCursor<RowDecoder._Wrapped>\n }\n extension TypedRequest where RowDecoder: _OptionalProtocol, RowDecoder._Wrapped: DatabaseValueConvertible & StatementColumnConvertible {\n+    func fetchCursor(_ db: Database) throws -> NullableColumnCursor<RowDecoder._Wrapped>\n }\n extension TypedRequest where RowDecoder: Row {\n-    func fetchCursor(_ db: Database) throws -> DatabaseCursor<Row>\n+    func fetchCursor(_ db: Database) throws -> RowCursor\n }\n```\n\n----------------------------------------\n\nTITLE: Handling Non-Optional Timestamps with Dual Record Types in Swift\nDESCRIPTION: Defines two complementary record types: Player with optional timestamps for unsaved records, and PersistedPlayer with non-optional timestamps for records that exist in the database. This approach eliminates the need to handle optionals when working with fetched records.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n/// `Player` deals with unsaved players\nstruct Player {\n    var id: Int64?              // optional\n    var creationDate: Date?     // optional\n    var modificationDate: Date? // optional\n    var name: String\n    var score: Int\n}\n\nextension Player: Encodable, MutablePersistableRecord {\n    /// Updates auto-incremented id upon successful insertion\n    mutating func didInsert(_ inserted: InsertionSuccess) {\n        id = inserted.rowID\n    }\n    \n    /// Sets both `creationDate` and `modificationDate` to the\n    /// transaction date, if they are not set yet.\n    mutating func willInsert(_ db: Database) throws {\n        if creationDate == nil {\n            creationDate = try db.transactionDate\n        }\n        if modificationDate == nil {\n            modificationDate = try db.transactionDate\n        }\n    }\n}\n\n/// `PersistedPlayer` deals with persisted players\nstruct PersistedPlayer: Identifiable {\n    let id: Int64              // not optional\n    let creationDate: Date     // not optional\n    var modificationDate: Date // not optional\n    var name: String\n    var score: Int\n}\n\nextension PersistedPlayer: Codable, FetchableRecord, PersistableRecord {\n    static var databaseTableName: String { \"player\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Named Table Aliases with SQL Snippets\nDESCRIPTION: Implementation of named table aliases for explicit SQL query construction with filtering conditions\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_72\n\nLANGUAGE: swift\nCODE:\n```\nlet bookAlias = TableAlias(name: \"b\")\nlet authorAlias = TableAlias(name: \"a\")\nlet request = Book.aliased(bookAlias)\n    .joining(required: Book.author.aliased(authorAlias)\n        .filter(sql: \"a.countryCode = ?\", arguments: [\"FR\"]))\n    .filter(sql: \"b.publishDate >= a.deathDate\")\n```\n\n----------------------------------------\n\nTITLE: Database Operations Without Transaction\nDESCRIPTION: Shows how database operations executed outside explicit transactions are handled by the observer.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\ntry dbQueue.writeWithoutTransaction { db in\n    try db.execute(sql: \"INSERT ...\") // 1. didChange, 2. willCommit, 3. didCommit\n    try db.execute(sql: \"UPDATE ...\") // 4. didChange, 5. willCommit, 6. didCommit\n}\n```\n\n----------------------------------------\n\nTITLE: SQLSpecificExpressible Extension Changes\nDESCRIPTION: API diff showing additions of nullable ordering terms to SQLSpecificExpressible when using custom SQLite builds.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_24\n\nLANGUAGE: diff\nCODE:\n```\n extension SQLSpecificExpressible {\n+    #if GRDBCUSTOMSQLITE\n+    var ascNullsLast: SQLOrderingTerm { get }\n+    var descNullsFirst: SQLOrderingTerm { get }\n+    #endif\n }\n```\n\n----------------------------------------\n\nTITLE: Using SQL Interpolation with Collations in Swift\nDESCRIPTION: Demonstrates how to embed collations into SQL literals using SQL interpolation. This feature allows for custom sorting rules when querying data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nlet request: SQLRequest<Player> = \"SELECT * FROM player ORDER BY email COLLATION \\(.nocase)\"\nlet request: SQLRequest<Player> = \"SELECT * FROM player ORDER BY name COLLATION \\(.localizedCompare)\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Immediate Scheduling with Combine Publisher in GRDB\nDESCRIPTION: Demonstrates how to set up immediate value scheduling when using ValueObservation with Combine publishers.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nlet observation = ValueObservation.tracking(Player.fetchAll)\nlet cancellable = observation\n    .publisher(\n        in: dbQueue, \n        // Opt in for immediate notification of the initial value\n        scheduling: .immediate)\n    .sink(...)\n```\n\n----------------------------------------\n\nTITLE: Converting Combined Observations to Single ValueObservation\nDESCRIPTION: Example of migrating from multiple combined observations to a single ValueObservation that maintains data consistency.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nstruct HallOfFame {\n    var totalPlayerCount: Int\n    var bestPlayers: [Player]\n}\n\n// BEFORE: GRDB 4\nlet totalPlayerCountObservation = ValueObservation.tracking(Player.fetchCount)\n\nlet bestPlayersObservation = ValueObservation.tracking(Player\n        .limit(10)\n        .order(Column(\"score\").desc)\n        .fetchAll)\n\nlet observation = ValueObservation\n    .combine(totalPlayerCountObservation, bestPlayersObservation)\n    .map(HallOfFame.init)\n\n// NEW: GRDB 5\nlet observation = ValueObservation.tracking { db -> HallOfFame in\n    let totalPlayerCount = try Player.fetchCount(db)\n    \n    let bestPlayers = try Player\n        .order(Column(\"score\").desc)\n        .limit(10)\n        .fetchAll(db)\n    \n    return HallOfFame(\n        totalPlayerCount: totalPlayerCount,\n        bestPlayers: bestPlayers)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DatabaseRegionConvertible Protocol in Swift\nDESCRIPTION: Protocol definition for DatabaseRegionConvertible which enables database region tracking for observability features.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nprotocol DatabaseRegionConvertible {\n    func databaseRegion(_ db: Database) throws -> DatabaseRegion\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Unicode61 Tokenizer in Swift\nDESCRIPTION: Shows how to configure the unicode61 tokenizer with options for diacritic handling in GRDB.swift.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\ntry db.create(virtualTable: \"book\", using: FTS5()) { t in\n    t.tokenizer = .unicode61()\n    t.tokenizer = .unicode61(diacritics: .keep)\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Table Query Without Alias\nDESCRIPTION: Example of an incorrect database query attempting to filter books by death date without proper table aliasing\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_69\n\nLANGUAGE: swift\nCODE:\n```\nlet request = Book\n    .joining(required: Book.author)\n    .filter(Column(\"publishDate\") >= Column(\"deathDate\"))\n```\n\n----------------------------------------\n\nTITLE: ValueObservation API Changes in Swift\nDESCRIPTION: Breaking changes to ValueObservation including scheduling and tracking modifications.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_37\n\nLANGUAGE: swift\nCODE:\n```\nenum ValueScheduling {\n    case async(onQueue: DispatchQueue, startImmediately: Bool)\n}\n\nstruct ValueObservation<Reducer> {\n    var extent: Database.TransactionObservationExtent\n    static func tracking(_ regions: DatabaseRegionConvertible..., reducer: Reducer) -> ValueObservation\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous memory release in GRDB\nDESCRIPTION: This snippet demonstrates how to release memory asynchronously using either DatabaseQueue's asyncWriteWithoutTransaction or DatabasePool's releaseMemoryEventually method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_218\n\nLANGUAGE: swift\nCODE:\n```\n// On a DatabaseQueue\ndbQueue.asyncWriteWithoutTransaction { db in\n    db.releaseMemory()\n}\n\n// On a DatabasePool\ndbPool.releaseMemoryEventually()\n```\n\n----------------------------------------\n\nTITLE: Updating QueryInterfaceRequest API in Swift\nDESCRIPTION: Changes to the QueryInterfaceRequest struct including modifying properties to methods and renaming the reverse method to reversed for more Swift-idiomatic naming.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_111\n\nLANGUAGE: swift\nCODE:\n```\nstruct QueryInterfaceRequest<T> {\n-    var distinct: QueryInterfaceRequest<T> { get }\n-    var exists: _SQLExpression { get }\n-    func reverse() -> QueryInterfaceRequest<T>\n+    func distinct() -> QueryInterfaceRequest<T>\n+    func exists() -> _SQLExpression\n+    func reversed() -> QueryInterfaceRequest<T>\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Deferred SQL Transaction Example\nDESCRIPTION: Shows an empty deferred SQL transaction that is no longer notified to transaction observers as of GRDB 2.2.0. This change was made to align with SQLite's behavior of not considering empty deferred transactions as actual transactions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_56\n\nLANGUAGE: SQL\nCODE:\n```\n-- Nothing happens, and thus no notification is sent\nBEGIN TRANSACTION\nCOMMIT\n```\n\n----------------------------------------\n\nTITLE: Inspecting Git Tags in Bash\nDESCRIPTION: Git command to examine all tags in the repository along with their authors, helping to identify any undesired tags before release.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/ReleaseProcess.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit for-each-ref --format '%(refname) %(authorname)' refs/tags\n```\n\n----------------------------------------\n\nTITLE: Modifying FetchedRecordsController API in Swift\nDESCRIPTION: Changes to the FetchedRecordsController API, including making fetchedRecords a non-optional property and inferring the fetched record type from the request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_89\n\nLANGUAGE: Swift\nCODE:\n```\nfinal class FetchedRecordsController<Record: RowConvertible> {\n-    var fetchedRecords: [Record]?\n+    var fetchedRecords: [Record]\n}\n\nfinal class FetchedRecordsController<Record: RowConvertible> {\n-    convenience init(...:request: Request) throws\n+    convenience init<Request>(...:request: Request) throws where Request: TypedRequest, Request.Fetched == Record\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Player Model with Timestamp Properties in Swift\nDESCRIPTION: Defines a Player struct with optional timestamp fields to represent records that might not yet be saved to the database. The optional timestamps indicate whether a record has been persisted.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nstruct Player {\n    var id: Int64?\n    var creationDate: Date?\n    var modificationDate: Date?\n    var name: String\n    var score: Int\n}\n```\n\n----------------------------------------\n\nTITLE: Updated TableMapping Configuration\nDESCRIPTION: Demonstrates the migration from selectsRowID property to databaseSelection array in TableMapping protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_66\n\nLANGUAGE: swift\nCODE:\n```\n struct Player: TableMapping {\n-    static let selectsRowID = true\n+    static let databaseSelection: [SQLSelectable] = [AllColumns(), Column.rowID]\n }\n```\n\n----------------------------------------\n\nTITLE: Extension to Set for Cursor Initialization\nDESCRIPTION: Adds a new initializer to Set that creates a set from a Cursor where the cursor's element type matches the set's element type.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_71\n\nLANGUAGE: diff\nCODE:\n```\n+extension Set {\n+    init<C: Cursor>(_ cursor: C) throws where C.Element == Element\n+}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Primary Key in GRDB.swift\nDESCRIPTION: This method retrieves information about the primary key of a specific table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_7\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/primaryKey(_:in:)\n```\n\n----------------------------------------\n\nTITLE: Version 2.4.2 Release Notes in Markdown\nDESCRIPTION: Release notes for version 2.4.2 (January 6, 2018) addressing fixes for schema introspection methods in database pools and restrictions on the DatabasePool.readFromCurrentState method when transactions are already active.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_54\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.4.2\n\nReleased January 6, 2018 &bull; [diff](https://github.com/groue/GRDB.swift/compare/v2.4.1...v2.4.2)\n\n**Fixed**\n\n- When using a database pool, the schema introspection methods could return wrong values whenever the database schema was concurrently read and modified. This has been fixed.\n- `DatabasePool.readFromCurrentState` no longer accepts to spawn a reader when a transaction is currently opened on the writer connection.\n```\n\n----------------------------------------\n\nTITLE: Implementing selectID Method Using selectPrimaryKey in Swift\nDESCRIPTION: Demonstrates how to implement a custom selectID() method using the new selectPrimaryKey() method as a replacement for the removed built-in selectID() method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nextension QueryInterfaceRequest<Player> {\n    func selectID() -> QueryInterfaceRequest<Int64> {\n        selectPrimaryKey()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Enforced Async/Await in Swift Function Definitions\nDESCRIPTION: Demonstrates how the Swift compiler enforces proper async/await usage in function signatures. When a function is marked as async, the compiler requires the await keyword for database operations, ensuring proper concurrency handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nfunc fetchPlayers() async throws -> [Player] {\n    try await writer.read(Player.fetchAll)\n}\n```\n\n----------------------------------------\n\nTITLE: Version 2.6.1 Release Notes in Markdown\nDESCRIPTION: Release notes for version 2.6.1 (January 19, 2018) which fixed a crash that could happen when a transaction observer uses the stopObservingDatabaseChangesUntilNextTransaction() method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_51\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.6.1\n\nReleased January 19, 2018 &bull; [diff](https://github.com/groue/GRDB.swift/compare/v2.6.0...v2.6.1)\n\n**Fixed**\n\n- Fixed a crash that could happen when a transaction observer uses the `stopObservingDatabaseChangesUntilNextTransaction()` method.\n```\n\n----------------------------------------\n\nTITLE: Querying External Content Full-Text Tables with JOIN in SQL\nDESCRIPTION: Shows how to query a regular table with full-text search capabilities by joining it with its external content full-text table. This approach is necessary since SQLite cannot perform full-text searches directly on regular tables.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/FullTextSearch.md#2025-04-22_snippet_21\n\nLANGUAGE: sql\nCODE:\n```\nSELECT book.*\nFROM book\nJOIN book_ft\n    ON book_ft.rowid = book.rowid\n    AND book_ft MATCH ?\n```\n\n----------------------------------------\n\nTITLE: Modifying Change Tracking API in Swift\nDESCRIPTION: Updates the change tracking API for FetchedRecordsController, renaming methods and parameters.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_91\n\nLANGUAGE: Swift\nCODE:\n```\nfinal class FetchedRecordsController<Record: RowConvertible> {\n-    func trackChanges(recordsWillChange:tableViewEvent:recordsDidChange:)\n+    func trackChanges(willChange:onChange:didChange:)\n}\n```\n\n----------------------------------------\n\nTITLE: Prepared Statements Interface Updates\nDESCRIPTION: Changes to prepared statement creation and validation methods, including updates to argument handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_106\n\nLANGUAGE: diff\nCODE:\n```\n class Database {\n-    func selectStatement(sql: String) throws -> SelectStatement\n-    func updateStatement(sql: String) throws -> SelectStatement\n+    func makeSelectStatement(_ sql: String) throws -> SelectStatement\n+    func makeUpdateStatement(_ sql: String) throws -> SelectStatement\n }\n```\n\n----------------------------------------\n\nTITLE: Configuring Double-Quoted String Literals Support in SQLite\nDESCRIPTION: Shows how to enable the Double-quoted String Literals feature in SQLite, which is disabled by default in GRDB 4.7.0 custom SQLite builds.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\n// Enable support for the Double-quoted String Literals misfeature\nvar configuration = Configuration()\nconfiguration.acceptsDoubleQuotedStringLiterals = true\nlet dbQueue = try DatabaseQueue(path: ..., configuration: configuration)\n```\n\n----------------------------------------\n\nTITLE: Accessing Statement from Row Cursor\nDESCRIPTION: Shows how to access the underlying statement from a RowCursor object.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_63\n\nLANGUAGE: swift\nCODE:\n```\nlet rows = try Row.fetchCursor(db, \"SELECT ...\")\nlet statement = rows.statement\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fluent's Fatal Error on Unloaded Relationships\nDESCRIPTION: This snippet shows how Fluent raises a fatal error when trying to access a relationship that wasn't explicitly loaded. It highlights the potential runtime issues with Fluent's approach.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\n// Oops, the books relation is not explicitly requested\nlet query = Author.query(on: db).first()\nif let author = query.get() {\n    // fatal error: Children relation not eager loaded.\n    for book in author.books { print(book.title) } \n}\n```\n\n----------------------------------------\n\nTITLE: API Changes in GRDB.swift 3.4.0\nDESCRIPTION: Shows API modifications in version 3.4.0, including association aggregates, group methods, and new extensions to various protocols and classes.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_41\n\nLANGUAGE: diff\nCODE:\n```\n protocol AggregatingRequest {\n-    func group(_ expressions: [SQLExpressible]) -> Self\n+    func group(_ expressions: @escaping (Database) throws -> [SQLExpressible]) -> Self\n }\n\n+extension AggregatingRequest {\n+    func group(_ expressions: [SQLExpressible]) -> Self\n+}\n\n+extension TableRequest where Self: AggregatingRequest {\n+    func groupByPrimaryKey() -> Self {\n+}\n\n+struct AssociationAggregate<RowDecoder> {\n+    func aliased(_ name: String) -> AssociationAggregate<RowDecoder>\n+    func aliased(_ key: CodingKey) -> AssociationAggregate<RowDecoder>\n+}\n\n+extension HasManyAssociation where Origin: TableRecord, Destination: TableRecord {\n+    var count: AssociationAggregate<Origin>\n+    var isEmpty: AssociationAggregate<Origin>\n+    func average(_ expression: SQLExpressible) -> AssociationAggregate<Origin>\n+    func max(_ expression: SQLExpressible) -> AssociationAggregate<Origin>\n+    func min(_ expression: SQLExpressible) -> AssociationAggregate<Origin>\n+    func sum(_ expression: SQLExpressible) -> AssociationAggregate<Origin>\n+}\n\n+extension QueryInterfaceRequest {\n+    func annotated(with selection: [SQLSelectable]) -> QueryInterfaceRequest<RowDecoder>\n+}\n\n+extension QueryInterfaceRequest where RowDecoder: TableRecord {\n+    func annotated(with aggregates: AssociationAggregate<RowDecoder>...) -> QueryInterfaceRequest<RowDecoder>\n+    func annotated(with aggregates: [AssociationAggregate<RowDecoder>]) -> QueryInterfaceRequest<RowDecoder>\n+    func having(_ aggregate: AssociationAggregate<RowDecoder>) -> QueryInterfaceRequest<RowDecoder>\n+}\n\n+extension TableRecord {\n+    static func annotated(with aggregates: AssociationAggregate<Self>...) -> QueryInterfaceRequest<Self>\n+    static func annotated(with aggregates: [AssociationAggregate<Self>]) -> QueryInterfaceRequest<Self>\n+    static func having(_ aggregate: AssociationAggregate<Self>) -> QueryInterfaceRequest<Self>\n+}\n\n+extension SQLSpecificExpressible {\n+    func aliased(_ key: CodingKey) -> SQLSelectable\n+}\n```\n\n----------------------------------------\n\nTITLE: Publishing to CocoaPods in Bash\nDESCRIPTION: Command to push the updated podspec to CocoaPods trunk, allowing for warnings that might occur during the process.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/ReleaseProcess.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npod trunk push --allow-warnings GRDB.swift.podspec\n```\n\n----------------------------------------\n\nTITLE: Implementing TransactionObserver Protocol with Pre-Update Hook in Swift\nDESCRIPTION: This snippet shows the TransactionObserver protocol with an additional method for pre-update hooks when SQLite is built with SQLITE_ENABLE_PREUPDATE_HOOK option. It allows observation of individual column values in modified rows.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nprotocol TransactionObserver: AnyObject {\n    #if SQLITE_ENABLE_PREUPDATE_HOOK\n    /// Notifies before a database change (insert, update, or delete)\n    /// with change information (initial / final values for the row's\n    /// columns).\n    ///\n    /// The event is only valid for the duration of this method call. If you\n    /// need to keep it longer, store a copy: event.copy().\n    func databaseWillChange(with event: DatabasePreUpdateEvent)\n    #endif\n}\n```\n\n----------------------------------------\n\nTITLE: Touching Record to Update Timestamp\nDESCRIPTION: Shows how to update only the modification timestamp of a record without changing other fields.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordTimestamps.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// Only update the modification date in the database.\ntry player.touch(db)\n```\n\n----------------------------------------\n\nTITLE: Setting Swift Compiler Flags in GRDBCustomSQLite-USER.xcconfig\nDESCRIPTION: Configuration file that enables extra GRDB APIs by passing SQLite compilation options to the Swift compiler. Note the space between -D and option names, unlike the C compiler flags.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CustomSQLiteBuilds.md#2025-04-22_snippet_2\n\nLANGUAGE: xcconfig\nCODE:\n```\n// As many -D options as there are custom SQLite compilation options\n// Note: there is one space between -D and the option name.\nCUSTOM_OTHER_SWIFT_FLAGS = -D SQLITE_ENABLE_SNAPSHOT -D SQLITE_ENABLE_FTS5\n```\n\n----------------------------------------\n\nTITLE: Database Pool Access with Passphrase Availability Considerations\nDESCRIPTION: Illustrates how DatabasePool operations may fail when a passphrase becomes unavailable during runtime. Shows examples of read and write operations that could fail if the passphrase is no longer accessible.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_194\n\nLANGUAGE: swift\nCODE:\n```\n// Success if and only if the passphrase is available\nlet dbPool = try DatabasePool(path: dbPath, configuration: config)\n\n// May fail if passphrase has turned unavailable\ntry dbPool.read { ... }\n\n// May trigger value observation failure if passphrase has turned unavailable\ntry dbPool.write { ... }\n```\n\n----------------------------------------\n\nTITLE: Using non-unicode-aware SQLite UPPER function in Swift\nDESCRIPTION: This example demonstrates the limitation of SQLite's built-in UPPER function, which is not unicode-aware and fails to properly handle accented characters like 'é'.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_211\n\nLANGUAGE: swift\nCODE:\n```\n// \"JéRôME\"\ntry String.fetchOne(db, sql: \"SELECT UPPER('Jérôme')\")\n```\n\n----------------------------------------\n\nTITLE: Creating Set from Database Cursor\nDESCRIPTION: Demonstrates how to create a Set from a database cursor result.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_64\n\nLANGUAGE: swift\nCODE:\n```\nlet strings = try Set(String.fetchCursor(...))\n```\n\n----------------------------------------\n\nTITLE: Updating Fetching Methods in Swift\nDESCRIPTION: Shows the changes in fetching methods, replacing fetch with fetchCursor and updating related types and error handling.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_95\n\nLANGUAGE: Swift\nCODE:\n```\n// No longer supported\nlet persons = Person.fetch(db) // DatabaseSequence<Person>\nfor person in persons {        // Person\n    ...\n}\n\n// New\nlet persons = try Person.fetchCursor(db) // DatabaseCursor<Person>\nwhile person = try persons.next() {      // Person\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Performance Report in Bash with Ruby Processing\nDESCRIPTION: Command pipeline that runs performance tests, parses the results with a Ruby script, and then generates a performance report for documentation.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/ReleaseProcess.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake test_performance | Tests/parsePerformanceTests.rb | Tests/generatePerformanceReport.rb\n```\n\n----------------------------------------\n\nTITLE: Using GRDB with Custom SQLite Build in Swift\nDESCRIPTION: Example of importing GRDB and initializing a DatabaseQueue after configuring the custom SQLite build.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CustomSQLiteBuilds.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nimport GRDB\n\nlet dbQueue = try DatabaseQueue(...)\n```\n\n----------------------------------------\n\nTITLE: Experimental API Change for SQLCount\nDESCRIPTION: Changes the SQLCount enum case from 'star' to 'all' in the experimental API.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_75\n\nLANGUAGE: diff\nCODE:\n```\n enum SQLCount {\n-    case star\n+    case all\n }\n```\n\n----------------------------------------\n\nTITLE: Accessing SQLite C Functions in GRDB 7\nDESCRIPTION: GRDB 7 changes how SQLite C functions are accessed. This example shows the additional imports required depending on how GRDB is integrated in your project.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB7MigrationGuide.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 6\nimport GRDB\n\nlet sqliteVersion = sqlite3_libversion_number()\n```\n\nLANGUAGE: swift\nCODE:\n```\nimport SQLite3\n\nlet sqliteVersion = sqlite3_libversion_number()\n```\n\nLANGUAGE: swift\nCODE:\n```\nimport SQLCipher\n\nlet sqliteVersion = sqlite3_libversion_number()\n```\n\n----------------------------------------\n\nTITLE: Version 2.5.0 Release Notes and API Changes in Markdown and Diff\nDESCRIPTION: Release notes for version 2.5.0 (January 11, 2018) describing fixes for transaction observers and new query interface capabilities for building requests from primary and unique keys. Includes both textual description and API diff.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_53\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.5.0\n\nReleased January 11, 2018 &bull; [diff](https://github.com/groue/GRDB.swift/compare/v2.4.2...v2.5.0)\n\n### Fixed\n\n- [Transaction observers](https://github.com/groue/GRDB.swift/blob/master/README.md#transactionobserver-protocol) used to be notified of some database changes they were not interested into, in case of complex statements with side effects (foreign key cascades or sql triggers). This has been fixed.\n\n\n### New\n\n- The query interface has learned to build requests from any key (primary keys and unique keys) ([documentation](https://github.com/groue/GRDB.swift/blob/master/README.md#fetching-by-key)):\n    \n    ```swift\n    // SELECT * FROM players WHERE id = 1\n    let request = Player.filter(key: 1)\n    let player = try request.fetchOne(db)    // Player?\n    \n    // SELECT * FROM countries WHERE isoCode IN ('FR', 'US')\n    let request = Country.filter(keys: [\"FR\", \"US\"])\n    let countries = try request.fetchAll(db) // [Country]\n    \n    // SELECT * FROM players WHERE email = 'arthur@example.com'\n    let request = Player.filter(key: [\"email\": \"arthur@example.com\"])\n    let player = try request.fetchOne(db)    // Player?\n    ```\n    \n    This feature has been introduced in order to ease the use of [RxGRDB](https://github.com/RxSwiftCommunity/RxGRDB):\n    \n    ```swift\n    // New\n    Player.filter(key: 1).rx\n        .fetchOne(in: dbQueue)\n        .subscribe(onNext: { player: Player? in\n            print(\"Player 1 has changed\")\n        })\n    ```\n```\n\nLANGUAGE: diff\nCODE:\n```\n### API diff\n\n```diff\n extension TableMapping {\n+    static func filter<PrimaryKeyType: DatabaseValueConvertible>(key: PrimaryKeyType?) -> QueryInterfaceRequest<Self>\n+    static func filter<Sequence: Swift.Sequence>(keys: Sequence) -> QueryInterfaceRequest<Self> where Sequence.Element: DatabaseValueConvertible\n+    static func filter(key: [String: DatabaseValueConvertible?]?) -> QueryInterfaceRequest<Self>\n+    static func filter(keys: [[String: DatabaseValueConvertible?]]) -> QueryInterfaceRequest<Self>\n }\n \n extension QueryInterfaceRequest where T: TableMapping {\n+    func filter<PrimaryKeyType: DatabaseValueConvertible>(key: PrimaryKeyType?) -> QueryInterfaceRequest<T>\n+    func filter<Sequence: Swift.Sequence>(keys: Sequence) -> QueryInterfaceRequest<T> where Sequence.Element: DatabaseValueConvertible\n+    func filter(key: [String: DatabaseValueConvertible?]?) -> QueryInterfaceRequest<T>\n+    func filter(keys: [[String: DatabaseValueConvertible?]]) -> QueryInterfaceRequest<T>\n }\n \n extension RowConvertible where Self: TableMapping {\n-    static func fetchOne(_ db: Database, key: [String: DatabaseValueConvertible?]) throws -> Self?\n+    static func fetchOne(_ db: Database, key: [String: DatabaseValueConvertible?]?) throws -> Self?\n }\n```\n```\n\n----------------------------------------\n\nTITLE: Cursor Class Renaming in GRDB.swift 3.3.0-beta1\nDESCRIPTION: Renaming of cursor classes for optimized database value access, with deprecation notices for the old class names.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_46\n\nLANGUAGE: diff\nCODE:\n```\n+final class FastDatabaseValueCursor<Value: DatabaseValueConvertible & StatementColumnConvertible> : Cursor { }\n+@available(*, deprecated, renamed: \"FastDatabaseValueCursor\")\n+typealias ColumnCursor<Value: DatabaseValueConvertible & StatementColumnConvertible> = FastDatabaseValueCursor<Value>\n\n+final class FastNullableDatabaseValueCursor<Value: DatabaseValueConvertible & StatementColumnConvertible> : Cursor { }\n+@available(*, deprecated, renamed: \"FastNullableDatabaseValueCursor\")\n+typealias NullableColumnCursor<Value: DatabaseValueConvertible & StatementColumnConvertible> = FastNullableDatabaseValueCursor<Value>\n```\n\n----------------------------------------\n\nTITLE: Initializing DatabaseValue from Swift Types in Swift\nDESCRIPTION: Shows how to create DatabaseValue instances from Swift types like Int and String using the databaseValue property. This is part of changes in version 0.35.0 that removed public initializers from DatabaseValue.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_121\n\nLANGUAGE: Swift\nCODE:\n```\n1.databaseValue\n\"foo\".databaseValue\n```\n\n----------------------------------------\n\nTITLE: Implementing Immediate Value Scheduling in GRDB ValueObservation\nDESCRIPTION: Shows how to configure immediate synchronous delivery of initial values using the scheduling parameter in ValueObservation.start() method. Must be called from the main thread.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nlet observation = ValueObservation.tracking(Player.fetchAll)\nlet cancellable = observation.start(\n    in: dbQueue,\n    // Opt in for immediate notification of the initial value\n    scheduling: .immediate,\n    onError: { error in ... },\n    onChange: { [weak self] (players: [Player]) in\n        guard let self else { return }\n        self.updateView(players)\n    })\n// <- Here the view has already been updated.\n```\n\n----------------------------------------\n\nTITLE: Defining SQLite Options in GRDBCustomSQLite-USER.h\nDESCRIPTION: Header file that lets the application know about extra SQLite compilation options by defining them as C preprocessor macros.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CustomSQLiteBuilds.md#2025-04-22_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n// As many #define as there are custom SQLite compilation options\n#define SQLITE_ENABLE_SNAPSHOT\n#define SQLITE_ENABLE_FTS5\n```\n\n----------------------------------------\n\nTITLE: Cloning GRDB Repository and Initializing SQLite Custom Source\nDESCRIPTION: Commands to clone the GRDB git repository, checkout the latest tagged version, and initialize the SQLite custom source submodule.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CustomSQLiteBuilds.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd [GRDB directory]\ngit checkout [latest tag]\ngit submodule update --init SQLiteCustom/src\n```\n\n----------------------------------------\n\nTITLE: Updating FetchRequest Protocol Method Signature in Swift\nDESCRIPTION: A change to the FetchRequest protocol's prepare method signature, updating the parameter label from 'db:' to just '_:' for the Database parameter.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_109\n\nLANGUAGE: swift\nCODE:\n```\nprotocol FetchRequest {\n-    func prepare(db: Database) throws -> (SelectStatement, RowAdapter?)\n+    func prepare(_ db: Database) throws -> (SelectStatement, RowAdapter?)\n}\n```\n\n----------------------------------------\n\nTITLE: Running GRDB Swift Smoke Tests\nDESCRIPTION: Command to run minimal testing of GRDB with system SQLite, SQLCipher, custom SQLite builds, and SPM integration. This should be executed before submitting a pull request.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nmake smokeTest\n```\n\n----------------------------------------\n\nTITLE: Deprecating primaryKeyRowComparator Method\nDESCRIPTION: Deprecates the primaryKeyRowComparator method in the TableMapping extension.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_73\n\nLANGUAGE: diff\nCODE:\n```\n extension TableMapping {\n-    @available(*, deprecated) static func primaryKeyRowComparator(_ db: Database) throws -> (Row, Row) -> Bool\n }\n```\n\n----------------------------------------\n\nTITLE: Accessing Statement Properties through Cursor in Swift\nDESCRIPTION: Shows how to migrate from accessing statement properties through the cursor.statement property to using dedicated cursor properties like sql and columnNames.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_13\n\nLANGUAGE: diff\nCODE:\n```\n-let sql = cursor.statement.sql\n-let columns = cursor.statement.columnNames\n+let sql = cursor.sql\n+let columns = cursor.columnNames\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Loading with Ruby's Active Record\nDESCRIPTION: This snippet shows how lazy loading works in Ruby's Active Record. It fetches the first author and then lazily loads their books when accessed.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/RecordRecommendedPractices.md#2025-04-22_snippet_19\n\nLANGUAGE: ruby\nCODE:\n```\n# Lazy loading with Active Record\nauthor = Author.first       # Fetch first author\nputs author.name\nauthor.books.each do |book| # Lazily fetch books on demand\n  puts book.title\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Non-Sendable Record Types in Swift Concurrency\nDESCRIPTION: Shows compiler errors when using non-Sendable record types with GRDB operations. The example demonstrates the issues that occur when trying to fetch, insert, or observe a class-based record type that doesn't conform to Sendable.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// A non-Sendable record type\nfinal class Player: Codable, Identifiable {\n    var id: Int64\n    var name: String\n    var score: Int\n}\n\nextension Player: FetchableRecord, PersistableRecord { }\n\n// ❌ Type 'Player' does not conform to the 'Sendable' protocol\nlet player = try await writer.read { db in\n    try Player.fetchOne(db, id: 42)\n}\n\n// ❌ Capture of 'player' with non-sendable type 'Player' in a `@Sendable` closure\nlet player: Player\ntry await writer.read { db in\n    try player.insert(db)\n}\n\n// ❌ Type 'Player' does not conform to the 'Sendable' protocol\nlet observation = ValueObservation.tracking { db in\n    try Player.fetchAll(db)\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating GRDBCombine Publisher Configuration\nDESCRIPTION: Shows how to update GRDBCombine fetchOnSubscription() calls to use the new scheduling parameter in GRDB 5.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4 + GRDBCombine\nlet observation = ValueObservation.tracking { db in ... }\nlet publisher = observation\n    .publisher(in: dbQueue)\n    .fetchOnSubscription()\n\n// NEW: GRDB 5\nlet observation = ValueObservation.tracking { db in ... }\nlet publisher = observation\n    .publisher(in: dbQueue, scheduling: .immediate)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Immediate Scheduling with RxGRDB\nDESCRIPTION: Shows configuration of immediate value scheduling when using ValueObservation with RxGRDB integration.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\nlet observation = ValueObservation.tracking(Player.fetchAll)\nlet disposable = observation\n    .rx.observe(\n        in: dbQueue, \n        // Opt in for immediate notification of the initial value\n        scheduling: .immediate)\n    .subscribe(...)\n```\n\n----------------------------------------\n\nTITLE: Renaming SQLColumn to Column in Swift\nDESCRIPTION: Changing the name of the SQLColumn struct to the simpler Column, making the API more concise.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_110\n\nLANGUAGE: swift\nCODE:\n```\n-struct SQLColumn {}\n+struct Column {}\n```\n\n----------------------------------------\n\nTITLE: Checking GRDB Internal Table in GRDB.swift\nDESCRIPTION: This method checks if a table is a GRDB internal table.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/DatabaseSchemaIntrospection.md#2025-04-22_snippet_9\n\nLANGUAGE: Swift\nCODE:\n```\nDatabase/isGRDBInternalTable(_:)\n```\n\n----------------------------------------\n\nTITLE: Migrating Database Trace Configuration from GRDB 4 to GRDB 5\nDESCRIPTION: Shows how to migrate from the deprecated Configuration.trace property to the new Database.trace method in GRDB 5. The new approach uses the prepareDatabase configuration method to access the database connection for trace setup.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nvar config = Configuration()\nconfig.trace = { print($0) }\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n \n// NEW: GRDB 5\nvar config = Configuration()\nconfig.prepareDatabase { db in\n    db.trace { print($0) }\n}\nlet dbQueue = try DatabaseQueue(path: dbPath, configuration: config)\n```\n\n----------------------------------------\n\nTITLE: Pre-action Script for Build Phase\nDESCRIPTION: Shell command to be added to the pre-actions section of the application build scheme to run the installation script before building.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/CustomSQLiteBuilds.md#2025-04-22_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nsource \"${PROJECT_DIR}/GRDBCustomSQLite/GRDBCustomSQLite-INSTALL.sh\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Change Tracking Control in Observer\nDESCRIPTION: Example of an observer that can stop tracking changes until the next transaction using stopObservingDatabaseChangesUntilNextTransaction().\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/Extension/TransactionObserver.md#2025-04-22_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\nclass PlayerObserver: TransactionObserver {\n    var playerTableWasModified = false\n\n    func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {\n        eventKind.tableName == \"player\"\n    }\n\n    func databaseDidChange(with event: DatabaseEvent) {\n        playerTableWasModified = true\n\n        // It is pointless to keep on tracking further changes:\n        stopObservingDatabaseChangesUntilNextTransaction()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating FetchedRecordsController Initialization in Swift\nDESCRIPTION: Removes the explicit compareRecordsByPrimaryKey parameter from FetchedRecordsController initialization for types adopting TableMapping protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_90\n\nLANGUAGE: Swift\nCODE:\n```\nextension FetchedRecordsController where Record: TableMapping {\n-    convenience init(...:compareRecordsByPrimaryKey: Bool) throws\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean SQL Generation Changes in GRDB 5\nDESCRIPTION: Shows the difference in SQL generation for explicit boolean tests between GRDB 4 and 5. GRDB 5 generates explicit equality comparisons for boolean values, which can be a breaking change for non-standard boolean representations.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_20\n\nLANGUAGE: swift\nCODE:\n```\n// GRDB 4: SELECT * FROM player WHERE isActive\n// GRDB 5: SELECT * FROM player WHERE isActive = 1\nPlayer.filter(Column(\"isActive\") == true)\n\n// GRDB 4: SELECT * FROM player WHERE NOT isActive\n// GRDB 5: SELECT * FROM player WHERE isActive = 0\nPlayer.filter(Column(\"isActive\") == false)\n\n// GRDB 4 & 5: SELECT * FROM player WHERE isActive\nPlayer.filter(Column(\"isActive\"))\n\n// GRDB 4 & 5: SELECT * FROM player WHERE NOT isActive\nPlayer.filter(!Column(\"isActive\"))\n```\n\n----------------------------------------\n\nTITLE: Executing Multiple SQL Queries with Associations in Swift\nDESCRIPTION: Shows how QueryInterfaceRequest with associations can execute multiple SQL queries to fetch related data.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT * FROM player\n// SELECT * FROM award WHERE playerId IN (...)\nstruct PlayerInfo: Decodable, FetchableRecord {\n    var player: Player\n    var awards: [Award]\n}\nlet playerInfos = try Player\n    .including(all: Player.awards)\n    .asRequest(of: PlayerInfo.self)\n    .fetchAll(db)\n```\n\n----------------------------------------\n\nTITLE: Row Handling Updates for Swift 3\nDESCRIPTION: Changes to Row class initialization and dictionary conversion methods, replacing NSDictionary with Swift dictionary types.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_102\n\nLANGUAGE: diff\nCODE:\n```\n final class Row {\n-    init?(_ dictionary: NSDictionary)\n-    func toNSDictionary() -> NSDictionary\n+    init?(_ dictionary: [AnyHashable: Any])\n }\n```\n\n----------------------------------------\n\nTITLE: Defining DerivableRequest Protocol in Swift\nDESCRIPTION: Protocol definition for DerivableRequest which provides refinement capabilities to queries and associations through a composition of multiple request protocols.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/QueryInterfaceOrganization.md#2025-04-22_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nprotocol DerivableRequest<RowDecoder>: AggregatingRequest, FilteredRequest,\n                                       JoinableRequest, OrderedRequest,\n                                       SelectionRequest, TableRequest\n{\n    func distinct() -> Self\n    func with<RowDecoder>(_ cte: CommonTableExpression<RowDecoder>) -> Self\n}\n```\n\n----------------------------------------\n\nTITLE: Codable Support Enhancements in GRDB.swift 3.3.0-beta1\nDESCRIPTION: New customization options for Codable records including user info context, date decoding strategy, and JSON encoding/decoding for specific columns.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_44\n\nLANGUAGE: diff\nCODE:\n```\n protocol FetchableRecord {\n+    static var databaseDecodingUserInfo: [CodingUserInfoKey: Any] { get }\n+    static var databaseDateDecodingStrategy: DatabaseDateDecodingStrategy { get }\n+    static func databaseJSONDecoder(for column: String) -> JSONDecoder\n }\n\n protocol MutablePersistableRecord: TableRecord {\n+    static var databaseEncodingUserInfo: [CodingUserInfoKey: Any] { get }\n+    static var databaseDateEncodingStrategy: DatabaseDateEncodingStrategy { get }\n+    static var databaseUUIDEncodingStrategy: DatabaseUUIDEncodingStrategy { get }\n+    static func databaseJSONEncoder(for column: String) -> JSONEncoder\n }\n```\n\n----------------------------------------\n\nTITLE: Version 2.8.0 Release Notes in Markdown\nDESCRIPTION: Release notes for version 2.8.0 (January 29, 2018) highlighting the upgrade to SQLite v3.22.0, FTS5 enhancements with initial token queries, and extensions to the Cursor protocol with methods inspired by the standard Sequence protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_49\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.8.0\n\nReleased January 29, 2018 &bull; [diff](https://github.com/groue/GRDB.swift/compare/v2.7.0...v2.8.0)\n\n**New**\n\n- Upgrade custom SQLite builds to [v3.22.0](https://www.sqlite.org/changes.html) (thanks to [@swiftlyfalling](https://github.com/swiftlyfalling/SQLiteLib)).\n- The FTS5 full-text search engine has been enhanced with [initial token queries](https://sqlite.org/fts5.html#carrotq), and FTS5Pattern has gained a new initializer: `FTS5Pattern(matchingPrefixPhrase:)`\n- The `Cursor` protocol is extended with more methods inspired by the standard Sequence protocol: `drop(while:)`, `dropFirst()`, `dropFirst(_:)`, `dropLast()`, `dropLast(_:)`, `joined(separator:)`, `prefix(_:)`, `max()`, `max(by:)`, `min()`, `min(by:)`, `prefix(while:)`, `reduce(into:_:)`, `suffix(_:)`,\n```\n\n----------------------------------------\n\nTITLE: MutablePersistable Protocol Method Signatures in Swift\nDESCRIPTION: Shows the updated method signatures for the MutablePersistable protocol. These methods now accept DatabaseWriter instead of Database parameters, enabling direct operations on database queues and pools.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_118\n\nLANGUAGE: swift\nCODE:\n```\nprotocol MutablePersistable {\n    mutating func insert(db: DatabaseWriter) throws\n    func update(db: DatabaseWriter) throws\n    mutating func save(db: DatabaseWriter) throws\n    func delete(db: DatabaseWriter) throws -> Bool\n    func exists(db: DatabaseReader) -> Bool\n}\n\nprotocol Persistable {\n    func insert(db: DatabaseWriter) throws\n    func save(db: DatabaseWriter) throws\n}\n\nclass Record {\n    func insert(db: DatabaseWriter) throws\n    func update(db: DatabaseWriter) throws\n    func save(db: DatabaseWriter) throws\n    func delete(db: DatabaseWriter) throws -> Bool\n    func exists(db: DatabaseReader) -> Bool\n}\n```\n\n----------------------------------------\n\nTITLE: Updating DerivableRequest Extension Syntax in Swift\nDESCRIPTION: Demonstrates the simplified syntax for DerivableRequest protocol extensions using primary associated types enabled by SE-0346. Shows how to order books by title using localized case-insensitive comparison.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB6MigrationGuide.md#2025-04-22_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n-extension DerivableRequest where RowDecoder == Book {\n+extension DerivableRequest<Book> {\n     /// Order books by title, in a localized case-insensitive fashion\n     func orderByTitle() -> Self {\n         order(Column(\"title\").collating(.localizedCaseInsensitiveCompare))\n     }\n }\n```\n\n----------------------------------------\n\nTITLE: Installing SQLite Custom Build for GRDB Swift\nDESCRIPTION: Command to set up a custom SQLite build for GRDB development. This step is recommended to avoid Xcode warnings when working on the project.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nmake SQLiteCustom\n```\n\n----------------------------------------\n\nTITLE: Incorrect Approach to HallOfFame Publisher Using combineLatest in Swift\nDESCRIPTION: Demonstrates an incorrect approach that loses data consistency by combining multiple independent database publishers. This can lead to assertion failures when database changes happen between publisher emissions.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/Combine.md#2025-04-22_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n// OK\nlet totalPlayerCountPublisher = ValueObservation\n    .tracking(Player.fetchCount)\n    .publisher(in: dbQueue)\n\n// OK\nlet bestPlayerPublisher = ValueObservation\n    .tracking(Player\n              .order(Column(\"score\").desc)\n              .limit(10)\n              .fetchAll)\n    .publisher(in: dbQueue)\n\n// NOT OK: DATA CONSISTENCY NOT GUARANTEED\nlet hallOfFamePublisher = totalPlayerCountPublisher\n    .combineLatest(bestPlayerPublisher)\n    .map(HallOfFame.init(totalPlayerCount:bestPlayers))\n\nlet cancellable = hallOfFamePublisher.sink(\n    receiveCompletion: { completion in ... },\n    receiveValue: { hallOfFame in\n        // ASSERTION MAY FAIL if some players are deleted\n        // at the wrong time\n        assert(hallOfFame.bestPlayers.count <= hallOfFame.totalPlayerCount)\n    })\n```\n\n----------------------------------------\n\nTITLE: Missing Await Detection in Swift Task Closures\nDESCRIPTION: Illustrates a Swift compiler limitation where it doesn't detect missing await keywords inside Task closures. This can lead to blocking the cooperative thread pool and potential deadlocks or performance issues.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/GRDB/Documentation.docc/SwiftConcurrency.md#2025-04-22_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nTask {\n    // The compiler does not spot the missing `await`\n    let players = try writer.read(Player.fetchAll)\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing ValueObservation Creation Between GRDB 4 and 5\nDESCRIPTION: Compares the old and new ways of creating ValueObservation instances, showing how specialized observation methods have been replaced with a more consistent API in GRDB 5.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nlet observation = request.observationForCount()\nlet observation = request.observationForFirst()\nlet observation = request.observationForAll()\nlet observation = ValueObservation.tracking(value: someFetchFunction)\nlet observation = ValueObservation.tracking(..., fetch: { db in ... })\n\n// NEW: GRDB 5\nlet observation = ValueObservation.tracking(request.fetchCount)\nlet observation = ValueObservation.tracking(request.fetchOne)\nlet observation = ValueObservation.tracking(request.fetchAll)\nlet observation = ValueObservation.tracking(someFetchFunction)\nlet observation = ValueObservation.tracking { db in ... }\n```\n\n----------------------------------------\n\nTITLE: Table Alias with Including All Method\nDESCRIPTION: Example demonstrating the unsupported use of table aliases with including(all:) method to filter associated records. This implementation for loading authors with their posthumous books is not supported.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/AssociationsBasics.md#2025-04-22_snippet_105\n\nLANGUAGE: swift\nCODE:\n```\n// NOT IMPLEMENTED: loading all authors along with their posthumous books\nlet authorAlias = TableAlias()\nlet request = Author\n    .aliased(authorAlias)\n    .including(all: Author.books\n        .filter(Column(\"publishDate\") >= authorAlias[Column(\"deathDate\")]))\n```\n\n----------------------------------------\n\nTITLE: Using Callable Custom SQL Functions in GRDB 5\nDESCRIPTION: Shows how to use custom SQL functions in GRDB 5, which are now callable values per Swift Evolution proposal 0253. This simplifies the syntax by removing the explicit call method.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_17\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nPlayer.select(myFunction.call(Column(\"name\")))\n \n// NEW: GRDB 5\nPlayer.select(myFunction(Column(\"name\")))\n```\n\n----------------------------------------\n\nTITLE: Error Handling in ValueObservation Between GRDB 4 and 5\nDESCRIPTION: Shows how error handling has changed in ValueObservation in GRDB 5, making the onError handler mandatory instead of using try-catch blocks.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\ndo {\n    try observation.start(in: dbQueue) { value in\n        print(\"fresh value: \\(value)\")\n    }\n} catch { ... }\n\n// NEW: GRDB 5\nobservation.start(\n    in: dbQueue,\n    onError: { error in ... },\n    onChange: { value in print(\"fresh value: \\(value)\") })\n```\n\n----------------------------------------\n\nTITLE: AS Operator for Column Aliasing in GRDB.swift\nDESCRIPTION: Examples of giving aliases to expressions using the forKey method and referring to the aliased columns using detached columns in other parts of the query.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/README.md#2025-04-22_snippet_161\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT (score + bonus) AS total\n// FROM player\nPlayer.select((Column(\"score\") + Column(\"bonus\")).forKey(\"total\"))\n```\n\nLANGUAGE: swift\nCODE:\n```\n// SELECT (score + bonus) AS total\n// FROM player \n// ORDER BY total\nPlayer\n    .select((Column(\"score\") + Column(\"bonus\")).forKey(\"total\"))\n    .order(Column(\"total\").detached)\n```\n\n----------------------------------------\n\nTITLE: Importing GRDB with Custom SQLite Builds in GRDB 5\nDESCRIPTION: Shows the change in module import for custom SQLite builds in GRDB 5. The module name is now simply 'GRDB' rather than 'GRDBCustomSQLite'.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/Documentation/GRDB5MigrationGuide.md#2025-04-22_snippet_18\n\nLANGUAGE: swift\nCODE:\n```\n// BEFORE: GRDB 4\nimport GRDBCustomSQLite\n \n// NEW: GRDB 5\nimport GRDB\n```\n\n----------------------------------------\n\nTITLE: DatabaseError and DatabaseReader Protocol Changes\nDESCRIPTION: API diff showing additions of isInterruptionError property to DatabaseError and interrupt() method to DatabaseReader protocol.\nSOURCE: https://github.com/groue/grdb.swift/blob/master/CHANGELOG.md#2025-04-22_snippet_23\n\nLANGUAGE: diff\nCODE:\n```\n extension DatabaseError {\n+    var isInterruptionError: Bool { get }\n }\n \n protocol DatabaseReader {\n+    func interrupt()\n }\n```"
  }
]