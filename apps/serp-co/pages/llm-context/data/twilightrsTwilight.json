[
  {
    "owner": "twilight-rs",
    "repo": "twilight",
    "content": "TITLE: Creating a Simple Discord Bot with Twilight in Rust\nDESCRIPTION: This example demonstrates how to create a Discord bot that responds with 'Pong!' when it receives a '!ping' command. It showcases setting up a shard with intents, initializing the HTTP client, configuring an in-memory cache, and handling events in an asynchronous event loop.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/overview.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, error::Error, sync::Arc};\nuse twilight_cache_inmemory::{DefaultInMemoryCache, ResourceType};\nuse twilight_gateway::{Event, EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\nuse twilight_http::Client as HttpClient;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n    let token = env::var(\"DISCORD_TOKEN\")?;\n\n    // Specify intents requesting events about things like new and updated\n    // messages in a guild and direct messages.\n    let intents = Intents::GUILD_MESSAGES | Intents::DIRECT_MESSAGES | Intents::MESSAGE_CONTENT;\n\n    // Create a single shard.\n    let mut shard = Shard::new(ShardId::ONE, token.clone(), intents);\n\n    // The http client is separate from the gateway, so startup a new\n    // one, also use Arc such that it can be cloned to other threads.\n    let http = Arc::new(HttpClient::new(token));\n\n    // Since we only care about messages, make the cache only process messages.\n    let cache = DefaultInMemoryCache::builder()\n        .resource_types(ResourceType::MESSAGE)\n        .build();\n\n    // Startup the event loop to process each event in the event stream as they\n    // come in.\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n        // Update the cache.\n        cache.update(&event);\n\n        // Spawn a new task to handle the event\n        tokio::spawn(handle_event(event, Arc::clone(&http)));\n    }\n\n    Ok(())\n}\n\nasync fn handle_event(\n    event: Event,\n    http: Arc<HttpClient>,\n) -> Result<(), Box<dyn Error + Send + Sync>> {\n    match event {\n        Event::MessageCreate(msg) if msg.content == \"!ping\" => {\n            http.create_message(msg.channel_id).content(\"Pong!\").await?;\n        }\n        Event::Ready(_) => {\n            println!(\"Shard is ready\");\n        }\n        _ => {}\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Discord Bot with Twilight in Rust\nDESCRIPTION: This code demonstrates a complete template for creating a Discord bot using Twilight's ecosystem. It sets up a gateway shard with specific intents, an HTTP client for API requests, and an in-memory cache. The example includes a simple ping-pong command handler and shows the structure for processing events asynchronously.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, error::Error, sync::Arc};\nuse twilight_cache_inmemory::{DefaultInMemoryCache, ResourceType};\nuse twilight_gateway::{Event, EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\nuse twilight_http::Client as HttpClient;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Initialize the tracing subscriber.\n    tracing_subscriber::fmt::init();\n\n    let token = env::var(\"DISCORD_TOKEN\")?;\n\n    // Use intents to only receive guild message events.\n    let mut shard = Shard::new(\n        ShardId::ONE,\n        token.clone(),\n        Intents::GUILD_MESSAGES | Intents::MESSAGE_CONTENT,\n    );\n\n    // HTTP is separate from the gateway, so create a new client.\n    let http = Arc::new(HttpClient::new(token));\n\n    // Since we only care about new messages, make the cache only\n    // cache new messages.\n    let cache = DefaultInMemoryCache::builder()\n        .resource_types(ResourceType::MESSAGE)\n        .build();\n\n    // Process each event as they come in.\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n\n        // Update the cache with the event.\n        cache.update(&event);\n\n        tokio::spawn(handle_event(event, Arc::clone(&http)));\n    }\n\n    Ok(())\n}\n\nasync fn handle_event(\n    event: Event,\n    http: Arc<HttpClient>,\n) -> Result<(), Box<dyn Error + Send + Sync>> {\n    match event {\n        Event::MessageCreate(msg) if msg.content == \"!ping\" => {\n            http.create_message(msg.channel_id)\n                .content(\"Pong!\")\n                .await?;\n        }\n        // Other events here...\n        _ => {}\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Discord Slash Commands with CommandBuilder in Rust\nDESCRIPTION: Demonstrates how to create a Discord slash command that sends an animal picture with options for animal type and size using the CommandBuilder from twilight-util. The example creates a command with a required string option with choices and an optional boolean parameter.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_7_first_party/section_4_util.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# fn main() {\nuse twilight_model::application::command::CommandType;\nuse twilight_util::builder::command::{BooleanBuilder, CommandBuilder, StringBuilder};\n\nCommandBuilder::new(\n    \"blep\",\n    \"Send a random adorable animal photo\",\n    CommandType::ChatInput,\n)\n.option(\n    StringBuilder::new(\"animal\", \"The type of animal\")\n        .required(true)\n        .choices([\n            (\"Dog\", \"animal_dog\"),\n            (\"Cat\", \"animal_cat\"),\n            (\"Penguin\", \"animal_penguin\"),\n        ]),\n)\n.option(BooleanBuilder::new(\n    \"only_smol\",\n    \"Whether to show only baby animals\",\n));\n# }\n```\n\n----------------------------------------\n\nTITLE: Complete Discord Bot with Reaction Handling in Rust\nDESCRIPTION: A comprehensive example showing a full Discord bot implementation using twilight-gateway and twilight-standby. The bot connects to Discord, processes events, and includes a handler that waits for user reactions to messages.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-standby/README.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, sync::Arc};\nuse twilight_gateway::{Event, EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\nuse twilight_model:{\n    channel::Message,\n    gateway::payload::incoming::ReactionAdd,\n};\nuse twilight_standby::Standby;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let token = env::var(\"DISCORD_TOKEN\")?;\n\n    // Start a shard connected to the gateway to receive events.\n    let intents = Intents::GUILD_MESSAGES | Intents::GUILD_MESSAGE_REACTIONS;\n    let mut shard = Shard::new(ShardId::ONE, token, intents);\n\n    let standby = Arc::new(Standby::new());\n\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n\n        // Have standby process the event, which will fulfill any futures\n        // that are waiting for an event.\n        standby.process(&event);\n\n        match event {\n            Event::MessageCreate(msg) if msg.content == \"!react\" => {\n                tokio::spawn(react(msg.0, Arc::clone(&standby)));\n            },\n            _ => {},\n        }\n    }\n\n    Ok()\n}\n\n// Wait for a reaction from the user who sent the message, and then print it\n// once they react.\nasync fn react(msg: Message, standby: Arc<Standby>) -> anyhow::Result<()> {\n    let author_id = msg.author.id;\n\n    let reaction = standby.wait_for_reaction(msg.id, move |event: &ReactionAdd| {\n        event.user_id == author_id\n    }).await?;\n\n    println!(\"user reacted with {:?}\", reaction.emoji);\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Recommended Shards and Handling Guild Events in Parallel in Rust\nDESCRIPTION: This example demonstrates how to create the recommended number of Discord gateway shards with the twilight-gateway crate, handle events in parallel, and gracefully shut down on CTRL+C. It uses atomic variables for shutdown coordination and spawns a separate task for each shard.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::\n    env,\n    sync::atomic::{AtomicBool, Ordering},\n};\nuse tokio::signal;\nuse twilight_gateway::\n    error::ReceiveMessageErrorType, CloseFrame, Config, Event, EventTypeFlags, Intents, Shard,\n    StreamExt as _,\n};\nuse twilight_http::Client;\n\nstatic SHUTDOWN: AtomicBool = AtomicBool::new(false);\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    tracing_subscriber::fmt::init();\n\n    let token = env::var(\"DISCORD_TOKEN\")?;\n    let client = Client::new(token.clone());\n    let config = Config::new(token, Intents::GUILDS);\n\n    let shards =\n        twilight_gateway::create_recommended(&client, config, |_, builder| builder.build()).await?;\n    let mut senders = Vec::with_capacity(shards.len());\n    let mut tasks = Vec::with_capacity(shards.len());\n\n    for shard in shards {\n        senders.push(shard.sender());\n        tasks.push(tokio::spawn(runner(shard)));\n    }\n\n    signal::ctrl_c().await?;\n    SHUTDOWN.store(true, Ordering::Relaxed);\n    for sender in senders {\n        // Ignore error if shard's already shutdown.\n        _ = sender.close(CloseFrame::NORMAL);\n    }\n\n    for jh in tasks {\n        _ = jh.await;\n    }\n\n    Ok(())\n}\n\n#[tracing::instrument(fields(shard = %shard.id()), skip_all)]\nasync fn runner(mut shard: Shard) {\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let event = match item {\n            Ok(Event::GatewayClose(_)) if SHUTDOWN.load(Ordering::Relaxed) => break,\n            Ok(event) => event,\n            Err(source) => {\n                tracing::warn!(?source, \"error receiving event\");\n\n                continue;\n            }\n        };\n\n        // You'd normally want to spawn a new tokio task for each event and\n        // handle the event there to not block the shard.\n        tracing::debug!(?event, shard = ?shard.id(), \"received event\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Simple Discord Embed with EmbedBuilder in Rust\nDESCRIPTION: Shows how to create a Discord embed with a description and inline fields using the EmbedBuilder from twilight-util. This example creates an embed with a description and two inline fields using the builder pattern.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_7_first_party/section_4_util.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #[allow(unused_variables)]\n# fn main() -> Result<(), Box<dyn std::error::Error>> {\nuse twilight_util::builder::embed::{EmbedBuilder, EmbedFieldBuilder};\n\nlet embed = EmbedBuilder::new()\n    .description(\"Here's a list of reasons why Twilight is the best pony:\")\n    .field(EmbedFieldBuilder::new(\"Wings\", \"She has wings.\").inline())\n    .field(EmbedFieldBuilder::new(\"Horn\", \"She can do magic, and she's really good at it.\").inline())\n    .build();\n#     Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Fetching Current User Information with Twilight HTTP Client\nDESCRIPTION: Example demonstrating how to initialize the Twilight HTTP client, authenticate with a Discord token, and fetch the current user's information. The example shows the basic pattern of initializing the client, making a request, and handling the response.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_2_http.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, error::Error};\nuse twilight_http::Client;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n    // Initialize the tracing subscriber.\n    tracing_subscriber::fmt::init();\n\n    let client = Client::new(env::var(\"DISCORD_TOKEN\")?);\n\n    let me = client.current_user().await?.model().await?;\n    println!(\"Current user: {}#{}\", me.name, me.discriminator);\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Discord Gateway Shard with Event Handling\nDESCRIPTION: Example showing how to initialize a Shard connection to Discord's gateway, set up intents for guild messages, and process incoming events within an asynchronous Rust application.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_3_gateway.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, error::Error};\nuse twilight_gateway::{EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n    // Initialize the tracing subscriber.\n    tracing_subscriber::fmt::init();\n\n    let token = env::var(\"DISCORD_TOKEN\")?;\n    let intents = Intents::GUILD_MESSAGES;\n    let mut shard = Shard::new(ShardId::ONE, token, intents);\n    tracing::info!(\"created shard\");\n\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n\n        tracing::debug!(?event, \"event\");\n    }\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Twilight Lavalink Client with Gateway Events Processing\nDESCRIPTION: Complete example showing how to create a Lavalink client, add a Lavalink node, and process Discord gateway events. It demonstrates setting up a connection with proper authentication and handling the event stream from a Discord shard.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_7_first_party/section_3_lavalink.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::\n    env,\n    error::Error,\n    net::SocketAddr,\n    str::FromStr,\n};\nuse twilight_gateway::{EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\nuse twilight_http::Client as HttpClient;\nuse twilight_lavalink::Lavalink;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error + Send + Sync + 'static>> {\n    let token = env::var(\"DISCORD_TOKEN\")?;\n    let lavalink_host = SocketAddr::from_str(&env::var(\"LAVALINK_HOST\")?)?;\n    let lavalink_auth = env::var(\"LAVALINK_AUTHORIZATION\")?;\n    let shard_count = 1_u32;\n\n    let http = HttpClient::new(token.clone());\n    let user_id = http.current_user().await?.model().await?.id;\n\n    let lavalink = Lavalink::new(user_id, shard_count);\n    lavalink.add(lavalink_host, lavalink_auth).await?;\n\n    let intents = Intents::GUILD_MESSAGES | Intents::GUILD_VOICE_STATES;\n    let mut shard = Shard::new(ShardId::ONE, token, intents);\n\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n\n        lavalink.process(&event).await?;\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for a Message with Specific Criteria in Rust\nDESCRIPTION: Example demonstrating how to use the Standby utility to wait for a message in a specific channel from a specific user with particular content. This shows the basic pattern of creating a Standby instance and using its wait_for_message method with a predicate function.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_6_standby.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #[allow(unused_variables)]\n# #[tokio::main]\n# async fn main() -> Result<(), Box<dyn std::error::Error>> {\nuse twilight_model::\n    gateway::payload::incoming::MessageCreate,\n    id::Id,\n};\nuse twilight_standby::Standby;\n\nlet standby = Standby::new();\n\n// Later on in the application...\nlet message = standby\n    .wait_for_message(\n        Id::new(123),\n        |event: &MessageCreate| {\n            event.author.id == Id::new(456) && event.content == \"test\"\n        },\n    )\n    .await?;\n#     Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating a Discord Embed with an Image Attachment in Rust\nDESCRIPTION: Demonstrates how to build a Discord embed that includes an image attachment using the EmbedBuilder from twilight-util. This example shows adding a description and attaching an image to an embed.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_7_first_party/section_4_util.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #[allow(unused_variables)]\n# fn main() -> Result<(), Box<dyn std::error::Error>> {\nuse twilight_util::builder::embed::{EmbedBuilder, ImageSource};\n\nlet embed = EmbedBuilder::new()\n    .description(\"Here's a cool image of Twilight Sparkle\")\n    .image(ImageSource::attachment(\"bestpony.png\")?)\n    .build();\n#     Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Processing Events from Multiple Shards in Twilight 0.15\nDESCRIPTION: Demonstrates how to create a range of shards, collect them into a ShardEventStream, and process events from all shards efficiently. This replaces the previous Cluster API with a more flexible approach.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/versions/0.15/summary.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::StreamExt;\nuse std::{env, error::Error};\nuse twilight_gateway::{\n    stream::{self, ShardEventStream},\n    Config,\n    Intents,\n};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n    // Initialize the tracing subscriber.\n    tracing_subscriber::fmt::init();\n\n    let token = env::var(\"DISCORD_TOKEN\")?;\n    let config = Config::new(token, Intents::GUILD_MESSAGES);\n\n    // Create a group of shards with IDs 0 through 10, out of a total of 20\n    // shards.\n    let mut shards = stream::create_range(\n        0..10,\n        20,\n        config,\n        |_, builder| builder.build(),\n    ).collect::<Vec<_>>();\n\n    // Create a stream to collect all of the shards and poll them for their next\n    // Discord gateway events.\n    let mut stream = ShardEventStream::new(shards.iter_mut());\n\n    while let Some((shard, event)) = stream.next().await {\n        let event = match event {\n            Ok(event) => event,\n            Err(source) => {\n                tracing::warn!(?source, \"error receiving event\");\n\n                // An error may be fatal when something like invalid privileged\n                // intents are specified or the Discord token is invalid.\n                if source.is_fatal() {\n                    break;\n                }\n\n                continue;\n            }\n        };\n\n        tracing::debug!(?event, shard = ?shard.id(), \"received event\");\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Creating User Mentions with Twilight\nDESCRIPTION: Demonstrates how to create a mention formatter for a Discord user ID and use it in a message string. The example shows usage of the Mention trait and Id type with UserMarker.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_7_first_party/section_2_mention.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #[allow(unused_variables)]\n# fn main() {\nuse twilight_mention::Mention;\nuse twilight_model::id::{Id, marker::UserMarker};\n\nlet user_id: Id<UserMarker> = Id::new(123);\nlet message = format!(\"Hey there, {}!\", user_id.mention());\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating Message with Embeds in Rust (New Style)\nDESCRIPTION: Example showing the new style of creating a message with embeds using the twilight HTTP client after version 0.6.0. This demonstrates the new borrowed types and exec/model pattern.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/CHANGELOG.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nclient.create_message(ChannelId(1))\n    .content(&\"some content\")?\n    .embeds(&[&Embed {}])?\n    .exec()\n    .await?\n    .model()\n    .await?\n```\n\n----------------------------------------\n\nTITLE: Documenting Structs in Twilight\nDESCRIPTION: Example of properly documenting a struct in the Twilight project. Shows how to write a short description, detailed explanation, and field documentation.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/CONTRIBUTING.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n/// Short description of the struct, limited to one sentence.\n///\n/// Some more information about the struct, specifying all behavior. This can be\n/// more than one sentence, and can span multiple lines. It can also contain\n/// [shortcut reference links].\n///\n/// When documenting struct fields, don't prefix with \"The\", otherwise most\n/// documentation lines would start with \"the\".\n///\n/// [shortcut reference links]: https://spec.commonmark.org/0.30/#shortcut-reference-link\nstruct Structy {\n    /// Something.\n    pub some: String,\n    /// Something else.\n    pub stuff: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Cache with Gateway Events in Rust\nDESCRIPTION: This example demonstrates how to initialize a DefaultInMemoryCache and update it with events received from a gateway shard. The cache is configured to store up to 10 messages per channel, and processes all incoming events to maintain an up-to-date cache of Discord resources.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-cache-inmemory/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, error::Error};\nuse twilight_cache_inmemory::DefaultInMemoryCache;\nuse twilight_gateway::{EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    // Initialize the tracing subscriber.\n    tracing_subscriber::fmt::init();\n\n    let token = env::var(\"DISCORD_TOKEN\")?;\n    let mut shard = Shard::new(ShardId::ONE, token, Intents::GUILD_MESSAGES);\n\n    // Create a cache, caching up to 10 messages per channel:\n    let cache = DefaultInMemoryCache::builder().message_cache_size(10).build();\n\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n\n        // Update the cache with the event.\n        cache.update(&event);\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Methods in Twilight\nDESCRIPTION: Example of properly documenting a method in the Twilight project. Includes a short description, additional information, and an error section with links to error types.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/CONTRIBUTING.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nimpl Structy {\n    /// Short description of the method, limited to one sentence.\n    ///\n    /// More important information or clarification.\n    /// \n    /// # Errors\n    /// \n    /// Returns an error of type [`SomethingWentWrong`] if something went wrong.\n    /// \n    /// [`SomethingWentWrong`]: SomethingErrorType::SomethingWentWrong\n    pub fn method(&self) -> Result<Something, SomethingError> {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient Formatter Implementation Example\nDESCRIPTION: Recommended approach for implementing Display in Twilight, using Formatter methods directly rather than macros. This approach avoids the runtime performance impact of format macros.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl Display for Foo {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\\n        f.write_str(\"the number \")?;\\n        Display::fmt(&self.number, f)?;\\n\\n        f.write_str(\" is too high\")\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lavalink Client with Discord Gateway Integration\nDESCRIPTION: A complete example demonstrating how to initialize a Lavalink client, connect to a Lavalink server, and process Discord voice events through a gateway shard. The code shows the basic setup for a Discord bot with Lavalink integration.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-lavalink/README.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std:{\n    env,\n    future::Future,\n    net::SocketAddr,\n    str::FromStr,\n};\nuse twilight_gateway::{Event, EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\nuse twilight_http::Client as HttpClient;\nuse twilight_lavalink::{http::LoadedTracks, model::Play, Lavalink};\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Initialize the tracing subscriber.\n    tracing_subscriber::fmt::init();\n\n    let token = env::var(\"DISCORD_TOKEN\")?;\n    let lavalink_host = SocketAddr::from_str(&env::var(\"LAVALINK_HOST\")?)?;\n    let lavalink_auth = env::var(\"LAVALINK_AUTHORIZATION\")?;\n    let shard_count = 1u32;\n\n    let http = HttpClient::new(token.clone());\n    let user_id = http.current_user().await?.model().await?.id;\n\n    let lavalink = Lavalink::new(user_id, shard_count);\n    lavalink.add(lavalink_host, lavalink_auth).await?;\n\n    let intents = Intents::GUILD_MESSAGES | Intents::GUILD_VOICE_STATES;\n    let mut shard = Shard::new(ShardId::ONE, token, intents);\n\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n\n        lavalink.process(&event).await?;\n    }\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Pattern in Twilight\nDESCRIPTION: Standard error implementation pattern for Twilight, showing the required struct with kind and source fields, along with methods for accessing error data. This pattern allows for API stability while updating dependencies.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{\\n    error::Error,\\n    fmt::{Display, Formatter, Result as FmtResult},\\n};\\n\\n/// Error created when something happens.\\n#[derive(Debug)]\\npub struct TwilightError {\\n    kind: TwilightErrorType,\\n    source: Option<Box<dyn Error + Send + Sync>>,\\n}\\n\\nimpl TwilightError {\\n    /// Immutable reference to the type of error that occurred.\\n    #[must_use = \"retrieving the type has no effect if left unused\"]\\n    pub const fn kind(&self) -> &TwilightErrorType {\\n        &self.kind\\n    }\\n\\n    /// Consume the error, returning the source error if there is any.\\n    #[must_use = \"consuming the error and retrieving the source has no effect if left unused\"]\\n    pub fn into_source(self) -> Option<Box<dyn Error + Send + Sync>> {\\n        self.source\\n    }\\n\\n    /// Consume the error, returning the owned error type and the source error.\\n    #[must_use = \"consuming the error into its parts has no effect if left unused\"]\\n    pub fn into_parts(self) -> (TwilightErrorType, Option<Box<dyn Error + Send + Sync>>) {\\n        (self.kind, self.source)\\n    }\\n}\\n\\nimpl Display for TwilightError {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\\n        match self.kind {\\n            TwilightErrorType::AnError => f.write_str(\"something went wrong\"),\\n            TwilightErrorType::AnotherError { mistake_count } => {\\n                f.write_str(\"something else went wrong, \")?;\\n                Display::fmt(&mistake_count, f)?;\\n\\n                f.write_str(\" mistakes\")\\n            }\\n        }\\n    }\\n}\\n\\nimpl Error for TwilightError {\\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\\n        self.source\\n            .as_ref()\\n            .map(|source| &**source as &(dyn Error + 'static))\\n    }\\n}\\n\\n/// Type of [`TwilightError`] that occurred.\\n#[derive(Debug)]\\n#[non_exhaustive]\\npub enum TwilightErrorType {\\n    /// Something went wrong.\\n    AnError,\\n    /// Something else went wrong.\\n    AnotherError {\\n        /// Amount of mistakes.\\n        mistake_count: u64\\n    },\\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Timestamps from Discord Snowflake IDs in Rust\nDESCRIPTION: Demonstrates how to extract the creation timestamp from a Discord snowflake ID using the Snowflake trait from twilight-util. This example retrieves the timestamp in milliseconds since the Unix epoch from a user ID.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_7_first_party/section_4_util.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# #[allow(unused_variables)]\n# fn main() {\nuse twilight_util::snowflake::Snowflake;\nuse twilight_model::id::{Id, marker::UserMarker};\n\nlet user: Id<UserMarker> = Id::new(123456);\nlet timestamp = user.timestamp();\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating a Cluster in Rust (Twilight Gateway 0.5.0+)\nDESCRIPTION: Example of how to create a Cluster and obtain its event stream in Twilight Gateway version 0.5.0 and later. This demonstrates the new tuple return style.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nlet (cluster, mut events) = Cluster::new(token, intents).await?;\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Shard Events in Twilight 0.16 (Rust)\nDESCRIPTION: Updated example of iterating over all events for a single shard in Twilight 0.16. It shows the new approach using StreamExt trait and the next_event() method with EventTypeFlags.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/versions/0.16/summary.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse twilight_gateway::StreamExt;\n\nlet intents = Intents::GUILDS | Intents::GUILD_MODERATION;\nlet mut shard = Shard::new(ShardId::ONE, env::var(\"DISCORD_TOKEN\")?, intents);\n\nwhile let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n    let Ok(event) = item else {\n        tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n        continue;\n    };\n\n    println!(\"Event: {event:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Request Builder in Twilight 0.16 (Rust)\nDESCRIPTION: Updated example of using the HTTP request builder in Twilight 0.16. It demonstrates the new approach where errors are returned upon finalization instead of at each stage.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/versions/0.16/summary.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet response = client.create_message(channel_id)\n    .content(\"I am a message!\")\n    .embeds(&embeds)\n    .tts(true)\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Converting Guild ID to Role ID Using Type Markers in Rust\nDESCRIPTION: This example demonstrates how to use the Id type with different markers to safely convert between contexts. It shows converting a guild ID to a role ID to access the @everyone role, using the cast() method which changes the marker type without runtime cost.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_1_model.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse twilight_model::id::{Id, marker::{GuildMarker, RoleMarker}};\n# fn main() {\n\nlet guild_id: Id<GuildMarker> = Id::new(123);\n\n// To get the everyone role we have to convert the guild id to a role id.\nlet everyone_role_id: Id<RoleMarker> = guild_id.cast();\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating Allowed Mentions in Twilight-Model\nDESCRIPTION: Example of using the AllowedMentions builder to specify which mentions are allowed in a message, including replied users and specific user IDs.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/CHANGELOG.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse twilight_model::channel::message::AllowedMentions;\n\nlet allowed_mentions = AllowedMentions::builder()\n    .replied_user()\n    .user_ids(user_ids)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Setting Presence with MinimalActivity in Rust (Twilight Gateway)\nDESCRIPTION: Example of using the MinimalActivity model to set a presence when building a shard in Twilight Gateway. This was added in version 0.4.1.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nShardBuilder::presence()\n```\n\n----------------------------------------\n\nTITLE: Parsing Discord Webhook URLs in Rust with twilight-util\nDESCRIPTION: Shows how to parse a Discord webhook URL to extract the webhook ID and token using the webhook module from twilight-util. This example parses a webhook URL and verifies the extracted ID and token values.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_7_first_party/section_4_util.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# #[allow(unused_variables)]\n# fn main() -> Result<(), Box<dyn std::error::Error>> {\nuse twilight_model::id::Id;\nuse twilight_util::link::webhook;\n\nlet url = \"https://discord.com/api/webhooks/794590023369752587/tjxHaPHLKp9aEdSwJuLeHhHHGEqIxt1aay4I67FOP9uzsYEWmj0eJmDn-2ZvCYLyOb_K\";\n\nlet (id, token) = webhook::parse(url)?;\nassert_eq!(Id::new(794590023369752587), id);\nassert_eq!(\n    Some(\"tjxHaPHLKp9aEdSwJuLeHhHHGEqIxt1aay4I67FOP9uzsYEWmj0eJmDn-2ZvCYLyOb_K\"),\n    token,\n);\n# Ok(()) }\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Shard in Twilight 0.15\nDESCRIPTION: Illustrates the new pattern for creating a shard and processing events in Twilight 0.15. This version uses direct polling of the shard for events and includes error handling.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/versions/0.15/summary.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet intents = Intents::GUILDS | Intents::GUILD_MODERATION;\nlet mut shard = Shard::new(ShardId::ONE, env::var(\"DISCORD_TOKEN\")?, intents);\n\nloop {\n    let event = match shard.next_event().await {\n        Ok(event) => event,\n        Err(source) => {\n            tracing::warn!(?source, \"error receiving event\");\n\n            if source.is_fatal() {\n                break;\n            }\n\n            continue;\n        }\n    };\n\n    println!(\"Event: {event:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Shard in Twilight 0.14\nDESCRIPTION: Demonstrates how to create a shard, start it, and process events in Twilight 0.14. This snippet shows the older pattern of using a separate events stream.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/versions/0.15/summary.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet intents = Intents::GUILDS | Intents::GUILD_MODERATION;\nlet (shard, mut events) = Shard::new(env::var(\"DISCORD_TOKEN\")?, intents);\n\nshard.start().await?;\nprintln!(\"Created shard\");\n\nwhile let Some(event) = events.next().await {\n    println!(\"Event: {event:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Route Usage for DeleteMessageSpecificReaction in Rust\nDESCRIPTION: Example showing the necessary updates when migrating from DeleteMessageSpecficReaction to DeleteMessageSpecificReaction due to a typo fix in the API.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/CHANGELOG.md#2025-04-17_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n-twilight_http::routing::Route::DeleteMessageSpecficReaction\n+twilight_http::routing::Route::DeleteMessageSpecificReaction\n```\n\n----------------------------------------\n\nTITLE: Sending Raw WebSocket Messages in Rust (Twilight Gateway 0.3.1+)\nDESCRIPTION: Example of sending raw WebSocket messages via Cluster or Shard in Twilight Gateway version 0.3.1 and later.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nCluster::send()\nShard::send()\n```\n\n----------------------------------------\n\nTITLE: Updating CreateInvite Method Usage in Rust\nDESCRIPTION: Example showing how to update method calls from target_user and target_user_type to the newer target_user_id and target_type in the CreateInvite struct.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/CHANGELOG.md#2025-04-17_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n-twilight_http::request::channel::invite::CreateInvite::target_user\n+twilight_http::request::channel::invite::CreateInvite::target_user_id\n\n-twilight_http::request::channel::invite::CreateInvite::target_user_type\n+twilight_http::request::channel::invite::CreateInvite::target_type\n```\n\n----------------------------------------\n\nTITLE: Using shard::Sink with Custom Message Type in Rust (Twilight Gateway 0.3.0+)\nDESCRIPTION: Example of using shard::Sink with the new shard::raw_message::Message type instead of tungstenite::Message in Twilight Gateway version 0.3.0 and later.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nshard::Sink::send(shard::raw_message::Message::Text(\"...\".to_string()))\n```\n\n----------------------------------------\n\nTITLE: Creating Message with Embeds in Rust (Old Style)\nDESCRIPTION: Example showing the old style of creating a message with embeds using the twilight HTTP client before version 0.6.0.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/CHANGELOG.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nclient.create_message(ChannelId(1))\n    .content(\"some content\")?\n    .embed(Embed {})?\n    .await?\n```\n\n----------------------------------------\n\nTITLE: Updating Status/Presence Code Example in Rust\nDESCRIPTION: Code diff showing the renaming of UpdateStatus to UpdatePresence and UpdateStatusInfo to UpdatePresencePayload in the twilight model gateway payload module.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-model/CHANGELOG.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n-twilight_model::gateway::payload::update_status::UpdateStatus\n+twilight_model::gateway::payload::update_presence::UpdatePresence\n\n-twilight_model::gateway::payload::update_status::UpdateStatusInfo\n+twilight_model::gateway::payload::update_presence::UpdatePresencePayload\n```\n\n----------------------------------------\n\nTITLE: Adding Serialization to Shard Types in Rust\nDESCRIPTION: Adds Deserialize and Serialize traits to shard information, latency, and connection stage types in the Twilight Gateway crate.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nAdd `Deserialize, Serialize` to the shard information, shard latency, and\nconnection stage types\n```\n\n----------------------------------------\n\nTITLE: Configuring InMemoryCache in Rust\nDESCRIPTION: Examples of how to configure and build an InMemoryCache instance using the builder pattern.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-cache-inmemory/CHANGELOG.md#2025-04-17_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nlet cache = InMemoryCache::builder()\n    .message_cache_size(10_000)\n    .resource_types(ResourceType::MESSAGE | ResourceType::USER)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Gateway URL in Cluster Builder\nDESCRIPTION: Implements proper usage of the configured gateway URL in the cluster builder for the Twilight Gateway.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nProperly use the configured gateway URL in the cluster builder\n```\n\n----------------------------------------\n\nTITLE: Adding Session ID to Shard Information in Rust\nDESCRIPTION: Adds the shard's session ID to the information provided about shards in the Twilight Gateway crate.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nAdd the shard's session ID to the information provided about shards\n(`Shard::info`)\n```\n\n----------------------------------------\n\nTITLE: Enabling SIMD JSON Dependencies\nDESCRIPTION: Cargo.toml dependency configuration for enabling SIMD JSON support in twilight-http with custom feature flags\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/README.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntwilighthttp = { default-features = false, features = [\"rustls-native-roots\", \"simd-json\"], version = \"0.2\" }\n```\n\n----------------------------------------\n\nTITLE: Customizing Gateway URL in Rust\nDESCRIPTION: Adds methods to customize the URL of the gateway to connect to in the Twilight Gateway crate. Useful for proxies or custom gateway implementations.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nAdd `ShardBuilder::gateway_url` and `ClusterBuilder::gateway_url` to customize\nthe URL of the gateway to connect to.\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation for Twilight HTTP Ratelimiting\nDESCRIPTION: Markdown documentation explaining the purpose and functionality of the twilight-http-ratelimiting crate, including its Ratelimiter trait and InMemoryRatelimiter implementation for managing Discord API rate limits.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http-ratelimiting/README.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# twilight-http-ratelimiting\n\nRatelimiting functionality for HTTP requests.\n\nDiscord ratelimits requests to the HTTP API both globally and per-route.\nFor more information on the specifics, please take a look at\n[Discord's documentation].\n\nThis crate provides a common [`Ratelimiter`] trait that all ratelimiter\nimplementations need to implement.\n\nIt also ships a default implementation, [`InMemoryRatelimiter`], that manages\nthe bucket states in memory.\n\n[Discord's documentation]: https://discord.com/developers/docs/topics/rate-limits\n```\n\n----------------------------------------\n\nTITLE: Accessing Guild Integrations in Rust\nDESCRIPTION: Methods added to retrieve a guild's integrations: InMemoryCache::guild_integrations for a list of integration IDs and InMemoryCache::integration to get an integration by guild and integration ID.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-cache-inmemory/CHANGELOG.md#2025-04-17_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nInMemoryCache::guild_integrations\nInMemoryCache::integration\n```\n\n----------------------------------------\n\nTITLE: Accessing Guild Stickers in Rust\nDESCRIPTION: Methods added to access guild stickers from the cache: InMemoryCache::guild_stickers and InMemoryCache::sticker.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-cache-inmemory/CHANGELOG.md#2025-04-17_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nInMemoryCache::guild_stickers\nInMemoryCache::sticker\n```\n\n----------------------------------------\n\nTITLE: Updating Cache Methods in Rust\nDESCRIPTION: Changes to cache methods that now return clones instead of Arc references. This improves safety and simplifies usage.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-cache-inmemory/CHANGELOG.md#2025-04-17_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n// Old\nlet user = cache.user(user_id).await?;\n\n// New \nlet user = cache.user(user_id).await?.clone();\n```\n\n----------------------------------------\n\nTITLE: Accessing Cache Statistics in Rust\nDESCRIPTION: How to retrieve statistics about the current state of the in-memory cache.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-cache-inmemory/CHANGELOG.md#2025-04-17_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nlet stats = cache.stats();\nprintln!(\"Cache contains {} users\", stats.users());\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Discord Bot with Twilight in Rust\nDESCRIPTION: This code demonstrates how to create a simple Discord bot using Twilight's HTTP and gateway clients with an in-memory cache. The bot initializes a shard connection with specific intents, processes incoming events, and responds to \"!ping\" messages with \"Pong!\".\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{env, error::Error, sync::Arc};\nuse twilight_cache_inmemory::{DefaultInMemoryCache, ResourceType};\nuse twilight_gateway::{Event, EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\nuse twilight_http::Client as HttpClient;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Initialize the tracing subscriber.\n    tracing_subscriber::fmt::init();\n\n    let token = env::var(\"DISCORD_TOKEN\")?;\n\n    // Use intents to only receive guild message events.\n    let mut shard = Shard::new(\n        ShardId::ONE,\n        token.clone(),\n        Intents::GUILD_MESSAGES | Intents::MESSAGE_CONTENT,\n    );\n\n    // HTTP is separate from the gateway, so create a new client.\n    let http = Arc::new(HttpClient::new(token));\n\n    // Since we only care about new messages, make the cache only\n    // cache new messages.\n    let cache = DefaultInMemoryCache::builder()\n        .resource_types(ResourceType::MESSAGE)\n        .build();\n\n    // Process each event as they come in.\n    while let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n        let Ok(event) = item else {\n            tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n            continue;\n        };\n\n        // Update the cache with the event.\n        cache.update(&event);\n\n        tokio::spawn(handle_event(event, Arc::clone(&http)));\n    }\n\n    Ok(())\n}\n\nasync fn handle_event(\n    event: Event,\n    http: Arc<HttpClient>,\n) -> Result<(), Box<dyn Error + Send + Sync>> {\n    match event {\n        Event::MessageCreate(msg) if msg.content == \"!ping\" => {\n            http.create_message(msg.channel_id)\n                .content(\"Pong!\")\n                .await?;\n        }\n        // Other events here...\n        _ => {}\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Channel Messages in Rust\nDESCRIPTION: Support for iterating over a channel's list of cached messages via the InMemoryCache::channel_messages method.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-cache-inmemory/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nInMemoryCache::channel_messages\n```\n\n----------------------------------------\n\nTITLE: Updating Intents Handling in Rust\nDESCRIPTION: Changes to how intents are handled in the Twilight Gateway crate, including re-exporting Intents and modifying methods to require intents as a parameter.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/CHANGELOG.md#2025-04-17_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n`twilight_model::gateway::Intents` is now re-exported as\n`twilight_gateway::Intents`.\n\nThe following methods now take a second \"intents\" parameter, as this is now\nrequired to be specified by the API:\n- `cluster::ClusterBuilder::new`\n- `cluster::Cluster::builder`\n- `cluster::Cluster::new`\n- `shard::ShardBuilder::new`\n- `shard::Shard::builder`\n- `shard::Shard::new`\n\nThe `shard::Config::intents` method no longer returns an option and now returns\na copy of the\nintents (returning `twilight_gateway::Intents`)\n```\n\n----------------------------------------\n\nTITLE: Renaming Invite Field in Rust\nDESCRIPTION: The 'target_user_type' field in the Invite struct has been renamed to 'target_type' to better reflect its purpose.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-model/CHANGELOG.md#2025-04-17_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\ninvite::Invite::target_user_type has been renamed to target_type\n```\n\n----------------------------------------\n\nTITLE: Basic Message Waiting Example in Rust\nDESCRIPTION: A simple example demonstrating how to wait for a specific message in a channel from a particular user using the Standby utility.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-standby/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse twilight_model:{\n    gateway::payload::incoming::MessageCreate,\n    id::Id,\n};\nuse twilight_standby::Standby;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let standby = Standby::new();\n\n    let channel_id = Id::new(123);\n\n    let message = standby.wait_for_message(channel_id, |event: &MessageCreate| {\n        event.author.id.get() == 456 && event.content == \"test\"\n    }).await?;\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Updating UpdateStageInstance Request Pattern in Rust\nDESCRIPTION: Example showing the migration from the old UpdateStageInstance request pattern to the new builder-style pattern where topic is optional.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/CHANGELOG.md#2025-04-17_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n-client.update_stage_instance(channel_id, topic)?.await?;\n+client.update_stage_instance(channel_id)\n+    .topic(topic)?\n+    .await?;\n```\n\n----------------------------------------\n\nTITLE: Creating User Mentions with twilight-mention in Rust\nDESCRIPTION: This example demonstrates how to create a mention formatter for a user ID and include it in a message string. It uses the Mention trait from twilight-mention and the Id type from twilight-model.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-mention/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse twilight_mention::Mention;\nuse twilight_model::id::{marker::UserMarker, Id};\n\nlet user_id = Id::<UserMarker>::new(123);\nlet message = format!(\"Hey there, {}!\", user_id.mention());\n```\n\n----------------------------------------\n\nTITLE: HTTP Request Builder in Twilight 0.15 (Rust)\nDESCRIPTION: Example of using the HTTP request builder in Twilight 0.15. It shows error handling at each stage of the building process.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/versions/0.16/summary.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet response = client.create_message(channel_id)\n    .content(\"I am a message!\")?\n    .embeds(&embeds)?\n    .tts(true)\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Configuring SIMD-JSON with Cargo\nDESCRIPTION: Cargo configuration required to enable SIMD optimizations when using the simd-json feature. This configuration sets the target CPU to native to utilize CPU-specific optimizations.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_2_http.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nrustflags = [\"-C\", \"target-cpu=native\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring SIMD-JSON in Cargo Config\nDESCRIPTION: Configuration for enabling SIMD-JSON optimization by setting native CPU target flags in the project's Cargo config file.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_3_gateway.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nrustflags = [\"-C\", \"target-cpu=native\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring SIMD JSON Build Settings\nDESCRIPTION: TOML configuration for enabling SIMD JSON support by setting target CPU flags in the project's Cargo config\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/README.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nrustflags = [\"-C\", \"target-cpu=native\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Native TLS Support\nDESCRIPTION: Cargo.toml dependency configuration for enabling native TLS support in twilight-http\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/README.md#2025-04-17_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntwilighthttp = { default-features = false, features = [\"native\"], version = \"0.2\" }\n```\n\n----------------------------------------\n\nTITLE: Configuring twilight-lavalink with native-tls in Cargo.toml\nDESCRIPTION: A Cargo.toml configuration example showing how to enable the native-tls feature for twilight-lavalink while disabling default features.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-lavalink/README.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntwilight-lavalink = { default-features = false, features = [\"native-tls\"], version = \"0.2\" }\n```\n\n----------------------------------------\n\nTITLE: Making Functions Const in Rust\nDESCRIPTION: A list of functions in the twilight-model crate that have been made const, allowing them to be evaluated at compile-time. This includes functions related to channels, messages, gateway events, and more.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-model/CHANGELOG.md#2025-04-17_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nchannel::ChannelType::name\nchannel::message::allowed_mentions::AllowedMentionsBuilder::new\nchannel::message::allowed_mentions::AllowedMentionsBuilder::replied_user\nchannel::message::allowed_mentions::AllowedMentions::new\nchannel::message::sticker::StickerType::value\nchannel::Channel::id\nchannel::GuildChannel::guild_id\nchannel::GuildChannel::id\nchannel::VideoQualityMode::name\ngateway::event::gateway::payload::Heartbeat::new\ngateway::event::gateway::payload::identify::Identify::new\ngateway::event::gateway::payload::request_guild_members::RequestGuildMembersBuilder::new\ngateway::event::gateway::payload::request_guild_members::RequestGuildMembers::builder\ngateway::event::gateway::payload::request_guild_members::UserIdsError::kind\ngateway::event::gateway::payload::update_status::UpdateStatusInfo::new\ngateway::event::gateway::payload::UpdateVoiceState::new\ngateway::event::gateway::presence::PresenceDeserializer::new\ngateway::event::gateway::presence::PresenceListDeserializer::new\ngateway::event::gateway::EventType::name\ngateway::event::gateway::Event::kind\ngateway::event::gateway::GatewayEventDeserializerOwned::op\ngateway::event::gateway::GatewayEventDeserializerOwned::sequence\ngateway::event::gateway::GatewayEventDeserializer::new\ngateway::event::gateway::GatewayEventDeserializer::event_type_ref\ngateway::event::gateway::GatewayEventDeserializer::op\ngateway::event::gateway::GatewayEventDeserializer::sequence\ngateway::event::gateway::GatewayEventDeserializer::into_parts\ngateway::event::DispatchEvent::kind\ngateway::event::DispatchEventWithTypeDeserializer::new\nguild::member::MemberDeserializer::new\nguild::member::MemberListDeserializer::new\nguild::member::OptionalMemberDeserializer::new\nvoice::CloseCodeConversionError::code\n```\n\n----------------------------------------\n\nTITLE: Installing and Serving the Twilight Book Locally Using mdbook\nDESCRIPTION: Instructions for setting up and serving the Twilight documentation book locally. This involves installing the mdbook tool via Cargo and then running the serve command to host the book on a local HTTP server.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/README.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install mdbook\n```\n\nLANGUAGE: shell\nCODE:\n```\nmdbook serve\n```\n\n----------------------------------------\n\nTITLE: Linking to Discord API Documentation\nDESCRIPTION: Example showing the proper format for linking to Discord API documentation in Twilight. Links must be prefixed with 'See' and have a specific anchor format.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/CONTRIBUTING.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n/// Edit a global command, by ID.\n///\n/// You must specify a name and description. See\n/// [Discord Docs/Edit Global Application Command].\n///\n/// [Discord Docs/Edit Global Application Command]: https://discord.com/developers/docs/interactions/application-commands#edit-global-application-command\npub const fn update_global_command(\n```\n\n----------------------------------------\n\nTITLE: Static Assertions for Public API Types in Tests\nDESCRIPTION: Example of using the static_assertions crate to verify properties of public API types in tests. This demonstrates testing field existence, trait implementations, and ensuring types are Send and Sync.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone, Copy, Debug)]\\npub enum PublicEnumType {\\n    Foo {\\n        bar: u64,\\n    },\\n    Baz {\\n        qux: i64,\\n        quz: bool,\\n    },\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::PublicEnumType;\\n    use static_assertions::{assert_fields, assert_impl_all};\\n\\n    assert_fields!(PublicEnumType::Foo: bar);\\n    assert_fields!(PublicEnumType::Baz: qux, quz);\\n    assert_impl_all!(PublicEnumType: Clone, Copy, Debug, Send, Sync);\\n}\n```\n\n----------------------------------------\n\nTITLE: Inefficient Formatter Implementation Example\nDESCRIPTION: Example of an inefficient Display implementation that should be avoided in Twilight due to runtime performance impacts. This approach uses the write! macro which has performance penalties.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::fmt::{Display, Formatter, Result as FmtResult};\\n\\nstruct Foo {\\n    number: u64,\\n}\\n\\nimpl Display for Foo {\\n    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {\\n        write!(f, \"the number {} is too high\", self.number)\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Shard Events in Twilight 0.15 (Rust)\nDESCRIPTION: Example of iterating over all events for a single shard in Twilight 0.15. It demonstrates the old approach of using Shard::next_event() and error handling.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/versions/0.16/summary.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet intents = Intents::GUILDS | Intents::GUILD_MODERATION;\nlet mut shard = Shard::new(ShardId::ONE, env::var(\"DISCORD_TOKEN\")?, intents);\n\nloop {\n    let event = match shard.next_event().await {\n        Ok(event) => event,\n        Err(source) => {\n            tracing::warn!(?source, \"error receiving event\");\n\n            if source.is_fatal() {\n                break;\n            }\n\n            continue;\n        }\n    };\n\n    println!(\"Event: {event:?}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Field Type Update - Voice Channel User Limit\nDESCRIPTION: Changes the user_limit field type from u8 to u32 to support larger user limits.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-model/CHANGELOG.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct VoiceChannel {\n    user_limit: u32,\n    // other fields...\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Shard Events with In-Memory Cache in Twilight\nDESCRIPTION: This example demonstrates how to set up a Twilight shard and process incoming events into an in-memory cache. It creates a shard with guild message intents, initializes a default in-memory cache, and updates the cache with each received event while handling potential errors.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/book/src/chapter_1_crates/section_4_cache_inmemory.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #[tokio::main]\n# async fn main() -> Result<(), Box<dyn std::error::Error>> {\nuse std::env;\nuse twilight_cache_inmemory::DefaultInMemoryCache;\nuse twilight_gateway::{EventTypeFlags, Intents, Shard, ShardId, StreamExt as _};\n\nlet token = env::var(\"DISCORD_TOKEN\")?;\n\nlet mut shard = Shard::new(ShardId::ONE, token, Intents::GUILD_MESSAGES);\n\nlet cache = DefaultInMemoryCache::new();\n\nwhile let Some(item) = shard.next_event(EventTypeFlags::all()).await {\n    let Ok(event) = item else {\n        tracing::warn!(source = ?item.unwrap_err(), \"error receiving event\");\n\n        continue;\n    };\n\n    cache.update(&event);\n}\n#     Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Rust Struct Field Update - Channel Position\nDESCRIPTION: Breaking change that modifies the Channel::position field type from an unspecified type to i32.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-model/CHANGELOG.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct Channel {\n    position: i32,\n    // other fields...\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Implementation - VoiceStateUpdate Deref\nDESCRIPTION: Adds Deref trait implementation for VoiceStateUpdate type.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-model/CHANGELOG.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl Deref for VoiceStateUpdate {\n    type Target = VoiceState;\n    fn deref(&self) -> &Self::Target { /* implementation */ }\n}\n```\n\n----------------------------------------\n\nTITLE: InteractionClient Method Renaming Reference Table in Markdown\nDESCRIPTION: A reference table showing the mapping between new and old method names in the InteractionClient, part of a change to standardize the naming convention across the API.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-http/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| New                          | Old                             |\n| ---------------------------- | ------------------------------- |\n| `create_response`            | `interaction_callback`          |\n| `delete_response`            | `delete_interaction_original`   |\n| `response`                   | `get_interaction_original`      |\n| `update_response`            | `update_interaction_original`   |\n| `create_followup`            | `create_followup_message`       |\n| `delete_followup`            | `delete_followup_message`       |\n| `followup`                   | `followup_message`              |\n| `update_followup`            | `update_followup_message`       |\n| `create_global_command`      | unchanged                       |\n| `delete_global_command`      | unchanged                       |\n| `global_command`             | `get_global_command`            |\n| `global_commands`            | `get_global_commands`           |\n| `set_global_commands`        | unchanged                       |\n| `update_global_command`      | unchanged                       |\n| `create_guild_command`       | unchanged                       |\n| `delete_guild_command`       | unchanged                       |\n| `guild_command`              | `get_guild_command`             |\n| `guild_commands`             | `get_guild_commands`            |\n| `set_guild_commands`         | unchanged                       |\n| `update_guild_command`       | unchanged                       |\n| `command_permissions`        | `get_command_permissions`       |\n| `guild_command_permissions`  | `get_guild_command_permissions` |\n| `set_command_permissions`    | unchanged                       |\n| `update_command_permissions` | unchanged                       |\n```\n\n----------------------------------------\n\nTITLE: Running Gateway Runtime Tests for Twilight-HTTP\nDESCRIPTION: These shell commands demonstrate how to run gateway runtime tests for the twilight-http module. The tests require a Discord token and should be run sequentially due to rate limits. An optional command is provided for running tests with output capture disabled.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-gateway/DEVELOPMENT.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ env DISCORD_TOKEN=\"your token here\" cargo test -j1 -- --ignored\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ env DISCORD_TOKEN=\"your token here\" cargo test -j1 -- --ignored --nocapture\n```\n\n----------------------------------------\n\nTITLE: Twilight-rs Changelog Content in Markdown\nDESCRIPTION: Markdown formatted changelog documenting version history including bug fixes, features, breaking changes, and other updates for the twilight-rs Discord API library.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-model/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\n## [0.16.0] - 2025-01-12\n\n### Bug Fixes\n\n- Address new rust CI errors ([#2285](https://github.com/twilight-rs/twilight/issues/2285))\n- [**breaking**] Bump `SessionStartLimit` field sizes ([#2286](https://github.com/twilight-rs/twilight/issues/2286))\n[...remaining changelog content truncated for brevity...]\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry\nDESCRIPTION: The main changelog content formatted in markdown, containing version history, changes, bug fixes and features.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-standby/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\n## [0.16.0] - 2025-01-12\n\n### Bug Fixes\n\n- Address new rust CI errors ([#2285](https://github.com/twilight-rs/twilight/issues/2285))\n\n### Build\n\n- Remove dependency on futures-util ([#2309](https://github.com/twilight-rs/twilight/issues/2309))\n\n### Features\n\n- Add support for premium apps ([#2282](https://github.com/twilight-rs/twilight/issues/2282))\n- add avatar decoration data ([#2343](https://github.com/twilight-rs/twilight/issues/2343))\n- [**breaking**] Add support for super reaction types ([#2347](https://github.com/twilight-rs/twilight/issues/2347))\n- add support for polls ([#2341](https://github.com/twilight-rs/twilight/issues/2341))\n- add call field to messages ([#2344](https://github.com/twilight-rs/twilight/issues/2344))\n- Add support for message forwarding ([#2340](https://github.com/twilight-rs/twilight/issues/2340))\n- Implement user applications ([#2323](https://github.com/twilight-rs/twilight/issues/2323))\n- Add guild field to interaction. ([#2383](https://github.com/twilight-rs/twilight/issues/2383))\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry for v0.16.0\nDESCRIPTION: Documents changes in version 0.16.0 including bug fixes, new features, refactoring and chores.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-mention/CHANGELOG.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## [0.16.0] - 2025-01-12\n\n### Bug Fixes\n\n- Address new rust CI errors (#2285)\n\n### Features\n\n- Add mention for commands (#2290)\n\n### Refactor\n\n- Remove redundant imports (#2316)\n\n### Chore\n\n- resolve rust 1.83 issues (#2391)\n- Clarify that MSRV may change in semver-compatible releases (#2408)\n- Fix clippy 1.84 lints (#2409)\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry for v0.15.2\nDESCRIPTION: Contains changes for version 0.15.2 including MSRV update and code reformatting.\nSOURCE: https://github.com/twilight-rs/twilight/blob/main/twilight-mention/CHANGELOG.md#2025-04-17_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## [0.15.2] - 2023-09-10\n\n### Build\n\n- bump MSRV to 1.67 (#2208)\n\n### Refactor\n\n- reformat code with rustfmt 1.6.0 (#2233)\n```"
  }
]