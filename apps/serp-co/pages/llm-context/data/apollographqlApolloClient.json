[
  {
    "owner": "apollographql",
    "repo": "apollo-client",
    "content": "TITLE: Connect Apollo Client to React with ApolloProvider\nDESCRIPTION: Wraps the React application with the `ApolloProvider` component to make the Apollo Client instance available throughout the component tree.  The `client` prop is set to the initialized `ApolloClient` instance. This allows React components to access GraphQL data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport * as ReactDOM from 'react-dom/client';\nimport { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';\nimport App from './App';\n\nconst client = new ApolloClient({\n  uri: 'https://flyby-router-demo.herokuapp.com/',\n  cache: new InMemoryCache(),\n});\n\n// Supported in React 18+\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n\nroot.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>,\n);\n```\n\n----------------------------------------\n\nTITLE: Fetch data using the useQuery hook\nDESCRIPTION: Defines a `DisplayLocations` component that uses the `useQuery` hook to fetch data from the GraphQL API.  The hook returns `loading`, `error`, and `data` properties, which are used to conditionally render the UI based on the query's state.  The component then maps over the `locations` in the `data` to render each location's details.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nfunction DisplayLocations() {\n  const { loading, error, data } = useQuery(GET_LOCATIONS);\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error : {error.message}</p>;\n\n  return data.locations.map(({ id, name, description, photo }) => (\n    <div key={id}>\n      <h3>{name}</h3>\n      <img width=\"400\" height=\"250\" alt=\"location-reference\" src={`${photo}`} />\n      <br />\n      <b>About this location:</b>\n      <p>{description}</p>\n      <br />\n    </div>\n  ));\n}\n```\n\n----------------------------------------\n\nTITLE: Using skipToken for Conditional Query Execution with Apollo Client Suspense Hooks in JavaScript\nDESCRIPTION: This JavaScript snippet illustrates the recommended approach for conditionally skipping queries with Apollo Client's Suspense hooks (`useSuspenseQuery` and `useBackgroundQuery`). By supplying `skipToken` instead of the deprecated `skip` option, the hook does not execute the query when the condition is falsy (e.g., no `id`). Dependencies: `@apollo/client` for `skipToken` and query hooks, and a defined GraphQL query. The key parameter is the guard expression (e.g., presence of `id`); the output is either query response data or no operation. Using `skipToken` aligns with future-proof best practices and avoids unwanted network requests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { skipToken, useSuspenseQuery } from '@apollo/client';\nconst { data } = useSuspenseQuery(\n  query,\n  id ? { variables: { id } } : skipToken\n);\n\n```\n\n----------------------------------------\n\nTITLE: Reading from Apollo Client cache using readQuery in JavaScript\nDESCRIPTION: Executes a GraphQL query directly against the Apollo Client's cache and returns the matching result or null if the query data is not found. Accepts an options object including a required query created with the gql template literal, optional variables, optimistic flag to return optimistic results, and a customizable root id. Returns cached data in the shape defined by the query. Mainly used for querying cached data without sending a network request.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Query a cached Todo object with id 5\nconst { todo } = cache.readQuery({\n  query: gql`\n    query ReadTodo {\n      todo(id: 5) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Query (GET_DOGS)\nDESCRIPTION: This snippet defines a GraphQL query named `GET_DOGS` using the `gql` function.  It fetches the `id` and `breed` fields from the `dogs` query. The `gql` function parses the GraphQL query string into a query document usable by Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/queries.mdx#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nimport { gql, useQuery } from '@apollo/client';\n\nconst GET_DOGS = gql`\n  query GetDogs {\n    dogs {\n      id\n      breed\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Handling Loading and Error States in React Component\nDESCRIPTION: This snippet demonstrates how to handle `loading` and `error` states within a React component that is connected to a GraphQL query using `graphql()`. It shows conditional rendering based on the `loading` and `error` properties of the `data` prop. The component expects the `data` prop to contain `loading`, `error`, and `todos` properties.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nrender() {\n  const { data: { loading, error, todos } } = this.props;\n  if (loading) {\n    return <p>Loading...</p>;\n  }\n  if (error) {\n    return <p>Error!</p>;\n  }\n  return (\n    <ul>\n      {todos.map(({ id, text }) => (\n        <li key={id}>{text}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Arrays in Cached Fields Using Merge Function - Apollo Client TypeScript\nDESCRIPTION: This field policy demonstrates a custom 'merge' function for the 'tasks' array field in the 'Agenda' type, ensuring that new incoming arrays are concatenated with existing cached task arrays rather than replacing them. The default parameter ensures safety when no data exists. Required dependency: Apollo Client. Inputs: 'existing' and 'incoming' arrays. Outputs: concatenated array. Limitation: merge must return a new array, not mutate existing.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Agenda: {\n      fields: {\n        tasks: {\n          merge(existing = [], incoming: any[]) {\n            return [...existing, ...incoming];\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Apollo Cache After Mutation with useMutation in JavaScript\nDESCRIPTION: Demonstrates using the `update` callback within the `useMutation` hook to modify the Apollo cache after a mutation. It uses `cache.modify` to target a specific object (identified by `cache.identify`) and `cache.writeFragment` to create a fragment for the new data (`addComment`), obtaining its cache reference (`newCommentRef`). This reference is then added to an existing list field (`comments`) within the modified object.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nconst [addComment] = useMutation(ADD_COMMENT, {\n  update(cache, { data: { addComment } }) {\n    cache.modify({\n      id: cache.identify(myPost),\n      fields: {\n        comments(existingCommentRefs = [], { readField }) {\n          const newCommentRef = cache.writeFragment({\n            data: addComment,\n            fragment: gql`\n              fragment NewComment on Comment {\n                id\n                text\n              }\n            `\n          });\n          return [...existingCommentRefs, newCommentRef];\n        }\n      }\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Optimistic Comment Update Mutation with Apollo Client in JSX\nDESCRIPTION: Illustrates how to implement an optimistic UI update for a GraphQL mutation in a React component using Apollo Client. The snippet defines a GraphQL mutation for updating comments and a React component employing the useMutation hook. It uses the optimisticResponse option to synchronously update the UI with predicted results matching the mutation's response shape, including id and __typename for cache identification. Inputs are the comment ID and content; output is the optimistic Comment object rendered immediately.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/optimistic-ui.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// Mutation definition\nconst UPDATE_COMMENT = gql`\n  mutation UpdateComment($commentId: ID!, $commentContent: String!) {\n    updateComment(commentId: $commentId, content: $commentContent) {\n      id\n      __typename\n      content\n    }\n  }\n`;\n\n// Component definition\nfunction CommentPageWithData() {\n  const [mutate] = useMutation(UPDATE_COMMENT);\n  return (\n    <Comment\n      updateComment={({ commentId, commentContent }) =>\n        mutate({\n          variables: { commentId, commentContent },\n          optimisticResponse: {\n            updateComment: {\n              id: commentId,\n              __typename: \"Comment\",\n              content: commentContent\n            }\n          }\n        })\n      }\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Execute a GraphQL query using ApolloClient\nDESCRIPTION: Demonstrates executing a GraphQL query directly using the `client.query()` method. The query retrieves a list of locations with their `id`, `name`, `description`, and `photo` properties. The result is then logged to the console.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n// const client = ...\n\nclient\n  .query({\n    query: gql`\n      query GetLocations {\n        locations {\n          id\n          name\n          description\n          photo\n        }\n      }\n    `,\n  })\n  .then((result) => console.log(result));\n```\n\n----------------------------------------\n\nTITLE: Using Variables in GraphQL Queries for Reusability\nDESCRIPTION: This snippet shows how to utilize GraphQL variables to parameterize queries, enhancing reusability and flexibility. It includes an example query with a variable `$dogId` and a JavaScript implementation using `useQuery` hook to pass variable values at runtime.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/operation-best-practices.mdx#_snippet_1\n\nLANGUAGE: GraphQL\nCODE:\n```\n# Recommended ✅\nquery GetDog($dogId: ID!) {\n  dog(id: $dogId) {\n    name\n    breed\n  }\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst GET_DOG = gql`\n  query GetDog($dogId: ID!) {\n    dog(id: $dogId) {\n      name\n      breed\n    }\n  }\n`;\n\nfunction Dog({ id }) {\n  const { loading, error, data } = useQuery(GET_DOG, {\n    variables: {\n      dogId: id\n    },\n  });\n  // ...render component...\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Optimistic Response for New Object Creation in Apollo Client with JavaScript\nDESCRIPTION: Shows how to specify an optimistic response for a mutation that adds a new item to a list when the new object's server-generated ID is not yet known. The optimisticResponse object uses a temporary id to let Apollo Client cache the optimistic object correctly. This temporarily updates the UI with a new Todo item before the server returns the actual id. Inputs include user input for description; output is an optimistic Todo object with a temporary identifier.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/optimistic-ui.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\noptimisticResponse: {\n  addTodo: {\n    id: 'temp-id',\n    __typename: \"Todo\",\n    description: input.value // Obtained from user input\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Concurrent Data Fetching with useBackgroundQuery and useReadQuery in Apollo Client (TypeScript)\nDESCRIPTION: This snippet illustrates the use of useBackgroundQuery to request data in a React parent component and pass a QueryReference to a child, which then reads the data with useReadQuery. It also demonstrates composition with useSuspenseQuery to fetch supplementary data. Dependencies include @apollo/client, appropriate GraphQL documents, and React. Key parameters are the query references and GraphQL variables. Data is suspended in the child if not available, and re-renders occur only where necessary, optimizing performance and separation of concerns.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction App() {\n  const [queryRef] = useBackgroundQuery(GET_BREEDS_QUERY);\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog name=\"Mozzarella\" queryRef={queryRef} />\n    </Suspense>\n  );\n}\n\nfunction Dog({\n  name,\n  queryRef,\n}: {\n  name: string;\n  queryRef: QueryReference<BreedData>;\n}) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { name },\n  });\n  return (\n    <>\n      Name: {data.dog.name}\n      <Suspense fallback={<div>Loading breeds...</div>}>\n        <Breeds queryRef={queryRef} />\n      </Suspense>\n    </>\n  );\n}\n\nfunction Breeds({ queryRef }: { queryRef: QueryReference<BreedData> }) {\n  const { data } = useReadQuery(queryRef);\n  return data.breeds.map(({ characteristics }) =>\n    characteristics.map((characteristic) => (\n      <div key={characteristic}>{characteristic}</div>\n    ))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ApolloProvider with Apollo Client - JSX\nDESCRIPTION: This code snippet illustrates initializing an ApolloClient with an in-memory cache and GraphQL endpoint, and integrating it into the React component tree using ApolloProvider. The example uses ReactDOM.render to mount the root component within the ApolloProvider, ensuring the configured client is available to all nested components. Required dependencies: @apollo/client, React, ReactDOM. Expected input includes a configured ApolloClient instance; output is a mounted component tree with Apollo context, no data is returned. The snippet assumes a valid 'MyRootComponent' and a DOM element with id 'root'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  uri: \"http://localhost:4000/graphql\"\n});\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <MyRootComponent />\n  </ApolloProvider>,\n  document.getElementById('root'),\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Local Resolvers for @client Fields in JavaScript\nDESCRIPTION: This snippet defines local resolvers for the @client isInCart field, showing how to check if an item is in the cart by reading from the cache and performing a calculation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_16\n\nLANGUAGE: js\nCODE:\n```\nimport { GET_CART_ITEMS } from './pages/cart';\n\nexport const resolvers = {\n  Launch: {\n    isInCart: (launch, _, { cache }) => {\n      const { cartItems } = cache.readQuery({ query: GET_CART_ITEMS });\n      return cartItems.includes(launch.id);\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Refetching a Specific Query by DocumentNode Using Apollo Client in TypeScript\nDESCRIPTION: This example refetches a specific GraphQL query using its DocumentNode reference instead of its operation name. The include option accepts an array of DocumentNode(s) to target. This requires that SOME_QUERY is a valid DocumentNode and an ApolloClient instance is available. Input: GraphQL DocumentNode. Output: Promise of refetch result.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  include: [SOME_QUERY],\n});\n```\n\n----------------------------------------\n\nTITLE: Using fetchMore to Load Additional Data in React\nDESCRIPTION: This React component example uses the useQuery hook to execute the FEED_QUERY and includes an onLoadMore handler that calls fetchMore with a new offset based on current feed length. This pattern supports infinite scrolling or 'load more' functionalities by fetching subsequent pages while preserving the existing data in cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/core-api.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst FeedWithData() {\n// ...continuing from above...\n\n// To show a loading indicator during fetchMore\nif (loading) return 'Loading...';\n\nreturn (\n    <Feed\n      entries={data.feed || []}\n      onLoadMore={() => fetchMore({\n        variables: {\n          offset: data.feed.length\n        },\n      })}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: useSuspenseQuery Example with React Suspense - JSX\nDESCRIPTION: This code demonstrates fetching query data using the useSuspenseQuery hook from Apollo Client in a React application utilizing React Suspense for loading states. The listQuery GraphQL document is defined and passed to useSuspenseQuery inside the List component, and App wraps List in a Suspense boundary with a fallback spinner. Dependencies: react, @apollo/client, a compatible GraphQL backend. Input: None for App and List; output: an ordered list rendered once the data is loaded. The example presumes valid schema support for the 'list' query and each list item having an 'id' field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_6\n\nLANGUAGE: JSX\nCODE:\n```\nimport { Suspense } from 'react';\nimport { useSuspenseQuery } from '@apollo/client';\n\nconst listQuery = gql`\n  query {\n    list {\n      id\n    }\n  }\n`;\n\nfunction App() {\n  return (\n    <Suspense fallback={<Spinner />}>\n      <List />\n    </Suspense>\n  );\n}\n\nfunction List() {\n  const { data } = useSuspenseQuery(listQuery);\n\n  return (\n    <ol>\n      {data.list.map(item => <Item key={item.id} id={item.id}/>)}\n    </ol>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Combining readQuery and writeQuery in Apollo Client (JavaScript)\nDESCRIPTION: Demonstrates reading existing data from the cache using `client.readQuery`, creating a new data item, and then writing the updated list (including the new item) back to the cache using `client.writeQuery`. This modification affects only the local cache and is not sent to the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Query that fetches all existing to-do items\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\n// Get the current to-do list\nconst data = client.readQuery({ query });\n\n// Create a new to-do item\nconst myNewTodo = {\n  id: '6',\n  text: 'Start using Apollo Client.',\n  completed: false,\n  __typename: 'Todo',\n};\n\n// Write back to the to-do list, appending the new item\nclient.writeQuery({\n  query,\n  data: {\n    todos: [...data.todos, myNewTodo],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Handling server response and modifying data in Apollo Link\nDESCRIPTION: This example demonstrates how to process the server's response within a custom Apollo Link by using the observable's `map` method to modify or inspect the response data before passing it back up the link chain.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// BEFORE (NO INTERACTION)\nreturn forward(operation);\n\n// AFTER\nreturn forward(operation).map((data) => {\n  // ...modify result as desired here...\n  return data;\n});\n```\n\n----------------------------------------\n\nTITLE: React Component Example Using Apollo Client's useQuery Hook\nDESCRIPTION: This code demonstrates a React component that performs a GraphQL query with useQuery, handling loading, error, and data states. It shows conditional rendering based on whether deferred data has arrived, emphasizing how to manage partial data in the UI during incremental data loading.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/defer.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { gql, useQuery } from \"@apollo/client\";\n\nfunction App() {\n  const { loading, error, data } = useQuery(GET_PERSON, {\n    variables: {\n      id: 1\n    }\n  });\n\n  if (loading) return \"Loading...\";\n  if (error) return `Error! ${error.message}`;\n\n  return (\n    <>\n      Welcome, {data.firstName} {data.lastName}!\n      <details>\n        <summary>Friends list</summary>\n        {data.friends ? (\n          <ul>\n            {data.friends.map((id) => (\n              <li key={id}>{id}</li>\n            ))}\n          </ul>\n        ) : null}\n      </details>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring a Parameterized GraphQL Mutation for Adding a To-Do Item - JavaScript/JSX\nDESCRIPTION: This code defines a parameterized GraphQL mutation using the gql function to allow adding a new item to a to-do list. The mutation accepts a required type parameter and specifies that the server should return the new object's id and type. This snippet is typically colocated with components that will submit or trigger this mutation. Dependencies: @apollo/client and a GraphQL server implementing the addTodo mutation. Accepts a type string as input and returns an object with id and type fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\nimport { gql, useMutation } from '@apollo/client';\n\nconst ADD_TODO = gql`\n  mutation AddTodo($type: String!) {\n    addTodo(type: $type) {\n      id\n      type\n    }\n  }\n`;\n\n```\n\n----------------------------------------\n\nTITLE: useMutation Hook Return Signature - TypeScript\nDESCRIPTION: This TypeScript snippet outlines the return value of the useMutation React hook from Apollo Client. It returns a tuple: the first element is a mutate function that accepts MutationFunctionOptions for customizing execution and returns a promise resolving to FetchResult, while the second is a MutationResult object with the current mutation state. The function can accept parameters like variables, optimisticResponse, refetchQueries, etc. Requires @apollo/client and TypeScript. Inputs are optional options for each mutation; output is a promise and mutation state. The hook must be run within an ApolloProvider context.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n[\n  mutate: (options?: MutationFunctionOptions<TData, TVariables>) => Promise<FetchResult<TData>>,\n  result: MutationResult<TData>\n]\n```\n\n----------------------------------------\n\nTITLE: Retrying Operations on Authentication Errors with Apollo Link\nDESCRIPTION: This snippet shows how to use Apollo Client's `onError` link to detect GraphQL errors like 'UNAUTHENTICATED' and re-authenticate by updating headers, then retry the request by forwarding the operation. Designed for handling token expiration scenarios.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/error-handling.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nonError(({ graphQLErrors, networkError, operation, forward }) => {\n  if (graphQLErrors) {\n    for (let err of graphQLErrors) {\n      switch (err.extensions.code) {\n        case \"UNAUTHENTICATED\":\n          // Modify the operation context with a new token\n          const oldHeaders = operation.getContext().headers;\n          operation.setContext({\n            headers: {\n              ...oldHeaders,\n              authorization: getNewToken(),\n            },\n          });\n          // Retry the request, returning the new observable\n          return forward(operation);\n      }\n    }\n  }\n  if (networkError) {\n    console.log(`[Network error]: ${networkError}`);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing RetryLink in Apollo Client (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import and instantiate the `RetryLink` from the `@apollo/client/link/retry` package. This `RetryLink` is used to automatically retry failed GraphQL operations due to network issues. No specific configuration is done here; it uses the default settings.  The code imports the `RetryLink` and creates a new instance.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-retry.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { RetryLink } from \"@apollo/client/link/retry\";\n\nconst link = new RetryLink();\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using the useMutation Hook in React with Apollo Client - JavaScript/JSX\nDESCRIPTION: This snippet demonstrates how to initialize and use the useMutation hook from Apollo Client to execute a GraphQL mutation inside a React component. The gql function is used to define the GraphQL mutation document, which is then passed to useMutation. It returns a tuple consisting of a mutate function and an object with the current mutation result state (data, loading, error). This pattern is the foundation for handling mutations in Apollo-powered React apps. Prerequisite: @apollo/client must be installed and configured. The expected input is a defined mutation document; outputs include the mutation result and status flags.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\nimport { gql, useMutation } from '@apollo/client';\n\n// Define mutation\nconst INCREMENT_COUNTER = gql`\n  # Increments a back-end counter and gets its resulting value\n  mutation IncrementCounter {\n    currentValue\n  }\n`;\n\nfunction MyComponent() {\n  // Pass mutation to useMutation\n  const [mutateFunction, { data, loading, error }] = useMutation(INCREMENT_COUNTER);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying and Fetching Relay Connections with React and useQuery\nDESCRIPTION: Defines a GraphQL query conforming to the Relay Cursor Connections specification and provides a React component that uses Apollo Client's `useQuery` hook to fetch data. It demonstrates how to extract `edges` and `pageInfo` from the response and implement a 'Load More' function using `fetchMore` to paginate results based on `pageInfo.endCursor` and `pageInfo.hasNextPage`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/cursor-based.mdx#_snippet_3\n\nLANGUAGE: GraphQL\nCODE:\n```\nconst COMMENTS_QUERY = gql`\n  query Comments($cursor: String) {\n    comments(first: 10, after: $cursor) {\n      edges {\n        node {\n          author\n          text\n        }\n      }\n      pageInfo {\n        endCursor\n        hasNextPage\n      }\n    }\n  }\n`;\n```\n\nLANGUAGE: jsx\nCODE:\n```\nfunction CommentsWithData() {\n  const { data, loading, fetchMore } = useQuery(COMMENTS_QUERY);\n\n  if (loading) return <Loading />;\n\n  const nodes = data.comments.edges.map((edge) => edge.node);\n  const pageInfo = data.comments.pageInfo;\n\n  return (\n    <Comments\n      entries={nodes}\n      onLoadMore={() => {\n        if (pageInfo.hasNextPage) {\n          fetchMore({\n            variables: {\n              cursor: pageInfo.endCursor,\n            },\n          });\n        }\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Apollo with React Router's loader - TypeScript\nDESCRIPTION: This snippet demonstrates integrating Apollo Client with React Router's `loader` function to preload data when transitioning to a route. It uses `preloadQuery` within the loader and `useReadQuery` in the route component. Requires Apollo Client, React Router (v6.4+), and a running GraphQL server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nimport { useLoaderData } from 'react-router-dom';\n\nexport function loader() {\n  return preloadQuery(GET_DOGS_QUERY);\n}\n\nexport function RouteComponent() {\n  const queryRef = useLoaderData();\n  const { data } = useReadQuery(queryRef);\n\n  return (\n    // ...\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating variables with useSuspenseQuery - TypeScript\nDESCRIPTION: This code shows how to update the variables passed to `useSuspenseQuery` to fetch different data. The example fetches a list of dogs using `GET_DOGS_QUERY` and allows the user to select a dog from a dropdown. Selecting a dog triggers `useSuspenseQuery` to fetch details (breed) for the selected dog using `GET_DOG_QUERY`. A `Suspense` boundary handles the loading state. Dependencies: `@apollo/client`, `react`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const GET_DOG_QUERY: TypedDocumentNode<\n  DogData,\n  Variables\n> = gql`\n  query GetDog($id: String) {\n    dog(id: $id) {\n      id\n      name\n      breed\n    }\n  }\n`;\n\nexport const GET_DOGS_QUERY: TypedDocumentNode<\n  DogsData,\n  Variables\n> = gql`\n  query GetDogs {\n    dogs {\n      id\n      name\n    }\n  }\n`;\n\nfunction App() {\n  const { data } = useSuspenseQuery(GET_DOGS_QUERY);\n  const [selectedDog, setSelectedDog] = useState(\n    data.dogs[0].id\n  );\n\n  return (\n    <>\n      <select\n        onChange={(e) => setSelectedDog(e.target.value)}\n      >\n        {data.dogs.map(({ id, name }) => (\n          <option key={id} value={id}>{name}</option>\n        ))}\n      </select>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Dog id={selectedDog} />\n      </Suspense>\n    </>\n  );\n}\n\nfunction Dog({ id }: DogProps) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { id },\n  });\n\n  return (\n    <>\n      <div>Name: {data.dog.name}</div>\n      <div>Breed: {data.dog.breed}</div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding an Item to a List using cache.modify in Apollo Client (JavaScript)\nDESCRIPTION: Shows how to add a new item to a cached list using `cache.modify`. Inside the modifier function for the list field, `cache.writeFragment` is used to add the new item data to the cache and obtain a reference to it. This reference is then added to the list of existing references, after checking to prevent duplicates. The updated list of references is returned to update the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst newComment = {\n  __typename: 'Comment',\n  id: 'abc123',\n  text: 'Great blog post!',\n};\n\ncache.modify({\n  id: cache.identify(myPost),\n  fields: {\n    comments(existingCommentRefs = [], { readField }) {\n      const newCommentRef = cache.writeFragment({\n        data: newComment,\n        fragment: gql`\n          fragment NewComment on Comment {\n            id\n            text\n          }\n        `\n      });\n\n      // Quick safety check - if the new comment is already\n      // present in the cache, we don't need to add it again.\n      if (existingCommentRefs.some(\n        ref => readField('id', ref) === newComment.id\n      )) {\n        return existingCommentRefs;\n      }\n\n      return [...existingCommentRefs, newCommentRef];\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: React component: Executing a GraphQL subscription with useSubscription Hook\nDESCRIPTION: This React component utilizes Apollo Client's `useSubscription` hook to subscribe to new comments on a blog post. It listens for server-pushed data updates and re-renders UI whenever a new comment is added, demonstrating real-time data handling in React.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst COMMENTS_SUBSCRIPTION: TypedDocumentNode<\n  OnCommentAddedSubscription,\n  OnCommentAddedSubscriptionVariables\n> = gql`\n  subscription OnCommentAdded($postID: ID!) {\n    commentAdded(postID: $postID) {\n      id\n      content\n    }\n  }\n`;\n\nfunction LatestComment({ postID }: LatestCommentProps) {\n  const { data, loading } = useSubscription(\n    COMMENTS_SUBSCRIPTION,\n    { variables: { postID } }\n  );\n\n  return <h4>New comment: {!loading && data.commentAdded.content}</h4>;\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst COMMENTS_SUBSCRIPTION = gql`\n  subscription OnCommentAdded($postID: ID!) {\n    commentAdded(postID: $postID) {\n      id\n      content\n    }\n  }\n`;\n\nfunction LatestComment({ postID }) {\n  const { data, loading } = useSubscription(\n    COMMENTS_SUBSCRIPTION,\n    { variables: { postID } }\n  );\n\n  return <h4>New comment: {!loading && data.commentAdded.content}</h4>;\n}\n```\n\n----------------------------------------\n\nTITLE: Refetching Queries After Mutation with 'options.refetchQueries'\nDESCRIPTION: This snippet illustrates how to refetch specified queries after a mutation using 'options.refetchQueries', which can be an array of query names or query objects with optional variables. This ensures the UI reflects the most recent data by re-executing the listed queries post-mutation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_38\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`mutation MyMutation { ... }`, {\n  options: {\n    refetchQueries: ['CommentList', 'PostList'],\n  },\n})(MyComponent);\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { COMMENT_LIST_QUERY } from '../components/CommentList';\n\nexport default graphql(gql`mutation MyMutation { ... }`, {\n  options: props => ({\n    refetchQueries: [\n      {\n        query: COMMENT_LIST_QUERY,\n      },\n      {\n        query: gql`\n          query GetPostById ($id: ID!) {\n            post(id: $id) {\n              commentCount\n            }\n          }\n        `,\n        variables: {\n          id: props.postID,\n        },\n      },\n    ],\n  }),\n})(MyComponent);\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`mutation MyMutation { ... }`, {\n  options: {\n    refetchQueries: mutationResult => ['CommentList', 'PostList'],\n  },\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Evicting a Field from a Cached Object (Apollo Client JavaScript)\nDESCRIPTION: Uses the evict method of InMemoryCache to target and remove a single field (e.g., 'yearOfFounding') from a specified object's cache entry. Requires the object ID and the fieldName as parameters. Often utilized for fine-grained cache invalidation scenarios and may be followed by a cache.gc() call for cleanup.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache.evict({ id: 'my-object-id', fieldName: 'yearOfFounding' });\n```\n\n----------------------------------------\n\nTITLE: Example Cache Structure for `readQuery` in Apollo Client\nDESCRIPTION: Illustrates the expected internal cache structure required for a `readQuery` operation with variables to successfully retrieve data. Shows how Apollo Client stores data using `ROOT_QUERY` and references (`__ref`) to normalized objects (e.g., `Todo:5`).\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  ROOT_QUERY: {\n    'todo({\"id\":5})': {\n      __ref: 'Todo:5'\n    }\n  },\n  'Todo:5': {\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using withApollo to enhance a component (JavaScript)\nDESCRIPTION: This code demonstrates the usage of the `withApollo` higher-order component (HOC). The `withApollo` function wraps `MyComponent` and passes the `ApolloClient` instance as a `client` prop.  The `MyComponent` function then logs the `client` prop to the console.  This example highlights the core functionality of accessing the Apollo client within a React component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_42\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyComponent({ client }) {\n  console.log(client);\n}\n\nexport default withApollo(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Context Links - Apollo Client - JavaScript\nDESCRIPTION: Demonstrates the fundamental usage of the `setContext` link to modify the operation context. It shows examples for setting a static header synchronously and performing an asynchronous operation (simulated with a timeout) to add data to the context using a Promise. The function provided to `setContext` receives the current request and the previous context.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-context.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { setContext } from \"@apollo/client/link/context\";\n\nconst setAuthorizationLink = setContext((request, previousContext) => ({\n  headers: {authorization: \"1234\"}\n}));\n\nconst asyncAuthLink = setContext(\n  request =>\n    new Promise((success, fail) => {\n      // do some async lookup here\n      setTimeout(() => {\n        success({ token: \"async found token\" });\n      }, 10);\n    })\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing GraphQLWsLink for WebSocket Subscriptions - TypeScript\nDESCRIPTION: This snippet shows how to initialize a `GraphQLWsLink` to handle GraphQL subscriptions over WebSocket using the `graphql-ws` library. It uses `createClient` from `graphql-ws` to establish the connection to the specified WebSocket endpoint (`ws://localhost:4000/subscriptions`) and wraps the client instance in a `GraphQLWsLink`. This link can then be added to your Apollo Client link chain.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\nimport { createClient } from 'graphql-ws';\n\nconst wsLink = new GraphQLWsLink(createClient({\n  url: 'ws://localhost:4000/subscriptions',\n}));\n```\n\n----------------------------------------\n\nTITLE: Refetching Queries After Mutation in Apollo Client\nDESCRIPTION: Demonstrates how to use refetchQueries option in useMutation to automatically refetch specific queries after a mutation completes. Accepts both DocumentNode objects and query names as strings.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Refetches two queries after mutation completes\nconst [addTodo, { data, loading, error }] = useMutation(ADD_TODO, {\n  refetchQueries: [\n    GET_POST, // DocumentNode object parsed with gql\n    'GetComments' // Query name\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Query Book with Author Name GraphQL\nDESCRIPTION: This GraphQL query retrieves the favorite book including the author's name. It serves as an example to demonstrate how Apollo Client fetches and caches related data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\nquery BookWithAuthorName {\n  favoriteBook {\n    id\n    author {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Default GraphQL Variables to useMutation Hook - JavaScript\nDESCRIPTION: This snippet demonstrates how to pass an options object as the second argument to the useMutation hook in order to provide default variable values for a GraphQL mutation. Such defaults are used for all calls unless overridden by variables provided when invoking the mutate function. The options object can include additional parameters as supported by Apollo Client. Prerequisite: @apollo/client, a corresponding GraphQL mutation document, and a React context with ApolloProvider.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst [addTodo, { data, loading, error }] = useMutation(ADD_TODO, {\n  variables: {\n    type: \"placeholder\",\n    someOtherVariable: 1234,\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Combining multiple Apollo Links into a chain with from()\nDESCRIPTION: This example demonstrates how to compose multiple links, including a retry mechanism, custom authentication, and HTTP transport, into a single serial chain using `ApolloLink.from`, enabling complex data flow customization.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { from, HttpLink } from '@apollo/client';\nimport { RetryLink } from '@apollo/client/link/retry';\nimport MyAuthLink from '../auth';\n\nconst additiveLink = from([\n  new RetryLink(),\n  new MyAuthLink(),\n  new HttpLink({ uri: 'http://localhost:4000/graphql' })\n]);\n```\n\n----------------------------------------\n\nTITLE: Implementing DogPhoto Component with Refetch\nDESCRIPTION: The `DogPhoto` component includes a button that calls the `refetch` function returned by `useQuery`.  Clicking the button triggers a refetch of the dog photo using the current `breed` value.  This allows you to refresh the data when the user interacts with the UI or a specific action is taken.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/queries.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nfunction DogPhoto({ breed }) {\n  const { loading, error, data, refetch } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n  });\n\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <div>\n      <img src={data.dog.displayImage} style={{ height: 100, width: 100 }} />\n      <button onClick={() => refetch()}>\n        Refetch new breed!\n      </button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Apollo Client: Build Time Hash Retrieval Example\nDESCRIPTION: This code demonstrates how to use a build script to retrieve a hash generated at build time for Automatic Persisted Queries (APQs).  It showcases passing a function to `generateHash` that extracts the hash from a document ID. Dependencies: Apollo Client, GraphQL Persisted Document Loader (or similar). Input:  Document ID. Output:  The corresponding hash for the query.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n{ generateHash: ({ documentId }) => documentId }\n```\n\n----------------------------------------\n\nTITLE: Reading Cache Data with `readQuery` in Apollo Client (JavaScript/GraphQL)\nDESCRIPTION: Demonstrates using `client.readQuery` to execute a GraphQL query directly against the Apollo Client cache. Requires a GraphQL query (`READ_TODO` defined using `gql`) and any necessary variables. Returns the cached data matching the query shape or `null` if any fields are missing. Does not fetch from the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst READ_TODO = gql`\n  query ReadTodo($id: ID!) {\n    todo(id: $id) {\n      id\n      text\n      completed\n    }\n  }\n`;\n\n// Fetch the cached to-do item with ID 5\nconst { todo } = client.readQuery({\n  query: READ_TODO,\n  // Provide any required variables in this object.\n  // Variables of mismatched types will return `null`.\n  variables: {\n    id: 5,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom RetryLink Strategies (JavaScript)\nDESCRIPTION: This snippet showcases how to create a `RetryLink` with custom retry and delay strategies.  It defines a retry function based on the presence of an error and the operation name and a delay function that calculates the delay using `Math.random()`.  These custom functions provide granular control over retry behavior.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-retry.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { RetryLink } from \"@apollo/client/link/retry\";\n\nconst link = new RetryLink({\n  attempts: (count, operation, error) => {\n    return !!error && operation.operationName != 'specialCase';\n  },\n  delay: (count, operation, error) => {\n    return count * 1000 * Math.random();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: FieldPolicy TypeScript Type Definitions for Apollo Client\nDESCRIPTION: Detailed TypeScript definitions for the FieldPolicy API which controls how fields in the Apollo Client cache are read, merged, and identified. Includes related helper types and the comprehensive FieldFunctionOptions interface that provides utilities for cache operations.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n// These generic type parameters will be inferred from the provided policy in\n// most cases, though you can use this type to constrain them more precisely.\ntype FieldPolicy<\n  TExisting,\n  TIncoming = TExisting,\n  TReadResult = TExisting,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult>;\n  merge?: FieldMergeFunction<TExisting, TIncoming> | boolean;\n};\n\ntype KeySpecifier = (string | KeySpecifier)[];\n\ntype KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  },\n) => string | KeySpecifier | null | void;\n\ntype FieldReadFunction<TExisting, TReadResult = TExisting> = (\n  existing: Readonly<TExisting> | undefined,\n  options: FieldFunctionOptions,\n) => TReadResult;\n\ntype FieldMergeFunction<TExisting, TIncoming = TExisting> = (\n  existing: Readonly<TExisting> | undefined,\n  incoming: Readonly<TIncoming>,\n  options: FieldFunctionOptions,\n) => TExisting;\n\n// These options are common to both read and merge functions:\ninterface FieldFunctionOptions {\n  cache: InMemoryCache;\n\n  // The final argument values passed to the field, after applying variables.\n  // If no arguments were provided, this property will be null.\n  args: Record<string, any> | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  // The variables that were provided when reading the query that contained\n  // this field. Possibly undefined, if no variables were provided.\n  variables?: Record<string, any>;\n\n  // Easily detect { __ref: string } reference objects.\n  isReference(obj: any): obj is Reference;\n\n  // Returns a Reference object if obj can be identified, which requires,\n  // at minimum, a __typename and any necessary key fields. If true is\n  // passed for the optional mergeIntoStore argument, the object's fields\n  // will also be persisted into the cache, which can be useful to ensure\n  // the Reference actually refers to data stored in the cache. If you\n  // pass an ID string, toReference will make a Reference out of it. If\n  // you pass a Reference, toReference will return it as-is.\n  toReference(\n    objOrIdOrRef: StoreObject | string | Reference,\n    mergeIntoStore?: boolean,\n  ): Reference | undefined;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField<T = StoreValue>(\n    nameOrField: string | FieldNode,\n    foreignObjOrRef?: StoreObject | Reference,\n  ): T;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead(value: StoreValue): boolean;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: Record<string, any>;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects<T extends StoreObject | Reference>(\n    existing: T,\n    incoming: T,\n  ): T | undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Field Policy for Merging Paginated Results in Apollo Cache\nDESCRIPTION: This code snippet configures Apollo Client's InMemoryCache with a typePolicy for the 'feed' field under 'Query'. It disables key arguments causing separate cache entries per argument value and provides a merge function to concat incoming results with existing cached data. This setup ensures seamlessly merged paginated results in the cache regardless of the query arguments used.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/core-api.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: false,\n          merge(existing = [], incoming) {\n            return [...existing, ...incoming];\n          },\n        }\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using TypedDocumentNode with useQuery Hook in Apollo Client and TypeScript\nDESCRIPTION: Introduces the TypedDocumentNode type to strongly type GraphQL queries to infer data and variable types automatically. Shows usage with gql tagged queries and React hooks useQuery with typed variables and data, enabling safer and more readable API usage without redundant type annotations on invocation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_16\n\nLANGUAGE: TSX\nCODE:\n```\nimport React from 'react';\nimport { useQuery, gql, TypedDocumentNode } from '@apollo/client';\n\ninterface RocketInventoryData {\n  rocketInventory: RocketInventory[];\n}\n\ninterface RocketInventoryVars {\n  year: number;\n}\n\nconst GET_ROCKET_INVENTORY: TypedDocumentNode<RocketInventoryData, RocketInventoryVars> = gql`\n  query GetRocketInventory($year: Int!) {\n    rocketInventory(year: $year) {\n      id\n      model\n      year\n      stock\n    }\n  }\n`;\n\nexport function RocketInventoryList() {\n  const { loading, data } = useQuery(\n    GET_ROCKET_INVENTORY,\n    { variables: { year: 2019 } }\n  );\n  return (\n    <div>\n      <h3>Available Inventory</h3>\n      {loading ? (\n        <p>Loading ...</p>\n      ) : (\n        <table>\n          <thead>\n            <tr>\n              <th>Model</th>\n              <th>Stock</th>\n            </tr>\n          </thead>\n          <tbody>\n            {data && data.rocketInventory.map(inventory => (\n              <tr>\n                <td>{inventory.model}</td>\n                <td>{inventory.stock}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      )}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended skipToken usage - TypeScript\nDESCRIPTION: Demonstrates the recommended way to conditionally skip a query using `skipToken` with `useSuspenseQuery` in TypeScript.  This avoids type errors and makes the connection between skipping and variable definitions explicit, improving code clarity and safety.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useSuspenseQuery(\n  query,\n  id ? { variables: { id } } : skipToken\n);\n```\n\n----------------------------------------\n\nTITLE: Adding Authorization Header with Custom Apollo Link (JavaScript)\nDESCRIPTION: This snippet demonstrates creating a custom Apollo Link named authMiddleware that adds an Authorization header using a token stored in local storage, and integrating it into Apollo Client via concat. It enables request-level customization to include authentication tokens.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, HttpLink, ApolloLink, InMemoryCache, concat } from '@apollo/client';\n\nconst httpLink = new HttpLink({ uri: '/graphql' });\n\nconst authMiddleware = new ApolloLink((operation, forward) => {\n  // add the authorization to the headers\n  operation.setContext(({ headers = {} }) => ({\n    headers: {\n      ...headers,\n      authorization: localStorage.getItem('token') || null,\n    }\n  }));\n\n  return forward(operation);\n})\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: concat(authMiddleware, httpLink),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Mocked Responses for GraphQL Query in Jest Test (JSX)\nDESCRIPTION: This snippet defines a mock response object passed to the MockedProvider mocks prop for the GET_DOG_QUERY query with variable name 'Buck'. The mock includes the request shape and the result data simulating a dog of breed bulldog. This allows tests to run without communicating with a real GraphQL server by providing predefined responses.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst mocks = [\n  {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: {\n        name: \"Buck\"\n      }\n    },\n    result: {\n      data: {\n        dog: { __typename: \"Dog\", id: \"1\", name: \"Buck\", breed: \"bulldog\" }\n      }\n    }\n  }\n];\n```\n\n----------------------------------------\n\nTITLE: Defining the mocks Array for MockedProvider - JavaScript\nDESCRIPTION: This snippet shows how to define the mocks array, which specifies the request/response pairs for use with MockedProvider. Each object in the array contains a request field with query and variables, and a corresponding result or error field. Key dependencies include GraphQL query definitions (such as GET_DOG) and required variables. Inputs: GraphQL operations and variables; Outputs: mocked responses for matching queries. Ensure queries and results match component expectations; errors can be simulated by returning new Error instances. All objects should match the shape expected by @apollo/client/testing for predictable test outcomes.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/testing.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mocks = [\n  {\n    request: {\n      query: GET_DOG,\n      variables: { index: 4 }\n    },\n    result: {\n      data: {\n        dog: {\n          name: \"Douglas\"\n        }\n      }\n    }\n  },\n  {\n    request: {\n      query: GET_DOG,\n      variables: { index: 8 }\n    },\n    error: new Error(\"Something went wrong\")\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with useSuspenseQuery - TypeScript\nDESCRIPTION: This code demonstrates how to use the `useSuspenseQuery` hook to fetch data and leverage React's Suspense feature.  The `Dog` component suspends while the network request is pending, triggering the nearest `Suspense` boundary to render a fallback. The `GET_DOG_QUERY` fetches data for a single dog by its ID.  Dependencies: `@apollo/client`, `react`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Suspense } from 'react';\nimport {\n  gql,\n  TypedDocumentNode,\n  useSuspenseQuery\n} from '@apollo/client';\n\ninterface Data {\n  dog: {\n    id: string;\n    name: string;\n  };\n}\n\ninterface Variables {\n  id: string;\n}\n\ninterface DogProps {\n  id: string\n}\n\nconst GET_DOG_QUERY: TypedDocumentNode<Data, Variables> = gql`\n  query GetDog($id: String) {\n    dog(id: $id) {\n      # By default, an object's cache key is a combination of\n      # its __typename and id fields, so we should always make\n      # sure the id is in the response so our data can be\n      # properly cached.\n      id\n      name\n      breed\n    }\n  }\n`;\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog id=\"3\" />\n    </Suspense>\n  );\n}\n\nfunction Dog({ id }: DogProps) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { id },\n  });\n\n  return <>Name: {data.dog.name}</>;\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query Using Async @client Field\nDESCRIPTION: Defines a GraphQL query that includes a field ('cameraRoll') marked with the `@client` directive. This indicates that the field should be resolved locally, potentially asynchronously, by a corresponding resolver defined in the Apollo Client configuration.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_13\n\nLANGUAGE: GraphQL\nCODE:\n```\nimport { gql } from \"@apollo/client\";\n\nconst GET_PHOTOS = gql`\n  query GetPhotos($assetType: String!) {\n    cameraRoll(assetType: $assetType) @client {\n      id\n      edges {\n        node {\n          image {\n            uri\n          }\n          location {\n            latitude\n            longitude\n          }\n        }\n      }\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Person Object JSON Before Cache Reference Replacement\nDESCRIPTION: This JSON snippet shows a specific object (`Person`) from a GraphQL response as it appears just before Apollo Client's cache performs normalization. It highlights the nested `homeworld` field which contains the full `Planet` object directly within the `Person` object's structure.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/overview.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"__typename\": \"Person\",\n  \"id\": \"cGVvcGxlOjE=\",\n  \"name\": \"Luke Skywalker\",\n  \"homeworld\": {\n    \"__typename\": \"Planet\",\n    \"id\": \"cGxhbmV0czox\",\n    \"name\": \"Tatooine\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Split Link Based on Operation Type - JavaScript\nDESCRIPTION: This snippet shows how to use the `split` function to route subscription operations to a `GraphQLWsLink` and other operations to an `HttpLink`. It uses `getMainDefinition` to determine the operation type from the query. It requires imports from `@apollo/client` and `@apollo/client/link/subscriptions` and assumes a `createClient` function from `graphql-ws`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { split, HttpLink } from '@apollo/client';\nimport { getMainDefinition } from '@apollo/client/utilities';\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\nimport { createClient } from 'graphql-ws';\n\nexport const link = split(\n  ({ query }) => {\n    const definition = getMainDefinition(query);\n    return (\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'subscription'\n    );\n  },\n  new GraphQLWsLink(createClient({ url: 'ws://localhost:3000/subscriptions' })),\n  new HttpLink({ uri: 'http://localhost:4000/graphql' })\n);\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Relay Pagination Cache Policy with relayStylePagination\nDESCRIPTION: Shows how to configure the Apollo Client `InMemoryCache` with a field policy for a Relay-style connection field (`comments`). It uses the built-in `relayStylePagination` utility function from `@apollo/client/utilities` to automatically handle the necessary `read` and `merge` logic for managing the cached list of results from a Relay connection, simplifying the use of `fetchMore`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/cursor-based.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { relayStylePagination } from \"@apollo/client/utilities\";\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        comments: relayStylePagination(),\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating useSuspenseFragment with Suspense\nDESCRIPTION: The `List` component integrates `useSuspenseFragment` with React Suspense. It uses `useSuspenseQuery` to fetch data and then wraps each `Item` component in a `Suspense` boundary, showing a spinner during data loading. Requires React, Apollo Client and a `useSuspenseQuery` setup.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\nfunction List() {\n  const { data } = useSuspenseQuery(listQuery);\n\n  return (\n    <ol>\n      {data.list.map(item => (\n        <Suspense fallback={<Spinner />}>\n          <Item key={item.id} item={item}/>\n        </Suspense>\n      ))}\n    </ol>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Loading and Success States with Delay in MockedProvider Using JSX\nDESCRIPTION: This snippet tests a component's asynchronous loading and success rendering states by defining a mock with a delay to prevent React from batching the loading state away. It uses screen.findByText to await elements representing the loading message and the successful data rendering.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nit(\"should render dog\", async () => {\n  const dogMock = {\n    delay: 30 // to prevent React from batching the loading state away\n    // delay: Infinity // if you only want to test the loading state\n\n    request: {\n      query: GET_DOG_QUERY,\n      variables: { name: \"Buck\" }\n    },\n    result: {\n      data: { dog: { __typename: \"Dog\", id: 1, name: \"Buck\", breed: \"poodle\" } }\n    }\n  };\n  render(\n    <MockedProvider mocks={[dogMock]}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>\n  );\n  expect(await screen.findByText(\"Loading...\")).toBeInTheDocument();\n  expect(await screen.findByText(\"Buck is a poodle\")).toBeInTheDocument();\n});\n```\n\n----------------------------------------\n\nTITLE: Typing `useMutation` Hook with Generated GraphQL Types in TypeScript\nDESCRIPTION: Shows how to generate a type-safe mutation hook for saving a rocket, with variables and response data strongly typed, facilitating form handling and error management.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ...\nconst SAVE_ROCKET = gql(/* GraphQL */ `\n  mutation saveRocket($rocket: RocketInput!) {\n    saveRocket(rocket: $rocket) {\n      model\n    }\n  }\n`);\n\nexport function NewRocketForm() {\n  const [model, setModel] = useState('');\n  const [year, setYear] = useState(0);\n  const [stock, setStock] = useState(0);\n\n  const [saveRocket, { error, data }] = useMutation(SAVE_ROCKET, {\n    variables: { rocket: { model, year: +year, stock: +stock } }\n  });\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Live Binding for Each Item with useFragment (TypeScript)\nDESCRIPTION: The `Item` component uses the `useFragment` hook to create a live binding for data from the `ItemFragment`. It receives an `id` property and uses it to specify which item's fragment data to fetch and display. It displays the item's text or an \"incomplete\" message based on the fragment data's status. Dependencies are React, Apollo Client, and an `ItemFragment` definition.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Item(props: { id: number }) {\n  const { complete, data } = useFragment({\n    fragment: ITEM_FRAGMENT,\n    fragmentName: \"ItemFragment\",\n    from: {\n      __typename: \"Item\",\n      id: props.id\n    }\n  });\n\n  return <li>{complete ? data.text : \"incomplete\"}</li>;\n}\n```\n\n----------------------------------------\n\nTITLE: Removing an Item from a List using cache.modify in Apollo Client (JavaScript)\nDESCRIPTION: Demonstrates removing an item from a list field within the cache using `cache.modify`. The modifier function for the list field receives the existing array of references. It uses the `readField` utility (available in the second argument of the modifier function) to access fields of the referenced items and filters out the item to be removed based on its ID.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst idToRemove = 'abc123';\n\ncache.modify({\n  id: cache.identify(myPost),\n  fields: {\n    comments(existingCommentRefs, { readField }) {\n      return existingCommentRefs.filter(\n        commentRef => idToRemove !== readField('id', commentRef)\n      );\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with Fragments on Unions/Interfaces\nDESCRIPTION: This is a GraphQL query example that utilizes fragments with an interface and inline fragments.  The `AllCharacters` query retrieves data from an interface type `Character` and selects specific fields depending on whether it's a `Jedi` or `Droid` object by the `side` or `model` fields respectively, demonstrating polymorphic data retrieval.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_15\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery AllCharacters {\n  allCharacters {\n    name\n\n    ... on Jedi {\n      side\n    }\n\n    ... on Droid {\n      model\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client with a Shared Fragment Registry\nDESCRIPTION: Initializing Apollo Client with a shared fragment registry that allows components to register fragments from anywhere in the application.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nimport { fragmentRegistry } from \"./fragmentRegistry\";\n\nconst client = new ApolloClient({\n  uri: \"http://localhost:4000/graphql\",\n  cache: new InMemoryCache({\n    fragments: fragmentRegistry,\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Cached Context Lookup with Error Handling - Apollo Client - JavaScript\nDESCRIPTION: Illustrates how to optimize asynchronous context lookups by caching the result (e.g., a user token) outside the link function. It uses `setContext` to return the cached value if available or perform the async lookup and cache the result otherwise. The `onError` link is then used to detect specific network errors (like a 401 Unauthorized) and invalidate the cached token, triggering a re-fetch on subsequent requests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-context.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { setContext } from \"@apollo/client/link/context\";\nimport { onError } from \"@apollo/client/link/error\";\n\n// cached storage for the user token\nlet token;\nconst withToken = setContext(() => {\n  // if you have a cached value, return it immediately\n  if (token) return { token };\n\n  return AsyncTokenLookup().then(userToken => {\n    token = userToken;\n    return { token };\n  });\n});\n\nconst resetToken = onError(({ networkError }) => {\n  if (\n    networkError &&\n    networkError.name ==='ServerError' &&\n    networkError.statusCode === 401\n  ) {\n    // remove cached token on 401 from the server\n    token = null;\n  }\n});\n\nconst authFlowLink = withToken.concat(resetToken);\n```\n\n----------------------------------------\n\nTITLE: Configuring Paginated Read and Merge Functions in Field Policy (JavaScript)\nDESCRIPTION: Shows how to configure `read` and `merge` functions within an `InMemoryCache`'s `typePolicies` for a paginated field (`feed`). The `read` function implements client-side re-pagination by slicing the `existing` cached list based on `offset` and `limit` arguments. The `merge` function combines `incoming` data into the `existing` list at the specified `offset`, ensuring immutability by copying the existing data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/core-api.mdx#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          read(existing, { args: { offset, limit }}) {\n            // A read function should always return undefined if existing is\n            // undefined. Returning undefined signals that the field is\n            // missing from the cache, which instructs Apollo Client to\n            // fetch its value from your GraphQL server.\n            return existing && existing.slice(offset, offset + limit);\n          },\n\n          // The keyArgs list and merge function are the same as above.\n          keyArgs: [],\n          merge(existing, incoming, { args: { offset = 0 }}) {\n            const merged = existing ? existing.slice(0) : [];\n            for (let i = 0; i < incoming.length; ++i) {\n              merged[offset + i] = incoming[i];\n            }\n            return merged;\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: useSuspenseQuery Hook Signature - TypeScript\nDESCRIPTION: This TypeScript snippet specifies the function signature for the useSuspenseQuery React hook in Apollo Client, which supports fetching query data with automatic Suspense integration. It receives a GraphQL DocumentNode and optional SuspenseQueryHookOptions or SkipToken, returning a UseSuspenseQueryResult containing query data and status. Requires react (>=18), @apollo/client, and TypeScript. Inputs are the query document and options; output is the current query state. Limitations: requires parent Suspense boundary for proper rendering.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useSuspenseQuery<TData, TVariables>(\n  query: DocumentNode,\n  options?: SuspenseQueryHookOptions<TData, TVariables> | SkipToken,\n): UseSuspenseQueryResult<TData, TVariables>\n```\n\n----------------------------------------\n\nTITLE: Using useReactiveVar hook in React to subscribe to reactive variables\nDESCRIPTION: Explains how React components can utilize the useReactiveVar hook to access reactive variables. This integration allows components to re-render automatically upon reactive variable updates, providing seamless reactivity without using useQuery.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/reactive-variables.mdx#_snippet_3\n\nLANGUAGE: React\nCODE:\n```\nimport { makeVar, useReactiveVar } from \"@apollo/client\";\n\nexport const cartItemsVar = makeVar([]);\n\nexport function Cart() {\n  const cartItems = useReactiveVar(cartItemsVar);\n  // component logic here\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Apollo Client Cache with update Function\nDESCRIPTION: Demonstrates how to use the update function with useMutation to manually modify the Apollo Client cache after a mutation. This example shows adding a new todo item to an existing list in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst GET_TODOS = gql`\n  query GetTodos {\n    todos {\n      id\n    }\n  }\n`;\n\nfunction AddTodo() {\n  let input;\n  const [addTodo] = useMutation(ADD_TODO, {\n    update(cache, { data: { addTodo } }) {\n      cache.modify({\n        fields: {\n          todos(existingTodos = []) {\n            const newTodoRef = cache.writeFragment({\n              data: addTodo,\n              fragment: gql`\n                fragment NewTodo on Todo {\n                  id\n                  type\n                }\n              `\n            });\n            return [...existingTodos, newTodoRef];\n          }\n        }\n      });\n    }\n  });\n\n  return (\n    <div>\n      <form\n        onSubmit={e => {\n          e.preventDefault();\n          addTodo({ variables: { type: input.value } });\n          input.value = \"\";\n        }}\n      >\n        <input\n          ref={node => {\n            input = node;\n          }}\n        />\n        <button type=\"submit\">Add Todo</button>\n      </form>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Hook Example with Custom Error Policy in Apollo Client\nDESCRIPTION: This React component demonstrates how to set a custom error policy ('all') in the `useQuery` hook to handle partial data alongside GraphQL errors, allowing rendering of both successful data and error messages.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/error-handling.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst MY_QUERY = gql`\n  query WillFail {\n    badField # This field's resolver produces an error\n    goodField # This field is populated successfully\n  }\n`;\n\nfunction ShowingSomeErrors() {\n  const { loading, error, data } = useQuery(MY_QUERY, { errorPolicy: \"all\" });\n\n  if (loading) return <span>loading...</span>;\n  return (\n    <div>\n      <h2>Good: {data.goodField}</h2>\n      <pre>\n        Bad: {\" \"}\n        {error.graphQLErrors.map(({ message }, i) => (\n          <span key={i}>{message}</span>\n        ))}\n      </pre>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client cache with initial local state\nDESCRIPTION: This snippet shows how to prepopulate the Apollo Client cache with initial data using `cache.writeQuery`. This practice ensures that local queries, run on component mount, won't error out when data is absent. It is also useful for resetting cache state upon user logout or similar actions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst cache = new InMemoryCache();\nconst client = new ApolloClient({\n  cache,\n  resolvers: { /* ... */ },\n});\n\ncache.writeQuery({\n  query: gql`\n    query GetTodosNetworkStatusAndFilter {\n      todos\n      visibilityFilter\n      networkStatus {\n        isConnected\n      }\n    }\n  `,\n  data: {\n    todos: [],\n    visibilityFilter: 'SHOW_ALL',\n    networkStatus: {\n      __typename: 'NetworkStatus',\n      isConnected: false,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Example Masked Query Output (With PublishedAt)\nDESCRIPTION: Illustrates the structure of the `data` object returned by the `useQuery` hook for the modified `GetPosts` query (where `publishedAt` is explicitly included) when data masking is enabled. The `publishedAt` field is now accessible to the parent component (`Posts`) for its filtering logic.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_37\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"posts\": [\n    {\n      \"__typename\": \"Post\",\n      \"publishedAt\": \"2024-01-01\",\n      \"id\": \"1\"\n    },\n    {\n      \"__typename\": \"Post\",\n      \"publishedAt\": null,\n      \"id\": \"2\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Network Error in React Component Test with MockedProvider Using JSX\nDESCRIPTION: This snippet tests how a component handles network errors by providing a mock object with an error field containing a new Error instance. The component is rendered with the MockedProvider wrapping and the test asserts that the error message is properly displayed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nit(\"should show error UI\", async () => {\n  const dogMock = {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: { name: \"Buck\" }\n    },\n    error: new Error(\"An error occurred\")\n  };\n  render(\n    <MockedProvider mocks={[dogMock]}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>\n  );\n  expect(await screen.findByText(\"An error occurred\")).toBeInTheDocument();\n});\n```\n\n----------------------------------------\n\nTITLE: Updating a GraphQL Fragment in Apollo Cache (JavaScript)\nDESCRIPTION: The `updateFragment` method fetches data from the cache in the shape of a provided GraphQL fragment and updates that cached data according to a provided update function. It takes an options object with the fragment and the ID of the cached object, and an update function that receives the current cached value.  It returns the updated result or null if the update failed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// Fetches a Todo object with id 5 and sets its `completed` boolean to true\nconst todo = cache.updateFragment({ // options object\n  id: '5', // The value of the to-do item's unique identifier\n  fragment: gql`\n    fragment MyTodo on Todo {\n      completed\n    }\n  `,\n}, (data) => ({ ...data, completed: true }) // update function\n);\n```\n\n----------------------------------------\n\nTITLE: Updating Cache with cache.writeFragment in Resolver - JS\nDESCRIPTION: This code snippet demonstrates how to update the Apollo Client cache using `cache.writeFragment` within a resolver function. It defines a resolver for the `updateUserEmail` mutation. It uses `cache.identify` to get the cache key for a given user.  The `fragment` and `data` are then used to update the specified fields for the user in the cache.  Dependencies include ApolloClient and InMemoryCache from '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  resolvers: {\n    Mutation: {\n      updateUserEmail: (_, { id, email }, { cache }) => {\n        cache.writeFragment({\n          id: cache.identify({ __typename: \"User\", id }),\n          fragment: gql`fragment UserEmail on User { email }`,\n          data: { email },\n        });\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Simulating GraphQL Error Response in Mock Using JavaScript\nDESCRIPTION: This snippet shows how to simulate GraphQL errors by defining an errors field containing an array of instantiated GraphQLError objects within a mock's result field. Such mocks can also include partial data to represent partial successful responses.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nconst dogMock = {\n  // ...\n  result: {\n    errors: [new GraphQLError(\"Error!\")],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Fetching Data in Response to User Interaction with useLoadableQuery - TypeScript\nDESCRIPTION: This snippet demonstrates the use of `useLoadableQuery` to fetch data based on user interaction (selecting a dog from a dropdown).  It uses `useSuspenseQuery` to fetch initial data and `useLoadableQuery` to fetch more data on user input. It renders a dog component that displays the dog's name and breed.  Requires Apollo Client and React.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  // ...\n  useLoadableQuery\n} from '@apollo/client';\n\nfunction App() {\n  const { data } = useSuspenseQuery(GET_DOGS_QUERY);\n  const [loadDog, queryRef] = useLoadableQuery(GET_DOG_QUERY);\n\n  return (\n    <>\n      <select\n        onChange={(e) => loadDog({ id: e.target.value })\n      >\n        {data.dogs.map(({ id, name }) => (\n          <option key={id} value={id}>\n            {name}\n          </option>\n        ))}\n      </select>\n      <Suspense fallback={<div>Loading...</div>}>\n        {queryRef && <Dog queryRef={queryRef} />}\n      </Suspense>\n    </>\n  );\n}\n\nfunction Dog({ queryRef }: DogProps) {\n  const { data } = useReadQuery(queryRef)\n\n  return (\n    <>\n      <div>Name: {data.dog.name}</div>\n      <div>Breed: {data.dog.breed}</div>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining an Item Fragment with GraphQL\nDESCRIPTION: This code defines a GraphQL fragment named `ItemFragment`. The fragment specifies the `text` field of an `Item` type. This fragment can be reused across multiple queries to select specific fields from the `Item` type.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_20\n\nLANGUAGE: graphql\nCODE:\n```\nconst ITEM_FRAGMENT = gql`\n  fragment ItemFragment on Item {\n    text\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Connect Apollo Client to VS Code Devtools - JavaScript\nDESCRIPTION: This JavaScript snippet imports the necessary function from `@apollo/client-devtools-vscode` and calls it with the `ApolloClient` instance and the WebSocket endpoint of the VS Code Devtools panel (defaulting to `ws://localhost:7095`). This establishes a connection, allowing introspection and debugging of the client's cache, queries, and mutations from within the VS Code environment. It is recommended to only run this in a development build.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/developer-tooling.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { connectApolloClientToVSCodeDevTools } from \"@apollo/client-devtools-vscode\";\n\nconst client = new ApolloClient({ /* ... */ });\n\n// we recommend wrapping this statement in a check for e.g. process.env.NODE_ENV === \"development\"\nconst devtoolsRegistration = connectApolloClientToVSCodeDevTools(\n  client,\n  // the default port of the VSCode DevTools is 7095\n  \"ws://localhost:7095\",\n);\n```\n\n----------------------------------------\n\nTITLE: Defining and integrating a client-side schema with ApolloClient\nDESCRIPTION: This code demonstrates how to define a client-side schema using GraphQL SDL, extend existing types, and provide this schema to the ApolloClient constructor for local-only state management. Dependencies include @apollo/client, and the main functionality involves schema extension and client configuration.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/client-side-schema.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst typeDefs = gql`\n  extend type Query {\n    isLoggedIn: Boolean!\n    cartItems: [Launch]!\n  }\n\n  extend type Launch {\n    isInCart: Boolean!\n  }\n\n  extend type Mutation {\n    addOrRemoveFromCart(id: ID!): [Launch]\n  }\n`;\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  uri: 'http://localhost:4000/graphql',\n  typeDefs,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Field Policy to Transform Cached Field - Apollo Client TypeScript\nDESCRIPTION: This code defines a field policy that transforms the cached value of the 'name' field for a 'Person' type to upper case whenever it's read from Apollo Client's cache. It uses the 'read' function in the 'fields' configuration for the 'Person' type inside InMemoryCache. The only dependency is the Apollo Client package, and this pattern supports transforming native or custom fields based on client requirements. The input is any value for 'name', and the output is always in upper-case string format. Limitations: transformation here is strictly to upper case; for advanced string transforms, further customization is needed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Person: {\n      fields: {\n        name: {\n          read(name) {\n            // Return the cached name, transformed to upper case\n            return name.toUpperCase();\n          }\n        }\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Item List with GraphQL and ItemFragment\nDESCRIPTION: This code defines a GraphQL query named `GetItemList` using `gql` to retrieve a list of items. The query includes the `id` field for each item and uses the `ItemFragment` fragment.  The inclusion of the fragment allows the query to retrieve the fields defined within `ItemFragment`. Dependencies include Apollo Client and a GraphQL client for executing the query.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_21\n\nLANGUAGE: graphql\nCODE:\n```\nconst listQuery = gql`\n  query GetItemList {\n    list {\n      id\n      ...ItemFragment\n    }\n  }\n\n  ${ITEM_FRAGMENT}\n`;\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Fragment in Apollo Client (Initial)\nDESCRIPTION: Defines a GraphQL query `GetPosts` that fetches a list of posts, including a fragment `PostDetailsFragment`, and shows a React component `Posts` using the `useQuery` hook to execute the query and render post details. This demonstrates a common pattern before enabling data masking, where the parent component might implicitly depend on fields defined in the fragment.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_30\n\nLANGUAGE: jsx\nCODE:\n```\nimport { POST_DETAILS_FRAGMENT } from './PostDetails';\n\nconst GET_POSTS = gql`\n  query GetPosts {\n    posts {\n      id\n      ...PostDetailsFragment\n    }\n  }\n\n  ${POST_DETAILS_FRAGMENT}\n`;\n\nexport default function Posts({ includeUnpublishedPosts }) {\n  const { data, loading } = useQuery(GET_POSTS);\n  const posts = data?.posts ?? [];\n\n  if (loading) {\n    return <Spinner />;\n  }\n\n  const allPosts = includeUnpublishedPosts\n    ? posts\n    : posts.filter((post) => post.publishedAt);\n\n  if (allPosts.length === 0) {\n    return <div>No posts to display</div>;\n  }\n\n  return (\n    <div>\n      {allPosts.map((post) => (\n        <PostDetails key={post.id} post={post} />\n      ))}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Custom Document Transform for Adding 'id' to 'currentUser' in TypeScript\nDESCRIPTION: Presents a full implementation of a DocumentTransform that checks all 'currentUser' field selections in incoming GraphQL documents and ensures an 'id' field is present, using graphql-js's visit, Kind, and BREAK utilities. Code includes dependency imports, full callback logic, and AST node manipulations. Input is a GraphQL document AST; output is a potentially modified document AST.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { DocumentTransform } from '@apollo/client';\nimport { visit, Kind, BREAK } from 'graphql';\n\nconst documentTransform = new DocumentTransform((document) => {\n  const transformedDocument = visit(document, {\n    Field(field) {\n      if (field.name.value !== 'currentUser') {\n        return;\n      }\n\n      const selections = field.selectionSet?.selections ?? [];\n\n      for (const selection of selections) {\n        if (\n          selection.kind === Kind.FIELD &&\n          selection.name.value === 'id'\n        ) {\n          return BREAK;\n        }\n      }\n\n      const idField = {\n        kind: Kind.FIELD,\n        name: {\n          kind: Kind.NAME,\n          value: 'id',\n        },\n      };\n\n      return {\n        ...field,\n        selectionSet: {\n          ...field.selectionSet,\n          selections: [...selections, idField],\n        },\n      };\n    },\n  });\n\n  return transformedDocument;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Query (GET_DOG_PHOTO)\nDESCRIPTION: Defines a GraphQL query `GET_DOG_PHOTO` using `gql`. This query takes a `breed` as a variable and fetches the corresponding `id` and `displayImage` from the `dog` query.  The `breed` variable is a string and is required, indicated by the `!`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/queries.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst GET_DOG_PHOTO = gql`\n  query Dog($breed: String!) {\n    dog(breed: $breed) {\n      id\n      displayImage\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Reading Fragment Data with useFragment (Complete)\nDESCRIPTION: Shows the full implementation of using the `useFragment` hook in the `PostDetails` component when data masking is enabled. It accesses the fragment data via the `data` property returned by the hook and includes a check using the `complete` flag to ensure all necessary data was available from the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_39\n\nLANGUAGE: jsx\nCODE:\n```\nfunction PostDetails({ post }) {\n  const { data, complete } = useFragment({\n    fragment: POST_DETAILS_FRAGMENT,\n    from: post,\n  });\n\n  // It's a good idea to check the `complete` flag to ensure all data was\n  // successfully queried from the cache. This can indicate a potential\n  // issue with the cache configuration or parent object when `complete`\n  // is `false`.\n  if (!complete) {\n    return null;\n  }\n\n  return (\n    <section>\n      <h1>{data.title}</h1>\n      <p>{data.shortDescription}</p>\n    </section>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing HttpLink in JavaScript\nDESCRIPTION: Basic example of importing the `HttpLink` class from '@apollo/client' and creating a new link instance, providing the URI for the GraphQL endpoint. This is the default link used by ApolloClient when a `uri` is provided.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-http.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { HttpLink } from '@apollo/client';\n\nconst link = new HttpLink({\n  uri: \"http://localhost:4000/graphql\"\n  // Additional options\n});\n```\n\n----------------------------------------\n\nTITLE: Invoking Garbage Collection with InMemoryCache (JavaScript)\nDESCRIPTION: Calls the gc method on an InMemoryCache instance to remove all objects from the normalized cache that are no longer reachable from root queries or mutations. No external dependencies are required beyond apollo-client and an instantiated InMemoryCache. This method returns a list of removed object IDs and is typically used to reclaim memory and ensure cache consistency after updates.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache.gc();\n```\n\n----------------------------------------\n\nTITLE: Invalidating Cache Fields for Selective Refetching with Apollo Client in TypeScript\nDESCRIPTION: This snippet uses cache.modify and the INVALIDATE sentinel object within updateCache to mark certain cache fields as invalid, prompting the client to refetch any dependent queries. This is useful for triggering refetch without changing the actual value. Input: cache.modify fields; Output: affected queries refetched. Dependencies: Apollo Client's cache.modify and INVALIDATE support.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  updateCache(cache) {\n    cache.modify({\n      fields: {\n        someRootField(value, { INVALIDATE }) {\n          // Update queries that involve Query.someRootField, without actually\n          // changing its value in the cache.\n          return INVALIDATE;\n        },\n      },\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Reading cached data using readFragment in Apollo Client (JavaScript)\nDESCRIPTION: Reads cached data shaped according to a specified GraphQL fragment. Accepts an options object with required fragment (created with gql template literal) and id of the target cached object, along with optional optimistic flag for optimistic data. Returns the matched data or null if unavailable in cache. Used for retrieving partial data uniquely identified by cache id and fragment shape.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst todo = cache.readFragment({\n  id: '5', // The value of the to-do item's unique identifier\n  fragment: gql`\n    fragment MyTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering DeleteButton Component with MockedProvider for Apollo Client Mutation Testing in JSX\nDESCRIPTION: Tests rendering of the DeleteButton component using @testing-library/react and Apollo Client's MockedProvider with an empty mocks array, ensuring component mounts without errors. This test does not trigger any mutations because the mutate function is not called. Dependencies include '@testing-library/react', '@testing-library/jest-dom', MockedProvider from '@apollo/client/testing', and the DeleteButton component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport '@testing-library/jest-dom';\nimport userEvent from '@testing-library/user-event';\nimport { render, screen } from '@testing-library/react';\nimport { MockedProvider } from \"@apollo/client/testing\";\nimport { DeleteButton, DELETE_DOG_MUTATION } from \"./delete-dog\";\n\nit(\"should render without error\", () => {\n  render(\n    <MockedProvider mocks={[]}>\n      <DeleteButton />\n    </MockedProvider>\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Obtaining and Using Apollo Cache ID with cache.identify in JavaScript\nDESCRIPTION: Shows how to obtain the cache ID for a JavaScript object (`invisibleManBook`) using `cache.identify`. This method automatically determines the ID based on the object's `__typename` and its configured identifier fields (e.g., `isbn`), even if custom. The resulting ID is then used in `cache.writeFragment` to target the correct object in the cache for updating its `publicationYear`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_17\n\nLANGUAGE: js\nCODE:\n```\nconst bookYearFragment = gql`\n  fragment BookYear on Book {\n    publicationYear\n  }\n`;\n\nconst fragmentResult = cache.writeFragment({\n  id: cache.identify(invisibleManBook),\n  fragment: bookYearFragment,\n  data: {\n    publicationYear: '1952'\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining FieldPolicy for Caching JavaScript\nDESCRIPTION: Illustrates the configuration of a custom `FieldPolicy` within Apollo Client's cache to optimize the retrieval of data already present in the cache.  The example defines a custom behavior, allowing `GET_DOG` to read from cache if available, and avoiding an unnecessary network request.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/why-apollo.mdx#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        dog(_, { args, toReference }) {\n          return toReference({\n            __typename: 'Dog',\n            id: args.id,\n          });\n        },\n      },\n    },\n  },\n});\n\nconst client = new ApolloClient({ cache });\n```\n\n----------------------------------------\n\nTITLE: Enhanced Merge Function Handling Offset Argument\nDESCRIPTION: This code demonstrates a more robust merge function in Apollo cache configuration that considers the 'offset' argument provided in the fetch. It creates a merged array by inserting incoming items at positions based on 'offset', allowing out-of-order or overlapping fetches to correctly merge without duplication, improving pagination handling.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/core-api.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: false,\n          merge(existing, incoming, { args: { offset = 0 }}) {\n            // Make a copy of existing list; slices prevent mutation issues.\n            const merged = existing ? existing.slice(0) : [];\n            for (let i = 0; i < incoming.length; ++i) {\n              merged[offset + i] = incoming[i];\n            }\n            return merged;\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Resetting Apollo Client cache and reinitializing local state\nDESCRIPTION: This code shows how to register a callback with `client.onResetStore` to reinitialize the cache's initial state after a store reset, such as on user logout. It ensures that local state remains consistent by resubmitting initial data to the cache using `writeQuery` whenever the store resets.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst cache = new InMemoryCache();\nconst client = new ApolloClient({\n  cache,\n  resolvers: { /* ... */ },\n});\n\nfunction writeInitialData() {\n  cache.writeQuery({\n    query: gql`\n      query GetTodosNetworkStatusAndFilter {\n        todos\n        visibilityFilter\n        networkStatus {\n          isConnected\n        }\n      }\n    `,\n    data: {\n      todos: [],\n      visibilityFilter: 'SHOW_ALL',\n      networkStatus: {\n        __typename: 'NetworkStatus',\n        isConnected: false,\n      },\n    },\n  });\n}\n\nwriteInitialData();\n\nclient.onResetStore(writeInitialData);\n```\n\n----------------------------------------\n\nTITLE: Install Apollo Client and GraphQL dependencies\nDESCRIPTION: Installs the necessary dependencies for using Apollo Client in a React application.  This includes `@apollo/client` which provides the core Apollo Client functionality and `graphql` which provides logic for parsing GraphQL queries.  The command is executed using npm.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client graphql\n```\n\n----------------------------------------\n\nTITLE: Implementing custom fetch function with authentication headers\nDESCRIPTION: This snippet shows how to define a custom fetch function to modify the outgoing request by injecting authorization headers calculated via Hawk. It then demonstrates creating an HttpLink with this custom fetch to allow advanced request control, such as adding authentication tokens dynamically.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst customFetch = (uri, options) => {\n  const { header } = Hawk.client.header(\n    \"http://example.com:8000/resource/1?b=1&a=2\",\n    \"POST\",\n    { credentials: credentials, ext: \"some-app-data\" }\n  );\n  options.headers.Authorization = header;\n  return fetch(uri, options);\n};\n\nconst link = new HttpLink({ fetch: customFetch });\n```\n\n----------------------------------------\n\nTITLE: Custom fetch for dynamic URI based on operation name\nDESCRIPTION: This snippet illustrates creating a custom fetch function that dynamically modifies the request URI based on the operation name extracted from the request body. It then shows how to assign this fetch to a new HttpLink, enabling flexible endpoint determination per request.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst customFetch = (uri, options) => {\n  const { operationName } = JSON.parse(options.body);\n  return fetch(`${uri}/graph/graphql?opname=${operationName}`, options);\n};\n\nconst link = new HttpLink({ fetch: customFetch });\n```\n\n----------------------------------------\n\nTITLE: Preventing Request Waterfalls with useBackgroundQuery and useReadQuery\nDESCRIPTION: This example shows how to avoid request waterfalls by initiating queries early in the component tree with useBackgroundQuery and reading the results with useReadQuery in child components. This pattern optimizes performance by starting data fetching as soon as possible.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  useBackgroundQuery,\n  useReadQuery,\n  useSuspenseQuery,\n} from '@apollo/client';\n\nfunction App() {\n  // We can start the request here, even though `Dog`\n  // suspends and the data is read by a grandchild component.\n  const [queryRef] = useBackgroundQuery(GET_BREEDS_QUERY);\n\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog id=\"3\" queryRef={queryRef} />\n    </Suspense>\n  );\n}\n\nfunction Dog({ id, queryRef }: DogProps) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { id },\n  });\n\n  return (\n    <>\n      Name: {data.dog.name}\n      <Suspense fallback={<div>Loading breeds...</div>}>\n        <Breeds queryRef={queryRef} />\n      </Suspense>\n    </>\n  );\n}\n\ninterface BreedsProps {\n  queryRef: QueryRef<BreedData>;\n}\n\nfunction Breeds({ queryRef }: BreedsProps) {\n  const { data } = useReadQuery(queryRef);\n\n  return data.breeds.map(({ characteristics }) =>\n    characteristics.map((characteristic) => (\n      <div key={characteristic}>{characteristic}</div>\n    ))\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining possibleTypes Manually\nDESCRIPTION: This JavaScript code snippet illustrates the manual configuration of `possibleTypes` for an `InMemoryCache` instance. It maps interface and union types (e.g., `Character`, `Test`, `Snake`) to their implementing object types. This is essential to help the client understand polymorphic relationships in the schema.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_16\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  possibleTypes: {\n    Character: [\"Jedi\", \"Droid\"],\n    Test: [\"PassingTest\", \"FailingTest\", \"SkippedTest\"],\n    Snake: [\"Viper\", \"Python\"],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Variables for GraphQL Queries in Apollo Client\nDESCRIPTION: This example demonstrates how to define variables for a GraphQL query, enabling parameterized queries via the options property. The variables are computed from component props, allowing dynamic query parameterization based on component state.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_27\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(\n  gql`\n  query MyQuery ($width: Int!, $height: Int!) {\n    ...\n  }\n`,\n  {\n    options: props => ({\n      variables: {\n        width: props.size,\n        height: props.size,\n      },\n    }),\n  }\n)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple DocumentTransforms Using concat in TypeScript\nDESCRIPTION: Explains how to combine two or more DocumentTransform instances using the concat method to create a chain of transforms. When the composite transform is executed via transformDocument(), the GraphQL document flows through each transform in sequence, allowing modular logic. Requires '@apollo/client' and valid DocumentTransform callbacks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst documentTransform1 = new DocumentTransform(transform1);\nconst documentTransform2 = new DocumentTransform(transform2);\n\nconst documentTransform = documentTransform1.concat(documentTransform2);\n```\n\n----------------------------------------\n\nTITLE: Using Error Boundaries with Apollo Client Suspense Queries\nDESCRIPTION: Example of integrating an error boundary with Apollo Client's useSuspenseQuery to gracefully handle query errors. The error boundary is placed outside the suspending component to catch and display a custom error UI when GraphQL or network errors occur.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nfunction App() {\n  const { data } = useSuspenseQuery(GET_DOGS_QUERY);\n  const [selectedDog, setSelectedDog] = useState(\n    data.dogs[0].id\n  );\n\n  return (\n    <>\n      <select\n        onChange={(e) => setSelectedDog(e.target.value)}\n      >\n        {data.dogs.map(({ id, name }) => (\n          <option key={id} value={id}>\n            {name}\n          </option>\n        ))}\n      </select>\n      <ErrorBoundary\n        fallback={<div>Something went wrong</div>}\n      >\n        <Suspense fallback={<div>Loading...</div>}>\n          <Dog id={selectedDog} />\n        </Suspense>\n      </ErrorBoundary>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Fields for Nested Queries Using @export in GraphQL (Apollo Client, GraphQL)\nDESCRIPTION: This GraphQL query uses the @export directive to extract a field from the result of one REST call and use it as an argument in a nested REST call within the same query. The parent users REST endpoint exports an id which is then referenced in the friends query path. Dependencies: Apollo Client, apollo-link-rest. Input: email address as query parameter. Output: user details and friends list, leveraging variable re-use across requests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_28\n\nLANGUAGE: GraphQL\nCODE:\n```\nconst QUERY = gql`\n  query RestData($email: String!) {\n    users @rest(path: '/users/email?{args.email}', method: 'GET', type: 'User') {\n      id @export(as: \"id\")\n      firstName\n      lastName\n      friends @rest(path: '/friends/{exportVariables.id}', type: '[User]') {\n        firstName\n        lastName\n      }\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Direct Cache Write with useApolloClient in React\nDESCRIPTION: This snippet demonstrates how to directly write to Apollo Client's cache using the useApolloClient hook in a React component. The FilterLink component updates the visibilityFilter in the cache when clicked.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\nimport React from \"react\";\nimport { useApolloClient } from \"@apollo/client\";\n\nimport Link from \"./Link\";\n\nfunction FilterLink({ filter, children }) {\n  const client = useApolloClient();\n  return (\n    <Link\n      onClick={() => client.writeQuery({\n        query: gql`query GetVisibilityFilter { visibilityFilter }`,\n        data: { visibilityFilter: filter },\n      })}\n    >\n      {children}\n    </Link>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing MockedProvider from Apollo Client - JavaScript\nDESCRIPTION: This code snippet imports the MockedProvider component from the @apollo/client/testing package. MockedProvider enables React component tests to provide custom mocked responses for GraphQL operations, eliminating network calls. To use, ensure @apollo/client is installed as a dependency. Input: none; Output: enables the usage of MockedProvider in subsequent test code.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/testing.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { MockedProvider } from \"@apollo/client/testing\";\n```\n\n----------------------------------------\n\nTITLE: Implementing Cursor-Based Pagination with `read`/`merge` in Apollo Client (TypeScript)\nDESCRIPTION: Provides an example of `merge` and `read` functions using an `afterId` argument for cursor-based pagination on the `tasks` field of the `Agenda` type. The `merge` function uses `readField` to check existing task IDs for deduplication and inserts new items after the specified `afterId`. The `read` function retrieves the page following the `afterId`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Agenda: {\n      fields: {\n        tasks: {\n          merge(existing: any[], incoming: any[], { args, readField }) {\n            const merged = existing ? existing.slice(0) : [];\n            // Obtain a Set of all existing task IDs.\n            const existingIdSet = new Set(\n              merged.map(task => readField(\"id\", task)));\n            // Remove incoming tasks already present in the existing data.\n            incoming = incoming.filter(\n              task => !existingIdSet.has(readField(\"id\", task)));\n            // Find the index of the task just before the incoming page of tasks.\n            const afterIndex = merged.findIndex(\n              task => args.afterId === readField(\"id\", task));\n            if (afterIndex >= 0) {\n              // If we found afterIndex, insert incoming after that index.\n              merged.splice(afterIndex + 1, 0, ...incoming);\n            } else {\n              // Otherwise insert incoming at the end of the existing data.\n              merged.push(...incoming);\n            }\n            return merged;\n          },\n\n          read(existing: any[], { args, readField }) {\n            if (existing) {\n              const afterIndex = existing.findIndex(\n                task => args.afterId === readField(\"id\", task));\n              if (afterIndex >= 0) {\n                const page = existing.slice(\n                  afterIndex + 1,\n                  afterIndex + 1 + args.limit,\n                );\n                if (page && page.length > 0) {\n                  return page;\n                }\n              }\n            }\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Network Status Update in Apollo Client\nDESCRIPTION: This code demonstrates how to enable the `notifyOnNetworkStatusChange` option in Apollo Client, using the `graphql` function.  When set to `true`, it re-renders the component when the network status or network errors change. The default is `false`. Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent, and a GraphQL query definition using `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_31\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: { notifyOnNetworkStatusChange: true },\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Writing data to Apollo Client cache with writeQuery in JavaScript\nDESCRIPTION: Writes data to the Apollo Client's cache in the shape defined by a GraphQL query. Accepts an options object including a required query with the gql template literal, a required data object conforming to the query's structure, optional variables, id specifying the root object in cache, and flags for broadcasting updates and overwriting existing data. Returns a Reference to the written cache object or undefined if the write failed. Typically used to create or modify cached objects immutably.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Create or modify a cached Todo object with id 5\ncache.writeQuery({\n  query: gql`\n    query ReadTodo($id: ID!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  data: {\n    todo: {\n      __typename: 'Todo',\n      id: 5,\n      text: 'Buy grapes 🍇',\n      completed: false\n    },\n  },\n  variables: {\n    id: 5\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Showing Pending UI during React Transition - TypeScript\nDESCRIPTION: This code enhances the previous example by providing visual feedback during the transition. The `useTransition` hook provides an `isPending` boolean, which is used to dim the select dropdown while a new dog's data is being fetched.  Dependencies: `@apollo/client`, `react`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState, Suspense, useTransition } from \"react\";\n\nfunction App() {\n  const [isPending, startTransition] = useTransition();\n  const { data } = useSuspenseQuery(GET_DOGS_QUERY);\n  const [selectedDog, setSelectedDog] = useState(\n    data.dogs[0].id\n  );\n\n  return (\n    <>\n      <select\n        style={{ opacity: isPending ? 0.5 : 1 }}\n        onChange={(e) => {\n          startTransition(() => {\n            setSelectedDog(e.target.value);\n          });\n        }}\n      >\n        {data.dogs.map(({ id, name }) => (\n          <option key={id} value={id}>{name}</option>\n        ))}\n      </select>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Dog id={selectedDog} />\n      </Suspense>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Merge Function for Authors Array\nDESCRIPTION: This code demonstrates a custom `merge` function for the `authors` field, which is an array of non-normalized `Author` objects. It merges incoming `author` objects into an `existing` array based on the author's `name`, using the `readField` and `mergeObjects` helpers to handle potential references within the cache, efficiently merging the authors. It avoids replacing existing arrays. It also demonstrates merging of the fields of author objects.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Book: {\n      fields: {\n        authors: {\n          merge(existing: any[], incoming: any[], { readField, mergeObjects }) {\n            const merged: any[] = existing ? existing.slice(0) : [];\n            const authorNameToIndex: Record<string, number> = Object.create(null);\n            if (existing) {\n              existing.forEach((author, index) => {\n                authorNameToIndex[readField<string>(\"name\", author)] = index;\n              });\n            }\n            incoming.forEach(author => {\n              const name = readField<string>(\"name\", author);\n              const index = authorNameToIndex[name];\n              if (typeof index === \"number\") {\n                // Merge the new author data with the existing author data.\n                merged[index] = mergeObjects(merged[index], author);\n              } else {\n                // First time we've seen this author in this array.\n                authorNameToIndex[name] = merged.length;\n                merged.push(author);\n              }\n            });\n            return merged;\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: SSR with SchemaLink in Apollo Client\nDESCRIPTION: This snippet demonstrates how to use SchemaLink with Apollo Client for server-side rendering (SSR) to avoid network calls. It imports necessary modules, creates an ApolloClient instance with a SchemaLink configured with the provided schema, and sets `ssrMode` to true. The schema should be defined elsewhere.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-schema.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\nimport { SchemaLink } from '@apollo/client/link/schema';\n\nimport schema from './path/to/your/schema';\n\nconst graphqlClient = new ApolloClient({\n  cache: new InMemoryCache(),\n  ssrMode: true,\n  link: new SchemaLink({ schema })\n});\n```\n\n----------------------------------------\n\nTITLE: Subscribing to More with Masked and Unmasked Data in Apollo Client (JavaScript)\nDESCRIPTION: This code demonstrates using Apollo Client's subscribeToMore method from a useQuery result to initiate a subscription. In the updateQuery callback, both the current queryData and the subscriptionData are unmasked. Dependencies: @apollo/client, QUERY, SUBSCRIPTION. Inputs: function call to start subscription; Outputs: access to unmasked data within updateQuery handler for cache updates or UI updates.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_47\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { subscribeToMore } = useQuery(QUERY);\n\nfunction startSubscription() {\n  subscribeToMore({\n    document: SUBSCRIPTION,\n    updateQuery: (queryData, { subscriptionData }) => {\n      // queryData is unmasked\n      // subscriptionData is unmasked\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Toggling Todo Completion Using cache.readFragment & cache.writeFragment - JS\nDESCRIPTION: This code demonstrates how to toggle the completion status of a todo item using `cache.readFragment` and `cache.writeFragment`. The `toggleTodo` resolver reads the current state of the todo from the cache using `cache.readFragment`, toggles the `completed` property, and then updates the cache with the modified todo using `cache.writeFragment`. The cache key (`id`) is constructed using the `TodoItem` type and the todo's ID. Dependencies include ApolloClient and InMemoryCache from '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  resolvers: {\n    Mutation: {\n      toggleTodo: (_, variables, { cache }) => {\n        const id = `TodoItem:${variables.id}`;\n        const fragment = gql`\n          fragment CompleteTodo on TodoItem {\n            completed\n          }\n        `;\n        const todo = cache.readFragment({ fragment, id });\n        const data = { ...todo, completed: !todo.completed };\n\n        cache.writeFragment({ fragment, id, data });\n        return null;\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying keyArgs Argument Array with offsetLimitPagination in JavaScript\nDESCRIPTION: This snippet demonstrates how to provide an array of argument names as the `keyArgs` parameter to the `offsetLimitPagination` helper. This configuration informs Apollo Client which arguments should be used to distinguish between different cached lists for the same field, such as filtering by `type` and `userId`. Setting `keyArgs` correctly ensures the cache stores and merges paginated results only for queries with matching key argument values, preventing data pollution across different query variants.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/offset-based.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nfields {\n  // Results belong to the same list only if both the type\n  // and userId arguments match exactly\n  feed: offsetLimitPagination([\"type\", \"userId\"])\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client with HTTP Connection in JavaScript\nDESCRIPTION: Sets up a basic Apollo Client instance with an HTTP connection to a GraphQL server. Requires specifying the server URL as the uri parameter and creating an in-memory cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/basic-http-networking.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'https://api.example.com',\n  cache: new InMemoryCache()\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating Document Transform with GraphQL Code Generator (TypeScript)\nDESCRIPTION: This configuration snippet demonstrates how to hook an Apollo Client `documentTransform` into the GraphQL Code Generator setup. The `transform` function iterates over the GraphQL documents found and applies the runtime transform logic statically, ensuring the generated TypeScript types accurately reflect the modified GraphQL documents before they are sent to the network.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CodegenConfig } from '@graphql-codegen/cli';\nimport { documentTransform } from './path/to/your/transform';\n\nconst config: CodegenConfig = {\n  schema: 'https://localhost:4000/graphql',\n  documents: ['src/**/*.tsx'],\n  generates: {\n    './src/gql/': {\n      preset: 'client',\n      documentTransforms: [\n        {\n          transform: ({ documents }) => {\n            return documents.map((documentFile) => {\n              documentFile.document = documentTransform\n                .transformDocument(documentFile.document);\n\n              return documentFile;\n            });\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Offset/Limit Pagination with `read`/`merge` in Apollo Client (TypeScript)\nDESCRIPTION: Shows how to define `merge` and `read` functions in `typePolicies` for the `InMemoryCache`. The `merge` function inserts incoming items based on `args.offset` and `args.limit`, while the `read` function retrieves a specific page using the same arguments. This ensures correct cache updates and reads for paginated data on the `tasks` field of the `Agenda` type.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Agenda: {\n      fields: {\n        tasks: {\n          merge(existing: any[], incoming: any[], { args }) {\n            const merged = existing ? existing.slice(0) : [];\n            // Insert the incoming elements in the right places, according to args.\n            const end = args.offset + Math.min(args.limit, incoming.length);\n            for (let i = args.offset; i < end; ++i) {\n              merged[i] = incoming[i - args.offset];\n            }\n            return merged;\n          },\n\n          read(existing: any[], { args }) {\n            // If we read the field before any data has been written to the\n            // cache, this function will return undefined, which correctly\n            // indicates that the field is missing.\n            const page = existing && existing.slice(\n              args.offset,\n              args.offset + args.limit,\n            );\n            // If we ask for a page outside the bounds of the existing array,\n            // page.length will be 0, and we should return undefined instead of\n            // the empty array.\n            if (page && page.length > 0) {\n              return page;\n            }\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Deleting Resources with REST Mutations in GraphQL (Apollo Client, GraphQL)\nDESCRIPTION: This GraphQL mutation illustrates how to trigger a REST DELETE request to remove a post. The @rest directive is used to configure the endpoint, method, and type. The $id variable is interpolated into the REST path. Requires Apollo Client, apollo-link-rest, and a DELETE API endpoint. Input: post id. Output: confirmation of deletion (the NoResponse field).\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_29\n\nLANGUAGE: GraphQL\nCODE:\n```\nmutation DeletePost($id: ID!) {\n  deletePostResponse(id: $id)\n    @rest(type: \"Post\", path: \"/posts/{args.id}\", method: \"DELETE\") {\n    NoResponse\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Pagination Field Policy Function in Apollo Client (TypeScript)\nDESCRIPTION: Illustrates abstracting cursor-based pagination logic into a reusable function (`afterIdLimitPaginatedFieldPolicy`). This function returns an object containing the `merge` and `read` functions (implementation details omitted with `...`), allowing the same pagination strategy to be applied to multiple fields easily within `typePolicies`. The example applies this reusable policy to the `tasks` field of the `Agenda` type.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nfunction afterIdLimitPaginatedFieldPolicy<T>() {\n  return {\n    merge(existing: T[], incoming: T[], { args, readField }): T[] {\n      ...\n    },\n    read(existing: T[], { args, readField }): T[] {\n      ...\n    },\n  };\n}\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Agenda: {\n      fields: {\n        tasks: afterIdLimitPaginatedFieldPolicy<Reference>(),\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Code Splitting with addResolvers - JS\nDESCRIPTION: This snippet illustrates how to use `addResolvers` to implement code splitting for Apollo Client resolvers. It shows how a resolver can be dynamically added to the Apollo Client when a specific component (`MessageCount`) is loaded. This avoids including the resolver code in the initial application bundle, reducing its size. It uses useApolloClient hook to access the client instance. Dependencies include ApolloConsumer, useApolloClient, useQuery and gql from '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from \"react\";\nimport { ApolloConsumer, useApolloClient, useQuery, gql } from \"@apollo/client\";\n\nconst GET_MESSAGE_COUNT = gql`\n  query GetMessageCount {\n    messageCount @client {\n      total\n    }\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    messageCount: (_, args, { cache }) => {\n      // ... calculate and return the number of messages in\n      // the cache ...\n      return {\n        total: 123,\n        __typename: \"MessageCount\",\n      };\n    },\n  },\n};\n\nexport function MessageCount() {\n  const client = useApolloClient();\n  client.addResolvers(resolvers);\n\n  const { loading, data: { messageCount } } = useQuery(GET_MESSAGE_COUNT);\n\n  if (loading) return \"Loading ...\";\n\n  return (\n    <p>\n      Total number of messages: {messageCount.total}\n    </p>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Merging and Reading Cursor-Based Paginated Data with IDs as Cursors in Apollo Client JavaScript\nDESCRIPTION: Defines a type policy in Apollo Client's InMemoryCache to handle paginated data by using unique item IDs as cursors. The merge function appends incoming items at the correct offset found via a cursor, while the read function slices the cached list to return the current page. Uses the readField helper to reliably access 'id' fields from both normalized and non-normalized list items. This strategy is resilient to list mutations and suited for appending new pages, but assumes incoming pages are appended rather than inserted in the middle.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/cursor-based.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: [\"type\"],\n\n          merge(existing, incoming, {\n            args: { cursor },\n            readField,\n          }) {\n            const merged = existing ? existing.slice(0) : [];\n            let offset = offsetFromCursor(merged, cursor, readField);\n            // If we couldn't find the cursor, default to appending to\n            // the end of the list, so we don't lose any data.\n            if (offset < 0) offset = merged.length;\n            // Now that we have a reliable offset, the rest of this logic\n            // is the same as in offsetLimitPagination.\n            for (let i = 0; i < incoming.length; ++i) {\n              merged[offset + i] = incoming[i];\n            }\n            return merged;\n          },\n\n          // If you always want to return the whole list, you can omit\n          // this read function.\n          read(existing, {\n            args: { cursor, limit = existing.length },\n            readField,\n          }) {\n            if (existing) {\n              let offset = offsetFromCursor(existing, cursor, readField);\n              // If we couldn't find the cursor, default to reading the\n              // entire list.\n              if (offset < 0) offset = 0;\n              return existing.slice(offset, offset + limit);\n            }\n          },\n        },\n      },\n    },\n  },\n});\n\nfunction offsetFromCursor(items, cursor, readField) {\n  // Search from the back of the list because the cursor we're\n  // looking for is typically the ID of the last item.\n  for (let i = items.length - 1; i >= 0; --i) {\n    const item = items[i];\n    // Using readField works for both non-normalized objects\n    // (returning item.id) and normalized references (returning\n    // the id field from the referenced entity object), so it's\n    // a good idea to use readField when you're not sure what\n    // kind of elements you're dealing with.\n    if (readField(\"id\", item) === cursor) {\n      // Add one because the cursor identifies the item just\n      // before the first item in the page we care about.\n      return i + 1;\n    }\n  }\n  // Report that the cursor could not be found.\n  return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Client-Side GraphQL Subscription - TypeScript\nDESCRIPTION: This snippet defines the client-side GraphQL subscription query using the `gql` tag. It specifies the `OnCommentAdded` subscription operation, includes a `$postID` variable of type `ID!`, and selects the `id` and `content` fields from the `commentAdded` root field result. Uses `TypedDocumentNode` for type safety with generated types `OnCommentAddedSubscription` and `OnCommentAddedSubscriptionVariables`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst COMMENTS_SUBSCRIPTION: TypedDocumentNode<\n  OnCommentAddedSubscription,\n  OnCommentAddedSubscriptionVariables\n> = gql`\n  subscription OnCommentAdded($postID: ID!) {\n    commentAdded(postID: $postID) {\n      id\n      content\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Defining UpdateDisplayImage Mutation JavaScript\nDESCRIPTION: Defines a GraphQL mutation named `UPDATE_DISPLAY_IMAGE` that updates a specified dog's display image.  This mutation demonstrates how to update existing data and automatically update the Apollo Client cache by modifying a field of an existing object in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/why-apollo.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst UPDATE_DISPLAY_IMAGE = gql`\n  mutation UpdateDisplayImage($id: String!, $displayImage: String!) {\n    updateDisplayImage(id: $id, displayImage: $displayImage) {\n      id\n      displayImage\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Using `subscribeToMore` with Typed `useQuery` Hook for Subscriptions\nDESCRIPTION: Shows how to subscribe to real-time data updates with `subscribeToMore`, using a subscription GraphQL document to keep UI in sync with live data, with type safety ensured.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ...\nconst ROCKET_STOCK_SUBSCRIPTION = gql(/* GraphQL */ `\n  subscription OnRocketStockUpdated {\n    rocketStockAdded {\n      id\n      stock\n    }\n  }\n`);\n\nexport function RocketInventoryList() {\n  const { subscribeToMore, loading, data } = useQuery(\n    GET_ROCKET_INVENTORY,\n    { variables: { year: 2019 } }\n  );\n\n  React.useEffect(() => {\n    subscribeToMore(\n      { document: ROCKET_STOCK_SUBSCRIPTION, variables: { year: 2019 } }\n    );\n  }, [subscribeToMore]);\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Write Query to Cache (writeQuery, JS)\nDESCRIPTION: This snippet demonstrates how to write data directly to the Apollo Client cache using `cache.writeQuery`.  It writes a boolean value to the `isLoggedIn` field of the `IS_LOGGED_IN` query, based on the presence of a `token` in `localStorage`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\ncache.writeQuery({\n  query: IS_LOGGED_IN,\n  data: {\n    isLoggedIn: !!localStorage.getItem(\"token\"),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Releasing Retained Cache Objects for Garbage Collection (Apollo Client JavaScript)\nDESCRIPTION: Calls the release method on InMemoryCache with a specific object ID to remove its retained status, making it eligible for removal during the next garbage collection if unreachable. This enables dynamic cache control depending on the application's data lifecycle.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache.release('my-object-id');\n```\n\n----------------------------------------\n\nTITLE: Mutation Data Masking with useMutation Hook in Apollo Client (JavaScript)\nDESCRIPTION: This snippet shows usage of Apollo Client's useMutation hook in React, demonstrating that mutation result data is masked except in certain update contexts. The mutate function is called and the resulting data object is masked by default. However, data passed to callback functions for update, refetchQueries, and updateQueries is unmasked. Dependencies: @apollo/client, defined MUTATION constant. Input: mutate function execution; Output: masked or unmasked data depending on where data is accessed. Limitation: Masking applies only to places designed for read-access, not cache updates.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_43\n\nLANGUAGE: JavaScript\nCODE:\n```\n// data is masked\nconst [mutate, { data }] = useMutation(MUTATION, {\n  onCompleted: (data) => {\n    // data is masked\n  },\n  update: (cache, { data }) => {\n    // data is unmasked\n  },\n  refetchQueries: ({ data }) => {\n    // data is unmasked\n  },\n  updateQueries: {\n    ExampleQuery: (previous, { mutationResult }) => {\n      // mutationResult is unmasked\n    }\n  }\n});\n\nasync function runMutation() {\n  const { data } = await mutate()\n\n  // data is masked\n}\n```\n\n----------------------------------------\n\nTITLE: Using config.skip for conditional data injection\nDESCRIPTION: Illustrates how to conditionally skip the execution of the GraphQL query based on component props or other logic. When skip is true, the component behaves as if graphql() is not applied, preventing data fetching.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  skip: props => !!props.skip,\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Defining the Feed Query with gql in React\nDESCRIPTION: This code snippet defines a GraphQL query using gql for fetching a feed with offset and limit parameters. It demonstrates integrating this query into a React component with useQuery, extracting loading state, data, and fetchMore function. This setup enables incremental loading of feed items via user actions like scrolling or button clicks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/core-api.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst FEED_QUERY = gql`\n  query Feed($offset: Int, $limit: Int) {\n    feed(offset: $offset, limit: $limit) {\n      id\n      # ...\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Using MockedProvider with Custom ApolloClient Cache and Resolvers for Local State Testing in JSX\nDESCRIPTION: Explains the internal ApolloClient instance created by MockedProvider and emphasizes the need to explicitly pass configured cache instances and resolvers when testing local state with Apollo Client 2.x or 3.x. It shows how to pass these props to MockedProvider to enable correct handling of local-only fields, type policies, or local resolvers in tests. This is essential because MockedProvider's default ApolloClient does not otherwise know how to resolve client-side fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\n<MockedProvider mocks={mocks} resolvers={resolvers} ...\n\n<MockedProvider mocks={mocks} cache={cache} ...\n\n<MockedProvider mocks={mocks} cache={cache} resolvers={resolvers} ...\n```\n\n----------------------------------------\n\nTITLE: Applying Masked Type Helper to Queries in Apollo Client\nDESCRIPTION: Illustrates how to use the `Masked` helper type from `@apollo/client` with `TypedDocumentNode` and the `useQuery` hook. This explicitly tells Apollo Client to treat the operation's type according to the masked type definition generated by Codegen, useful for per-operation opt-in or when the global mode is `unmask`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_56\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Masked, TypedDocumentNode } from \"@apollo/client\";\n\n// With TypedDocumentNode\nconst QUERY: TypedDocumentNode<Masked<QueryType>, VarsType> = gql`\n  # ...\n`;\n\n// with generic arguments\nconst { data } = useQuery<Masked<QueryType>, VarsType>(QUERY)\n```\n\n----------------------------------------\n\nTITLE: GraphQL Data Fetching for Components with Granular Queries\nDESCRIPTION: This example illustrates a complex, monolithic query fetching multiple collections and nested data, which is discouraged. The guidance suggests splitting such queries into smaller, component-specific queries to improve cache efficiency and performance. Fragment usage for distributing query structure and pagination for large lists are recommended best practices.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/operation-best-practices.mdx#_snippet_3\n\nLANGUAGE: GraphQL\nCODE:\n```\n# Not recommended ❌\nquery GetGlobalStatus {\n  stores {\n    id\n    name\n    address {\n      street\n      city\n    }\n    employees {\n      id\n    }\n    manager {\n      id\n    }\n  }\n  products {\n    id\n    name\n    price {\n      amount\n      currency\n    }\n  }\n  employees {\n    id\n    role\n    name {\n      firstName\n      lastName\n    }\n    store {\n      id\n    }\n  }\n  offers {\n    id\n    products {\n      id\n    }\n    discount {\n      discountType\n      amount\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Nested GraphQL Query Response JSON\nDESCRIPTION: This JSON snippet shows a sample response from a GraphQL query. It illustrates how nested objects, like a `Person` object containing a `Planet` object in its `homeworld` field, are structured in the raw response received by Apollo Client before caching and normalization.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/overview.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"person\": {\n      \"__typename\": \"Person\",\n      \"id\": \"cGVvcGxlOjE=\",\n      \"name\": \"Luke Skywalker\",\n      \"homeworld\": {\n        \"__typename\": \"Planet\",\n        \"id\": \"cGxhbmV0czox\",\n        \"name\": \"Tatooine\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Dynamic Headers and Accessing Responses via ApolloLink Context in JavaScript\nDESCRIPTION: Illustrates creating a custom `ApolloLink` (`authRestLink`) that uses `operation.setContext` to add dynamic headers (e.g., reading a token from `localStorage`) before the request is forwarded to `RestLink`. It also shows how to access the `restResponses` from the context after the operation to retrieve response headers (e.g., updating the stored token). Requires `ApolloLink`, `ApolloClient`, `InMemoryCache`, and `RestLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_21\n\nLANGUAGE: js\nCODE:\n```\nconst authRestLink = new ApolloLink((operation, forward) => {\n  operation.setContext(({headers}) => {\n    const token = localStorage.getItem(\"token\");\n    return {\n      headers: {\n        ...headers,\n        Accept: \"application/json\",\n        Authorization: token\n      }\n    };\n  });\n  return forward(operation).map(result => {\n    const { restResponses } = operation.getContext();\n    const authTokenResponse = restResponses.find(res => res.headers.has(\"Authorization\"));\n    // You might also filter on res.url to find the response of a specific API call\n    if (authTokenResponse) {\n      localStorage.setItem(\"token\", authTokenResponse.headers.get(\"Authorization\"));\n    }\n    return result;\n  });\n});\n\nconst restLink = new RestLink({ uri: \"uri\" });\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: ApolloLink.from([authRestLink, restLink])\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Refetch/FetchMore in Deep Components with useQueryRefHandlers and Apollo Client (TypeScript)\nDESCRIPTION: This example demonstrates using Apollo Client's `useBackgroundQuery` to initialize a suspendable query, and leveraging `useQueryRefHandlers` in a nested component to access refetch logic. The Dog component receives a `queryRef` prop, extracts `refetch`, and uses React transitions for smooth UI updates. Dependencies include `@apollo/client` hooks and React. Expected input is a query reference; output includes data rendering and refetch capability deep in the component tree without redundant suspends. This pattern is recommended when handler methods must be passed through or accessed in distant descendants.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction App() {\n  const [queryRef] = useBackgroundQuery(GET_BREEDS_QUERY);\n\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog id=\"3\" queryRef={queryRef} />\n    </Suspense>\n  );\n}\n\nfunction Dog({ id, queryRef }: DogProps) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { id },\n  });\n  const [isPending, startTransition] = useTransition();\n  const { refetch } = useQueryRefHandlers(queryRef);\n\n  function handleRefetch() {\n    startTransition(() => {\n      refetch();\n    });\n  };\n\n  return (\n    <>\n      Name: {data.dog.name}\n      <Suspense fallback={<div>Loading breeds...</div>}>\n        <Breeds queryRef={queryRef} isPending={isPending} />\n      </Suspense>\n      <button onClick={handleRefetch}>Refetch!</button>\n    </>\n  );\n}\n\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: Defining a local resolver for toggling a Todo's completed status using Apollo Client\nDESCRIPTION: This code demonstrates how to set up a local mutation resolver in Apollo Client to toggle the 'completed' boolean of a Todo item. It utilizes cache.modify and cache.identify to update cache fields efficiently, and the resolver is integrated into an Apollo Client instance.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  resolvers: {\n    Mutation: {\n      toggleTodo: (_root, variables, { cache }) => {\n        cache.modify({\n          id: cache.identify({\n            __typename: 'TodoItem',\n            id: variables.id,\n          }),\n          fields: {\n            completed: value => !value,\n          },\n        });\n        return null;\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using SchemaLink for Local GraphQL Execution in SSR\nDESCRIPTION: Server-side initialization of Apollo Client using SchemaLink instead of HttpLink. This approach avoids network requests by executing GraphQL operations directly against the schema when the GraphQL endpoint is on the same server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client'\nimport { SchemaLink } from '@apollo/client/link/schema';\n\n// ...\n\nconst client = new ApolloClient({\n  ssrMode: true,\n  // Instead of \"createHttpLink\" use SchemaLink here\n  link: new SchemaLink({ schema }),\n  cache: new InMemoryCache(),\n});\n```\n\n----------------------------------------\n\nTITLE: Using keyArgs with cache type policies to handle argument-based cache separation\nDESCRIPTION: Sets keyArgs for the 'feed' field in the Query type, allowing cache separation based on argument values like category. This simplifies cache configuration by delegating data partitioning to Apollo Client without custom read/merge functions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: [\"category\"],\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Item List Using React and Apollo Client\nDESCRIPTION: This React component `List` uses the `useQuery` hook from Apollo Client to fetch and display a list of items. It renders a list of `Item` components, passing each item's data as a prop. Requires an Apollo Client setup and a configured GraphQL server and an available `ItemFragment` definition.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_22\n\nLANGUAGE: jsx\nCODE:\n```\nfunction List() {\n  const { loading, data } = useQuery(listQuery);\n\n  return (\n    <ol>\n      {data?.list.map(item => (\n        <Item key={item.id} item={item}/>\n      ))}\n    </ol>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Core Apollo Client without React\nDESCRIPTION: Illustrates how to import the core `ApolloClient` class from the `@apollo/client/core` entry point. This is useful when using Apollo Client with view layers other than React (e.g., Vue, Angular, Svelte) or in non-UI environments, ensuring React-specific code is not bundled.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient } from '@apollo/client/core';\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client InMemoryCache with possibleTypes and typePolicies in JSX\nDESCRIPTION: Defines an Apollo Client cache configuration specifying possibleTypes to declare Dog as a supertype of ShibaInu, and typePolicies to customize keyFields for the Dog type using 'name' and 'breed' instead of default 'id'. Also includes a GraphQL fragment ShibaFragment and query GET_DOG_QUERY to fetch dog data with conditional ShibaInu-specific fields. This setup ensures correct cache behavior when testing with MockedProvider, requiring matching cache configurations to prevent inconsistencies.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_13\n\nLANGUAGE: jsx\nCODE:\n```\n// \"Dog\" supertype can be of type \"ShibaInu\"\nconst ShibaFragment = gql`\n  fragment ShibaInuFields on Dog {\n    ... on ShibaInu {\n      tail {\n        isCurly\n      }\n    }\n  }\n`;\n\nexport const GET_DOG_QUERY = gql`\n  query GetDog($name: String) {\n    dog(name: $name) {\n      id\n      name\n      breed\n\n      ...ShibaInuFields\n    }\n  }\n\n  ${ShibaFragment}\n`;\n\nexport const cache = new ApolloClient({\n  cache: new InMemoryCache({\n    possibleTypes: {\n      Dog: [\"ShibaInu\"],\n    },\n    // suppose you want you key fields for \"Dog\" to not be simply \"id\"\n    typePolicies: {\n      keyFields: {\n        Dog: [\"name\", \"breed\"],\n      },\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring TypePolicies with Custom keyFields\nDESCRIPTION: Example demonstrating how to customize cache ID generation using typePolicies with keyFields. Shows various scenarios including single fields, field combinations, nested fields, singletons, disabling normalization, and using functions to dynamically determine keyFields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-configuration.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Product: {\n      // In an inventory management system, products might be identified\n      // by their UPC.\n      keyFields: [\"upc\"],\n    },\n    Person: {\n      // In a user account system, the combination of a person's name AND email\n      // address might uniquely identify them.\n      keyFields: [\"name\", \"email\"],\n    },\n    Book: {\n      // If one of the keyFields is an object with fields of its own, you can\n      // include those nested keyFields by using a nested array of strings:\n      keyFields: [\"title\", \"author\", [\"name\"]],\n    },\n    AllProducts: {\n      // Singleton types that have no identifying field can use an empty\n      // array for their keyFields.\n      keyFields: [],\n    },\n    Store: {\n      // If you need to disable normalization, set the keyFields to false\n      // and the object will be embedded in the parent\n      keyFields: false\n    },\n    Location: {\n      // You can also use a function to determine any of the values above.\n      // The first argument is the reference to the record to be written, and the second is the runtime context\n      keyFields: (location, context) => {\n        if (context.readField(\"state\")) {\n          return [\"city\", \"state\", \"country\"]\n        } else {\n          return [\"city\", \"country\"]\n        }\n      }\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Request Body Structure with bodyBuilder in REST Mutation (Apollo Client, GraphQL)\nDESCRIPTION: This GraphQL mutation leverages the bodyBuilder option of the @rest directive to structure the POST body using a custom encoder or transformation function. The $encryptor variable encapsulates any necessary transformation logic before sending the request body. Dependencies: Apollo Client, apollo-link-rest, suitable encryptor function in context. Input includes input data and an encryptor function; output is a published post with id and title.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_26\n\nLANGUAGE: GraphQL\nCODE:\n```\nmutation EncryptedPost(\n  $input: PublishablePostInput!\n  $encryptor: any\n) {\n  publishedPost: publish(input: $input)\n    @rest(\n      type: \"Post\",\n      path: \"/posts/new\",\n      method: \"POST\",\n      bodyBuilder: $encryptor\n    ) {\n    id\n    title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending offsetLimitPagination with a Custom Paginated Read Function in JavaScript\nDESCRIPTION: This code configures Apollo Client's cache to customize the `read` function for offset-based pagination, extending the default field policy generated by `offsetLimitPagination()`. The custom `read` function can implement logic to return only the requested subset of items from the cached data based on offset and limit arguments. This approach enables more precise control over how paginated data is read from the cache, useful for read-time pagination strategies.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/offset-based.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { InMemoryCache } from \"@apollo/client\";\nimport { offsetLimitPagination } from \"@apollo/client/utilities\";\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          ...offsetLimitPagination(),\n          read(existing, { args }) {\n            // Implement here\n          }\n        }\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding Default useMutation Variables with the Mutate Function - JavaScript\nDESCRIPTION: This snippet shows how to pass an options object (including variables) directly to the mutate function returned by useMutation, enabling dynamic or user-supplied values to override any predefined defaults. In this example, input.value (referenced from the DOM) is supplied as the value of the type GraphQL variable. This technique is useful for user-driven mutations, such as those triggered by form input.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\naddTodo({\n  variables: {\n    type: input.value,\n  },\n});\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client with Authentication Link and DefaultContext in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to configure an ApolloClient instance with an HTTP link and an authentication context link using @apollo/client's setContext. It shows how to attach authorization headers dynamically based on a token, and how to update the client's defaultContext property to change the token at runtime without recreating the client or using global variables. Dependencies include @apollo/client and the context link utility. The input is a new token string passed to onNewToken, and the output is updated defaultContext used for future requests. This pattern enables dynamic authentication handling in Apollo Client applications.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, createHttpLink, InMemoryCache } from \"@apollo/client\";\nimport { setContext } from \"@apollo/client/link/context\";\n\nconst httpLink = createHttpLink({\n  uri: \"/graphql\",\n});\n\nconst authLink = setContext((_, { headers, token }) => {\n  return {\n    headers: {\n      ...headers,\n      authorization: token ? `Bearer ${token}` : \"\",\n    },\n  };\n});\n\nconst client = new ApolloClient({\n  link: authLink.concat(httpLink),\n  cache: new InMemoryCache(),\n});\n\n// somewhere else in your application\nfunction onNewToken(newToken) {\n  // token can now be changed for future requests without need for a global\n  // variable, scoped ref or recreating the client\n  client.defaultContext.token = newToken;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a DocumentTransform with custom cache key for dynamic runtime conditions\nDESCRIPTION: This snippet demonstrates how to instantiate a DocumentTransform with a custom getCacheKey() function to handle cases where transformation depends on external runtime conditions, such as network status. Including the document in the cache key ensures each unique document is transformed appropriately when conditions change, preventing incorrect cache hits.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst documentTransform = new DocumentTransform(\n  (document) => {\n    if (window.navigator.onLine) {\n      // Transform the document when the user is online\n    } else {\n      // Transform the document when the user is offline\n    }\n  },\n  {\n    getCacheKey: (document) => [document, window.navigator.onLine]\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring prop name with config.name to avoid collisions\nDESCRIPTION: Explains how to specify a custom prop name for the React component to receive GraphQL data or mutation functions, useful when multiple queries or mutations are used on the same component to prevent prop name conflicts.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default compose(\n  graphql(gql`mutation CreateTodoMutation (...) { ... }`, { name: 'createTodo' }),\n  graphql(gql`mutation UpdateTodoMutation (...) { ... }`, { name: 'updateTodo' }),\n  graphql(gql`mutation DeleteTodoMutation (...) { ... }`, { name: 'deleteTodo' }),\n)(MyComponent);\n\nfunction MyComponent(props) {\n  // Instead of the default prop name, `mutate`,\n  // we have three different prop names.\n  console.log(props.createTodo);\n  console.log(props.updateTodo);\n  console.log(props.deleteTodo);\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Credentials in Apollo Client HTTP Requests\nDESCRIPTION: Demonstrates how to include user credentials (like cookies or basic auth) in Apollo Client HTTP requests. This example enables sending cookies for cross-origin requests by setting the credentials parameter to 'include'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/basic-http-networking.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'https://api.example.com',\n  cache: new InMemoryCache(),\n  // Enable sending cookies over cross-origin requests\n  credentials: 'include'\n});\n```\n\n----------------------------------------\n\nTITLE: Using Fragments in a @nonreactive Context (JSX)\nDESCRIPTION: Shows a React `Trail` component (JSX) that uses the `useFragment` hook to read data defined in `TrailFragment` from the cache, identified by `id`. Because the parent `App` component applied `@nonreactive` to the fragment spread in its query, updates to the trail's status (triggered via `useMutation`) only rerender the specific `Trail` component instance, not the parent `App` component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst Trail = ({ id }) => {\n  const [updateTrail] = useMutation(UPDATE_TRAIL);\n  const { data } = useFragment({\n    fragment: TrailFragment,\n    from: {\n      __typename: \"Trail\",\n      id,\n    },\n  });\n  return (\n    <li key={id}>\n      {data.name} - {data.status}\n      <input\n        checked={data.status === \"OPEN\" ? true : false}\n        type=\"checkbox\"\n        onChange={(e) => {\n          updateTrail({\n            variables: {\n              trailId: id,\n              status: e.target.checked ? \"OPEN\" : \"CLOSED\",\n            },\n          });\n        }}\n      />\n    </li>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Reset Apollo Client Cache with resetStore for User Logout\nDESCRIPTION: Illustrates how to reset the Apollo Client cache upon user logout by invoking client.resetStore(), which also refetches active queries. It retrieves the Apollo client via useQuery hook and provides a button to trigger cache reset. Dependencies include '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useQuery } from '@apollo/client';\nfunction Profile() {\n    const { data, client } = useQuery(PROFILE_QUERY);\n    return (\n      <Fragment>\n        <p>Current user: {data?.currentUser}</p>\n        <button onClick={async ()=>client.resetStore()}>\n            Log out\n        </button>\n      </Fragment>\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Bailing Out of Optimistic UI Update with Apollo Client in TSX\nDESCRIPTION: Demonstrates how to conditionally disable optimistic UI updates in Apollo Client mutations by passing a function to the optimisticResponse option. The function evaluates mutation variables and returns the IGNORE sentinel to skip optimistic updates under specified conditions (e.g., when comment content equals \"foo\"). This avoids prematurely updating the UI when an optimistic response is not appropriate. Inputs include mutation variables and the IGNORE sentinel. Output is either an optimistic response object or IGNORE.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/optimistic-ui.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst UPDATE_COMMENT = gql`\n  mutation UpdateComment($commentId: ID!, $commentContent: String!) {\n    updateComment(commentId: $commentId, content: $commentContent) {\n      id\n      __typename\n      content\n    }\n  }\n`;\n\nfunction CommentPageWithData() {\n  const [mutate] = useMutation(UPDATE_COMMENT);\n\n  return (\n    <Comment\n      updateComment={({ commentId, commentContent }) =>\n        mutate({\n          variables: { commentId, commentContent },\n          optimisticResponse: (vars, { IGNORE }) => {\n            if (commentContent === \"foo\") {\n              // conditionally bail out of optimistic updates\n              return IGNORE;\n            }\n            return {\n              updateComment: {\n                id: commentId,\n                __typename: \"Comment\",\n                content: commentContent\n              }\n            }\n          },\n        })\n      }\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying a Cached Field with cache.modify in Apollo Client (JavaScript)\nDESCRIPTION: Illustrates using `cache.modify` to directly change the value of a specific field within a cached object. It requires the object's cache ID (obtained via `cache.identify`) and a map of modifier functions keyed by field names. The modifier function receives the current field value and returns the new value. This example converts the `name` field to uppercase.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\ncache.modify({\n  id: cache.identify(myObject),\n  fields: {\n    name(cachedName) {\n      return cachedName.toUpperCase();\n    },\n  },\n  /* broadcast: false // Include this to prevent automatic query refresh */\n});\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Object Representation for Apollo Cache Interaction\nDESCRIPTION: Example of a standard JavaScript object representing a GraphQL entity (`Book`) intended for interaction with the Apollo cache. It includes the mandatory `__typename` field and relevant data fields, including the field used for the custom cache ID (`isbn`). This object structure is often used as input for methods like `cache.identify` or `cache.writeFragment`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_16\n\nLANGUAGE: js\nCODE:\n```\nconst invisibleManBook = {\n  __typename: 'Book',\n  isbn: '9780679601395', // The key field for this type's cache ID\n  title: 'Invisible Man',\n  author: {\n    __typename: 'Author',\n    name: 'Ralph Ellison',\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Testing the jscodeshift Transform\nDESCRIPTION: Provides commands to install necessary dependencies (`npm install`) and then run the `imports.js` jscodeshift transform on example JS, TS, and TSX files located in the `examples` directory. This allows users to test the transform and preview its effects within a checkout of the Apollo Client repository.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/scripts/codemods/ac2-to-ac3/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nnpm install\nnpx jscodeshift -t imports.js --extensions js examples\nnpx jscodeshift -t imports.js --extensions ts --parser ts examples\nnpx jscodeshift -t imports.js --extensions tsx --parser tsx examples\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for Example\nDESCRIPTION: Defines the GraphQL schema including types `Book`, `Author`, and `Query` for demonstration purposes. This schema is used to illustrate how Apollo Client handles and merges data in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\ntype Book {\n  id: ID!\n  title: String!\n  author: Author!\n}\n\ntype Author { # Has no key fields\n  name: String!\n  dateOfBirth: String!\n}\n\ntype Query {\n  favoriteBook: Book!\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring keyArgs in Apollo Client\nDESCRIPTION: Demonstrates how to configure the `keyArgs` property in an Apollo Client `InMemoryCache` field policy. This example specifies that only the `category` argument should be used to generate the cache key for the `Query.feed` field. This allows the cache to merge results for different `offset` and `limit` values within the same category.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: [\"category\"],\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Reusable Mock Response with Limited Usage Count in JSX\nDESCRIPTION: This snippet demonstrates how to define a mock response with a maxUsageCount of 2 to allow the same mocked response to be used twice before being removed from the mocks array. This enables tests requiring repeated query executions with consistent responses.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { GET_DOG_QUERY } from \"./dog\";\n\nconst mocks = [\n  {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: {\n        name: \"Buck\"\n      }\n    },\n    result: {\n      data: {\n        dog: { __typename: \"Dog\", id: \"1\", name: \"Buck\", breed: \"bulldog\" }\n      }\n    },\n    maxUsageCount: 2, // The mock can be used twice before it's removed, default is 1\n  }\n];\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client with SSR Force Fetch Delay\nDESCRIPTION: Client-side initialization of Apollo Client with a delay for force-fetching queries. This approach allows even queries with network-only or cache-and-network fetch policies to initially use only the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new ApolloClient({\n  cache: new InMemoryCache().restore(window.__APOLLO_STATE__),\n  link,\n  ssrForceFetchDelay: 100, // in milliseconds\n});\n```\n\n----------------------------------------\n\nTITLE: Combining refetchQueries with onQueryUpdated in Apollo Client\nDESCRIPTION: Demonstrates how to combine refetchQueries with onQueryUpdated to ensure specific queries are included in the onQueryUpdated callback, guaranteeing they can be considered for refetching.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\naddTodo({\n  variables: { type: input.value },\n  update(cache, result) {\n    // Update the cache as an approximation of server-side mutation effects.\n  },\n  // Force ReallyImportantQuery to be passed to onQueryUpdated.\n  refetchQueries: [\"ReallyImportantQuery\"],\n  onQueryUpdated(observableQuery) {\n    // If ReallyImportantQuery is active, it will be passed to onQueryUpdated.\n    // If no query with that name is active, a warning will be logged.\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Local-Only Field with Read Function using Local Storage - Apollo Client TypeScript\nDESCRIPTION: This code adds a 'userId' field to the Person type in Apollo Client's cache with a read function that pulls its value from the browser's localStorage. The field exists locally only and does not require schema definition; queries must use the @client directive for Apollo Client to resolve it from cache. Inputs: none. Outputs: string value from localStorage. Limitation: browser environment with localStorage is required.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Person: {\n      fields: {\n        userId() {\n          return localStorage.getItem(\"loggedInUserId\");\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Refetching a Specific Query by Name Using Apollo Client in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the client.refetchQueries method of Apollo Client to refetch a specific query by its operation name. The include option is set to an array containing the desired query name. Requires an instance of ApolloClient and assumes the query has been registered. Input: query name string. Output: Promise resolving when refetch is complete. No additional dependencies are needed beyond Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  include: [\"SomeQueryName\"],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Local Resolver Function\nDESCRIPTION: Details the implementation of a local resolver function ('isInCart') for the 'Launch' type. It takes the parent object ('launch'), ignores arguments ('_args'), and uses the 'cache' from the context to read local state and determine if the launch ID is in the cart.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n  resolvers: {\n    Launch: {\n      isInCart: (launch, _args, { cache }) => {\n        const { cartItems } = cache.readQuery({ query: GET_CART_ITEMS });\n        return cartItems.includes(launch.id);\n      },\n    },\n  },\n```\n\n----------------------------------------\n\nTITLE: Reshaping Operation Result with props Function in graphql HOC (TypeScript)\nDESCRIPTION: Shows how to use the props function inside the graphql wrapper to manually reshape or massage the data returned by the GraphQL operation before passing it as props to the wrapped component. Ensures the props and options functions are typed for full type safety, enabling strict type checking of the data structure passed down.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_12\n\nLANGUAGE: TSX\nCODE:\n```\nimport React from \"react\";\nimport { graphql, ChildDataProps } from \"@apollo/react-hoc\";\n\nimport { gql, GetCharacterQuery, GetCharacterQueryVariables } from '../src/gql';\n\nconst HERO_QUERY = gql(/* GraphQL */ `\n  query GetCharacter($episode: Episode!) {\n    hero(episode: $episode) {\n      name\n      id\n      friends {\n        name\n        id\n        appearsIn\n      }\n    }\n  }\n`);\n\n\ntype ChildProps = ChildDataProps<GetCharacterQueryVariables, GetCharacterQuery, GetCharacterQueryVariables>;\n\nconst withCharacter = graphql<\n  GetCharacterQueryVariables,\n  GetCharacterQuery,\n  GetCharacterQueryVariables,\n  ChildProps\n>(HERO_QUERY, {\n  options: ({ episode }) => ({\n    variables: { episode }\n  }),\n  props: ({ data }) => ({ ...data }) // highlight-line\n});\n\nexport default withCharacter(({ loading, hero, error }) => {\n  if (loading) return <div>Loading</div>;\n  if (error) return <h1>ERROR</h1>;\n  return ...// actual component with data;\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client with Local Resolvers (Example 1)\nDESCRIPTION: Configures Apollo Client to handle local state. It defines a GraphQL query for local data (@client), initializes the cache, writes initial data, and sets up a resolver for a Launch type field ('isInCart') that reads from the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, gql } from '@apollo/client';\n\nconst GET_CART_ITEMS = gql`\n  query GetCartItems {\n    cartItems @client\n  }\n`;\n\nconst cache = new InMemoryCache();\ncache.writeQuery({\n  query: GET_CART_ITEMS,\n  data: {\n    cartItems: [],\n  },\n});\n\nconst client = new ApolloClient({\n  cache,\n  link: new HttpLink({\n    uri: 'http://localhost:4000/graphql',\n  }),\n  resolvers: {\n    Launch: {\n      isInCart: (launch, _args, { cache }) => {\n        const { cartItems } = cache.readQuery({ query: GET_CART_ITEMS });\n        return cartItems.includes(launch.id);\n      },\n    },\n  },\n});\n\nconst GET_LAUNCH_DETAILS = gql`\n  query LaunchDetails($launchId: ID!) {\n    launch(id: $launchId) {\n      isInCart @client\n      site\n      rocket {\n        type\n      }\n    }\n  }\n`;\n\n// ... run the query using client.query, a <Query /> component, etc.\n```\n\n----------------------------------------\n\nTITLE: Illustrating FragmentType Preventing Missing Fragment Spreads\nDESCRIPTION: This example demonstrates how using `FragmentType` for a component prop ensures that the required fragment spread (`...PostDetailsFragment`) is included in the parent query. TypeScript correctly issues an error if the fragment spread is omitted, even if the parent query selects the same fields, reinforcing correct query composition patterns.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_60\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst GET_POSTS = gql`\n  query GetPosts {\n    posts {\n      id\n      title\n      shortDescription\n    }\n  }\n`;\n\nexport default function Posts() {\n  // ...\n\n  return (\n    <div>\n      {allPosts.map((post) => (\n        <PostDetails key={post.id} post={post} />\n        // ❌ Type '{ __typename: \"Post\"; id: string; title: string; shortDescription: string; }' has no properties in common with type '{ \" $fragmentRefs\"?: { PostDetailsFragment: PostDetailsFragment; } | undefined; }'.\n      ))}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying a reactive variable with new data in JavaScript\nDESCRIPTION: Illustrates how to update the reactive variable's value by calling the function with a new array. It also emphasizes avoiding in-place mutations and instead passing a new array copy to trigger reactive updates.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/reactive-variables.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cartItemsVar = makeVar([]);\nconst cartItemIds = [100, 101, 102];\n\ncartItemsVar(cartItemIds);\n\n// Output: [100, 101, 102]\nconsole.log(cartItemsVar());\n\n// Add new item without mutating original array\ncartItemsVar([...cartItemIds, 456]);\n\n// Output: [100, 101, 102, 456]\nconsole.log(cartItemsVar());\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client for Automatic Persisted Queries (APQ) (javascript)\nDESCRIPTION: Shows how to set up ApolloClient for APQ by importing dependencies, configuring a SHA-256 hashing function (e.g., from crypto-hash), and concatenating createPersistedQueryLink with HttpLink. This approach relies on sending operation hashes instead of full query strings, resulting in lower bandwidth use but does not provide safelisting security.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { HttpLink, InMemoryCache, ApolloClient } from \"@apollo/client\";\nimport { createPersistedQueryLink } from \"@apollo/client/link/persisted-queries\";\nimport { sha256 } from 'crypto-hash';\n\nconst httpLink = new HttpLink({ uri: \"/graphql\" });\nconst persistedQueriesLink = createPersistedQueryLink({ sha256 });\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: persistedQueriesLink.concat(httpLink),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling access to wrapped component instance with config.withRef\nDESCRIPTION: Demonstrates how to enable access to the underlying component instance by setting withRef: true, allowing parent components to call methods or access properties on the wrapped component via getWrappedInstance().\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass MyComponent extends Component {\n  saySomething() {\n    console.log('Hello, world!');\n  }\n\n  render() {\n    // ...\n  }\n}\n\nconst MyGraphQLComponent = graphql(gql`query MyQuery { ... }`, { withRef: true })(MyComponent);\n\nclass MyContainerComponent extends Component {\n  render() {\n    return (\n      <MyGraphQLComponent\n        ref={component => {\n          const wrappedInstance = component.getWrappedInstance();\n          assert(wrappedInstance instanceof MyComponent);\n          // Call methods on the instance.\n          wrappedInstance.saySomething();\n        }}\n      />\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamically Modifying URI Endpoint Query Parameters with Apollo Client HttpLink in JavaScript\nDESCRIPTION: This snippet illustrates how to implement a custom fetch function that alters the request URI by appending a query parameter derived from the GraphQL operation name. It parses the GraphQL operation name from the JSON body in fetch options and appends it to the URI before making the fetch call. The modified fetch function is passed to HttpLink to enable operation-specific endpoint customization. Inputs are the request URI and options containing the GraphQL request body; output is the Promise returned by fetch with the adjusted URI.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-http.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst customFetch = (uri, options) => {\n  const { operationName } = JSON.parse(options.body);\n  return fetch(`${uri}/graph/graphql?opname=${operationName}`, options);\n};\n\nconst link = new HttpLink({ fetch: customFetch });\n```\n\n----------------------------------------\n\nTITLE: Merging Non-normalized Nested Objects in Cached Fields - Apollo Client TypeScript\nDESCRIPTION: This code provides a merge function for the 'author' field of 'Book', where the author is a nested non-normalized object. The function uses the provided 'mergeObjects' helper for deep merging. Dependency: Apollo Client, and the 'mergeObjects' utility within merge context. Inputs: 'existing' and 'incoming' objects representing authors. Outputs: merged author object. Limitation: only applies to non-normalized, nested objects within a normalized parent.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Book: {\n      fields: {\n        author: { // Non-normalized Author object within Book\n          merge(existing, incoming, { mergeObjects }) {\n            return mergeObjects(existing, incoming);\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing ownProps and lastProps within config.props\nDESCRIPTION: This code demonstrates how to use the second argument for lastProps and access ownProps to customize the props passed to the component, enabling more complex prop derivation based on previous or external props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  props: ({ data: { liveImage } }, lastProps) => ({\n    image: liveImage,\n    lastImage: lastProps.data.liveImage,\n  }),\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Migrating QueryReference to QueryRef in TypeScript\nDESCRIPTION: This diff shows how to migrate from the deprecated `QueryReference` type to the new `QueryRef` type in Apollo Client, as mentioned in PR #11824. The migration involves updating import statements and type annotations. This change restricts the API of `QueryRef` compared to `QueryReference`, notably affecting access to `toPromise`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n-import { QueryReference } from '@apollo/client'\n+import { QueryRef } from '@apollo/client'\n\n- function Component({ queryRef }: { queryRef: QueryReference<TData> }) {\n+ function Component({ queryRef }: { queryRef: QueryRef<TData> }) {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Apollo Client @client and @export for Variable Passing in JavaScript\nDESCRIPTION: Shows how to fetch a top-level local field (`currentAuthorId`) using `@client`, export its value as a variable (`authorId`) using `@export(as: \"authorId\")`, and use that variable in another field (`postCount`) within the same GraphQL query. Requires setting up Apollo Client, defining the query, and pre-populating the cache using `cache.writeQuery`. Dependencies include `@apollo/client`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, gql } from '@apollo/client';\n\nconst query = gql`\n  query CurrentAuthorPostCount($authorId: Int!) {\n    currentAuthorId @client @export(as: \"authorId\")\n    postCount(authorId: $authorId)\n  }\n`;\n\nconst cache = new InMemoryCache();\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: 'http://localhost:4000/graphql' }),\n  cache,\n  resolvers: {},\n});\n\ncache.writeQuery({\n  query: gql`query GetCurrentAuthorId { currentAuthorId }`,\n  data: {\n    currentAuthorId: 12345,\n  },\n});\n\n// ... run the query using client.query, the <Query /> component, etc.\n```\n\n----------------------------------------\n\nTITLE: Querying for Current User and Profile Fragment (GraphQL)\nDESCRIPTION: This GraphQL document defines a GetCurrentUser query and an associated ProfileFragment. The query selects id and spreads ProfileFragment (name, age) for the currentUser. This sets up fragment masking behavior based on codegen config. Input: GraphQL query and fragment definition; Output: currentUser data with possibility of masking/unmasking in the resulting types depending on client setup.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_50\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery GetCurrentUser {\n  currentUser {\n    id\n    ...ProfileFragment\n  }\n}\n\nfragment ProfileFragment on User {\n  name\n  age\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a custom Apollo Link with a request handler in JavaScript\nDESCRIPTION: This snippet defines a custom Apollo Link that adds a timestamp to the operation's context before passing it down the chain, illustrating how to create a simple custom link by extending ApolloLink and implementing a request method.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloLink } from '@apollo/client';\n\nconst timeStartLink = new ApolloLink((operation, forward) => {\n  operation.setContext({ start: new Date() });\n  return forward(operation);\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Polling Interval in Apollo Client\nDESCRIPTION: This snippet demonstrates how to set the `pollInterval` option in Apollo Client using the `graphql` function. The `pollInterval` specifies the interval (in milliseconds) at which the query will be executed via the network. The component then re-renders. Setting the interval to 0 disables polling.  Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent, and a GraphQL query definition using `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_30\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: { pollInterval: 5000 },\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Index.ts and Index.js: Providing the link chain to Apollo Client\nDESCRIPTION: This snippet shows how to initialize Apollo Client with a combined link chain and in-memory cache. It exemplifies passing the custom split link to ensure proper routing of operations to HTTP or WebSocket transports, overriding default URI settings if the link is provided.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\n// ...code from the above example goes here...\n\nconst client = new ApolloClient({\n  link: splitLink,\n  cache: new InMemoryCache()\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with useSuspenseQuery Hook in Apollo Client (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the useSuspenseQuery hook from Apollo Client to fetch GraphQL data in a React component, suspending rendering while the network request is in progress. It defines TypeScript interfaces for the query data and variables, sets up a query document, and shows integration with React's Suspense component for smooth concurrent data fetching. Required dependencies include @apollo/client and React; expected parameters are GraphQL query definitions and variables, and the output is the fetched data rendered within the component UI.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Suspense } from \"react\";\nimport { gql, TypedDocumentNode, useSuspenseQuery } from \"@apollo/client\";\n\ninterface Data {\n  dog: {\n    id: string;\n    name: string;\n  };\n}\n\ninterface Variables {\n  name: string;\n}\n\nconst GET_DOG_QUERY: TypedDocumentNode<Data, Variables> = gql`\n  query GetDog($name: String) {\n    dog(name: $name) {\n      id\n      name\n    }\n  }\n`;\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog name=\"Mozzarella\" />\n    </Suspense>\n  );\n}\n\nfunction Dog({ name }: { name: string }) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { name },\n  });\n\n  return <>Name: {data.dog.name}</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Refetching queries with error handling in TypeScript using Apollo Client\nDESCRIPTION: This code snippet demonstrates how to refetch multiple queries using Apollo Client with robust error handling, preventing individual query errors from rejecting the entire promise. It captures the `queries` and `results` from `client.refetchQueries`, then processes each result with a catch block to log errors without failing the overall refetch. This approach ensures resilience during refetching operations.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst { queries, results } = client.refetchQueries({\n  // Specific client.refetchQueries options are not relevant to this example.\n});\n\nconst finalResults = await Promise.all(\n  results.map((result, i) => {\n    return Promise.resolve(result).catch(error => {\n      console.error(`Error refetching query ${queries[i].queryName}: ${error}`);\n      return null; // Silence this Promise rejection.\n    });\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing InMemoryCache with Apollo Client\nDESCRIPTION: Code example showing how to create an InMemoryCache instance and provide it to the ApolloClient constructor. This is the basic setup required to configure Apollo Client's caching system.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-configuration.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { InMemoryCache, ApolloClient } from '@apollo/client';\n\nconst client = new ApolloClient({\n  // ...other arguments...\n  cache: new InMemoryCache(options)\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an HTML Component for Server-side Rendering with Apollo State\nDESCRIPTION: A React component that renders the HTML structure for SSR, including the Apollo state for client-side rehydration. It safely embeds the cache state in a script tag and renders the React content in the root div.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nexport function Html({ content, state }) {\n  return (\n    <html>\n      <body>\n        <div id=\"root\" dangerouslySetInnerHTML={{ __html: content }} />\n        <script dangerouslySetInnerHTML={{\n          __html: `window.__APOLLO_STATE__=${JSON.stringify(state).replace(/</g, '\\\\u003c')};`,\n        }} />\n      </body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reading a GraphQL Fragment from Apollo Cache (TypeScript)\nDESCRIPTION: The `readFragment` method allows reading data from the Apollo Client cache in the shape of a GraphQL fragment. It takes an options object with the fragment, ID of the cached object, and optional variables.  It returns the fragment data or null if not found.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nreadFragment<FragmentType, TVariables = any>(\n  options: DataProxy.Fragment<TVariables>,\n  optimistic: boolean = false,\n): FragmentType | null\n```\n\n----------------------------------------\n\nTITLE: Configuring Paginated Read Function with Default Args (JavaScript)\nDESCRIPTION: Refines the paginated `read` function example by demonstrating how to provide default values for the `offset` and `limit` arguments if they are not included in the query. This allows the `read` function to return the entire cached list by default, while still supporting reading specific pages when arguments are provided. The surrounding `typePolicies` and `merge` function configuration would be similar to the previous example.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/core-api.mdx#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          read(existing, {\n            args: {\n              // Default to returning the entire cached list,\n              // if offset and limit are not provided.\n              offset = 0,\n              limit = existing?.length,\n            } = {},\n          }) {\n            return existing && existing.slice(offset, offset + limit);\n          },\n          // ... keyArgs, merge ...\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Controlling REST Query Strings with Apollo Client (GraphQL)\nDESCRIPTION: This GraphQL snippet illustrates how to pass arguments as query string parameters and context-derived values to a REST GET endpoint using apollo-link-rest. The @rest directive constructs the endpoint dynamically with args and context variables. Dependencies include Apollo Client, apollo-link-rest, and a context provider. Inputs are query and page_size; context provides language. Outputs are post entities with id and title fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_24\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery PostTitle {\n  postSearch(query: \"some key words\", page_size: 5)\n    @rest(type: \"Post\", path: \"/search?{args}&{context.language}\") {\n    id\n    title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Variables in JavaScript\nDESCRIPTION: Example of using the makeVar function to create a reactive variable with an initial value, returning a function that can be used to read or modify the variable.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nconst cartItems = makeVar([]);\n```\n\n----------------------------------------\n\nTITLE: Using FragmentType for Type-Safe Fragment Props with useFragment\nDESCRIPTION: Demonstrates how to use the `FragmentType` helper type for component props that receive a fragment reference. This ensures the prop is type-safe, containing only the necessary fragment reference and preventing direct access to the data fields; access must be done via the `useFragment` hook.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_58\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { FragmentType } from \"@apollo/client\";\nimport type { PostDetailsFragment } from \"./path/to/gql/types.ts\";\n\nexport const POST_DETAILS_FRAGMENT: TypedDocumentNode<\n  PostDetailsFragment\n> = gql`\n  fragment PostDetailsFragment on Post {\n    title\n    shortDescription\n  }\n`;\n\ninterface PostDetailsProps {\n  post: FragmentType<PostDetailsFragment>\n}\n\nfunction PostDetails({ post }: PostDetailsProps) {\n  const { data } = useFragment({\n    fragment: POST_DETAILS_FRAGMENT,\n    from: post,\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying Cached Objects in Apollo Cache (TypeScript)\nDESCRIPTION: The `identify` method returns the canonical ID for a specified cached object. It accepts either an object or an object reference. If it receives an object it returns the object's string-based ID. If it receives a reference it returns the reference's `__ref` ID string.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nidentify(object: StoreObject | Reference): string | undefined\n```\n\n----------------------------------------\n\nTITLE: Optimizing Rollup Bundles to Remove Development Code - JavaScript\nDESCRIPTION: This Rollup configuration showcases how to use a minify plugin with specific options to redefine globalThis.__DEV__ as false, mangling and compressing code. Requires Rollup and a compatible minify plugin. Key parameters control mangling and global_defs; expected input is a Rollup config file and output is a production-ready bundle optimized for size.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default [\n  {\n    // ... input, output, etc.\n    plugins: [\n      minify({\n        mangle: {\n          toplevel: true,\n        },\n        compress: {\n          toplevel: true,\n          global_defs: {\n            \"@globalThis.__DEV__\": \"false\",\n          },\n        },\n      }),\n    ],\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: TypePolicy Interface Definition in TypeScript\nDESCRIPTION: Provides the type definition for the TypePolicy interface used in Apollo Client. It includes options for defining key fields, specifying root operation types, and configuring field policies for cache behavior customization.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-configuration.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\ntype TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names, a function that returns an arbitrary string, or\n  // false to disable normalization for objects of this type.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // If your schema uses a custom __typename for any of the root Query,\n  // Mutation, and/or Subscription types (rare), set the corresponding\n  // field below to true to indicate that this type serves as that type.\n  queryType?: true,\n  mutationType?: true,\n  subscriptionType?: true,\n\n  fields?: {\n    [fieldName: string]:\n      | FieldPolicy<StoreValue>\n      | FieldReadFunction<StoreValue>;\n  }\n};\n\n// Recursive type aliases are coming in TypeScript 3.7, so this isn't the\n// actual type we use, but it's what it should be:\ntype KeySpecifier = (string | KeySpecifier)[];\n\ntype KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: {\n    typename: string;\n    selectionSet?: SelectionSetNode;\n    fragmentMap?: FragmentMap;\n  },\n) => string | null | void;\n```\n\n----------------------------------------\n\nTITLE: Integrating a DocumentTransform with ApolloClient and Querying in TypeScript\nDESCRIPTION: Illustrates how to integrate a DocumentTransform into a new ApolloClient instance by providing it in the configuration options. Demonstrates sending a query to the server and accessing the transformed data containing the required 'id' field. Prerequisites are '@apollo/client' and a running GraphQL server; input is a GraphQL query; output is the response data from the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ApolloClient, DocumentTransform } from '@apollo/client';\n\nconst query = gql`\n  query TestQuery {\n    currentUser {\n      name\n    }\n  }\n`;\n\nconst documentTransform = new DocumentTransform((document) => {\n  // ...\n});\n\nconst client = new ApolloClient({\n  // ...\n  documentTransform\n});\n\nconst result = await client.query({ query });\n\nconsole.log(result.data);\n// {\n//   currentUser: {\n//     id: \"...\",\n//     name: \"...\"\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Updating cached data immutably with updateQuery TypeScript signature\nDESCRIPTION: TypeScript method signature for updateQuery allowing generic types for data and variables. Takes an options object defining the query and variables, alongside an update function that transforms the current cached state into an updated state or returns undefined to skip changes. Returns the updated cached data or null if no update occurred. This ensures type safety and supports immutable cache updates.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\npublic updateQuery<TData = any, TVariables = any>(\n  options: Cache.UpdateQueryOptions<TData, TVariables>,\n  update: (data: TData | null) => TData | null | void,\n): TData | null\n```\n\n----------------------------------------\n\nTITLE: Configuring nextFetchPolicy with useQuery in Apollo Client (JavaScript)\nDESCRIPTION: This snippet shows how to leverage the 'nextFetchPolicy' option within the 'useQuery' React hook to control cache fetching behavior after the initial request. It sets 'fetchPolicy' to 'cache-and-network' initially and switches to 'cache-first' for subsequent fetches. Required dependencies include React, '@apollo/client', and a defined 'GET_ALL_TODOS' query. The main parameters are the query, 'fetchPolicy', and 'nextFetchPolicy' options; the output includes 'loading', 'error', and 'data' objects as typically returned by Apollo useQuery.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { loading, error, data } = useQuery(GET_ALL_TODOS, {\n  fetchPolicy: \"cache-and-network\",\n  nextFetchPolicy: \"cache-first\",\n});\n```\n\n----------------------------------------\n\nTITLE: skipToken Usage with useBackgroundQuery (JavaScript)\nDESCRIPTION: Shows the recommended usage of `skipToken` with the `useBackgroundQuery` hook in JavaScript. If `id` is not defined, the query is skipped using `skipToken`, avoiding unnecessary background requests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport { skipToken, useBackgroundQuery } from '@apollo/client';\nconst [queryRef] = useBackgroundQuery(\n  query,\n  id ? { variables: { id } } : skipToken\n);\n```\n\n----------------------------------------\n\nTITLE: Tracking and Displaying GraphQL Mutation Status with useMutation - JavaScript/JSX\nDESCRIPTION: This code snippet demonstrates how to use the loading and error fields returned by the useMutation hook to conditionally display status messages in a React component. It allows the UI to reflect whether the mutation is in progress or if an error occurred. Requires that useMutation has been called and destructured with the loading and error properties. Inputs are implicit (mutation in progress/status), and outputs are UI strings or error details.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_5\n\nLANGUAGE: JSX\nCODE:\n```\nif (loading) return 'Submitting...';\nif (error) return `Submission error! ${error.message}`;\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Relay with Multipart HTTP Subscriptions - TypeScript\nDESCRIPTION: This snippet shows how to set up Relay to consume multipart HTTP subscriptions using Apollo Client's adapter. It creates a fetch function (`fetchMultipartSubs`) using `createFetchMultipartSubscription` from `@apollo/client/utilities/subscriptions/relay` and integrates it into a `relay-runtime` Network object. Requires `@apollo/client/utilities/subscriptions/relay` and `relay-runtime`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { createFetchMultipartSubscription } from \"@apollo/client/utilities/subscriptions/relay\";\nimport { Environment, Network, RecordSource, Store } from \"relay-runtime\";\n\nconst fetchMultipartSubs = createFetchMultipartSubscription(\n  \"https://api.example.com\"\n);\n\nconst network = Network.create(fetchQuery, fetchMultipartSubs);\n\nexport const RelayEnvironment = new Environment({\n  network,\n  store: new Store(new RecordSource()),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring onError Link Options in Apollo Client\nDESCRIPTION: This snippet references the onError API options in Apollo Client's error handling link. It provides a link to the API documentation, outlining how to configure and use the onError link to handle GraphQL errors and network errors effectively within Apollo Client setups.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/error-handling.mdx#_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n### `onError` link options\n\nSee the [`onError` API reference](../api/link/apollo-link-error/#options).\n```\n\n----------------------------------------\n\nTITLE: Handling Network Errors with Apollo Link Error (JavaScript)\nDESCRIPTION: This snippet uses @apollo/client/link/error's onError to intercept network errors such as 401 Unauthorized. When such an error occurs, it triggers a logout function, enabling centralized error handling and response to authentication failures.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';\nimport { onError } from '@apollo/client/link/error';\n\nimport { logout } from './logout';\n\nconst httpLink = new HttpLink({ uri: '/graphql' });\n\nconst logoutLink = onError(({ networkError }) => {\n  if (networkError.statusCode === 401) logout();\n});\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: logoutLink.concat(httpLink),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Cache and Writing Query - JavaScript\nDESCRIPTION: This code snippet initializes an InMemoryCache and writes initial data to the cache using the writeQuery method. It sets the isLoggedIn status based on the presence of a token in localStorage and initializes an empty cartItems array.  The gql tagged template literal is used to define the query.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_30\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { InMemoryCache } from '@apollo/client';\n\nconst cache = new InMemoryCache();\ncache.writeQuery({\n  query: gql`query MyQuery {\n    isLoggedIn,\n    cartItems\n  }`,\n  data: {\n    isLoggedIn: !!localStorage.getItem('token'),\n    cartItems: [],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Cache State Before/After `writeQuery` Update in Apollo Client\nDESCRIPTION: Illustrates how `client.writeQuery` updates existing cached data. It shows the state of a specific cache object (`Todo:5`) before and after the `writeQuery` operation, highlighting that only fields present in the `data` argument are overwritten, while others are preserved.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// BEFORE\n{\n  'Todo:5': {\n    __typename: 'Todo',\n    id: 5,\n    text: 'Buy oranges 🍊',\n    completed: true,\n    dueDate: '2022-07-02'\n  }\n}\n\n// AFTER\n{\n  'Todo:5': {\n    __typename: 'Todo',\n    id: 5,\n    text: 'Buy grapes 🍇',\n    completed: false,\n    dueDate: '2022-07-02'\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring cache keys with keyArgs including directives in Apollo Client\nDESCRIPTION: Demonstrates how to specify cache key arguments that include GraphQL directives like @connection by listing them in the keyArgs array. This approach ensures cache entries are separated based on directive parameters, supporting complex cache invalidation and data separation strategies.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: [\"someArg\", \"anotherArg\", \"@connection\", [\"key\"]]],\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Writing data to Apollo Client cache with writeQuery TypeScript signature\nDESCRIPTION: TypeScript signature for the writeQuery method which takes a generic data type and optional variables type. Accepts an options object describing the query shape and data to write, returning a Reference to the written object or undefined if the operation fails. Enables strongly-typed and flexible cache writes aligned with GraphQL query definitions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nwriteQuery<TData = any, TVariables = any>(\n  options: Cache.WriteQueryOptions<TData, TVariables>,\n): Reference | undefined\n```\n\n----------------------------------------\n\nTITLE: Masked TypeScript Type for Query Result Without Fragment Fields\nDESCRIPTION: This TypeScript type definition provides the masked shape of GetCurrentUserQuery, showing only the scalar fields directly present in the query selection, omitting those from fragment spreads. This type is produced when GraphQL Codegen masking is enabled. Input: type generated for masked selection; Output: a safer, restricted shape for currentUser.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_52\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype GetCurrentUserQuery = {\n  currentUser: {\n    __typename: \"User\";\n    id: string;\n    // omitted: additional internal metadata\n  } | null\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting Apollo Client Cache Sizes After Loading the Library in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to modify Apollo Client's cache sizes at runtime after the library has been loaded. It imports the 'cacheSizes' object from '@apollo/client/utilities' and directly changes a cache size property. Because such changes only impact newly created caches, the snippet calls 'print.reset()' to reset the cache, ensuring the new sizes take effect immediately. This requires the 'print' export from '@apollo/client' to trigger cache reset. Inputs include the numeric cache size value assigned and the cache reset function invoked. Output is an effective update of cache sizes used by Apollo Client post-initialization.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/memory-management.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { cacheSizes } from '@apollo/client/utilities';\nimport { print } from '@apollo/client'\n\ncacheSizes.print = 100;\n// cache sizes changed this way will only take effect for caches\n// created after the cache size has been changed, so we need to\n// reset the cache for it to be effective\n\nprint.reset();\n```\n\n----------------------------------------\n\nTITLE: MakeVar Method Signature in TypeScript\nDESCRIPTION: The signature for the makeVar method that creates a reactive variable with an optional initial value and returns a ReactiveVar function.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nmakeVar<T>(value: T): ReactiveVar<T>\n```\n\n----------------------------------------\n\nTITLE: Configuring HttpLink for Text Streaming in React Native\nDESCRIPTION: Creates an HttpLink with specific fetchOptions to enable text streaming for multipart HTTP responses in React Native applications.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/react-native.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst link = new HttpLink({\n  uri: \"http://localhost:4000/graphql\",\n  fetchOptions: {\n    reactNative: { textStreaming: true },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initialize ApolloClient with URI and cache\nDESCRIPTION: Initializes an instance of ApolloClient, configuring it to connect to a GraphQL API and cache query results.  The `uri` property specifies the URL of the GraphQL server, and the `cache` property uses `InMemoryCache` to store query results locally.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst client = new ApolloClient({\n  uri: 'https://flyby-router-demo.herokuapp.com/',\n  cache: new InMemoryCache(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining static options within config.options for a GraphQL query\nDESCRIPTION: Shows how to set static options in the config object to customize query behavior, such as fetching policies, variables, or other parameters, directly within the options property.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: {\n    // Options go here.\n  },\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Defining a Modifier Function for Cache Modification in TypeScript\nDESCRIPTION: The signature for the modify method of InMemoryCache class, which allows for targeted updates to cached data without requiring a complete write operation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nmodify(options: Cache.ModifyOptions): boolean\n```\n\n----------------------------------------\n\nTITLE: Providing Multiple Custom Links in Apollo Client (JavaScript)\nDESCRIPTION: This snippet showcases creating multiple middleware links: one for authorization and another for recent activity, then combining them into a link chain using from(). It demonstrates advanced request modification by adding headers sequentially before sending via HttpLink.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, HttpLink, ApolloLink, InMemoryCache, from } from '@apollo/client';\n\nconst httpLink = new HttpLink({ uri: '/graphql' });\n\nconst authMiddleware = new ApolloLink((operation, forward) => {\n  // add the authorization to the headers\n  operation.setContext(({ headers = {} }) => ({\n    headers: {\n      ...headers,\n      authorization: localStorage.getItem('token') || null,\n    }\n  }));\n\n  return forward(operation);\n});\n\nconst activityMiddleware = new ApolloLink((operation, forward) => {\n  // add the recent-activity custom header to the headers\n  operation.setContext(({ headers = {} }) => ({\n    headers: {\n      ...headers,\n      'recent-activity': localStorage.getItem('lastOnlineTime') || null,\n    }\n  }));\n\n  return forward(operation);\n});\n\ndefault = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: from([\n    authMiddleware,\n    activityMiddleware,\n    httpLink\n  ]),\n});\n```\n\n----------------------------------------\n\nTITLE: Submitting a To-Do Form with useMutation and Tracking Status - JavaScript/JSX\nDESCRIPTION: This React component, AddTodo, sets up a form to submit new to-do items by calling the mutate function returned by the useMutation hook. It displays loading and error messages based on the mutation status and resets the form input after successful submission. Required dependencies include @apollo/client and a defined ADD_TODO mutation. The input's value is taken as the to-do type, passed as a variable to the mutation; the component returns UI elements reflecting current mutation state and supports error handling.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\nfunction AddTodo() {\n  let input;\n  const [addTodo, { data, loading, error }] = useMutation(ADD_TODO);\n\n  if (loading) return 'Submitting...';\n  if (error) return `Submission error! ${error.message}`;\n\n  return (\n    <div>\n      <form\n        onSubmit={e => {\n          e.preventDefault();\n          addTodo({ variables: { type: input.value } });\n          input.value = '';\n        }}\n      >\n        <input\n          ref={node => {\n            input = node;\n          }}\n        />\n        <button type=\"submit\">Add Todo</button>\n      </form>\n    </div>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Executing deleteDog GraphQL Mutation with Apollo Client useMutation in JSX\nDESCRIPTION: Defines a React component DeleteButton that executes the DELETE_DOG_MUTATION GraphQL mutation to delete a dog by name using Apollo Client's useMutation hook. It handles and renders loading, error, and success states based on mutation lifecycle. The mutation requires a 'name' parameter as input and returns the dog's id, name, and breed. Dependencies include React and @apollo/client's gql and useMutation hooks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from \"react\";\nimport { gql, useMutation } from \"@apollo/client\";\n\nexport const DELETE_DOG_MUTATION = gql`\n  mutation deleteDog($name: String!) {\n    deleteDog(name: $name) {\n      id\n      name\n      breed\n    }\n  }\n`;\n\nexport function DeleteButton() {\n  const [mutate, { loading, error, data }] = useMutation(DELETE_DOG_MUTATION);\n\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error!</p>;\n  if (data) return <p>Deleted!</p>;\n\n  return (\n    <button onClick={() => mutate({ variables: { name: \"Buck\" } })}>\n      Click to Delete Buck\n    </button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query with Export Directive (GQL, JS)\nDESCRIPTION: Defines a GraphQL query `GET_CURRENT_AUTHOR_POST_COUNT` that utilizes the `@export` directive to use the value of the local-only field `currentAuthorId` as the value of the `$authorId` variable, which is then passed to the `postCount` field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nconst GET_CURRENT_AUTHOR_POST_COUNT = gql`\n  query CurrentAuthorPostCount($authorId: Int!) {\n    currentAuthorId @client @export(as: \"authorId\")\n    postCount(authorId: $authorId)\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Define GraphQL Query for Cart Items (GQL, JS)\nDESCRIPTION: Defines a GraphQL query `GET_CART_ITEMS` to fetch a list of item IDs in the user's cart from the local state using the `@client` directive. The `cartItems` field is designated as a client-side only field and will not be resolved by a GraphQL server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport const GET_CART_ITEMS = gql`\n  query GetCartItems {\n    cartItems @client\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Writing Cache Data with `writeQuery` in Apollo Client (JavaScript/GraphQL)\nDESCRIPTION: Demonstrates using `client.writeQuery` to write data directly to the Apollo Client cache, matching the shape of a provided GraphQL query. Requires a query (`gql`), the data to write (`data`), and any necessary variables. This modifies the cache locally, does not interact with the server, and overwrites existing fields specified in `data`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nclient.writeQuery({\n  query: gql`\n    query WriteTodo($id: Int!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }`,\n  data: { // Contains the data to write\n    todo: {\n      __typename: 'Todo',\n      id: 5,\n      text: 'Buy grapes 🍇',\n      completed: false\n    },\n  },\n  variables: {\n    id: 5\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using graphql() to create a higher-order component wrapping a React component\nDESCRIPTION: This snippet demonstrates how to wrap a React component with graphql() to inject GraphQL data, specifically executing a query named TodoAppQuery to fetch a list of todos. The enhanced component receives data via props and renders a list accordingly.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction TodoApp({ data: { todos } }) {\n  return (\n    <ul>\n      {todos.map(({ id, text }) => (\n        <li key={id}>{text}</li>\n      ))}\n    </ul>\n  );\n}\n\nexport default graphql(gql`\n  query TodoAppQuery {\n    todos {\n      id\n      text\n    }\n  }\n`)(TodoApp);\n```\n\n----------------------------------------\n\nTITLE: Refetching Queries with Temporary Optimistic Cache Layer in Apollo Client (TypeScript)\nDESCRIPTION: This example demonstrates using the optimistic boolean option with updateCache in client.refetchQueries. It applies cache operations (like evict) using an optimistic layer, so cache updates are discarded after refetching. Useful for temporarily invalidating data for refetching purposes without a permanent change. Requires Apollo Client's support for optimistic cache layers.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  updateCache(cache) {\n    cache.evict({ fieldName: \"someRootField\" });\n  },\n\n  // Evict Query.someRootField only temporarily, in an optimistic layer.\n  optimistic: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Stateful ApolloLink Example - JavaScript\nDESCRIPTION: This code shows how to create a stateful `ApolloLink` by extending `ApolloLink` and overriding the `request` method. This link maintains a counter (`operationCount`) that increments each time a request is processed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink } from '@apollo/client';\n\nclass OperationCountLink extends ApolloLink {\n  constructor() {\n    super();\n    this.operationCount = 0;\n  }\n  request(operation, forward) {\n    this.operationCount += 1;\n    return forward(operation);\n  }\n}\n\nconst link = new OperationCountLink();\n\n```\n\n----------------------------------------\n\nTITLE: Using @client Fields with Fetch Policies in React Component\nDESCRIPTION: This example shows a React component that uses a query with a mix of remote fields and @client fields. It demonstrates how Apollo Client's fetch policies affect the resolution of @client fields in a launch details component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_15\n\nLANGUAGE: jsx\nCODE:\n```\nimport React, { Fragment } from \"react\";\nimport { useQuery, gql } from \"@apollo/client\";\n\nimport { Loading, Header, LaunchDetail } from \"../components\";\nimport { ActionButton } from \"../containers\";\n\nexport const GET_LAUNCH_DETAILS = gql`\n  query LaunchDetails($launchId: ID!) {\n    launch(id: $launchId) {\n      isInCart @client\n      site\n      rocket {\n        type\n      }\n    }\n  }\n`;\n\nexport default function Launch({ launchId }) {\n  const { loading, error, data } = useQuery(\n    GET_LAUNCH_DETAILS,\n    { variables: { launchId } }\n  );\n\n  if (loading) return <Loading />;\n  if (error) return <p>ERROR: {error.message}</p>;\n\n  return (\n    <Fragment>\n      <Header image={data.launch.mission.missionPatch}>\n        {data.launch.mission.name}\n      </Header>\n      <LaunchDetail {...data.launch} />\n      <ActionButton {...data.launch} />\n    </Fragment>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Nested Local-only Fields Using the @client Directive in Apollo Client JavaScript\nDESCRIPTION: This GraphQL query illustrates how to use the @client directive with nested subfields, allowing Apollo Client to resolve multiple local-only fields such as isInCart and isOnWishlist within a purchaseStatus object. Inputs: productId (ID!). The server receives only server-resolvable fields, while the client resolves purchaseStatus and its subfields locally via policies in the cache. Dependencies: field policies must be configured for purchaseStatus and its subfields. Output: a product object with server and local-only status. Limitation: All nested subfields inherit the @client directive and must be backed by local resolvers or field policies.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_3\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery ProductDetails($productId: ID!) {\n  product(id: $productId) {\n    name\n    price\n    purchaseStatus @client {\n      isInCart\n      isOnWishlist\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Apollo Client Cache Structure for Paginated Feed\nDESCRIPTION: Illustrates the default cache behavior in Apollo Client for paginated data.  Because all arguments are treated as key arguments by default, each distinct combination of `offset`, `limit`, and `category` results in a separate cache entry, which prevents proper merging of paginated results.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  'ROOT_QUERY': {\n    // First query\n    'feed({\"offset\":\"0\",\"limit\":\"10\",\"category\":\"SPORTS\"})': [\n      {\n        '__ref': 'FeedItem:1'\n      },\n      // ...additional items...\n    ],\n    // Second query\n    'feed({\"offset\":\"10\",\"limit\":\"10\",\"category\":\"SPORTS\"})': [\n      {\n        '__ref': 'FeedItem:11'\n      },\n      // ...additional items...\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Cache Data with `readFragment` in Apollo Client (JavaScript/GraphQL)\nDESCRIPTION: Demonstrates using `client.readFragment` to read specific fields from a normalized cache object using a GraphQL fragment. Requires the cache ID (`id`) of the object (typically `<__typename>:<id>`) and a GraphQL fragment defined with `gql`. Returns the requested data or `null` if the object or any specified fields are missing.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst todo = client.readFragment({\n  id: 'Todo:5', // The value of the to-do item's cache ID\n  fragment: gql`\n    fragment MyTodo on Todo {\n      id\n      text\n      completed\n    }\n  `,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Server-Side GraphQL Subscription Schema - GraphQL\nDESCRIPTION: This snippet defines a sample `Subscription` type in a GraphQL schema. It includes a `commentAdded` field which is a subscription that takes a `postID` argument of type `ID!` (non-nullable ID) and returns a `Comment` type when a new comment is added to that post. This is part of the server-side schema definition.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Subscription {\n  commentAdded(postID: ID!): Comment\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query to Avoid Hardcoded Arguments\nDESCRIPTION: This snippet emphasizes the disadvantages of hardcoded arguments in GraphQL queries, such as reduced cache effectiveness and potential exposure of sensitive data. Using variables instead provides better performance, privacy, and reusability.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/operation-best-practices.mdx#_snippet_2\n\nLANGUAGE: GraphQL\nCODE:\n```\n# Not recommended ❌\nquery GetDog {\n  dog(id: \"5\") {\n    name\n    breed\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Unmasking Fragment Data with @unmask in GraphQL\nDESCRIPTION: Demonstrates using the `@unmask` directive (Apollo Client >= 3.12.0) on fragment spreads (`...PostDetails`, `...CommentFragment`) within a GraphQL query and fragment definition. This makes the fields defined within those fragments directly accessible on the parent query or fragment result when data masking is enabled, overriding the default masking behavior. The directive has no effect if data masking is disabled.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetPosts {\n  posts {\n    id\n    ...PostDetails @unmask\n  }\n}\n\nfragment PostDetails on Post {\n  title\n  publishedAt\n  topComment {\n    id\n    ...CommentFragment @unmask\n  }\n}\n\nfragment CommentFragment on Comment {\n  content\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling cache in DocumentTransform to force re-transformations\nDESCRIPTION: This snippet shows how to disable caching within a DocumentTransform by passing the 'cache: false' option. This ensures the transform function runs on each invocation regardless of previous transformations, useful when transforms depend on changing runtime data that cannot be captured in cache keys.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst documentTransform = new DocumentTransform(\n  (document) => {\n    // ...\n  },\n  {\n    cache: false\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Using the @skip Directive in GraphQL\nDESCRIPTION: Demonstrates the basic usage of the built-in `@skip` directive in a GraphQL query. The `experimentalField` is conditionally excluded from the query results if the `$someTest` variable is true. Directives are placed after the element they decorate and can accept arguments.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery myQuery($someTest: Boolean) {\n  experimentalField @skip(if: $someTest)\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Data with SchemaLink in Apollo Client\nDESCRIPTION: This snippet demonstrates how to use SchemaLink with Apollo Client for mocking data. It imports necessary modules, defines type definitions and mocks, creates an executable schema with mocks using `graphql-tools`, and configures an ApolloClient instance with a SchemaLink that uses the schema with mocks. It also uses `InMemoryCache` to initialize the Apollo cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-schema.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\nimport { SchemaLink } from '@apollo/client/link/schema';\nimport { makeExecutableSchema, addMockFunctionsToSchema } from 'graphql-tools';\n\nconst typeDefs = `\n  Query {\n  ...\n  }\n`;\n\nconst mocks = {\n  Query: () => ...,\n  Mutation: () => ...\n};\n\nconst schema = makeExecutableSchema({ typeDefs });\nconst schemaWithMocks = addMockFunctionsToSchema({\n  schema,\n  mocks\n});\n\nconst apolloCache = new InMemoryCache(window.__APOLLO_STATE__);\n\nconst graphqlClient = new ApolloClient({\n  cache: apolloCache,\n  link: new SchemaLink({ schema: schemaWithMocks })\n});\n```\n\n----------------------------------------\n\nTITLE: Using fetchMore with useQuery Hook for Offset Pagination in React JSX\nDESCRIPTION: This React functional component demonstrates how to use Apollo Client's `useQuery` hook with offset-based pagination by leveraging `fetchMore`. It performs an initial query with offset 0 and limit 10, then uses `fetchMore` to load additional items by updating the offset to the current number of loaded items. The cached results are merged automatically, and the component receives the entire paginated list in its props. The example also includes a comment explaining adding `notifyOnNetworkStatusChange:true` for loading state updates.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/offset-based.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst FeedData() {\n  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {\n    variables: {\n      offset: 0,\n      limit: 10\n    },\n  });\n\n  // If you want your component to rerender with loading:true whenever\n  // fetchMore is called, add notifyOnNetworkStatusChange:true to the\n  // options you pass to useQuery above.\n  if (loading) return <Loading/>;\n\n  return (\n    <Feed\n      entries={data.feed || []}\n      onLoadMore={() => fetchMore({\n        variables: {\n          offset: data.feed.length\n        },\n      })}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Shorthand for merge function for Author\nDESCRIPTION: Shows the shorthand syntax to define the `merge` function for the `author` field in `typePolicies` for the `Book` object. This approach is equivalent to the previous snippet but is more concise and directly indicates merging should occur.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Book: {\n      fields: {\n        author: {\n          // Equivalent to options.mergeObjects(existing, incoming).\n          merge: true,\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using ApolloConsumer for Accessing Apollo Client - JSX\nDESCRIPTION: This snippet shows how to use the ApolloConsumer component to access a configured ApolloClient instance directly in functional React components via the render prop pattern. ApolloConsumer expects a single child function that receives the ApolloClient as an argument, allowing direct queries or cache manipulation. Dependencies: @apollo/client, React. Input: None. Output: Rendered content with client access. No asynchronous data loading is handled in this snippet.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\nimport { ApolloConsumer } from '@apollo/client';\n\nfunction WithApolloClient() {\n  return (\n    <ApolloConsumer>\n      {client => 'We have access to the client!' /* do stuff here */}\n    </ApolloConsumer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Preloading Queries and Refetching via useQueryRefHandlers with Apollo Client in TypeScript\nDESCRIPTION: This snippet shows how to preload a GraphQL query outside the React lifecycle using Apollo Client's `preloadQuery`, and then integrate it into the component tree by obtaining refetch handlers via `useQueryRefHandlers`. The App component uses React's `useTransition` to manage UI state and invokes refetch when necessary. Dependencies: `@apollo/client` for preload and handler hooks, GraphQL queries, and React transitions. Input includes a valid query object for preloading; output is the ability to refetch data from preloaded contexts without fallback suspensions. The approach decouples query management from React tree mounting to optimize initial render performance.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ...\nimport {\n  // ...\n  useQueryRefHandlers,\n} from \"@apollo/client\";\n\nconst queryRef = preloadQuery(GET_BREEDS_QUERY);\n\nfunction App() {\n  const [isPending, startTransition] = useTransition();\n  const { refetch } = useQueryRefHandlers(queryRef);\n\n  function handleRefetch() {\n    startTransition(() => {\n      refetch();\n    });\n  };\n\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog\n        id=\"3\"\n        isPending={isPending}\n        onRefetch={handleRefetch}\n      />\n    </Suspense>\n  );\n}\n\n// ...\n\n```\n\n----------------------------------------\n\nTITLE: Separating Global and User-Specific Data in GraphQL\nDESCRIPTION: This snippet highlights the practice of splitting queries based on whether they return the same data for all users or user-specific data. Separating such queries optimizes caching strategies, enabling better performance and privacy.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/operation-best-practices.mdx#_snippet_4\n\nLANGUAGE: GraphQL\nCODE:\n```\n# Returns static data for all users\nquery GetAllElements {\n  elements {\n    atomicNumber\n    name\n    symbol\n  }\n}\n\n# Returns user-specific data\nquery GetMyDocuments {\n  myDocuments {\n    id\n    title\n    url\n    updatedAt\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using responseTransformer for Non-JSON Responses\nDESCRIPTION: Shows how to use `responseTransformer` to handle non-JSON responses (like XML or plain text) from a REST API. The transformer reads the response as text and then calls a custom parsing function (`parseXmlResponseToJson`) to convert it into the JSON format Apollo expects.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_16\n\nLANGUAGE: js\nCODE:\n```\nconst link = new RestLink({\n  uri: '/xmlApi',\n  responseTransformer: async response => response.text().then(text => parseXmlResponseToJson(text)),\n});\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Cache Keys with @connection in GraphQL\nDESCRIPTION: Illustrates using the `@connection` directive in an Apollo Client GraphQL query to assign a custom cache key ('feed') to a paginated field (`feed`). This helps manage cached lists effectively, particularly when implementing pagination.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery Feed($offset: Int, $limit: Int) {\n  feed(offset: $offset, limit: $limit) @connection(key: \"feed\") {\n    ...FeedFields\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Queries for Paginated Feed Items\nDESCRIPTION: Presents two GraphQL queries that fetch feed items with different `offset` values. The first query fetches items from offset 0, and the second query fetches items from offset 10. Both queries specify the same `category` (SPORTS).\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\n# First query\nquery GetFeedItems {\n  feed(offset: 0, limit: 10, category: \"SPORTS\")\n}\n\n# Second query\nquery GetFeedItems {\n  feed(offset: 10, limit: 10, category: \"SPORTS\")\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client Cache with offsetLimitPagination Helper in JavaScript\nDESCRIPTION: This snippet shows how to configure Apollo Client's in-memory cache to use the `offsetLimitPagination` helper function for the `feed` field on the `Query` type. It defines a type policy with a field policy that automatically merges paginated results fetched by queries using offset and limit. The example imports necessary dependencies from @apollo/client and @apollo/client/utilities and sets up the cache to handle merging pagination results in the cache transparently.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/offset-based.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { InMemoryCache } from \"@apollo/client\";\nimport { offsetLimitPagination } from \"@apollo/client/utilities\";\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: offsetLimitPagination()\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using @connection directive for cache separation in Apollo Client queries\nDESCRIPTION: Illustrates how to replace the @connection directive with keyArgs configuration, allowing separate cache entries for different connection keys. The @connection directive facilitates cache separation for queries with variables or dynamic identifiers, with configuration via keyArgs using special syntax.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst FEED_QUERY = gql`\n  query Feed($offset: Int, $limit: Int, $feedKey: String) {\n    feed(offset: $offset, limit: $limit) @connection(key: $feedKey) {\n      edges {\n        node { ... }\n      }\n      pageInfo {\n        endCursor\n        hasNextPage\n      }\n    }\n  }\n`;\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: [\"@connection\", [\"key\"]]],\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: skipToken Usage with useSuspenseQuery (JavaScript)\nDESCRIPTION: Demonstrates the recommended usage of `skipToken` with the `useSuspenseQuery` hook in JavaScript.  If `id` is not defined, the query is skipped using `skipToken`, preventing unnecessary requests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { skipToken, useSuspenseQuery } from '@apollo/client';\nconst { data } = useSuspenseQuery(\n  query,\n  id ? { variables: { id } } : skipToken\n);\n```\n\n----------------------------------------\n\nTITLE: Installing ts-transform-graphql-tag with npm\nDESCRIPTION: This snippet shows how to install the `ts-transform-graphql-tag` package using npm as a development dependency.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install --save-dev ts-transform-graphql-tag\n```\n\n----------------------------------------\n\nTITLE: Generating Persisted Query Manifest via CLI (bash)\nDESCRIPTION: Runs the manifest generator CLI to extract operation queries from the application. This command analyzes source files and outputs a persisted-query-manifest.json, which is required for safelisting queries with Apollo.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx generate-persisted-query-manifest\n```\n\n----------------------------------------\n\nTITLE: Displaying Error Message with GraphQL HOC\nDESCRIPTION: This snippet demonstrates how to display an error message if a GraphQL query fails using the `data.error` property. The `graphql()` HOC injects the `data` prop into the component.  It uses the destructured `error` property from the `data` prop.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyComponent({ data: { error } }) {\n  if (error) {\n    return <div>Error!</div>;\n  } else {\n    // ...\n  }\n}\n\nexport default graphql(gql`query MyComponentQuery  { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Implementing custom read and merge functions for cache management in Apollo Client\nDESCRIPTION: Defines cache policies for the 'feed' field in the Query type, removing keyArgs to handle multiple categories via custom functions. The 'read' extracts a slice of cached data based on arguments, and 'merge' updates the cache with incoming data considering offsets. This approach allows manual control over cache separation by category, useful when category data interdependence exists.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: false,\n\n          read(existing = {}, { args: { offset, limit, category }}) {\n            return existing[category]?.slice(offset, offset + limit);\n          },\n\n          merge(existing = {}, incoming, { args: { category, offset = 0 }}) {\n            const merged = existing[category] ? existing[category].slice(0) : [];\n            for (let i = 0; i < incoming.length; ++i) {\n              merged[offset + i] = incoming[i];\n            }\n            existing[category] = merged;\n            return existing;\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Dogs Component with useQuery\nDESCRIPTION: The `Dogs` component utilizes the `useQuery` hook to execute the `GET_DOGS` GraphQL query.  It retrieves `loading`, `error`, and `data` properties from the hook.  Based on the query's state, it conditionally renders a loading message, an error message, or a dropdown menu populated with dog breeds from the server.  The `onDogSelected` prop is a function to send the selection to parent component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/queries.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Dogs({ onDogSelected }) {\n  const { loading, error, data } = useQuery(GET_DOGS);\n\n  if (loading) return 'Loading...';\n  if (error) return `Error! ${error.message}`;\n\n  return (\n    <select name='dog' onChange={onDogSelected}>\n      {data.dogs.map((dog) => (\n        <option key={dog.id} value={dog.breed}>\n          {dog.breed}\n        </option>\n      ))}\n    </select>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Custom Fetch Handler with RestLink in JavaScript\nDESCRIPTION: Illustrates how to provide a `customFetch` function to `RestLink`. This function receives the `uri` and `options` and must return a Promise resolving with a fetch-like response object. This allows developers to integrate custom request logic or libraries.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_18\n\nLANGUAGE: js\nCODE:\n```\nconst link = new RestLink({\n  endpoints: \"/api\",\n  customFetch: (uri, options) => new Promise((resolve, reject) => {\n    // Your own (asynchronous) request handler\n    resolve(responseObject)\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Computing options dynamically from props with config.options as a function\nDESCRIPTION: Demonstrates how to set the options property as a function accepting component props, enabling dynamic configuration such as variables or fetch policies based on current props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: props => ({\n    // Options computed from `props` here.\n  }),\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Preloading Queries with createQueryPreloader - TypeScript\nDESCRIPTION: Illustrates how to use `createQueryPreloader` to initiate query fetching outside of React components, enabling earlier data retrieval. The function returns a `preloadQuery` function, which when called, returns a `queryRef`. The `queryRef` is then passed to `useReadQuery` inside a React component wrapped in `Suspense` for seamless integration with the UI.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst preloadQuery = createQueryPreloader(client);\nconst queryRef = preloadQuery(QUERY, { variables, ...otherOptions });\n\nfunction App() {\n  return {\n    <Suspense fallback={<div>Loading</div>}>\n      <MyQuery />\n    </Suspense>\n  }\n}\n\nfunction MyQuery() {\n  const { data } = useReadQuery(queryRef);\n\n  // do something with data\n}\n```\n\n----------------------------------------\n\nTITLE: Index.ts and Index.js: Configuring WebSocket connectionParams for authentication\nDESCRIPTION: This code demonstrates passing authentication parameters, such as an authToken, via connectionParams to the WebSocket link. The server can then utilize these parameters for authenticating subscription clients during connection establishment.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\nimport { createClient } from 'graphql-ws';\n\nconst wsLink = new GraphQLWsLink(createClient({\n  url: 'ws://localhost:4000/subscriptions',\n  connectionParams: {\n    authToken: user.authToken,\n  },\n}));\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\nimport { createClient } from 'graphql-ws';\n\nconst wsLink = new GraphQLWsLink(createClient({\n  url: 'ws://localhost:4000/subscriptions',\n  connectionParams: {\n    authToken: user.authToken,\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Reading Fragment Data with useFragment (Initial)\nDESCRIPTION: Introduces the `useFragment` hook, demonstrating how a component like `PostDetails` accesses the data defined in its associated fragment (`POST_DETAILS_FRAGMENT`) when data masking is enabled. The hook takes the fragment definition and the parent object containing the fragment's data (passed via the `from` option).\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_38\n\nLANGUAGE: jsx\nCODE:\n```\nfunction PostDetails({ post }) {\n  const { data, complete } = useFragment({\n    fragment: POST_DETAILS_FRAGMENT,\n    from: post,\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Todo to Cache Using cache.readQuery & cache.writeQuery - JS\nDESCRIPTION: This snippet shows how to add a new todo item to a list of todos stored in the Apollo Client cache.  It initializes the cache with an empty list of todos using `cache.writeQuery`.  The `addTodo` resolver reads the existing todos using `cache.readQuery`, adds the new todo to the list, and then updates the cache with the updated list using `cache.writeQuery`. Dependencies include ApolloClient, InMemoryCache and gql from '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nlet nextTodoId = 0;\n\nconst cache = new InMemoryCache();\n\ncache.writeQuery({\n  query: gql`query GetTodos { todos { ... } }`,\n  data: { todos: [] },\n});\n\nconst client = new ApolloClient({\n  resolvers: {\n    Mutation: {\n      addTodo: (_, { text }, { cache }) => {\n        const query = gql`\n          query GetTodos {\n            todos @client {\n              id\n              text\n              completed\n            }\n          }\n        `;\n\n        const previous = cache.readQuery({ query });\n        const newTodo = { id: nextTodoId++, text, completed: false, __typename: 'TodoItem' };\n        const data = {\n          todos: [...previous.todos, newTodo],\n        };\n\n        cache.writeQuery({ query, data });\n        return newTodo;\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Polling Status with GraphQL HOC\nDESCRIPTION: This snippet demonstrates how to display a polling status using the `data.networkStatus` property. It shows a specific message when the network status indicates a polling request is in flight (status code 6). The `graphql()` HOC injects the `data` prop, which includes `networkStatus`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyComponent({ data: { networkStatus } }) {\n  if (networkStatus === 6) {\n    return <div>Polling!</div>;\n  } else if (networkStatus < 7) {\n    return <div>Loading...</div>;\n  } else {\n    // ...\n  }\n}\n\nexport default graphql(gql`query MyComponentQuery  { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: src/__tests__/server.ts\nDESCRIPTION: Sets up an MSW server instance for Node.js environment, enabling interception of network requests during tests by importing predefined request handlers.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/schema-driven-testing.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { setupServer } from \"msw/node\";\nimport { handlers } from \"./handlers\";\n\n// This configures a request mocking server with the given request handlers.\nexport const server = setupServer(...handlers);\n```\n\n----------------------------------------\n\nTITLE: Refetch with New Variables\nDESCRIPTION: Demonstrates passing new variables to the `refetch` function to update the query parameters.  In this case, the `refetch` function will always refetch a dalmatian, overriding the original breed variable.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/queries.mdx#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<button\n  onClick={() =>\n    refetch({\n      breed: 'dalmatian', // Always refetches a dalmatian instead of original breed\n    })\n  }\n>\n  Refetch!\n</button>\n```\n\n----------------------------------------\n\nTITLE: Installing babel-plugin-import-graphql with npm\nDESCRIPTION: Shows how to install the `babel-plugin-import-graphql` package using npm as a development dependency.  This plugin is designed for importing GraphQL files.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install --save-dev babel-plugin-import-graphql\n```\n\n----------------------------------------\n\nTITLE: Defining a merge function at the type level for Author\nDESCRIPTION: Demonstrates defining a default `merge` function at the type level for the `Author` type in Apollo Client. By setting `Author: { merge: true }` in `typePolicies`, any field that returns an `Author` object automatically uses this merge function, eliminating the need for field-level definitions in most cases.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Book: {\n      fields: {\n        // No longer required!\n        // author: {\n        //   merge: true,\n        // },\n      },\n    },\n\n    Author: {\n      merge: true,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Local Fragment Definition Taking Precedence\nDESCRIPTION: Demonstrating how a local fragment definition in a component overrides a registered fragment with the same name when used in a query.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst GET_ITEM_LIST = gql`\n  query GetItemList {\n    list {\n      ...ItemFragment\n    }\n  }\n\n  fragment ExtraFields on Item {\n    createdBy\n  }\n`;\nfunction ToDoList() {\n  const { data } = useQuery(GET_ITEM_LIST);\n  return (\n    <ol>\n      {data?.list.map((item) => (\n        {/* `createdBy` exists on the returned items, `isCompleted` does not */}\n        <Item key={item.id} text={item.text} author={item.createdBy} />\n      ))}\n    </ol>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from client.writeData to client.writeQuery in Apollo Client (JavaScript)\nDESCRIPTION: These snippets illustrate how to update local Apollo Client state management, replacing the deprecated 'writeData' API with 'writeQuery'. Both examples clear an array of 'cartItems' in the client cache. The first approach uses the old 'writeData', while the second uses 'writeQuery' with an explicit GraphQL query definition via the 'gql' template literal. Requires '@apollo/client' and the 'gql' tag for query construction.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nclient.writeData({\n  data: {\n    cartItems: []\n  }\n});\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nclient.writeQuery({\n  query: gql`\n    query GetCartItems {\n      cartItems\n    }\n  `,\n  data: {\n    cartItems: []\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Apollo Client Cache APIs in JavaScript\nDESCRIPTION: This snippet demonstrates how to import 'ApolloCache' and 'InMemoryCache' types directly from '@apollo/client/cache', aligning with Apollo Client 3.0 changes. No additional dependencies are required beyond '@apollo/client'. The main inputs are the import specifiers, and the output is access to Apollo Client’s cache classes for custom cache management or advanced use cases.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloCache, InMemoryCache } from '@apollo/client/cache';\n```\n\n----------------------------------------\n\nTITLE: App Component Using Login Status (React, JSX)\nDESCRIPTION: This React component `App` uses the `useQuery` hook to fetch the `IS_LOGGED_IN` query.  It renders either the `Pages` component if the user is logged in, or the `Login` component if the user is not logged in, based on the value of the `isLoggedIn` field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nfunction App() {\n  const { data } = useQuery(IS_LOGGED_IN);\n  return data.isLoggedIn ? <Pages /> : <Login />;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Context in Apollo Links - JavaScript\nDESCRIPTION: This example demonstrates how to manage the context object within a link chain. The `timeStartLink` sets a `start` timestamp in the context. The `logTimeLink` then calculates the duration of the operation using the `start` timestamp retrieved from the context and logs it to the console.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink, from } from '@apollo/client';\n\nconst timeStartLink = new ApolloLink((operation, forward) => {\n  operation.setContext({ start: new Date() });\n  return forward(operation);\n});\n\nconst logTimeLink = new ApolloLink((operation, forward) => {\n  return forward(operation).map((data) => {\n    // data from a previous link\n    const time = new Date() - operation.getContext().start;\n    console.log(`operation ${operation.operationName} took ${time} to complete`);\n    return data;\n  })\n});\n\nconst additiveLink = from([\n  timeStartLink,\n  logTimeLink\n]);\n\n```\n\n----------------------------------------\n\nTITLE: Conditional Field Truncation via Args in Read Function - Apollo Client TypeScript\nDESCRIPTION: This code configures a read function for the 'name' field on 'Person' type that conditionally truncates the string if a 'maxLength' argument is provided. Function signature demonstrates TypeScript typing and uses object destructuring for args. Dependencies: Apollo Client with GraphQL schema supporting field arguments. Inputs include the potential cached value and the args object; output is truncated or full name string. Limitation: only supports substring truncation based on numeric maxLength.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Person: {\n      fields: {\n        // If a field's TypePolicy would only include a read function,\n        // you can optionally define the function like so, instead of\n        // nesting it inside an object as shown in the previous example.\n        name(name: string, { args }) {\n          if (args && typeof args.maxLength === \"number\") {\n            return name.substring(0, args.maxLength);\n          }\n          return name;\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Optimistic Response with Mutations in Apollo Client\nDESCRIPTION: This code shows how to use the `optimisticResponse` option with mutations in Apollo Client.  The `optimisticResponse` allows you to update the UI with a simulated result of the mutation before it completes.  This helps to make the UI feel more responsive. Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent, and a GraphQL mutation definition with `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_36\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction MyComponent({ newText, mutate }) {\n  return (\n    <button\n      onClick={() => {\n        mutate({\n          variables: {\n            text: newText,\n          },\n          // The optimistic response has all of the fields that are included in\n          // the GraphQL mutation document below.\n          optimisticResponse: {\n            createTodo: {\n              id: -1, // A temporary id. The server decides the real id.\n              text: newText,\n              completed: false,\n            },\n          },\n        });\n      }}\n    >\n      Add Todo\n    </button>\n  );\n}\n\nexport default graphql(gql`\n  mutation CreateTodo ($text: String!) {\n    createTodo(text: $text) {\n      id\n      text\n      completed\n    }\n  }\n`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Resolving @client Fields from Cache in React Application\nDESCRIPTION: This example demonstrates how to use @client fields in Apollo Client that resolve directly from the cache without local resolvers. It creates a simple login check where the isLoggedIn state is written to and read from the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  ApolloClient,\n  InMemoryCache,\n  HttpLink,\n  ApolloProvider,\n  useQuery,\n  gql\n} from \"@apollo/client\";\n\nimport Pages from \"./pages\";\nimport Login from \"./pages/login\";\n\nconst cache = new InMemoryCache();\nconst client = new ApolloClient({\n  cache,\n  link: new HttpLink({ uri: \"http://localhost:4000/graphql\" }),\n  resolvers: {},\n});\n\nconst IS_LOGGED_IN = gql`\n  query IsUserLoggedIn {\n    isLoggedIn @client\n  }\n`;\n\ncache.writeQuery({\n  query: IS_LOGGED_IN,\n  data: {\n    isLoggedIn: !!localStorage.getItem(\"token\"),\n  },\n});\n\nfunction App() {\n  const { data } = useQuery(IS_LOGGED_IN);\n  return data.isLoggedIn ? <Pages /> : <Login />;\n}\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>,\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Persisted Query IDs from Manifest (javascript)\nDESCRIPTION: Demonstrates use of the generatePersistedQueryIdsFromManifest utility to load and parse a persisted query manifest. The loadManifest option should return a Promise resolving to the manifest, typically using a dynamic import to prevent bundling sensitive configuration in production builds.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\ngeneratePersistedQueryIdsFromManifest({\n  loadManifest: () => import(\"./path/to/persisted-query-manifest.json\"),\n})\n```\n\n----------------------------------------\n\nTITLE: Composing Synchronous-like Asynchronous Reads with Reactive Variables in Apollo Client JavaScript\nDESCRIPTION: This advanced JavaScript snippet configures InMemoryCache with a field policy for Person.isInCart utilizing reactive variables for on-demand, almost asynchronous data updates. The custom read function sets up a reactive variable in the storage object and asynchronously updates it using setTimeout based on localStorage. Dependencies: Apollo Client, access to localStorage, and a makeVar utility for reactive variables. Key parameters: variables.productId and storage.var. The output is a boolean value from the reactive variable, providing a way for the field to update after an async operation without blocking UI rendering. Limitation: setTimeout introduces non-determinism and the approach should only be used if immediate consistency is not required.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew InMemoryCache({\n  typePolicies: {\n    Person: {\n      fields: {\n        isInCart: {\n          read(_, { variables, storage }) {\n            if (!storage.var) {\n              storage.var = makeVar(false);\n              setTimeout(() => {\n                storage.var(\n                  localStorage.getItem('CART').includes(\n                    variables.productId\n                  )\n                );\n              }, 100);\n            }\n            return storage.var();\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Lazily Registering a Fragment in a Component File\nDESCRIPTION: Example of lazily registering a fragment with the shared registry when a component module is loaded, allowing the fragment to be referenced by name.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_11\n\nLANGUAGE: jsx\nCODE:\n```\nimport { gql } from \"@apollo/client\";\nimport { fragmentRegistry } from \"./fragmentRegistry\";\n\n// Define the fragment outside the component to ensure it gets registered when this module is loaded.\nconst ITEM_FRAGMENT = gql`\n  fragment ItemFragment on Item {\n    # ...\n  }\n`\n\nfragmentRegistry.register(ITEM_FRAGMENT);\n\nfunction TodoItem() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect skip usage with default value - TypeScript\nDESCRIPTION: Illustrates an incorrect way to use the `skip` option with `useSuspenseQuery` and a default value, which is not recommended.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useSuspenseQuery(query, {\n  variables: { id: id || 0 },\n  skip: !id\n});\n```\n\n----------------------------------------\n\nTITLE: Define GraphQL Query for Login Status (GQL, JS)\nDESCRIPTION: Defines a GraphQL query `IS_LOGGED_IN` to fetch the login status from the local state using the `@client` directive.  The `isLoggedIn` field is designated as a client-side only field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst IS_LOGGED_IN = gql`\n  query IsUserLoggedIn {\n    isLoggedIn @client\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Unmasking Fragment Data Using the @unmask Directive in Apollo Client (GraphQL)\nDESCRIPTION: This GraphQL query illustrates the use of the @unmask directive with a fragment spread, causing the fields defined in PostFragment to be included unmasked in the operation result. Dependencies: Apollo Client configured for data masking, with @unmask directive support. Input: GraphQL query; Output: unmasked fragment data for posts. Only fragments marked with @unmask will be unmasked.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_48\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery GetPosts {\n  posts {\n    id\n    ...PostFragment @unmask\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Data Masking in ApolloClient Initialization - TypeScript\nDESCRIPTION: This snippet demonstrates how to enable the data masking feature when instantiating ApolloClient in a TypeScript-based application. To use data masking, ensure that Apollo Client is installed and imported, and then set the 'dataMasking' option to 'true' within the ApolloClient configuration object. Other standard ApolloClient options (like uri, cache, etc.) should also be specified as needed. The expected input is a configuration object including 'dataMasking: true'; the output is an ApolloClient instance enforcing field-level masking. This configuration works in applications using colocated fragments for better modularization. Limitation: Ensure Apollo Client version supports the 'dataMasking' option; older versions will not recognize it.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew ApolloClient({\n  dataMasking: true,\n  // ... other options\n});\n```\n\n----------------------------------------\n\nTITLE: Define a GraphQL query using gql\nDESCRIPTION: Defines a GraphQL query named `GET_LOCATIONS` using the `gql` template literal.  This query retrieves a list of locations with their `id`, `name`, `description`, and `photo` properties.  This query is later used with the `useQuery` hook to fetch the data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst GET_LOCATIONS = gql`\n  query GetLocations {\n    locations {\n      id\n      name\n      description\n      photo\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Rendering Partial Data with useSuspenseQuery in React/TypeScript\nDESCRIPTION: This example demonstrates how to use the returnPartialData option with useSuspenseQuery to immediately render partial data from the cache without suspending. The component displays available data (the dog's name) while fetching the complete data in the background.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\ninterface PartialData {\n  dog: {\n    id: string;\n    name: string;\n  };\n}\n\nconst PARTIAL_GET_DOG_QUERY: TypedDocumentNode<\n  PartialData,\n  Variables\n> = gql`\n  query GetDog($id: String) {\n    dog(id: $id) {\n      id\n      name\n    }\n  }\n`;\n\n// Write partial data for Buck to the cache\n// so it is available when Dog renders\nclient.writeQuery({\n  query: PARTIAL_GET_DOG_QUERY,\n  variables: { id: \"1\" },\n  data: { dog: { id: \"1\", name: \"Buck\" } },\n});\n\nfunction App() {\n  const client = useApolloClient();\n\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog id=\"1\" />\n    </Suspense>\n  );\n}\n\nfunction Dog({ id }: DogProps) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { id },\n    returnPartialData: true,\n  });\n\n  return (\n    <>\n      <div>Name: {data?.dog?.name}</div>\n      <div>Breed: {data?.dog?.breed}</div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useFragment Hook with Masked Data in React (JSX)\nDESCRIPTION: This React component uses the `useFragment` hook to access masked fragment data after enabling data masking. It destructures the returned object to obtain the unmasked `data` and completeness indicator. Required dependencies are React and the `useFragment` hook from Apollo Client. Props must include a `post` object; outputs are controlled access to fragment fields via `data`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_68\n\nLANGUAGE: JSX\nCODE:\n```\nfunction PostDetails({ post }) {\n  const { data, complete } = useFragment({\n    fragment: POST_DETAILS_FRAGMENT,\n    from: post,\n  })\n\n  // ... use `data` instead of `post`\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Named Fragments with InMemoryCache\nDESCRIPTION: Setting up a fragment registry with the Apollo Client InMemoryCache to allow referencing fragments by name in queries and cache operations.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nimport { ApolloClient, gql, InMemoryCache } from \"@apollo/client\";\nimport { createFragmentRegistry } from \"@apollo/client/cache\";\n\nconst client = new ApolloClient({\n  uri: \"http://localhost:4000/graphql\",\n  cache: new InMemoryCache({\n    fragments: createFragmentRegistry(gql`\n      fragment ItemFragment on Item {\n        id\n        text\n      }\n    `)\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query with Named Operation\nDESCRIPTION: This snippet demonstrates the importance of naming GraphQL operations to improve debugging, readability, and analytics in Apollo GraphOS Studio. It contrasts a named query with an anonymous one, highlighting best practices for operation naming.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/operation-best-practices.mdx#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\n# Recommended ✅\nquery GetBooks {\n  books {\n    title\n  }\n}\n\n# Not recommended ❌\nquery {\n  books {\n    title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using skipToken for Conditional Background Queries with Apollo Client in JavaScript\nDESCRIPTION: This snippet demonstrates how to conditionally execute a background query using Apollo Client's `useBackgroundQuery` hook in React, leveraging `skipToken` to prevent execution if a condition (such as presence of an ID) is not met. This avoids extra network operations and ensures components remain in sync with query state. Dependencies: `@apollo/client` and the relevant GraphQL query. Inputs are the dynamic parameters evaluated for execution; the output is a query reference if executed. This pattern supersedes the legacy `skip` prop for Suspense hooks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_16\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { skipToken, useBackgroundQuery } from '@apollo/client';\nconst [queryRef] = useBackgroundQuery(\n  query,\n  id ? { variables: { id } } : skipToken\n);\n\n```\n\n----------------------------------------\n\nTITLE: Using `gql` Function to Define GraphQL Query in TypeScript\nDESCRIPTION: Demonstrates how to define a GraphQL query with the generated `gql` function, enabling type-safe hooks like `useQuery`. The example fetches rocket inventory data and maps results to UI components.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport React from 'react';\nimport { useQuery } from '@apollo/client';\n\nimport { gql } from '../src/__generated__/gql';\n\nconst GET_ROCKET_INVENTORY = gql(/* GraphQL */ `\n  query GetRocketInventory($year: Int!) {\n    rocketInventory(year: $year) {\n      id\n      model\n      year\n      stock\n    }\n  }\n`);\n\nexport function RocketInventoryList() {\n  const { loading, data } = useQuery(\n    GET_ROCKET_INVENTORY,\n    { variables: { year: 2019 } }\n  );\n  return (\n    <div>\n      <h3>Available Inventory</h3>\n      {loading ? (\n        <p>Loading ...</p>\n      ) : (\n        <table>\n          <thead>\n            <tr>\n              <th>Model</th>\n              <th>Stock</th>\n            </tr>\n          </thead>\n          <tbody>\n            {data && data.rocketInventory.map(inventory => (\n              <tr>\n                <td>{inventory.model}</td>\n                <td>{inventory.stock}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      )}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Incrementally Loading Data with @defer in GraphQL\nDESCRIPTION: Demonstrates applying the `@defer` directive (available as a preview in Apollo Client >= 3.7.0) to a fragment within a GraphQL query. This allows slower fields (`friends`) contained within the deferred fragment to be streamed incrementally after the initial faster fields (`id`, `firstName`, `lastName`) are received. Note that additional configuration might be needed for React Native.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery PersonQuery($personId: ID!) {\n  person(id: $personId) {\n    # Basic fields (fast)\n    id\n    firstName\n    lastName\n\n    # Friend fields (slower)\n    ... @defer {\n      friends {\n        id\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering local toggleTodo mutation from a React component with Apollo Client\nDESCRIPTION: This React component uses Apollo Client's `useMutation` hook to trigger the local `toggleTodo` mutation. The mutation is defined with the `@client` directive, indicating it is handled by local resolvers. The component responds to clicks to toggle the Todo item's completion state visually.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport React from \"react\";\nimport { gql, useMutation } from \"@apollo/client\";\n\nconst TOGGLE_TODO = gql`\n  mutation ToggleTodo($id: Int!) {\n    toggleTodo(id: $id) @client\n  }\n`;\n\nfunction Todo({ id, completed, text }) {\n  const [toggleTodo] = useMutation(TOGGLE_TODO, { variables: { id } });\n  return (\n    <li\n      onClick={toggleTodo}\n      style={{\n        textDecoration: completed ? \"line-through\" : \"none\",\n      }}\n    >\n      {text}\n    </li>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Codegen for Masked Output with typescript-operations Plugin (TypeScript)\nDESCRIPTION: This configuration demonstrates how to generate masked TypeScript types using GraphQL Codegen's typescript-operations plugin. The config object enables inline fragment masking and sets up the apolloUnmask directive support. Dependencies: @graphql-codegen/cli, @graphql-codegen/typescript-operations v4.4.0+. Input: codegen configuration file; Output: generated types that honor fragment masking settings. Limitations: Only works for GraphQL Codegen v4.4.0 or later, and needs proper plugin installation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_53\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst config: CodegenConfig = {\n  // ...\n  generates: {\n    \"path/to/types.ts\": {\n      plugins: [\"typescript-operations\"],\n      config: {\n        // ...\n        inlineFragmentTypes: \"mask\",\n        customDirectives: {\n          apolloUnmask: true\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a New 'id' Field AST Node in TypeScript\nDESCRIPTION: Defines an AST node object representing a GraphQL field with the name 'id'. This plain object follows the structure expected by graphql-js based on the Kind enum and is intended for use when adding new selections to a field's selectionSet. No dependencies beyond 'graphql-js' types are required for construction.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst idField = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: 'id',\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Typing Higher-Order Components with Props-Driven Options in TypeScript\nDESCRIPTION: An enhanced example showing how to type the props passed into a HOC wrapper to ensure that query variables used in options have correct type definitions. This improves type safety when passing variables from parent components, and helps catch errors. Uses ChildDataProps with typed variables for strong typing of input props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_10\n\nLANGUAGE: TSX\nCODE:\n```\nimport React from \"react\";\nimport { ChildDataProps, graphql } from \"@apollo/react-hoc\";\n\nimport { gql, GetCharacterQuery, GetCharacterQueryVariables } from '../src/gql';\n\nconst HERO_QUERY = gql(/* GraphQL */ `\n  query GetCharacter($episode: Episode!) {\n    hero(episode: $episode) {\n      name\n      id\n      friends {\n        name\n        id\n        appearsIn\n      }\n    }\n  }\n`);\n\ntype ChildProps = ChildDataProps<GetCharacterQueryVariables, GetCharacterQuery, GetCharacterQueryVariables>;\n\nconst withCharacter = graphql<\n  GetCharacterQueryVariables,\n  GetCharacterQuery,\n  GetCharacterQueryVariables,\n  ChildProps\n>(HERO_QUERY, {\n  // highlight-start\n  options: ({ episode }) => ({\n    variables: { episode }\n  }),\n  // highlight-end\n});\n\nexport default withCharacter(({ data: { loading, hero, error } }) => {\n  if (loading) return <div>Loading</div>;\n  if (error) return <h1>ERROR</h1>;\n  return ...// actual component with data;\n});\n```\n\n----------------------------------------\n\nTITLE: Cloning Apollo Client Repository using Shell\nDESCRIPTION: This shell command clones the official Apollo Client GitHub repository, which is required for accessing the provided codemod scripts. There are no specific input parameters beyond the repository URL and it creates a local copy of the entire repository for further operations.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_63\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/apollographql/apollo-client.git\n```\n\n----------------------------------------\n\nTITLE: Serializing Request Bodies with bodySerializer in REST Mutation (Apollo Client, GraphQL & TypeScript)\nDESCRIPTION: This set of snippets demonstrates two approaches to serializing the request body of a REST mutation using either a serialization function (formSerializer) or a named serializer (\"xml\") registered in RestLink. GraphQL side leverages the bodySerializer directive, and TypeScript defines a typical serializer that converts input to FormData and sets headers. Requires Apollo Client, apollo-link-rest, and a bodySerializers configuration. Input: typed mutation variables, possibly a serialization function. Output: published post or feed updates with id/title.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_27\n\nLANGUAGE: GraphQL\nCODE:\n```\nmutation EncryptedForm(\n  $input: PublishablePostInput!,\n  $formSerializer: any\n) {\n  publishedPost: publish(input: $input)\n    @rest(\n      type: \"Post\",\n      path: \"/posts/new\",\n      method: \"POST\",\n      bodySerializer: $formSerializer\n    ) {\n      id\n      title\n    }\n\n  publishRSS(input: $input)\n    @rest(\n      type: \"Post\",\n      path: \"/feed\",\n      method: \"POST\",\n      bodySerializer: \"xml\"\n    )\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst formSerializer = (data: any, headers: Headers) => {\n  const formData = new FormData();\n  for (let key in data) {\n    if (data.hasOwnProperty(key)) {\n      formData.append(key, data[key]);\n    }\n  }\n\n  headers.set('Content-Type', 'application/x-www-form-urlencoded');\n\n  return {body: formData, headers};\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst restLink = new RestLink({\n  ...otherOptions,\n  bodySerializers: {\n    xml: xmlSerializer\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Typing `useSubscription` Hook with Generated Types in TypeScript\nDESCRIPTION: Demonstrates how to define a subscription with the generated `gql` function, and type the hook's data and loading state for real-time updates within a React component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ...\nconst LATEST_NEWS = gql(/* GraphQL */ `\n  subscription getLatestNews {\n    latestNews {\n      content\n    }\n  }\n`);\n\nexport function LatestNews() {\n  const { loading, data } = useSubscription(LATEST_NEWS);\n  return (\n    <div>\n      <h5>Latest News</h5>\n      <p>{loading ? 'Loading...' : data!.latestNews.content}</p>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Querying local state with GraphQL and Apollo Client React hooks\nDESCRIPTION: This code illustrates how to query local state data by adding `@client` directives in the GraphQL query. The `useQuery` hook fetches local data such as `todos` and `visibilityFilter` from the cache or local resolvers, enabling React components to display current local state without server communication.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport React from \"react\";\nimport { gql, useQuery } from \"@apollo/client\";\n\nimport Todo from \"./Todo\";\n\nconst GET_TODOS = gql`\n  query GetTodos {\n    todos @client {\n      id\n      completed\n      text\n    }\n    visibilityFilter @client\n  }\n`;\n\nfunction TodoList() {\n  const { data: { todos, visibilityFilter } } = useQuery(GET_TODOS);\n  return (\n    <ul>\n      {getVisibleTodos(todos, visibilityFilter).map(todo => (\n        <Todo key={todo.id} {...todo} />\n      ))}\n    </ul>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Fields for Local Resolution with @client in GraphQL\nDESCRIPTION: Shows how to use the `@client` directive in an Apollo Client GraphQL query to mark the `description` field for local resolution. This field will not be requested from the GraphQL server and can be resolved using client-side logic or the Apollo Client cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nquery LaunchDetails($launchId: ID!) {\n  launch(id: $launchId) {\n    site\n    rocket {\n      type\n      # resolved locally on the client,\n      # removed from the request to the server\n      description @client\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mutation Data Masking with client.mutate Method in Apollo Client (JavaScript)\nDESCRIPTION: This snippet demonstrates direct mutation via Apollo Client's client.mutate method, where the data received is masked in the main promise result, but data within update, refetchQueries, and updateQueries handlers is unmasked. Dependencies: @apollo/client, configured client and mutation query. Inputs: mutation execution; Outputs: masked data to callers, unmasked data within cache update utilities.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_44\n\nLANGUAGE: JavaScript\nCODE:\n```\n// data is masked\nconst { data } = await client.mutate({\n  update: (cache, { data }) => {\n    // data is unmasked\n  },\n  refetchQueries: ({ data }) => {\n    // data is unmasked\n  },\n  updateQueries: {\n    ExampleQuery: (previous, { mutationResult }) => {\n      // mutationResult is unmasked\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Exporting Nested Apollo Client @client Fields as Variables in JavaScript\nDESCRIPTION: Illustrates exporting a specific field (`authorId`) from a nested object (`currentAuthor`) fetched via `@client` to use as a variable (`authorId`) for another field (`postCount`) in the same operation using `@export(as: \"authorId\")`. Involves Apollo Client setup, cache pre-population with a nested structure, and the combined GraphQL query definition. Dependencies include `@apollo/client`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, gql } from '@apollo/client';\n\nconst query = gql`\n  query CurrentAuthorPostCount($authorId: Int!) {\n    currentAuthor @client {\n      name\n      authorId @export(as: \"authorId\")\n    }\n    postCount(authorId: $authorId)\n  }\n`;\n\nconst cache = new InMemoryCache();\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: 'http://localhost:4000/graphql' }),\n  cache,\n  resolvers: {},\n});\n\ncache.writeQuery({\n  query: gql`\n    query GetCurrentAuthor {\n      currentAuthor {\n        name\n        authorId\n      }\n    }\n  `,\n  data: {\n    currentAuthor: {\n      __typename: 'Author',\n      name: 'John Smith',\n      authorId: 12345,\n    },\n  },\n});\n\n// ... run the query using client.query, the <Query /> component, etc.\n```\n\n----------------------------------------\n\nTITLE: Fixing Query Deduplication Using Printed Query\nDESCRIPTION: This snippet improves query deduplication by caching printed GraphQL documents, optimizing repeated query operations for better performance.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_43\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Setting Apollo Client Data Masking Mode via Declaration Merging\nDESCRIPTION: Demonstrates how to use TypeScript declaration merging to extend the `@apollo/client` package's `DataMasking` interface. This allows you to set a default data masking `mode` (e.g., `\"preserveTypes\"`) for your entire Apollo Client application, customizing how masked types are handled unless overridden.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_55\n\nLANGUAGE: TypeScript\nCODE:\n```\n// This import is necessary to ensure all Apollo Client imports\n// are still available to the rest of the application.\nimport '@apollo/client';\n\ndeclare module \"@apollo/client\" {\n  interface DataMasking {\n    mode: \"preserveTypes\";\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating possibleTypes with GraphQL Codegen\nDESCRIPTION: This code provides a snippet for generating `possibleTypes` configurations using GraphQL Codegen and the `fragment-matcher` plugin. It instructs the user to configure GraphQL Codegen to generate a JSON file that contains `possibleTypes` data.  The user is then instructed on how to import the generated JSON module within their codebase.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport possibleTypes from './path/to/possibleTypes.json';\n\nconst cache = new InMemoryCache({\n  possibleTypes,\n});\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Configuration Example for RestLink in JavaScript\nDESCRIPTION: Provides a detailed example of initializing `RestLink` with multiple options, including endpoint mapping, default URI, custom fetch implementation (`cross-fetch`), default headers, credentials policy, field name normalization/denormalization (using `camelcase` and `snake-case`), type patching, and a default body serializer for form data. Requires `cross-fetch`, `camelcase`, `snake-case`, and `RestLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_20\n\nLANGUAGE: js\nCODE:\n```\nimport fetch from 'cross-fetch';\nimport * as camelCase from 'camelcase';\nimport * as snake_case from 'snake-case';\n\nconst link = new RestLink({\n  endpoints: { github: 'github.com' },\n  uri: 'api.com',\n  customFetch: fetch,\n  headers: {\n    \"Content-Type\": \"application/json\"\n  },\n  credentials: \"same-origin\",\n  fieldNameNormalizer: (key: string) => camelCase(key),\n  fieldNameDenormalizer: (key: string) => snake_case(key),\n  typePatcher: {\n    Post: ()=> {\n      bodySnippet...\n    }\n  },\n  defaultSerializer: (data: any, headers: Headers) => {\n    const formData = new FormData();\n    for (let key in data) {\n      formData.append(key, data[key]);\n    }\n    headers.set(\"Content-Type\", \"x-www-form-encoded\")\n    return {data: formData, headers};\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Importing React Hooks in Apollo Client 3.0\nDESCRIPTION: Shows how to import common React Hooks like `ApolloProvider`, `useQuery`, and `useApolloClient` directly from the main `@apollo/client` package entry point. This consolidation replaces the need for the separate `@apollo/react-hooks` package.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloProvider, useQuery, useApolloClient } from '@apollo/client'\n```\n\n----------------------------------------\n\nTITLE: Using useQueryRefHandlers Hook - JavaScript\nDESCRIPTION: Shows how to use the `useQueryRefHandlers` hook to retrieve `refetch` and `fetchMore` functions for a given `queryRef`. This hook is particularly helpful when the handlers are not directly accessible from the component that created the `queryRef`, such as when using `createQueryPreloader` or when the `queryRef` is created in a different component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst MyComponent({ queryRef }) {\n  const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Data Prop from GraphQL Query\nDESCRIPTION: This snippet illustrates how to access the `data` prop provided by the `graphql()` HOC. The `data` prop contains the results of the GraphQL query as well as utility properties like `loading` and `error`. The component expects a `data` prop to be injected by the `graphql()` HOC.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nrender() {\n  const { data } = this.props; // <- The `data` prop.\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Apollo Client Using Main and Deep Entrypoints - JavaScript\nDESCRIPTION: This snippet illustrates two styles for importing Apollo Client modules: the 'main entrypoint' imports all needed modules from the @apollo/client package, while the 'deep entrypoint' imports individual modules from their specific paths. No dependencies beyond Apollo Client are necessary. Inputs are ESM import statements and outputs are the properly imported modules for use in your application. Choice of import style may affect bundle size depending on your bundler's configuration.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// \"main entrypoint import\" style\nimport { ApolloClient, InMemoryCache, useQuery } from \"@apollo/client\";\n\n// \"deep entrypoint import\" style\nimport { ApolloClient, InMemoryCache } from \"@apollo/client/core\";\nimport { useQuery } from \"@apollo/client/react/hooks\";\n```\n\n----------------------------------------\n\nTITLE: Defining Per-Endpoint Response Transformers with RestLink in JavaScript\nDESCRIPTION: Demonstrates configuring `RestLink` with multiple endpoints, each having its own `uri` and a custom `responseTransformer` function. This allows tailored processing of responses based on the specific REST endpoint being called (e.g., extracting data differently for '/v1' and '/v2'). Requires `RestLink` from Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_17\n\nLANGUAGE: js\nCODE:\n```\nconst link = new RestLink({\n  endpoints: {\n    v1: {\n      uri: '/v1',\n      responseTransformer: async response => response.data,\n    },\n    v2: {\n      uri: '/v2',\n      responseTransformer: async (response, typeName) => response[typeName],\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Client-Side GraphQL Subscription - JavaScript\nDESCRIPTION: This snippet defines the client-side GraphQL subscription query using the `gql` tag. It specifies the `OnCommentAdded` subscription operation, includes a `$postID` variable, and selects the `id` and `content` fields from the `commentAdded` root field result. This is the standard JavaScript definition.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst COMMENTS_SUBSCRIPTION = gql`\n  subscription OnCommentAdded($postID: ID!) {\n    commentAdded(postID: $postID) {\n      id\n      content\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Retaining Cache Objects from Garbage Collection (Apollo Client JavaScript)\nDESCRIPTION: Invokes the retain method on InMemoryCache to prevent a specific object (and its children) identified by its id from being removed during garbage collection, regardless of reachability. Useful when certain cache data should persist through manual retention. Only requires the cache and the target cache object ID as parameters.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache.retain('my-object-id');\n```\n\n----------------------------------------\n\nTITLE: useFragment Hook Signature - TypeScript\nDESCRIPTION: This TypeScript snippet conveys the function signature for the useFragment React hook, which provides a live, reactive binding to cached fragment data managed by Apollo Client. It takes options including the cache reference (from), GraphQL fragment document, fragmentName (optional), variables, optimistic flag, and a flag for returning partial data. Input is the options object; output is a UseFragmentResult with the current state for the fragment. Dependencies: @apollo/client (>=3.8.0), TypeScript. UseFragment does not fetch data from the network; it only reads from the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useFragment<\n  TData = any,\n  TVars = OperationVariables\n>({\n  from: string | StoreObject | Reference;\n  fragment: DocumentNode | TypedDocumentNode<TData, TVars>;\n  fragmentName?: string;\n  optimistic?: boolean;\n  variables?: TVars;\n  returnPartialData?: boolean;\n}): UseFragmentResult<TData> {}\n```\n\n----------------------------------------\n\nTITLE: Manually Merging FetchMore Results with updateQuery in TypeScript\nDESCRIPTION: Demonstrates how to use the `updateQuery` option within a `fetchMore` call to manually merge the results of a subsequent fetch into the previous data for a query. This approach is necessary when you need custom merging logic, or when using `fetchMore` with a `no-cache` fetch policy where field policy `merge` functions are ignored. It shows how to handle the previous data's immutability by creating a copy before merging.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/core-api.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nfetchMore({\n  variables: { offset: data.feed.length },\n  updateQuery(previousData, { fetchMoreResult, variables: { offset }}) {\n    // Slicing is necessary because the existing data is\n    // immutable, and frozen in development.\n    const updatedFeed = previousData.feed.slice(0);\n    for (let i = 0; i < fetchMoreResult.feed.length; ++i) {\n      updatedFeed[offset + i] = fetchMoreResult.feed[i];\n    }\n    return { ...previousData, feed: updatedFeed };\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: HttpLink Constructor Options and Usage (JavaScript)\nDESCRIPTION: This documentation details the options available for configuring HttpLink instances, including setting the server URI, headers, fetch implementation, credentials, and request method preferences. It emphasizes providing custom fetch implementations for environments lacking native fetch support.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst link = new HttpLink({ uri: \"/graphql\" });\n```\n\n----------------------------------------\n\nTITLE: Providing a Default Value for Cached Field with Read Function - Apollo Client TypeScript\nDESCRIPTION: This snippet demonstrates configuring a 'read' function for the 'name' field on 'Person' to return 'UNKNOWN NAME' if no cached value is available. The approach uses default parameters in the TypeScript function to enforce fallback behavior. Required dependencies are Apollo Client and TypeScript. Inputs are any existing cached value for 'name'; output is either the value or the fallback string. No special constraints except that the field policy must be included in InMemoryCache configuration.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Person: {\n      fields: {\n        name: {\n          // highlight-start\n          read(name = \"UNKNOWN NAME\") {\n            return name;\n          }\n          // highlight-end\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client for React Native\nDESCRIPTION: Command to install Apollo Client and GraphQL packages using npm for a React Native application.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/react-native.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client graphql\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client and REST Link Dependencies\nDESCRIPTION: Installs the necessary packages (`@apollo/client`, `apollo-link-rest`, `graphql`, `qs`) using npm to enable REST API integration with Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @apollo/client apollo-link-rest graphql qs\n```\n\n----------------------------------------\n\nTITLE: ApolloClient Constructor with Resolvers and TypeDefs - JS\nDESCRIPTION: This code shows how to instantiate an ApolloClient with resolvers and typeDefs during construction. The `resolvers` option is used to provide a map of resolver functions, and the `typeDefs` option is used to provide a client-side schema. Dependencies include ApolloClient and InMemoryCache from '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  resolvers: { ... },\n  typeDefs: { ... },\n});\n```\n\n----------------------------------------\n\nTITLE: Package.json Script Configuration for GraphQL Code Generation\nDESCRIPTION: Adds npm scripts to run 'graphql-codegen' for generating TypeScript types and code based on project configuration, enabling automation of type generation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"scripts\": {\n    \"compile\": \"graphql-codegen\",\n    \"watch\": \"graphql-codegen -w\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client Link Order with RestLink and HttpLink in JavaScript\nDESCRIPTION: Demonstrates the correct chaining order for Apollo Links when using `RestLink` alongside other links like `createHttpLink`, context links (`authLink`), and middleware links (`errorLink`, `retryLink`). `RestLink` should typically appear before terminating links like `httpLink` but after context-setting links. Requires `createHttpLink`, `RestLink`, `ApolloClient`, `InMemoryCache`, `ApolloLink`, and potentially custom links like `authLink`, `errorLink`, `retryLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_22\n\nLANGUAGE: js\nCODE:\n```\nconst httpLink = createHttpLink({ uri: \"server.com/graphql\" });\nconst restLink = new RestLink({ uri: \"api.server.com\" });\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: ApolloLink.from([authLink, restLink, errorLink, retryLink, httpLink])\n  // Note: httpLink is terminating so must be last, while retry & error wrap\n  // the links to their right. State & context links should happen before (to\n  // the left of) restLink.\n});\n```\n\n----------------------------------------\n\nTITLE: Refetching Queries Affected by Cache Updates with Apollo Client in TypeScript\nDESCRIPTION: This snippet shows how to use the updateCache option with client.refetchQueries to evict a specific field from the Apollo Client cache, automatically refetching any queries dependent on that field. The updateCache callback receives the cache object and performs operations like evict. Requires an ApolloClient instance and an understanding of cache API. Inputs: cache field name to evict. Output: queries depending on the evicted field are refetched.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  updateCache(cache) {\n    cache.evict({ fieldName: \"someRootField\" });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Data Masking in Apollo Client Constructor\nDESCRIPTION: Demonstrates how to enable the data masking feature in Apollo Client by setting the `dataMasking` option to `true` within the `ApolloClient` constructor. Enabling this option restricts components' access to data fields that are not explicitly requested in their own queries or fragments.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_33\n\nLANGUAGE: jsx\nCODE:\n```\nconst client = new ApolloClient({\n  dataMasking: true,\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Allowing Early Bail-Out in updateQuery Function in TypeScript\nDESCRIPTION: Shows how the `updateQuery` callback function can return early by returning undefined to bail out of updating the query result. This helps prevent unwanted return values while maintaining type safety. It depends on Apollo Client's ObservableQuery API with TypeScript.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nobservableQuery.updateQuery(\n  (unsafePreviousData, { previousData, complete }) => {\n    if (!complete) {\n      // Bail out of the update by returning early\n      return;\n    }\n\n    // ...\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Registering Custom GraphQL Document Transforms in Apollo Client (TypeScript)\nDESCRIPTION: This snippet shows how to create and register a custom DocumentTransform in Apollo Client, allowing modification of GraphQL queries before cache reads, local state resolution, or network requests. Utilize the DocumentTransform class from @apollo/client and supply a transformation function. The ApolloClient instance consumes the transform via the documentTransform configuration option. Dependencies are @apollo/client. The transform function receives a GraphQL DocumentNode and should return a valid, modified DocumentNode.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { DocumentTransform } from \"@apollo/client\";\n\nconst documentTransform = new DocumentTransform((document) => {\n  // do something with `document`\n  return transformedDocument;\n});\n\nconst client = new ApolloClient({ documentTransform: documentTransform });\n```\n\n----------------------------------------\n\nTITLE: Configuring RestLink with typePatcher for Typename Injection (TypeScript)\nDESCRIPTION: Shows how to use the `typePatcher` option in the `RestLink` constructor to automatically add `__typename` fields to nested objects within REST API responses. This example defines a patcher for the `PlanetPayload` type to add `__typename: \"Planet\"` to each item in the `results` array.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst restLink = new RestLink({\n  uri: '/api',\n  typePatcher: {\n    PlanetPayload: (\n      data: any,\n      outerType: string,\n      patchDeeper: RestLink.FunctionalTypePatcher,\n    ): any => {\n      if (data.results != null) {\n        data.results =\n          data.results.map(planet => ({ __typename: \"Planet\", ...planet }));\n      }\n      return data;\n    },\n    // ... other nested type patchers\n  },\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst restLink = new RestLink({\n  uri: '/api',\n  typePatcher: {\n    PlanetPayload: (\n      data: any,\n      outerType: string,\n      patchDeeper: RestLink.FunctionalTypePatcher,\n    ): any => {\n      if (data.typePatchedResults != null) {\n        data.typePatchedResults =\n          data.typePatchedResults.map(planet => { __typename: \"Planet\", ...planet });\n      }\n      return data;\n    },\n    // ... other nested type patchers\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Importing ApolloProvider in Apollo Client - JavaScript\nDESCRIPTION: This snippet demonstrates how to import the ApolloProvider component from the @apollo/client package for use within a React application. ApolloProvider is required for supplying your ApolloClient instance to the React component tree via React Context. No additional dependencies are required beyond @apollo/client. There are no input or output parameters; it is solely the import statement needed for provider setup.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloProvider } from '@apollo/client';\n```\n\n----------------------------------------\n\nTITLE: Importing the graphql() function from @apollo/client/react/hoc\nDESCRIPTION: The snippet shows how to import the core graphql() higher-order component function from the Apollo Client React HOC package, enabling the creation of components connected to GraphQL queries, mutations, or subscriptions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { graphql } from '@apollo/client/react/hoc';\n```\n\n----------------------------------------\n\nTITLE: Merge with Reusable Helper Function\nDESCRIPTION: Demonstrates the use of a reusable helper function `mergeArrayByField` to define the merge logic for the `authors` field, improving code maintainability. It hides the complexity of the merging process behind a reusable abstraction.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Book: {\n      fields: {\n        authors: {\n          merge: mergeArrayByField<AuthorType>(\"name\"),\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Client State with makeVar in TypeScript\nDESCRIPTION: Illustrates the use of the `makeVar` function to create reactive local variables managed by Apollo Client. Updating these variables can invalidate dependent cache query results, enabling reactive client state. The function is type-safe.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_51\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { makeVar } from \"@apollo/client\";\nconst v = makeVar(123);\nconsole.log(v()); // 123\nconsole.log(v(v() + 1)); // 124\nconsole.log(v()); // 124\nv(\"asdf\"); // TS type error\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client Error Handling with Apollo Link\nDESCRIPTION: This code demonstrates how to create an Apollo Client instance with an error handling link (`onError`) that logs GraphQL and network errors, combined with an HTTP link for sending operations to the server. It allows centralized error logging in the client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/error-handling.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { ApolloClient, HttpLink, InMemoryCache, from } from \"@apollo/client\";\nimport { onError } from \"@apollo/client/link/error\";\n\nconst errorLink = onError(({ graphQLErrors, networkError }) => {\n  if (graphQLErrors)\n    graphQLErrors.forEach(({ message, locations, path }) =>\n      console.log(\n        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`\n      )\n    );\n  if (networkError) console.error(`[Network error]: ${networkError}`);\n});\n\nconst httpLink = new HttpLink({ uri: 'http://localhost:4000/graphql' });\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: from([errorLink, httpLink])\n});\n```\n\n----------------------------------------\n\nTITLE: Defining VoteButtonsFragment\nDESCRIPTION: This snippet defines a GraphQL fragment named `VoteButtonsFragment` using the `gql` tag function. It targets the `FeedEntry` type and specifies the fields `score` and `vote { choice }` to be included in the fragment. This fragment is designed for use in a child component, `VoteButtons.jsx`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const VOTE_BUTTONS_FRAGMENT = gql`\n  fragment VoteButtonsFragment on FeedEntry {\n    score\n    vote {\n      choice\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Directional Composition and removeTypename\nDESCRIPTION: Shows how to integrate `removeTypenameLink` into a link chain that uses directional composition, commonly used with subscriptions and websockets. Dependencies include `from` and `split` from `@apollo/client` and other link components. It ensures that the `__typename` field is removed before `splitLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { from, split } from '@apollo/client';\nimport { removeTypenameFromVariables } from '@apollo/client/link/remove-typename';\n\nconst removeTypenameLink = removeTypenameFromVariables();\n\nconst splitLink = split(\n  ({ query }) => {\n    const definition = getMainDefinition(query);\n    return (\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'subscription'\n    );\n  },\n  wsLink,\n  httpLink,\n);\n\nconst link = from([removeTypenameLink, splitLink]);\n\nconst client = new ApolloClient({\n  link,\n  // ... other options\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client with `name` and `version` for Metrics\nDESCRIPTION: This snippet demonstrates setting the `name` and `version` options in Apollo Client's constructor to enable detailed metrics reporting in Apollo Studio. These values are included in operation headers and traces, aiding client segmentation and performance analysis.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/operation-best-practices.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache(),\n  name: 'MarketingSite',\n  version: '1.2'\n});\n```\n\n----------------------------------------\n\nTITLE: useLoadableQuery Result Tuple (TypeScript)\nDESCRIPTION: Describes the tuple returned by the `useLoadableQuery` hook. It includes a `loadQuery` function, a `queryRef`, and handlers for `fetchMore`, `refetch`, and `reset`.  The `loadQuery` function is used to imperatively load the query and create/update the `queryRef`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n[\n    loadQuery: LoadQueryFunction<TVariables>,\n    queryRef: QueryRef<TData, TVariables> | null,\n    {\n      fetchMore: FetchMoreFunction<TData, TVariables>;\n      refetch: RefetchFunction<TData, TVariables>;\n      reset: ResetFunction;\n    }\n  ]\n```\n\n----------------------------------------\n\nTITLE: useBackgroundQuery Example with Suspense and Cache Reading - JSX\nDESCRIPTION: This snippet demonstrates the useBackgroundQuery hook in a React application with Apollo Client to initiate background GraphQL queries, then read the cached results using useReadQuery in a child component. It integrates ApolloProvider for context, uses Suspense for loading fallback handling, and shows the flow from defining the query, creating the ApolloClient, and connecting components. Dependencies: @apollo/client, react, valid GraphQL schema. Input: None for Parent and Child; output: renders bar value from GraphQL response. Assumes server at http://localhost:4000/graphql exposes 'foo { bar }'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_8\n\nLANGUAGE: JSX\nCODE:\n```\nimport { Suspense } from 'react';\nimport {\n  ApolloClient,\n  InMemoryCache,\n  useBackgroundQuery,\n  useReadQuery,\n} from '@apollo/client';\n\nconst query = gql`\n  foo {\n    bar\n  }\n`;\n\nconst client = new ApolloClient({\n  uri: \"http://localhost:4000/graphql\",\n  cache: new InMemoryCache()\n});\n\nfunction SuspenseFallback() {\n  return <div>Loading...</div>;\n}\n\nfunction Child({ queryRef }) {\n  const { data } = useReadQuery(queryRef);\n\n  return <div>{data.foo.bar}</div>;\n}\n\nfunction Parent() {\n  const [queryRef] = useBackgroundQuery(query);\n\n  return (\n    <Suspense fallback={<SuspenseFallback />}>\n      <Child queryRef={queryRef} />\n    </Suspense>\n  );\n}\n\nfunction App() {\n  return (\n    <ApolloProvider client={client}>\n      <Parent />\n    </ApolloProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypePolicy Inheritance with possibleTypes and typePolicies\nDESCRIPTION: Provides an example setup for InMemoryCache with possibleTypes to support inheritance-like behavior among types, and typePolicies to set default keyFields and field merge functions. Demonstrates how inheritance propagates configurations among schema types, reducing repetition and enhancing cache management. Dependencies include '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  possibleTypes: {\n    Reptile: [\"Snake\", \"Turtle\"],\n    Snake: [\"Python\", \"Viper\", \"Cobra\"],\n    Viper: [\"Cottonmouth\", \"DeathAdder\"],\n  },\n\n  typePolicies: {\n    Reptile: {\n      keyFields: [\"tagId\"],\n      fields: {\n        scientificName: {\n          merge(_, incoming) {\n            return incoming.toLowerCase();\n          },\n        },\n      },\n    },\n    Snake: {\n      fields: {\n        venomous(status = \"unknown\") {\n          return status;\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Incremental Re-rendering of Deferred Queries After Refetch or Skip\nDESCRIPTION: This enhancement allows `useSuspenseQuery` to re-render incrementally after `refetch` or changing `skip` to false, improving user experience by showing data sooner instead of waiting for complete loading.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_39\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Using a Fragment in a GraphQL Query\nDESCRIPTION: Example of including the NameParts fragment in a query that fetches a person's data, demonstrating the spread operator syntax for fragment inclusion.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetPerson {\n  people(id: \"7\") {\n    ...NameParts\n    avatar(size: LARGE)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Masked Fragment with useFragment in Apollo Client (JavaScript)\nDESCRIPTION: This React component defines a reusable GraphQL fragment (CommentFragment) for the Comment type, using Apollo Client's gql and useFragment hook to read masked data. The function expects a comment prop and uses the fragment to query for displayName, createdAt, and content. Dependencies include @apollo/client and proper fragment definition including masking support. Input: comment object; Output: component rendering with masked comment data. Note that data masking restricts fields available to only those specified in the fragment.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_40\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const COMMENT_FRAGMENT = gql`\n  fragment CommentFragment on Comment {\n    postedBy {\n      displayName\n    }\n    createdAt\n    content\n  }\n`\n\nexport default function Comment({ comment }) {\n  const { data, complete } = useFragment({\n    fragment: COMMENT_FRAGMENT,\n    from: comment,\n  });\n\n  // ... render comment details\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client with Persisted Queries (javascript)\nDESCRIPTION: Illustrates how to combine the persisted query link, generated with createPersistedQueryLink and the output from generatePersistedQueryIdsFromManifest, with ApolloClient's HttpLink. This setup ensures queries are sent as operation IDs, reducing network payload and safeguarding against unauthorized operations. Requires @apollo/client and @apollo/persisted-query-lists packages, and an available persisted-query-manifest.json.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { HttpLink, InMemoryCache, ApolloClient } from \"@apollo/client\";\nimport { generatePersistedQueryIdsFromManifest } from \"@apollo/persisted-query-lists\";\nimport { createPersistedQueryLink } from \"@apollo/client/link/persisted-queries\";\n\nconst persistedQueryLink = createPersistedQueryLink(\n  generatePersistedQueryIdsFromManifest({\n    loadManifest: () => import(\"./path/to/persisted-query-manifest.json\"),\n  }),\n);\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: persistedQueriesLink.concat(httpLink),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing withApollo from @apollo/client (JavaScript)\nDESCRIPTION: This snippet imports the `withApollo` function from the `@apollo/client/react/hoc` module. This is the necessary step to use `withApollo` in a React component to access the ApolloClient instance.  It sets up the environment for using the higher-order component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_41\n\nLANGUAGE: javascript\nCODE:\n```\nimport { withApollo } from '@apollo/client/react/hoc';\n```\n\n----------------------------------------\n\nTITLE: Preventing Route Transitions until Query Loaded - TypeScript\nDESCRIPTION: This snippet illustrates how to prevent React Router from transitioning a route until the data is fully loaded using the `toPromise` method of a queryRef. The loader waits for the promise to resolve before navigating.  Requires React Router and Apollo Client.  Requires a GraphQL backend.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nexport async function loader() {\n  const queryRef = await preloadQuery(GET_DOGS_QUERY).toPromise();\n\n  return queryRef;\n}\n\n// You may also return the promise directly from loader.\n// This is equivalent to the above.\nexport async function loader() {\n  return preloadQuery(GET_DOGS_QUERY).toPromise();\n}\n\nexport function RouteComponent() {\n  const queryRef = useLoaderData();\n  const { data } = useReadQuery(queryRef);\n\n  // ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting up Apollo Client with React Native\nDESCRIPTION: Initializes Apollo Client and wraps the root component with ApolloProvider in a React Native application. Configures the client with a GraphQL endpoint and cache implementation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/react-native.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport { AppRegistry } from 'react-native';\nimport { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';\n\n// Initialize Apollo Client\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache()\n});\n\nconst App = () => (\n  <ApolloProvider client={client}>\n    <MyRootComponent />\n  </ApolloProvider>\n);\n\nAppRegistry.registerComponent('MyApplication', () => App);\n```\n\n----------------------------------------\n\nTITLE: Define GraphQL Query (currentUser.graphql)\nDESCRIPTION: Defines a simple GraphQL query named `CurrentUserForLayout` to retrieve the `login` and `avatar_url` fields from the `currentUser` object. This query is intended to be stored in a separate `.graphql` file (`currentUser.graphql`) and imported into application code.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/webpack.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery CurrentUserForLayout {\n  currentUser {\n    login\n    avatar_url\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing the Request Body with bodyKey in a REST Mutation (Apollo Client, GraphQL)\nDESCRIPTION: This GraphQL mutation uses the @rest directive to POST data to an endpoint, specifying a custom request body key via bodyKey. The variable someApiWithACustomBodyKey of type PublishablePostInput! is inserted into the body field instead of the default input. Prerequisites: Apollo Client, apollo-link-rest, and a matching backend expecting the body field. Inputs are input and body; the output includes id and title from the response.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_25\n\nLANGUAGE: GraphQL\nCODE:\n```\nmutation PublishPost(\n  $someApiWithACustomBodyKey: PublishablePostInput!\n) {\n  publishedPost: publish(input: \"Foo\", body: $someApiWithACustomBodyKey)\n    @rest(\n      type: \"Post\"\n      path: \"/posts/{args.input}/new\"\n      method: \"POST\"\n      bodyKey: \"body\"\n    ) {\n    id\n    title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client with RestLink\nDESCRIPTION: Demonstrates how to set up an Apollo Client instance configured with `RestLink` to communicate with a specified REST API endpoint. It imports necessary modules and configures the client with an `InMemoryCache` and the `RestLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\nimport { RestLink } from 'apollo-link-rest';\n\n// Set `RestLink` with your endpoint\nconst restLink = new RestLink({ uri: \"https://swapi.dev/api/\" });\n\n// Setup your client\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: restLink\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Real-Time Data Subscription with data.subscribeToMore() in Apollo Client\nDESCRIPTION: This snippet illustrates how to establish a GraphQL subscription within a React component, managing subscriptions with getDerivedStateFromProps. It involves providing a subscription document, optional variables, and an updateQuery function to merge new subscription data into the existing query result. An unsubscribe function is stored for cleanup.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_23\n\nLANGUAGE: JavaScript\nCODE:\n```\nstatic getDerivedStateFromProps(nextProps, prevState) {\n  if (!nextProps.data.loading) {\n    if (prevState.unsubscribe) {\n      if (prevState.subscriptionParam === nextProps.subscriptionParam) {\n        return null;\n      }\n      prevState.unsubscribe();\n    }\n    return {\n      unsubscribe: nextProps.data.subscribeToMore({\n        document: gql`subscription MySubscription {...}`,\n        variables: {\n          param: nextProps.subscriptionParam,\n        },\n        updateQuery: (previousResult, { subscriptionData, variables }) => {\n          // Perform updates on previousResult with subscriptionData\n          return updatedResult;\n        },\n      }),\n      subscriptionParam: nextProps.subscriptionParam,\n    };\n  }\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema Definition for User Query\nDESCRIPTION: Defines a GraphQL schema for a `Query` type with a `user` field that accepts an `id` argument and returns a `User` object.  This field is used as a simple example of how argument values are used to create cache keys by default in Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  # Returns whichever User object corresponds to `id`\n  user(id: ID!): User\n}\n```\n\n----------------------------------------\n\nTITLE: Removing nextFetchPolicy Support from useSuspenseQuery for Compatibility\nDESCRIPTION: This change removes deprecated and unsupported `nextFetchPolicy` support from `useSuspenseQuery`, streamlining hook API and preventing legacy usage.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_42\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Import useQuery hook and gql\nDESCRIPTION: Imports the `useQuery` hook and `gql` from the `@apollo/client` library. The `useQuery` hook is used to fetch data from a GraphQL API, and `gql` is used to parse GraphQL query strings.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n// Import everything needed to use the `useQuery` hook\nimport { useQuery, gql } from '@apollo/client';\n```\n\n----------------------------------------\n\nTITLE: Provide Link Chain to ApolloClient - JavaScript\nDESCRIPTION: This snippet demonstrates how to provide a composed link chain to the constructor of `ApolloClient`. It imports necessary modules from `@apollo/client` and creates an `ApolloClient` instance with a specified `cache` and `link`. The `link` is set to `directionalLink` which is defined in a previous code snippet.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, HttpLink, InMemoryCache } from '@apollo/client';\nimport { RetryLink } from '@apollo/client/link/retry';\n\nconst directionalLink = new RetryLink().split(\n  (operation) => operation.getContext().version === 1,\n  new HttpLink({ uri: \"http://localhost:4000/v1/graphql\" }),\n  new HttpLink({ uri: \"http://localhost:4000/v2/graphql\" })\n);\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: directionalLink\n});\n\n```\n\n----------------------------------------\n\nTITLE: Typing Higher-Order Components with Apollo react-hoc in TypeScript\nDESCRIPTION: Defines a GraphQL query with gql and uses the graphql HOC from @apollo/react-hoc to create a typed component that passes query result data as props. Shows the usage of ChildDataProps to describe the shape of the data and variables with type parameters. Provides an example of static query variables via options.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_9\n\nLANGUAGE: TSX\nCODE:\n```\nimport React from \"react\";\nimport { ChildDataProps, graphql } from \"@apollo/react-hoc\";\n\nimport { gql, GetCharacterQuery, GetCharacterQueryVariables } from '../src/gql';\n\nconst HERO_QUERY = gql(/* GraphQL */ `\n  query GetCharacter($episode: Episode!) {\n    hero(episode: $episode) {\n      name\n      id\n      friends {\n        name\n        id\n        appearsIn\n      }\n    }\n  }\n`);\n\n\ntype ChildProps = ChildDataProps<{}, GetCharacterQuery, GetCharacterQueryVariables>;\n\nconst withCharacter = graphql<{}, GetCharacterQuery, GetCharacterQueryVariables, ChildProps>(HERO_QUERY, {\n  options: () => ({\n    variables: { episode: \"JEDI\" }\n  })\n});\n\nexport default withCharacter(({ data: { loading, hero, error } }) => {\n  if (loading) return <div>Loading</div>;\n  if (error) return <h1>ERROR</h1>;\n  return ...// actual component with data;\n});\n```\n\n----------------------------------------\n\nTITLE: Query for Book with Author Names\nDESCRIPTION: A GraphQL query example that fetches the `Book` with a list of `authors` and their names.  This query aims to illustrate the merging strategy when an array of non-normalized objects is involved.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_13\n\nLANGUAGE: graphql\nCODE:\n```\nquery BookWithAuthorNames {\n  favoriteBook {\n    isbn\n    title\n    authors {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Index.ts and Index.js: Implementing split link with Apollo Client\nDESCRIPTION: This code initializes both HTTP and WebSocket links, then uses Apollo Client's split function to direct queries/mutations over HTTP and subscriptions over WebSocket. It illustrates combining links based on the operation type for optimized connection management.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { split, HttpLink } from '@apollo/client';\nimport { getMainDefinition } from '@apollo/client/utilities';\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\nimport { createClient } from 'graphql-ws';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:4000/graphql'\n});\n\nconst wsLink = new GraphQLWsLink(createClient({\n  url: 'ws://localhost:4000/subscriptions',\n}));\n\n// The split function takes three parameters:\n//\n// * A function that's called for each operation to execute\n// * The Link to use for an operation if the function returns a \"truthy\" value\n// * The Link to use for an operation if the function returns a \"falsy\"\" value\nconst splitLink = split(\n  ({ query }) => {\n    const definition = getMainDefinition(query);\n    return (\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'subscription'\n    );\n  },\n  wsLink,\n  httpLink,\n);\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { split, HttpLink } from '@apollo/client';\nimport { getMainDefinition } from '@apollo/client/utilities';\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\nimport { createClient } from 'graphql-ws';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:4000/graphql'\n});\n\nconst wsLink = new GraphQLWsLink(createClient({\n  url: 'ws://localhost:4000/subscriptions',\n}));\n\n// The split function takes three parameters:\n//\n// * A function that's called for each operation to execute\n// * The Link to use for an operation if the function returns a \"truthy\" value\n// * The Link to use for an operation if the function returns a \"falsy\"\" value\nconst splitLink = split(\n  ({ query }) => {\n    const definition = getMainDefinition(query);\n    return (\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'subscription'\n    );\n  },\n  wsLink,\n  httpLink,\n);\n```\n\n----------------------------------------\n\nTITLE: Writing a GraphQL Fragment to Apollo Cache (JavaScript)\nDESCRIPTION: The `writeFragment` method allows writing data to the Apollo Client cache in the shape of a GraphQL fragment. It takes an options object containing the fragment, ID of the cached object, and the data to be written.  The method returns a `Reference` to the written object or `undefined` if the write fails.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nclient.writeFragment({\n  id: 'Todo:5',\n  fragment: gql`\n    fragment MyTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Error and Development Message Bundling in Apollo Client (JavaScript)\nDESCRIPTION: This JavaScript snippet explains how to opt in to bundling detailed error and development messages when building applications with Apollo Client. By importing loadErrorMessages and loadDevMessages from the @apollo/client/dev entrypoint and conditionally invoking them based on NODE_ENV, applications can include helpful texts in non-production bundles, improving developer experience at the cost of slightly increased bundle size. No parameters are required; these calls affect Apollo Client's runtime behavior globally.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_21\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { loadErrorMessages, loadDevMessages } from \"@apollo/client/dev\";\nif (process.env.NODE_ENV !== \"production\") {\n  loadErrorMessages();\n  loadDevMessages();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring babel-plugin-graphql-tag\nDESCRIPTION: This shows how to configure the Babel plugin. It adds \"graphql-tag\" to the plugins array within a `.babelrc` file to enable precompilation of GraphQL queries using `babel-plugin-graphql-tag`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"plugins\": [\n    \"graphql-tag\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Refetch with Suspense and Transitions using Apollo Client in TypeScript\nDESCRIPTION: This TypeScript React code demonstrates how to enable refetching of breeds data using Apollo Client's Suspense hooks. The App component initializes background data fetching for breeds via `useBackgroundQuery` and uses React's `useTransition` to indicate pending state during refetch operations. The Dog component fetches a single dog record and passes query references and transition state to a Breeds child component for rendering. Dependencies: `@apollo/client` for hooks (`useSuspenseQuery`, `useBackgroundQuery`, `useReadQuery`) and GraphQL queries, and React for Suspense and transitions. Key inputs are the query IDs; outputs are re-rendered components based on new data and UI state. It requires the full query definitions and type props available elsewhere in the codebase.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Suspense, useTransition } from \"react\";\nimport {\n  useSuspenseQuery,\n  useBackgroundQuery,\n  useReadQuery,\n  gql,\n  TypedDocumentNode,\n  QueryRef,\n} from \"@apollo/client\";\n\nfunction App() {\n  const [isPending, startTransition] = useTransition();\n  const [queryRef, { refetch }] = useBackgroundQuery(\n    GET_BREEDS_QUERY\n  );\n\n  function handleRefetch() {\n    startTransition(() => {\n      refetch();\n    });\n  };\n\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Dog\n        id=\"3\"\n        queryRef={queryRef}\n        isPending={isPending}\n        onRefetch={handleRefetch}\n      />\n    </Suspense>\n  );\n}\n\nfunction Dog({\n  id,\n  queryRef,\n  isPending,\n  onRefetch,\n}: DogProps) {\n  const { data } = useSuspenseQuery(GET_DOG_QUERY, {\n    variables: { id },\n  });\n\n  return (\n    <>\n      Name: {data.dog.name}\n      <Suspense fallback={<div>Loading breeds...</div>}>\n        <Breeds isPending={isPending} queryRef={queryRef} />\n      </Suspense>\n      <button onClick={onRefetch}>Refetch!</button>\n    </>\n  );\n}\n\nfunction Breeds({ queryRef, isPending }: BreedsProps) {\n  const { data } = useReadQuery(queryRef);\n\n  return data.breeds.map(({ characteristics }) =>\n    characteristics.map((characteristic) => (\n      <div\n        style={{ opacity: isPending ? 0.5 : 1 }}\n        key={characteristic}\n      >\n        {characteristic}\n      </div>\n    ))\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Complete React Component Test Using MockedProvider with Defined Mock in JSX\nDESCRIPTION: This snippet shows a complete test file that imports necessary packages, defines a mocked response for GET_DOG_QUERY with the variable 'Buck', and renders the Dog component inside MockedProvider with the mocked responses. It asserts that the loading message is initially visible. This demonstrates how to integrate mocks into tests effectively.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport \"@testing-library/jest-dom\";\nimport { render, screen } from \"@testing-library/react\";\nimport { MockedProvider } from \"@apollo/client/testing\";\nimport { GET_DOG_QUERY, Dog } from \"./dog\";\n\nconst mocks = [\n  {\n    request: {\n      query: GET_DOG_QUERY,\n      variables: {\n        name: \"Buck\"\n      }\n    },\n    result: {\n      data: {\n        dog: { __typename: \"Dog\", id: \"1\", name: \"Buck\", breed: \"bulldog\" }\n      }\n    }\n  }\n];\n\nit(\"renders without error\", async () => {\n  render(\n    <MockedProvider mocks={mocks}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>\n  );\n  expect(await screen.findByText(\"Loading...\")).toBeInTheDocument();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring InMemoryCache with Field Policies\nDESCRIPTION: This snippet configures the InMemoryCache in Apollo Client with field policies that include field directives and arguments when using keyArgs notation. This allows for separate caching of data from different queries with the same field, enhancing cache management. This configuration applies to Apollo Client version 3.5.0 and later.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_46\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: [\"type\", \"@connection\", [\"key\"]],\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating cached data immutably with updateQuery in Apollo Client (JavaScript)\nDESCRIPTION: Fetches cached data matching a GraphQL query and applies an immutable update function to create a new updated cache state. Accepts an options object defining the query, variables, root object id, and flags to control broadcasting and overwriting, as well as a required update callback function that returns the new data or undefined if no change. Returns the updated cached data or null if unsuccessful. This method facilitates safe cache modifications by generating new results without mutating existing cache data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Fetches a Todo object with id 5 and flips its `completed` boolean\ncache.updateQuery({ // options object\n  query: gql`\n    query ReadTodo($id: ID!) {\n      todo(id: $id) {\n        id\n        text\n        completed\n      }\n    }\n  `,\n  variables: {\n    id: 5\n  }\n}, (data) => ({ // update function\n  todo: {\n    ...data.todo,\n    completed: !data.todo.completed\n  }\n}));\n```\n\n----------------------------------------\n\nTITLE: Persist Apollo Client Cache using 'apollo3-cache-persist' with AsyncStorage\nDESCRIPTION: This snippet shows how to persist and rehydrate Apollo Client's InMemoryCache using the 'apollo3-cache-persist' library and AsyncStorage as the storage provider. It initializes the cache, calls persistCache with async handling, and sets up rehydration on startup. Dependencies include '@react-native-async-storage/async-storage', '@apollo/client', and 'apollo3-cache-persist'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { InMemoryCache } from '@apollo/client';\nimport { persistCache } from 'apollo3-cache-persist';\n\nconst cache = new InMemoryCache();\n\npersistCache({\n  cache,\n  storage: AsyncStorage,\n}).then(() => {\n  // Continue setting up Apollo Client as usual.\n})\n```\n\n----------------------------------------\n\nTITLE: Render a component with GraphQL data\nDESCRIPTION: Renders the `DisplayLocations` component within the main `App` component. This will trigger the `useQuery` hook inside `DisplayLocations`, fetching and rendering the location data. The `DisplayLocations` component displays the fetched GraphQL data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function App() {\n  return (\n    <div>\n      <h2>My first Apollo app 🚀</h2>\n      <br/>\n      <DisplayLocations />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GetAllDogs Query JavaScript\nDESCRIPTION: Defines a GraphQL query named `GET_ALL_DOGS` that fetches a list of dogs, including their ID, breed, and display image. This query serves as a simple example of data retrieval using GraphQL, and is used in subsequent examples demonstrating the caching mechanism of Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/why-apollo.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst GET_ALL_DOGS = gql`\n  query GetAllDogs {\n    dogs {\n      id\n      breed\n      displayImage\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js to Disable Development Mode - JavaScript\nDESCRIPTION: This code shows how to adapt next.config.js for Next.js applications to remove Apollo Client's development code using webpack.DefinePlugin. The configuration pushes a DefinePlugin instance setting globalThis.__DEV__ to false, ensuring production builds are optimized. Requires Next.js, webpack and related dependencies. Inputs include the existing next.config.js file and outputs an optimized production build.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// ...\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  webpack(config, { webpack }) {\n    config.plugins.push(\n      new webpack.DefinePlugin({\n        \"globalThis.__DEV__\": false,\n      })\n    );\n    return config;\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n----------------------------------------\n\nTITLE: Invalidating All Fields in Apollo Cache Object using cache.modify in JavaScript\nDESCRIPTION: Demonstrates invalidating all fields within a specific cached object. A modifier function is passed directly to the `fields` option of `cache.modify`. This function receives the field value and a `details` object containing utilities, including `INVALIDATE`. Returning `details.INVALIDATE` invalidates the current field being processed. The `details.fieldName` can be used to identify the field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_15\n\nLANGUAGE: js\nCODE:\n```\ncache.modify({\n  id: cache.identify(myPost),\n  fields(fieldValue, details) {\n    return details.INVALIDATE;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing DogPhoto Component with Polling\nDESCRIPTION: This example demonstrates how to use the `pollInterval` option in `useQuery` for polling. The `DogPhoto` component fetches the current breed's image from the server periodically (every 500 milliseconds in this case).  This ensures near real-time synchronization between the client and server for displayImage.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/queries.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nfunction DogPhoto({ breed }) {\n  const { loading, error, data } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n    pollInterval: 500,\n  });\n\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <img src={data.dog.displayImage} style={{ height: 100, width: 100 }} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Visiting Field Nodes in a GraphQL AST in TypeScript\nDESCRIPTION: This snippet defines a visitor object for the 'visit' function that specifically processes 'Field' nodes in the AST, enabling targeted transformation of query fields. The 'Field' callback is executed for every field encountered during traversal. Input is a GraphQL document AST; no field filtering occurs in this snippet.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst transformedDocument = visit(document, {\n  Field(field) {\n    // ...\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Querying a REST Endpoint with GraphQL\nDESCRIPTION: Shows how to define a GraphQL query using the `gql` tag and the `@rest` directive to fetch data from a specific REST endpoint path. The `@rest` directive specifies the expected data type (`Person`) and the path (`people/1/`).\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { gql } from '@apollo/client';\n\nconst query = gql`\n  query Luke {\n    person @rest(type: \"Person\", path: \"people/1/\") {\n      name\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Updating Cache with cache.writeQuery in Resolver - JS\nDESCRIPTION: This code snippet shows how to update the Apollo Client cache using `cache.writeQuery` inside a resolver function.  It defines a resolver for the `updateVisibilityFilter` mutation that writes data to the cache.  The query `GetVisibilityFilter` is used to identify the data to be updated, and the `data` object specifies the new value for `visibilityFilter`. Dependencies include ApolloClient and InMemoryCache from '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  resolvers: {\n    Mutation: {\n      updateVisibilityFilter: (_, { visibilityFilter }, { cache }) => {\n        cache.writeQuery({\n          query: gql`query GetVisibilityFilter { visibilityFilter }`,\n          data: {\n            __typename: 'Filter',\n            visibilityFilter,\n          },\n        });\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Executing a REST Link Query with Apollo Client\nDESCRIPTION: Illustrates how to use the configured Apollo Client instance to execute a GraphQL query that utilizes `RestLink`. It fetches data from the REST endpoint defined in the query and logs the result.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\n// Invoke the query and log the person's name\nclient.query({ query }).then(response => {\n  console.log(response.data.person.name);\n});\n```\n\n----------------------------------------\n\nTITLE: Using Own Options Type for useBackgroundQuery\nDESCRIPTION: This update makes `useBackgroundQuery` utilize a dedicated options type named `BackgroundQueryHookOptions`, promoting type safety and clarity when configuring background queries.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_38\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Watch Mode with npm - Shell\nDESCRIPTION: Details how to launch the test suite in watch mode, automatically rerunning relevant tests as files change. This requires npm and the appropriate watch test script to be set up in the project. Ideal for real-time feedback during development.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nnpm run test:watch\n```\n\n----------------------------------------\n\nTITLE: Returning a Modified Field with Added 'id' Selection in TypeScript\nDESCRIPTION: Returns a new field node that appends the generated 'id' field AST node to the selectionSet's 'selections' array, integrating the new selection into the query. Spread operators are used to preserve other field properties and selectionSet items. Input is a Field AST node and the newly created idField object.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst transformedDocument = visit(document, {\n  Field(field) {\n    // ...\n    const idField = {\n      // ...\n    };\n\n    return {\n      ...field,\n      selectionSet: {\n        ...field.selectionSet,\n        selections: [...selections, idField],\n      },\n    };\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using name Property in graphql HOC and Typing Props Function in TypeScript\nDESCRIPTION: Shows how to use the name property in graphql HOC config to rename the injected prop and how to manually type the props function using NamedProps for the named response prop, ensuring strong typing and enabling type safety while accessing data and ownProps.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_15\n\nLANGUAGE: TS\nCODE:\n```\nimport { NamedProps, QueryProps } from '@apollo/react-hoc';\n\nexport const withCharacter = graphql<GetCharacterQueryVariables, GetCharacterQuery, {}, Prop>(HERO_QUERY, {\n  name: 'character', // highlight-line\n  props: ({ character, ownProps }: NamedProps<{ character: QueryProps & GetCharacterQuery }, Props) => ({\n    ...character,\n    // $ExpectError [string] This type cannot be compared to number\n    episode: ownProps.episode > 1,\n    // $ExpectError property `isHero`. Property not found on object type\n    isHero: character && character.hero && character.hero.isHero\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: Full App Example with ApolloProvider (React, JSX)\nDESCRIPTION: This complete example showcases integrating Apollo Client with a React application. It includes setting up `ApolloClient`, defining a query for login status, writing data to the cache, and rendering components based on the login status.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_14\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport {\n  ApolloClient,\n  InMemoryCache,\n  ApolloProvider,\n  useQuery,\n  gql\n} from '@apollo/client';\n\nimport Pages from './pages';\nimport Login from './pages/login';\n\nconst cache = new InMemoryCache();\n\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache\n});\n\nconst IS_LOGGED_IN = gql`\n  query IsUserLoggedIn {\n    isLoggedIn @client\n  }\n`;\n\ncache.writeQuery({\n  query: IS_LOGGED_IN,\n  data: {\n    isLoggedIn: !!localStorage.getItem(\"token\"),\n  },\n});\n\nfunction App() {\n  const { data } = useQuery(IS_LOGGED_IN);\n  return data.isLoggedIn ? <Pages /> : <Login />;\n}\n\nReactDOM.render(\n  <ApolloProvider client={client}>\n    <App />\n  </ApolloProvider>,\n  document.getElementById(\"root\"),\n);\n```\n\n----------------------------------------\n\nTITLE: Disabling Cache Merging for a Type in Apollo Client (TypeScript)\nDESCRIPTION: Demonstrates disabling automatic merging for an entire type (`Author`) by setting `merge: false` within its `typePolicies` definition in the `InMemoryCache`. This prevents Apollo Client from attempting to merge incoming data for objects of this type, overriding any field-specific merge functions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Book: {\n      fields: {\n        // No longer necessary!\n        // author: {\n        //   merge: true,\n        // },\n      },\n    },\n\n    Author: {\n      merge: false,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Query Book with Author Birthdate GraphQL\nDESCRIPTION: This GraphQL query fetches the favorite book including the author's birthdate. This query is used to show how Apollo Client can merge data from multiple queries for the same object.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nquery BookWithAuthorBirthdate {\n  favoriteBook {\n    id\n    author {\n      dateOfBirth\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing deleteDog Mutation Execution and UI States with MockedProvider in JSX\nDESCRIPTION: Tests the DeleteButton component by providing a mock response to the DELETE_DOG_MUTATION and simulates a user clicking the delete button. It asynchronously verifies the UI transitions through 'Loading...' and 'Deleted!' states after the mutation is fired. Mocks include the mutation request with variables, and the corresponding result simulating deletion of a dog named \"Buck\". This test relies on @testing-library/react's user-event for interaction simulation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_12\n\nLANGUAGE: jsx\nCODE:\n```\nit(\"should render loading and success states on delete\", async () => {\n  const deleteDog = { __typename: \"Dog\", name: \"Buck\", breed: \"Poodle\", id: 1 };\n  const mocks = [\n    {\n      request: {\n        query: DELETE_DOG_MUTATION,\n        variables: { name: \"Buck\" }\n      },\n      result: { data: deleteDog }\n    }\n  ];\n\n  render(\n    <MockedProvider mocks={mocks}>\n      <DeleteButton />\n    </MockedProvider>\n  );\n\n  // Find the button element...\n  const button = await screen.findByText(\"Click to Delete Buck\");\n  userEvent.click(button); // Simulate a click and fire the mutation\n\n  expect(await screen.findByText(\"Loading...\")).toBeInTheDocument();\n  expect(await screen.findByText(\"Deleted!\")).toBeInTheDocument();\n});\n```\n\n----------------------------------------\n\nTITLE: src/__tests__/handlers.ts\nDESCRIPTION: Defines MSW request handlers for intercepting GraphQL operations, creating a mock schema with resolvers and scalars, and returning mock data responses for GraphQL queries during tests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/schema-driven-testing.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { graphql, HttpResponse } from \"msw\";\nimport { execute } from \"graphql\";\nimport type { ExecutionResult } from \"graphql\";\nimport type { ObjMap } from \"graphql/jsutils/ObjMap\";\nimport { gql } from \"@apollo/client\";\nimport { createTestSchema } from \"@apollo/client/testing/experimental\";\nimport { makeExecutableSchema } from \"@graphql-tools/schema\";\nimport graphqlSchema from \"../../../schema.graphql\";\n\n// First, create a static schema...\nconst staticSchema = makeExecutableSchema({ typeDefs: graphqlSchema });\n\n// ...which is then passed as the first argument to `createTestSchema`\n// along with mock resolvers and default scalar values.\nexport let testSchema = createTestSchema(staticSchema, {\n  resolvers: {\n    Query: {\n      products: () => [\n        {\n          id: \"1\",\n          title: \"Blue Jays Hat\",\n        },\n      ],\n    },\n  },\n  scalars: {\n    Int: () => 6,\n    Float: () => 22.1,\n    String: () => \"string\",\n  },\n});\n\nexport const handlers = [\n  // Intercept all GraphQL operations and return a response generated by the\n  // test schema. Add additional handlers as needed.\n  graphql.operation<ExecutionResult<ObjMap<unknown>, ObjMap<unknown>>>(\n    async ({ query, variables, operationName }) => {\n      const document = gql(query);\n\n      const result = await execute({\n        document,\n        operationName,\n        schema: testSchema,\n        variableValues: variables,\n      });\n\n      return HttpResponse.json(result);\n    }\n  ),\n];\n```\n\n----------------------------------------\n\nTITLE: Defining GetDog Query JavaScript\nDESCRIPTION: Defines a GraphQL query named `GET_DOG` to fetch details for a specific dog, utilizing a cache reference for potential performance optimization.  Demonstrates how Apollo Client can retrieve data efficiently by checking the local cache before fetching from the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/why-apollo.mdx#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst GET_DOG = gql`\n  query GetDog {\n    dog(id: \"abc\") {\n      id\n      breed\n      displayImage\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Starting Fullstack Tutorial Server Shell\nDESCRIPTION: Navigates back to the server directory within the final project of the fullstack tutorial and starts the server application using npm start. This makes the backend API available for the client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n# ... assuming still in [fullstack-tutorial-root]/final/client/node_modules from step 4\ncd ../../server\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Applying @unmask Codemod\nDESCRIPTION: This code snippet provides instructions on how to use the `@unmask` codemod to apply the data masking directive to named fragments in an Apollo Client project. It specifies the command to run with `jscodeshift`, including options for file extensions, parser, and a custom tag. It also explains options for using the directive in migrate mode to receive runtime warnings.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nnpx jscodeshift -t node_modules/@apollo/client/scripts/codemods/data-masking/unmask.ts --extensions tsx --parser tsx path/to/app/\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo DevTools Client in React Native\nDESCRIPTION: Sets up Apollo DevTools client for Flipper integration in a React Native application. The setup is conditionally executed only in development mode.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/react-native.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { apolloDevToolsInit } from 'react-native-apollo-devtools-client';\n\nconst client = new ApolloClient({\n  // ...\n});\n\nif (__DEV__) {\n  apolloDevToolsInit(client);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing BatchHttpLink in JavaScript\nDESCRIPTION: This snippet demonstrates how to import and initialize the `BatchHttpLink` from `@apollo/client/link/batch-http`. It configures the link with the GraphQL endpoint `uri`, sets the maximum operations per batch (`batchMax`) to 5, and the maximum time interval (`batchInterval`) to 20ms before sending a batch. This link replaces the standard `HttpLink` to enable operation batching.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-batch-http.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { BatchHttpLink } from \"@apollo/client/link/batch-http\";\n\nconst link = new BatchHttpLink({\n  uri: \"http://localhost:4000/graphql\",\n  batchMax: 5, // No more than 5 operations per batch\n  batchInterval: 20 // Wait no more than 20ms after first batched operation\n});\n```\n\n----------------------------------------\n\nTITLE: Using @unmask(mode: \"migrate\") for Incremental Adoption (GraphQL)\nDESCRIPTION: Shows how to use the `@unmask` directive with the `mode: \"migrate\"` argument in a GraphQL query (Apollo Client >= 3.12.0). This specific mode enables development-only warnings when fields that would normally be masked (like `title` within `PostDetails`) are accessed directly on the query result, facilitating the gradual adoption of data masking practices.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetPost(id: $id) {\n  post(id: $id) {\n    id\n    ...PostDetails @unmask(mode: \"migrate\")\n  }\n}\n\nfragment PostDetails on Post {\n  title\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a GraphQLWsLink instance with graphql-ws\nDESCRIPTION: Demonstrates how to import and initialize a GraphQLWsLink using the createClient function from graphql-ws. The example shows connecting to a WebSocket endpoint at localhost:3000/subscriptions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-subscriptions.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { GraphQLWsLink } from \"@apollo/client/link/subscriptions\";\nimport { createClient } from \"graphql-ws\";\n\nconst link = new GraphQLWsLink(\n  createClient({\n    url: \"ws://localhost:3000/subscriptions\",\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Fragment When Masking Enabled (PublishedAt Included)\nDESCRIPTION: Shows the modified `GetPosts` GraphQL query definition. To make the `publishedAt` field available to the `Posts` component when data masking is enabled, it must be explicitly added to the fields requested directly in the query, in addition to being included in the fragment. This allows the parent component to access the field for its filtering logic.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_36\n\nLANGUAGE: jsx\nCODE:\n```\nconst GET_POSTS = gql`\n  query GetPosts {\n    posts {\n      id\n      publishedAt\n      ...PostDetailsFragment\n    }\n  }\n\n  ${POST_DETAILS_FRAGMENT}\n`;\n```\n\n----------------------------------------\n\nTITLE: Example of using babel-plugin-import-graphql\nDESCRIPTION: Demonstrates how to use the `babel-plugin-import-graphql` plugin.  It imports a GraphQL query from a separate `.graphql` file and uses it in a React component, illustrating how the plugin transforms the import statement to provide a usable GraphQL DocumentNode.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_10\n\nLANGUAGE: JSX\nCODE:\n```\nimport React, { Component } from 'react';\nimport { graphql } from '@apollo/react-hoc';\nimport myImportedQuery from './productsQuery.graphql';\n// or for files with multiple operations:\n// import { query1, query2 } from './queries.graphql';\n\nclass QueryingComponent extends Component {\n  render() {\n    if (this.props.data.loading) return <h3>Loading...</h3>;\n    return <div>{`This is my data: ${this.props.data.queryName}`}</div>;\n  }\n}\n\nexport default graphql(myImportedQuery)(QueryingComponent);\n```\n\n----------------------------------------\n\nTITLE: React Query with Cursor-Based Pagination and Map Cache in Apollo Client JSX/JavaScript\nDESCRIPTION: Demonstrates a React component that executes a GraphQL query with cursor-based pagination using Apollo Client's useQuery hook. It fetches comments with a cursor and limit, supports loading state, and fetches more comments with fetchMore by passing the current cursor. The accompanying cache policy uses a map internally to store unique comment items keyed by ID and returns an array of comments with an explicit cursor field. This approach handles duplicates and sorting/filtering criteria effectively.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/cursor-based.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\nconst MORE_COMMENTS_QUERY = gql`\n  query MoreComments($cursor: String, $limit: Int!) {\n    moreComments(cursor: $cursor, limit: $limit) {\n      cursor\n      comments {\n        id\n        author\n        text\n      }\n    }\n  }\n`;\n\nfunction CommentsWithData() {\n  const {\n    data,\n    loading,\n    fetchMore,\n  } = useQuery(MORE_COMMENTS_QUERY, {\n    variables: { limit: 10 },\n  });\n\n  if (loading) return <Loading/>;\n\n  return (\n    <Comments\n      entries={data.moreComments.comments || []}\n      onLoadMore={() => fetchMore({\n        variables: {\n          cursor: data.moreComments.cursor,\n        },\n      })}\n    />\n  );\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        moreComments: {\n          keyArgs: false,\n          merge(existing, incoming, { readField }) {\n            const comments = existing ? { ...existing.comments } : {};\n            incoming.comments.forEach(comment => {\n              comments[readField(\"id\", comment)] = comment;\n            });\n            return {\n              cursor: incoming.cursor,\n              comments,\n            };\n          },\n\n          read(existing) {\n            if (existing) {\n              return {\n                cursor: existing.cursor,\n                comments: Object.values(existing.comments),\n              };\n            }\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: src/__tests__/products.test.tsx\nDESCRIPTION: Contains React component tests for the `Products` component, verifying rendering behavior using an Apollo Client configured with the test schema. Includes tests for initial render, updating resolvers dynamically, and resetting schema resolvers to initial state.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/schema-driven-testing.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Suspense } from \"react\";\nimport { render as rtlRender, screen } from \"@testing-library/react\";\nimport {\n  ApolloClient,\n  ApolloProvider,\n  NormalizedCacheObject\n} from \"@apollo/client\";\nimport { testSchema } from \"./handlers\";\nimport { Products } from \"../products\";\n// This should be a function that returns a new ApolloClient instance\n// configured just like your production Apollo Client instance - see the FAQ.\nimport { makeClient } from \"../client\";\n\nconst render = (renderedClient: ApolloClient<NormalizedCacheObject>) =>\n  rtlRender(\n    <ApolloProvider client={renderedClient}>\n      <Suspense fallback=\"Loading...\">\n        <Products />\n      </Suspense>\n    </ApolloProvider>\n  );\n\ndescribe(\"Products\", () => {\n  test(\"renders\", async () => {\n    render(makeClient());\n\n    await screen.findByText(\"Loading...\");\n\n    // This is the data from our initial mock resolver in the test schema\n    // defined in the handlers file 🎉\n    expect(await screen.findByText(/blue jays hat/i)).toBeInTheDocument();\n  });\n\n  test(\"allows resolvers to be updated via .add\", async () => {\n    // Calling .add on the test schema will update the resolvers\n    // with new data\n    testSchema.add({\n      resolvers: {\n        Query: {\n          products: () => {\n            return [\n              {\n                id: \"2\",\n                title: \"Mets Hat\",\n              },\n            ];\n          },\n        },\n      },\n    });\n\n    render(makeClient());\n\n    await screen.findByText(\"Loading...\");\n\n    // Our component now renders the new data from the updated resolver\n    await screen.findByText(/mets hat/i);\n  });\n\n  test(\"handles test schema resetting via .reset\", async () => {\n    // Calling .reset on the test schema will reset the resolvers\n    testSchema.reset();\n\n    render(makeClient());\n\n    await screen.findByText(\"Loading...\");\n\n    // The component now renders the initial data configured on the test schema\n    await screen.findByText(/blue jays hat/i);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite to Disable Development Mode - JavaScript\nDESCRIPTION: This snippet demonstrates how to configure Vite in a vite.config.js file to set globalThis.__DEV__ to false using the define property. This enables the removal of development-only checks from Apollo Client bundles. Requires Vite and may need other project dependencies as per your project setup. The expected input is a Vite configuration object and the output is a build that excludes Apollo Client's development checks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default defineConfig({\n  // ...\n  define: {\n    \"globalThis.__DEV__\": JSON.stringify(false),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Cache Redirects with typePolicies and read Function\nDESCRIPTION: Shows how to define a type policy with a read function for the 'book' field, which generates a cache reference using toReference based on arguments. This allows Apollo Client to resolve references from the cache instead of fetching from the network, improving cache efficiency for related queries. Dependencies include '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache({\n    typePolicies: {\n      Query: {\n        fields: {\n          book: {\n            read(_, { args, toReference }) {\n              return toReference({\n                __typename: 'Book',\n                id: args.id,\n              });\n            }\n          }\n        }\n      }\n    }\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client with Client-Side Schema\nDESCRIPTION: Initialization of ApolloClient with a client-side schema to support mocked fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new ApolloClient({\n  uri: 'http://localhost:4000/graphql',\n  cache: new InMemoryCache(),\n  typeDefs\n});\n```\n\n----------------------------------------\n\nTITLE: Using MaskedDocumentNode Shorthand Type\nDESCRIPTION: Introduces the `MaskedDocumentNode` type as a convenient shorthand for `TypedDocumentNode<Masked<QueryType>, VarsType>`. This type simplifies annotations when you specifically intend for an operation's type to be the masked version.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_57\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MaskedDocumentNode } from \"@apollo/client\";\n\nconst QUERY: MaskedDocumentNode<QueryType, VarsType> = gql`\n  # ...\n`;\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client JavaScript\nDESCRIPTION: Shows how to initialize an Apollo Client with an `InMemoryCache`. This sets up the basic configuration for caching GraphQL responses. The `InMemoryCache` is a local, in-memory cache that stores normalized data, allowing Apollo Client to efficiently manage and update the application's data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/why-apollo.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n});\n```\n\n----------------------------------------\n\nTITLE: Stateless ApolloLink with Error Reporting - JavaScript\nDESCRIPTION: This snippet demonstrates a stateless `ApolloLink` that reports errors using a provided `errorCallback`. It creates an `Observable` and subscribes to the result of the `forward(operation)` call.  If an error occurs, the `errorCallback` is invoked with details, and the error is propagated.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink } from '@apollo/client';\n\nconst reportErrors = (errorCallback) => new ApolloLink((operation, forward) => {\n  return new Observable((observer) => {\n    const observable = forward(operation);\n    const subscription = observable.subscribe({\n      next(value) {\n        observer.next(value);\n      },\n      error(networkError) {\n        errorCallback({ networkError, operation });\n        observer.error(networkError);\n      },\n      complete() {\n        observer.complete();\n      },\n    });\n\n    return () => subscription.unsubscribe();\n  });\n});\n\nconst link = reportErrors(console.error);\n\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Mutation for Comment Update in GraphQL\nDESCRIPTION: Defines the GraphQL mutation type for updating a comment. This mutation accepts a comment ID and new content as inputs and returns the updated Comment object. This snippet forms the basis for later optimistic UI updates by specifying the mutation's input parameters and expected output shape.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/optimistic-ui.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype Mutation {\n  updateComment(commentId: ID!, content: String!): Comment!\n\n  # ...other mutations...\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional DocumentTransform using split() for operation type-based transformation\nDESCRIPTION: This snippet demonstrates how to create a dynamically conditional document transform that applies a specific transform only to subscription operations using the split() static method. It emphasizes using utility functions like isSubscriptionOperation to decide runtime transformation behavior. The resulting DocumentTransform applies the subscriptionTransform only when the document is a subscription operation, otherwise it returns the document unmodified.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isSubscriptionOperation } from '@apollo/client/utilities';\n\nconst subscriptionTransform = new DocumentTransform(transform);\n\nconst documentTransform = DocumentTransform.split(\n  (document) => isSubscriptionOperation(document),\n  subscriptionTransform\n);\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Type Policies to InMemoryCache in TypeScript\nDESCRIPTION: Demonstrates how to create an InMemoryCache with custom type policies for a Person type and then add additional type policies using the addTypePolicies method. The example shows how to provide default values and transformations for name and email fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-configuration.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Person: {\n      fields: {\n        name: {\n          read(name = \"UNKNOWN NAME\") {\n            return name.toUpperCase();\n          }\n        },\n      },\n    },\n  },\n});\n\n// Add a type policy to the cache.\ncache.policies.addTypePolicies({\n  Person: {\n    fields: {\n      email: {\n        read(email = \"unknown@example.com\") {\n          return email;\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Default Values for Nested Cached Fields - Apollo Client TypeScript\nDESCRIPTION: This snippet defines a read function for a 'fullName' field, where the subfields 'firstName' and 'lastName' have explicit default values if absent. The function uses object parameter defaulting in TypeScript and returns the composite fullName object with guaranteed subkeys. Dependencies: Apollo Client, use of TypePolicies with nested objects. Inputs: an optional fullName object; outputs: an object with 'firstName' and 'lastName' properties, defaulting as needed. Constraints: all properties expected are assigned defaults.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Person: {\n      fields: {\n        fullName: {\n          read(fullName = {\n            firstName: \"UNKNOWN FIRST NAME\",\n            lastName: \"UNKNOWN LAST NAME\",\n          }) {\n            return { ...fullName };\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Default refetchWritePolicy in Apollo Client (TypeScript)\nDESCRIPTION: Demonstrates how to set a default `refetchWritePolicy` to \"merge\" within the Apollo Client constructor's `defaultOptions`. This configuration allows developers to revert to the pre-v3.4 behavior where refetched data is merged with existing cache data using field policy `merge` functions, instead of the new default \"overwrite\" behavior which mimics Apollo Client 2.x.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_47\n\nLANGUAGE: ts\nCODE:\n```\nnew ApolloClient({\n  defaultOptions: {\n    watchQuery: {\n      refetchWritePolicy: \"merge\",\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using graphql-tag.macro\nDESCRIPTION: Demonstrates changing an import from `graphql-tag` to `graphql-tag.macro` to leverage the macro capabilities. This approach requires babel-macros installed and configured. It is a more explicit way to indicate which `gql` calls should be precompiled.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport gql from 'graphql-tag.macro'; // <-- Use the macro\n\nconst query = gql`\n  query HelloWorld {\n    hello {\n      world\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Configuring Context for Persisted Queries with BatchHttpLink in JavaScript\nDESCRIPTION: This snippet shows how to set the context for an individual operation to support persisted queries when using `BatchHttpLink`. Setting `http.includeExtensions` to `true` ensures the extensions field (often containing the query ID) is sent, while `http.includeQuery` set to `false` prevents the full query string from being transmitted, optimizing the request size. This context is applied per-query within a batch.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-batch-http.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\noperation.setContext({\n  http: {\n    includeExtensions: true,\n    includeQuery: false,\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up @nonreactive for Fragments in a React Query (JSX)\nDESCRIPTION: Defines a GraphQL query (`ALL_TRAILS`) and fragment (`TrailFragment`) using `gql` in a React component context (JSX). The `@nonreactive` directive (Apollo Client >= 3.8.0) is applied to the `TrailFragment` spread within the `allTrails` query. This prevents the parent component (`App` using `useQuery`) from rerendering when data within `TrailFragment` changes in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst TrailFragment = gql`\n  fragment TrailFragment on Trail {\n    name\n    status\n  }\n`;\n\nconst ALL_TRAILS = gql`\n  query allTrails {\n    allTrails {\n      id\n      ...TrailFragment @nonreactive\n    }\n  }\n  ${TrailFragment}\n`;\n\nfunction App() {\n  const { data, loading } = useQuery(ALL_TRAILS);\n  return (\n    <main>\n      <h2>Ski Trails</h2>\n      <ul>\n        {data?.trails.map((trail) => (\n          <Trail key={trail.id} id={trail.id} />\n        ))}\n      </ul>\n    </main>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Cart Component with useReactiveVar (React, JSX)\nDESCRIPTION: This React component `Cart` uses the `useReactiveVar` hook to directly access the `cartItemsVar` reactive variable.  It renders the cart items based on the current value of the variable, and rerenders automatically whenever `cartItemsVar` is updated.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useReactiveVar } from '@apollo/client';\n\nexport function Cart() {\n  const cartItems = useReactiveVar(cartItemsVar);\n\n  return (\n    <div class=\"cart\">\n      <Header>My Cart</Header>\n      {cartItems.length === 0 ? (\n        <p>No items in your cart</p>\n      ) : (\n        <Fragment>\n          {cartItems.map(productId => (\n            <CartItem key={productId} />\n          ))}\n        </Fragment>\n      )}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: ApolloClient setResolvers Method - JS\nDESCRIPTION: Demonstrates the `setResolvers` method to overwrite existing resolvers in the Apollo Client. It creates an ApolloClient instance and then uses `client.setResolvers` to replace the current resolvers with a new set. Dependencies include ApolloClient, InMemoryCache, and HttpLink from '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: new HttpLink({ uri: 'http://localhost:4000/graphql' }),\n});\n\nclient.setResolvers({ ... });\n```\n\n----------------------------------------\n\nTITLE: Specifying `keyArgs` for Field Caching in Apollo Client (TypeScript)\nDESCRIPTION: Illustrates configuring `keyArgs` within a field's `typePolicies` in the `InMemoryCache`. By specifying `[\"number\"]` as `keyArgs` for the `monthForNumber` field on the `Query` type, it tells the cache that only the `number` argument affects the field's result, allowing results with different non-key arguments (like an implied `accessToken`) to potentially overwrite each other in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        monthForNumber: {\n          keyArgs: [\"number\"],\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Displaying Loading Indicator with GraphQL HOC\nDESCRIPTION: This snippet demonstrates how to display a loading indicator while a GraphQL query is in flight using the `data.loading` property. The `graphql()` HOC injects the `data` prop into the component. This component uses the destructured `loading` property from the `data` prop.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyComponent({ data: { loading } }) {\n  if (loading) {\n    return <div>Loading...</div>;\n  } else {\n    // ...\n  }\n}\n\nexport default graphql(gql`query MyQuery { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Querying Local Field JavaScript\nDESCRIPTION: Illustrates a GraphQL query to fetch data, including a local-only field marked with `@client`.  This shows how Apollo Client can combine remote data with local state data in the same query.  This is an example of how to manage both local and remote data using Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/why-apollo.mdx#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst GET_DOG = gql`\n  query GetDogByBreed($breed: String!) {\n    dog(breed: $breed) {\n      images {\n        url\n        id\n        isLiked @client\n      }\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Defining Local/Remote Query for Product Details in Apollo Client JavaScript\nDESCRIPTION: This JavaScript snippet defines a GET_PRODUCT_DETAILS GraphQL query using the gql template literal for use with Apollo Client. The query retrieves product fields name, price, and the local-only isInCart field by applying the @client directive. Dependencies: Apollo Client, gql function. Input: productId variable. Output: product details object. Limitation: The isInCart field requires a client-side field policy and will be excluded from the remote request.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst GET_PRODUCT_DETAILS = gql`\n  query ProductDetails($productId: ID!) {\n    product(id: $productId) {\n      name\n      price\n      isInCart @client\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Persisted Query Manifest Generator (bash)\nDESCRIPTION: Installs the @apollo/generate-persisted-query-manifest package as a development dependency using npm. This package is required to generate operation manifests used for persisted query safelisting with Apollo Client and GraphOS Router.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save-dev @apollo/generate-persisted-query-manifest\n```\n\n----------------------------------------\n\nTITLE: Full JSON Result of All People GraphQL Query\nDESCRIPTION: This JSON snippet presents the complete data response returned by the example `allPeople` GraphQL query. It contains an array of `Person` objects, each with a nested `homeworld`. This raw response is processed by Apollo Client's cache to create the normalized, flat lookup table structure described in the document.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/overview.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"allPeople\": {\n      \"people\": [\n        {\n          \"__typename\": \"Person\",\n          \"id\": \"cGVvcGxlOjE=\",\n          \"name\": \"Luke Skywalker\",\n          \"homeworld\": {\n            \"__typename\": \"Planet\",\n            \"id\": \"cGxhbmV0czox\",\n            \"name\": \"Tatooine\"\n          }\n        },\n        {\n          \"__typename\": \"Person\",\n          \"id\": \"cGVvcGxlOjI=\",\n          \"name\": \"C-3PO\",\n          \"homeworld\": {\n            \"__typename\": \"Planet\",\n            \"id\": \"cGxhbmV0czox\",\n            \"name\": \"Tatooine\"\n          }\n        },\n        {\n          \"__typename\": \"Person\",\n          \"id\": \"cGVvcGxlOjM=\",\n          \"name\": \"R2-D2\",\n          \"homeworld\": {\n            \"__typename\": \"Planet\",\n            \"id\": \"cGxhbmV0czo4\",\n            \"name\": \"Naboo\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining merge Function for Author with mergeObjects Helper\nDESCRIPTION: This TypeScript snippet demonstrates how to define a custom `merge` function within `typePolicies` for the `author` field of a `Book` object in Apollo Client. It utilizes the `mergeObjects` helper to merge the `existing` and `incoming` `Author` objects.  This ensures that when the same `Book` is fetched with different `Author` fields, the data is merged rather than overwritten.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Book: {\n      fields: {\n        author: {\n          merge(existing, incoming, { mergeObjects }) {\n            return mergeObjects(existing, incoming);\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Modifying GraphQL Schema Resolvers using testSchema.add\nDESCRIPTION: This snippet demonstrates modifying the return value of a GraphQL resolver for testing purposes using `testSchema.add`. It adds a new resolver for the `products` query to return an array of products with modified IDs and media URLs.  It relies on `createSchemaFetch` and `render` from React Testing Library. The  `testSchema.reset()` and `restore()` methods are utilized to clean up the test environment.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/schema-driven-testing.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\ndescribe(\"Products\", () => {\n  it(\"renders\", async () => {\n    const { restore } = createSchemaFetch(schema).mockGlobal();\n\n    render(makeClient());\n\n    // make assertions against the rendered DOM output\n\n    // Here we want to change the return value of the `products` resolver\n    // for the next outgoing query.\n    testSchema.add({\n      resolvers: {\n        Query: {\n          products: () =>\n            Array.from({ length: 5 }, (_element, id) => ({\n              // we want to return ids starting from 5 for the second request\n              id: id + 5,\n              mediaUrl: `https://example.com/image${id + 5}.jpg`,\n            })),\n        },\n      },\n    });\n\n    // trigger a new query with a user interaction\n    userEvent.click(screen.getByText(\"Fetch more\"));\n\n    // make assertions against the rendered DOM output\n\n    restore();\n    testSchema.reset();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching and Mutating Fragment Data in Child Components with Apollo Client (JavaScript/JSX)\nDESCRIPTION: This snippet illustrates a Trail functional React component using Apollo Client's useFragment and useMutation hooks together with a predefined TrailFragment to bind to a specific Trail entity by id. It allows a user to toggle the status ('OPEN'/'CLOSED') using an HTML checkbox. Dependencies are Apollo Client hooks, a valid UPDATE_TRAIL mutation, React, and the TrailFragment definition. Inputs are the id prop, with UI-driven changes reflected by calling updateTrail on interaction. Outputs are rendered list items with trail data and update side-effects. The implementation assumes integration with Apollo Client's cache and reactive data system.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_23\n\nLANGUAGE: JSX\nCODE:\n```\nconst Trail = ({ id }) => {\n  const [updateTrail] = useMutation(UPDATE_TRAIL);\n  const { data } = useFragment({\n    fragment: TrailFragment,\n    from: {\n      __typename: \"Trail\",\n      id,\n    },\n  });\n  return (\n    <li key={id}>\n      {data.name} - {data.status}\n      <input\n        checked={data.status === \"OPEN\" ? true : false}\n        type=\"checkbox\"\n        onChange={(e) => {\n          updateTrail({\n            variables: {\n              trailId: id,\n              status: e.target.checked ? \"OPEN\" : \"CLOSED\",\n            },\n          });\n        }}\n      />\n    </li>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Bailing Out of Optimistic Updates with IGNORE in Apollo Client - JavaScript/JSX\nDESCRIPTION: This code demonstrates how to use the IGNORE sentinel object in Apollo Client's optimisticResponse function to conditionally prevent optimistic cache updates. The CommentPageWithData component defines an optimisticResponse that checks for a specific commentContent value and returns IGNORE to skip the update when necessary. Requires @apollo/client with a recent version supporting IGNORE, React, useMutation, and GraphQL setup. Parameters include commentId and commentContent for mutation variables. If commentContent equals 'foo', the optimistic update is bypassed, otherwise a simulated cache update occurs with the provided content.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_11\n\nLANGUAGE: JSX\nCODE:\n```\nconst UPDATE_COMMENT = gql`\n  mutation UpdateComment($commentId: ID!, $commentContent: String!) {\n    updateComment(commentId: $commentId, content: $commentContent) {\n      id\n      __typename\n      content\n    }\n  }\n`;\n\nfunction CommentPageWithData() {\n  const [mutate] = useMutation(UPDATE_COMMENT);\n  return (\n    <Comment\n      updateComment={({ commentId, commentContent }) =>\n        mutate({\n          variables: { commentId, commentContent },\n          optimisticResponse: (vars, { IGNORE }) => {\n            if (commentContent === \"foo\") {\n              // conditionally bail out of optimistic updates\n              return IGNORE;\n            }\n            return {\n              updateComment: {\n                id: commentId,\n                __typename: \"Comment\",\n                content: commentContent,\n              },\n            };\n          },\n        })\n      }\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using `fetchMore` with Typed `useQuery` Hook\nDESCRIPTION: Illustrates invoking `fetchMore` with type safety, allowing to fetch additional data for the same query with new variables. Demonstrates expanding the previous rocket inventory example to load more data dynamically.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ...\nexport function RocketInventoryList() {\n  const { fetchMore, loading, data } = useQuery(\n    GET_ROCKET_INVENTORY,\n    { variables: { year: 2019 } }\n  );\n\n  return (\n    // ...\n    <button\n      onClick={() => {\n        fetchMore({ variables: { year: 2020 } });\n      }}\n    >\n      Add 2020 Inventory\n    </button>\n    // ...\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ApolloClient Instance in v3\nDESCRIPTION: Example of initializing the `ApolloClient` in version 3.0. It demonstrates using direct configuration options like `uri`, `headers`, and `credentials` within the constructor, which simplifies setup by implicitly creating an `HttpLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new ApolloClient({\n  cache, // Assumes 'cache' is an instance of InMemoryCache, defined elsewhere\n  uri: 'http://localhost:4000/graphql',\n  headers: {\n    authorization: localStorage.getItem('token') || '',\n    'client-name': 'Space Explorer [web]',\n    'client-version': '1.0.0',\n  },\n  // Other ApolloClient options can be added here\n  ...\n});\n```\n\n----------------------------------------\n\nTITLE: Stateless ApolloLink with Constructor - JavaScript\nDESCRIPTION: This code shows how to define a stateless `ApolloLink` by providing a request handler function to the constructor.  This example logs the start and end of each request using `console.log`. It requires importing `ApolloLink` from `@apollo/client` and uses the `forward` function to pass the operation to the next link in the chain.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink } from '@apollo/client';\n\nconst consoleLink = new ApolloLink((operation, forward) => {\n  console.log(`starting request for ${operation.operationName}`);\n  return forward(operation).map((data) => {\n    console.log(`ending request for ${operation.operationName}`);\n    return data;\n  })\n})\n\n```\n\n----------------------------------------\n\nTITLE: Installing All Apollo React Paradigms\nDESCRIPTION: This code snippet combines the installation of the core client with packages supporting hooks, render prop components, and HOCs, allowing a mixed usage approach in React applications.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/hooks-migration.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client @apollo/react-components @apollo/react-hoc\n```\n\n----------------------------------------\n\nTITLE: HttpLink Object for Sending GraphQL Requests (JavaScript)\nDESCRIPTION: This section describes the HttpLink class used for executing GraphQL operations over HTTP, supporting POST and GET methods, with options for customization such as headers, credentials, and request method. Examples show instantiation with a specified URI.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { HttpLink } from \"@apollo/client\";\n\nconst link = new HttpLink({ uri: \"/graphql\" });\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client's Query Options with component options\nDESCRIPTION: This snippet shows how to set the options for a GraphQL query via a static options object or function, which can depend on component props. These options include variables, fetch policy, and other fetch-related settings, and enable dynamic query configuration based on component state or props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: {\n    // Options go here.\n  },\n});\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: props => ({\n    // Options are computed from `props` here.\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Apollo Utilities in Apollo Client 3.0\nDESCRIPTION: Shows how to import utility functions, such as `isReference` and `isInlineFragment`, from the `@apollo/client/utilities` entry point. This replaces the deprecated `apollo-utilities` package.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { isReference, isInlineFragment } from '@apollo/client/utilities';\n```\n\n----------------------------------------\n\nTITLE: Complete Express Server Setup for SSR with Apollo Client\nDESCRIPTION: A complete example of setting up an Express server for SSR with Apollo Client and React Router. This code initializes the Apollo Client and creates the React component tree with the necessary providers.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  ApolloProvider,\n  ApolloClient,\n  createHttpLink,\n  InMemoryCache\n} from '@apollo/client';\nimport Express from 'express';\nimport React from 'react';\nimport { StaticRouter } from 'react-router';\n\n// File shown below\nimport Layout from './routes/Layout';\n\nconst app = new Express();\napp.use((req, res) => {\n\n  const client = new ApolloClient({\n    ssrMode: true,\n    link: createHttpLink({\n      uri: 'http://localhost:3010',\n      credentials: 'same-origin',\n      headers: {\n        cookie: req.header('Cookie'),\n      },\n    }),\n    cache: new InMemoryCache(),\n  });\n\n  const context = {};\n\n  // The client-side App will instead use <BrowserRouter>\n  const App = (\n    <ApolloProvider client={client}>\n      <StaticRouter location={req.url} context={context}>\n        <Layout />\n      </StaticRouter>\n    </ApolloProvider>\n  );\n\n  // TODO: rendering code (see below)\n});\n\napp.listen(basePort, () => console.log(\n  `app Server is now running on http://localhost:${basePort}`\n));\n```\n\n----------------------------------------\n\nTITLE: Using @unmask Migrate Mode\nDESCRIPTION: This snippet shows how to use the `@unmask` directive with the `mode: \"migrate\"` option in a GraphQL query. This is intended to help with the transition to data masking. It adds runtime warnings when accessing fields that would be masked, which helps identify potential issues during migration to the data masking feature.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_6\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery {\n  user {\n    id\n    ...UserFields @unmask(mode: \"migrate\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Fragment in a Component File\nDESCRIPTION: Creating and exporting a reusable Comment fragment from a component file, which defines the data requirements for a Comment component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nimport { gql } from '@apollo/client';\n\nexport const COMMENT_FRAGMENT = gql`\n  fragment CommentFragment on Comment {\n    id\n    postedBy {\n      username\n      displayName\n    }\n    createdAt\n    content\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client for React Render Prop Components\nDESCRIPTION: This code snippet shows how to install the Apollo Client core along with react-components package to support render prop components in React, facilitating legacy patterns alongside hooks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/hooks-migration.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client @apollo/react-components\n```\n\n----------------------------------------\n\nTITLE: Resetting Canonical Results and Identities on Garbage Collection (Apollo Client JavaScript)\nDESCRIPTION: Invokes gc with both resetResultCache and resetResultIdentities options, enabling InMemoryCache to release memory for both cached results and canonical result objects. This is useful for memory profiling if canonizeResults was enabled on the cache but may involve risks of memory leaks; usage of canonizeResults is deprecated. Requires no additional setup except for the cache instance.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache.gc({\n  resetResultCache: true,\n  resetResultIdentities: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Removing @unmask Directive from GraphQL Query (diff)\nDESCRIPTION: This unified diff snippet illustrates how to remove the `@unmask(mode: \"migrate\")` directive from a fragment spread in a GraphQL query after all data masking migrations are complete. The expected input is a query containing the directive, and the output is a query without it, which enables field masking as the default behavior.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_69\n\nLANGUAGE: diff\nCODE:\n```\nquery GetPosts {\n  posts {\n    id\n-   ...PostDetails @unmask(mode: \"migrate\")\n+   ...PostDetails\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Fetch Policy in Apollo Client\nDESCRIPTION: This snippet demonstrates how to set the `fetchPolicy` option within Apollo Client's `graphql` function.  The `fetchPolicy` controls how the component interacts with the cache. In this case, it sets the fetch policy to `cache-and-network`.  This means the component will first try to read from the cache, then execute the request through the network interface. Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent and a GraphQL query definition using `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_28\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: { fetchPolicy: 'cache-and-network' },\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Modifying Response Data in Apollo Link (JavaScript)\nDESCRIPTION: This code creates a custom Apollo Link that intercepts responses and modifies the 'date' field by converting it into a JavaScript Date object. The link is composed with HttpLink to process incoming data before passing it to the application.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, ApolloLink } from '@apollo/client';\n\nconst httpLink = new HttpLink({ uri: '/graphql' });\n\nconst formatDateLink = new ApolloLink((operation, forward) => {\n  return forward(operation).map(response => {\n    if (response.data.date) {\n      response.data.date = new Date(response.data.date);\n    }\n    return response;\n  });\n});\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: formatDateLink.concat(httpLink),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Read Function for Mocked GraphQL Field\nDESCRIPTION: Configuration for InMemoryCache that defines a read function for the Rocket.description field, returning a placeholder value.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Rocket: {\n      fields: {\n        description: {\n          read() { // Read function for Rocket.description\n            return 'Placeholder rocket description';\n          }\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Client-Side Field with @client Directive\nDESCRIPTION: GraphQL query that includes the mocked description field with the @client directive to prevent it from being sent to the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nexport const GET_LAUNCH_DETAILS = gql`\n  query LaunchDetails($launchId: ID!) {\n    launch(id: $launchId) {\n      site\n      rocket {\n        type\n        description @client\n      }\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Deleting Field from Apollo Cache Object using cache.modify in JavaScript\nDESCRIPTION: Shows how to delete a specific field (`comments`) from a cached object identified by `cache.identify(myPost)`. This is achieved by returning the `DELETE` sentinel object, provided as the second argument to the field modifier function within `cache.modify`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_13\n\nLANGUAGE: js\nCODE:\n```\ncache.modify({\n  id: cache.identify(myPost),\n  fields: {\n    comments(existingCommentRefs, { DELETE }) {\n      return DELETE;\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Using GraphQL Query and React Component with Apollo Client in JSX\nDESCRIPTION: This snippet defines a GraphQL query using gql from @apollo/client and a React functional component that executes this query using the useQuery hook. It handles loading and error states, then renders the query data. Both the query and component are exported for testing and reuse.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from \"react\";\nimport { gql, useQuery } from \"@apollo/client\";\n\n// Make sure that both the query and the component are exported\nexport const GET_DOG_QUERY = gql`\n  query GetDog($name: String) {\n    dog(name: $name) {\n      id\n      name\n      breed\n    }\n  }\n`;\n\nexport function Dog({ name }) {\n  const { loading, error, data } = useQuery(GET_DOG_QUERY, {\n    variables: { name }\n  });\n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>{error.message}</p>;\n  return (\n    <p>\n      {data.dog.name} is a {data.dog.breed}\n    </p>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Queries with getDataFromTree in Express\nDESCRIPTION: Implementation of getDataFromTree to execute all GraphQL queries in a React component tree on the server. This code extracts the Apollo cache state and renders the complete HTML with the initial state embedded.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Add this import to the top of the file\nimport { getDataFromTree } from \"@apollo/client/react/ssr\";\n\n// Replace the TODO with this\ngetDataFromTree(App).then((content) => {\n  // Extract the entirety of the Apollo Client cache's current state\n  const initialState = client.extract();\n\n  // Add both the page content and the cache state to a top-level component\n  const html = <Html content={content} state={initialState} />;\n\n  // Render the component to static markup and return it\n  res.status(200);\n  res.send(`<!doctype html>\\n${ReactDOM.renderToStaticMarkup(html)}`);\n  res.end();\n});\n```\n\n----------------------------------------\n\nTITLE: Using Apollo Client with customized HttpLink context headers\nDESCRIPTION: This snippet demonstrates initializing an Apollo Client instance with an InMemoryCache and setting a custom URI. It shows how to perform a query while overriding request headers on a per-operation basis via the context object, enabling dynamic header configuration for specific GraphQL requests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from \"@apollo/client\";\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  uri: \"/graphql\"\n});\n\nclient.query({\n  query: MY_QUERY,\n  context: {\n    headers: {\n      special: \"Special header value\"\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Apollo Cache Data Manually with data.updateQuery() in React Components\nDESCRIPTION: This code demonstrates how to manually modify the Apollo Client cache outside of mutations or subscriptions using updateQuery. It involves providing a function that receives the current result and returns a new data object, enabling reactive updates of the query data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_25\n\nLANGUAGE: JavaScript\nCODE:\n```\ndata.updateQuery(previousResult => ({\n  ...previousResult,\n  count: previousResult.count + 1,\n}));\n```\n\n----------------------------------------\n\nTITLE: Writing to Cache using writeQuery with @connection\nDESCRIPTION: This code snippet shows how to use `writeQuery` to update the Apollo Client cache, clearing the feed data.  It uses the same `@connection` configuration as the query above to ensure the update targets the correct cache key. The `variables` object specifies the type to filter the feed by, and the `data` object sets the feed to an empty array, effectively clearing the cached results for that type.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nclient.writeQuery({\n  query: gql`\n    query Feed($type: FeedType!) {\n      feed(type: $type) @connection(key: \"feed\", filter: [\"type\"]) {\n        id\n      }\n    }\n  `,\n  variables: {\n    type: \"top\",\n  },\n  data: {\n    feed: [],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Potentially Masked Fields in TypeScript (TSX)\nDESCRIPTION: Illustrates accessing a field (`data.post.title`) within a TypeScript React component (TSX) after fetching data with `useQuery`. If the `GetPost` query used `@unmask(mode: \"migrate\")` on the fragment defining `title`, this direct access would trigger a development console warning, guiding developers to access the field via the fragment instead.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data } = useQuery(GET_POST);\n\nconst title = data.post.title;\n```\n\n----------------------------------------\n\nTITLE: Partial Refetch Option in Apollo Client\nDESCRIPTION: This example shows how to set the `partialRefetch` option. When set to `true`, Apollo Client will refetch the query if the result is partial and the returned data is reset by `QueryManager` due to a cache miss. The default value is `false`. Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent, and a GraphQL query definition using `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_32\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: { partialRefetch: true },\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Writing Cache Data with `writeFragment` in Apollo Client (JavaScript/GraphQL)\nDESCRIPTION: Demonstrates using `client.writeFragment` to write specific fields to a normalized cache object using a GraphQL fragment. Requires the cache ID (`id`), the fragment (`gql`), and the data (`data`) to write. Modifies the cache locally, does not push changes to the server, and triggers updates for subscribed components.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nclient.writeFragment({\n  id: 'Todo:5',\n  fragment: gql`\n    fragment MyTodo on Todo {\n      completed\n    }\n  `,\n  data: {\n    completed: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Typescript Interfaces/Types for Resolvers and FragmentMatcher - TS\nDESCRIPTION: This snippet displays the TypeScript interfaces and types for defining resolvers and FragmentMatcher in Apollo Client. It includes the `Resolvers` interface and the `FragmentMatcher` type definition. This provides type safety when working with local state management in TypeScript. The Resolvers interface defines a nested object structure of resolvers by key and field. The FragmentMatcher type defines a function signature for matching fragments.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Resolvers {\n  [key: string]: {\n    [field: string]: (\n      rootValue?: any,\n      args?: any,\n      context?: any,\n      info?: any,\n    ) => any;\n  };\n}\n\ntype FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n```\n\n----------------------------------------\n\nTITLE: Forking a GraphQL Schema using testSchema.fork\nDESCRIPTION: This snippet illustrates the use of `testSchema.fork` to create an isolated copy of a GraphQL schema. It demonstrates the creation of a new schema with a  `baseSchema` initialized with staticSchema and custom resolvers and scalars.  The forkedSchema is then modified with `forkedSchema.add`. The `restore()` method cleans up the mock setup. This approach avoids modifying the original testSchema, enabling incremental testing and preventing interference between tests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/schema-driven-testing.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst baseSchema = createTestSchema(staticSchema, {\n  resolvers: {\n    // ...\n  },\n  scalars: {\n    // ...\n  },\n});\n\ntest(\"a test\", () => {\n  const forkedSchema = baseSchema.fork();\n\n  const { restore } = createSchemaFetch(forkedSchema).mockGlobal();\n\n  // make assertions against the rendered DOM output\n\n  forkedSchema.add({\n    // ...\n  });\n\n  restore();\n  // forkedSchema will just be discarded, and there is no need to reset it\n});\n```\n\n----------------------------------------\n\nTITLE: Navigate to Docs Directory and Install Dependencies (Shell)\nDESCRIPTION: This command navigates into the cloned `docs` repository directory and runs `npm i` to install all necessary dependencies listed in its `package.json` file. This prepares the documentation site project for building and serving.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd docs && npm i\n```\n\n----------------------------------------\n\nTITLE: Using Variable Matcher Function in GraphQL Mock with TypeScript\nDESCRIPTION: This snippet defines a MockedResponse object with a variableMatcher function property that returns true for all variables, matching any invocation of GET_DOG_QUERY regardless of variables. This technique is useful when exact variables are unknown or dynamic, and request.variables cannot be used simultaneously.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { MockedResponse } from \"@apollo/client/testing\";\n\nconst dogMock: MockedResponse<Data, Variables> = {\n  request: {\n    query: GET_DOG_QUERY\n  },\n  variableMatcher: (variables) => true,\n  result: {\n    data: { dog: { __typename: 'Dog', id: 1, name: 'Buck', breed: 'poodle' } },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining FeedEntryFragment\nDESCRIPTION: This snippet defines a GraphQL fragment named `FeedEntryFragment` using the `gql` tag function, which includes fields like `commentCount`, nested `repository` information, and uses spread syntax (`...`) to include other fragments like `VoteButtonsFragment` and `EntryInfoFragment`. This fragment is colocated within `FeedEntry.jsx` and combines multiple fragments.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const FEED_ENTRY_FRAGMENT = gql`\n  fragment FeedEntryFragment on FeedEntry {\n    commentCount\n    repository {\n      full_name\n      html_url\n      owner {\n        avatar_url\n      }\n    }\n    ...VoteButtonsFragment\n    ...EntryInfoFragment\n  }\n  ${VOTE_BUTTONS_FRAGMENT}\n  ${ENTRY_INFO_FRAGMENT}\n`\n```\n\n----------------------------------------\n\nTITLE: Configuring Create React App via Craco for Production - JavaScript\nDESCRIPTION: This snippet provides a craco.config.js configuration for create-react-app projects, enabling the use of webpack.DefinePlugin to remove Apollo Client's development code. It requires craco and webpack as dependencies and expects a standard craco-based project setup. The main input is the craco.config.js configuration and the output is a reduced-size production build without development checks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  webpack: {\n    plugins: [\n      new webpack.DefinePlugin({\n        \"globalThis.__DEV__\": false,\n      }),\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing renderToStringWithData - Apollo Client React - JavaScript\nDESCRIPTION: This snippet shows how to import the renderToStringWithData function from @apollo/client/react/ssr. renderToStringWithData initiates rendering of a React component tree to a string while resolving all data requirements via Apollo GraphQL queries server-side. This function is ideal for SSR and expects a ReactElement as input, returning a Promise of the HTML string.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/ssr.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { renderToStringWithData } from \"@apollo/client/react/ssr\";\n```\n\n----------------------------------------\n\nTITLE: Using onQueryUpdated with Apollo Client Mutations\nDESCRIPTION: Shows how to use the onQueryUpdated callback to selectively refetch queries after a mutation. This pattern allows for conditional refetching based on custom logic after cache updates are applied.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\naddTodo({\n  variables: { type: input.value },\n  update(cache, result) {\n    // Update the cache as an approximation of server-side mutation effects\n  },\n  onQueryUpdated(observableQuery) {\n    // Define any custom logic for determining whether to refetch\n    if (shouldRefetchQuery(observableQuery)) {\n      return observableQuery.refetch();\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Local State with useQuery in React\nDESCRIPTION: This example shows how to read and write local state using the useQuery hook with the @client directive. The FilterLink component reads the current visibilityFilter from the cache, updates it when clicked, and conditionally applies an active state.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\nimport React from \"react\";\nimport { gql, useQuery } from \"@apollo/client\";\n\nimport Link from \"./Link\";\n\nconst GET_VISIBILITY_FILTER = gql`\n  query GetVisibilityFilter {\n    visibilityFilter @client\n  }\n`;\n\nfunction FilterLink({ filter, children }) {\n  const { data, client } = useQuery(GET_VISIBILITY_FILTER);\n  return (\n    <Link\n      onClick={() => client.writeQuery({\n        query: GET_VISIBILITY_FILTER,\n        data: { visibilityFilter: filter },\n      })}\n      active={data.visibilityFilter === filter}\n    >\n      {children}\n    </Link>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using updateQuery for Combined Cache Read/Write in Apollo Client (JavaScript)\nDESCRIPTION: Shows how to use the `cache.updateQuery` method as a convenience to both read from and write to the cache in a single operation. It takes a query and an update function. The update function receives the current cached data and returns the modified data to be written back, following immutable update patterns. This example marks all todos as completed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Query to fetch all todo items\nconst query = gql`\n  query MyTodoAppQuery {\n    todos {\n      id\n      text\n      completed\n    }\n  }\n`;\n\n// Set all todos in the cache as completed\ncache.updateQuery({ query }, (data) => ({\n  todos: data.todos.map((todo) => ({ ...todo, completed: true }))\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating Multipart Subscription Adapter for Relay with Apollo Client - TypeScript/TSX\nDESCRIPTION: This TypeScript snippet shows how to implement a multipart subscription network adapter in a Relay environment using Apollo Client utilities. It imports createFetchMultipartSubscription and wires the returned fetchMultipartSubs into Relay's Network.create method alongside a fetchQuery function. The resulting network stack is used to instantiate a Relay Environment. Requires @apollo/client utilities, relay-runtime, and a backend endpoint for multipart subscriptions. Key parameters include the GraphQL endpoint URL and user-defined fetchQuery. Output is a configured RelayEnvironment instance supporting multipart subscriptions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_12\n\nLANGUAGE: TSX\nCODE:\n```\nimport { createFetchMultipartSubscription } from \"@apollo/client/utilities/subscriptions/relay\";\nimport { Environment, Network, RecordSource, Store } from \"relay-runtime\";\n\nconst fetchMultipartSubs = createFetchMultipartSubscription(\n  \"http://localhost:4000\"\n);\n\nconst network = Network.create(fetchQuery, fetchMultipartSubs);\n\nexport const RelayEnvironment = new Environment({\n  network,\n  store: new Store(new RecordSource()),\n});\n```\n\n----------------------------------------\n\nTITLE: Subscription Data Masking with useSubscription Hook in Apollo Client (JavaScript)\nDESCRIPTION: This React function component uses Apollo Client's useSubscription hook to execute a GraphQL subscription. The data field obtained from useSubscription is masked, but the onData callback receives unmasked data. Dependency: @apollo/client. Input: subscription document and observer; Output: masked data in the hook and unmasked data in handler. This illustrates the difference in masking application between hook return values and event callbacks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_45\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction MyComponent() {\n  // data is masked\n  const { data } = useSubscription(SUBSCRIPTION, {\n    onData: ({ data }) => {\n      // data is unmasked\n    }\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Apollo Client with upload link in JavaScript\nDESCRIPTION: Sample code demonstrating how to configure Apollo Client to support file uploads by importing necessary classes and creating a client instance with an upload link. This setup requires 'apollo-client', 'apollo-cache-inmemory', and 'apollo-upload-client' packages.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/file-uploads.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { ApolloClient } = require('apollo-client')\nconst { InMemoryCache } = require('apollo-cache-inmemory')\nconst { createUploadLink } = require('apollo-upload-client')\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: createUploadLink()\n})\n```\n\n----------------------------------------\n\nTITLE: Transforming Custom Directives with DocumentTransform (TypeScript)\nDESCRIPTION: This code demonstrates using `DocumentTransform` to modify a GraphQL document at runtime. It shows how a custom `@feature` directive can be transformed into a standard `@include` directive with an added variable definition, enabling conditional field inclusion based on a feature flag system. The transform logic itself (commented out) would implement the details of this modification, noting that document transforms are limited to modifying the document structure and cannot access cache or response data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst query = gql`\n  query MyQuery {\n    myCustomField @feature(name: \"custom\", version: 2)\n  }\n`;\n\nconst documentTransform = new DocumentTransform((document) => {\n  // convert `@feature` directives to `@include` directives and update variable definitions\n});\n\ndocumentTransform.transformDocument(query);\n// query MyQuery($feature_custom_v2: Boolean!) {\n//   myCustomField @include(if: $feature_custom_v2)\n// }\n```\n\n----------------------------------------\n\nTITLE: Combining @type Directive and typePatcher\nDESCRIPTION: Illustrates using both the `@type` directive and the `typePatcher` configuration simultaneously for different fields within the same query. The `results` field uses `@type`, while `typePatchedResults` relies on the `typePatcher`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results @type(name: \"Results\") {\n      name\n    }\n    typePatchedResults {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Read Behavior for Dangling References in Apollo Client (JavaScript)\nDESCRIPTION: Defines custom read functions within the InMemoryCache typePolicies to control how fields with possible dangling references are resolved. The example policy for Query.ruler returns a default deity object if the existing reference is not readable, and Deity.offspring filters out any non-readable offspring references, providing an empty array as a fallback. Requires specifying typePolicies during InMemoryCache instantiation; designed to ensure cache consistency and provide default values or cleanup when references may be missing.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        ruler(existingRuler, { canRead, toReference }) {\n          // If there is no existing ruler, Apollo becomes the ruling deity\n          return canRead(existingRuler) ? existingRuler : toReference({\n            __typename: \"Deity\",\n            name: \"Apollo\",\n          });\n        },\n      },\n    },\n\n    Deity: {\n      keyFields: [\"name\"],\n      fields: {\n        offspring(existingOffspring: Reference[], { canRead }) {\n          // Filter out any dangling references left over from removing\n          // offspring, supplying a default empty array if there are no\n          // offspring left.\n          return existingOffspring\n            ? existingOffspring.filter(canRead)\n            : [];\n        },\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using @nonreactive Fragment Spreads in Apollo Client React Components (JavaScript/JSX)\nDESCRIPTION: This snippet demonstrates how to define a GraphQL fragment (TrailFragment) and query (ALL_TRAILS) using the gql template literal tag, applying the @nonreactive directive to the fragment spread within the ALL_TRAILS query. The App React component leverages the useQuery hook to fetch the list of trails and renders child Trail components using just the trail id as a prop. Dependencies include Apollo Client's gql, useQuery, and a React environment. Key parameters include no explicit inputs besides configuration of GraphQL endpoints; outputs are rendered React elements. The code shows how @nonreactive prevents parent re-renders when child data changes, enabling granular reactivity. It assumes a functional Apollo cache and schema including Trail and allTrails types.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_22\n\nLANGUAGE: JSX\nCODE:\n```\nconst TrailFragment = gql`\n  fragment TrailFragment on Trail {\n    name\n    status\n  }\n`;\n\nconst ALL_TRAILS = gql`\n  query allTrails {\n    allTrails {\n      id\n      ...TrailFragment @nonreactive\n    }\n  }\n  ${TrailFragment}\n`;\n\nfunction App() {\n  const { data, loading } = useQuery(ALL_TRAILS);\n  return (\n    <main>\n      <h2>Ski Trails</h2>\n      <ul>\n        {data?.trails.map((trail) => (\n          <Trail key={trail.id} id={trail.id} />\n        ))}\n      </ul>\n    </main>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Import and Use GraphQL Query with Apollo HOC (JavaScript)\nDESCRIPTION: Imports the `currentUserQuery` variable from the `./currentUser.graphql` file, which is processed by the Webpack loader. It then uses the `@apollo/react-hoc` `graphql` higher-order component to connect this query to a React class component, providing the query results as props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/webpack.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport React, { Component } from 'react';\nimport { graphql } from '@apollo/react-hoc';\nimport currentUserQuery from './currentUser.graphql';\n\nclass Profile extends Component { ... }\nProfile.propTypes = { ... };\n\nexport default graphql(currentUserQuery)(Profile)\n```\n\n----------------------------------------\n\nTITLE: Install VS Code Devtools Package - npm\nDESCRIPTION: This command uses npm to install the `@apollo/client-devtools-vscode` package. This package is required on the client-side code base to programmatically connect an `ApolloClient` instance to the Apollo Client Devtools panel running within Visual Studio Code, enabling remote debugging capabilities.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/developer-tooling.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @apollo/client-devtools-vscode\n```\n\n----------------------------------------\n\nTITLE: Configuring RestLink with Default and Named Endpoints\nDESCRIPTION: Illustrates configuring `RestLink` with both a default endpoint (using the `uri` option) and additional named endpoints (using the `endpoints` option). Queries without an explicit `endpoint` in the `@rest` directive will use the default URI.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nconst link = new RestLink({\n  endpoints: { github: 'github.com' },\n  uri: 'api.com',\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Variables to Mutations in Apollo Client\nDESCRIPTION: This code demonstrates how to pass `variables` to a mutation operation within Apollo Client's `graphql` function.  Variables are used to execute a mutation with specific values. Variables can be computed from props. Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent, and a GraphQL mutation definition with `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_35\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(\n  gql`\n  mutation MyMutation ($foo: String!, $bar: String!) {\n    ...\n  }\n`,\n  {\n    options: props => ({\n      variables: {\n        foo: props.foo,\n        bar: props.bar,\n      },\n    }),\n  },\n)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Keeping __typename in Nested Fields\nDESCRIPTION: This snippet configures the `removeTypenameFromVariables` link to retain the `__typename` field for nested fields within specific input object types, even within JSON scalars. This uses a nested object within the `except` option. The `DashboardInput` is an example.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { removeTypenameFromVariables, KEEP } from '@apollo/client/link/remove-typename';\n\nconst removeTypenameLink = removeTypenameFromVariables({\n  except: {\n    DashboardInput: {\n      config: KEEP\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Masked Types with Unmasked Helper\nDESCRIPTION: Shows the usage of the `Unmasked` helper type, which unwraps masked types generated by Codegen, providing the full, combined type structure without the masking metadata. This type is useful for inspecting the complete shape of data or in specific scenarios where the unmasked type is required, and it's the type Apollo Client uses internally when the masking mode is set to `unmask`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_61\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Unmasked } from \"@apollo/client\";\n\ntype QueryType = {\n  currentUser: {\n    __typename: \"User\";\n    id: string;\n    name: string;\n  } & { \" $fragmentRefs\"?: { UserFragment: UserFragment } }\n}\n\ntype UserFragment = {\n  __typename: \"User\";\n  age: number | null;\n} & { \" $fragmentName\"?: \"UserFragment\" }\n\ntype UnmaskedQueryType = Unmasked<QueryType>;\n//   ^? type UnmaskedQueryType = {\n//        currentUser: {\n//          __typename: \"User\";\n//          id: string;\n//          name: string;\n//          age: number | null;\n//        }\n//      }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Definition for ServerParseError (Conceptual)\nDESCRIPTION: Describes the structure of a `ServerParseError` object thrown by `HttpLink`. This error occurs when the server's HTTP response body cannot be parsed as valid JSON. It includes the raw fetch `Response` object, the HTTP `statusCode`, and the raw `bodyText` received from the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-http.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n//type ServerParseError\n{\n  response: Response;               // Object returned from fetch()\n  statusCode: number;               // HTTP status code\n  bodyText: string                  // text that was returned from server\n};\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query Requiring Typename Patching\nDESCRIPTION: A GraphQL query example demonstrating a scenario where nested objects (`results`) returned by the REST API lack a `__typename`, requiring a mechanism like `typePatcher` or the `@type` directive to add it for Apollo Client caching.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_7\n\nLANGUAGE: graphql\nCODE:\n```\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Local Field Values as Variables with @export in JavaScript\nDESCRIPTION: Defines a GraphQL query using the `gql` tag in JavaScript. It shows how the `@export(as: \"authorId\")` directive on the `@client` field `currentAuthorId` exports its resolved value to be used as the `$authorId` variable for the `postCount` field within the same query.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/directives.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst GET_CURRENT_AUTHOR_POST_COUNT = gql`\n  query CurrentAuthorPostCount($authorId: Int!) {\n    currentAuthorId @client @export(as: \"authorId\")\n    postCount(authorId: $authorId)\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Throttling REST Requests using Custom Fetch and pThrottle in JavaScript\nDESCRIPTION: Shows how to use the `p-throttle` library within a `customFetch` function to limit the number of concurrent REST requests (to 2) and enforce a minimum delay (500ms) between batches. This is useful for avoiding rate limits on APIs. Requires `p-throttle` and `RestLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_19\n\nLANGUAGE: js\nCODE:\n```\nimport pThrottle from \"p-throttle\";\n\nconst link = new RestLink({\n  endpoints: \"/api\",\n  customFetch: pThrottle((uri, config) => {\n      return fetch(uri, config);\n    },\n    2, // Max. concurrent Requests\n    500 // Min. delay between calls\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing graphql-tag-swc-plugin with yarn\nDESCRIPTION: This snippet shows how to install the `graphql-tag-swc-plugin` package using yarn as a development dependency. This is an alternative to using npm.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add --dev graphql-tag-swc-plugin\n```\n\n----------------------------------------\n\nTITLE: Person Object JSON After Cache Reference Replacement\nDESCRIPTION: This JSON snippet shows the same `Person` object after Apollo Client's cache has performed normalization. The nested `homeworld` field's original object value has been replaced by a `__ref` field containing the cache ID (`Planet:cGxhbmV0czox`), pointing to the separate, normalized `Planet` object stored in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/overview.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"__typename\": \"Person\",\n  \"id\": \"cGVvcGxlOjE=\",\n  \"name\": \"Luke Skywalker\",\n  \"homeworld\": {\n    \"__ref\": \"Planet:cGxhbldzOx\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Automatically Stripping __typename Fields from Variables in Apollo Link HTTP\nDESCRIPTION: This snippet modifies Apollo Link HTTP, Batch HTTP, and GraphQL WebSocket links to automatically remove `__typename` fields from variables before sending requests. This prevents the need for manual cleanup and ensures cleaner request payloads, facilitating easier cache updates and data handling.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_25\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Installing graphql-ws library - Bash\nDESCRIPTION: This snippet provides the command-line instruction to install the `graphql-ws` library using npm. This library is required to use WebSocket subscriptions with Apollo Client's `GraphQLWsLink`. Execute this command in your project's terminal.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install graphql-ws\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack Directly to Disable Development Mode - JavaScript\nDESCRIPTION: This JavaScript snippet adds a webpack.DefinePlugin to an existing Webpack configuration to set globalThis.__DEV__ to false. It's intended for any JavaScript project using a plain webpack config. Users need webpack as a dependency. Inputs are in the form of an existing Webpack config file, and the output is a minimized bundle with development checks removed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconfig.plugins.push(\n  new webpack.DefinePlugin({\n    \"globalThis.__DEV__\": false,\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Equivalent Query Without Fragment\nDESCRIPTION: The expanded version of the GetPerson query, showing the fields that would be included when the NameParts fragment is resolved.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetPerson {\n  people(id: \"7\") {\n    firstName\n    lastName\n    avatar(size: LARGE)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Jest Mock Function as Variable Matcher in GraphQL Mock with TypeScript\nDESCRIPTION: This snippet uses a jest.fn() mock function for variableMatcher to assert that specific variables are passed into queries. The matcher mock is set to return true, allowing the mock to match calls. It facilitates fine-grained testing of query variable usage in components.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { MockedResponse } from \"@apollo/client/testing\";\n\nconst dogMock: MockedResponse<Data, Variables> = {\n  request: {\n    query: GET_DOG_QUERY\n  },\n  variableMatcher: jest.fn().mockReturnValue(true),\n  result: {\n    data: { dog: { __typename: 'Dog', id: 1, name: 'Buck', breed: 'poodle' } },\n  },\n};\n\nexpect(variableMatcher).toHaveBeenCalledWith(expect.objectContaining({\n  name: 'Buck'\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining Field Policy for Local-only Field in Apollo Client Cache JavaScript\nDESCRIPTION: This JavaScript snippet shows how to configure Apollo Client's InMemoryCache with a field policy to resolve the Product.isInCart field locally. The field policy for isInCart on the Product type provides a custom read function that checks if the supplied productId variable exists in the CART item of localStorage. Dependencies: Apollo Client, access to localStorage. Key parameter: variables.productId is used to identify the product. The output is a boolean derived from the local CART array. Limitation: The approach assumes CART is a string in localStorage and does not handle errors or item absence.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: { // Type policy map\n    Product: {\n      fields: { // Field policy map for the Product type\n        isInCart: { // Field policy for the isInCart field\n          read(_, { variables }) { // The read function for the isInCart field\n            return localStorage.getItem('CART').includes(\n              variables.productId\n            );\n          }\n        }\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Pagination with data.fetchMore() in Apollo Client\nDESCRIPTION: This snippet demonstrates how to use the fetchMore method to implement pagination by appending new data to an existing list within a React component. It requires a previous query result, new fetch result, and variables to produce an updated data object for the Apollo cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_22\n\nLANGUAGE: JavaScript\nCODE:\n```\ndata.fetchMore({\n  updateQuery: (previousResult, { fetchMoreResult, variables }) => {\n    return {\n      ...previousResult,\n      // Add the new feed data to the end of the old feed data.\n      feed: [...previousResult.feed, ...fetchMoreResult.feed],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Ensuring Queries Without 'currentUser' Are Unaffected by the Transform in TypeScript\nDESCRIPTION: Demonstrates that the custom DocumentTransform leaves queries unchanged if they do not select 'currentUser'. The code transforms a query for 'user' and prints the resulting query to verify no modifications occurred. Input is a GraphQL query AST; output is the untransformed printed query string.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst query = gql`\n  query TestQuery {\n    user {\n      name\n    }\n  }\n`;\n\nconst modifiedQuery = documentTransform.transformDocument(query);\n\nconsole.log(print(modifiedQuery));\n// query TestQuery {\n//   user {\n//     name\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Query for Book with Author Languages\nDESCRIPTION: A GraphQL query example that fetches the `Book` with a list of `authors` and their languages. This query serves to demonstrate how to merge the data related to `authors` in the cache if the incoming data contains different fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_14\n\nLANGUAGE: graphql\nCODE:\n```\nquery BookWithAuthorLanguages {\n  favoriteBook {\n    isbn\n    title\n    authors {\n      language\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Understanding the flow of resolving `@client` fields in Apollo Client\nDESCRIPTION: This section explains the process Apollo Client follows when executing a query with `@client` directives, including checking for a local resolver and fetching data directly from the cache. Although not presented as a code snippet, it provides conceptual understanding critical for implementing local state management.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Managing paginated variables with fetchMore and React useState Hook in JSX\nDESCRIPTION: This React component example shows how to dynamically manage `limit` and `offset` variables for paginated queries using the `useState` Hook alongside Apollo Client's `useQuery` and `fetchMore`. It loads more items on demand, updates the `limit` state after fetching new pages to include all received items, and ensures that the paginated query reflects the increasing dataset. This pattern allows fine-grained control of pagination variables in the component's state to handle paginated cache reads properly.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/offset-based.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst FeedData = () => {\n  const [limit, setLimit] = useState(10);\n  const { loading, data, fetchMore } = useQuery(FEED_QUERY, {\n    variables: {\n      offset: 0,\n      limit,\n    },\n  });\n\n  if (loading) return <Loading/>;\n\n  return (\n    <Feed\n      entries={data.feed || []}\n      onLoadMore={() => {\n        const currentLength = data.feed.length;\n        fetchMore({\n          variables: {\n            offset: currentLength,\n            limit: 10,\n          },\n        }).then(fetchMoreResult => {\n          // Update variables.limit for the original query to include\n          // the newly added feed items.\n          setLimit(currentLength + fetchMoreResult.data.feed.length);\n        });\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SWC to Remove Development Code - JSON\nDESCRIPTION: This .swcrc JSON configuration uses SWC's optimizer to globally redefine globalThis.__DEV__ as \"false\" and remove development-only code from Apollo Client. The snippet requires SWC and proper placement of this file in your project. Input is a .swcrc config file and the output bundle will have development checks eliminated.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"jsc\": {\n    \"transform\": {\n      \"optimizer\": {\n        \"globals\": {\n          \"vars\": {\n            \"globalThis.__DEV__\": \"false\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying a List Field in GraphQL\nDESCRIPTION: A basic GraphQL query demonstrating how to fetch a list of book titles. This query, without pagination arguments, can potentially return a very large amount of data if the 'books' list is extensive.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/overview.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetBookTitles {\n  books {\n    title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Map to Store Unique Paginated Items in Apollo Client with JavaScript\nDESCRIPTION: Implements a pagination strategy where the internal cache stores a set of unique items as an object map keyed by item IDs. The merge function merges incoming items into this map, preventing overwrites of unrelated items. The read function returns the stored items as an array, maintaining predictable ordering via JavaScript's insertion order. This approach simplifies managing uniqueness but requires careful cursor management outside the cache structure.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/cursor-based.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: [\"type\"],\n\n          // While args.cursor may still be important for requesting\n          // a given page, it no longer has any role to play in the\n          // merge function.\n          merge(existing, incoming, { readField }) {\n            const merged = { ...existing };\n            incoming.forEach(item => {\n              merged[readField(\"id\", item)] = item;\n            });\n            return merged;\n          },\n\n          // Return all items stored so far, to avoid ambiguities\n          // about the order of the items.\n          read(existing) {\n            return existing && Object.values(existing);\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Ensuring Completion of Refetched Queries with 'options.awaitRefetchQueries'\nDESCRIPTION: This snippet provides a brief explanation that setting 'options.awaitRefetchQueries' to true ensures that refetched queries are completed before the mutation resolves. This helps in maintaining data consistency before proceeding further.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_39\n\n\n\n----------------------------------------\n\nTITLE: Filtering for 'currentUser' Fields in a Document Transform in TypeScript\nDESCRIPTION: Within the 'Field' visitor, this code checks whether the current field's name is 'currentUser' and returns early (leaving the node unchanged) if it is not. This focuses subsequent logic on the target field only. The approach relies on the structure of the GraphQL AST provided by graphql-js.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst transformedDocument = visit(document, {\n  Field(field) {\n    if (field.name.value !== 'currentUser') {\n      return;\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using variables with useReadQuery in TypeScript\nDESCRIPTION: Specifies how to define GraphQL variables for a query. Each key in the object corresponds to a variable name, with its associated value.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{ [key: string]: any }\n```\n\n----------------------------------------\n\nTITLE: Apollo Client: Query Signature with Full Query Example\nDESCRIPTION: This snippet shows the format of a query signature that includes the full query text, used when the client needs to register the hash with the server. It’s essential for the initial query and hash registration. Dependencies: Apollo Client. Input: None. Output: A JSON object showing the full query along with the hash within the `extensions` field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  operationName: 'MyQuery',\n  variables: null,\n  query: `query MyQuery { id }`,\n  extensions: {\n    persistedQuery: {\n      version: 1,\n      sha256Hash: hashOfQuery\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bulk Query Inclusion with Dynamic Filtering in Apollo Client (TypeScript)\nDESCRIPTION: This snippet demonstrates combining the include option (set to 'active') with onQueryUpdated to dynamically filter which active queries are refetched. The callback returns a boolean based on custom logic, enabling fine-grained control over which queries get refetched. Inputs: all active queries; Output: subset is refetched according to filter.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  // Include all active queries by default, which may be ill-advised unless\n  // you also use onQueryUpdated to filter those queries.\n  include: \"active\";\n\n  // Called once for every active query, allowing dynamic filtering:\n  onQueryUpdated(observableQuery) {\n    return !shouldIgnoreQuery(observableQuery);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up Polyfills for Text Streaming in React Native\nDESCRIPTION: Imports and configures necessary polyfills to enable text streaming functionality for @defer and multipart HTTP subscriptions in React Native applications.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/react-native.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { polyfill as polyfillEncoding } from \"react-native-polyfill-globals/src/encoding\";\nimport { polyfill as polyfillReadableStream } from \"react-native-polyfill-globals/src/readable-stream\";\nimport { polyfill as polyfillFetch } from \"react-native-polyfill-globals/src/fetch\";\n\npolyfillReadableStream();\npolyfillEncoding();\npolyfillFetch();\n```\n\n----------------------------------------\n\nTITLE: Deferring ItemFragment Data Loading with GraphQL\nDESCRIPTION: This code demonstrates the use of the `@defer` directive in a GraphQL query to defer the loading of the `ItemFragment` data. The query retrieves the list and then defers the loading of the text fields of the item until later. Requires Apollo Client and GraphQL server support for the `@defer` directive.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_29\n\nLANGUAGE: graphql\nCODE:\n```\nquery GetItemList {\n  list {\n    id\n    ...ItemFragment @defer\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Establishing a request handler with context and timing in Apollo Link\nDESCRIPTION: This snippet shows how to create a link that records the start time before sending the request and logs the operation duration after the server responds, utilizing the `setContext` and `getContext` methods for timing telemetry.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloLink } from '@apollo/client';\n\nconst roundTripLink = new ApolloLink((operation, forward) => {\n  // Called before operation is sent to server\n  operation.setContext({ start: new Date() });\n\n  return forward(operation).map((data) => {\n    // Called after server responds\n    const time = new Date() - operation.getContext().start;\n    console.log(`Operation ${operation.operationName} took ${time} to complete`);\n    return data;\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client for Server-side Rendering\nDESCRIPTION: Server-side initialization of Apollo Client with ssrMode enabled. This example shows how to create an HttpLink with proper authentication headers and configure the cache for server-side use.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  ApolloClient,\n  createHttpLink,\n  InMemoryCache\n} from '@apollo/client';\n\nconst client = new ApolloClient({\n  ssrMode: true,\n  link: createHttpLink({\n    uri: 'http://localhost:3010',\n    credentials: 'same-origin',\n    headers: {\n      cookie: req.header('Cookie'),\n    },\n  }),\n  cache: new InMemoryCache(),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with onError Link (JavaScript)\nDESCRIPTION: This JavaScript code snippet demonstrates how to use the `onError` link in Apollo Client to handle GraphQL, protocol, and network errors.  It imports the `onError` function and defines a callback to log specific error details such as message, location, path, and extensions. The code logs different error types when they occur during a GraphQL operation to facilitate debugging and monitoring.  No specific dependencies beyond Apollo Client are required for this code snippet.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-error.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { onError } from \"@apollo/client/link/error\";\n\n// Log any GraphQL errors, protocol errors, or network error that occurred\nconst errorLink = onError(({ graphQLErrors, networkError, protocolErrors }) => {\n  if (graphQLErrors)\n    graphQLErrors.forEach(({ message, locations, path }) =>\n      console.log(\n        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`\n      )\n    );\n\n  if (protocolErrors) {\n    protocolErrors.forEach(({ message, extensions }) => {\n      console.log(\n        `[Protocol error]: Message: ${message}, Extensions: ${JSON.stringify(extensions)}`\n      );\n    });\n  }\n\n  if (networkError) console.log(`[Network error]: ${networkError}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Controlling Polling Behavior with skipPollAttempt in Apollo Client - TypeScript\nDESCRIPTION: Illustrates how to prevent a polling refetch in Apollo Client by providing a skipPollAttempt callback function. If this function returns true (e.g., when the browser tab is hidden or inactive), polling is skipped for that cycle. Can be supplied per-query via useQuery options or globally in ApolloClient defaultOptions. Assumes recent Apollo Client version supporting skipPollAttempt. Expected input includes QUERY and an environment where document.hidden or document.hasFocus is meaningful. Output is reduced network usage during inactive sessions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nuseQuery(QUERY, {\n  pollInterval: 1000,\n  skipPollAttempt: () => document.hidden, // or !document.hasFocus()\n});\n// or define it globally\nnew ApolloClient({\n  defaultOptions: {\n    watchQuery: {\n      skipPollAttempt: () => document.hidden, // or !document.hasFocus()\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing possibleTypes JSON\nDESCRIPTION: This code snippet demonstrates the import of the `possibleTypes` data, which is generated by introspection or GraphQL Codegen, into a TypeScript/JavaScript file. This allows the client to correctly handle polymorphic data.  The path to the `possibleTypes.json` is specified in the import statement.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport possibleTypes from './path/to/possibleTypes.json';\n\nconst cache = new InMemoryCache({\n  possibleTypes,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Crypto Hash Dependency for APQ (bash)\nDESCRIPTION: Installs the crypto-hash package, which provides a SHA-256 function required by the Apollo persisted queries link when implementing APQ. Necessary if no other hashing implementation is available.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm install crypto-hash\n```\n\n----------------------------------------\n\nTITLE: Load GraphQL Query with graphql.macro (JavaScript)\nDESCRIPTION: Demonstrates how to load a `.graphql` file in a Create-React-App environment without ejecting, using `graphql.macro`. It imports the `loader` function from `graphql.macro` and uses it to load the contents of the specified `.graphql` file at build time.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/webpack.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { loader } from 'graphql.macro';\nconst currentUserQuery = loader('./currentUser.graphql');\n```\n\n----------------------------------------\n\nTITLE: Preloading Queries Outside React using createQueryPreloader - TypeScript\nDESCRIPTION: This snippet demonstrates preloading queries outside of React using `createQueryPreloader`. It initializes a preload function with `createQueryPreloader` and calls it to start fetching data before the React component renders. The `queryRef` returned by the preload function is then passed to `useReadQuery` within the component.  Requires Apollo Client, React, and a running GraphQL server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  // ...\n  createQueryPreloader\n} from '@apollo/client';\n\n// This `preloadQuery` function does not have to be created each time you\n// need to preload a new query. You may prefer to export this function\n// alongside your client instead.\nconst preloadQuery = createQueryPreloader(client);\nconst preloadedQueryRef = preloadQuery(GET_DOGS_QUERY);\n\nfunction App() {\n  const { data } = useReadQuery(preloadedQueryRef);\n  const [loadDog, queryRef] = useLoadableQuery(GET_DOG_QUERY)\n\n  return (\n    <>\n      <select\n        onChange={(e) => loadDog({ id: e.target.value })}\n      >\n        {data.dogs.map(({ id, name }) => (\n          <option key={id} value={id}>{name}</option>\n        ))}\n      </select>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Dog queryRef={queryRef} />\n      </Suspense>\n    </>\n  );\n}\n\nconst root = createRoot(document.getElementById('app'));\n\nroot.render(\n  <ApolloProvider client={client}>\n    <Suspense fallback={<div>Loading...</div>}>\n      <App />\n    </Suspense>\n  </ApolloProvider>\n);\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client with @client Selection Set Resolver\nDESCRIPTION: Configures Apollo Client to resolve an entire local selection set ('session') marked with `@client`. It includes a resolver that returns a structured object simulating local session details, including '__typename' for type policy matching.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, gql } from '@apollo/client';\n\nconst MEMBER_DETAILS = gql`\n  query Member {\n    member {\n      name\n      role\n      session @client {\n        isLoggedIn\n        connectionCount\n        errors\n      }\n    }\n  }\n`;\n\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: 'http://localhost:4000/graphql' }),\n  cache: new InMemoryCache(),\n  resolvers: {\n    Member: {\n      session() {\n        return {\n          __typename: 'Session',\n          isLoggedIn: someInternalLoginVerificationFunction(),\n          connectionCount: calculateOpenConnections(),\n          errors: sessionError(),\n        };\n      }\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Specific Endpoints with @rest Directive\nDESCRIPTION: Shows how to specify which named endpoint to use for a particular REST call within a GraphQL query by adding the `endpoint` argument to the `@rest` directive.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nconst postTitleQuery1 = gql`\n  query PostTitle {\n    post @rest(type: \"Post\", path: \"/post\", endpoint: \"v1\") {\n      id\n      title\n    }\n  }\n`;\nconst postTitleQuery2 = gql`\n  query PostTitle {\n    post @rest(type: \"[Tag]\", path: \"/tags\", endpoint: \"v2\") {\n      id\n      tags\n    }\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Writing a GraphQL Fragment to Apollo Cache (TypeScript)\nDESCRIPTION: The `writeFragment` method allows writing data to the Apollo Client cache in the shape of a GraphQL fragment. It takes an options object with the fragment, ID of the cached object and the data to write.  It returns a Reference or undefined.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nwriteFragment<TData = any, TVariables = any>(\n  options: Cache.WriteFragmentOptions<TData, TVariables>,\n): Reference | undefined\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema Definition for Paginated Feed Query\nDESCRIPTION: Defines a GraphQL schema for a `Query` type with a `feed` field that accepts `offset`, `limit`, and `category` arguments and returns a list of `FeedItem` objects. The `offset` and `limit` arguments are typically used for pagination.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  feed(offset: Int, limit: Int, category: Category): [FeedItem!]\n}\n```\n\n----------------------------------------\n\nTITLE: Importing getDataFromTree - Apollo Client React - JavaScript\nDESCRIPTION: This code snippet demonstrates how to import the getDataFromTree function from the @apollo/client/react/ssr package. getDataFromTree is used to traverse a React component tree, resolve all GraphQL queries needed for SSR, and fetch the required data before rendering. Requires Apollo Client v3 or above as a dependency and expects a React component tree as input.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/ssr.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { getDataFromTree } from \"@apollo/client/react/ssr\";\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Persisted Query Lists (bash)\nDESCRIPTION: Installs the @apollo/persisted-query-lists package, providing utilities for working with persisted query manifests in the Apollo Client. Required for safelisting with operation manifests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/persisted-query-lists\n```\n\n----------------------------------------\n\nTITLE: Nesting and Consuming Multiple Fragments with useFragment in Apollo Client (JavaScript)\nDESCRIPTION: This React component (PostDetails) demonstrates how to nest fragments by composing PostDetailsFragment to include a spread of CommentFragment, and how to use the useFragment hook for masked cache reads in Apollo Client. It imports COMMENT_FRAGMENT, defines the composite POST_DETAILS_FRAGMENT with fragment spreads, and uses fragmentName to select the proper fragment in the gql document. Dependencies: @apollo/client, COMMENT_FRAGMENT, PostDetailsFragment. Inputs: post object. Outputs: Section rendering title, description, and nested comment. The component requires specifying fragmentName due to multiple fragment definitions within the gql document.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_41\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { COMMENT_FRAGMENT } from \"./Comment\";\n\nexport const POST_DETAILS_FRAGMENT = gql`\n  fragment PostDetailsFragment on Post {\n    title\n    shortDescription\n    topComment {\n      id\n      ...CommentFragment\n    }\n  }\n\n  ${COMMENT_FRAGMENT}\n`;\n\nexport default function PostDetails({ post }) {\n  const { data, complete } = useFragment({\n    fragment: POST_DETAILS_FRAGMENT,\n    from: post,\n    fragmentName: \"PostDetailsFragment\",\n  });\n\n  // complete check omitted for brevity\n\n  return (\n    <section>\n      <h1>{data.title}</h1>\n      <p>{data.shortDescription}</p>\n      <Comment comment={data.topComment} />\n    </section>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Import Fragment in GraphQL Query File (GraphQL)\nDESCRIPTION: Shows how to import a GraphQL fragment defined in `./UserInfoFragment.graphql` into a query file using the `#import` directive. This allows breaking down complex queries into smaller, reusable fragment definitions across multiple files which are then combined by the loader.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/webpack.mdx#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\n#import \"./UserInfoFragment.graphql\"\n\nquery CurrentUserForLayout {\n  currentUser {\n    ...UserInfo\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the reset Function from useMutation to Reset State after Mutation - JavaScript/JSX\nDESCRIPTION: This login page component demonstrates how to destructure and use the reset function from the result object of the useMutation hook. When a login error occurs, the error message is displayed in a child component, with the onDismiss handler bound to reset(), allowing the UI to clear error state and mutation results. Prerequisite: @apollo/client with a LOGIN_MUTATION defined. Expects standard form inputs and handles error states for improved user experience.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_6\n\nLANGUAGE: JSX\nCODE:\n```\nfunction LoginPage () {\n  const [login, { error, reset }] = useMutation(LOGIN_MUTATION);\n\n  return (\n    <>\n      <form>\n        <input class=\"login\"/>\n        <input class=\"password\"/>\n        <button onclick={login}>Login</button>\n      </form>\n      {\n        error &&\n        <LoginFailedMessageWindow\n          message={error.message}\n          onDismiss={() => reset()}\n        />\n      }\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query for Nested Fields in Apollo Client\nDESCRIPTION: This GraphQL query retrieves the 'firstName' and 'lastName' subfields from the 'fullName' field for a person. Its purpose is to demonstrate how nested cached objects can be queried and resolved through previously defined read functions in Apollo Client's field policies. No dependencies required beyond a compatible server/schema. Inputs: none. Outputs: server or cache response with 'firstName' and 'lastName'. No special constraints.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-field-behavior.mdx#_snippet_4\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery personWithFullName {\n  fullName {\n    firstName\n    lastName\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Apollo Client Cache Structure with keyArgs Configured\nDESCRIPTION: Shows the cache structure after configuring `keyArgs` to only include the `category`.  Now, only the `category` argument is included in the storage key, and items from different pages of the `SPORTS` feed are merged into a single cache entry.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  'ROOT_QUERY': {\n    'feed({\"category\":\"SPORTS\"})': [\n      {\n        '__ref': 'FeedItem:1'\n      },\n      // ...additional items from first query...\n      {\n        '__ref': 'FeedItem:11'\n      },\n      // ...additional items from second query...\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @unmask Directive\nDESCRIPTION: This snippet illustrates the use of the `@unmask` directive within a GraphQL query.  The `@unmask` directive is applied to a named fragment (`UserFields`), allowing access to all fields requested by that fragment, even when data masking is enabled. This is useful for scenarios where components need access to all data within a fragment, bypassing data masking restrictions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_5\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery {\n  user {\n    id\n    ...UserFields @unmask\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Definition for ClientParseError (Conceptual)\nDESCRIPTION: Describes the structure of a `ClientParseError` object thrown by `HttpLink`. This error occurs when the request body (e.g., variables) cannot be serialized into JSON, often due to circular references. It contains the original `Error` object encountered during parsing.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-http.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n//type ClientParseError\n{\n  parseError: Error;                // Error returned from response.json()\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Client-Side Schema Extension in Apollo Client\nDESCRIPTION: JavaScript code that defines a client-side schema extension for the Rocket type, adding a description field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst typeDefs = gql`\n  extend type Rocket {\n    description: String\n  }\n`;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Error Boundary Component in React\nDESCRIPTION: A simple implementation of a React error boundary class component that catches errors thrown by child components. This error boundary can be used to gracefully handle errors from useSuspenseQuery by displaying a fallback UI.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback;\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fragments with GraphQL Queries\nDESCRIPTION: This code snippet demonstrates how to use GraphQL fragments with the various precompilation approaches.  It shows defining a fragment and then including it within a query string, using interpolation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport gql from 'graphql-tag';\n// or import gql from 'graphql-tag.macro';\n\nconst fragments = {\n  hello: gql`\n    fragment HelloStuff on Hello {\n      universe\n      galaxy\n    }\n  `\n};\n\nconst query = gql`\n  query HelloWorld {\n    hello {\n      world\n      ...HelloStuff\n    }\n  }\n\n  ${fragments.hello}\n`;\n```\n\n----------------------------------------\n\nTITLE: Type Definition for ServerError (Conceptual)\nDESCRIPTION: Describes the structure of a `ServerError` object thrown by `HttpLink`. This error type covers non-2xx HTTP responses or responses that are structurally invalid (missing `data` or `errors`). It includes the parsed `result` (if available), the raw fetch `Response` object, and the HTTP `statusCode`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-http.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n//type ServerError\n{\n  result: Record<string, any>;      // Parsed object from server response\n  response: Response;               // Object returned from fetch()\n  statusCode: number;               // HTTP status code\n};\n```\n\n----------------------------------------\n\nTITLE: Skipping Queries with skipToken in useBackgroundQuery and Child Data Consumption (TypeScript)\nDESCRIPTION: This snippet expands on skipToken usage by showing how useBackgroundQuery and useReadQuery work together with conditional query execution in a React parent-child component relationship. The skipToken is applied to useBackgroundQuery to determine dynamically whether to start the query. The child component only attempts to read the data if a valid QueryReference is available. This approach prevents unnecessary network requests and enforces type safety. Dependencies include @apollo/client, a valid query, and expected child props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { skipToken, useBackgroundQuery } from \"@apollo/client\";\n\nfunction Parent() {\n  const [queryRef] = useBackgroundQuery(\n    query,\n    id ? { variables: { id } } : skipToken\n  );\n\n  return queryRef ? <Child queryRef={queryRef} /> : null;\n}\n\nfunction Child({ queryRef }: { queryRef: QueryReference<TData> }) {\n  const { data } = useReadQuery(queryRef);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Shared Fragment Registry for Lazy Registration\nDESCRIPTION: Setting up a shared fragment registry that can be imported across the application for lazily registering fragments.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nexport const { fragmentRegistry } = createFragmentRegistry();\n```\n\n----------------------------------------\n\nTITLE: Defining Default Options for ApolloClient Initialization - Apollo Client - JavaScript\nDESCRIPTION: This snippet demonstrates how to define a defaultOptions object for initializing the ApolloClient. The object specifies fetch and error policies for 'watchQuery', 'query', and 'mutate' operations. These options customize the default behavior of client functions, but values can still be overridden per function call. The 'defaultOptions' object should be passed as part of ApolloClientOptions during client creation. Dependencies include @apollo/client, and the keys 'watchQuery', 'query', and 'mutate' configure their respective behaviors.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/core/ApolloClient.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst defaultOptions = {\n  watchQuery: {\n    fetchPolicy: 'cache-and-network',\n    errorPolicy: 'ignore',\n  },\n  query: {\n    fetchPolicy: 'network-only',\n    errorPolicy: 'all',\n  },\n  mutate: {\n    errorPolicy: 'all',\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Read Function with Random Text Generator\nDESCRIPTION: Modified read function that returns randomized text for rocket descriptions using the faker library.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// (within InMemoryCache constructor)\nread() {\n  return oneOrTwoSentences();\n}\n```\n\n----------------------------------------\n\nTITLE: Using the @type Directive for Typename Patching\nDESCRIPTION: Demonstrates an alternative approach to typename patching using the `@type(name: ...)` directive directly within the GraphQL query. This manually assigns a `__typename` to the `results` field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_9\n\nLANGUAGE: graphql\nCODE:\n```\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results @type(name: \"Planet\") {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing apollo-upload-client package\nDESCRIPTION: Command to install the 'apollo-upload-client' package via npm, which adds support for file uploads in Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/file-uploads.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install apollo-upload-client\n```\n\n----------------------------------------\n\nTITLE: Installing babel-plugin-graphql-tag with npm\nDESCRIPTION: This snippet shows how to install the `babel-plugin-graphql-tag` package using npm as a development dependency.  It prepares the project to use the plugin for precompiling GraphQL queries written with `graphql-tag`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install --save-dev babel-plugin-graphql-tag\n```\n\n----------------------------------------\n\nTITLE: Refetching All Active Queries with Apollo Client in TypeScript\nDESCRIPTION: This snippet shows how to refetch all currently active queries managed by Apollo Client. The include option is set to 'active' to target active observable queries with observers. Requires an ApolloClient instance. No further parameters necessary. Returns a Promise resolved after all matching queries are refetched from the network.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  include: \"active\",\n});\n```\n\n----------------------------------------\n\nTITLE: Using useSuspenseFragment for Item Component\nDESCRIPTION: This React component `Item` leverages `useSuspenseFragment` for Suspense-aware data fetching. It receives an item's props and then displays the item's text. The `useSuspenseFragment` will suspend until the data is complete. Requires React, Apollo Client, `useSuspenseFragment`, and `ItemFragment` and the availability of Suspense integration.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useSuspenseFragment } from \"@apollo/client\";\n\nfunction Item(props) {\n  const { data } = useSuspenseFragment({\n    fragment: ITEM_FRAGMENT,\n    fragmentName: \"ItemFragment\",\n    from: props.item\n  });\n\n  return <li>{data.text}</li>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Webpack graphql-tag Loader (JavaScript)\nDESCRIPTION: Adds a rule to the Webpack configuration's `module.rules` array. This rule uses the `graphql-tag/loader` to process files ending with `.graphql` or `.gql`, excluding files in `node_modules`, allowing them to be imported directly in JavaScript.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/webpack.mdx#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nmodule: {\n  rules: [\n    {\n      test: /\\.(graphql|gql)$/,\n      exclude: /node_modules/,\n      loader: 'graphql-tag/loader',\n    },\n  ],\n},\n```\n\n----------------------------------------\n\nTITLE: Improving useBackgroundQuery Type Interface in Apollo Client\nDESCRIPTION: This update refines the TypeScript interface `useBackgroundQuery` to improve type safety and clarity by defining specific hook options, facilitating better developer experience and code maintainability.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_33\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query with @defer Directive Example\nDESCRIPTION: This snippet shows a GraphQL query where the @defer directive is applied to defer the retrieval of a user's friends list, enabling incremental data fetching to improve performance. It highlights the way to mark slow fields for deferred resolution, contingent on server support.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/defer.mdx#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery PersonQuery($personId: ID!) {\n  person(id: $personId) {\n    id\n    firstName\n    lastName\n\n    ... @defer {\n      friends {\n        id\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Typing Apollo Client with React and Providing to Tree\nDESCRIPTION: Demonstrates setting up Apollo Client by creating an http link and in-memory cache, and using ApolloProvider to pass the client instance to the React component tree. Shows how disconnected typing can result in type errors in child components when expected props are missing or mismatched.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_11\n\nLANGUAGE: TSX\nCODE:\n```\nimport React from \"react\";\nimport {\n  ApolloClient,\n  createHttpLink,\n  InMemoryCache,\n  ApolloProvider\n} from \"@apollo/client\";\n\nimport Character from \"./Character\";\n\nexport const link = createHttpLink({\n  uri: \"https://mpjk0plp9.lp.gql.zone/graphql\"\n});\n\nexport const client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link,\n});\n\nexport default () =>\n  <ApolloProvider client={client}>\n    // $ExpectError property `episode`. Property not found in. See: src/Character.js:43\n    <Character />\n  </ApolloProvider>;\n```\n\n----------------------------------------\n\nTITLE: Using fetchPolicy 'no-cache' in Apollo Client useQuery Hook\nDESCRIPTION: This code demonstrates how to set the fetchPolicy to 'no-cache' in an Apollo Client's useQuery hook to prevent reading from or writing to the cache for a specific GraphQL query. It is useful for retrieving data that should not be cached or persisted locally. Dependencies include '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { loading, error, data } = useQuery(GET_DOGS, {\n  fetchPolicy: \"no-cache\" // highlight-line\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Exported @client Variables to Other @client Resolvers in JavaScript\nDESCRIPTION: Demonstrates exporting a value (`currentAuthorId`) using `@client @export` and passing it as a variable (`authorId`) to another local resolver (`postCount` also marked with `@client`). This allows chaining local computations within a single operation. Requires Apollo Client setup with relevant resolvers, cache pre-population, and the GraphQL query definition. Dependencies include `@apollo/client`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, gql } from '@apollo/client';\n\nconst query = gql`\n  query CurrentAuthorPostCount($authorId: Int!) {\n    currentAuthorId @client @export(as: \"authorId\")\n    postCount(authorId: $authorId) @client\n  }\n`;\n\nconst cache = new InMemoryCache();\nconst client = new ApolloClient({\n  cache,\n  resolvers: {\n    Query: {\n      postCount(_, { authorId }) {\n        return authorId === 12345 ? 100 : 0;\n      },\n    },\n  },\n});\n\ncache.writeQuery({\n  query: gql`{ currentAuthorId }`,\n  data: {\n    currentAuthorId: 12345,\n  },\n});\n\n// ... run the query using client.query, the <Query /> component, etc.\n```\n\n----------------------------------------\n\nTITLE: Installing graphql-tag-swc-plugin with npm\nDESCRIPTION: This shows how to install the `graphql-tag-swc-plugin` package using npm as a development dependency.  This plugin is designed for use with SWC, a fast Rust-based alternative to Babel.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install --save-dev graphql-tag-swc-plugin\n```\n\n----------------------------------------\n\nTITLE: Skipping Queries with skipToken in useSuspenseQuery (TypeScript)\nDESCRIPTION: This snippet demonstrates conditional query execution in Apollo Client's useSuspenseQuery hook using the skipToken sentinel. The skipToken, imported from @apollo/client, can be returned in place of query options to prevent the query from running, offering a type-safe alternative to the deprecated 'skip' option. This pattern supports variables that may be undefined, ensuring precise control over query triggers. Inputs include the query definition and an optional variable; outputs are either query data or no data if the query is skipped.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { skipToken, useSuspenseQuery } from \"@apollo/client\";\n\nconst id: number | undefined;\n\nconst { data } = useSuspenseQuery(\n  query,\n  id ? { variables: { id } } : skipToken\n);\n```\n\n----------------------------------------\n\nTITLE: Generating possibleTypes Automatically\nDESCRIPTION: This JavaScript code uses `cross-fetch` to perform a GraphQL introspection query to retrieve the schema details and then processes this information to create a `possibleTypes` configuration.  This dynamically generates the necessary information to initialize `InMemoryCache`. It then writes the JSON to a `possibleTypes.json` file.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst fetch = require('cross-fetch');\nconst fs = require('fs');\n\nfetch(`${YOUR_API_HOST}/graphql`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    variables: {},\n    query: `\n      {\n        __schema {\n          types {\n            kind\n            name\n            possibleTypes {\n              name\n            }\n          }\n        }\n      }\n    `,\n  }),\n}).then(result => result.json())\n  .then(result => {\n    const possibleTypes = {};\n\n    result.data.__schema.types.forEach(supertype => {\n      if (supertype.possibleTypes) {\n        possibleTypes[supertype.name] =\n          supertype.possibleTypes.map(subtype => subtype.name);\n      }\n    });\n\n    fs.writeFile('./possibleTypes.json', JSON.stringify(possibleTypes), err => {\n      if (err) {\n        console.error('Error writing possibleTypes.json', err);\n      } else {\n        console.log('Fragment types successfully extracted!');\n      }\n    });\n  });\n```\n\n----------------------------------------\n\nTITLE: Overriding the Default print Function in HttpLink (JavaScript)\nDESCRIPTION: This example shows how to customize the serialization of GraphQL ASTs into query strings within HttpLink by providing a custom print function. Here, the function strips ignored characters from the default printed document, supporting query minification or whitespace removal.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ASTNode, stripIgnoredCharacters } from 'graphql';\n\nconst httpLink = new HttpLink({\n  uri: '/graphql',\n  print(\n    ast: ASTNode,\n    originalPrint: (ast: ASTNode) => string,\n  ) {\n    return stripIgnoredCharacters(originalPrint(ast));\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client for React Hooks\nDESCRIPTION: This code snippet demonstrates how to install the core Apollo Client package to enable React hooks integration, replacing previous packages like react-apollo or @apollo/react-hooks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/hooks-migration.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client\n```\n\n----------------------------------------\n\nTITLE: Stateless ApolloLink by Extending ApolloLink - JavaScript\nDESCRIPTION: This example demonstrates how to create a stateless link by extending the `ApolloLink` class and implementing the `request` method. It reimplements the error reporting functionality from the previous example as a class.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink } from '@apollo/client';\n\nclass ReportErrorLink extends ApolloLink {\n  constructor(errorCallback) {\n    super();\n    this.errorCallback = errorCallback;\n  }\n  request(operation, forward) {\n    const observable = forward(operation);\n    // errors will be sent to the errorCallback\n    observable.subscribe({ error: this.errorCallback })\n    return observable;\n  }\n}\n\nconst link = new ReportErrorLink(console.error);\n\n```\n\n----------------------------------------\n\nTITLE: Refetch Queries after Mutation using useMutation's refetchQueries Option\nDESCRIPTION: Explains how to automatically refetch certain queries after a mutation by providing the refetchQueries option in useMutation hook, useful when cache update logic is complex or insufficient. Highlights the trade-offs including extra network requests. Dependencies include '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Usage within useMutation:\n// const [mutateFunction] = useMutation(SOME_MUTATION, {\n//   refetchQueries: [{ query: SOME_QUERY }],\n// });\n```\n\n----------------------------------------\n\nTITLE: Initializing a DocumentTransform with Apollo Client in TypeScript\nDESCRIPTION: This snippet shows how to instantiate a DocumentTransform using Apollo Client, providing a callback function for transforming GraphQL documents. No transformation logic is included in this example; developers should implement their desired behavior in the callback. Prerequisites include installing '@apollo/client' and working in a TypeScript environment.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { DocumentTransform } from '@apollo/client';\n\nconst documentTransform = new DocumentTransform((document) => {\n  // Modify the document\n});\n```\n\n----------------------------------------\n\nTITLE: Installing ts-transform-graphql-tag with yarn\nDESCRIPTION: This snippet shows how to install the `ts-transform-graphql-tag` package using yarn as a development dependency.  It's an alternative to using npm.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add --dev ts-transform-graphql-tag\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query with @client Fields\nDESCRIPTION: This GraphQL query structure demonstrates how a query with @client fields appears when processed by Apollo Client's cache mechanism, showing the fields that will be checked in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_17\n\nLANGUAGE: graphql\nCODE:\n```\nlaunch(id: $launchId) {\n  isInCart\n  site\n  rocket {\n    type\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Subscription Data Masking with client.subscribe Method in Apollo Client (JavaScript)\nDESCRIPTION: This snippet creates a subscription observable using Apollo Client's client.subscribe method. Subscribers receive data in the next callback, where the data is masked according to Apollo Client's masking rules. Dependencies: @apollo/client, SUBSCRIPTION query. Input: subscription execution; Output: masked data in event handlers. Maintains masking outside of update-related contexts.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_46\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst observable = client.subscribe({ query: SUBSCRIPTION });\n\nobservable.subscribe({\n  next: ({ data }) => {\n    // data is masked\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Live Binding with useFragment using item prop (JavaScript)\nDESCRIPTION: The `Item` component utilizes the `useFragment` hook, leveraging the item object as the `from` option. It passes the entire item object via props, accessing `item.id` and `item.__typename` to fetch data via a fragment. It shows the item text or \"incomplete\" based on data availability. Depends on React, Apollo Client, and a preceding `ItemFragment`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_26\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Item(props) {\n  const { complete, data } = useFragment({\n    fragment: ITEM_FRAGMENT,\n    fragmentName: \"ItemFragment\",\n    from: props.item\n  });\n\n  return <li>{complete ? data.text : \"incomplete\"}</li>;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Authorization Header with Apollo Client HttpLink in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a custom fetch function that adds a Hawk-based Authorization header to every HTTP request before calling the standard fetch. It requires the Hawk authentication client to generate the header, and modifies the headers property of the options object passed to fetch. The resulting custom fetch is provided to Apollo Client's HttpLink, enabling authenticated requests to the GraphQL server. Inputs include the URI and fetch options object with request details; the output is the Promise returned by fetch.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-http.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst customFetch = (uri, options) => {\n  const { header } = Hawk.client.header(\n    \"http://example.com:8000/resource/1?b=1&a=2\",\n    \"POST\",\n    { credentials: credentials, ext: \"some-app-data\" }\n  );\n  options.headers.Authorization = header;\n  return fetch(uri, options);\n};\n\nconst link = new HttpLink({ fetch: customFetch });\n```\n\n----------------------------------------\n\nTITLE: Creating Multipart Subscription Adapter for Urql with Apollo Client - TypeScript/TSX\nDESCRIPTION: This TypeScript example integrates Apollo Client's multipart subscription support into an Urql client setup. It uses createFetchMultipartSubscription to produce a forwardSubscription handler for the subscriptionExchange plugin in Urql. Dependencies include @apollo/client utilities, @urql/core, and a running multipart-enabled GraphQL server. Parameters include the GraphQL endpoint URL and Urql's exchange list. The client will be able to handle multipart GraphQL subscriptions as part of its connection.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_13\n\nLANGUAGE: TSX\nCODE:\n```\nimport { createFetchMultipartSubscription } from \"@apollo/client/utilities/subscriptions/urql\";\nimport { Client, fetchExchange, subscriptionExchange } from \"@urql/core\";\n\nconst url = \"http://localhost:4000\";\n\nconst multipartSubscriptionForwarder = createFetchMultipartSubscription(url);\n\nconst client = new Client({\n  url,\n  exchanges: [\n    fetchExchange,\n    subscriptionExchange({\n      forwardSubscription: multipartSubscriptionForwarder,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing the graphql-ws library\nDESCRIPTION: Command to install the graphql-ws library, which is required for the GraphQLWsLink to function. This dependency enables WebSocket communication for GraphQL operations.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-subscriptions.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install graphql-ws\n```\n\n----------------------------------------\n\nTITLE: Checking for Existing 'id' Field in Selection Set Using graphql-js in TypeScript\nDESCRIPTION: Illustrates how to search the 'selectionSet' of a field node for an existing field named 'id', using the Kind enum to verify node types. If an 'id' field is found, BREAK halts further traversal. This is crucial for avoiding duplicate field selections when modifying GraphQL queries.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { visit, Kind, BREAK } from 'graphql';\n\nconst transformedDocument = visit(document, {\n  Field(field) {\n    // ...\n    const selections = field.selectionSet?.selections ?? [];\n\n    for (const selection of selections) {\n      if (\n        selection.kind === Kind.FIELD &&\n        selection.name.value === 'id'\n      ) {\n        return BREAK;\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Using React.version as Key for Shared Contexts in Apollo Client\nDESCRIPTION: This snippet updates context key generation in React integrations to use `React.version` for better compatibility, especially with Preact which can have multiple instances sharing the same version string, thus avoiding context sharing issues across different React versions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface for RefetchQueriesOptions in Apollo Client\nDESCRIPTION: The interface definition for the options object passed to client.refetchQueries. It includes four optional properties for controlling cache updates, specifying which queries to refetch, customizing query update behavior, and toggling optimistic cache updates.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/refetchQueries-options.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RefetchQueriesOptions<\n  TCache extends ApolloCache<any>,\n  TResult = Promise<ApolloQueryResult<any>>,\n> {\n  updateCache?: (cache: TCache) => void;\n  include?: Array<string | DocumentNode> | \"all\" | \"active\";\n  onQueryUpdated?: (\n    observableQuery: ObservableQuery<any>,\n    diff: Cache.DiffResult<any>,\n    lastDiff: Cache.DiffResult<any> | undefined,\n  ) => boolean | TResult;\n  optimistic?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing babel-plugin-graphql-tag with yarn\nDESCRIPTION: This snippet shows how to install the `babel-plugin-graphql-tag` package using yarn as a development dependency. It's an alternative to using npm.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add --dev babel-plugin-graphql-tag\n```\n\n----------------------------------------\n\nTITLE: Example Return Value from `readQuery` in Apollo Client\nDESCRIPTION: Shows the typical structure of the data object returned by a successful `client.readQuery` call. The object matches the GraphQL query shape and automatically includes the `__typename` field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  todo: {\n    __typename: 'Todo', // __typename is automatically included\n    id: 5,\n    text: 'Buy oranges 🍊',\n    completed: true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening GraphQL Selections Using graphql Visitor in TypeScript\nDESCRIPTION: This TypeScript function demonstrates how to flatten a GraphQL SelectionNode by traversing its selection sets using the visitor pattern from the graphql library. It accumulates all nested selections into a single flat array. The snippet replaces the deprecated 'flattenSelections' export from apollo-utilities and provides a practical utility to handle GraphQL AST traversal without modifying the AST directly. The code requires the 'graphql/language/visitor' module and expects a SelectionNode input, returning an array of SelectionNodes as output.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_55\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { visit } from \"graphql/language/visitor\";\n\nfunction flattenSelections(selection: SelectionNode) {\n  const selections: SelectionNode[] = [];\n  visit(selection, {\n    SelectionSet(ss) {\n      selections.push(...ss.selections);\n    },\n  });\n  return selections;\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Local and Remote Fields in Apollo Client with GraphQL\nDESCRIPTION: This GraphQL query demonstrates how to include local-only fields with the @client directive alongside remote fields in a single query for Apollo Client. The query expects a variable productId and retrieves the name and price from the server while using custom local logic for the isInCart field. Apollo Client requires the field policy for isInCart to be defined on the cache to resolve this local field. Inputs: productId (ID!). Output: a product object with name, price, and isInCart properties. The @client directive ensures isInCart is handled locally and not sent to the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_0\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery ProductDetails($productId: ID!) {\n  product(id: $productId) {\n    name\n    price\n    isInCart @client # This is a local-only field\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define GraphQL Fragment (GraphQL)\nDESCRIPTION: Defines a reusable GraphQL fragment named `UserInfo` on the `User` type. This fragment includes the `login` and `avatar_url` fields, intended to be stored in a separate `.graphql` file (`UserInfoFragment.graphql`) and imported into other query or fragment files using the `#import` directive.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/webpack.mdx#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nfragment UserInfo on User {\n  login\n  avatar_url\n}\n```\n\n----------------------------------------\n\nTITLE: products.test.tsx (alternative fetch mocking approach)\nDESCRIPTION: Demonstrates mocking fetch requests during tests using `createSchemaFetch` to generate network responses based on a test schema, allowing for realistic integration testing without actual network calls.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/schema-driven-testing.mdx#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\nimport {\n  createSchemaFetch,\n  createTestSchema,\n} from \"@apollo/client/testing/experimental\";\nimport { makeExecutableSchema } from \"@graphql-tools/schema\";\nimport { render as rtlRender, screen } from \"@testing-library/react\";\nimport graphqlSchema from \"../../../schema.graphql\";\n// This should be a function that returns a new ApolloClient instance\n// configured just like your production Apollo Client instance - see the FAQ.\nimport { makeClient } from \"../../client\";\nimport { ApolloProvider, NormalizedCacheObject } from \"@apollo/client\";\nimport { Products } from \"../../products\";\nimport { Suspense } from \"react\";\n\n// First, let's create an executable schema...\nconst staticSchema = makeExecutableSchema({ typeDefs: graphqlSchema });\n\n// which is then passed as the first argument to `createTestSchema`.\nconst schema = createTestSchema(staticSchema, {\n  // Next, let's define mock resolvers\n  resolvers: {\n    Query: {\n      products: () =>\n        Array.from({ length: 5 }, (_element, id) => ({\n          id,\n          mediaUrl: `https://example.com/image${id}.jpg`,\n        })),\n    },\n  },\n  // ...and default scalar values\n  scalars: {\n    Int: () => 6,\n    Float: () => 22.1,\n    String: () => \"default string\",\n  },\n});\n\n// This `render` helper function would typically be extracted and shared between\n// test files.\nconst render = (renderedClient: ApolloClient<NormalizedCacheObject>) =>\n  rtlRender(\n    <ApolloProvider client={renderedClient}>\n      <Suspense fallback=\"Loading...\">\n        <Products />\n      </Suspense>\n    </ApolloProvider>\n  );\n\n// In your test, you can now use createSchemaFetch to mock the global fetch.\n// Example:\ndescribe(\"Products\", () => {\n  it(\"renders\", async () => {\n    using _fetch = createSchemaFetch(schema).mockGlobal();\n\n    render(makeClient());\n\n    await screen.findByText(\"Loading...\");\n\n    // title is rendering the default string scalar\n    const findAllByText = await screen.findAllByText(/default string/);\n    expect(findAllByText).toHaveLength(5);\n\n    // the products resolver is returning 5 products\n    await screen.findByText(/0/);\n    await screen.findByText(/1/);\n    await screen.findByText(/2/);\n    await screen.findByText(/3/);\n    await screen.findByText(/4/);\n  });\n}); \n```\n\n----------------------------------------\n\nTITLE: Configuring refetchWritePolicy in useReadQuery\nDESCRIPTION: Defines the type for refetchWritePolicy which controls how refetched data is written to the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n\"merge\" | \"overwrite\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic GraphQL Fragment\nDESCRIPTION: Declaration of a simple GraphQL fragment called NameParts that can be used with any Person object to retrieve firstName and lastName fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\nfragment NameParts on Person {\n  firstName\n  lastName\n}\n```\n\n----------------------------------------\n\nTITLE: Importing from all-in-one Apollo Client package in TypeScript\nDESCRIPTION: Example of the new consolidated import pattern in Apollo Client 3.0, which allows importing core client, provider, and hooks from a single package.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_52\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ApolloClient, ApolloProvider, useQuery } from \"@apollo/client\";\n```\n\n----------------------------------------\n\nTITLE: Todo Object Structure in Apollo Client Cache\nDESCRIPTION: Illustrates the structure of a Todo object that would be returned from a mutation response and stored in the Apollo Client cache. Shows the __typename and id fields used for normalization.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/mutations.mdx#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"__typename\": \"Todo\",\n  \"id\": \"5\",\n  \"type\": \"groceries\"\n}\n```\n\n----------------------------------------\n\nTITLE: Querying REST Endpoints with Variables in GraphQL (Apollo Client, GraphQL)\nDESCRIPTION: This GraphQL query demonstrates fetching a post's title from a REST endpoint using apollo-link-rest with parameters embedded in the REST path via the @rest directive. It shows how a variable (in this case, the post id as a string literal) is used to interpolate values in the RESTful path. Requires Apollo Client and apollo-link-rest. Input: static post id. Output: post id and title. All fields are results of the REST endpoint mapped to the GraphQL query response.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_23\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery PostTitle {\n  post(id: \"1\") @rest(type: \"Post\", path: \"/post/{args.id}\") {\n    id\n    title\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Cache with Improved Type Inference in TypeScript\nDESCRIPTION: Demonstrates the usage of `cache.modify` with a generic type parameter (`<Book>`) to improve TypeScript type inference. This allows the fields (`title`, `author`) within the modifier callback to have specific types inferred (e.g., `string`, `Reference | Book[\"author\"]`) instead of `any`, enhancing type safety when interacting with the Apollo Client cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\ncache.modify<Book>({\n  id: cache.identify(someBook),\n  fields: {\n    title: (title) => {\n      // title has type `string`.\n      // It used to be `any`.\n    },\n    author: (author) => {\n      // author has type `Reference | Book[\"author\"]`.\n      // It used to be `any`.\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Navigate to Apollo Client Repository (Shell)\nDESCRIPTION: Changes the current directory to the cloned `apollo-client` repository. This is necessary to execute scripts related to the Apollo Client source code and its documentation generation.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd apollo-client\n```\n\n----------------------------------------\n\nTITLE: Updating Apollo Client Cache with 'options.updateQueries' (Deprecated)\nDESCRIPTION: This snippet discusses the use of 'options.updateQueries' to update specific queries in the cache based on mutation results. It demonstrates defining reducer functions keyed by query names, which receive previous data and mutation result to produce updated data, following Redux reducer patterns.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_40\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(\n  gql`\n  mutation SubmitComment ($text: String!) {\n    submitComment(text: $text) { ... }\n  }\n`,\n  {\n    options: {\n      updateQueries: {\n        Comments: (previousData, { mutationResult }) => {\n          const newComment = mutationResult.data.submitComment;\n          return {\n            ...previousData,\n            entry: {\n              ...previousData.entry,\n              comments: [newComment, ...previousData.entry.comments],\n            },\n          };\n        },\n      },\n    },\n  },\n)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Applying Data Masking Codemod with jscodeshift (Shell)\nDESCRIPTION: This command uses `npx` to run the `jscodeshift` code modification tool, targeting TypeScript files to apply the `@unmask` directive with 'migrate' mode using the `unmask.ts` script. Required dependencies include `jscodeshift` and the Apollo Client scripts. Key parameters involve specifying the file extensions, parser, source pattern, and `--mode migrate` option for migration warnings.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_65\n\nLANGUAGE: shell\nCODE:\n```\nnpx jscodeshift -t ../path/to/apollo-client/scripts/codemods/data-masking/unmask.ts --extensions ts --parser ts ./src/**/*.ts --mode migrate\n```\n\n----------------------------------------\n\nTITLE: Running jscodeshift for JS Files\nDESCRIPTION: Executes the jscodeshift command-line tool to apply the `imports.js` codemod script to all `.js` files within a specified source directory. This updates Apollo Client 2.x imports to 3.x. Requires `jscodeshift` to be installed and assumes the command is run from a location where `apollo-client/scripts/codemods/ac2-to-ac3/imports.js` points to the transform script in a checkout of the Apollo Client repository.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/scripts/codemods/ac2-to-ac3/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# To transform all .js files:\nnpx jscodeshift \\\n  -t apollo-client/scripts/codemods/ac2-to-ac3/imports.js \\\n  --extensions js \\\n  source-directory\n```\n\n----------------------------------------\n\nTITLE: Forcing Apollo Client Local Resolver Execution with @client(always: true) in JavaScript/JSX\nDESCRIPTION: Demonstrates configuring an Apollo Client with a local resolver (`isLoggedIn`) and using the `@client(always: true)` directive within a GraphQL query (`IS_LOGGED_IN`) to ensure the resolver runs on every request, bypassing the default cache behavior. This is useful for dynamic values that need constant refreshing, like checking `localStorage` for an auth token. Dependencies include `@apollo/client`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  resolvers: {\n    Query: {\n      isLoggedIn() {\n        return !!localStorage.getItem('token');\n      },\n    },\n  },\n});\n\nconst IS_LOGGED_IN = gql`\n  query IsUserLoggedIn {\n    isLoggedIn @client(always: true)\n  }\n`;\n\n// ... run the query using client.query, a <Query /> component, etc.\n```\n\n----------------------------------------\n\nTITLE: Prefetching Data using Apollo Client `client.query` in JSX\nDESCRIPTION: This React component snippet demonstrates how to prefetch GraphQL data using `client.query` from the Apollo Client instance obtained via `useQuery`. Data fetching is triggered by the `onMouseOver` event on a link (`Link` component), allowing the application to load data for a detail page before the user navigates to it, thus improving perceived loading speed. Requires Apollo Client's React hooks and a routing library providing a `Link` component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/performance.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Feed() {\n  const { loading, error, data, client } = useQuery(GET_DOGS);\n\n  let content;\n  if (loading) {\n    content = <Fetching />;\n  } else if (error) {\n    content = <Error />;\n  } else {\n    content = (\n      <DogList\n        data={data.dogs}\n        renderRow={(type, data) => (\n          <Link\n            to={{\n              pathname: `/${data.breed}/${data.id}`,\n              state: { id: data.id }\n            }}\n            onMouseOver={() =>\n              client.query({\n                query: GET_DOG,\n                variables: { breed: data.breed }\n              })\n            }\n            style={{ textDecoration: \"none\" }}\n          >\n            <Dog {...data} url={data.displayImage} />\n          </Link>\n        )}\n      />\n    );\n  }\n\n  return (\n    <View style={styles.container}>\n      <Header />\n      {content}\n    </View>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useLoadableQuery Hook with Suspense - TypeScript\nDESCRIPTION: Demonstrates the use of the `useLoadableQuery` hook in conjunction with React's `Suspense` API. This hook provides an ergonomic way to load a query during a user interaction. The `loadQuery` function triggers the query, `queryRef` is passed to `useReadQuery` within a Suspense boundary, and optional handlers are returned for refetching, fetching more, or resetting the query.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction App() {\n  const [loadQuery, queryRef, { refetch, fetchMore, reset }] = \n    useLoadableQuery(query, options);\n\n  return (\n    <>\n      <button onClick={() => loadQuery(variables)}>Load query</button>\n      <Suspense fallback={<SuspenseFallback />}>\n        {queryRef && <Child queryRef={queryRef} />}\n      </Suspense>\n    </>\n  );\n}\n\nfunction Child({ queryRef }) {\n  const { data } = useReadQuery(queryRef);\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring urql with Multipart HTTP Subscriptions - TypeScript\nDESCRIPTION: This snippet shows how to set up urql to consume multipart HTTP subscriptions using Apollo Client's adapter. It creates a forwarder function (`multipartSubscriptionForwarder`) using `createFetchMultipartSubscription` from `@apollo/client/utilities/subscriptions/urql` and uses it within urql's `subscriptionExchange` to handle subscriptions. Requires `@apollo/client/utilities/subscriptions/urql` and `@urql/core`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/subscriptions.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createFetchMultipartSubscription } from \"@apollo/client/utilities/subscriptions/urql\";\nimport { Client, fetchExchange, subscriptionExchange } from \"@urql/core\";\n\nconst url = \"https://api.example.com\";\n\nconst multipartSubscriptionForwarder = createFetchMultipartSubscription(\n  url\n);\n\nconst client = new Client({\n  url,\n  exchanges: [\n    fetchExchange,\n    subscriptionExchange({\n      forwardSubscription: multipartSubscriptionForwarder,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Updating TypeScript Constraints for Generic Types in Apollo Client\nDESCRIPTION: Shows how to update function signatures to properly constrain generic types due to TypeScript 4.9.4 changes. This example demonstrates adding an explicit constraint to the TVariables type parameter to satisfy TypeScript's stricter type checking.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_44\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  QueryHookOptions,\n  QueryResult,\n  useQuery,\n+ OperationVariables,\n} from '@apollo/client';\n- export function useWrappedQuery<T, TVariables>(\n+ export function useWrappedQuery<T, TVariables extends OperationVariables>(\n    query: DocumentNode,\n    queryOptions: QueryHookOptions<T, TVariables>\n  ): QueryResult<T, TVariables> {\n    const [execute, result] = useQuery<T, TVariables>(query);\n  }\n```\n\n----------------------------------------\n\nTITLE: Running Specific Tests with Jest - Shell\nDESCRIPTION: Explains how to manually invoke Jest with a custom configuration and test regex to run a targeted test file. Assumes Jest and its configuration file exist in the specified location. The primary input is the path to the desired test file, and the output is the results for only those tests matching the regex.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\njest --config ./config/jest.config.js --testRegex __tests__/useQuery.test.tsx\n```\n\n----------------------------------------\n\nTITLE: Using createQueryPreloader Function for Apollo Client\nDESCRIPTION: This code imports the FunctionDetails component from the shared ApiDoc module and renders documentation for the createQueryPreloader function from @apollo/client, providing detail and context in the API reference. The function is used for preloading GraphQL queries to improve client performance and user experience. The code depends on the shared ApiDoc module and React framework, with version compatibility starting from 3.9.0.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/preloading.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { FunctionDetails } from '../../../shared/ApiDoc';\n\n<FunctionDetails canonicalReference=\"@apollo/client!createQueryPreloader:function(1)\" headingLevel={2} />\n```\n\n----------------------------------------\n\nTITLE: Creating a WebSocketLink Instance in JavaScript\nDESCRIPTION: Example showing how to create a new WebSocketLink by first importing the necessary classes and then instantiating a WebSocketLink with a SubscriptionClient. The connection includes a reconnect option set to true.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-ws.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { WebSocketLink } from \"@apollo/client/link/ws\";\nimport { SubscriptionClient } from \"subscriptions-transport-ws\";\n\nconst link = new WebSocketLink(\n  new SubscriptionClient(\"ws://localhost:4000/graphql\", {\n    reconnect: true\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: useBackgroundQuery Signature (TypeScript)\nDESCRIPTION: Defines the signature of the `useBackgroundQuery` hook in TypeScript. This hook fetches data in the background and provides methods for refetching and fetching more data. It returns a `QueryRef` or `undefined` if skipped, along with fetch and refetch functions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useBackgroundQuery<TData, TVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptions<TData, TVariables> | SkipToken,\n): [\n  // Will return `undefined` here if no query has been executed yet and the query\n  // is currently skipped using `skipToken` or { skip: true }\n  QueryRef<TData> | undefined,\n  {\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n    refetch: RefetchFunction<TData, TVariables>;\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Nested Arrays Configuration\nDESCRIPTION: This code snippet demonstrates how to keep `__typename` on nested fields inside an array within an input type.  It is used in conjunction with the previous `DashboardInput` setup.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { removeTypenameFromVariables, KEEP } from '@apollo/client/link/remove-typename';\n\nconst removeTypenameLink = removeTypenameFromVariables({\n  except: {\n    // Keep __typename on the `config` field for each widget\n    // in the `widgets` array for variables declared as\n    // a `DashboardInput` type\n    DashboardInput: {\n      widgets: {\n        config: KEEP\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Relocating DocumentTransform to Utilities Sub-Package to Avoid Circular Dependencies\nDESCRIPTION: This refactor moves the `DocumentTransform` utility to a separate `utilities` package, breaking a circular dependency between core and cache modules within Apollo Client's architecture, thereby improving module decoupling.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_32\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Configuring graphql-tag-swc-plugin\nDESCRIPTION: This code block shows how to configure the `graphql-tag-swc-plugin` within a `.swcrc` file.  It configures the plugin, specifying the import sources and identifiers to be precompiled.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  jsc: {\n    experimental: {\n      plugins: [\n        [\"graphql-tag-swc-plugin\",\n          {\n            importSources: [\"@apollo/client\", \"graphql-tag\"],\n            gqlTagIdentifiers: [\"gql\"]\n          },\n        ],\n      ],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using the deprecated skip option in useReadQuery\nDESCRIPTION: Defines the boolean type for the deprecated skip option that controls whether the query executes.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nboolean\n```\n\n----------------------------------------\n\nTITLE: Importing React Testing Utilities in Apollo Client 3.0\nDESCRIPTION: Demonstrates how to import testing utilities, like the `MockedProvider`, from the `@apollo/client/testing` entry point. This replaces imports from the deprecated `@apollo/react-testing` package.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { MockedProvider } from '@apollo/client/testing';\n```\n\n----------------------------------------\n\nTITLE: Starting Fullstack Tutorial Client Shell\nDESCRIPTION: Navigates to the client directory within the final project of the fullstack tutorial in a separate terminal window and starts the client application using npm start. This launches the web application that will consume the linked Apollo Client.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\n# ... in a separate terminal window\ncd [fullstack-tutorial-root]/final/client\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Extending GraphQL Schema with Client-Side Field in Apollo Client\nDESCRIPTION: A GraphQL schema definition that adds a description field to the Rocket type, which isn't yet supported by the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype Rocket {\n  id: ID!\n  name: String\n  type: String\n  description: String # field not yet supported\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Registered Fragment in a Component Query\nDESCRIPTION: Referencing a registered fragment by name in a component's query without needing to import or interpolate the fragment definition.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst listQuery = gql`\n  query GetItemList {\n    list {\n      ...ItemFragment\n    }\n  }\n`;\nfunction ToDoList() {\n  const { data } = useQuery(listQuery);\n  return (\n    <ol>\n      {data?.list.map(item => (\n        <Item key={item.id} text={item.text} />\n      ))}\n    </ol>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Error Policy in Apollo Client\nDESCRIPTION: This code shows how to configure `errorPolicy` in Apollo Client using the `graphql` function.  The error policy dictates how the component handles errors from GraphQL. Valid values are `none` (default), `ignore`, and `all`. Setting the error policy to `all` means the component will be notified of any GraphQL errors. Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent, and a GraphQL query definition with `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_29\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  options: { errorPolicy: 'all' },\n})(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Updating State with React Transitions - TypeScript\nDESCRIPTION: This code shows how to use React's `startTransition` to update state without triggering the Suspense fallback.  When a new dog is selected, the previous dog's information remains displayed until the new dog's data is loaded. This provides a smoother user experience. Dependencies: `@apollo/client`, `react`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/suspense.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState, Suspense, startTransition } from \"react\";\n\nfunction App() {\n  const { data } = useSuspenseQuery(GET_DOGS_QUERY);\n  const [selectedDog, setSelectedDog] = useState(\n    data.dogs[0].id\n  );\n\n  return (\n    <>\n      <select\n        onChange={(e) => {\n          startTransition(() => {\n            setSelectedDog(e.target.value);\n          });\n        }}\n      >\n        {data.dogs.map(({ id, name }) => (\n          <option key={id} value={id}>{name}</option>\n        ))}\n      </select>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Dog id={selectedDog} />\n      </Suspense>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Cart Component with useQuery (React, JSX)\nDESCRIPTION: This React component `Cart` uses the `useQuery` hook to fetch the `GET_CART_ITEMS` query.  It displays a loading state, error state, or the cart items based on the query result. When `cartItemsVar` changes, this component rerenders and fetches updated data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nexport const GET_CART_ITEMS = gql`\n  query GetCartItems {\n    cartItems @client\n  }\n`;\n\nexport function Cart() {\n  const { data, loading, error } = useQuery(GET_CART_ITEMS);\n\n  if (loading) return <Loading />;\n  if (error) return <p>ERROR: {error.message}</p>;\n\n  return (\n    <div class=\"cart\">\n      <Header>My Cart</Header>\n      {data && data.cartItems.length === 0 ? (\n        <p>No items in your cart</p>\n      ) : (\n        <Fragment>\n          {data && data.cartItems.map(productId => (\n            <CartItem key={productId} />\n          ))}\n        </Fragment>\n      )}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript interface definition for QueryRef and helper functions in useBackgroundQuery\nDESCRIPTION: This snippet shows the TypeScript type definitions for the return values of useBackgroundQuery, including the queryRef and helper functions like refetch and fetchMore.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-result.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UseBackgroundQueryResult<TData, TVariables> {\n  queryRef: QueryRef<TData>;\n  refetch: (variables?: Partial<TVariables>) => Promise<ApolloQueryResult>;\n  fetchMore: ({ query?: DocumentNode, variables?: TVariables, updateQuery: Function}) => Promise<ApolloQueryResult>;\n}\n```\n\n----------------------------------------\n\nTITLE: Linking React/ReactDOM Modules Shell\nDESCRIPTION: Navigates back up one directory from @apollo, removes the application's installed react and react-dom modules, and creates symbolic links to the versions used by the local Apollo Client checkout. This prevents potential \"duplicate React\" errors when the application and the linked library have different React versions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n# ... assuming still in [fullstack-tutorial-root]/final/client/node_modules/@apollo from step 3\ncd ..\nrm -Rf ./react ./react-dom\nln -s [apollo-client-root]/node_modules/react\nln -s [apollo-client-root]/node_modules/react-dom\n```\n\n----------------------------------------\n\nTITLE: Importing 'graphql' Package in Apollo Client 3.3.0 Improvements - TypeScript\nDESCRIPTION: Illustrates the change in importing modules from the 'graphql' package in Apollo Client 3.3.0. Previously, nested imports like 'graphql/language/visitor' were used. Now, imports are done from the top-level 'graphql' package.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_48\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { visit } from \"graphql/language/visitor\";\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { visit } from \"graphql\";\n```\n\n----------------------------------------\n\nTITLE: Configuring RestLink for Multiple Endpoints\nDESCRIPTION: Demonstrates how to configure `RestLink` to work with multiple named REST API endpoints using the `endpoints` option in the constructor.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst link = new RestLink({ endpoints: { v1: 'api.com/v1', v2: 'api.com/v2' } });\n```\n\n----------------------------------------\n\nTITLE: Building Apollo Client via npm - Shell\nDESCRIPTION: Demonstrates how to perform a single build of the Apollo Client project using npm. Requires npm to be installed and run within the root directory of the repository. Success results in a compiled version of the client, ready for testing or further development.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Conditional Query Refetching Based on Result Metadata with Apollo Client in TypeScript\nDESCRIPTION: This code provides advanced filtering in onQueryUpdated by examining result metadata (complete, missing, etc). It allows for custom conditional refetching: returning false skips, returning a Promise initiates a custom fetch, and returning true forces network refetch. Inputs: observableQuery, Cache.DiffResult. Output: selectively refetched queries based on custom logic.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  updateCache(cache) {\n    cache.evict({ fieldName: \"someRootField\" });\n  },\n\n  onQueryUpdated(observableQuery, { complete, result, missing }) {\n    if (shouldIgnoreQuery(observableQuery)) {\n      return false;\n    }\n\n    if (complete) {\n      // Update the query according to its chosen FetchPolicy, rather than\n      // refetching it unconditionally from the network.\n      return observableQuery.reobserve();\n    }\n\n    // Refetch the query unconditionally from the network.\n    return true;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with useQuery React\nDESCRIPTION: Demonstrates using the `useQuery` hook in React to fetch data from a GraphQL server. This hook simplifies the data fetching process by handling loading, error states, and UI updates.  It requires the `@apollo/client` library to be installed and a configured ApolloClient instance.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/why-apollo.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nfunction ShowDogs() {\n  const { loading, error, data } = useQuery(GET_DOGS);\n  if (error) return <Error />;\n  if (loading) return <Fetching />;\n\n  return <DogList dogs={data.dogs} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Live Binding for Each Item with useFragment (JavaScript)\nDESCRIPTION: The `Item` component uses the `useFragment` hook to create a live binding for data from the `ItemFragment`. It receives an `id` property and uses it to specify which item's fragment data to fetch and display. It displays the item's text or an \"incomplete\" message based on the fragment data's status. Dependencies are React, Apollo Client, and an `ItemFragment` definition.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_24\n\nLANGUAGE: jsx\nCODE:\n```\nfunction Item(props) {\n  const { complete, data } = useFragment({\n    fragment: ITEM_FRAGMENT,\n    fragmentName: \"ItemFragment\",\n    from: {\n      __typename: \"Item\",\n      id: props.id\n    }\n  });\n\n  return <li>{complete ? data.text : \"incomplete\"}</li>;\n}\n```\n\n----------------------------------------\n\nTITLE: Typing React Class Components with graphql HOC in TypeScript\nDESCRIPTION: Demonstrates how to type React class components wrapped with graphql HOC, including typing incoming props with ChildProps to get typed data and variables. Shows destructuring of data properties with conditional UI based on loading and error states before rendering the actual content.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_14\n\nLANGUAGE: TSX\nCODE:\n```\nimport { ChildProps } from \"@apollo/react-hoc\";\n\nconst withCharacter = graphql<GetCharacterQueryVariables, GetCharacterQuery>(HERO_QUERY, {\n  options: ({ episode }) => ({\n    variables: { episode }\n  })\n});\n\nclass Character extends React.Component<ChildProps<GetCharacterQueryVariables, GetCharacterQuery>, {}> {\n  render(){\n    const { loading, hero, error } = this.props.data;\n    if (loading) return <div>Loading</div>;\n    if (error) return <h1>ERROR</h1>;\n    return ...// actual component with data;\n  }\n}\n\nexport default withCharacter(Character);\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client 3.0 using npm\nDESCRIPTION: Command to install the core Apollo Client 3.0 package using npm. This single package replaces older packages like `apollo-client`, `react-apollo`, `apollo-boost`, and various `@apollo/react-*` packages.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client\n```\n\n----------------------------------------\n\nTITLE: Configuring Metro Bundler for Apollo Client\nDESCRIPTION: This snippet configures the Metro bundler in a React Native project to understand the `.cjs` file extension, which is used by Apollo Client's CommonJS bundles. This configuration ensures that Metro correctly interprets these modules. This snippet is no longer necessary as of Apollo Client v3.6.4.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_45\n\nLANGUAGE: JavaScript\nCODE:\n```\n// NOTE: No longer necessary in @apollo/client@3.6.4!\nconst { getDefaultConfig } = require(\"metro-config\");\nconst { resolver: defaultResolver } = getDefaultConfig.getDefaultValues();\nexports.resolver = {\n  ...defaultResolver,\n  sourceExts: [...defaultResolver.sourceExts, \"cjs\"],\n};\n```\n\n----------------------------------------\n\nTITLE: Overriding Root Operation Types in InMemoryCache\nDESCRIPTION: Example showing how to override the default root operation type names in Apollo Client. The example defines an unconventional root query type and demonstrates how to read queries with fragments against this custom root type.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-configuration.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst cache = new InMemoryCache({\n  typePolicies: {\n    UnconventionalRootQuery: {\n      // The RootQueryFragment can only match if the cache knows the __typename\n      // of the root query object.\n      queryType: true,\n    },\n  },\n});\n\nconst result = cache.readQuery({\n  query: gql`\n    query MyQuery {\n      ...RootQueryFragment\n    }\n    fragment RootQueryFragment on UnconventionalRootQuery {\n      field1\n      field2 {\n        subfield\n      }\n    }\n  `,\n});\n\nconst equivalentResult = cache.readQuery({\n  query: gql`\n    query MyQuery {\n      field1\n      field2 {\n        subfield\n      }\n    }\n  `,\n});\n```\n\n----------------------------------------\n\nTITLE: Setting client instance for useReadQuery\nDESCRIPTION: Specifies the type for the client option which determines which ApolloClient instance to use.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nApolloClient\n```\n\n----------------------------------------\n\nTITLE: useLazyQuery Hook Return Signature - TypeScript\nDESCRIPTION: This TypeScript snippet describes the tuple returned by the useLazyQuery React hook in Apollo Client. The first item is an execute function to manually trigger a paused GraphQL query (accepts LazyQueryHookOptions and returns a promise resolving to LazyQueryResult). The second is a QueryResult object reflecting the current state of the query. Requires @apollo/client and TypeScript types. Input for the execute function is optional query options; output is a promise of query result. Limitations include dependence on proper hook usage within a React component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n[execute: LazyQueryExecFunction<TData, TVariables>, result: QueryResult<TData, TVariables>]\n```\n\n----------------------------------------\n\nTITLE: Running jscodeshift for TSX Files\nDESCRIPTION: Executes the jscodeshift command-line tool to apply the `imports.js` codemod script to all `.tsx` files within a specified source directory, using the TSX parser (`--parser tsx`). This updates Apollo Client 2.x imports to 3.x. Requires `jscodeshift` to be installed and assumes the command is run from a location where `apollo-client/scripts/codemods/ac2-to-ac3/imports.js` points to the transform script in a checkout of the Apollo Client repository.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/scripts/codemods/ac2-to-ac3/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n# To transform all .tsx files:\nnpx jscodeshift \\\n  -t apollo-client/scripts/codemods/ac2-to-ac3/imports.js \\\n  --extensions tsx --parser tsx \\\n  source-directory\n```\n\n----------------------------------------\n\nTITLE: Testing and Printing Modified GraphQL Documents Using print in TypeScript\nDESCRIPTION: Shows how to use the 'print' function from graphql-js to render a transformed GraphQL document as a string, after applying a DocumentTransform. The sample demonstrates transforming a query and outputting its formatted string to the console. Dependencies are '@apollo/client' and 'graphql'; input is a GraphQL query AST; expected output is the transformed readable query string.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { print } from 'graphql';\n\nconst query = gql`\n  query TestQuery {\n    currentUser {\n      name\n    }\n  }\n`;\n\nconst documentTransform = new DocumentTransform((document) => {\n  // ...\n});\n\nconst modifiedQuery = documentTransform.transformDocument(query);\n\nconsole.log(print(modifiedQuery));\n// query TestQuery {\n//   currentUser {\n//     name\n//     id\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Running jscodeshift for TS Files\nDESCRIPTION: Executes the jscodeshift command-line tool to apply the `imports.js` codemod script to all `.ts` files within a specified source directory, using the TypeScript parser (`--parser ts`). This updates Apollo Client 2.x imports to 3.x. Requires `jscodeshift` to be installed and assumes the command is run from a location where `apollo-client/scripts/codemods/ac2-to-ac3/imports.js` points to the transform script in a checkout of the Apollo Client repository.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/scripts/codemods/ac2-to-ac3/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# To transform all .ts files:\nnpx jscodeshift \\\n  -t apollo-client/scripts/codemods/ac2-to-ac3/imports.js \\\n  --extensions ts --parser ts \\\n  source-directory\n```\n\n----------------------------------------\n\nTITLE: Directional Composition with split - JavaScript\nDESCRIPTION: This snippet demonstrates how to use the `split` function or method to execute different `Link`s based on the result of a boolean check. It imports necessary modules from `@apollo/client` and `@apollo/client/link/retry` and creates a `RetryLink` that splits execution to different `HttpLink`s based on the context's `version` property.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink, HttpLink } from '@apollo/client';\nimport { RetryLink } from '@apollo/client/link/retry';\n\nconst directionalLink = new RetryLink().split(\n  (operation) => operation.getContext().version === 1,\n  new HttpLink({ uri: 'http://localhost:4000/v1/graphql' }),\n  new HttpLink({ uri: 'http://localhost:4000/v2/graphql' })\n);\n\n```\n\n----------------------------------------\n\nTITLE: Including networkStatus in useSuspenseQuery Results\nDESCRIPTION: This change ensures that the `networkStatus` field is returned in the result object of `useSuspenseQuery`, providing developers with additional insight into the query's network state alongside data and loading status.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_31\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Specifying canonizeResults option type\nDESCRIPTION: Defines the type for canonizeResults option which determines if objects read from cache will be canonized.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nBoolean\n```\n\n----------------------------------------\n\nTITLE: Expected JSON Response Structure for Single Record\nDESCRIPTION: Example JSON structure that Apollo Client expects by default when fetching a single record via REST Link. The data object should be at the root level.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": 1,\n  \"name\": \"Apollo\"\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining multiple DocumentTransforms with concat() for complex transformations\nDESCRIPTION: This snippet shows how to combine multiple DocumentTransform instances into a single transform chain using the concat() method. Each transform can have its own caching configuration. It exemplifies building a complex transformation pipeline and highlights the importance of order, especially placing non-cached transforms at the end to prevent memory leaks due to referential mismatches.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst documentTransform1 = new DocumentTransform(transform1);\nconst documentTransform2 = new DocumentTransform(transform2);\nconst documentTransform3 = new DocumentTransform(transform3);\n\nconst documentTransform = documentTransform1\n  .concat(documentTransform2)\n  .concat(documentTransform3);\n```\n\n----------------------------------------\n\nTITLE: Transforming GraphQL Documents with the visit Function in TypeScript\nDESCRIPTION: Demonstrates using the graphql-js library's 'visit' function to traverse and potentially modify a GraphQL AST within a DocumentTransform. The visitor object can be expanded to process different node types as needed. Dependencies are '@apollo/client' and 'graphql', and the input is a GraphQL document AST.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { DocumentTransform } from '@apollo/client';\nimport { visit } from 'graphql';\n\nconst documentTransform = new DocumentTransform((document) => {\n  const transformedDocument = visit(document, {\n    // visitor\n  });\n\n  return transformedDocument;\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Live Binding with useFragment using item prop (TypeScript)\nDESCRIPTION: The `Item` component utilizes the `useFragment` hook, leveraging the item object as the `from` option. It passes the entire item object via props, accessing `item.id` and `item.__typename` to fetch data via a fragment. It shows the item text or \"incomplete\" based on data availability. Depends on React, Apollo Client, and a preceding `ItemFragment`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Item(props: { item: { __typename: 'Item', id: number }}) {\n  const { complete, data } = useFragment({\n    fragment: ItemFragment,\n    fragmentName: \"ItemFragment\",\n    from: props.item\n  });\n\n  return <li>{complete ? data.text : \"incomplete\"}</li>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Apollo Client with Error Handling in JavaScript\nDESCRIPTION: Creates an Apollo Client instance with error handling capability and HTTP connectivity to a GraphQL server. It includes an error link that logs GraphQL and network errors to the console, and an HTTP link that specifies the GraphQL endpoint. The client is configured with a link chain and an in-memory cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/link-chain.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, from } from \"@apollo/client\";\nimport { onError } from \"@apollo/client/link/error\";\n\nconst httpLink = new HttpLink({\n  uri: \"http://localhost:4000/graphql\"\n});\n\nconst errorLink = onError(({ graphQLErrors, networkError }) => {\n  if (graphQLErrors)\n    graphQLErrors.forEach(({ message, locations, path }) =>\n      console.log(\n        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`,\n      ),\n    );\n\n  if (networkError) console.log(`[Network error]: ${networkError}`);\n});\n\n// If you provide a link chain to ApolloClient, you\n// don't provide the `uri` option.\nconst client = new ApolloClient({\n  // The `from` function combines an array of individual links\n  // into a link chain\n  link: from([errorLink, httpLink]),\n  cache: new InMemoryCache()\n});\n```\n\n----------------------------------------\n\nTITLE: Rehydrating Apollo Client Cache on the Client Side\nDESCRIPTION: Client-side initialization of Apollo Client with cache rehydration from the server-rendered state. This enables the client to have immediate access to data without additional network requests.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst client = new ApolloClient({\n  cache: new InMemoryCache().restore(window.__APOLLO_STATE__),\n  uri: 'https://example.com/graphql'\n});\n```\n\n----------------------------------------\n\nTITLE: Using Apollo Client React SSR functions\nDESCRIPTION: This code snippet imports server-side rendering utilities such as getDataFromTree from the Apollo Client React SSR module to facilitate server-side rendering of Apollo-powered React components.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/hooks-migration.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { getDataFromTree } from \"@apollo/client/react/ssr\";\n```\n\n----------------------------------------\n\nTITLE: Reading from Apollo Client cache using readQuery with TypeScript signature\nDESCRIPTION: TypeScript signature for the readQuery method allowing generic query and variable types. Accepts a query and optional optimistic flag to return optimistic results. Returns the result matching the QueryType or null if no data is found. This method reads data directly from the cache following the GraphQL query structure provided.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nreadQuery<QueryType, TVariables = any>(\n  options: DataProxy.Query<TVariables>,\n  optimistic: boolean = false,\n): QueryType | null\n```\n\n----------------------------------------\n\nTITLE: Defining Fragment and Component (Modified)\nDESCRIPTION: Shows a modified version of the `PostDetailsFragment` and `PostDetails` component where the `publishedAt` field has been removed from both the fragment and the component's rendering logic. This serves as an example to illustrate how removing a field from a fragment can break a parent component that implicitly relied on it, demonstrating the problem data masking addresses.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_32\n\nLANGUAGE: jsx\nCODE:\n```\nexport const POST_DETAILS_FRAGMENT = gql`\n  fragment PostDetailsFragment on Post {\n    title\n    shortDescription\n  }\n`;\n\nexport default function PostDetails({ post }) {\n  return (\n    <section>\n      <h1>{post.title}</h1>\n      <p>{post.shortDescription}</p>\n    </section>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring graphql() with an options object\nDESCRIPTION: This snippet illustrates how to pass an optional configuration object as the second argument to graphql(), allowing customization of the behavior of the generated HOC, such as specifying options based on component props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(\n  gql`query MyQuery { ... }`,\n  config, // <- The `config` object.\n)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Import Apollo Client components\nDESCRIPTION: Imports necessary components from the `@apollo/client` library.  These include `ApolloClient` for creating the client instance, `InMemoryCache` for caching query results, `ApolloProvider` for connecting the client to React, and `gql` for parsing GraphQL queries.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/get-started.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { ApolloClient, InMemoryCache, ApolloProvider, gql } from '@apollo/client';\n```\n\n----------------------------------------\n\nTITLE: Rendering React Component with Empty MockedProvider in JSX\nDESCRIPTION: This snippet shows a basic rendering test for the Dog component using the MockedProvider from @apollo/client/testing with an empty mocks array. It verifies that the loading state renders without error. The test uses React Testing Library's render and screen utilities along with Jest DOM matchers.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/testing.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport \"@testing-library/jest-dom\";\nimport { render, screen } from \"@testing-library/react\";\nimport { MockedProvider } from \"@apollo/client/testing\";\nimport { GET_DOG_QUERY, Dog } from \"./dog\";\n\nconst mocks = []; // We'll fill this in next\n\nit(\"renders without error\", async () => {\n  render(\n    <MockedProvider mocks={mocks}>\n      <Dog name=\"Buck\" />\n    </MockedProvider>\n  );\n  expect(await screen.findByText(\"Loading...\")).toBeInTheDocument();\n});\n```\n\n----------------------------------------\n\nTITLE: Resetting Result Cache during Garbage Collection (Apollo Client JavaScript)\nDESCRIPTION: Calls the gc method with the resetResultCache option set to true, instructing InMemoryCache to release memory used for preserving previous cache results in addition to normal garbage collection. This may slow down subsequent cache reads temporarily but helps profile memory usage or troubleshoot leaks. No extra dependencies are required.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache.gc({ resetResultCache: true })\n```\n\n----------------------------------------\n\nTITLE: Implementing DogPhoto Component and useQuery\nDESCRIPTION: The `DogPhoto` component fetches dog photos based on a passed `breed` prop using the `useQuery` hook. It passes the `breed` prop as a variable to the `GET_DOG_PHOTO` query. The component renders a loading message, error messages, or the dog photo image according to the query's state. The styling of the image is inline.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/queries.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nfunction DogPhoto({ breed }) {\n  const { loading, error, data } = useQuery(GET_DOG_PHOTO, {\n    variables: { breed },\n  });\n\n  if (loading) return null;\n  if (error) return `Error! ${error}`;\n\n  return (\n    <img src={data.dog.displayImage} style={{ height: 100, width: 100 }} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Schema for Offset-Based Pagination in GraphQL\nDESCRIPTION: This GraphQL schema snippet defines a query field `feed` that supports offset-based pagination by accepting `offset` and `limit` integer arguments. The `feed` field returns a list of non-nullable `FeedItem` objects, each with an `id` and a `message`. This schema is the starting point for implementing offset-based pagination on the server by specifying where to start in the list and how many items to return.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/offset-based.mdx#_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\ntype Query {\n  feed(offset: Int, limit: Int): [FeedItem!]\n}\n\ntype FeedItem {\n  id: ID!\n  message: String!\n}\n```\n\n----------------------------------------\n\nTITLE: Including a Fragment in a Query from Another File\nDESCRIPTION: Importing and using a fragment defined in another file within a GraphQL query by interpolating it into the query string.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { gql } from '@apollo/client';\nimport { COMMENT_FRAGMENT } from './Comment';\n\nconst GET_POST_DETAILS = gql`\n  query GetPostDetails($postId: ID!) {\n    post(postId: $postId) {\n      title\n      body\n      author\n      comments {\n        ...CommentFragment\n      }\n    }\n  }\n\n  ${COMMENT_FRAGMENT}\n`;\n\n// ...PostDetails component definition...\n```\n\n----------------------------------------\n\nTITLE: Visualizing Server-side Rendering Flow with Mermaid\nDESCRIPTION: A sequence diagram showing the flow of server-side rendering between browser and server. It illustrates how the server renders the initial state before sending HTML and CSS to the browser, which then displays it and rehydrates the view layer.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Browser;\n    participant Server;\n\n    Browser->>Server: Requests example.com;\n    Note over Server: Renders initial state of example.com on server;\n    Server->>Browser: Returns raw HTML and CSS;\n    Note over Browser: Displays raw HTML and CSS;\n    Note over Browser: Initializes view layer and \"rehydrates\" it with returned data\n```\n\n----------------------------------------\n\nTITLE: Compose GraphQL HOCs with Alias\nDESCRIPTION: This snippet demonstrates how to use the `compose` function from `recompose` to combine multiple `graphql()` HOCs.  It sets the `alias` option to customize the display name of the higher-order component wrappers for better identification in React Devtools. It requires the `recompose` library and `graphql` from `react-apollo`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nexport default compose(\n  graphql(gql`query MyQuery { ... }`, { alias: 'withCurrentUser' }),\n  graphql(gql`query MyQuery { ... }`, { alias: 'withList' }),\n)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Updating Apollo Client Cache Using 'options.update' Function\nDESCRIPTION: This snippet demonstrates how to update the Apollo Client cache after a mutation using the 'update' function within the options object. It reads query data with 'readQuery', modifies the data, and writes it back with 'writeQuery' to update the cache reactively.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_37\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst query = gql`query GetAllTodos { todos { ... } }`;\n\nexport default graphql(\n  gql`\n  mutation CreateTodo ($text: String!) {\n    createTodo(text: $text) { ... }\n  }\n`,\n  {\n    options: {\n      update: (proxy, { data: { createTodo } }) => {\n        const data = proxy.readQuery({ query });\n        data.todos.push(createTodo);\n        proxy.writeQuery({ query, data });\n      },\n    },\n  },\n)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Defining GraphQL Query with @connection directive\nDESCRIPTION: This code snippet demonstrates the use of the `@connection` directive within a GraphQL query. The directive is applied to the `feed` field to create a custom cache key, ensuring that paginated results are handled correctly. It also uses the `filter` parameter to include the `type` query argument in the cache key.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst query = gql`\n  query Feed($type: FeedType!, $offset: Int, $limit: Int) {\n    feed(type: $type, offset: $offset, limit: $limit) @connection(key: \"feed\", filter: [\"type\"]) {\n      ...FeedEntry\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Incorrect skip usage with type assertion - TypeScript\nDESCRIPTION: Illustrates an incorrect way to use the `skip` option with `useSuspenseQuery` and a type assertion, which is not recommended.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useSuspenseQuery(query, {\n  variables: { id: id! },\n  skip: !id\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Data Masking in Apollo Client\nDESCRIPTION: This code snippet demonstrates how to enable data masking in Apollo Client by setting the `dataMasking` option to `true` in the `ApolloClient` constructor.  Data masking helps improve performance by only re-rendering components when the requested fields are updated. It also explains how to use the `@unmask` directive to selectively disable data masking for specific fragments.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew ApolloClient({\n  dataMasking: true,\n  // ... other options\n});\n```\n\n----------------------------------------\n\nTITLE: Add Product to Cart Button Component (React, JSX)\nDESCRIPTION: This React component `AddToCartButton` updates the `cartItemsVar` reactive variable when clicked. It appends the associated `productId` to the existing cart items array, triggering updates to any active queries that include the `cartItems` field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { cartItemsVar } from './cache';\n// ... other imports\n\nexport function AddToCartButton({ productId }) {\n  return (\n    <div class=\"add-to-cart-button\">\n      <Button onClick={() => cartItemsVar([...cartItemsVar(), productId])}>\n        Add to Cart\n      </Button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Apollo Persisted Query Manifest (json)\nDESCRIPTION: Shows the structure of the persisted-query-manifest.json file, containing metadata, version, and an operations array including IDs, operation bodies, unique names, and operation types. This manifest is consumed by both server and client to validate and map persisted queries.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"format\": \"apollo-persisted-query-manifest\",\n  \"version\": 1,\n  \"operations\": [\n    {\n      \"id\": \"e0321f6b438bb42c022f633d38c19549dea9a2d55c908f64c5c6cb8403442fef\",\n      \"body\": \"query GetItem { thing { __typename } }\",\n      \"name\": \"GetItem\",\n      \"type\": \"query\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Example Masked Query Output (Without PublishedAt)\nDESCRIPTION: Illustrates the structure of the `data` object returned by the `useQuery` hook for the `GetPosts` query when data masking is enabled and the `publishedAt` field is *not* explicitly included in the main query fields. Only fields explicitly requested (`id` in this case) are visible, while fragment fields (`title`, `shortDescription`, `publishedAt`) are hidden from the parent component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_35\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"posts\": [\n    {\n      \"__typename\": \"Post\",\n      \"id\": \"1\"\n    },\n    {\n      \"__typename\": \"Post\",\n      \"id\": \"2\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Type Policy Inheritance for Fuzzy Possible Types\nDESCRIPTION: This update addresses issues with type policy inheritance involving `possibleTypes`, ensuring consistent and correct type resolution in Apollo Client's cache policies.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_36\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Refetching All Queries (Including Inactive) Using Apollo Client in TypeScript\nDESCRIPTION: This code refetches all queries tracked by Apollo Client, including those that are inactive or have no observers. The include option is set to 'all'. This approach may incur significant network usage and is generally less common than targeting only active queries. Requires an ApolloClient instance. Input: none. Output: Promise with refetch results.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  include: \"all\", // Consider using \"active\" instead!\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with @unmask Directive in GraphQL\nDESCRIPTION: This snippet demonstrates how to apply the `@unmask` directive to a GraphQL fragment spread within a query. The directive enables 'migrate' mode, which provides development-only warnings when accessing masked fields, assisting incremental adoption of data masking. Input variables include `id` and the output includes the full set of fields from the `PostDetails` fragment, bypassing field masking during the migration.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_62\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery GetPost($id) {\n  post(id: $id) {\n    id\n    ...PostDetails @unmask(mode: \"migrate\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating ObservableQuery with Type-Safe Previous Data in TypeScript\nDESCRIPTION: Demonstrates how to use the updated `updateQuery` callback in ObservableQuery with type-safe `previousData` and `complete` parameters. It shows how to correctly check if the previous data is complete or partial to avoid runtime crashes. This snippet depends on Apollo Client's ObservableQuery interface and TypeScript typings.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nobservableQuery.updateQuery(\n  (unsafePreviousData, { previousData, complete }) => {\n    previousData;\n    // ^? TData | DeepPartial<TData> | undefined\n\n    if (complete) {\n      previousData;\n      // ^? TData\n    } else {\n      previousData;\n      // ^? DeepPartial<TData> | undefined\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Typing Render Prop Components with Generated GraphQL Query Types\nDESCRIPTION: Shows how to type a render prop component like `<Query />` by providing GraphQL query types for data and variables, ensuring type safety within the render function.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { gql, AllPeopleQuery, AllPeopleQueryVariables } from '../src/__generated__/gql';\n\nconst ALL_PEOPLE_QUERY = gql(/* GraphQL */ `\n  query All_People {\n    allPeople {\n      people {\n        id\n        name\n      }\n    }\n  }\n`);\n\n// Usage in a React component with typed render prop\nconst AllPeopleComponent = <Query<AllPeopleQuery, AllPeopleQueryVariables> query={ALL_PEOPLE_QUERY}>\n  {({ loading, error, data }) => { /* render logic */ }}\n</Query>;\n```\n\n----------------------------------------\n\nTITLE: Non-Standard JSON Response Structure Example\nDESCRIPTION: An example of a JSON response structure where the data array is nested within a `data` key, differing from the default structure expected by Apollo Client. This necessitates using a `responseTransformer`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"meta\": {},\n  \"data\": [\n    {\n      \"id\": 1,\n      \"name\": \"Apollo\"\n    },\n    {\n      \"id\": 2,\n      \"name\": \"Starman\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Async Local Resolver\nDESCRIPTION: Sets up Apollo Client with a resolver ('cameraRoll') that is asynchronous. This example demonstrates how to fetch data from a promise-based local API (like React Native's CameraRoll) within a local resolver and structure the result.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\nimport { CameraRoll } from 'react-native';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  resolvers: {\n    Query: {\n      async cameraRoll(_, { assetType }) {\n        try {\n          const media = await CameraRoll.getPhotos({\n            first: 20,\n            assetType,\n          });\n\n          return {\n            ...media,\n            id: assetType,\n            __typename: 'CameraRoll',\n          };\n        } catch (e) {\n          console.error(e);\n          return null;\n        }\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Combining multiple graphql() HOCs with compose and skip options\nDESCRIPTION: Shows how to use the compose function to layer multiple graphql() enhancers on a component, each with their own skip condition, allowing dynamic selection of data sources based on props.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default compose(\n  graphql(gql`query MyQuery1 { ... }`, { skip: props => !props.useQuery1 }),\n  graphql(gql`query MyQuery2 { ... }`, { skip: props => props.useQuery1 }),\n)(MyComponent);\n\nfunction MyComponent({ data }) {\n  // The data may be from `MyQuery1` or `MyQuery2` depending on the value\n  // of the prop `useQuery1`.\n  console.log(data);\n}\n```\n\n----------------------------------------\n\nTITLE: Linking Apollo Client Distribution Shell\nDESCRIPTION: Navigates into the application's @apollo node modules directory, removes the installed @apollo/client package, and creates a symbolic link (ln -s) pointing to the compiled dist directory of the local Apollo Client checkout. This directs the application to use the locally built version.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n# ... assuming still in [fullstack-tutorial-root]/final/client from step 2\ncd node_modules/@apollo\nrm -Rf ./client\nln -s [apollo-client-root]/dist client\n```\n\n----------------------------------------\n\nTITLE: Using `mutate` Function in Apollo Client Mutations\nDESCRIPTION: This code demonstrates the use of the `mutate` function provided by the `graphql` higher-order component when handling mutations. The `mutate` function executes the mutation using the network interface and also updates the cache according to defined configurations. It also accepts the same options as `config.options`. Dependencies: Apollo Client, `graphql` function, `gql`, and a component that uses it.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_33\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction MyComponent({ mutate }) {\n  return (\n    <button\n      onClick={() => {\n        mutate({\n          variables: { foo: 42 },\n        });\n      }}\n    >\n      Mutate\n    </button>\n  );\n}\n\nexport default graphql(gql`mutation MyMutation { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Modifying Cache Fields using cache.modify in TypeScript\nDESCRIPTION: Demonstrates how to use the `cache.modify` method to update a specific field within a cached entity. It requires an entity `id` and an object defining field update functions. The function receives the old value and a context object with helpers like `readField`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_50\n\nLANGUAGE: TypeScript\nCODE:\n```\ncache.modify({\n  id: cache.identify(post),\n  fields: {\n    comments(comments: Reference[], { readField }) {\n      return comments.filter(\n        (comment) => idToRemove !== readField(\"id\", comment)\n      );\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Evicting Objects or Fields from Cache in JavaScript\nDESCRIPTION: Example of using the evict method to remove either a complete normalized object or a specific field from a cached object.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\ncache.evict({ id: 'my-object-id', fieldName: 'myFieldName' });\n```\n\n----------------------------------------\n\nTITLE: setupTests.ts\nDESCRIPTION: Configures global test setup and teardown hooks for managing the MSW server lifecycle in Jest testing environment, including starting, stopping, and resetting mock handlers.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/schema-driven-testing.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport \"@testing-library/jest-dom\";\nimport { gql } from \"@apollo/client\";\n\ngql.disableFragmentWarnings();\n\nbeforeAll(() => server.listen({ onUnhandledRequest: \"error\" }));\nafterAll(() => server.close());\nafterEach(() => server.resetHandlers());\n```\n\n----------------------------------------\n\nTITLE: Evicting Objects from Apollo Client Cache (JavaScript)\nDESCRIPTION: Calls the evict method on InMemoryCache to remove a specific normalized object by its object ID from the cache. This operation often leaves other references to the evicted object in place, so it is commonly followed by a gc operation. No external dependencies are required beyond the cache instance.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/garbage-collection.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\ncache.evict({ id: 'my-object-id' })\n```\n\n----------------------------------------\n\nTITLE: Register Callback for Cache Reset with client.onResetStore\nDESCRIPTION: Demonstrates registering callbacks to execute when the cache is reset via client.onResetStore, passing in functions that update cache defaults or trigger UI rerenders. It also shows unregistering callbacks. Dependencies include '@apollo/client'.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/advanced-topics.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { useApolloClient } from '@apollo/client';\n\nfunction Foo (){\n  const [reset, setReset] = useState(0);\n  const client = useApolloClient();\n\n  useEffect(() => {\n    const unsubscribe = client.onResetStore(() =>\n      new Promise(()=>setReset(reset + 1))\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  });\n\n  return reset ? <div /> : <span />;\n}\n\nexport default Foo;\n```\n\n----------------------------------------\n\nTITLE: Configuring esbuild to Remove Development Code - JSON\nDESCRIPTION: This configuration file shows how to use esbuild's define property to set globalThis.__DEV__ to \"false\", ensuring Apollo Client development-mode code is excluded from the bundle. Requires an esbuild-compatible project. The input is typically a JavaScript or JSON configuration file, and the output is a leaner bundle.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/reducing-bundle-size.mdx#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"define\": {\n    \"globalThis.__DEV__\": \"false\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query for All People\nDESCRIPTION: This GraphQL query example is used to demonstrate how Apollo Client's cache stores data retrieved from a server. It fetches a list of people, including their ID, name, and homeworld (ID and name), illustrating a common query pattern that results in nested data structures.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/overview.mdx#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  allPeople(first:3) { # Return the first 3 items\n    people {\n      id\n      name\n      homeworld {\n        id\n        name\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Apollo Client with @client Field Resolver (Example 2)\nDESCRIPTION: Sets up Apollo Client to integrate local state ('isLoggedIn') with a remote query. It defines a query with a field marked `@client`, initializes the client with a remote link, cache, and a resolver that calls a local function.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/local-resolvers.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ApolloClient, InMemoryCache, HttpLink, gql } from '@apollo/client';\n\nconst MEMBER_DETAILS = gql`\n  query Member {\n    member {\n      name\n      role\n      isLoggedIn @client\n    }\n  }\n`;\n\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: 'http://localhost:4000/graphql' }),\n  cache: new InMemoryCache(),\n  resolvers: {\n    Member: {\n      isLoggedIn() {\n        return someInternalLoginVerificationFunction();\n      }\n    }\n  },\n});\n\n// ... run the query using client.query, the <Query /> component, etc.\n```\n\n----------------------------------------\n\nTITLE: Stateless ApolloLink for Authorization - JavaScript\nDESCRIPTION: This snippet illustrates adding an `Authorization` header to every outgoing request using a stateless `ApolloLink`. It sets the `Authorization` header in the operation context using `operation.setContext`. The `Auth.userId()` function is assumed to return the user's ID or token.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/introduction.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink } from '@apollo/client';\n\nconst authLink = new ApolloLink((operation, forward) => {\n  operation.setContext(({ headers }) => ({ headers: {\n    authorization: Auth.userId(), // however you get your token\n    ...headers\n  }}));\n  return forward(operation);\n});\n\n```\n\n----------------------------------------\n\nTITLE: Configuration of GraphQL Code Generator (`codegen.ts`)\nDESCRIPTION: Defines the configuration for GraphQL Code Generator, specifying schema source, document paths, output directory, and presets. Sets up the generator to produce typed GraphQL hooks and types for a TypeScript project.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { CodegenConfig } from '@graphql-codegen/cli';\n\nconst config: CodegenConfig = {\n  schema: '<URL_OF_YOUR_GRAPHQL_API>',\n  documents: ['src/**/*.{ts,tsx}'],\n  generates: {\n    './src/__generated__/': {\n      preset: 'client',\n      plugins: [],\n      presetConfig: {\n        gqlTagName: 'gql',\n      }\n    }\n  },\n  ignoreNoDocuments: true,\n};\n\nexport default config;\n```\n\n----------------------------------------\n\nTITLE: Starting Apollo Client Watch Build Shell\nDESCRIPTION: Navigates to the root directory of the local Apollo Client checkout and runs the watch npm script. This typically compiles the Apollo Client source code and watches for file changes, automatically rebuilding the dist directory when modifications are detected. This is necessary for testing local changes.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\n# ... in a separate terminal window\ncd [apollo-client-root]\nnpm run watch\n```\n\n----------------------------------------\n\nTITLE: Configuring refetchQueries Context in Apollo Client mutate - JavaScript\nDESCRIPTION: This snippet demonstrates how to provide a custom context for specific queries within the `refetchQueries` option of the `client.mutate` method in Apollo Client. This allows overriding the default context used when the refetched queries were initially observed. It requires an Apollo Client instance and defined GraphQL query and mutation documents.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_56\n\nLANGUAGE: javascript\nCODE:\n```\ncontext = {\n  headers: {\n    token: 'some auth token',\n  },\n};\nclient.mutate({\n  mutation: UPDATE_CUSTOMER_MUTATION,\n  variables: {\n    userId: user.id,\n    firstName,\n    ...\n  },\n  refetchQueries: [{\n    query: CUSTOMER_MESSAGES_QUERY,\n    variables: { userId: user.id },\n    context,\n  }],\n  context,\n});\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Response Modification Using asyncMap (JavaScript)\nDESCRIPTION: This snippet demonstrates using @apollo/client/utilities' asyncMap to asynchronously modify response data, such as converting a USD price to EUR via an external API. It's suitable for modifications requiring asynchronous operations within the response pipeline.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/advanced-http-networking.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  ApolloClient,\n  InMemoryCache,\n  HttpLink,\n  ApolloLink\n} from \"@apollo/client\";\nimport { asyncMap } from \"@apollo/client/utilities\";\n\nimport { usdToEur } from './currency';\n\nconst httpLink = new HttpLink({ uri: '/graphql' });\n\nconst usdToEurLink = new ApolloLink((operation, forward) => {\n  return asyncMap(forward(operation), async (response) => {\n    let data = response.data;\n    if (data.price && data.currency === \"USD\") {\n      data.price = await usdToEur(data.price);\n      data.currency = \"EUR\";\n    }\n    return response;\n  });\n});\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: usdToEurLink.concat(httpLink)\n});\n```\n\n----------------------------------------\n\nTITLE: Importing React HOC and Components in Apollo Client 3.0\nDESCRIPTION: Demonstrates how to import React Higher-Order Components (`graphql`) and Components (`Query`, `Mutation`, `Subscription`) from specific entry points within the `@apollo/client` package in version 3.0. This replaces previous imports from separate `@apollo/react-hoc` and `@apollo/react-components` packages.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Query, Mutation, Subscription } from '@apollo/client/react/components';\nimport { graphql } from '@apollo/client/react/hoc';\n```\n\n----------------------------------------\n\nTITLE: Invalidating Specific Field in Apollo Cache Object using cache.modify in JavaScript\nDESCRIPTION: Illustrates how to invalidate a specific field (`comments`) in a cached object without changing its value. This is done by returning the `INVALIDATE` sentinel object from the field modifier function within `cache.modify`, causing dependent watched queries to refetch.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-interaction.mdx#_snippet_14\n\nLANGUAGE: js\nCODE:\n```\ncache.modify({\n  id: cache.identify(myPost),\n  fields: {\n    comments(existingCommentRefs, { INVALIDATE }) {\n      return INVALIDATE;\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Define Field Policy for cartItems (InMemoryCache, JS)\nDESCRIPTION: Defines a field policy for the `cartItems` field within the `Query` type in the `InMemoryCache`. The `read` function is configured to return the current value of the `cartItemsVar` reactive variable whenever the `cartItems` field is queried.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nexport const cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        cartItems: {\n          read() {\n            return cartItemsVar();\n          }\n        }\n      }\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Initialize Reactive Variable (makeVar, JS)\nDESCRIPTION: Initializes a reactive variable `cartItemsVar` using `makeVar` from `@apollo/client`. This variable stores an array of cart items. The initial value is set to an empty array, and the returned function is used to access and update the variable's value.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/managing-state-with-field-policies.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { makeVar } from '@apollo/client';\n\nexport const cartItemsVar = makeVar([]);\n```\n\n----------------------------------------\n\nTITLE: Skipping a query during SSR using Apollo Client in React\nDESCRIPTION: This snippet demonstrates how to prevent a GraphQL query from running during server-side rendering by setting the 'ssr' option to false in the 'useQuery' hook. It helps components render correctly in loading state without executing the query on the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/server-side-rendering.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction withClientOnlyUser() {\n  useQuery(GET_USER_WITH_ID, { ssr: false });\n  return <span>My query won't be run on the server</span>;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Data Masking in Apollo Client (JavaScript)\nDESCRIPTION: This snippet shows how to instantiate a new `ApolloClient` instance with the `dataMasking` option enabled. This client-wide setting enforces default masking behavior for all GraphQL queries and fragments in the application. The configuration requires Apollo Client version with masking support and should be applied after all `@unmask` migration changes.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_67\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew ApolloClient({\n  dataMasking: true,\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Fragment and Component in Apollo Client (Initial)\nDESCRIPTION: Defines a GraphQL fragment `PostDetailsFragment` containing fields like `title`, `shortDescription`, and `publishedAt`, and a React component `PostDetails` that uses data from this fragment to render post information. This shows the initial setup where the fragment defines the data requirements for the component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_31\n\nLANGUAGE: jsx\nCODE:\n```\nexport const POST_DETAILS_FRAGMENT = gql`\n  fragment PostDetailsFragment on Post {\n    title\n    shortDescription\n    publishedAt\n  }\n`;\n\nexport default function PostDetails({ post }) {\n  return (\n    <section>\n      <h1>{post.title}</h1>\n      <p>{post.shortDescription}</p>\n      <p>\n        {post.publishedAt ?\n          `Published: ${formatDate(post.publishedAt)}`\n        : 'Private'}\n      </p>\n    </section>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Faker.js to Generate Random Descriptions\nDESCRIPTION: Utility function using faker.js library to generate random Lorem Ipsum text for mocked rocket descriptions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { faker } from \"@faker-js/faker\";\n\n// Returns 1 or 2 sentences of Lorem Ipsum\nconst oneOrTwoSentences = () =>\n  faker.lorem.sentences(Math.random() < 0.5 ? 1 : 2);\n```\n\n----------------------------------------\n\nTITLE: Limitation of typePatcher with Nested @type Directives\nDESCRIPTION: Shows a GraphQL query illustrating a known limitation where `typePatcher` cannot act on nested fields (`failingResults`) within an object already annotated with the `@type` directive (`results`).\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_11\n\nLANGUAGE: graphql\nCODE:\n```\nquery MyQuery {\n  planets @rest(type: \"PlanetPayload\", path: \"planets/\") {\n    count\n    next\n    results @type(name: \"Planet\") {\n      name\n      failingResults {\n        name\n      }\n    }\n    typePatchedResults {\n      name\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running All Tests with npm - Shell\nDESCRIPTION: Shows how to execute the entire Apollo Client test suite once using npm. This depends on npm and the project's test scripts, and outputs results from all defined tests. Useful for validating changes or confirming a clean working state.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm run test\n```\n\n----------------------------------------\n\nTITLE: Creating an enhancer function with graphql() and applying it to a component\nDESCRIPTION: This example creates an intermediate enhancer function using graphql() with a specific query, then applies this enhancer to wrap a React component, separating data logic from presentation for better modularity.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Create our enhancer function.\nconst withTodoAppQuery = graphql(gql`query TodoAppQuery { ... }`);\n\n// Enhance our component.\nconst TodoAppWithData = withTodoAppQuery(TodoApp);\n\n// Export the enhanced component.\nexport default TodoAppWithData;\n```\n\n----------------------------------------\n\nTITLE: useReadQuery Signature (TypeScript)\nDESCRIPTION: Defines the signature of the `useReadQuery` hook in TypeScript. This hook reads data from a `QueryRef` created by `useBackgroundQuery` or `useLoadableQuery`. It returns the data, network status, and any errors associated with the query.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useReadQuery<TData>(\n  queryRef: QueryRef<TData>\n): {\n  data: TData;\n  networkStatus: NetworkStatus;\n  error: ApolloError | undefined;\n} {}\n```\n\n----------------------------------------\n\nTITLE: Reloading Data with refetch Function\nDESCRIPTION: This snippet demonstrates how to use the `data.refetch` function to reload data in a component. It attaches the `refetch` function to a button's `onClick` handler. The `graphql()` HOC injects the `data` prop, which includes the `refetch` function.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyComponent({ data: { refetch } }) {\n  return <button onClick={() => refetch()}>Reload</button>;\n}\n\nexport default graphql(gql`query MyComponentQuery  { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Fixing Cache Update Propagation in useSuspenseQuery for Strict Mode\nDESCRIPTION: This change addresses an issue where cache updates did not propagate to `useSuspenseQuery` when React was in strict mode. It ensures cache changes trigger appropriate re-renders, maintaining data consistency in Suspense-enabled hooks.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_27\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Updating a GraphQL Fragment in Apollo Cache (TypeScript)\nDESCRIPTION: The `updateFragment` method fetches data from the cache in the shape of a provided GraphQL fragment and updates that cached data according to a provided update function. It takes an options object with the fragment and the ID of the cached object, and an update function that receives the current cached value.  It returns the updated result or null if the update failed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\npublic updateFragment<TData = any, TVariables = any>(\n  options: Cache.UpdateFragmentOptions<TData, TVariables>,\n  update: (data: TData | null) => TData | null | void,\n): TData | null\n```\n\n----------------------------------------\n\nTITLE: Cloning & Installing Fullstack Tutorial Shell\nDESCRIPTION: Clones the Apollo fullstack tutorial application repository, navigates to the final directory, and installs dependencies for both the server and client projects using npm. This sets up the application that will be used for testing.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\ngit clone https://github.com/apollographql/fullstack-tutorial.git\ncd fullstack-tutorial\ncd final/server\nnpm i\ncd ../client\nnpm i\n```\n\n----------------------------------------\n\nTITLE: Setting Apollo Client Cache Sizes Before Loading the Library in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to set custom cache sizes globally before importing and initializing the Apollo Client library. By assigning an object to a global symbol keyed as \"apollo.cacheSize\", you define specific sizes for different internal caches such as the parser and fragment registry. This approach ensures that caches created after the library loads inherit these sizes. It requires the 'CacheSizes' type from '@apollo/client/utilities' to maintain type safety. Input is an object mapping cache keys to their desired sizes, and output affects internal caching behavior on library initialization.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/memory-management.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CacheSizes } from '@apollo/client/utilities';\n\nglobalThis[Symbol.for(\"apollo.cacheSize\")] = {\n parser: 100,\n \"fragmentRegistry.lookup\": 500\n} satisfies Partial<CacheSizes>\n```\n\n----------------------------------------\n\nTITLE: Creating a reactive variable with makeVar in JavaScript\nDESCRIPTION: Demonstrates how to initialize a reactive variable using Apollo Client's makeVar function to hold an array, which can be read and modified later. The snippet emphasizes that makeVar returns a function used to access and update the variable's value.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/reactive-variables.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { makeVar } from '@apollo/client';\n\nconst cartItemsVar = makeVar([]);\n```\n\n----------------------------------------\n\nTITLE: Using responseTransformer for Non-Standard JSON\nDESCRIPTION: Demonstrates configuring `RestLink` with a `responseTransformer` function to handle REST API responses that don't match the default expected structure. This transformer extracts the nested `data` array.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_15\n\nLANGUAGE: js\nCODE:\n```\nconst link = new RestLink({\n  uri: '/api',\n  responseTransformer: async response => response.json().then(({data}) => data),\n});\n```\n\n----------------------------------------\n\nTITLE: Apollo Client Cache Structure for User Query\nDESCRIPTION: Demonstrates the default cache structure in Apollo Client for the `Query.user` field. Each `user` query with a different `id` argument results in a separate cache entry under the `ROOT_QUERY` object. The storage key includes the argument values.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/key-args.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  'ROOT_QUERY': {\n    'user({\"id\":\"1\"})': {\n      '__ref': 'User:1'\n    },\n    'user({\"id\":\"2\"})': {\n      '__ref': 'User:2'\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Headers to Apollo Client HTTP Requests\nDESCRIPTION: Shows how to add custom HTTP headers to every request made by Apollo Client. This example includes an authorization token from localStorage and client identification headers.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/networking/basic-http-networking.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloClient, InMemoryCache } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'https://api.example.com',\n  cache: new InMemoryCache(),\n  headers: {\n    authorization: localStorage.getItem('token'),\n    'client-name': 'WidgetX Ecom [web]',\n    'client-version': '1.0.0'\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Performing Garbage Collection in JavaScript\nDESCRIPTION: Example of calling the gc method on an InMemoryCache instance to remove unreachable normalized objects, returning an array of removed object IDs.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\ncache.gc();\n```\n\n----------------------------------------\n\nTITLE: Using removeTypename in Link Chain\nDESCRIPTION: This snippet shows how to integrate the `removeTypenameLink` into an Apollo Client link chain to automatically remove `__typename` fields from all variables. It depends on the `from` function and an `httpLink`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { from } from '@apollo/client';\n\nconst link = from([removeTypenameLink, httpLink]);\n\nconst client = new ApolloClient({\n  link,\n  // ... other options\n});\n```\n\n----------------------------------------\n\nTITLE: Mutation Example\nDESCRIPTION: This snippet illustrates a GraphQL mutation using the data retrieved from the previous query. It highlights the issue of the `__typename` field causing errors if not removed.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst mutation = gql`\n  mutation UpdateDashboardMutation($dashboard: DashboardInput!) {\n    updateDashboard(dashboard: $dashboard) {\n      id\n      name\n    }\n  }\n`;\n\nawait client.mutate({\n  mutation,\n  variables: {\n    dashboard: { ...data.dashboard, name: 'My Updated Dashboard' }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Generate Apollo Client Documentation Model (Shell)\nDESCRIPTION: Executes the `docmodel` script defined in the `apollo-client` repository's `package.json`. This script processes the documentation source files within Apollo Client and generates the data structure required by the main documentation site to display the content.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm run docmodel\n```\n\n----------------------------------------\n\nTITLE: Ensuring Context Value Stability in ApolloProvider\nDESCRIPTION: This update maintains stability of the React Context when re-rendering `ApolloProvider` with the same client or suspense cache props, preventing unnecessary reinitializations or context resets during re-renders.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_29\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Importing Fragment in Webpack with GraphQL\nDESCRIPTION: This snippet provides an example of importing a fragment using the `#import` directive in a GraphQL file.  It's designed to be used with a Webpack loader such as `graphql-tag/loader`. This enables inclusion of fragment definitions from separate `.graphql` files, facilitating code reusability and organization.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_14\n\nLANGUAGE: GraphQL\nCODE:\n```\n#import \"./someFragment.graphql\"\n```\n\n----------------------------------------\n\nTITLE: Responding to Cache Updates in useSuspenseQuery with Cache-First fetchPolicy\nDESCRIPTION: This fix ensures `useSuspenseQuery` responds appropriately to cache updates when using `cache-first` fetch policy by triggering re-renders after data changes, maintaining UI consistency.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_34\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Ensuring includeUnusedVariables Works with BatchHttpLink\nDESCRIPTION: This fix makes the `includeUnusedVariables` option functional when used with `BatchHttpLink`, ensuring variables that are not used in GraphQL requests are properly handled according to the configuration.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_37\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Making Private Fields in QueryManager Protected for Extensibility\nDESCRIPTION: This snippet refactors `inFlightLinkObservables` and `fetchCancelFns` in QueryManager to be protected, allowing subclasses in `@apollo/experimental-nextjs-app-support` to access these internal states for advanced use-cases or extensions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_28\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Cloning & Installing Apollo Client Shell\nDESCRIPTION: Clones the Apollo Client repository from GitHub, navigates into the directory, and installs its dependencies using npm. This prepares the local Apollo Client source for development and linking.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\ngit clone https://github.com/apollographql/apollo-client.git\ncd apollo-client\nnpm i\ncd ..\n```\n\n----------------------------------------\n\nTITLE: Configuring GraphQL Codegen Preset for Apollo Data Masking\nDESCRIPTION: Shows how to configure the `@graphql-codegen/client-preset` to disable its built-in fragment masking (`fragmentMasking: false`) and enable Apollo Client-specific options (`customDirectives`, `inlineFragmentTypes`) necessary for Apollo's data masking features. This configuration is essential when migrating from Codegen's masking to Apollo Client's.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_54\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst config: CodegenConfig = {\n  // ...\n  generates: {\n    \"path/to/gql/\": {\n      preset: \"client\",\n      presetConfig: {\n        // ...\n        // disables the incompatible GraphQL Codegen fragment masking feature\n        fragmentMasking: false,\n      },\n      config: {\n        customDirectives: {\n          apolloUnmask: true\n        },\n        inlineFragmentTypes: \"mask\",\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Diagnostic Query Filtering Using onQueryUpdated Callback in Apollo Client (TypeScript)\nDESCRIPTION: This code demonstrates attaching an onQueryUpdated callback to client.refetchQueries for logging and debugging purposes. The callback is called for each candidate ObservableQuery, and the default refetching behavior is preserved by returning true. Input: observableQuery instance; Output: logs on which queries are considered and a Promise resolving after refetch. Useful in development and debugging scenarios.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst results = await client.refetchQueries({\n  updateCache(cache) {\n    cache.evict({ fieldName: \"someRootField\" });\n  },\n\n  onQueryUpdated(observableQuery) {\n    // Logging and/or debugger breakpoints can be useful in development to\n    // understand what client.refetchQueries is doing.\n    console.log(`Examining ObservableQuery ${observableQuery.queryName}`);\n    debugger;\n\n    // Proceed with the default refetching behavior, as if onQueryUpdated\n    // was not provided.\n    return true;\n  },\n});\n\nresults.forEach(result => {\n  // These results will be ApolloQueryResult<any> objects, after all\n  // results have been refetched from the network.\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client for React Higher-Order Components (HOCs)\nDESCRIPTION: This code snippet details how to set up the environment to use Apollo HOCs by installing the core client and hoc-specific package, enabling the use of HOC pattern in React.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/hooks-migration.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client @apollo/react-hoc\n```\n\n----------------------------------------\n\nTITLE: Default RetryLink Configuration in TypeScript\nDESCRIPTION: This snippet shows the equivalent default configuration of `RetryLink` using Typescript to illustrate the default options. It defines the `delay` and `attempts` options with their default values, including the `initial`, `max`, and `jitter` properties for delay and `max` and `retryIf` properties for attempts. This snippet can be translated to JavaScript by omitting the type definitions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-retry.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nnew RetryLink({\n  delay: {\n    initial: 300,\n    max: Infinity,\n    jitter: true\n  },\n  attempts: {\n    max: 5,\n    retryIf: (error, _operation) => !!error\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering Component with Mocked Field Data\nDESCRIPTION: React component that displays both server-provided data and locally mocked field data using the useQuery hook.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/client-schema-mocking.mdx#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function LaunchDetails({ launchId }) {\n  const { data } = useQuery(GET_LAUNCH_DETAILS, { variables: { rocketId } });\n  return (\n    <div>\n      <p>Rocket Type: {data.launch.rocket.type}</p>\n      <p>Description: {data.launch.rocket.description}</p>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Making useSuspenseQuery Compatible with React's useDeferredValue\nDESCRIPTION: This update fixes compatibility issues between `useSuspenseQuery` and React’s `useDeferredValue` and `startTransition`, enabling better concurrent UI rendering while suspending.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_41\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Importing Apollo Link Utilities in Apollo Client 3.0\nDESCRIPTION: Shows how to import Apollo Link related functionalities (`ApolloLink`, `HttpLink`, `from`, `split`, `execute`) directly from the `@apollo/client` package. This integration replaces the need for separate `apollo-link`, `apollo-link-http`, and `apollo-link-http-common` packages.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ApolloLink, HttpLink, from, split, execute } from '@apollo/client';\n```\n\n----------------------------------------\n\nTITLE: Configuring Metro Bundler for CJS Extensions in React Native\nDESCRIPTION: Sets up Metro configuration to properly resolve .cjs file extensions in React Native projects, which is necessary for using Apollo Client imports correctly.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/integrations/react-native.mdx#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst { getDefaultConfig } = require('@expo/metro-config');\n\nconst config = getDefaultConfig(__dirname);\n\nconfig.resolver.sourceExts.push(\n  'cjs'\n);\n\nmodule.exports = config;\n```\n\n----------------------------------------\n\nTITLE: Defining FetchPolicy and WatchQueryFetchPolicy Types in TypeScript for Apollo Client\nDESCRIPTION: Shows the TypeScript type definitions for FetchPolicy and WatchQueryFetchPolicy enums used by Apollo Client to specify caching and network fetching behaviors for queries. The FetchPolicy type lists permissible strategies for queries, excluding 'cache-and-network', which is encapsulated in WatchQueryFetchPolicy. This separation enforces stronger typing and helps catch invalid fetch policy usages at compile time. Both type aliases are string unions representing different fetch approaches like 'cache-first' or 'network-only'. It requires TypeScript syntax support.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_54\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type FetchPolicy =\n  | \"cache-first\"\n  | \"network-only\"\n  | \"cache-only\"\n  | \"no-cache\"\n  | \"standby\";\n\nexport type WatchQueryFetchPolicy = FetchPolicy | \"cache-and-network\";\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Fragment When Masking Enabled (Initial)\nDESCRIPTION: Shows the original `GetPosts` GraphQL query definition used by the `Posts` component after data masking has been enabled. When data masking is active, fields defined *only* within `...PostDetailsFragment` will not be accessible directly from the `data` object returned by `useQuery` in the `Posts` component.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_34\n\nLANGUAGE: jsx\nCODE:\n```\nconst GET_POSTS = gql`\n  query GetPosts {\n    posts {\n      id\n      ...PostDetailsFragment\n    }\n  }\n\n  ${POST_DETAILS_FRAGMENT}\n`;\n\nexport default function Posts({ includeUnpublishedPosts }) {\n  const { data, loading } = useQuery(GET_POSTS);\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Document Transform in Apollo Client with TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom document transform using the DocumentTransform class and pass it to the ApolloClient constructor. The transform takes a document as input, modifies it, and returns the transformed document.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/document-transforms.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DocumentTransform } from '@apollo/client';\n\nconst documentTransform = new DocumentTransform((document) => {\n  // modify the document\n  return transformedDocument;\n});\n\nconst client = new ApolloClient({\n  documentTransform\n});\n```\n\n----------------------------------------\n\nTITLE: Reading the value of a reactive variable in JavaScript\nDESCRIPTION: Shows how to obtain the current value of a reactive variable by invoking the function returned by makeVar with no arguments. It outputs the current state of the variable.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/local-state/reactive-variables.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst cartItemsVar = makeVar([]);\n\n// Output: []\nconsole.log(cartItemsVar());\n```\n\n----------------------------------------\n\nTITLE: Illustrating FragmentType Preventing Direct Prop Access\nDESCRIPTION: This snippet, shown within the component context, illustrates the TypeScript error that occurs when attempting to directly access fields (like `post.title`) on a prop typed with `FragmentType`. It highlights that `FragmentType` encapsulates the data, requiring `useFragment` to safely access the underlying fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_59\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction PostDetails({ post }: PostDetailsProps) {\n  // ...\n\n  post.title\n  // ❌ Property 'title' does not exist on type '{ \" $fragmentRefs\"?: { PostDetailsFragment: PostDetailsFragment; } | undefined; }'\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring babel-plugin-import-graphql\nDESCRIPTION: Shows how to configure `babel-plugin-import-graphql` within a `.babelrc` configuration file. It adds \"import-graphql\" to the plugins array.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"plugins\": [\n    \"import-graphql\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing babel-plugin-import-graphql with yarn\nDESCRIPTION: Shows how to install the `babel-plugin-import-graphql` package using yarn as a development dependency.  This is an alternative to using npm.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/performance/babel.mdx#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add --dev babel-plugin-import-graphql\n```\n\n----------------------------------------\n\nTITLE: Instantiating removeTypename Link\nDESCRIPTION: This code demonstrates how to import and instantiate the `removeTypenameFromVariables` link from the Apollo Client library.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { removeTypenameFromVariables } from '@apollo/client/link/remove-typename';\n\nconst removeTypenameLink = removeTypenameFromVariables();\n```\n\n----------------------------------------\n\nTITLE: Overriding Registered Fragments with Local Versions\nDESCRIPTION: Example of declaring local fragment definitions that take precedence over fragments registered with the cache, even when referenced indirectly.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nimport { ApolloClient, gql, InMemoryCache } from \"@apollo/client\";\nimport { createFragmentRegistry } from \"@apollo/client/cache\";\n\nconst client = new ApolloClient({\n  uri: \"http://localhost:4000/graphql\",\n  cache: new InMemoryCache({\n    fragments: createFragmentRegistry(gql`\n      fragment ItemFragment on Item {\n        id\n        text\n        ...ExtraFields\n      }\n\n      fragment ExtraFields on Item {\n        isCompleted\n      }\n    `)\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: Evict Method Signature in TypeScript\nDESCRIPTION: The signature for the evict method of InMemoryCache class, which removes data from the cache based on the provided options.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nevict(options: Cache.EvictOptions): boolean\n```\n\n----------------------------------------\n\nTITLE: Configuring fetchPolicy in useReadQuery\nDESCRIPTION: Defines the fetch policy type which controls how the query interacts with the Apollo Client cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nSuspenseQueryHookFetchPolicy\n```\n\n----------------------------------------\n\nTITLE: Unmasked TypeScript Type for Query Result Including Fragment Fields\nDESCRIPTION: This TypeScript type definition shows the unmasked version of the GetCurrentUserQuery query result, where all fields from fragment spreads are included directly in the type. This example illustrates the resulting structure when masking is disabled or @unmask is used. Input: generated codegen result; Output: object with all fragment and base selection fields for currentUser.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_51\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype GetCurrentUserQuery = {\n  currentUser: {\n    __typename: \"User\";\n    id: string;\n    name: string;\n    age: number;\n  } | null\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping Certain Queries During Refetching Using onQueryUpdated in Apollo Client (TypeScript)\nDESCRIPTION: This snippet shows how to skip specific queries that would otherwise be refetched by client.refetchQueries by returning false from the onQueryUpdated callback. The code logs examined queries and applies filtering logic via shouldIgnoreQuery. Inputs: observableQuery and its result metadata. Output: queries not matching the filter are skipped.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/refetching.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait client.refetchQueries({\n  updateCache(cache) {\n    cache.evict({ fieldName: \"someRootField\" });\n  },\n\n  onQueryUpdated(observableQuery, { complete, result, missing }) {\n    console.log(`Examining ObservableQuery ${\n      observableQuery.queryName\n    } whose latest result is ${JSON.stringify(result)} which is ${\n      complete ? \"complete\" : \"incomplete\"\n    }`);\n\n    if (shouldIgnoreQuery(observableQuery)) {\n      return false;\n    }\n\n    // Refetch the query unconditionally from the network.\n    return true;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting returnPartialData option type\nDESCRIPTION: Specifies the boolean type for returnPartialData option that allows partial results from cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nboolean\n```\n\n----------------------------------------\n\nTITLE: Configuring Link context in useReadQuery\nDESCRIPTION: Specifies the type for the context object that gets passed along Apollo Link chain.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nRecord<string, any>\n```\n\n----------------------------------------\n\nTITLE: Example of Strict Type Safety and Errors in props Function with graphql HOC\nDESCRIPTION: An example illustrating type checking in the props function that enforces correct types and surfaces errors when invalid properties or type mismatches occur. Demonstrates how the types enable detection of invalid comparisons or access to undefined properties.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_13\n\nLANGUAGE: TS\nCODE:\n```\nexport const withCharacter = graphql<\n  GetCharacterQueryVariables,\n  GetCharacterQuery,\n  GetCharacterQueryVariables,\n  Props\n>(HERO_QUERY, {\n  options: ({ episode }) => ({\n    variables: { episode }\n  }),\n  props: ({ data, ownProps }) => ({\n    ...data,\n    // $ExpectError [string] This type cannot be compared to number\n    episode: ownProps.episode > 1,\n    // $ExpectError property `isHero`. Property not found on object type\n    isHero: data && data.hero && data.hero.isHero\n  })\n});\n```\n\n----------------------------------------\n\nTITLE: Installing subscriptions-transport-ws Package\nDESCRIPTION: Command to install the subscriptions-transport-ws library via npm, which is required for using WebSocketLink.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-ws.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install subscriptions-transport-ws\n```\n\n----------------------------------------\n\nTITLE: Initializing ApolloClient with Immutable Results Flag in TypeScript\nDESCRIPTION: Demonstrates how to initialize an ApolloClient instance with the 'assumeImmutableResults' option enabled. This option informs Apollo Client that the application will not modify cached result objects, allowing it to skip deep cloning for performance gains. The snippet requires the '@apollo/client' package and assumes standard Apollo Client setup with TypeScript. The code input creates an ApolloClient object with this optimization flag enabled, outputting an instance prepared to manage GraphQL operations efficiently.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_53\n\nLANGUAGE: TypeScript\nCODE:\n```\nnew ApolloClient({ assumeImmutableResults: true });\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query Example\nDESCRIPTION: This is a GraphQL query example used to illustrate data fetching.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_21\n\nLANGUAGE: graphql\nCODE:\n```\nquery ViewerAndTodos {\n  viewer {\n    name\n  }\n  todos {\n    text\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect skip usage - TypeScript\nDESCRIPTION: Illustrates an incorrect way to use the `skip` option with `useSuspenseQuery` in TypeScript, leading to potential type errors and hidden bugs.  It highlights the problem of needing to use type assertions or default values, obscuring the relationship between skipping and variable definitions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hooks.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst { data } = useSuspenseQuery(query, {\n  variables: { id },\n  skip: !id\n});\n```\n\n----------------------------------------\n\nTITLE: Apollo Client: Query Signature Example\nDESCRIPTION: This snippet illustrates the structure of a query signature when implementing Automatic Persisted Queries (APQs) in Apollo Client.  It demonstrates how the `extensions` field is used to send the hash of the query. Dependencies:  Apollo Client. Input:  None. Output:  A JSON object representing the query signature.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  operationName: 'MyQuery',\n  variables: null,\n  extensions: {\n    persistedQuery: {\n      version: 1,\n      sha256Hash: hashOfQuery\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Masked Response Structure after useFragment (JSON)\nDESCRIPTION: This JSON object demonstrates the structure of masked result data returned from Apollo Client's useFragment when using a fragment on the Post type. Only properties included in the fragment (title, shortDescription, topComment.id) are present, with nested objects maintaining masking. This is useful for confirming data masking behavior in Apollo Client's cache reads.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_42\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"__typename\": \"Post\",\n  \"title\": \"The Amazing Adventures of Data Masking\",\n  \"shortDescription\": \"In this article we dive into...\",\n  \"topComment\": {\n    \"__typename\": \"Comment\",\n    \"id\": \"1\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Silencing useLayoutEffect Warning on Server for useSuspenseQuery\nDESCRIPTION: This change suppresses React's `useLayoutEffect` warning during server-side rendering of `useSuspenseQuery`, preventing unnecessary warning logs when hooks run outside of client DOM.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_40\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Setting Apollo Client Log Verbosity - TypeScript\nDESCRIPTION: Demonstrates how to configure the logging level for Apollo Client console messages using the `setLogVerbosity` function. This function controls which types of messages (log, warn, error) are displayed in the console during development.\nDependencies: @apollo/client package. Parameters: Takes a string argument ('log', 'warn', 'error', 'silent') to set the verbosity level. Output: Adjusts console output behavior.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_49\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { setLogVerbosity } from \"@apollo/client\";\nsetLogVerbosity(\"log\"); // display all messages\nsetLogVerbosity(\"warn\"); // display only warnings and errors (default)\nsetLogVerbosity(\"error\"); // display only errors\nsetLogVerbosity(\"silent\"); // hide all console messages\n```\n\n----------------------------------------\n\nTITLE: Nested Fields Configuration\nDESCRIPTION: This code demonstrates how to configure `removeTypenameFromVariables` to keep `__typename` for deeply nested fields within different input types, including multiple levels of nesting. It also includes array handling in the `widgets` property.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport { removeTypenameFromVariables, KEEP } from '@apollo/client/link/remove-typename';\n\nconst removeTypenameLink = removeTypenameFromVariables({\n  except: {\n    // Keep __typename for `bar` and `baz` fields on any variable\n    // declared as a `FooInput` type\n    FooInput: {\n      bar: KEEP,\n      baz: KEEP,\n    },\n\n    // Keep __typename for the `baz.qux` field on any variable\n    // declared as a `BarInput` type\n    BarInput: {\n      baz: {\n        qux: KEEP\n      }\n    },\n\n    // Keep __typename on `bar.baz` and `bar.qux.foo` fields for any\n    // variable declared as a `BazInput` type\n    BazInput: {\n      bar: {\n        baz: KEEP,\n        qux: {\n          foo: KEEP\n        }\n      }\n    },\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Garbage Collection Method Signature in TypeScript\nDESCRIPTION: The signature for the gc method of InMemoryCache class, which performs garbage collection of unreachable normalized objects in the cache.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ngc()\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Error Response Format\nDESCRIPTION: This code sample illustrates the JSON structure of an error response returned when a GraphQL operation encounters an error, including error message, locations, extensions, and partial data.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/error-handling.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"errors\": [\n    {\n      \"message\": \"Cannot query field \\\"nonexistentField\\\" on type \\\"Query\\\".\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 3\n        }\n      ],\n      \"extensions\": {\n        \"code\": \"GRAPHQL_VALIDATION_FAILED\",\n        \"exception\": {\n          \"stacktrace\": [\n            \"GraphQLError: Cannot query field \\\"nonexistentField\\\" on type \\\"Query\\\".\",\n            \"...additional lines...\"\n          ]\n        }\n      }\n    }\n  ],\n  \"data\": null\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing onError Callback in useMutation with errorPolicy 'all'\nDESCRIPTION: This snippet fixes a bug where the `onError` callback in `useMutation` was not invoked when an error occurred with `errorPolicy` set to 'all'. It ensures proper error handling behavior aligns with Apollo's error policies.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_30\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Expected JSON Response Structure for Collection\nDESCRIPTION: Example JSON structure that Apollo Client expects by default when fetching a collection of records via REST Link. The response should be an array of objects at the root level.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-rest.mdx#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"id\": 1,\n    \"name\": \"Apollo\"\n  },\n  {\n    \"id\": 2,\n    \"name\": \"Starman\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Accessing Apollo Client React Testing Utilities\nDESCRIPTION: This code snippet demonstrates how to import the MockedProvider component from @apollo/client/testing to facilitate mocking GraphQL data during React testing scenarios.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/hooks-migration.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { MockedProvider } from '@apollo/client/testing';\n```\n\n----------------------------------------\n\nTITLE: Removing nextFetchPolicy Support from useSuspenseQuery\nDESCRIPTION: This breaking change removes support for `nextFetchPolicy` in `useSuspenseQuery`, simplifying the API and avoiding confusion by disallowing unsupported fetch policy configurations.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CHANGELOG.md#_snippet_35\n\nLANGUAGE: JavaScript\nCODE:\n```\n/* code not provided in input, description based on commit message */\n```\n\n----------------------------------------\n\nTITLE: Illustrating Offset-Based Pagination Flow\nDESCRIPTION: A Mermaid sequence diagram illustrating the client-server interaction for offset-based pagination. The client makes requests with 'offset' and 'limit' parameters to fetch specific pages of data from the server.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/pagination/overview.mdx#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram;\n  Client app->>GraphQL server: query GetBookTitles(offset=0 limit=20)\n  GraphQL server->>Client app: Returns the first 20 list elements\n  Client app->>GraphQL server: query GetBookTitles(offset=20 limit=10)\n  GraphQL server->>Client app: Returns the next 10 list elements\n```\n\n----------------------------------------\n\nTITLE: Importing React SSR Utilities in Apollo Client 3.0\nDESCRIPTION: Illustrates importing Server-Side Rendering utilities, such as `renderToStringWithData`, from the `@apollo/client/react/ssr` entry point. This replaces imports from the deprecated `@apollo/react-ssr` package.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/migrating/apollo-client-3-migration.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { renderToStringWithData } from '@apollo/client/react/ssr';\n```\n\n----------------------------------------\n\nTITLE: Combining Masked and Unmasked Fragment Spreads in an Operation (GraphQL)\nDESCRIPTION: This GraphQL query example demonstrates the simultaneous usage of masked and unmasked fragment spreads. The PostFragment is unmasked via @unmask, while PostDetailsFragment remains masked in the query result. Input: GraphQL query; Output: mixed masking for different fragment spreads in the operation result. Requires client support for the @unmask directive.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_49\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery GetPosts {\n  posts {\n    id\n    ...PostFragment @unmask\n    # This data remains masked\n    ...PostDetailsFragment\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Query Printing with stripIgnoredCharacters in JavaScript\nDESCRIPTION: Demonstrates using the `print` constructor option in `HttpLink` to customize how GraphQL query `DocumentNode` objects are transformed into strings before sending. This example uses `stripIgnoredCharacters` from the `graphql` library to remove extraneous whitespace, potentially reducing request size. Requires `@apollo/client` and `graphql` dependencies.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-http.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { stripIgnoredCharacters } from 'graphql';\n\nconst httpLink = new HttpLink({\n  uri: '/graphql',\n  print: (ast, originalPrint) => stripIgnoredCharacters(originalPrint(ast)),\n});\n```\n\n----------------------------------------\n\nTITLE: Restore Method Signature in TypeScript\nDESCRIPTION: The signature for the restore method of InMemoryCache class, which populates the cache with data from a serialized NormalizedCacheObject.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nrestore(data: NormalizedCacheObject): this\n```\n\n----------------------------------------\n\nTITLE: Extract Method Signature in TypeScript\nDESCRIPTION: The signature for the extract method of InMemoryCache class, which serializes the current cache contents into a NormalizedCacheObject.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/cache/InMemoryCache.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nextract(optimistic: boolean = false): NormalizedCacheObject\n```\n\n----------------------------------------\n\nTITLE: Using config.props to map GraphQL data to custom component props\nDESCRIPTION: This snippet shows how to define a mapping function in config.props, transforming the data received from the GraphQL HOC into simplified or custom props for the wrapped component, such as exposing only needed data or functions.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`query MyQuery { ... }`, {\n  props: ({ data: { fetchMore } }) => ({\n    onLoadMore: () => {\n      fetchMore({ ... });\n    },\n  }),\n})(MyComponent);\n\nfunction MyComponent({ onLoadMore }) {\n  return (\n    <button onClick={onLoadMore}>\n      Load More!\n    </button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Options for Mutations in Apollo Client\nDESCRIPTION: This code snippet illustrates how to define the `options` configuration for mutations in Apollo Client's `graphql` function. `options` is an object or function that returns an object used to configure how the query is fetched and updated. Options can also be passed to the `mutate` function. Dependencies: Apollo Client, `graphql` function from `react-apollo` or equivalent, and a GraphQL mutation definition with `gql`.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_34\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`mutation MyMutation { ... }`, {\n  options: {\n    // Options go here.\n  },\n})(MyComponent);\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default graphql(gql`mutation MyMutation { ... }`, {\n  options: props => ({\n    // Options are computed from `props` here.\n  }),\n})(MyComponent);\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction MyComponent({ mutate }) {\n  return (\n    <button\n      onClick={() => {\n        mutate({\n          // Options are component from `props` and component state here.\n        });\n      }}\n    >\n      Mutate\n    </button>\n  );\n}\n\nexport default graphql(gql`mutation MyMutation { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Keeping __typename in JSON Scalars\nDESCRIPTION: This snippet configures the `removeTypenameFromVariables` link to retain the `__typename` field for specific JSON scalar input types, such as those used in conjunction with the `JSON` type. Dependencies include the `KEEP` sentinel and the `removeTypenameFromVariables` function.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { removeTypenameFromVariables, KEEP } from '@apollo/client/link/remove-typename';\n\nconst removeTypenameLink = removeTypenameFromVariables({\n  except: {\n    JSON: KEEP\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Data Refresh with data.startPolling() and data.stopPolling() in Apollo Client\nDESCRIPTION: These snippets show how to start polling for data at specified intervals and how to stop polling in a React component, enabling periodic data refreshes without manual re-fetching. The startPolling method accepts an interval in milliseconds, while stopPolling ceases the polling process.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_24\n\nLANGUAGE: JavaScript\nCODE:\n```\ncomponentDidMount() {\n  this.props.data.startPolling(1000);\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass MyComponent extends Component {\n  render() {\n    return (\n      <div>\n        <button\n          onClick={() => {\n            this.props.data.startPolling(1000);\n          }}\n        >\n          Start Polling\n        </button>\n        <button\n          onClick={() => {\n            this.props.data.stopPolling();\n          }}\n        >\n          Stop Polling\n        </button>\n      </div>\n    );\n  }\n}\nexport default graphql(gql`query MyComponentQuery { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Setting ErrorPolicy in useReadQuery\nDESCRIPTION: Defines the error policy type for handling GraphQL errors and partial results in queries.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/shared/useBackgroundQuery-options.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nErrorPolicy\n```\n\n----------------------------------------\n\nTITLE: Querying Data Example\nDESCRIPTION: This snippet shows a sample GraphQL query using Apollo Client to retrieve data, which automatically includes the `__typename` field.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/apollo-link-remove-typename.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst query = gql`\n  query DashboardQuery($id: ID!) {\n    dashboard(id: $id) {\n      id\n      name\n    }\n  }\n`;\n\nconst { data } = await client.query({ query, variables: { id: 1 }});\n// {\n//   \"dashboard\": {\n//     \"__typename\": \"Dashboard\",\n//     \"id\": 1,\n//     \"name\": \"My Dashboard\"\n//   }\n// }\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client Core Package (JavaScript)\nDESCRIPTION: This code shows how to install the @apollo/client NPM package, which includes all core Apollo Client features as well as deprecated React Apollo render prop components. No additional dependencies are necessary. Run this command in your project directory to download the package and add it to your package.json file.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/components.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client\n\n```\n\n----------------------------------------\n\nTITLE: Installing Apollo Client (bash)\nDESCRIPTION: Installs the @apollo/client package via npm, which is necessary for configuring Apollo Client and using persisted queries or APQ features in a JavaScript application.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/link/persisted-queries.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @apollo/client\n```\n\n----------------------------------------\n\nTITLE: Displaying Query Variables\nDESCRIPTION: This snippet demonstrates how to access and display the variables used in a GraphQL query. It retrieves the variables from the `data.variables` property provided by the `graphql()` HOC and displays them as a JSON string. It expects `data.variables` to be an object representing the query variables.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyComponent({ data: { variables } }) {\n  return (\n    <div>\n      Query executed with the following variables:\n      <code>{JSON.stringify(variables)}</code>\n    </div>\n  );\n}\n\nexport default graphql(gql`query MyComponentQuery  { ... }`)(MyComponent);\n```\n\n----------------------------------------\n\nTITLE: Customizing Global Cache ID Generation with dataIdFromObject\nDESCRIPTION: Legacy approach from Apollo Client 2.x that allows customizing cache ID generation globally using a dataIdFromObject function. It demonstrates type-specific ID generation with a fallback to the default behavior.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/caching/cache-configuration.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defaultDataIdFromObject } from '@apollo/client';\n\nconst cache = new InMemoryCache({\n  dataIdFromObject(responseObject) {\n    switch (responseObject.__typename) {\n      case 'Product': return `Product:${responseObject.upc}`;\n      case 'Person': return `Person:${responseObject.name}:${responseObject.email}`;\n      default: return defaultDataIdFromObject(responseObject);\n    }\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Data from Data Prop\nDESCRIPTION: This snippet demonstrates how to access specific query results from the `data` prop. The `data` object contains properties corresponding to the fields defined in your GraphQL query. This snippet shows accessing data from `viewer` and `todos` fields, assuming a query named `ViewerAndTodos` returns those fields.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/api/react/hoc.mdx#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nrender() {\n  const { data } = this.props;\n\n  console.log(data.viewer); // <- The data returned by your query for `viewer`.\n  console.log(data.todos); // <- The data returned by your query for `todos`.\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom GraphQL Tag for Codemod (Shell)\nDESCRIPTION: This command shows how to use the `--tag` flag with `jscodeshift` to apply the codemod to GraphQL template literals with a custom tag name, such as `myGql`. This is necessary if the project uses non-standard tag names for defining GraphQL queries in source code.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_66\n\nLANGUAGE: shell\nCODE:\n```\nnpx jscodeshift ... --tag myGql\n```\n\n----------------------------------------\n\nTITLE: Extending Apollo Render Prop Components in TypeScript\nDESCRIPTION: Shows how to replace class-based render prop components (Query) with new functional wrapped components typed with GraphQL data and variables. Demonstrates that extending class components is no longer supported and recommends using hooks or wrapped components as alternatives.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/development-testing/static-typing.mdx#_snippet_8\n\nLANGUAGE: TSX\nCODE:\n```\nclass SomeQuery extends Query<SomeData, SomeVariables> {}\n\nexport const SomeQuery = () => (\n  <Query<SomeData, SomeVariables> query={SOME_QUERY} /* ... */>\n    {({ loading, error, data }) => { ... }}\n  </Query>\n);\n```\n\n----------------------------------------\n\nTITLE: Start Local Documentation Server (Shell)\nDESCRIPTION: Sets the environment variable `DOCS_MODE` to 'local' and runs the `start:local` npm script in the `docs` repository. This script starts a local development server which serves the documentation site, configured to use the documentation data generated from the `apollo-client` repository.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nDOCS_MODE='local' npm run start:local -- ../apollo-client\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm in Apollo Client (Shell)\nDESCRIPTION: This command installs all required npm dependencies within the cloned `apollo-client` directory, enabling codemod execution. Running this in the target directory will create a `node_modules` folder with all packages specified in `package.json`. No input parameters are required.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/docs/source/data/fragments.mdx#_snippet_64\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Verifying Apollo Client Changes Shell\nDESCRIPTION: Navigates into the src directory of the local Apollo Client checkout and appends a simple console.log statement to the index.ts file. This provides a concrete change that the watch build should detect and include in the linked distribution, allowing verification in the running fullstack tutorial application.\nSOURCE: https://github.com/apollographql/apollo-client/blob/main/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\n# ... assuming still in [apollo-client-root] from step 6\ncd src\necho \"console.log('it worked');\" >> index.ts\n```"
  }
]