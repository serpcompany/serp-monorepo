[
  {
    "owner": "celery",
    "repo": "billiard",
    "content": "TITLE: Creating and Starting a Basic Process in Python\nDESCRIPTION: A simple example demonstrating how to create and start a Process object in Python's multiprocessing module. The code creates a function that prints a greeting and then spawns a process to execute this function.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process\n\ndef f(name):\n    print('hello', name)\n\nif __name__ == '__main__':\n    p = Process(target=f, args=('bob',))\n    p.start()\n    p.join()\n```\n\n----------------------------------------\n\nTITLE: Using a Pool of Worker Processes for Parallel Execution\nDESCRIPTION: Shows how to use a Pool of worker processes to distribute tasks. The Pool class provides methods to offload tasks to worker processes in different ways, including asynchronous execution and mapping a function across an iterable.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Pool\n\ndef f(x):\n    return x*x\n\nif __name__ == '__main__':\n    pool = Pool(processes=4)               # start 4 worker processes\n    result = pool.apply_async(f, [10])     # evaluate \"f(10)\" asynchronously\n    print(result.get(timeout=1))           # prints \"100\" unless your computer is *very* slow\n    print(pool.map(f, range(10)))          # prints \"[0, 1, 4,..., 81]\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pool Usage in Python Multiprocessing\nDESCRIPTION: This example shows how to use the Pool class from the multiprocessing module. It demonstrates creating a pool of worker processes, executing functions asynchronously, using map to apply a function to multiple inputs, and using imap for iterative processing. The example also shows timeout handling with asynchronous calls.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Pool\n\ndef f(x):\n    return x*x\n\nif __name__ == '__main__':\n    pool = Pool(processes=4)              # start 4 worker processes\n\n    result = pool.apply_async(f, (10,))   # evaluate \"f(10)\" asynchronously\n    print(result.get(timeout=1))          # prints \"100\" unless your computer is *very* slow\n\n    print(pool.map(f, range(10)))         # prints \"[0, 1, 4,..., 81]\"\n\n    it = pool.imap(f, range(10))\n    print(next(it))                       # prints \"0\"\n    print(next(it))                       # prints \"1\"\n    print(it.next(timeout=1))             # prints \"4\" unless your computer is *very* slow\n\n    import time\n    result = pool.apply_async(time.sleep, (10,))\n    print(result.get(timeout=1))          # raises TimeoutError\n```\n\n----------------------------------------\n\nTITLE: Inter-Process Communication Using Queue\nDESCRIPTION: Example of using a Queue for communication between processes. The child process puts data into the queue, and the parent process retrieves it. Queues are thread and process safe mechanisms for exchanging objects.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Queue\n\ndef f(q):\n    q.put([42, None, 'hello'])\n\nif __name__ == '__main__':\n    q = Queue()\n    p = Process(target=f, args=(q,))\n    p.start()\n    print(q.get())    # prints \"[42, None, 'hello']\"\n    p.join()\n```\n\n----------------------------------------\n\nTITLE: Inter-Process Communication Using Pipe\nDESCRIPTION: Demonstrates using a Pipe for communication between processes. The Pipe function returns a pair of connection objects connected by a pipe. The child process sends data through one end, and the parent process receives it from the other end.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Pipe\n\ndef f(conn):\n    conn.send([42, None, 'hello'])\n    conn.close()\n\nif __name__ == '__main__':\n    parent_conn, child_conn = Pipe()\n    p = Process(target=f, args=(child_conn,))\n    p.start()\n    print(parent_conn.recv())   # prints \"[42, None, 'hello']\"\n    p.join()\n```\n\n----------------------------------------\n\nTITLE: Sharing State Between Processes Using Shared Memory\nDESCRIPTION: Example of using shared memory for inter-process communication with Value and Array. These shared objects are process and thread-safe and allow processes to update shared data in a controlled manner.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Value, Array\n\ndef f(n, a):\n    n.value = 3.1415927\n    for i in range(len(a)):\n        a[i] = -a[i]\n\nif __name__ == '__main__':\n    num = Value('d', 0.0)\n    arr = Array('i', range(10))\n\n    p = Process(target=f, args=(num, arr))\n    p.start()\n    p.join()\n\n    print(num.value)\n    print(arr[:])\n```\n\n----------------------------------------\n\nTITLE: Sharing State Between Processes Using Manager Objects\nDESCRIPTION: Demonstrates using a Manager to share Python objects between processes. A manager controls a server process that holds Python objects and allows other processes to manipulate them using proxies, supporting various data types like lists and dictionaries.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Manager\n\ndef f(d, l):\n    d[1] = '1'\n    d['2'] = 2\n    d[0.25] = None\n    l.reverse()\n\nif __name__ == '__main__':\n    manager = Manager()\n\n    d = manager.dict()\n    l = manager.list(range(10))\n\n    p = Process(target=f, args=(d, l))\n    p.start()\n    p.join()\n\n    print(d)\n    print(l)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Process Class Usage in Python\nDESCRIPTION: Example showing how to create, start, and terminate a Process object using the multiprocessing module. Demonstrates checking process status and handling termination signals.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> import multiprocessing, time, signal\n>>> p = multiprocessing.Process(target=time.sleep, args=(1000,))\n>>> print(p, p.is_alive())\n<Process(Process-1, initial)> False\n>>> p.start()\n>>> print(p, p.is_alive())\n<Process(Process-1, started)> True\n>>> p.terminate()\n>>> time.sleep(0.1)\n>>> print(p, p.is_alive())\n<Process(Process-1, stopped[SIGTERM])> False\n>>> p.exitcode == -signal.SIGTERM\nTrue\n```\n\n----------------------------------------\n\nTITLE: Process Synchronization Using Lock\nDESCRIPTION: Shows how to use a Lock to synchronize processes. The lock ensures that only one process can access a shared resource (in this case, standard output) at a time, preventing mixed outputs from different processes.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Lock\n\ndef f(l, i):\n    l.acquire()\n    print('hello world', i)\n    l.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n\n    for num in range(10):\n        Process(target=f, args=(lock, num)).start()\n```\n\n----------------------------------------\n\nTITLE: Proper Resource Passing in Python Multiprocessing\nDESCRIPTION: Demonstrates the correct way to pass shared resources to child processes as arguments, ensuring cross-platform compatibility and proper resource management.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Lock\n\ndef f(l):\n    ... do something using \"l\" ...\n\nif __name__ == '__main__':\n   lock = Lock()\n   for i in range(10):\n        Process(target=f, args=(lock,)).start()\n```\n\n----------------------------------------\n\nTITLE: Windows Entry Point Protection in Python Multiprocessing\nDESCRIPTION: Demonstrates how to properly structure a multiprocessing program's entry point for Windows compatibility using __name__ == '__main__' guard.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, freeze_support\n\ndef foo():\n    print('hello')\n\nif __name__ == '__main__':\n    freeze_support()\n    p = Process(target=foo)\n    p.start()\n```\n\n----------------------------------------\n\nTITLE: Using Pipe Connections for Inter-Process Communication in Python\nDESCRIPTION: This example demonstrates how to use Connection objects created by Pipe() to send and receive various types of data between processes, including Python objects, bytes, and array buffers.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> from multiprocessing import Pipe\n>>> a, b = Pipe()\n>>> a.send([1, 'hello', None])\n>>> b.recv()\n[1, 'hello', None]\n>>> b.send_bytes(b'thank you')\n>>> a.recv_bytes()\nb'thank you'\n>>> import array\n>>> arr1 = array.array('i', range(5))\n>>> arr2 = array.array('i', [0] * 10)\n>>> a.send_bytes(arr1)\n>>> count = b.recv_bytes_into(arr2)\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Remote Manager in Python\nDESCRIPTION: Example demonstrating how to connect a local manager object to a remote manager process. This allows a process to access shared objects managed by a separate manager process.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> from multiprocessing.managers import BaseManager\n>>> m = BaseManager(address=('127.0.0.1', 5000), authkey='abc')\n>>> m.connect()\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic Manager Server in Python\nDESCRIPTION: Example showing how to create and start a server for a BaseManager that listens on a specific address with authentication. The server process will handle connections from other processes.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from multiprocessing.managers import BaseManager\n>>> manager = BaseManager(address=('', 50000), authkey='abc')\n>>> server = manager.get_server()\n>>> server.serve_forever()\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Manager Class in Python Multiprocessing\nDESCRIPTION: Example showing how to create a custom manager by subclassing BaseManager and registering custom types. This allows sharing specialized objects between processes with customized functionality.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing.managers import BaseManager\n\nclass MathsClass:\n    def add(self, x, y):\n        return x + y\n    def mul(self, x, y):\n        return x * y\n\nclass MyManager(BaseManager):\n    pass\n\nMyManager.register('Maths', MathsClass)\n\nif __name__ == '__main__':\n    manager = MyManager()\n    manager.start()\n    maths = manager.Maths()\n```\n\n----------------------------------------\n\nTITLE: Using Multiprocessing Wait for Multiple Processes in Python\nDESCRIPTION: This code demonstrates how to use multiprocessing.connection.wait to handle messages from multiple processes simultaneously. It creates multiple processes, each sending messages through a pipe.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nimport time, random\nfrom multiprocessing import Process, Pipe, current_process\nfrom multiprocessing.connection import wait\n\ndef foo(w):\n    for i in range(10):\n        w.send((i, current_process().name))\n    w.close()\n\nif __name__ == '__main__':\n    readers = []\n\n    for i in range(4):\n        r, w = Pipe(duplex=False)\n        readers.append(r)\n        p = Process(target=foo, args=(w,))\n        p.start()\n        # We close the writable end of the pipe now to be sure that\n        # p is the only process which owns a handle for it.  This\n        # ensures that when p closes its handle for the writable end,\n        # wait() will promptly report the readable end as being ready.\n        w.close()\n\n    while readers:\n        for r in wait(readers):\n            try:\n                msg = r.recv()\n            except EOFError:\n                readers.remove(r)\n            else:\n                print(msg)\n```\n\n----------------------------------------\n\nTITLE: Fork-safe Cache Implementation in Python\nDESCRIPTION: Shows how to implement a fork-safe cache by tracking process IDs and resetting the cache when the process ID changes.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n@property\ndef cache(self):\n    pid = os.getpid()\n    if pid != self._pid:\n        self._pid = pid\n        self._cache = []\n    return self._cache\n```\n\n----------------------------------------\n\nTITLE: Displaying Process Information in Multiprocessing\nDESCRIPTION: An expanded example showing how to display process information including module name, parent process ID, and process ID. This demonstrates the parent-child relationship between processes created with the multiprocessing module.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process\nimport os\n\ndef info(title):\n    print(title)\n    print('module name:', __name__)\n    print('parent process:', os.getppid())\n    print('process id:', os.getpid())\n\ndef f(name):\n    info('function f')\n    print('hello', name)\n\nif __name__ == '__main__':\n    info('main line')\n    p = Process(target=f, args=('bob',))\n    p.start()\n    p.join()\n```\n\n----------------------------------------\n\nTITLE: Queue Deadlock Example in Python Multiprocessing\nDESCRIPTION: Demonstrates a deadlock scenario when joining a process before consuming its queue items. The process puts data in a queue and blocks until the queue is consumed.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Queue\n\ndef f(q):\n    q.put('X' * 1000000)\n\nif __name__ == '__main__':\n    queue = Queue()\n    p = Process(target=f, args=(queue,))\n    p.start()\n    p.join()                    # this deadlocks\n    obj = queue.get()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Process Creation with freeze_support in Python\nDESCRIPTION: This code example shows how to properly initialize a Python multiprocessing program that might be frozen into a Windows executable. The freeze_support() function must be called immediately after the main module check.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, freeze_support\n\ndef f():\n    print('hello world!')\n\nif __name__ == '__main__':\n    freeze_support()\n    Process(target=f).start()\n```\n\n----------------------------------------\n\nTITLE: Modifying Shared ctypes Objects in Child Processes\nDESCRIPTION: Example demonstrating how to create and modify shared ctypes objects across processes using Value and Array from multiprocessing.sharedctypes. The child process squares numeric values and upper-cases string values.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Lock\nfrom multiprocessing.sharedctypes import Value, Array\nfrom ctypes import Structure, c_double\n\nclass Point(Structure):\n    _fields_ = [('x', c_double), ('y', c_double)]\n\ndef modify(n, x, s, A):\n    n.value **= 2\n    x.value **= 2\n    s.value = s.value.upper()\n    for a in A:\n        a.x **= 2\n        a.y **= 2\n\nif __name__ == '__main__':\n    lock = Lock()\n\n    n = Value('i', 7)\n    x = Value(c_double, 1.0/3.0, lock=False)\n    s = Array('c', 'hello world', lock=lock)\n    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n\n    p = Process(target=modify, args=(n, x, s, A))\n    p.start()\n    p.join()\n\n    print(n.value)\n    print(x.value)\n    print(s.value)\n    print([(a.x, a.y) for a in A])\n```\n\n----------------------------------------\n\nTITLE: Working with Namespace Proxies in Python Multiprocessing\nDESCRIPTION: Example showing how to use a Namespace object from a Manager to share attributes between processes. Demonstrates the behavior of private attributes and the string representation.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> manager = multiprocessing.Manager()\n>>> Global = manager.Namespace()\n>>> Global.x = 10\n>>> Global.y = 'hello'\n>>> Global._z = 12.3    # this is an attribute of the proxy\n>>> print(Global)\nNamespace(x=10, y='hello')\n```\n\n----------------------------------------\n\nTITLE: Remote Queue Manager Server Setup\nDESCRIPTION: Implementation of a remote manager server that creates a shared queue accessible by remote clients\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing.managers import BaseManager\nimport queue\nqueue = Queue.Queue()\nclass QueueManager(BaseManager): pass\nQueueManager.register('get_queue', callable=lambda:queue)\nm = QueueManager(address=('', 50000), authkey='abracadabra')\ns = m.get_server()\ns.serve_forever()\n```\n\n----------------------------------------\n\nTITLE: Remote Queue Client Implementation\nDESCRIPTION: Client-side code for connecting to a remote queue manager and putting data into the queue\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing.managers import BaseManager\nclass QueueManager(BaseManager): pass\nQueueManager.register('get_queue')\nm = QueueManager(address=('foo.bar.org', 50000), authkey='abracadabra')\nm.connect()\nqueue = m.get_queue()\nQueue.put('hello')\n```\n\n----------------------------------------\n\nTITLE: Local Worker Process Implementation\nDESCRIPTION: Implementation of a local worker process that can access the remote queue\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Queue\nfrom multiprocessing.managers import BaseManager\nclass Worker(Process):\n    def __init__(self, q):\n        self.q = q\n        super(Worker, self).__init__()\n    def run(self):\n        self.q.put('local hello')\n\nqueue = Queue()\nw = Worker(queue)\nw.start()\nclass QueueManager(BaseManager): pass\nQueueManager.register('get_queue', callable=lambda: queue)\nm = QueueManager(address=('', 50000), authkey='abracadabra')\ns = m.get_server()\ns.serve_forever()\n```\n\n----------------------------------------\n\nTITLE: Creating a Listener Server with Authentication in Python\nDESCRIPTION: This code snippet demonstrates how to create a listener server using multiprocessing.connection.Listener with authentication. It sets up a connection, sends data to the client, and then closes the connection.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing.connection import Listener\nfrom array import array\n\naddress = ('localhost', 6000)     # family is deduced to be 'AF_INET'\nlistener = Listener(address, authkey=b'secret password')\n\nconn = listener.accept()\nprint('connection accepted from', listener.last_accepted)\n\nconn.send([2.25, None, 'junk', float])\n\nconn.send_bytes(b'hello')\n\nconn.send_bytes(array('i', [42, 1729]))\n\nconn.close()\nlistener.close()\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Multiprocessing Server and Receiving Data in Python\nDESCRIPTION: This code snippet shows how to connect to a multiprocessing server using Client, receive data sent by the server, and handle different types of data including arrays.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing.connection import Client\nfrom array import array\n\naddress = ('localhost', 6000)\nconn = Client(address, authkey=b'secret password')\n\nprint(conn.recv())                  # => [2.25, None, 'junk', float]\n\nprint(conn.recv_bytes())            # => 'hello'\n\narr = array('i', [0, 0, 0, 0, 0])\nprint(conn.recv_bytes_into(arr))    # => 8\nprint(arr)                          # => array('i', [42, 1729, 0, 0, 0])\n\nconn.close()\n```\n\n----------------------------------------\n\nTITLE: Resource Sharing Anti-pattern in Python Multiprocessing\nDESCRIPTION: Shows incorrect way of sharing resources between processes using global variables, which may cause issues especially on Windows.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Process, Lock\n\ndef f():\n    ... do something using \"lock\" ...\n\nif __name__ == '__main__':\n   lock = Lock()\n   for i in range(10):\n        Process(target=f).start()\n```\n\n----------------------------------------\n\nTITLE: Comparing RawArray Creation Syntaxes in Python Multiprocessing\nDESCRIPTION: Different syntaxes for creating shared memory arrays using RawArray from the multiprocessing.sharedctypes module. Shows equivalent ways to create arrays with specific data types.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n(c_short * 7)()      RawArray(c_short, 7)       RawArray('h', 7)\n(c_int * 3)(9, 2, 8) RawArray(c_int, (9, 2, 8)) RawArray('i', (9, 2, 8))\n```\n\n----------------------------------------\n\nTITLE: Updating Mutable Values in Manager Proxies\nDESCRIPTION: Example demonstrating how to properly update mutable values in manager proxies. Shows that reassignment is necessary to notify the proxy of changes made to mutable objects like dictionaries within a list.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# create a list proxy and append a mutable object (a dictionary)\nlproxy = manager.list()\nlproxy.append({})\n# now mutate the dictionary\nd = lproxy[0]\nd['a'] = 1\nd['b'] = 2\n# at this point, the changes to d are not yet synced, but by\n# reassigning the dictionary, the proxy is notified of the change\nlproxy[0] = d\n```\n\n----------------------------------------\n\nTITLE: Proxy Object Usage Example\nDESCRIPTION: Demonstration of using proxy objects with a manager to create and manipulate shared lists\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom multiprocessing import Manager\nmanager = Manager()\nl = manager.list([i*i for i in range(10)])\nprint(l)\nprint(repr(l))\nl[4]\nl[2:5]\n```\n\n----------------------------------------\n\nTITLE: Setting Python Interpreter Path for Child Processes\nDESCRIPTION: This code snippet demonstrates how to set the Python interpreter path for child processes in embedded applications, particularly for Windows environments.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nset_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Array Manipulation in Python\nDESCRIPTION: A code example showing array operations with assertions about size and content. The example demonstrates how array data is stored and accessed.\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> assert count == len(arr1) * arr1.itemsize\n>>> arr2\narray('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: Lists required Python packages with minimum version requirements for the billiard project. Includes pytest 6.2 or higher for testing and psutil 5.9.0 or higher for system resource monitoring.\nSOURCE: https://github.com/celery/billiard/blob/main/requirements/test.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npytest>=6.2\npsutil>=5.9.0\n```\n\n----------------------------------------\n\nTITLE: Defining Development Dependencies for Billiard Project\nDESCRIPTION: This snippet lists the development dependencies required for the Billiard project with their minimum versions. It includes setuptools and wheel for packaging, flake8 for code linting, and tox for automated testing.\nSOURCE: https://github.com/celery/billiard/blob/main/requirements/pkgutils.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsetuptools>=59.2.0\nwheel>=0.37.0\nflake8>=4.0.1\ntox>=3.24.4\n```\n\n----------------------------------------\n\nTITLE: Installing Multiprocessing Package via Setup.py\nDESCRIPTION: The standard installation command for installing the multiprocessing package from source using Python's setup.py mechanism. This works when you have the correct C compiler configuration.\nSOURCE: https://github.com/celery/billiard/blob/main/INSTALL.txt#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython setup.py install\n```\n\n----------------------------------------\n\nTITLE: Basic Math Operations Example\nDESCRIPTION: Simple demonstration of math operations using print statements\nSOURCE: https://github.com/celery/billiard/blob/main/Doc/library/multiprocessing.rst#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nprint(maths.add(4, 3))         # prints 7\nprint(maths.mul(7, 8))         # prints 56\n```\n\n----------------------------------------\n\nTITLE: Specifying pytest-cov Dependency for the Billiard Project\nDESCRIPTION: This snippet specifies pytest-cov as a dependency or requirement for the project. The pytest-cov package is a plugin for pytest that provides code coverage reporting functionality.\nSOURCE: https://github.com/celery/billiard/blob/main/requirements/test-ci.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npytest-cov\n```\n\n----------------------------------------\n\nTITLE: Setup.py Configuration Section for Unix Platforms\nDESCRIPTION: The configuration section in setup.py that may need modification on Unix platforms. It defines compilation macros and required libraries for Unix-specific features.\nSOURCE: https://github.com/celery/billiard/blob/main/INSTALL.txt#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nelse:\n    macros = dict(\n        HAVE_SEM_OPEN=1,\n        HAVE_SEM_TIMEDWAIT=1,\n        HAVE_FD_TRANSFER=1\n        )\n    libraries = ['rt']\n```\n\n----------------------------------------\n\nTITLE: Installing Sphinx and Building Documentation\nDESCRIPTION: Commands to install Sphinx documentation generator using easy_install and build the documentation using the Makefile. Requires Sphinx 0.5+ and setuptools 0.6c9+.\nSOURCE: https://github.com/celery/billiard/blob/main/INSTALL.txt#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo easy_install-2.5 \"Sphinx>=0.5\"\nmake doc\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Python 2.5\nDESCRIPTION: Command to run the multiprocessing test suite using Python 2.5. It utilizes Python's module execution functionality.\nSOURCE: https://github.com/celery/billiard/blob/main/INSTALL.txt#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython -m multiprocessing.tests\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Python 2.4\nDESCRIPTION: Command to run the multiprocessing test suite using Python 2.4, which requires a different approach since the module execution mechanism differs in this version.\nSOURCE: https://github.com/celery/billiard/blob/main/INSTALL.txt#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython -c \"from multiprocessing.tests import main; main()\"\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Makefile using Python 2.5\nDESCRIPTION: Command to run the unit tests using the provided Makefile with the default Python 2.5. This executes test scripts using both processes and threads.\nSOURCE: https://github.com/celery/billiard/blob/main/INSTALL.txt#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake test\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Makefile using Specific Python Version\nDESCRIPTION: Command to run the unit tests using the provided Makefile with a specified Python version (example shows Python 2.4).\nSOURCE: https://github.com/celery/billiard/blob/main/INSTALL.txt#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake test PYTHON=python2.4\n```"
  }
]