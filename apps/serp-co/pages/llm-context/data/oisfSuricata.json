[
  {
    "owner": "oisf",
    "repo": "suricata",
    "content": "TITLE: Suricata Flow Direction & Stream Matching\nDESCRIPTION: This example shows how to combine multiple flow options to match specific traffic directions, connection states, and stream characteristics. It uses `flow:to_server, established, only_stream` to match packets from the client to the server in established connections that have been reassembled by the stream engine.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nflow:to_server, established, only_stream\n```\n\n----------------------------------------\n\nTITLE: IPREP Rule Example\nDESCRIPTION: This Suricata rule demonstrates the usage of the 'iprep' keyword to detect communication with a CnC server. It checks the destination IP's reputation score and alerts if it exceeds 30 in the CnC category.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ip-reputation-rules.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip $HOME_NET any -> any any (msg:\"IPREP internal host talking to CnC server\"; flow:to_server; iprep:dst,CnC,>,30; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring User and Group for Suricata Process\nDESCRIPTION: This snippet configures the user and group that Suricata will run as. This is important for security reasons to limit the privileges of the Suricata process. The example sets the user and group to 'suri'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nrun-as:\n  user: suri\n  group: suri\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Example\nDESCRIPTION: This example demonstrates the basic structure of a Suricata rule, including the action (alert), header (protocol, source/destination IP and port), and rule options (message, flow, content matching, etc.). It shows how these components are combined to define a specific network traffic pattern to detect.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Drop SSH Traffic without Alert\nDESCRIPTION: This Suricata rule drops inbound SSH traffic without generating an alert. The 'drop' action blocks the traffic, and the 'noalert' keyword prevents the rule from creating an alert. This is useful in IPS deployments.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\ndrop tcp any any -> any 22 (msg:\"Drop inbound SSH traffic\"; noalert; sid: 3)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Request Example\nDESCRIPTION: This Suricata rule demonstrates how to detect a specific HTTP request using keywords like `http.method`, `http.uri`, `http.protocol`, `http.user_agent`, and `http.host`. It checks for a GET request to `/index.html` with specific values for User-Agent and Host headers. The `bsize` option specifies the buffer size for each content match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Request Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.method; \\\n  content:\"GET\"; http.uri; content:\"/index.html\"; bsize:11; http.protocol; \\\n  content:\"HTTP/1.1\"; bsize:8; http.user_agent; content:\"Mozilla/5.0\"; bsize:11; \\\n  http.host; content:\"suricata.io\"; bsize:11;` classtype:bad-unknown; sid:25; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Threshold Rule Example (threshold type)\nDESCRIPTION: This example demonstrates the use of the 'threshold' type to generate an alert if there are 10 or more inbound emails from the same server within one minute. It tracks by source IP and defines a count of 10 within 60 seconds.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/thresholding.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tcp !$HOME_NET any -> $HOME_NET 25 (msg:\"ET POLICY Inbound Frequent Emails - Possible Spambot Inbound\";\n  flow:established; content:\"mail from|3a|\"; nocase;\n  :example-rule-emphasis:`threshold: type threshold, track by_src, count 10, seconds 60;`\n  reference:url,doc.emergingthreats.net/2002087; classtype:misc-activity; sid:2002087; rev:10;)\n```\n\n----------------------------------------\n\nTITLE: Setting Runmode in Suricata YAML\nDESCRIPTION: This snippet configures the runmode for Suricata. The runmode affects how Suricata processes network traffic. Available runmodes can be listed using the '--list-runmodes' command line option. This example sets the runmode to 'autofp'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nrunmode: autofp\n```\n\n----------------------------------------\n\nTITLE: Defining datasets in Suricata configuration\nDESCRIPTION: This snippet demonstrates how to define datasets in the main Suricata configuration file. It shows examples for tracking unique string and SHA256 values, including specifying the data type and state file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\ndatasets:\n  ua-seen:\n    type: string\n    state: ua-seen.lst\n  dns-sha256-seen:\n    type: sha256\n    state: dns-sha256-seen.lst\n```\n\n----------------------------------------\n\nTITLE: Configure TLS/SSL Parser\nDESCRIPTION: This configuration enables the TLS/SSL parser in Suricata and specifies the detection port (default TCP/443). It also shows the `encryption-handling` option, which determines how Suricata handles encrypted traffic after the TLS handshake. The options are 'track-only', 'bypass', and 'full', influencing inspection and flow processing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_43\n\nLANGUAGE: yaml\nCODE:\n```\ntls:\n  enabled: yes\n  detection-ports:\n    dp: 443\n\n  # What to do when the encrypted communications start:\n  # - track-only: keep tracking TLS session, check for protocol anomalies,\n  #            inspect tls_* keywords. Disables inspection of unmodified\n  #            'content' signatures.\n  # - bypass:  stop processing this flow as much as possible. No further\n  #            TLS parsing and inspection. Offload flow bypass to kernel\n  #            or hardware if possible.\n  # - full:    keep tracking and inspection as normal. Unmodified content\n  #            keyword signatures are inspected as well.\n  #\n  # For the best performance, select 'bypass'.\n  #\n  #encryption-handling: track-only\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Status Code Example\nDESCRIPTION: This Suricata rule demonstrates how to detect a specific HTTP response based on the status code and content type. It checks for a 200 OK response with a content type of `text/html`. The `bsize` option is used to specify buffer sizes. The rule uses the `http.stat_code` and `http.content_type` keywords.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Stat Code Example\"; \\\n  flow:established,to_client; :example-rule-options:`http.stat_code; \\\n  content:\"200\"; bsize:8; http.content_type; content:\"text/html\"; bsize:9;` \\\n  classtype:bad-unknown; sid:30; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Installing from Package Repositories (CentOS, RHEL, AlmaLinux, RockyLinux, etc Version 8+)\nDESCRIPTION: This command sequence installs Suricata using dnf on CentOS, RHEL, AlmaLinux, RockyLinux, and other similar distributions (version 8+). It enables the EPEL repository, the Suricata COPR repository, and then installs the Suricata package. Requires sudo.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_3\n\nLANGUAGE: none\nCODE:\n```\nsudo dnf install epel-release dnf-plugins-core\nsudo dnf copr enable @oisf/suricata-7.0\nsudo dnf install suricata\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Negated Content Example\nDESCRIPTION: This example shows a Suricata rule alerting on outdated Firefox versions on Windows. It includes 'content' keywords for matching the User-Agent string, Firefox version, and a negated content check to exclude a specific Firefox version (3.6.13).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_1\n\nLANGUAGE: suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"Outdated Firefox on\\n  Windows\"; content:\"User-Agent|3A| Mozilla/5.0 |28|Windows|3B| \";\n  content:\"Firefox/3.\"; distance:0; content:!\"Firefox/3.6.13\";\n  distance:-10; sid:9000000; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Multiple Logger Instances Configuration for EVE JSON\nDESCRIPTION: This snippet demonstrates how to configure multiple EVE logger instances to output different types of events to different files. Each instance can be configured with its own types of events to log (alert, drop, http, dns, tls). With the exception of 'drop', you can specify multiples of the same logger type, however, 'drop' can only be used once.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_9\n\nLANGUAGE: Config\nCODE:\n```\n  outputs:\n    - eve-log:\n        enabled: yes\n        type: file\n        filename: eve-ips.json\n        types:\n          - alert\n          - drop\n\n    - eve-log:\n        enabled: yes\n        type: file\n        filename: eve-nsm.json\n        types:\n          - http\n          - dns\n          - tls\n```\n\n----------------------------------------\n\nTITLE: Matching TCP Flags with Modifiers in Suricata\nDESCRIPTION: This example shows how to match specific TCP flags using modifiers (+, *, !) in Suricata rules. The rule checks for a SYN flag, regardless of the values of reserved bits using the ``tcp.flags:S,CE;`` syntax. This is useful for detecting session initiation packets, such as ECN, where a SYN packet is sent with CWR and ECE flags set.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"Example tcp.flags sig\";\n   :example-rule-emphasis:`tcp.flags:FPU,CE;` classtype:misc-activity; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching DNS queries against a blacklist in Suricata\nDESCRIPTION: This example demonstrates how to match DNS queries against a blacklist called `dns-bl` using the `dataset` keyword. The `isset` command checks if the DNS query is present in the dataset.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\ndns.query; dataset:isset,dns-bl;\n```\n\n----------------------------------------\n\nTITLE: Adding local rules path to Suricata config\nDESCRIPTION: This YAML snippet illustrates how to include a custom rules file into Suricata's configuration. The 'default-rule-path' specifies the base directory for rules, and the 'rule-files' section lists the rules files to be loaded, including 'local.rules' which must be defined by its full or relative path.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/adding-your-own-rules.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-rule-path: /usr/local/etc/suricata/rules\n\nrule-files:\n  - suricata.rules\n  - /path/to/local.rules\n```\n\n----------------------------------------\n\nTITLE: Enabling Rules in enable.conf\nDESCRIPTION: This configuration file allows you to enable rules that are disabled by default.  You can enable specific signatures by SID, entire rule files by group name, or rules matching a regex pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n2019401                   # enable signature with this sid\ngroup:emerging-icmp.rules # enable this rulefile\nre:trojan                 # enable all rules with this string\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: File SHA1 Blacklisting\nDESCRIPTION: This Suricata rule demonstrates how to use the `filesha1` keyword to match a file's SHA1 hash against a list of SHA1 checksums. The file 'sha1-blacklist' should be in the Suricata rules directory and contain a list of SHA1 hashes to block. The rule alerts if a file's SHA1 hash matches any of the entries in the blacklist file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesha1:sha1-blacklist;\n```\n\n----------------------------------------\n\nTITLE: Configuring Lua Rule Sandboxing in Suricata\nDESCRIPTION: This snippet configures the Lua rule sandboxing in Suricata. It includes options to disable Lua rules entirely, set upper bounds on memory allocations and instruction counts for Lua rules, and allow or disallow restricted Lua operations such as external packages and file I/O.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_74\n\nLANGUAGE: yaml\nCODE:\n```\nsecurity:\n  lua:\n    # Allow Lua rules. Enabled by default.\n    #allow-rules: true\n\n    # Upper bound of allocations by a Lua rule before it will fail\n    #max-bytes: 500000 \n\n    # Upper bound of lua instructions by a Lua rule before it will fail\n    #max-instructions: 500000\n\n    # Allow dangerous lua operations like external packages and file io\n    #allow-restricted-functions: false\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Flow Event Example\nDESCRIPTION: This JSON presents an example of a `flow` event type, summarizing network flow information observed by Suricata.  The data includes the timestamp, flow ID, source and destination IPs/ports, protocol, application protocol, and flow attributes such as the number of packets/bytes sent in each direction, start/end times, age, state, reason, alert status, and exception policies. TCP flags are also included.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n      \"timestamp\": \"2023-09-18T06:13:21.216460+0000\",\n      \"flow_id\": 1676750115612680,\n      \"event_type\": \"flow\",\n      \"src_ip\": \"192.168.100.237\",\n      \"src_port\": 49175,\n      \"dest_ip\": \"142.11.240.191\",\n      \"dest_port\": 35361,\n      \"proto\": \"TCP\",\n      \"app_proto\": \"http\",\n      \"flow\": {\n        \"pkts_toserver\": 3869,\n        \"pkts_toclient\": 1523,\n        \"bytes_toserver\": 3536402,\n        \"bytes_toclient\": 94102,\n        \"start\": \"2023-09-18T06:13:33.324862+0000\",\n        \"end\": \"2023-09-18T06:14:13.752399+0000\",\n        \"age\": 40,\n        \"state\": \"closed\",\n        \"reason\": \"shutdown\",\n        \"alerted\": true,\n        \"exception_policy\": [\n          {\n            \"target\": \"stream_midstream\",\n            \"policy\": \"ignore\"\n          }\n        ]\n      },\n      \"ether\": {\n        \"dest_macs\": [\n          \"52:54:00:36:3e:ff\"\n        ],\n        \"src_macs\": [\n          \"12:a9:86:6c:77:de\"\n        ]\n      },\n      \"tcp\": {\n        \"tcp_flags\": \"1e\",\n        \"tcp_flags_ts\": \"1e\",\n        \"tcp_flags_tc\": \"1a\",\n        \"syn\": true,\n        \"rst\": true,\n        \"psh\": true,\n        \"ack\": true,\n        \"state\": \"closed\",\n        \"ts_max_regions\": 1,\n        \"tc_max_regions\": 1\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Matching Traffic with Lua Script\nDESCRIPTION: The `match` function is the core of a Lua script in Suricata, responsible for analyzing the data from the registered buffers and determining if a specific pattern or condition is met. It receives a table (`args`) containing the buffer data and returns 1 if the conditions match, and 0 if they do not. In the example, it checks if the `http.request_line` starts with \"POST\" followed by a path ending in \".php\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/lua-detection.rst#_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nfunction match(args)\n    a = tostring(args[\"http.request_line\"])\n    if #a > 0 then\n        if a:find(\"^POST%s+/.*%.php%s+HTTP/1.0$\") then\n            return 1\n        end\n    end\n\n    return 0\nend\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 data with defaults - Suricata Rule\nDESCRIPTION: This rule decodes a Base64 encoded string using the `from_base64` transformation with default options and checks if the decoded output matches \"This is Suricata\".  It assumes the entire buffer is Base64 encoded, and decodes it according to RFC 4648 by default.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\ncontent: \"VGhpcyBpcyBTdXJpY2F0YQ==\"; from_base64; content:\"This is Suricata\";\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Response Header with Suricata Rule\nDESCRIPTION: This Suricata rule demonstrates how to detect a specific HTTP response header (Location) containing \"suricata.io\". It uses the `http.response_header` keyword along with a `content` modifier to search for the specified string within the response headers. The `flow` keyword specifies the traffic direction to be 'to_client'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_20\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Response Example\"; \\\nflow:established,to_client; :example-rule-options:`http.response_header; \\\ncontent:\"Location|3a 20|suricata.io\";` classtype:bad-unknown; sid:127; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Setting Default Packet Size in Suricata YAML\nDESCRIPTION: This snippet configures the default packet size that Suricata expects to process. Setting this to the common packet size on your network can improve performance. While Suricata can handle larger packets, doing so will impact performance. The default is usually 1514 bytes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-packet-size: 1514\n```\n\n----------------------------------------\n\nTITLE: Suricata byte_jump rule example\nDESCRIPTION: This example shows how to use the `byte_jump` keyword in Suricata rules to move the detection pointer to a new position in the packet payload based on the specified number of bytes and offset. It showcases various options like relative offsets and jumping from the end of the payload.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert tcp any any -> any any \\\n\t(msg:\"Byte_Jump Example\"; \\\n\tcontent:\"Alice\"; byte_jump:2,0; content:\"Bob\";)\n\n  alert tcp any any -> any any \\\n\t(msg:\"Byte_Jump Multiple Jumps\"; \\\n\tbyte_jump:2,0; byte_jump:2,0,relative; content:\"foobar\"; distance:0; within:6;)\n\n  alert tcp any any -> any any \\\n\t(msg:\"Byte_Jump From the End -8 Bytes\"; \\\n\tbyte_jump:0,0, from_end, post_offset -8; \\\n\tcontent:\"|6c 33 33 74|\"; distance:0 within:4;)\n```\n\n----------------------------------------\n\nTITLE: Set Log File Permissions\nDESCRIPTION: This snippet configures the permissions for Suricata's log directory.  `mkdir -p /var/log/suricata` creates the log directory if it doesn't exist. `chown -R root:suri /var/log/suricata` changes the owner and group of the directory and its contents to root:suri. `chmod -R 775 /var/log/suricata` sets the permissions to 775, allowing the owner and group to read, write, and execute, while others can only read and execute. This allows Suricata, running as the 'suri' user, to write to the log files.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/dropping-privileges.rst#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nmkdir -p /var/log/suricata\nchown -R root:suri /var/log/suricata\nchmod -R 775 /var/log/suricata\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Request Header in Suricata\nDESCRIPTION: This Suricata rule matches on the name and value of an HTTP/1 or HTTP/2 request header. It uses the `http.request_header` keyword along with the `content` keyword to search for a specific header and its value. The rule includes options like `flow`, `classtype`, `sid`, and `rev` for defining the flow direction, classification, rule ID, and revision number, respectively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Request Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.request_header; \\\n  content:\"Host|3a 20|suricata.io\";` classtype:bad-unknown; sid:126; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Complete Lua Script Example for Suricata\nDESCRIPTION: This complete Lua script demonstrates a basic Suricata detection rule. It initializes by requesting access to the `http.request_line` buffer, then the `match` function checks if the request line matches a pattern indicative of a POST request to a PHP file, returning 1 if matched and 0 otherwise. This script highlights the structure needed for Lua-based detection in Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/lua-detection.rst#_snippet_2\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"http.request_line\"] = tostring(true)\n    return needs\nend\n\nfunction match(args)\n    a = tostring(args[\"http.request_line\"])\n    if #a > 0 then\n        if a:find(\"^POST%s+/.*%.php%s+HTTP/1.0$\") then\n            return 1\n        end\n    end\n\n    return 0\nend\n\nreturn 0\n```\n\n----------------------------------------\n\nTITLE: Getting Packet Source Port in Lua\nDESCRIPTION: Retrieves the source port of the packet as an integer, specifically for TCP, UDP, or SCTP. Returns `nil` for other protocols.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_6\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\nsource_port = p:sp()\nif source_port == 31337 then\n    return 1\nend\n```\n\n----------------------------------------\n\nTITLE: Rule Variables Configuration\nDESCRIPTION: This YAML snippet demonstrates how to configure rule variables (address and port groups) in Suricata. These variables define network address ranges and port lists that rules can use to filter traffic. Using `any` indicates all addresses or ports.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_64\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  address-groups:\n    HOME_NET: \"[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]\"        #By using [], it is possible to set\n                                                                 #complicated variables.\n    EXTERNAL_NET: any\n    HTTP_SERVERS: \"$HOME_NET\"                                    #The $-sign tells that what follows is\n                                                                 #a variable.\n    SMTP_SERVERS: \"$HOME_NET\"\n    SQL_SERVERS: \"$HOME_NET\"\n    DNS_SERVERS: \"$HOME_NET\"\n    TELNET_SERVERS: \"$HOME_NET\"\n    AIM_SERVERS: any\n```\n\nLANGUAGE: yaml\nCODE:\n```\nport-groups:\n  HTTP_PORTS: \"80\"\n  SHELLCODE_PORTS: \"!80\"\n  ORACLE_PORTS: 1521\n  SSH_PORTS: 22\n  SIP_PORTS: \"[5060, 5061]\"\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Application Protocol Example\nDESCRIPTION: This JSON shows an `app_proto` field in EVE, which indicates the application layer protocol detected by Suricata.  When an application layer protocol is detected, the common section includes the `app_proto` field. This field can be used to filter events based on the detected protocol.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_8\n\nLANGUAGE: JSON\nCODE:\n```\n\"app_proto\": \"http\"\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Parser (libhtp)\nDESCRIPTION: This snippet illustrates the YAML configuration for the HTTP parser (libhtp) in Suricata. It defines the default personality, request/response body limits, and server-specific configurations based on IP/network addresses. Server personalities affect how Suricata handles HTTP anomalies.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_37\n\nLANGUAGE: yaml\nCODE:\n```\nlibhtp:\n\n  default-config:\n    personality: IDS\n    request-body-limit: 3072\n    response-body-limit: 3072\n\n  server-config:\n     - apache:\n         address: [192.168.1.0/24, 127.0.0.0/8, \"::1\"]\n         personality: Apache_2_2\n         request-body-limit: 0\n         response-body-limit: 0\n\n     - iis7:\n         address:\n           - 192.168.0.0/24\n           - 192.168.10.0/24\n         personality: IIS_7_0\n         request-body-limit: 4096\n         response-body-limit: 8192\n```\n\n----------------------------------------\n\nTITLE: Configuring Packet Profiling in Suricata\nDESCRIPTION: This snippet shows how to configure packet profiling in Suricata, including enabling profiling, setting the output filename, enabling appending to the file, and configuring CSV output. Packet profiling requires Suricata to be compiled with `--enable-profiling`. The filename option specifies the file where packet profiling information is stored.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_69\n\nLANGUAGE: yaml\nCODE:\n```\npackets:\n\n  # Profiling can be disabled here, but it will still have a\n  # performance impact if compiled in.\n\n\n  enabled: yes                                  #this option is enabled by default\n  filename: packet_stats.log                    #name of the file in which packet profiling information will be\n                                                #stored.\n  append: yes                                   #If set to yes, new packet profiling information will be added to the\n                                                #information that was saved last in the file.\n\n  # per packet csv output\n  csv:\n\n    # Output can be disabled here, but it will still have a\n    # performance impact if compiled in.\n\n    enabled: no                                #the sending of packet output to a csv-file is by default disabled.\n    filename: packet_stats.csv                 #name of the file in which csv packet profiling information will be\n                                               #stored\n```\n\n----------------------------------------\n\nTITLE: Matching SIP From Header in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match the SIP From header in a Suricata rule. The `sip.from` keyword is used to inspect the From header field. The `content` option should contain the value of the From header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.from; content:\"user\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Thresholding Settings in Suricata (YAML)\nDESCRIPTION: This snippet shows how to configure thresholding settings in Suricata, including hash-size and memcap. It controls the size of the hash table used for tracking thresholds (by_src, by_dst, by_both).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\n  detect:\n    thresholds:\n      hash-size: 16384\n      memcap: 16mb\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Direction Example\nDESCRIPTION: This example illustrates the directionality in Suricata rules, where '->' specifies traffic from the source to the destination.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Anomaly Event Example\nDESCRIPTION: This example shows the structure of an 'anomaly' event in Suricata's Eve JSON output. It includes fields such as timestamp, pcap_cnt, event_type, src_ip, src_port, dest_ip, dest_port, proto, packet, packet_info, and anomaly. The anomaly object contains the type of anomaly and the event that triggered it.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"anomaly\": {\n    \"type\": \"decode\",\n    \"event\": \"decoder.icmpv4.unknown_type\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"anomaly\": {\n    \"type\": \"decode\",\n    \"event\": \"decoder.udp.pkt_too_small\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"anomaly\": {\n    \"type\": \"decode\",\n    \"event\": \"decoder.ipv4.wrong_ip_version\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"anomaly\": {\n    \"type\": \"stream\",\n    \"event\": \"stream.pkt_invalid_timestamp\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"timestamp\": \"1969-12-31T16:04:21.000000-0800\",\n  \"pcap_cnt\": 9262,\n  \"event_type\": \"anomaly\",\n  \"src_ip\": \"208.21.2.184\",\n  \"src_port\": 0,\n  \"dest_ip\": \"10.1.1.99\",\n  \"dest_port\": 0,\n  \"proto\": \"UDP\",\n  \"packet\": \"////////AQEBAQEBCABFAAA8xZ5AAP8R1+DQFQK4CgE=\",\n  \"packet_info\": {\n    \"linktype\": 1\n  },\n  \"anomaly\": {\n    \"type\": \"decode\",\n    \"event\": \"decoder.udp.pkt_too_small\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"timestamp\": \"2016-01-11T05:10:54.612110-0800\",\n  \"flow_id\": 412547343494194,\n  \"pcap_cnt\": 1391293,\n  \"event_type\": \"anomaly\",\n  \"src_ip\": \"192.168.122.149\",\n  \"src_port\": 49324,\n  \"dest_ip\": \"69.195.71.174\",\n  \"dest_port\": 443,\n  \"proto\": \"TCP\",\n  \"app_proto\": \"tls\",\n  \"anomaly\": {\n    \"type\": \"applayer\",\n    \"event\": \"APPLAYER_DETECT_PROTOCOL_ONLY_ONE_DIRECTION\",\n    \"layer\": \"proto_detect\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"timestamp\": \"2016-01-11T05:10:52.828802-0800\",\n  \"flow_id\": 201217772575257,\n  \"pcap_cnt\": 1391281,\n  \"event_type\": \"anomaly\",\n  \"src_ip\": \"192.168.122.149\",\n  \"src_port\": 49323,\n  \"dest_ip\": \"69.195.71.174\",\n  \"dest_port\": 443,\n  \"proto\": \"TCP\",\n  \"tx_id\": 0,\n  \"app_proto\": \"tls\",\n  \"anomaly\": {\n    \"type\": \"applayer\",\n    \"event\": \"INVALID_RECORD_TYPE\",\n    \"layer\": \"proto_parser\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: LDAP Bind Request Alert Rule with Operation Name\nDESCRIPTION: This Suricata rule alerts when an LDAP bind request operation is detected. It uses the `ldap.request.operation` keyword with the operation name `bind_request` to identify the bind request.  The `msg` option provides a descriptive message for the alert.  This demonstrates using the name instead of the code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP bind request\"; :example-rule-emphasis:`ldap.request.operation:bind_request;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: NFtables: Forward all packets to Suricata\nDESCRIPTION: This nftables command adds a rule to the 'IPS' chain of the 'filter' table to queue all packets to Netfilter queue for processing by Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnft> add rule filter IPS queue\n```\n\n----------------------------------------\n\nTITLE: DPDK Configuration - YAML\nDESCRIPTION: This YAML snippet demonstrates the DPDK configuration within Suricata. It includes settings for eal-params, which are passed to the DPDK Environment Abstraction Layer (EAL), and interface configurations, which specify how Suricata interacts with network interfaces using DPDK.  Important parameters include `proc-type`, `allow`, `interface`, `threads`, `promisc`, and checksum related options.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_49\n\nLANGUAGE: yaml\nCODE:\n```\n    dpdk:\n      eal-params:\n        proc-type: primary\n        allow: [\"0000:3b:00.0\", \"0000:3b:00.1\"]\n      interfaces:\n        - interface: 0000:3b:00.0\n          threads: auto\n          promisc: true\n          multicast: true\n          checksum-checks: true\n          checksum-checks-offload: true\n          vlan-strip-offload: true\n          linkup-timeout: 10\n          mtu: 1500\n          mempool-size: auto\n          mempool-cache-size: auto\n          rx-descriptors: auto\n          tx-descriptors: auto\n          copy-mode: none\n          copy-iface: none # or PCIe address of the second interface\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule File Configuration\nDESCRIPTION: This YAML configuration shows how to specify the default rule path and list of rule files for Suricata. The `default-rule-path` specifies the directory where Suricata will look for rules, and the `rule-files` list specifies which rule files to load.  Absolute paths or base names relative to the default rule path can be used.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_62\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-rule-path: /var/lib/suricata/rules\nrule-files:\n  - suricata.rules\n```\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-rule-path: /var/lib/suricata/rules\nrule-files:\n  - suricata.rules\n  - /etc/suricata/rules/custom.rules\n```\n\n----------------------------------------\n\nTITLE: Enabling Statistics in Suricata YAML\nDESCRIPTION: This snippet shows how to enable engine statistics logging in Suricata. Statistics include packet counters, memory usage, and other performance metrics. A text log (stats.log) and an EVE record type ('stats') are enabled by default.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n# global stats configuration\nstats:\n  enabled: yes\n```\n\n----------------------------------------\n\nTITLE: Example Suricata Rule\nDESCRIPTION: This is an example Suricata rule that alerts on HTTP traffic containing the word \"Scarlett\" (case-insensitive). It assigns a message, classification, SID, and revision to the alert.  The rule triggers if the HTTP request body contains the string \"Scarlett\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/adding-your-own-rules.rst#_snippet_5\n\nLANGUAGE: suricata\nCODE:\n```\nalert http any any -> any any (msg:\"Do not read gossip during work\";\ncontent:\"Scarlett\"; nocase; classtype:policy-violation; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Publish Message with PCRE\nDESCRIPTION: This example demonstrates matching the payload of a MQTT PUBLISH message using the `mqtt.publish.message` keyword combined with a PCRE. It requires the message type to be PUBLISH and matches payloads containing \"uid=[0-9]+\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.type:PUBLISH; mqtt.publish.message; pcre:\"/uid=[0-9]+/;\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Port Example\nDESCRIPTION: This example shows how to specify source and destination ports in a Suricata rule.  In this example, 'any' represents all ports.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching JA3 hash in Suricata rule\nDESCRIPTION: This example shows how to create a Suricata rule to match a specific JA3 hash. The `ja3.hash` keyword is used to specify that the content should be matched against the JA3 hash of the TLS client.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ja-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tls any any -> any any (msg:\"match JA3 hash\"; \\\n      ja3.hash; content:\"e7eca2baf4458d095b7f45da28c16c34\"; \\\n      sid:100001;)\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Header Contents\nDESCRIPTION: These Suricata rules demonstrate matching on normalized HTTP header contents.  They use the `http.header` keyword to detect specific user-agent and host headers in HTTP requests. The content keyword includes hexadecimal representation of special characters. The flow keyword defines traffic direction.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_33\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Example 1\"; \\\n  flow:established,to_server; :example-rule-options:`http.header; \\\n  content:\"User-Agent|3a 20|Mozilla/5.0|0d 0a|;\";` classtype:bad-unknown; \\\n  sid:70; rev:1;)\n\n  alert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Example 2\"; \\\n  flow:established,to_server; :example-rule-options:`http.header; \\\n  content:\"Host|3a 20|suricata.io|0d 0a|;\";` classtype:bad-unknown; \\\n  sid:71; rev:1;)\n\n  alert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Example 3\"; \\\n  flow:established,to_server; :example-rule-options:`http.header; \\\n  content:\"User-Agent|3a 20|Mozilla/5.0|0d 0a|;\"; startswith; \\\n  content:\"Host|3a 20|suricata.io|0d 0a|;\";` classtype:bad-unknown; \\\n  sid:72; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata rule detecting unique TLDs\nDESCRIPTION: This example shows a rule that detects unique top-level domains (TLDs) by extracting them from DNS queries and adding them to the `dns-tld-seen` dataset.  It uses `pcrexform` to extract the TLD.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns $HOME_NET any -> any any (msg:\"LOCAL DNS unique TLD\"; dns.query; pcrexform:\".([^\\\\.]+)$\"; dataset:set,dns-tld-seen, type string, state dns-tld-seen.csv; sid:8000002; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configure SMB Resource Limits\nDESCRIPTION: This snippet showcases how to set resource limits for the SMB parser in Suricata, controlling maximum read and write sizes, as well as queue sizes and counts for out-of-order data chunks. These limits help prevent resource exhaustion and improve performance. The values are in bytes, with 'mb' indicating megabytes. The count relates to the number of data chunks that can be queued.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_41\n\nLANGUAGE: yaml\nCODE:\n```\nsmb:\n  enabled: yes\n  max-read-size: 8mb\n  max-write-size: 1mb\n\n  max-read-queue-size: 16mb\n  max-read-queue-cnt: 16\n\n  max-write-queue-size: 16mb\n  max-write-queue-cnt: 16\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Transactional HTTP Alert\nDESCRIPTION: This Suricata rule matches HTTP flows to 5.6.7.8 on port 80. It will only trigger an alert when both the HTTP URI from the request contains \"/download\" and the HTTP status code from the response contains \"200\". Requires Suricata to have both the request and response data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any => 5.6.7.8 80 (msg:\"matching both uri and status\"; sid: 1; http.uri; content: \"/download\"; http.stat_code; content: \"200\";)\n```\n\n----------------------------------------\n\nTITLE: Matching Source IP Address with Dataset\nDESCRIPTION: This Suricata rule uses the `ip.src` keyword to match the source IP address against a dataset named `badips`. The rule triggers if the source IP is found in the `badips` dataset, which is of type `ip` and loaded from the `badips.list` file. This example demonstrates how to check if an inbound traffic source IP is on a bad list.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ipaddr.rst#_snippet_0\n\nLANGUAGE: suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"Inbound bad list\"; flow:to_server; ip.src; dataset:isset,badips,type ip,load badips.list; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Enabling a suricata-update Source\nDESCRIPTION: These commands enable a specific ruleset (e.g., 'oisf/trafficid') and then update the rules.  First, `enable-source` activates the ruleset, and then `suricata-update` downloads the rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata-update enable-source oisf/trafficid\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata-update\n```\n\n----------------------------------------\n\nTITLE: Configuring Packet Alert Max in Suricata YAML\nDESCRIPTION: This snippet sets the maximum number of alerts that can be triggered for a single packet. This limits the number of alerts generated per packet and helps prevent alert flooding.  The default value is 15.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n#Define maximum number of possible alerts that can be triggered for the same\n# packet. Default is 15\npacket-alert-max: 15\n```\n\n----------------------------------------\n\nTITLE: Run Suricata with User and Group Options\nDESCRIPTION: This snippet demonstrates how to run Suricata with specific user and group privileges after startup.  The `-D` option runs Suricata in daemon mode, `-i eth0` specifies the interface to listen on, `--user=suri` sets the user to 'suri', and `--group=suri` sets the group to 'suri'.  This ensures that Suricata drops its root privileges and runs as the specified user and group after initialization.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/dropping-privileges.rst#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nsuricata -D -i eth0 --user=suri --group=suri\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP User-Agent in Suricata\nDESCRIPTION: This Suricata rule matches on the User-Agent field in HTTP request headers. It uses the `http.user_agent` keyword along with the `content` keyword to search for a specific string within the User-Agent field. The rule includes options like `flow`, `bsize`, `classtype`, `sid`, and `rev` for defining the flow direction, buffer size, classification, rule ID, and revision number, respectively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP User-Agent Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.user_agent; \\\n  content:\"Mozilla/5.0\";` bsize:11; classtype:bad-unknown; sid:90; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Modbus Data Access Matching\nDESCRIPTION: This snippet demonstrates matching Modbus requests based on data access properties using the `access` setting.  It allows matching on read/write operations, primary table access (Discretes Input, Coils, Input Registers, Holding Registers), address ranges, and written values. Comparison operators can be used with the address setting.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/modbus-keyword.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: access read\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: access write\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: access read input\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: access write coils\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: access read discretes, address <100\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: access write holding, address 500, value >200\n```\n\n----------------------------------------\n\nTITLE: Iptables NFQUEUE rule configuration\nDESCRIPTION: This iptables rule configures Netfilter Queue to send packets to Suricata. The packets are marked and skipped based on the mark to avoid loops. `$MARK` and `$MASK` are variables to be replaced with appropriate values.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_59\n\nLANGUAGE: iptables\nCODE:\n```\niptables -I FORWARD -m mark ! --mark $MARK/$MASK -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Suricata byte_extract rule examples\nDESCRIPTION: This example demonstrates how to use the `byte_extract` keyword in Suricata rules to extract bytes from a packet payload and store them in a variable. The extracted value can then be used in subsequent rule options, such as `distance` and `within`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert tcp any any -> any any \\\n\t (msg:\"Byte_Extract Example Using distance\"; \\\n\t content:\"Alice\"; byte_extract:2,0,size; content:\"Bob\"; distance:size; within:3; sid:1;)\n  alert tcp any any -> any any \\\n\t (msg:\"Byte_Extract Example Using within\"; \\\n\t flow:established,to_server; content:\"|00 FF|\"; \\\n\t byte_extract:1,0,len,relative; content:\"|5c 00|\"; distance:2; within:len; sid:2;)\n  alert tcp any any -> any any \\\n\t (msg:\"Byte_Extract Example Comparing Bytes\"; \\\n\t flow:established,to_server; content:\"|00 FF|\"; \\\n\t byte_extract:2,0,cmp_ver,relative; content:\"FooBar\"; distance:0; byte_test:2,=,cmp_ver,0; sid:3;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Stats Logging with EVE JSON\nDESCRIPTION: This snippet configures the logging of statistics counters with the EVE JSON output. It provides the option to exclude counters that have a zero value by setting `null-values` to false.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_5\n\nLANGUAGE: Config\nCODE:\n```\n    - stats:\n        # Don't log stats counters that are zero. Default: true\n        #null-values: false    # False will NOT log stats counters: 0\n```\n\n----------------------------------------\n\nTITLE: Suricata TCP Urgent Pointer Handling Configuration\nDESCRIPTION: This snippet configures how Suricata handles TCP urgent pointers during stream reassembly. The `policy` option specifies the action to take on urgent packets (drop, inline, oob, or gap), and the `oob-limit-policy` option defines the behavior when the number of out-of-band bytes exceeds the limit. This allows for controlling how Suricata deals with potential ambiguities and vulnerabilities related to TCP urgent pointers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_34\n\nLANGUAGE: yaml\nCODE:\n```\nstream:\n  reassembly:\n    urgent:\n      policy: oob              # drop, inline, oob (1 byte, see RFC 6093, 3.1), gap\n      oob-limit-policy: drop\n```\n\n----------------------------------------\n\nTITLE: BPF Capture Filter Command Line Example\nDESCRIPTION: This command-line example shows how to apply a BPF capture filter to Suricata when starting the application. The `-i` option specifies the interface, and `-v` along with the filter expression configures Suricata to only capture traffic that does not involve the host 1.2.3.4. The second example filters for tcp or udp traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/ignoring-traffic.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -i eth0 -v not host 1.2.3.4\nsuricata -i eno1 -c suricata.yaml tcp or udp\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with Unix Socket Option\nDESCRIPTION: These commands show how to start Suricata with the `--unix-socket` option to enable Unix socket communication. The first command uses the default socket filename, while the second specifies a custom socket filename. When specifying a custom socket, the complete path to the socket must be provided to `suricatasc`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/unix-socket.rst#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nsuricata -c /etc/suricata-full-sigs.yaml --unix-socket\n```\n\nLANGUAGE: Shell\nCODE:\n```\nsuricata --unix-socket=custom.socket\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Request Body in Suricata\nDESCRIPTION: This Suricata rule matches on the HTTP request body. It uses the `http.request_body` keyword along with the `content` keyword to search for a specific string within the request body. The rule includes options like `flow`, `classtype`, `sid`, and `rev` for defining the flow direction, classification, rule ID, and revision number, respectively.  The amount of the request body inspected is configured in the `libhtp` configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Request Body Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.request_body; \\\n  content:\"Suricata request body\";` classtype:bad-unknown; sid:115; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Content Example\nDESCRIPTION: This example shows a Suricata rule using the 'content' keyword to match a specific string in IRC traffic. It includes flow control, PCRE matching, a reference URL, classification, SID, and revision number. The example demonstrates a bot nick detection.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_0\n\nLANGUAGE: suricata\nCODE:\n```\ndrop tcp $HOME_NET any -> $EXTERNAL_NET any (msg:\"ET TROJAN Likely Bot Nick in IRC (USA +..)\"; flow:established,to_server; flowbits:isset,is_proto_irc; content:\"NICK \"; pcre:\"/NICK .*USA.*[0-9]{3,}/i\"; reference:url,doc.emergingthreats.net/2008124; classtype:trojan-activity; sid:2008124; rev:2;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: File MD5 Whitelisting\nDESCRIPTION: This Suricata rule example demonstrates using the `filemd5` keyword with negation (`!`) for whitelisting files based on their MD5 hash. The file 'md5-whitelist' contains a list of MD5 hashes that are considered safe. The rule will not alert if a file's MD5 hash matches an entry in this whitelist.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nfilemd5:!md5-whitelist;\n```\n\n----------------------------------------\n\nTITLE: Configuring CPU Affinity for Suricata Thread Sets\nDESCRIPTION: This snippet demonstrates how to configure CPU affinity for different thread sets (management, receive, worker, and verdict) in Suricata. It shows how to specify which CPU cores each thread set should use, the mode (balanced or exclusive), and the priority for each thread.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_27\n\nLANGUAGE: yaml\nCODE:\n```\ncpu-affinity:\n  - management-cpu-set:\n      cpu: [ 0 ]  # include only these cpus in affinity settings\n  - receive-cpu-set:\n      cpu: [ 0 ]  # include only these cpus in affinity settings\n  - worker-cpu-set:\n      cpu: [ \"all\" ]\n      mode: \"exclusive\"\n      # Use explicitly 3 threads and don't compute number by using\n      # detect-thread-ratio variable:\n      # threads: 3\n      prio:\n        low: [ 0 ]\n        medium: [ \"1-2\" ]\n        high: [ 3 ]\n        default: \"medium\"\n  - verdict-cpu-set:\n      cpu: [ 0 ]\n      prio:\n        default: \"high\"\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Configuration for SMB Protocol\nDESCRIPTION: This snippet defines Suricata rule configurations that target the SMB protocol. It includes specifications for matching content, extracting bytes, and testing byte values within the 'dce_stub_data' buffer in both 'toclient' and 'toserver' directions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n        {\n          \"name\": \"dce_stub_data\",\n          \"direction\": \"toclient\",\n          \"is_mpm\": true,\n          \"app_proto\": \"smb\",\n          \"progress\": 0,\n          \"matches\": [\n            {\n              \"name\": \"content\",\n              \"content\": {\n                \"pattern\": \"abc\",\n                \"length\": 3,\n                \"nocase\": false,\n                \"negated\": false,\n                \"starts_with\": false,\n                \"ends_with\": false,\n                \"is_mpm\": true,\n                \"no_double_inspect\": false,\n                \"fast_pattern\": false,\n                \"relative_next\": true\n              }\n            },\n            {\n              \"name\": \"byte_extract\"\n            },\n            {\n              \"name\": \"byte_test\",\n              \"byte_test\": {\n                \"nbytes\": 4,\n                \"offset\": 4,\n                \"base\": \"unset\",\n                \"flags\": [\n                  \"little_endian\"\n                ]\n              }\n            }\n          ]\n        },\n        {\n          \"name\": \"dce_stub_data\",\n          \"direction\": \"toserver\",\n          \"is_mpm\": true,\n          \"app_proto\": \"smb\",\n          \"progress\": 0,\n          \"matches\": [\n            {\n              \"name\": \"content\",\n              \"content\": {\n                \"pattern\": \"abc\",\n                \"length\": 3,\n                \"nocase\": false,\n                \"negated\": false,\n                \"starts_with\": false,\n                \"ends_with\": false,\n                \"is_mpm\": true,\n                \"no_double_inspect\": false,\n                \"fast_pattern\": false,\n                \"relative_next\": true\n              }\n            },\n            {\n              \"name\": \"byte_extract\"\n            },\n            {\n              \"name\": \"byte_test\",\n              \"byte_test\": {\n                \"nbytes\": 4,\n                \"offset\": 4,\n                \"base\": \"unset\",\n                \"flags\": [\n                  \"little_endian\"\n                ]\n              }\n            }\n          ]\n        }\n      ]\n\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: File MD5 Blacklisting\nDESCRIPTION: This Suricata rule demonstrates how to use the `filemd5` keyword to match a file's MD5 hash against a list of MD5 checksums.  The file 'md5-blacklist' should be in the Suricata rules directory and contain a list of MD5 hashes to block. The rule alerts if a file's MD5 hash matches any of the entries in the blacklist file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nfilemd5:md5-blacklist;\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Referer in Suricata\nDESCRIPTION: This Suricata rule matches on the Referer field in HTTP request headers. It uses the `http.referer` keyword along with the `content` keyword to search for a specific string within the Referer field. The rule includes other options like `flow`, `bsize`, `classtype`, `sid`, and `rev` for defining the flow direction, buffer size, classification, rule ID, and revision number, respectively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Referer Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.referer; \\\n  content:\"http|3a 2f 2f|suricata.io\";` bsize:19; classtype:bad-unknown; \\\n  sid:200; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: File SHA256 Blacklisting\nDESCRIPTION: This Suricata rule demonstrates how to use the `filesha256` keyword to match a file's SHA256 hash against a list of SHA256 checksums. The file 'sha256-blacklist' should be in the Suricata rules directory and contain a list of SHA256 hashes to block. The rule alerts if a file's SHA256 hash matches any of the entries in the blacklist file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesha256:sha256-blacklist;\n```\n\n----------------------------------------\n\nTITLE: Enabling Stacktrace on Signal in Suricata Logging\nDESCRIPTION: This snippet enables the display of diagnostic stacktraces when Suricata terminates unexpectedly due to a signal (e.g., SIGSEGV, SIGABRT). Requires `libunwind` to be available during Suricata's configuration and build process.  If enabled, a diagnostic message with the offending stacktrace is displayed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_72\n\nLANGUAGE: yaml\nCODE:\n```\nlogging:\n  # Requires libunwind to be available when Suricata is configured and built.\n  # If a signal unexpectedly terminates Suricata, displays a brief diagnostic\n  # message with the offending stacktrace if enabled.\n  #stacktrace-on-signal: on\n```\n\n----------------------------------------\n\nTITLE: RPC Keyword Example in Suricata Rule\nDESCRIPTION: This snippet shows an example of the `rpc` keyword in a Suricata rule.  It alerts on UDP traffic to port 111 with a specific RPC application number and wildcard version/procedure numbers.  The rule includes a message, reference, classtype, SID, and revision number.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert udp $EXTERNAL_NET any -> $HOME_NET 111 (msg:\"RPC portmap request yppasswdd\"; :example-rule-emphasis:`rpc:100009,*,*;` reference:bugtraq,2763; classtype:rpc-portmap-decode; sid:1296; rev:4;)\n```\n\n----------------------------------------\n\nTITLE: Using pcrexform to extract data from HTTP request line - Suricata Rule\nDESCRIPTION: This rule uses the `pcrexform` transformation to extract a portion of the `http.request_line` using a regular expression.  The regular expression `[a-zA-Z]+\\s+(.*)\\s+HTTP` captures the part of the request line between the HTTP method and \"HTTP\". The rule alerts if the extracted content contains `/dropper.php`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"HTTP with pcrexform\"; http.request_line; \\\n    pcrexform:\"[a-zA-Z]+\\s+(.*)\\s+HTTP\"; content:\"/dropper.php\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Flow Integer Variable\nDESCRIPTION: This Lua code demonstrates how to access and modify a Flow integer variable in Suricata. It uses `SCFlowintGet(0)` to retrieve the current value of the flowint at index 0 (assumed to be `tls-cnt`). The code then increments the value and uses `SCFlowintSet(0, ...)` to update the flowint.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_49\n\nLANGUAGE: Lua\nCODE:\n```\nfunction match(args)\n    a = SCFlowintGet(0);\n    if a then\n        SCFlowintSet(0, a + 1)\n    else\n        SCFlowintSet(0, 1)\n    end\n```\n\n----------------------------------------\n\nTITLE: LDAP Response DN Match Alert Rule\nDESCRIPTION: This Suricata rule alerts if a packet has the LDAP distinguished name `dc=example,dc=com` in a response. It uses the `ldap.responses.dn` keyword along with the `content` keyword to match the distinguished name. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAPDN\"; :example-rule-emphasis:`ldap.responses.dn; content:\"dc=example,dc=com\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Content-Length Request with Byte Test in Suricata Rule\nDESCRIPTION: This Suricata rule demonstrates detecting an HTTP request content length greater than or equal to 100 using `http.content_len` and `byte_test`. The `byte_test` checks if the content length is >= 100. The `flow` keyword specifies the traffic direction to be 'to_server'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_29\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Content-Length Request \\\nByte Test Example\"; flow:established,to_server; \\\n:example-rule-options:`http.content_len; byte_test:0,>=,100,0,string,dec;` \\\nclasstype:bad-unknown; sid:99; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Detection Engine in Suricata (YAML)\nDESCRIPTION: This snippet shows how to configure the detection engine in Suricata, including setting the profile (medium, high, low, custom-values), custom values for toclient and toserver groups, sgh-mpm-context, inspection-recursion-limit, stream-tx-log-limit, guess-applayer-tx, and grouping options for TCP and UDP priority ports.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n  detect:\n    profile: medium\n    custom-values:\n      toclient-groups: 3\n      toserver-groups: 25\n    sgh-mpm-context: auto\n    inspection-recursion-limit: 3000\n    stream-tx-log-limit: 4\n    guess-applayer-tx: no\n    grouping:\n      tcp-priority-ports: 53, 80, 139, 443, 445, 1433, 3306, 3389, 6666, 6667, 8080\n      udp-priority-ports: 53, 135, 5060\n```\n\n----------------------------------------\n\nTITLE: Suricata HTTP Log Output Configuration (YAML)\nDESCRIPTION: This configuration defines the settings for the http.log output, which tracks HTTP traffic events. It allows enabling/disabling the log, setting the filename, specifying append behavior, and enabling extended logging for more detailed information. The `extended` parameter controls the verbosity of the log entries.  The `enabled` parameter activates/deactivates the logging, `filename` sets the name of the log file, and `append` determines if the log file should be appended to or overwritten on Suricata restart.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n  - http-log:                     #The log-name.\n      enabled: yes                #This log is enabled. Set 'no' to disable.\n      filename: http.log          #The name of the file in the default logging directory.\n      append: yes/no              #If this option is set to yes, the last filled http.log-file will not be\n                                  # overwritten while restarting Suricata.\n      extended: yes               # If set to yes more information is written about the event.\n```\n\n----------------------------------------\n\nTITLE: Stream Engine Configuration in Suricata\nDESCRIPTION: This snippet configures the stream engine in Suricata, including memory limits (memcap), checksum validation, session pre-allocation, midstream session handling, and asynchronous stream handling. The memcap-policy defines the action to take when memory limits are reached, and the `midstream-policy` determines how Suricata handles sessions that start midstream.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_32\n\nLANGUAGE: yaml\nCODE:\n```\nstream:\n  memcap: 64mb                # Max memory usage (in bytes) for TCP session tracking\n  memcap-policy: ignore       # In IPS mode, call memcap policy if memcap is reached\n  checksum-validation: yes    # Validate packet checksum, reject packets with invalid checksums.\n  prealloc-sessions: 32768     # 32k sessions prealloc'd\n  midstream: false             # do not allow midstream session pickups\n  midstream-policy: drop-flow  # in IPS mode, drop flows that start midstream\n  async-oneside: false         # do not enable async stream handling\n  inline: no                   # stream inline mode\n  drop-invalid: yes            # drop invalid packets\n  bypass: no\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Connection Header with Suricata Rule\nDESCRIPTION: This Suricata rule illustrates detecting a specific HTTP connection header value using the `http.connection` keyword. It searches for the string \"Keep-Alive\" within the HTTP Connection header. The `flow` keyword specifies the traffic direction to be 'to_server'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_26\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Connection Example\"; \\\nflow:established,to_server; :example-rule-options:`http.connection; \\\ncontent:\"Keep-Alive\";` bsize:10; classtype:bad-unknown; sid:94; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email Cc Field\nDESCRIPTION: This Suricata rule creates an alert if an SMTP packet has a 'Cc' (Carbon Copy) field containing the given string. The rule utilizes the 'email.cc' keyword to focus on the email's CC recipients. The 'content' option sets the specific value to be matched. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_3\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email cc\"; email.cc; content:\"Emily <emily.roberts@example.com>, Ava <ava.johnson@example.com>, Sophia Wilson <sophia.wilson@example.com>\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Stream Reassembly Configuration\nDESCRIPTION: This snippet configures the stream reassembly engine in Suricata, including memory limits (memcap), reassembly depth, chunk sizes for inspection, and options for randomizing chunk sizes and disabling raw reassembly.  The memcap-policy defines the action to take when memory limits are reached during reassembly. Segment preallocation is also configured.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_33\n\nLANGUAGE: yaml\nCODE:\n```\nreassembly:\n  memcap: 256mb             # Memory reserved for stream data reconstruction (in bytes)\n  memcap-policy: ignore     # What to do when memcap for reassembly is hit\n  depth: 1mb                # The depth of the reassembling.\n  toserver-chunk-size: 2560 # inspect raw stream in chunks of at least this size\n  toclient-chunk-size: 2560 # inspect raw stream in chunks of at least\n  randomize-chunk-size: yes\n  #randomize-chunk-range: 10\n  raw: no\n  segment-prealloc: 2048    # pre-alloc 2k segments per thread\n  check-overlap-different-data: true\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Header Absence\nDESCRIPTION: These Suricata rules match on the absence of specific HTTP headers. They use the `http.header_names` keyword with a negated content match (`!`) to check for the absence of 'User-Agent' and 'Date' headers, respectively, in HTTP requests and responses.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_37\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Names Request \\\n  Example 3\"; flow:established,to_server; :example-rule-options:`http.header_names; \\\n  content:!\"|0d 0a|User-Agent|0d 0a|;\";` classtype:bad-unknown; sid:114; rev:1;)\n\n  alert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Header Names Response \\\n  Example 3\"; flow:established,to_client; :example-rule-options:`http.header_names; \\\n  content:!\"|0d 0a|Date|0d 0a|;\";` classtype:bad-unknown; sid:115; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Checking Allocated Hugepages (Bash)\nDESCRIPTION: These commands are used to check the number of allocated hugepages. The first command, `sudo dpdk-hugepages.py -s`, is a DPDK helper script. The second command, `grep Huge /proc/meminfo`, parses /proc/meminfo file for memory information and filters the output to display lines containing 'Huge', showing the size and number of allocated hugepages.  Sufficient hugepages are required for DPDK to allocate memory pools.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\nsudo dpdk-hugepages.py -s\n```\n\nLANGUAGE: bash\nCODE:\n```\ngrep Huge /proc/meminfo\n```\n\n----------------------------------------\n\nTITLE: Decoding XOR encoded data in HTTP URI - Suricata Rule\nDESCRIPTION: This rule decodes an XOR-encoded value in the `http.uri` buffer using the `xor` transformation with the key `0d0ac8ff`. The rule alerts if the XOR-decoded URI contains `password=`, indicating a potential password being transmitted in an encoded form.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"HTTP with xor\"; http.uri; \\\n    xor:\"0d0ac8ff\"; content:\"password=\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Alert Event Example\nDESCRIPTION: This JSON provides an example of the `alert` event type, providing further insight to the included data. It encompasses details like the timestamp, associated flow ID, packet count, source and destination IPs/ports, protocol, Ethernet details, and the specific alert information including signature ID, message, category, and severity. The HTTP information is also provided, alongside the direction of the traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n      \"timestamp\": \"2023-09-18T06:13:41.532140+0000\",\n      \"flow_id\": 1676750115612680,\n      \"pcap_cnt\": 130,\n      \"event_type\": \"alert\",\n      \"src_ip\": \"142.11.240.191\",\n      \"src_port\": 35361,\n      \"dest_ip\": \"192.168.100.237\",\n      \"dest_port\": 49175,\n      \"proto\": \"TCP\",\n      \"pkt_src\": \"wire/pcap\",\n      \"ether\": {\n        \"src_mac\": \"52:54:00:36:3e:ff\",\n        \"dest_mac\": \"12:a9:86:6c:77:de\"\n      },\n      \"tx_id\": 1,\n      \"alert\": {\n        \"action\": \"allowed\",\n        \"gid\": 1,\n        \"signature_id\": 2045001,\n        \"rev\": 1,\n        \"signature\": \"ET ATTACK_RESPONSE Win32/LeftHook Stealer Browser Extension Config Inbound\",\n        \"category\": \"A Network Trojan was detected\",\n        \"severity\": 1,\n        \"metadata\": {\n          \"affected_product\": [\n            \"Windows_XP_Vista_7_8_10_Server_32_64_Bit\"\n          ],\n          \"attack_target\": [\n            \"Client_Endpoint\"\n          ],\n          \"created_at\": [\n            \"2023_04_17\"\n          ],\n          \"deployment\": [\n            \"Perimeter\"\n          ],\n          \"former_category\": [\n            \"ATTACK_RESPONSE\"\n          ],\n          \"signature_severity\": [\n            \"Major\"\n          ],\n          \"updated_at\": [\n            \"2023_04_18\"\n          ]\n        }\n      },\n      \"http\": {\n        \"hostname\": \"142.11.240.191\",\n        \"http_port\": 35361,\n        \"url\": \"/\",\n        \"http_content_type\": \"text/xml\",\n        \"http_method\": \"POST\",\n        \"protocol\": \"HTTP/1.1\",\n        \"status\": 200,\n        \"length\": 5362\n      },\n      \"files\": [\n        {\n          \"filename\": \"/\",\n          \"gaps\": false,\n          \"state\": \"CLOSED\",\n          \"stored\": false,\n          \"size\": 5362,\n          \"tx_id\": 1\n        }\n      ],\n      \"app_proto\": \"http\",\n      \"direction\": \"to_client\",\n      \"flow\": {\n        \"pkts_toserver\": 13,\n        \"pkts_toclient\": 12,\n        \"bytes_toserver\": 1616,\n        \"bytes_toclient\": 8044,\n        \"start\": \"2023-09-18T06:13:33.324862+0000\",\n        \"src_ip\": \"192.168.100.237\",\n        \"dest_ip\": \"142.11.240.191\",\n        \"src_port\": 49175,\n        \"dest_port\": 35361\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Suricata rule using dataset with SHA256 hash\nDESCRIPTION: This rule demonstrates how to use a dataset with SHA256 hashes.  It transforms the DNS query to SHA256 and then checks if it exists in the `dns-sha256-seen` dataset using the `dataset:isset` keyword.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns any any -> any any (msg:\"dns list test\"; dns.query; to_sha256; dataset:isset,dns-sha256-seen; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Enabling Suricata on boot\nDESCRIPTION: This command enables the Suricata service to start automatically on system boot using systemctl. It requires sudo privileges to execute. The system will start Suricata automatically during startup.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl enable suricata\n```\n\n----------------------------------------\n\nTITLE: Limiting Process Creation in Suricata\nDESCRIPTION: This snippet shows how to limit process creation by Suricata using the `limit-noproc` setting in the `security` section of the `suricata.yaml` file. Enabling this option calls `setrlimit` with `RLIMIT_NPROC` to prevent potential exploits that involve forking new processes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_73\n\nLANGUAGE: yaml\nCODE:\n```\nsecurity:\n limit-noproc: true\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Random Bytes Field in Suricata\nDESCRIPTION: This example demonstrates how to match the last 28 bytes of the TLS random field from the client or server hello records using the `tls.random_bytes` keyword. The content keyword specifies the hexadecimal representation of these 28 bytes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_18\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"TLS random_bytes test\"; \\\n    tls.random_bytes; content:\"|57 5d 77 02 07 c2 9d be 24 01 cc f0 5d cd e1 d2 a5 86 9c 4a 3e ee 38 db 55 1a d9 bc|\"; sid: 200076;)\n```\n\n----------------------------------------\n\nTITLE: File-store v2 Configuration Example\nDESCRIPTION: This YAML snippet illustrates an example of a Suricata file-store configuration in version 2. It includes the version field, the directory for storing files, options for forcing hash logging, controlling stream depth, and enabling the writing of file information. It demonstrates the updated configuration style.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/config-update.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n  - file-store:\n      version: 2\n      enabled: yes\n      dir: filestore\n      force-hash: [md5]\n      file-filestore: no\n      stream-depth: 1mb\n      max-open-files: 0\n      write-fileinfo: yes\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-requisites for Suricata Build - Bash\nDESCRIPTION: This command installs the necessary dependencies to build Suricata on Ubuntu. It uses apt-get to install various development libraries and tools, including pcre2, build-essential, autoconf, automake, libtool, libpcap, libnet, libyaml, pkg-config, zlib, libcap-ng, make, libmagic, libjansson, rustc, cargo, jq, and git-core.  It is essential to execute this command before proceeding with the Suricata installation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get -y install libpcre2-dev build-essential autoconf \\\n  automake libtool libpcap-dev libnet1-dev libyaml-0-2 libyaml-dev \\\n  pkg-config zlib1g zlib1g-dev libcap-ng-dev libcap-ng0 make \\\n  libmagic-dev libjansson-dev rustc cargo jq git-core\n```\n\n----------------------------------------\n\nTITLE: Example Suricata Rule with 'msg' Keyword\nDESCRIPTION: This example demonstrates a complete Suricata rule that includes the 'msg' keyword.  It shows how the 'msg' keyword is used in conjunction with other rule options like 'flow', 'http.method', and 'content' to define specific network traffic patterns.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Eve Log Configuration\nDESCRIPTION: This configuration snippet shows how to enable eve-log output in Suricata, specify the output file, and configure logging of alerts and DNS events. It demonstrates how to enable logging for specific DNS record types and to configure request/response logging.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n    - eve-log:\n        enabled: yes\n        type: file #file|syslog|unix_dgram|unix_stream\n        filename: eve.json\n        # the following are valid when type: syslog above\n        #identity: \"suricata\"\n        #facility: local5\n        #level: Info ## possible levels: Emergency, Alert, Critical,\n                     ## Error, Warning, Notice, Info, Debug\n        types:\n          - alert\n          - dns:\n\n            # Logging format. In 8.0 version 3 is the default. Can be\n            # set to 2 to keep compatibility with Suricata 7.0.\n            # version: 3\n\n            # Control logging of requests and responses:\n            # - requests: enable logging of DNS queries\n            # - responses: enable logging of DNS answers\n            # By default both requests and responses are logged.\n            requests: yes\n            responses: yes\n            # DNS record types to log, based on the query type.\n            # Default: all.\n            #types: [a, aaaa, cname, mx, ns, ptr, txt]\n            types: [a, ns, md, mf, cname, soa, mb, mg, mr, null,\n            wks, ptr, hinfo, minfo, mx, txt, rp, afsdb, x25, isdn,\n            rt, nsap, nsapptr, sig, key, px, gpos, aaaa, loc, nxt,\n            srv, atma, naptr, kx, cert, a6, dname, opt, apl, ds,\n            sshfp, ipseckey, rrsig, nsec, dnskey, dhcid, nsec3,\n            nsec3param, tlsa, hip, cds, cdnskey, spf, tkey,\n            tsig, maila, any, uri]\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for SSH Protocol in Lua\nDESCRIPTION: This code demonstrates the initialization of the `needs` table for SSH protocol analysis. The `protocol` is set to 'ssh' so the script can access SSH protocol data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_35\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"protocol\"] = \"ssh\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Lua Script for Detection\nDESCRIPTION: The `init` function in a Lua script registers the buffers that need inspection by the Suricata engine. It returns a table (`needs`) where keys are the buffer names (e.g., \"http.request_line\") and values are set to `tostring(true)`. This function is required for the Lua script to function correctly within Suricata's detection engine. The available buffers are listed in the surrounding text.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/lua-detection.rst#_snippet_0\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"http.request_line\"] = tostring(true)\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: EVE JSON HTTP Event Example\nDESCRIPTION: This JSON presents an example of an `http` event type, offering details about HTTP traffic observed by Suricata. The data includes the timestamp, flow ID, packet count, source and destination IPs/ports, protocol, Ethernet details, along with HTTP attributes such as the hostname, URL, content type, method, protocol version, status code, length, request headers, and response headers. The HTTP headers provide more detailed information about the transaction.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n      \"timestamp\": \"2023-09-18T06:13:33.903924+0000\",\n      \"flow_id\": 1676750115612680,\n      \"pcap_cnt\": 70,\n      \"event_type\": \"http\",\n      \"src_ip\": \"192.168.100.237\",\n      \"src_port\": 49175,\n      \"dest_ip\": \"142.11.240.191\",\n      \"dest_port\": 35361,\n      \"proto\": \"TCP\",\n      \"pkt_src\": \"wire/pcap\",\n      \"ether\": {\n        \"src_mac\": \"12:a9:86:6c:77:de\",\n        \"dest_mac\": \"52:54:00:36:3e:ff\"\n      },\n      \"tx_id\": 0,\n      \"http\": {\n        \"hostname\": \"142.11.240.191\",\n        \"http_port\": 35361,\n        \"url\": \"/\",\n        \"http_content_type\": \"text/xml\",\n        \"http_method\": \"POST\",\n        \"protocol\": \"HTTP/1.1\",\n        \"status\": 200,\n        \"length\": 212,\n        \"request_headers\": [\n          {\n            \"name\": \"Content-Type\",\n            \"value\": \"text/xml; charset=utf-8\"\n          },\n          {\n            \"name\": \"SOAPAction\",\n            \"value\": \"\\\"http://tempuri.org/Endpoint/CheckConnect\\\"\"\n          },\n          {\n            \"name\": \"Host\",\n            \"value\": \"142.11.240.191:35361\"\n          },\n          {\n            \"name\": \"Content-Length\",\n            \"value\": \"137\"\n          },\n          {\n            \"name\": \"Expect\",\n            \"value\": \"100-continue\"\n          },\n          {\n            \"name\": \"Accept-Encoding\",\n            \"value\": \"gzip, deflate\"\n          },\n          {\n            \"name\": \"Connection\",\n            \"value\": \"Keep-Alive\"\n          }\n        ],\n        \"response_headers\": [\n          {\n            \"name\": \"Content-Length\",\n            \"value\": \"212\"\n          },\n          {\n            \"name\": \"Content-Type\",\n            \"value\": \"text/xml; charset=utf-8\"\n          },\n          {\n            \"name\": \"Server\",\n            \"value\": \"Microsoft-HTTPAPI/2.0\"\n          },\n          {\n            \"name\": \"Date\",\n            \"value\": \"Mon, 18 Sep 2023 06:13:33 GMT\"\n          }\n        ]\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Start of Request/Response\nDESCRIPTION: These Suricata rules detect the start of an HTTP request or response, including the request/response line and headers. They use the `http.start` keyword along with content matching to identify specific patterns. The `flow` keyword differentiates between client and server traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_40\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Start Request \\\n  Example\"; flow:established,to_server; :example-rule-options:`http.start; \\\n  content:\"POST / HTTP/1.1|0d 0a|Host|0d 0a|Connection|0d 0a 0d 0a|;\";` \\\n  classtype:bad-unknown; sid:101; rev:1;)\n\n  alert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Start Response \\\n  Example\"; flow:established,to_client; :example-rule-options:`http.start; \\\n  content:\"HTTP/1.1 200 OK|0d 0a|Content-Type|0d 0a|Server|0d 0a 0d a0|;\";` \\\n  classtype:bad-unknown; sid:102; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuration for Classtype Definitions\nDESCRIPTION: This snippet demonstrates how to define 'classtype' configurations in Suricata's configuration file.  Classtypes assign a short name, long name, and priority to rules, which affects how alerts are classified and prioritized.  The configurations determine priority.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_7\n\nLANGUAGE: Suricata Configuration\nCODE:\n```\nconfig classification: web-application-attack,Web Application Attack,1\nconfig classification: not-suspicious,Not Suspicious Traffic,3\n```\n\n----------------------------------------\n\nTITLE: TLS Certificate Logging Example (JSON)\nDESCRIPTION: This example demonstrates the JSON structure for TLS certificate logging in Suricata's Eve log. It includes fields such as subject, sni, and certificate, representing information extracted from the TLS handshake.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_27\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"subject\": \"C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.googleapis.com\",\n      \"sni\": \"www.googleapis.com\",\n      \"certificate\": \"MIIE3TCCA8WgAwIBAgIIQPsvobRZN0gwDQYJKoZIhvcNAQELBQAwSTELMA [...]\"\n   }\n```\n\n----------------------------------------\n\nTITLE: Suricata Flow Direction, Connection, and Fragment Matching\nDESCRIPTION: This example shows how to combine multiple flow options to match specific traffic directions, connection states, and stream characteristics.  It uses `flow:to_server, not_established, no_frag` to match packets from the client to the server in non-established connections that have not been reassembled from fragments.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nflow:to_server, not_established, no_frag\n```\n\n----------------------------------------\n\nTITLE: Matching TLS/SSL Certificate SHA1 Fingerprint in Suricata\nDESCRIPTION: This example demonstrates matching the SHA1 fingerprint of a TLS/SSL certificate using the `tls.fingerprint` keyword in Suricata. The fingerprint must be in lowercase.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.fingerprint:!\"f3:40:21:48:70:2c:31:bc:b5:aa:22:ad:63:d6:bc:2e:b3:46:e2:5a\"\n```\n\n----------------------------------------\n\nTITLE: SMTP helo keyword example\nDESCRIPTION: This example shows how to use the `smtp.helo` keyword to match the parameter passed to the HELO command in SMTP. The rule triggers if the HELO command contains \"localhost\". `smtp.helo` is a sticky buffer and can be used as `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"SMTP helo localhost\"; smtp.helo; content:\"localhost\"; sid:2; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Alert Event Example\nDESCRIPTION: This JSON snippet shows an example of an alert event within Suricata's EVE format. The alert includes information about the matched signature, source and destination IPs and ports, protocol, and other metadata useful for identifying and analyzing potential security threats.  It provides details on the event type, timestamps, and the specific alert triggered.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"timestamp\": \"2017-04-07T22:24:37.251547+0100\",\n    \"flow_id\": 586497171462735,\n    \"pcap_cnt\": 53381,\n    \"event_type\": \"alert\",\n    \"src_ip\": \"192.168.2.14\",\n    \"src_port\": 50096,\n    \"dest_ip\": \"209.53.113.5\",\n    \"dest_port\": 80,\n    \"proto\": \"TCP\",\n    \"metadata\": {\n      \"flowbits\": [\n        \"http.dottedquadhost\"\n      ]\n    },\n    \"tx_id\": 4,\n    \"alert\": {\n      \"action\": \"allowed\",\n      \"gid\": 1,\n      \"signature_id\": 2018358,\n      \"rev\": 10,\n      \"signature\": \"ET HUNTING GENERIC SUSPICIOUS POST to Dotted Quad with Fake Browser 1\",\n      \"category\": \"Potentially Bad Traffic\",\n      \"severity\": 2\n    },\n    \"app_proto\": \"http\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file data\nDESCRIPTION: This Suricata rule example demonstrates how to use the `file.data` keyword to match content within a file being transferred over SMTP, HTTP, HTTP2, NFS, FTP, or TCP. It alerts if the file's data contains the string \"example file content\". The rule leverages sticky buffers and payload keywords for content matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"smtp app layer file.data example\"; \\\n file.data; content:\"example file content\"; sid:1; rev:1)\n\nalert http any any -> any any (msg:\"http app layer file.data example\"; \\\n file.data; content:\"example file content\"; sid:2; rev:1)\n\nalert http2 any any -> any any (msg:\"http2 app layer file.data example\"; \\\n file.data; content:\"example file content\"; sid:3; rev:1;)\n\nalert nfs any any -> any any (msg:\"nfs app layer file.data example\"; \\\n file.data; content:\" \"; sid:5; rev:1)\n\nalert ftp-data any any -> any any (msg:\"ftp app layer file.data example\"; \\\n file.data; content:\"example file content\"; sid:6; rev:1;)\n\nalert tcp any any -> any any (msg:\"tcp file.data example\"; \\\n file.data; content:\"example file content\"; sid:4; rev:1)\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Content-Type in Request/Response\nDESCRIPTION: This Suricata rule detects specific content types in HTTP requests and responses.  It uses the `http.content_type` keyword along with content matching to identify 'multipart/form-data' in requests and 'text/html' in responses. The `flow` keyword specifies the direction of the traffic to inspect.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_31\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Content-Type Request \\\n  Example\"; flow:established,to_server; :example-rule-options:`http.content_type; \\\n  content:\"multipart/form-data|3b 20|;\";` startswith; classtype:bad-unknown; \\\n  sid:95; rev:1;)\n\n  alert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Content-Type Response \\\n  Example\"; flow:established,to_client; :example-rule-options:`http.content_type; \\\n  content:\"text/html\";` bsize:9; classtype:bad-unknown; sid:96; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Enabling Bypass in Suricata Configuration (YAML)\nDESCRIPTION: This YAML snippet shows how to enable bypass in the stream section of the `suricata.yaml` file. This setting allows Suricata to bypass flows once the stream depth is reached. This needs to be enabled in `suricata.yaml`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\n stream:\n   bypass: true\n```\n\n----------------------------------------\n\nTITLE: Matching TCP MSS Option Value with tcp.mss in Suricata\nDESCRIPTION: This example demonstrates using the `tcp.mss` keyword in a Suricata rule to match on the TCP Maximum Segment Size (MSS) option value. The MSS value is checked to be less than 536 in the example rule.  This keyword requires that the MSS option is present in the TCP header to match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (flow:stateless; flags:S,12; :example-rule-emphasis:`tcp.mss:<536;` sid:1234; rev:5;)\n```\n\n----------------------------------------\n\nTITLE: Setting af-packet version in suricata.yaml\nDESCRIPTION: This code snippet demonstrates how to enforce the use of af-packet v3 in the `af-packet` configuration section of the `suricata.yaml` file. This is recommended for IDS/NSM deployments. The `tpacket-v3: yes` option specifically enforces the use of af-packet v3.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tuning-considerations.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\naf-packet:\n  - interface: eth0\n    ....\n    ....\n    ....\n    tpacket-v3: yes\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Header Flags\nDESCRIPTION: This example illustrates matching MQTT header flags using the `mqtt.flags` keyword. It matches when the `dup` flag is set and the `retain` flag is not set and also matches when the `retain` flag is set. Valid flags are `dup` and `retain`. Flags may be prefixed by `!` to indicate negation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.flags:dup,!retain;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.flags:retain;\n```\n\n----------------------------------------\n\nTITLE: Configuring force-bind-mode in suricata.yaml\nDESCRIPTION: This snippet shows how to configure the force-bind-mode in the suricata.yaml configuration file. The force-bind-mode can be set to copy, zero or none. zero is the preferred mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  force-bind-mode: <value> where: value = <copy|zero|none>\n  force-bind-mode: zero\n```\n\n----------------------------------------\n\nTITLE: Suricata PCAP Log Output Configuration (YAML)\nDESCRIPTION: This configuration defines the settings for the pcap-log output, which saves packets captured by Suricata. It allows enabling/disabling the log, specifying the filename, setting a size limit, choosing between normal and multi mode, and defining conditional logging based on alerts or tags. The user can use BPF filters to select the packets to log. `limit` specifies the maximum size of the pcap file.  The user can control if only alert or tagged packet are logged. The mode `normal` and `multi` differ in the way how files are created and written to disk. \nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\n  - pcap-log:\n      enabled:  yes\n      filename: log.pcap\n\n      # Limit in MB.\n      limit: 32\n\n      mode: normal # \"normal\" or multi\n      conditional: alerts\n\n      # A BPF filter that will be applied to all packets being\n      # logged. If set, packets must match this filter otherwise they\n      # will not be logged.\n      #bpf-filter:\n```\n\n----------------------------------------\n\nTITLE: Matching DNS RRtype Value in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match a specific rrtype value in the DNS message using the `dns.rrtype` keyword in a Suricata rule. The rrtype is an unsigned 16-bit integer representing the resource record type.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.rrtype:4;\n```\n\n----------------------------------------\n\nTITLE: Downloading Emerging Threats Open Ruleset with suricata-update\nDESCRIPTION: This command downloads the Emerging Threats Open ruleset into the /var/lib/suricata/rules/ directory. It is the simplest way to get started with suricata-update.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata-update\n```\n\n----------------------------------------\n\nTITLE: Suricata byte_math rule example\nDESCRIPTION: This example demonstrates the use of the `byte_math` keyword in a Suricata rule. It performs arithmetic operations on bytes within the packet payload and stores the result in a variable. The rule checks for specific content, performs byte math, and then verifies the result using byte_test.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\n    (msg:\"Testing bytemath_body\"; \\\n    content:\"|00 04 93 F3|\"; \\\n    content:\"|00 00 00 07|\"; distance:4; within:4; \\\n    byte_math:bytes 4, offset 0, oper +, rvalue \\\n    248, result var, relative;)\n\n  alert udp any any -> any any \\\n    (byte_extract: 1, 0, extracted_val, relative; \\\n    byte_math: bytes 1, offset 1, oper +, rvalue extracted_val, result var; \\\n    byte_test: 2, =, var, 13; \\\n    msg:\"Byte extract and byte math with byte test verification\";)\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Server Name Indication (SNI) in Suricata\nDESCRIPTION: This example demonstrates how to match the Server Name Indication (SNI) field in a TLS/SSL handshake using the `tls.sni` keyword in Suricata. It shows the use of `content` for string matching, along with the `nocase` modifier and PCRE for more complex pattern matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.sni; content:\"oisf.net\"; nocase; isdataat:!1,relative;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.sni; content:\"oisf.net\"; nocase; pcre:\"/oisf\\.net$/\";\n```\n\n----------------------------------------\n\nTITLE: Suricata rule detecting unique user agents\nDESCRIPTION: This example shows a rule that detects unique user agents by adding them to the `http-ua-seen` dataset. It defines the dataset type as string and specifies a state file for persistence.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"LOCAL HTTP new UA\"; http.user_agent; dataset:set,http-ua-seen, type string, state http-ua-seen.csv; sid:8000001; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata rule to store PDF files (magic)\nDESCRIPTION: This Suricata rule stores files identified as PDF documents based on their magic number.  It alerts on HTTP traffic and uses the `filemagic` keyword to match files with the \"PDF document\" magic string.  The `filestore` keyword then stores the identified files.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/file-extraction.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert http any any -> any any (msg:\"FILE pdf detected\"; filemagic:\"PDF document\"; filestore; sid:3; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Enabling Unix Socket in Suricata YAML Configuration\nDESCRIPTION: This snippet shows how to enable the Unix socket in Suricata's YAML configuration file. It enables the socket using `enabled: yes` and allows specifying an alternate socket filename using the `filename` variable, which is relative to the local state base directory. The socket allows external commands to be sent to the Suricata instance.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/unix-socket.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nunix-command:\n  enabled: yes\n  #filename: custom.socket # use this to specify an alternate file\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with 'sid' Keyword Example\nDESCRIPTION: This snippet shows a complete Suricata rule including the 'sid' keyword.  It demonstrates placement, typically as the last (or second to last, before 'rev') keyword in the rule. 'sid' values must be unique within a rule group.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MD5 hash of a DNS query against a blacklist\nDESCRIPTION: This example shows how to match the MD5 hash of a DNS query against a blacklist called `dns-bl`. The `to_md5` transform converts the DNS query to its MD5 hash before checking its presence in the dataset.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\ndns.query; to_md5; dataset:isset,dns-bl;\n```\n\n----------------------------------------\n\nTITLE: Configuring DNS Logging with EVE JSON\nDESCRIPTION: This snippet configures DNS logging using the EVE JSON output format. It demonstrates how to enable/disable the logger, control logging of requests and responses, specify the format of answer logging (detailed or grouped), and define the types of DNS records to log.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n        - dns:\n            #version: 3\n\n            # Enable/disable this logger. Default: enabled.\n            #enabled: yes\n\n            # Control logging of requests and responses:\n            # - requests: enable logging of DNS queries\n            # - responses: enable logging of DNS answers\n            # By default both requests and responses are logged.\n            #requests: no\n            #responses: no\n\n            # Format of answer logging:\n            # - detailed: array item per answer\n            # - grouped: answers aggregated by type\n            # Default: all\n            #formats: [detailed, grouped]\n\n            # Types to log, based on the query type.\n            # Default: all.\n            #types: [a, aaaa, cname, mx, ns, ptr, txt]\n```\n\n----------------------------------------\n\nTITLE: Iptables: Forward traffic to NFQUEUE (gateway scenario)\nDESCRIPTION: This iptables rule forwards all traffic passing through the gateway to the NFQUEUE.  This is used when Suricata is protecting computers behind the gateway.  It assumes the default queue number (0) is being used by Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I FORWARD -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Host Example\nDESCRIPTION: This Suricata rule shows how to match the HTTP host header after normalization (lowercase conversion). It uses the `http.host` keyword and checks for the value `suricata.io`. The `bsize` option is included.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Host Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.host; \\\n  content:\"suricata.io\";` bsize:11; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Bidirectional Direction Example\nDESCRIPTION: This example shows a bidirectional traffic match using the '<>' operator. This rule matches packets in either direction between the source and destination.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nsource <> destination\n```\n\n----------------------------------------\n\nTITLE: Enable Tagged Packet Logging in EVE\nDESCRIPTION: This YAML snippet configures Suricata to log tagged packets in EVE (JSON) format.  The `tagged-packets: true` setting under the `alert` type ensures that packet events for tagged packets are included in the EVE log. This requires enabling the eve-log output.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tag.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\noutputs:\n  - eve-log:\n      enabled: yes\n      filename: eve.json\n      types:\n        - alert:\n            tagged-packets: true\n```\n\n----------------------------------------\n\nTITLE: Classification Configuration\nDESCRIPTION: This YAML snippet shows the classification file path for Suricata. This file contains rule classifications that define the severity and purpose of different types of network events.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_63\n\nLANGUAGE: yaml\nCODE:\n```\nclassification-file: /etc/suricata/classification.config\n```\n\n----------------------------------------\n\nTITLE: DHCP Logging Example (Default)\nDESCRIPTION: This JSON snippet demonstrates a DHCP log entry captured by Suricata using the default logging level. It includes basic information such as the message type, transaction ID, client MAC address, assigned IP address, DHCP message type, renewal time, and client ID. This logging level provides enough information to map MAC addresses to IP addresses.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_75\n\nLANGUAGE: JSON\nCODE:\n```\n  \"dhcp\": {\n    \"type\":\"reply\",\n    \"id\":755466399,\n    \"client_mac\":\"54:ee:75:51:e0:66\",\n    \"assigned_ip\":\"100.78.202.125\",\n    \"dhcp_type\":\"ack\",\n    \"renewal_time\":21600,\n    \"client_id\":\"54:ee:75:51:e0:66\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring TLS Logging with EVE JSON\nDESCRIPTION: This snippet configures TLS logging using the EVE JSON output format.  It shows how to enable extended logging information, or how to use the custom option to control which TLS fields are included in the eve-log.  Note that using `custom` disables `extended` logging.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\n        - tls:\n            extended: yes     # enable this for extended logging information\n            # custom allows to control which tls fields that are included\n            # in eve-log\n            #custom: [subject, issuer, serial, fingerprint, sni, version, not_before, not_after, certificate, chain, ja3, ja3s, ja4]\n```\n\n----------------------------------------\n\nTITLE: Detection Filter Rule Example\nDESCRIPTION: This rule generates alerts after 15 or more matches have occurred within 2 seconds. It tracks by the source IP and contains a count of 15 within a period of 2 seconds.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/thresholding.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any\n  (msg:\"ET WEB_SERVER WebResource.axd access without t (time) parameter - possible ASP padding-oracle exploit\";\n  flow:established,to_server; content:\"GET\"; http_method; content:\"WebResource.axd\"; http_uri; nocase;\n  content:!\"&t=\"; http_uri; nocase; content:!\"&amp|3b|t=\"; http_uri; nocase;\n  :example-rule-emphasis:`detection_filter:track by_src,count 15,seconds 2;`\n  reference:url,netifera.com/research/; reference:url,www.microsoft.com/technet/security/advisory/2416728.mspx;\n  classtype:web-application-attack; sid:2011807; rev:5;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Tenancy in suricata.yaml (YAML)\nDESCRIPTION: This YAML snippet shows how to configure multi-tenancy support in the main Suricata configuration file (suricata.yaml). It includes settings for enabling multi-tenancy, specifying the selector type (VLAN or direct), setting the number of loader threads, defining tenants with their YAML configuration files, and mapping VLAN IDs to tenant IDs.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nmulti-detect:\n  enabled: yes\n  #selector: direct # direct or vlan\n  selector: vlan\n  loaders: 3\n\n  tenants:\n  - id: 1\n    yaml: tenant-1.yaml\n  - id: 2\n    yaml: tenant-2.yaml\n  - id: 3\n    yaml: tenant-3.yaml\n\n  mappings:\n  - vlan-id: 1000\n    tenant-id: 1\n  - vlan-id: 2000\n    tenant-id: 2\n  - vlan-id: 1112\n    tenant-id: 3\n```\n\n----------------------------------------\n\nTITLE: Customizing libhtp HTTP Parsing\nDESCRIPTION: This snippet demonstrates various customizable parameters for the libhtp HTTP parser in Suricata. The parameters configure aspects such as backslash conversion, lowercase conversion, NUL byte handling, separator compression/decoding, URL encoding handling, and UTF-8 conversion.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_38\n\nLANGUAGE: yaml\nCODE:\n```\n# Configures whether backslash characters are treated as path segment\n# separators. They are not on Unix systems, but are on Windows systems.\n# If this setting is enabled, a path such as \"/one\\two/three\" will be\n# converted to \"/one/two/three\".  Accepted values - yes, no.\n#path-convert-backslash-separators: yes\n\n# Configures whether input data will be converted to lowercase.\n#path-convert-lowercase: yes\n\n# Configures how the server reacts to encoded NUL bytes.\n#path-nul-encoded-terminates: no\n\n# Configures how the server reacts to raw NUL bytes.\n#path-nul-raw-terminates: no\n\n# Configures whether consecutive path segment separators will be\n# compressed. When enabled, a path such as \"/one//two\" will be normalized\n# to \"/one/two\". The backslash_separators and decode_separators\n# parameters are used before compression takes place. For example, if\n# backslash_separators and decode_separators are both enabled, the path\n# \"/one\\\\/two\\/%5cthree/%2f//four\" will be converted to\n# \"/one/two/three/four\".  Accepted values - yes, no.\n#path-separators-compress: yes\n\n# Configures whether encoded path segment separators will be decoded.\n# Apache does not do this, but IIS does. If enabled, a path such as\n# \"/one%2ftwo\" will be normalized to \"/one/two\". If the\n# backslash_separators option is also enabled, encoded backslash\n# characters will be converted too (and subsequently normalized to\n# forward slashes).  Accepted values - yes, no.\n#path-separators-decode: yes\n\n# Configures whether %u-encoded sequences in path will be decoded. Such\n# sequences will be treated as invalid URL encoding if decoding is not\n# desireable.  Accepted values - yes, no.\n#path-u-encoding-decode: yes\n\n# Configures how server reacts to invalid encoding in path.  Accepted\n# values - preserve_percent, remove_percent, decode_invalid, status_400\n#path-url-encoding-invalid-handling: preserve_percent\n\n# Controls whether the data should be treated as UTF-8 and converted\n# to a single-byte stream using best-fit mapping\n#path-utf8-convert-bestfit:yes\n\n# Sets the replacement character that will be used to in the lossy\n# best-fit mapping from Unicode characters into single-byte streams.\n# The question mark is the default replacement character.\n#path-bestfit-replacement-char: ?\n\n# Configures whether plus characters are converted to spaces\n# when decoding URL-encoded strings.\n#query-plusspace-decode: yes\n```\n\n----------------------------------------\n\nTITLE: Configuring XDP Bypass (YAML)\nDESCRIPTION: This YAML snippet configures Suricata to use XDP for bypass. It sets the `cluster-type` to `cluster_qm`, `xdp-mode` to `driver`, and specifies the path to the XDP filter file within the af-packet configuration in `suricata.yaml`. This configures Suricata for early packet dropping using XDP.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\n  - interface: eth3\n    threads: 16\n    cluster-id: 97\n    cluster-type: cluster_qm # symmetric hashing is a must!\n    defrag: yes\n    # Xdp mode, \"soft\" for skb based version, \"driver\" for network card based\n    # and \"hw\" for card supporting eBPF.\n    xdp-mode: driver\n    xdp-filter-file:  /usr/libexec/suricata/ebpf/xdp_filter.bpf\n```\n\n----------------------------------------\n\nTITLE: Matching on the Entire UDP Header with udp.hdr in Suricata\nDESCRIPTION: This example demonstrates how to use the `udp.hdr` keyword in a Suricata rule to match on the entire UDP header. The rule looks for a UDP length field with a value of 8 at offset 4, indicating that there is no payload.  This can also be accomplished using `dsize:0;`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_19\n\nLANGUAGE: Suricata\nCODE:\n```\nalert udp any any -> any any (:example-rule-emphasis:`udp.hdr; content:\"|00 08|\"; offset:4; depth:2;` sid:1234; rev:5;)\n```\n\n----------------------------------------\n\nTITLE: TCP Packet Rule Example - Suricata\nDESCRIPTION: This example shows how to create a Suricata rule that only applies to TCP packets and not the reassembled stream. The `tcp-pkt` keyword restricts the rule's scope to individual TCP packets.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp-pkt ...\n```\n\n----------------------------------------\n\nTITLE: SSH Rate Filter Example\nDESCRIPTION: Example of setting a rate filter on an SSH connection rule.  If an IP address triggers the 'Connection to SSH server' rule more than 10 times within a minute, a drop rate_filter is set with a timeout of 5 minutes.  Requires a pre-existing rule with sid 888.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nalert tcp any any -> $MY_SSH_SERVER 22 (msg:\"Connection to SSH server\"; \\\n  flow:to_server; flags:S,12; sid:888;)\n\nrate_filter gen_id 1, sig_id 888, track by_src, count 10, seconds 60, \\\n  new_action drop, timeout 300\n```\n\n----------------------------------------\n\nTITLE: Checking CPU Core and NUMA Location (Bash)\nDESCRIPTION: This command retrieves the CPU core IDs and NUMA locations from the /proc/cpuinfo file.  The `grep` command filters the output to show only lines containing 'physical id' or 'processor', which indicate the NUMA node and processor ID, respectively. This information is crucial for optimizing Suricata's performance by placing worker threads and memory on the same NUMA node as the NIC.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\ncat /proc/cpuinfo | grep 'physical id\\|processor'\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file extension with file.name\nDESCRIPTION: This Suricata rule demonstrates matching a file extension using the `file.name` keyword with `content`, `nocase`, and `endswith`. This is an alternative to using `fileext`. It alerts if a file with the extension \".pdf\" (case-insensitive) is found.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nfile.name; content:\".pdf\"; nocase; endswith;\n```\n\n----------------------------------------\n\nTITLE: Matching Quic Version in Suricata\nDESCRIPTION: This Suricata rule matches on the Quic header version in long headers. It uses the `quic.version` keyword and the `content` keyword to specify the version to match.  This rule triggers an alert with SID 3 when the specific Quic version is detected.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/quic-keywords.rst#_snippet_2\n\nLANGUAGE: suricata\nCODE:\n```\nalert quic any any -> any any (msg:\"QUIC VERSION\"; \\\n    quic.version; content:\"Q046\"; \\\n    sid:3;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Less Than or Equal Matching\nDESCRIPTION: This code snippet shows how to match an integer value that is less than or equal to a specified value. `bsize:<=22;` means the rule will match if the value of the `bsize` field is less than or equal to 22.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:<=22;\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Response Body with Suricata Rule\nDESCRIPTION: This Suricata rule demonstrates detecting a specific string in the HTTP response body using the `file.data` keyword. It searches for the string \"Server response body\" within the HTTP response data. The `flow` keyword specifies the traffic direction to be 'to_client'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_25\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP file.data Example\"; \\\nflow:established,to_client; :example-rule-options:`file.data; \\\ncontent:\"Server response body\";` classtype:bad-unknown; sid:128; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Iptables: Input/Output traffic to NFQUEUE (host scenario)\nDESCRIPTION: These iptables rules forward all incoming and outgoing traffic on the host machine to the NFQUEUE. This is used when Suricata is protecting the computer it is running on. It assumes the default queue number (0) is being used by Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I INPUT -j NFQUEUE\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I OUTPUT -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Configuring eBPF Load Balancing (YAML)\nDESCRIPTION: This YAML snippet configures Suricata to use eBPF for load balancing. It sets the `cluster-type` to `cluster_ebpf` and specifies the path to the eBPF load balancing file within the af-packet configuration in `suricata.yaml`. This enables programmable load balancing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n  - interface: eth3\n    threads: 16\n    cluster-id: 97\n    cluster-type: cluster_ebpf\n    defrag: yes\n    # eBPF file containing a 'loadbalancer' function that will be inserted into the\n    # kernel and used as load balancing function\n    ebpf-lb-file:  /usr/libexec/suricata/ebpf/lb.bpf\n    ring-size: 200000\n```\n\n----------------------------------------\n\nTITLE: Configure SMB Parser\nDESCRIPTION: This code snippet demonstrates how to enable the SMB parser and specify the detection ports in Suricata's YAML configuration file. This allows Suricata to analyze SMB traffic on the defined ports.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_40\n\nLANGUAGE: yaml\nCODE:\n```\nsmb:\n  enabled: yes\n  detection-ports:\n    dp: 139, 445\n```\n\n----------------------------------------\n\nTITLE: Matching Flow Age in Suricata Rules\nDESCRIPTION: Demonstrates how to use the `flow.age` keyword in Suricata rules to match flows based on their age. The age can be matched exactly or compared using operators like `<`, `>`, `>=`, and `<=`. The example provided combines `flow.age` with `flowbits` to trigger an alert after the flow's age exceeds one hour.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_18\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.age:3\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.age:<3\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.age:>=2\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Flow longer than one hour\"; flow.age:>3600; flowbits: isnotset, onehourflow; flowbits: onehourflow, name; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Getting Packet Timestamp (Seconds & Microseconds) in Lua\nDESCRIPTION: Retrieves the packet's timestamp as two numbers: seconds and microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_2\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\nlocal sec, usec = p:timestamp()\n```\n\n----------------------------------------\n\nTITLE: Suricata Configuration for Myricom (YAML)\nDESCRIPTION: This YAML snippet configures Suricata to use the 'eth5' interface with 8 threads, a buffer size of 512kb, and disables checksum checks. The threads setting determines the number of reader threads created for the specified interface, while the Myricom driver attaches each thread to its own ring buffer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/myricom.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\npcap:\n  - interface: eth5\n    threads: 8\n    buffer-size: 512kb\n    checksum-checks: no\n```\n\n----------------------------------------\n\nTITLE: Configure MQTT Maximum Message Length\nDESCRIPTION: This configuration shows how to set the maximum message length for the MQTT parser in Suricata. This helps prevent denial-of-service issues by limiting the size of messages that Suricata will fully parse. Messages larger than the limit are logged with reduced metadata.  The value '1mb' specifies 1 megabyte.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_45\n\nLANGUAGE: yaml\nCODE:\n```\nmqtt:\n  max-msg-length: 1mb\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Example - Non-HTTP traffic on port 80\nDESCRIPTION: This Suricata rule generates an alert when non-HTTP traffic is detected on port 80. It uses the 'app-layer-protocol' keyword with negation and the 'final' mode to ensure the protocol is not HTTP after final detection, and the 'flow' keyword to only examine traffic flowing to the server.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/app-layer.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any 80 (msg:\"non-HTTP traffic over HTTP standard port\"; flow:to_server; app-layer-protocol:!http,final; sid:1; )\n```\n\n----------------------------------------\n\nTITLE: Matching Normalized HTTP URI in Suricata\nDESCRIPTION: This Suricata rule matches on the normalized HTTP URI. It uses the `http.uri` keyword along with the `content` keyword to search for a specific URI. The rule includes options like `flow`, `bsize`, `classtype`, `sid`, and `rev` for defining the flow direction, buffer size, classification, rule ID, and revision number, respectively.  Normalization removes double slashes and other inconsistencies.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP URI Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.uri; \\\n  content:\"/index.html\";` bsize:11; classtype:bad-unknown; sid:3; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Netmap Inline IDS Mode\nDESCRIPTION: This YAML configuration sets up Suricata in Netmap inline IDS mode, which is similar to IPS mode but does not enforce `drop` policies.  The `copy-mode` is set to `tap` to ensure that all packets are forwarded, even if they match a rule that would normally trigger a drop action. The `copy-iface` specifies where to copy the packets to.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nnetmap:\n  - interface: igb0\n    copy-mode: tap\n    copy-iface: igb1\n  - interface: igb1\n    copy-mode: tap\n    copy-iface: igb0\n```\n\n----------------------------------------\n\nTITLE: Netmap IPS Configuration - Single Interface Host Stack Mode\nDESCRIPTION: This YAML snippet demonstrates the Netmap configuration for Suricata in IPS mode using host stack mode with a single physical network interface.  It configures the interface, copy mode (IPS), and copy interface using the '^' notation to indicate host stack mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\n  - interface: enp60s0f0\n    copy-mode: ips\n    copy-iface: enp6s0f0^\n\nThe configuration on ``enp6s0f0^`` is symmetric ::\n\n  - interface: enp60s0f0^\n    copy-mode: ips\n    copy-iface: enp6s0f0\n```\n\n----------------------------------------\n\nTITLE: LDAP DN and Operation Match Alert Rule\nDESCRIPTION: This Suricata rule alerts if a packet has an LDAP search request operation and contains the LDAP distinguished name `dc=example,dc=com`. It uses the `ldap.request.operation` keyword with the operation name `search_request` and the `ldap.request.dn` keyword along with the `content` keyword to match the distinguished name. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAPDN and operation\"; :example-rule-emphasis:`ldap.request.operation:search_request; ldap.request.dn; content:\"dc=example,dc=com\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Defining a Suricata 'sid' Keyword\nDESCRIPTION: This snippet shows the syntax for the 'sid' (signature ID) keyword in a Suricata rule. The 'sid' assigns a unique identifier to each signature. This ID is crucial for tracking and managing rules. The value must be a positive integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nsid:123;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Negated Range Matching\nDESCRIPTION: This code snippet shows how to match an integer value that is outside of a specified range. `bsize:!19-22;` means the rule will match if the value of the `bsize` field is less than 19 or greater than 22.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:!19-22;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Websocket Flags Matching\nDESCRIPTION: This code snippet demonstrates how to match websocket flags using a comma-separated list of flag strings. The rule `websocket.flags:fin,!comp;` matches when the `fin` flag is set and the `comp` flag is not set.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nwebsocket.flags:fin,!comp;\n```\n\n----------------------------------------\n\nTITLE: Threshold Rule Example (limit type)\nDESCRIPTION: This example shows how to use the 'limit' type to prevent a flood of alerts. At most 1 alert is generated per host within a period of 3 minutes if \"MSIE 6.0\" is detected. It tracks by the source IP, has a count of 1, and a period of 180 seconds.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/thresholding.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert http $HOME_NET any -> any any (msg:\"ET INFO Internet Explorer 6 in use - Significant Security Risk\";\n   flow:established,to_server; http.user_agent; content:\"Mozilla/4.0 (compatible|3b| MSIE 6.0|3b|\";\n   :example-rule-emphasis:`threshold: type limit, track by_src, seconds 180, count 1;`\n   classtype:policy-violation; sid:2010706; rev:10; metadata:created_at 2010_07_30, updated_at 2024_03_16;)\n```\n\n----------------------------------------\n\nTITLE: Updating Suricata Rules\nDESCRIPTION: Updates Suricata rules using the `suricata-update` tool.  This command fetches the Emerging Threats Open ruleset, which is the default.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nsudo suricata-update\n```\n\n----------------------------------------\n\nTITLE: Suricata Pass Rule Example\nDESCRIPTION: This example illustrates a Suricata pass rule that allows all traffic to and from the IP address 1.2.3.4 without triggering alerts or drops. Although the traffic is passed, logs such as Eve or http.log are still generated for this traffic. The rule has a specific message and a unique SID (signature ID).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/ignoring-traffic.rst#_snippet_3\n\nLANGUAGE: suricata\nCODE:\n```\npass ip 1.2.3.4 any <> any any (msg:\"pass all traffic from/to 1.2.3.4\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Stats Logging in Suricata (YAML)\nDESCRIPTION: This snippet shows how to configure the stats.log file in Suricata. It enables stats logging, sets the filename, and configures whether to append to the existing log file on restart. The directory defaults to /var/log/suricata/ but can be overridden with an absolute path.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n  - stats:\n       enabled: yes               #By default, the stats-option is enabled\n       filename: stats.log        #The log-name. Combined with the default logging directory\n                                  #(default-log-dir) it will result in /var/log/suricata/stats.log.\n                                  #This directory can be overruled with a absolute path. (A\n                                  #directory starting with / ).\n       append: yes/no             #If this option is set to yes, the last filled fast.log-file will not be\n                                  #overwritten while restarting Suricata.\n```\n\n----------------------------------------\n\nTITLE: Suricata Config Rule Example\nDESCRIPTION: This example shows how to disable DNS transaction logging if a DNS query contains the string 'suricata'. It uses the 'config' keyword with 'logging disable', 'type tx', and 'scope tx' to achieve this.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/config.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nconfig dns any any -> any any (dns.query; content:\"suricata\"; config: logging disable, type tx, scope tx; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: PF_RING Interface Configuration (YAML)\nDESCRIPTION: This YAML snippet shows how to configure the network interface for PF_RING packet capture in Suricata. The `interface` option specifies the network interface (e.g., eth0) from which packets will be read. This is a fundamental setting for PF_RING, determining the source of network traffic for Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_56\n\nLANGUAGE: yaml\nCODE:\n```\npfring:\n  interface: eth0    # In this option you can set the network-interface\n                     # on which you want the packets of the network to be read.\n```\n\n----------------------------------------\n\nTITLE: Suricata af-packet Configuration\nDESCRIPTION: Configuration settings for af-packet capture in Suricata's `suricata.yaml` file. Sets interface, number of threads, cluster-id, and cluster-type to cluster_qm for optimized packet processing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\naf-packet:\n  - interface: eth1\n    threads: 16\n    cluster-id: 99\n    cluster-type: cluster_qm\n    ...\n```\n\n----------------------------------------\n\nTITLE: Suricata Eve Log Configuration\nDESCRIPTION: This configuration shows how to enable and configure eve-log output in Suricata's suricata.yaml file. It allows specifying the output type (file, syslog, unix_dgram, unix_stream), filename, and the types of events to log (e.g., alert, http). It also demonstrates how to enable extended HTTP logging and customize logged HTTP fields.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n   - eve-log:\n        enabled: yes\n        type: file #file|syslog|unix_dgram|unix_stream\n        filename: eve.json\n        # the following are valid when type: syslog above\n        #identity: \"suricata\"\n        #facility: local5\n        #level: Info ## possible levels: Emergency, Alert, Critical,\n                     ## Error, Warning, Notice, Info, Debug\n        types:\n          - alert\n          - http:\n              extended: yes     # enable this for extended logging information\n              # custom allows additional http fields to be included in eve-log\n              # the example below adds three additional fields when uncommented\n              #custom: [Accept-Encoding, Accept-Language, Authorization]\n              custom: [accept, accept-charset, accept-encoding, accept-language,\n              accept-datetime, authorization, cache-control, cookie, from,\n              max-forwards, origin, pragma, proxy-authorization, range, te, via,\n              x-requested-with, dnt, x-forwarded-proto, accept-range, age,\n              allow, connection, content-encoding, content-language,\n              content-length, content-location, content-md5, content-range,\n              content-type, date, etags, expires, last-modified, link, location,\n              proxy-authenticate, referer, refresh, retry-after, server,\n              set-cookie, trailer, transfer-encoding, upgrade, vary, warning,\n              www-authenticate, x-flash-version, x-authenticated-user]\n```\n\n----------------------------------------\n\nTITLE: Suricata threading configuration in suricata.yaml\nDESCRIPTION: This snippet demonstrates how to configure threading in Suricata's suricata.yaml file.  It sets CPU affinity for management, receive, and worker threads, including exclusive mode and priority settings. Defines which CPUs are dedicated to each type of thread.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nthreading:\n set-cpu-affinity: yes\n cpu-affinity:\n  - management-cpu-set:\n  cpu: [ \"120-127\" ]  # include only these cpus in affinity settings\n  - receive-cpu-set:\n  cpu: [ 0 ]  # include only these cpus in affinity settings\n  - worker-cpu-set:\n  cpu: [ \"8-55\" ]\n  mode: \"exclusive\"\n  prio:\n  high: [ \"8-55\" ]\n  default: \"high\"\n```\n\n----------------------------------------\n\nTITLE: Configure SMTP Raw Extraction\nDESCRIPTION: This configuration enables raw extraction for the SMTP parser in Suricata. When enabled, the entire SMTP conversation (headers and body) is stored as a file named \"rawmsg\". This allows signatures to match on the raw content of the email. This setting is incompatible with `decode-mime`. If both are enabled, `raw-extraction` will be disabled automatically.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_46\n\nLANGUAGE: yaml\nCODE:\n```\nsmtp:\n  # extract messages in raw format from SMTP\n  raw-extraction: true\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Base64 Decoding with Relative Offset\nDESCRIPTION: This Suricata rule demonstrates how to decode a base64 encoded string (\"test\") within the http_uri buffer, starting relative to the string \"somestring\" with an offset of 1. The base64_decode keyword decodes the data, and base64_data makes it available for content matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/base64-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"Example\"; http.uri; content:\"somestring\"; \\\n     base64_decode:bytes 8, offset 1, relative; \\\n     base64_data; content:\"test\"; sid:10001; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Enabling fileinfo logging in eve output\nDESCRIPTION: This code snippet shows how to enable fileinfo logging in Suricata's eve output.  It configures the eve-log output type to include file information with options to force magic and hash calculations. This configuration is required to output file metadata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/file-extraction.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n  - outputs:\n      - eve-log:\n        types:\n\t    - files:\n\t        force-magic: no\n\t        force-hash: [md5,sha256]\n```\n\n----------------------------------------\n\nTITLE: PCRE Keyword Example in Suricata Rule: IRC Nick Matching\nDESCRIPTION: This code snippet shows a complete Suricata rule using the `pcre` keyword to detect a likely bot nick in IRC traffic.  It checks for \"NICK \" followed by \"USA\" and at least three digits.  The rule uses flowbits, content matching, and references an external threat document.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\ndrop tcp $HOME_NET any -> $EXTERNAL_NET any (msg:\"ET TROJAN Likely Bot Nick in IRC (USA +..)\"; flow:established,to_server; flowbits:isset,is_proto_irc; content:\"NICK \"; :example-rule-emphasis:`pcre:\"/NICK .*USA.*[0-9]{3,}/i\";` reference:url,doc.emergingthreats.net/2008124; classtype:trojan-activity; sid:2008124; rev:2;)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Flow String Variable\nDESCRIPTION: This Lua code accesses and modifies a Flow string variable at index 0 (assumed to be 'cnt'). It retrieves the current value, increments it as a number, converts the incremented number back to a string, and then sets the flow variable to the new string value using `SCFlowvarSet`. The length of the string is passed as an argument to `SCFlowvarSet`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_51\n\nLANGUAGE: Lua\nCODE:\n```\nfunction match(args)\n    a = SCFlowvarGet(0);\n    if a then\n        a = tostring(tonumber(a)+1)\n        SCFlowvarSet(0, a, #a)\n    else\n        a = tostring(1)\n        SCFlowvarSet(0, a, #a)\n    end\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Header Names and Order\nDESCRIPTION: These Suricata rules demonstrate matching HTTP header names and their order in requests/responses. They use the `http.header_names` keyword along with content matching to enforce a specific header sequence. The `flow` keyword distinguishes between client and server traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_35\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Names Request \\\n  Example\"; flow:established,to_server; :example-rule-options:`http.header_names; \\\n  content:\"|0d 0a|Host|0d 0a|Connection|0d 0a 0d 0a|;\";` bsize:22; \\\n  classtype:bad-unknown; sid:110; rev:1;)\n\n  alert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Header Names Response \\\n  Example\"; flow:established,to_client; :example-rule-options:`http.header_names; \\\n  content:\"|0d 0a|Content-Type|0d 0a|Server|0d 0a 0d a0|;\";` bsize:26; \\\n  classtype:bad-unknown; sid:111; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Detect Thread Ratio in Suricata\nDESCRIPTION: This snippet configures the detect thread ratio, which determines the number of detection threads relative to the number of CPU cores. Setting it to 1.5 results in more detection threads than cores, potentially improving performance when threads are waiting.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_25\n\nLANGUAGE: yaml\nCODE:\n```\ndetect-thread-ratio: 1.5\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Publish Topic\nDESCRIPTION: This example demonstrates matching the topic of a MQTT PUBLISH message using the `mqtt.publish.topic` keyword combined with content matching. It matches when the topic is \"mytopic\". The publish topic is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_18\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.publish.topic; content:\"mytopic\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Alert Debug Log Output Configuration (YAML)\nDESCRIPTION: This configuration defines the settings for the alert-debug.log output, which provides supplementary information about alerts. It specifies whether the log is enabled and the filename. This log type is useful for debugging and writing signatures but can impact performance due to the amount of information stored.  The `enabled` parameter activates/deactivates the logging and `filename` sets the name of the log file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n  - alert-debug:                  #The log-name.\n      enabled: no                 #This log is not enabled. Set 'yes' to enable.\n      filename: alert-debug.log   #The name of the file in the default logging directory.\n```\n\n----------------------------------------\n\nTITLE: Suricata Suppress Rule Example\nDESCRIPTION: This example shows a Suricata suppress rule that prevents alerts from being generated for traffic originating from the IP address 1.2.3.4. The rule uses `track by_src` to suppress alerts based on the source IP, and specifies the generator ID (gen_id) and signature ID (sig_id) to match. Note that suppression is only considered after rule matching, which makes this method less efficient than capture filters or pass rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/ignoring-traffic.rst#_snippet_4\n\nLANGUAGE: suricata\nCODE:\n```\nsuppress gen_id 0, sig_id 0, track by_src, ip 1.2.3.4\n```\n\n----------------------------------------\n\nTITLE: Checking DPDK Version (Bash)\nDESCRIPTION: This command checks the installed version of the DPDK library using `pkg-config`. `pkg-config` is a tool for retrieving information about installed libraries.  It uses the `--modversion` option to query the version of the `libdpdk` module.  A properly configured `pkg-config` is essential for Suricata's configuration and compilation when using DPDK.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_55\n\nLANGUAGE: bash\nCODE:\n```\npkg-config --modversion libdpdk\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Unsubscribe Topic\nDESCRIPTION: This example demonstrates matching a topic in a MQTT UNSUBSCRIBE message using the `mqtt.unsubscribe.topic` keyword combined with content matching. It matches when the topic is \"mytopic\". The unsubscribe topic is a 'sticky buffer' and supports multi-buffer matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_20\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.unsubscribe.topic; content:\"mytopic\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Bsize Example\nDESCRIPTION: This example demonstrates the usage of the 'bsize' keyword in Suricata rules to match on the buffer length. It is used in conjunction with content matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_5\n\nLANGUAGE: suricata\nCODE:\n```\nalert dns any any -> any any (msg:\"bsize exact buffer size\"; dns.query; content:\"google.com\"; bsize:10; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Capturing Live Traffic with Suricata\nDESCRIPTION: This command captures live network traffic from the specified interface (eno1 in this example) using Suricata.  Suricata will analyze the traffic based on its configuration and rules and generate alerts and logs. No specific dependencies are listed, but suricata must be installed and configured.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/manpages/suricata.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -i eno1\n```\n\n----------------------------------------\n\nTITLE: Using tcp.flags with prefilter in Suricata\nDESCRIPTION: This example demonstrates using the `tcp.flags` content with the `prefilter` keyword in a Suricata rule. The `prefilter` keyword optimizes rule processing by quickly filtering packets based on the specified TCP flags, making it an efficient approach for high-performance intrusion detection.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"Example tcp.flags sig\";\n   :example-rule-emphasis:`tcp.flags:FPU,CE; prefilter;` classtype:misc-activity; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: File SHA256 Whitelisting\nDESCRIPTION: This Suricata rule example demonstrates using the `filesha256` keyword with negation (`!`) for whitelisting files based on their SHA256 hash. The file 'sha256-whitelist' contains a list of SHA256 hashes that are considered safe. The rule will not alert if a file's SHA256 hash matches an entry in this whitelist.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesha256:!sha256-whitelist;\n```\n\n----------------------------------------\n\nTITLE: Suricata CPU Affinity Configuration\nDESCRIPTION: Configuration settings for CPU affinity in Suricata's `suricata.yaml` file. Sets CPU sets for management, receive, and worker threads to specific CPU cores. It uses the 'exclusive' mode for worker CPUs and defines priorities.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n# Suricata is multi-threaded. Here the threading can be influenced.\nthreading:\n  cpu-affinity:\n    - management-cpu-set:\n        cpu: [ \"1-10\" ]  # include only these CPUs in affinity settings\n    - receive-cpu-set:\n        cpu: [ \"0-10\" ]  # include only these CPUs in affinity settings\n    - worker-cpu-set:\n        cpu: [ \"18-35\", \"54-71\" ]\n        mode: \"exclusive\"\n        prio:\n          low: [ 0 ]\n          medium: [ \"1\" ]\n          high: [ \"18-35\",\"54-71\" ]\n          default: \"high\"\n```\n\n----------------------------------------\n\nTITLE: Engine Analysis Configuration\nDESCRIPTION: This YAML snippet enables engine analysis in Suricata, which provides information about signature and pattern matching. When enabled, Suricata generates a log file containing details about which pattern is used for each signature.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_66\n\nLANGUAGE: yaml\nCODE:\n```\nengine-analysis:\n   rules-fast-pattern: yes\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hassh Server MD5 in Lua\nDESCRIPTION: This script calls HasshServerGet() and returns the MD5 of hassh algorithms used by the server.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_42\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    hassh_string = HasshServerGet()\n    if hassh == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: PF_RING Cluster Type Configuration (YAML)\nDESCRIPTION: This YAML snippet sets the cluster type for PF_RING load balancing. The `cluster-type` option determines how traffic is distributed across acquisition threads within the same cluster. Options include `cluster_flow`, `cluster_inner_flow_*`, and `cluster_round_robin`. `cluster_flow` is the default and `cluster_round_robin` is not recommended. VLAN considerations are also included when choosing `cluster_inner_flow` cluster types.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_58\n\nLANGUAGE: yaml\nCODE:\n```\ncluster-type: cluster_inner_flow_5_tuple\n```\n\n----------------------------------------\n\nTITLE: Stopping Suricata service\nDESCRIPTION: This command stops the Suricata service using systemctl.  It requires sudo privileges to execute. The command halts the Suricata intrusion detection system.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl stop suricata\n```\n\n----------------------------------------\n\nTITLE: PF_RING Cluster ID Configuration (YAML)\nDESCRIPTION: This YAML snippet configures the cluster ID for PF_RING. The `cluster-id` option assigns a unique identifier to a cluster of packet acquisition threads.  All threads participating in load balancing should have the same cluster ID.  This ID must be unique across the system to avoid conflicts with other engines or programs using PF_RING clusters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_57\n\nLANGUAGE: yaml\nCODE:\n```\ncluster-id: 99\n```\n\n----------------------------------------\n\nTITLE: Configuring Flow Timeouts in Suricata\nDESCRIPTION: This snippet configures flow timeouts for different protocols (TCP, UDP, ICMP, and default) in Suricata. It specifies timeouts for new, established, and closed states, as well as emergency modes, controlling how long Suricata keeps flow information in memory. Timeouts are specified in seconds.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_31\n\nLANGUAGE: yaml\nCODE:\n```\nflow-timeouts:\n\n  default:\n    new: 30                     #Time-out in seconds after the last activity in this flow in a New state.\n    established: 300            #Time-out in seconds after the last activity in this flow in a Established\n                                #state.\n    emergency-new: 10           #Time-out in seconds after the last activity in this flow in a New state\n                                #during the emergency mode.\n    emergency-established: 100  #Time-out in seconds after the last activity in this flow in a Established\n                                #state in the emergency mode.\n  tcp:\n    new: 60\n    established: 3600\n    closed: 120\n    emergency-new: 10\n    emergency-established: 300\n    emergency-closed: 20\n  udp:\n    new: 30\n    established: 300\n    emergency-new: 10\n    emergency-established: 100\n  icmp:\n    new: 30\n    established: 300\n    emergency-new: 10\n    emergency-established: 100\n```\n\n----------------------------------------\n\nTITLE: Allocating Hugepages (Bash)\nDESCRIPTION: These commands allocate 2GB of memory in hugepages across all available NUMA nodes using `dpdk-hugepages.py`. The alternative method uses `tee` to write the number of desired hugepages (1024 in this example, for 2MB pages) to the `nr_hugepages` file for NUMA node 0.  The number of hugepages needed depends on the memory requirements of the DPDK application and the size of the hugepages (2MB or 1GB). The first option is recommended as it sets up hugepages for all NUMA nodes and the second only configures NUMA node 0.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\nsudo dpdk-hugepages.py --setup 2G\n```\n\nLANGUAGE: bash\nCODE:\n```\necho 1024 | sudo tee \\\n  /sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages\n```\n\n----------------------------------------\n\nTITLE: Community Flow ID Configuration for EVE JSON Output\nDESCRIPTION: This example shows how to configure Suricata to add a `community_id` field to each EVE JSON output. This is useful when used with tools like Bro/Zeek. The community id is generated based on network flow characteristics.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_12\n\nLANGUAGE: Example\nCODE:\n```\n    {\n      \"timestamp\": \"2003-12-16T13:21:44.891921+0000\",\n      \"flow_id\": 1332028388187153,\n      \"pcap_cnt\": 1,\n      \"event_type\": \"alert\",\n      ...\n      \"community_id\": \"1:LQU9qZlK+B5F3KDmev6m5PMibrg=\",\n      \"alert\": {\n```\n\n----------------------------------------\n\nTITLE: Retrieving TLS Certificate Information in Lua\nDESCRIPTION: This code snippet demonstrates how to retrieve TLS certificate information using the `TlsGetCertInfo()` function, which returns the version, subject, issuer, and fingerprint of the certificate.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_21\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    version, subject, issuer, fingerprint = TlsGetCertInfo()\n    if version == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting File Permissions for Suricata Library Directory\nDESCRIPTION: These commands modify the group ownership and permissions of the /var/lib/suricata directory. They set the group to 'suricata' and grant read, write, and setgid permissions to the group.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nchgrp -R suricata /var/lib/suricata\nchmod -R g+srw /var/lib/suricata\n```\n\n----------------------------------------\n\nTITLE: Suricata Stream Size Matching Example\nDESCRIPTION: This example demonstrates how to use the `stream_size` keyword to match traffic based on the registered amount of bytes by the sequence numbers. It uses the `both` modifier to check the stream size in both directions and alerts if the total size is greater than 5000 bytes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (stream_size:both, >, 5000; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Example: app-layer-protocol keyword\nDESCRIPTION: This example demonstrates the use of the `app-layer-protocol` keyword in Suricata. This keyword can be used to specify the application layer protocol to be detected, regardless of the port being used. It provides an alternative approach to protocol detection when combined with 'any' for port specification.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nalert tcp $HOME_NET any -> $EXTERNAL_NET any (app-layer-protocol:http; ...\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching DCERPC Interface UUID\nDESCRIPTION: This Suricata rule demonstrates how to match a specific DCERPC interface UUID. It uses the `dce_iface` keyword to identify packets with the interface UUID 00000143-0000-0000-c000-000000000046.  The rule is designed to detect WMI remote process execution attempts.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dcerpc-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> $HOME_NET any (msg:\"ET NETBIOS DCERPC WMI Remote Process Execution\"; flow:to_server,established; dce_iface:00000143-0000-0000-c000-000000000046; classtype:bad-unknown; sid:2027167; rev:1; metadata:affected_product Windows_XP_Vista_7_8_10_Server_32_64_Bit, attack_target Client_Endpoint, created_at 2019_04_09, deployment Internal, former_category NETBIOS, signature_severity Informational, updated_at 2019_04_09;)\n```\n\n----------------------------------------\n\nTITLE: Detecting Expired TLS Certificates in Suricata\nDESCRIPTION: This example demonstrates how to use the `tls_cert_expired` keyword in Suricata to detect if a TLS certificate is expired. This keyword evaluates the validity dates within the certificate.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls_cert_expired;\n```\n\n----------------------------------------\n\nTITLE: Suricata Unix Socket command: dataset-add\nDESCRIPTION: This is an example showing how to add data to a dataset using the Suricata Unix socket. This command immediately adds 'google.com' (base64 encoded) to the set 'myset' as a string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_12\n\nLANGUAGE: Text\nCODE:\n```\ndataset-add myset string Z29vZ2xlLmNvbQ==\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Configuration\nDESCRIPTION: This configuration snippet shows how to configure Suricata to load rules from the /var/lib/suricata/rules/ directory. The `default-rule-path` sets the base path, and `rule-files` specifies the rule file to load.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-rule-path: /var/lib/suricata/rules\nrule-files:\n  - suricata.rules\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Header Existence\nDESCRIPTION: These Suricata rules match on the existence of specific HTTP headers. They use the `http.header_names` keyword to check for the presence of 'Host' and 'Content-Type' headers, respectively, in HTTP requests and responses.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_36\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Names Request \\\n  Example 2\"; flow:established,to_server; :example-rule-options:`http.header_names; \\\n  content:\"|0d 0a|Host|0d 0a|;\";` classtype:bad-unknown; sid:112; rev:1;)\n\n  alert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Header Names Response \\\n  Example 2\"; flow:established,to_client; :example-rule-options:`http.header_names; \\\n  content:\"|0d 0a|Content-Type|0d 0a|;\";` classtype:bad-unknown; sid:113; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Getting flow tuple information in Lua\nDESCRIPTION: This snippet retrieves the IP version (4 or 6), source IP address, destination IP address (as strings), IP protocol (as integer), source port, and destination port (as integers) from the flow.  The protocol value is derived from the IP header. It returns six values representing the flow tuple information.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_5\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\nipver, srcip, dstip, proto, sp, dp = f:tuple()\n```\n\n----------------------------------------\n\nTITLE: Suricata AF-Packet Configuration - YAML\nDESCRIPTION: This snippet shows the Suricata configuration required to activate hardware mode and disable the `use-percpu-hash` option in the `af-packet` configuration for the interface. It also sets the `cluster_qm` as the cluster type for load balancing based on IP pairs in the eBPF code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_21\n\nLANGUAGE: YAML\nCODE:\n```\n    xdp-mode: hw\n    use-percpu-hash: no\n```\n\n----------------------------------------\n\nTITLE: Splitting Configuration with Include (Multiple Sections)\nDESCRIPTION: This example demonstrates using 'include' to include entire sections from another YAML file. This provides a way to split the suricata.yaml into more manageable pieces. If sections are redefined after the include statement, they will be overwritten.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n# host_1.yaml\n\nmax-pending-packets: 2048\n\noutputs:\n    - fast\n        enabled: yes\n        filename: fast.log\n        append: yes\n```\n\nLANGUAGE: yaml\nCODE:\n```\n# suricata.yaml\n\ninclude: host_1.yaml\n\n...\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto-config with CPU Affinity in Suricata YAML\nDESCRIPTION: This YAML snippet configures Suricata to use Napatech with CPU affinity. It enables CPU affinity, specifies CPU sets, enables Napatech auto-config, and defines ports and the hashmode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_8\n\nLANGUAGE: YAML\nCODE:\n```\nthreading:\n    set-cpu-affinity: yes\n    cpu-affinity:\n      management-cpu-set:\n        cpu: [ 0 ]\n      receive-cpu-set:\n        cpu: [ 0 ]\n      worker-cpu-set:\n        cpu: [ all ]\n        .\n        .\n        .\n  napatech:\n    auto-config: yes\n    ports: [all]\n    hashmode: hash5tuplesorted\n```\n\n----------------------------------------\n\nTITLE: Configuring Prefilter Engine in Suricata (YAML)\nDESCRIPTION: This snippet demonstrates configuring the prefilter engine in Suricata.  It shows how to set the default prefilter engine (mpm or auto), and how to enable prefiltering for specific rules using the 'prefilter' keyword. The default is MPM/fast_pattern. 'auto' lets Suricata decide.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\n  detect:\n    prefilter:\n      default: mpm\n```\n\nLANGUAGE: yaml\nCODE:\n```\n  alert ip any any -> any any (ttl:123; prefilter; sid:1;)\n```\n\nLANGUAGE: yaml\nCODE:\n```\n  detect:\n    prefilter:\n      default: auto\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Alerting on Username Count Threshold\nDESCRIPTION: This example demonstrates how to use `flowint` to count username occurrences and generate an alert only when the count exceeds a threshold (5 in this case). It increments `usernamecount` and then checks if it's greater than 5.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"More than Five Usernames!\"; content:\"jonkman\"; \\\n        flowint: usernamecount, +, 1; flowint:usernamecount, >, 5;)\n```\n\n----------------------------------------\n\nTITLE: Triggering Suricata Alert\nDESCRIPTION: Triggers the Suricata rule with SID 2100498 by making an HTTP request to `testmynids.org`. This causes an alert to be logged in `fast.log`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\ncurl http://testmynids.org/uid/index.html\n```\n\n----------------------------------------\n\nTITLE: Example of datarep content\nDESCRIPTION: This shows an example entry in a datarep file, containing both the data and the reputation value. The data is separated from the value by a comma.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_16\n\nLANGUAGE: Text\nCODE:\n```\n<data>,<value>\n```\n\n----------------------------------------\n\nTITLE: Engine Analysis: Packet Rule\nDESCRIPTION: This JSON snippet represents the Engine Analysis report for a Suricata packet rule with anchored content. It includes details such as the rule's ID, message, requirements (payload, real_pkt), type (pkt), packet engine configurations, and information about content matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"raw\": \"alert tcp-pkt any any -> any any (msg:\\\"tcp-pkt, anchored content\\\"; content:\\\"abc\\\"; startswith; sid:203;)\",\n  \"id\": 203,\n  \"gid\": 1,\n  \"rev\": 0,\n  \"msg\": \"tcp-pkt, anchored content\",\n  \"app_proto\": \"unknown\",\n  \"requirements\": [\n    \"payload\",\n    \"real_pkt\"\n  ],\n  \"type\": \"pkt\",\n  \"flags\": [\n    \"src_any\",\n    \"dst_any\",\n    \"sp_any\",\n    \"dp_any\",\n    \"need_packet\",\n    \"toserver\",\n    \"toclient\",\n    \"prefilter\"\n  ],\n  \"pkt_engines\": [\n    {\n      \"name\": \"payload\",\n      \"is_mpm\": true\n    }\n  ],\n  \"frame_engines\": [],\n  \"lists\": {\n    \"payload\": {\n      \"matches\": [\n        {\n          \"name\": \"content\",\n          \"content\": {\n            \"pattern\": \"abc\",\n            \"length\": 3,\n            \"nocase\": false,\n            \"negated\": false,\n            \"starts_with\": true,\n            \"ends_with\": false,\n            \"is_mpm\": true,\n            \"no_double_inspect\": false,\n            \"depth\": 3,\n            \"fast_pattern\": false,\n            \"relative_next\": false\n          }\n        }\n      ]\n    }\n  },\n  \"mpm\": {\n    \"buffer\": \"payload\",\n    \"pattern\": \"abc\",\n    \"length\": 3,\n    \"nocase\": false,\n    \"negated\": false,\n    \"starts_with\": true,\n    \"ends_with\": false,\n    \"is_mpm\": true,\n    \"no_double_inspect\": false,\n    \"depth\": 3,\n    \"fast_pattern\": false,\n    \"relative_next\": false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving JA3S String for Logging in Lua\nDESCRIPTION: This code snippet demonstrates how to retrieve the JA3S string using the `Ja3SGetString()` function within a Suricata Lua script, primarily for logging.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_33\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    str = Ja3SGetString()\n    if str == nil then\n      return\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Byte Variable Access\nDESCRIPTION: This Lua code initializes access to byte variables named `var1` and `var2`. It populates the `needs[\"bytevar\"]` table with the names of the byte variables that will be accessed. These variables are defined by `byte_extract` or `byte_math` in Suricata rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_53\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init(args)\n    local needs = {}\n    needs[\"bytevar\"] = {\"var1\", \"var2\"}\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Reputation Files in Suricata\nDESCRIPTION: This YAML list specifies the reputation files to load.  If the path is absolute, the file is loaded directly. Otherwise, the `default-reputation-path` is prepended.  These files are reloaded on USR2 signal.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/reputation/ipreputation/ip-reputation-config.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nreputation-files:\n - badhosts.list\n - knowngood.list\n - sharedhosting.list\n```\n\n----------------------------------------\n\nTITLE: SMTP stream frame example\nDESCRIPTION: This example showcases the use of the `smtp.stream` frame to inspect the entire TCP data stream of an SMTP session. The rule checks for a sequence of bytes representing \"250 ok\", a newline, and \"354 go ahead\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any (flow:to_client; \\\n  :example-rule-options:`frame:smtp.stream; content:\"250 ok|0d 0a|354 go ahead\";` \\\n  sid:1;)\n```\n\n----------------------------------------\n\nTITLE: SMTP file.name keyword example\nDESCRIPTION: This example demonstrates how to use the `file.name` keyword in a Suricata rule to detect specific filenames in SMTP traffic. The rule checks for the presence of \"winmail.dat\" using the `file.name` keyword.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"SMTP file.name usage\"; \\\n  :example-rule-options:`file.name; content:\"winmail.dat\";` \\\n  classtype:bad-unknown; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with id Keyword\nDESCRIPTION: This example demonstrates how to use the `id` keyword to match a specific IP ID value. This rule alerts if the IP ID is 1 and contains specific content.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"id keyword example\"; id:1; content:\"content|3a 20|\"; fast_pattern; classtype:misc-activity; sid:12; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Flow Engine Settings in Suricata\nDESCRIPTION: This snippet configures the flow engine settings in Suricata, including the memory cap, memory cap policy, hash size, and preallocation of flows. It also configures rate tracking for flows to identify elephant flows.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_29\n\nLANGUAGE: yaml\nCODE:\n```\nflow:\n  memcap: 33554432              #The maximum amount of bytes the flow-engine will make use of.\n  memcap-policy: bypass         #How to handle the flow if memcap is reached (IPS mode)\n  hash-size: 65536              #Flows will be organized in a hash-table. With this option you can set the\n                                #size of the hash-table.\n  prealloc: 10000               #The amount of flows Suricata has to keep ready in memory.\n  rate-tracking:                #Enable tracking of flows by the following rate definition; mark them\n                                #as elephant flows if they exceed the defined rate. Disabled by default.\n    bytes: 1GiB                 #Number of bytes to track\n    interval: 10                #Time interval in seconds for which tracking should be done\n```\n\n----------------------------------------\n\nTITLE: Configuring Netmap Interfaces in Suricata YAML\nDESCRIPTION: This YAML configuration defines multiple Netmap interfaces for Suricata to use, specifying the interface name and the number of capture threads for each.  The `netmap` block configures the Netmap interfaces. `interface` specifies the interface name, and `threads` sets the number of capture threads to use for that interface. This configuration is useful when the NIC has symmetric RSS hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nnetmap:\n  - interface: igb0\n    threads: 2\n  - interface: igb1\n    threads: 4\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file magic (filemagic keyword)\nDESCRIPTION: This Suricata rule example demonstrates the `filemagic` keyword. This keyword operates like `file.magic`, but defaults to case-insensitive matching. The rule alerts if a file identified as \"executable for MS Windows\" (case-insensitive) by libmagic is seen.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nfilemagic:\"executable for MS Windows\";\n```\n\n----------------------------------------\n\nTITLE: Inspecting DNS Query with Content Matching in Suricata Rules\nDESCRIPTION: This snippet shows how to inspect the DNS query name and match specific content within it using the `dns.query` sticky buffer in a Suricata rule. It requires a following payload keyword, such as `content`.  The `nocase` keyword makes the match case-insensitive.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert dns any any -> any any (msg:\"Test dns.query option\"; dns.query; content:\"google\"; nocase; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring eBPF Bypass (YAML)\nDESCRIPTION: This YAML snippet configures Suricata to use eBPF for bypass. It sets the `bypass` option to `yes` and specifies the path to the eBPF filter file within the af-packet configuration in `suricata.yaml`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n  - interface: eth3\n    threads: 16\n    cluster-id: 97\n    cluster-type: cluster_qm # symmetric RSS hashing is mandatory to use this mode\n    # eBPF file containing a 'filter' function that will be inserted into the\n    # kernel and used as packet filter function\n    ebpf-filter-file:  /usr/libexec/suricata/ebpf/bypass_filter.bpf\n    bypass: yes\n    ring-size: 200000\n```\n\n----------------------------------------\n\nTITLE: Find Unique HTTP User Agents with jq\nDESCRIPTION: This command extracts unique HTTP user agents from the eve.json file and counts their occurrences. It groups the user agents and then formats the output as a key-value pair with the user agent and its count.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-examplesjq.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat eve.json | jq -s '[.[]|.http.http_user_agent]|group_by(.)|map({key:.[0],value:(.|length)})|from_entries'\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Response Header in Lua\nDESCRIPTION: This example demonstrates how to retrieve a specific HTTP response header, such as the 'Server' header, using the `HttpGetResponseHeader()` function and print its value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_9\n\nLANGUAGE: lua\nCODE:\n```\nserver = HttpGetResponseHeader(\"Server\");\nprint (\"Server: \" .. server);\n```\n\n----------------------------------------\n\nTITLE: Matching CIP Service, Class and Attribute in Suricata Rules\nDESCRIPTION: The `cip_service` keyword is used to match against the CIP Service, Class, and Attribute, which are comma-separated values. The values are described in the CIP specification. This keyword helps in identifying specific CIP services, classes, or attributes within network traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\ncip_service:75\n```\n\nLANGUAGE: Suricata\nCODE:\n```\ncip_service:16,246,6\n```\n\n----------------------------------------\n\nTITLE: Disabling Teredo Decoder in Suricata\nDESCRIPTION: This snippet demonstrates how to disable or configure the Teredo decoder in Suricata. The Teredo decoder can be disabled if it is known to be inaccurate in detecting Teredo traffic.  The `ports` option allows specifying specific UDP ports for Teredo detection, defaulting to port 3544 if no ports are specified.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_70\n\nLANGUAGE: yaml\nCODE:\n```\ndecoder:\n  # Teredo decoder is known to not be completely accurate\n  # it will sometimes detect non-teredo as teredo.\n  teredo:\n    enabled: true\n    # ports to look for Teredo. Max 4 ports. If no ports are given, or\n    # the value is set to 'any', Teredo detection runs on _all_ UDP packets.\n    ports: $TEREDO_PORTS # syntax: '[3544, 1234]'\n```\n\n----------------------------------------\n\nTITLE: Negating DNS Rcode Value in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to negate matching a specific rcode value in the DNS header using the `dns.rcode` keyword in a Suricata rule. The `!` character negates the match. The rcode is an unsigned 8-bit integer representing the response code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.rcode:!0;\n```\n\n----------------------------------------\n\nTITLE: Matching SSL/TLS Record Version in Suricata\nDESCRIPTION: This example demonstrates matching the SSL/TLS record version using the `ssl_version` keyword in Suricata. It includes matching a specific version and matching multiple versions simultaneously.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"match TLSv1.2\"; \\\n    ssl_version:tls1.2; sid:200030;)\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"match SSLv2 and SSLv3\"; \\\n    ssl_version:sslv2,sslv3; sid:200031;)\n```\n\n----------------------------------------\n\nTITLE: Threaded File Output Configuration for EVE JSON\nDESCRIPTION: This snippet configures threaded file output for EVE JSON. When enabled, each output thread writes to individual files, with a unique identifier added to the filename. All the files produced must be considered together.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_7\n\nLANGUAGE: Config\nCODE:\n```\n   outputs:\n     - eve-log:\n         filename: eve.json\n         threaded: on\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Request Headers\nDESCRIPTION: Retrieves the HTTP request headers using the `request_headers()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_12\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nhttp_request_headers = tx:request_headers()\nprint(http_request_headers)\n```\n\n----------------------------------------\n\nTITLE: Restarting Suricata Service\nDESCRIPTION: Restarts the Suricata service using `systemctl restart suricata` after updating rules or modifying configuration. This ensures that the changes are applied.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nsudo systemctl restart suricata\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Subject Alternative Name in Suricata\nDESCRIPTION: This example illustrates how to match against the Subject Alternative Name (SAN) field of a TLS/SSL certificate using the `tls.subjectaltname` keyword in Suricata. It uses the `content` keyword to match a specific hexadecimal string representing a domain name.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.subjectaltname; content:\"|73 75 72 69 63 61 74 61 2e 69 6f|\";\n```\n\n----------------------------------------\n\nTITLE: Installing from Package Repositories (CentOS 7)\nDESCRIPTION: This command sequence installs Suricata using yum on CentOS 7. It enables the EPEL repository, the Suricata COPR repository, and then installs the Suricata package. Requires sudo.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_4\n\nLANGUAGE: none\nCODE:\n```\nsudo yum install epel-release yum-plugin-copr\nsudo yum copr enable @oisf/suricata-7.0\nsudo yum install suricata\n```\n\n----------------------------------------\n\nTITLE: Matching ICMP Type with itype Keyword in Suricata\nDESCRIPTION: This example shows how to use the `itype` keyword in a Suricata rule to match on a specific ICMP type.  The example looks for an ICMP type of 8, which corresponds to Echo Request. This is often used in network reconnaissance detection.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_20\n\nLANGUAGE: Suricata\nCODE:\n```\nalert icmp $EXTERNAL_NET any -> $HOME_NET any (msg:\"GPL SCAN Broadscan Smurf Scanner\"; dsize:4; icmp_id:0; icmp_seq:0; :example-rule-emphasis:`itype:8;` classtype:attempted-recon; sid:2100478; rev:4;)\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Certificate Issuer with Suricata\nDESCRIPTION: This example demonstrates how to match the Issuer field of a TLS/SSL certificate using the `tls.cert_issuer` keyword in Suricata.  It includes examples with `content`, `nocase`, `isdataat`, `relative` and `pcre` modifiers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.cert_issuer; content:\"WoSign\"; nocase; isdataat:!1,relative;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.cert_issuer; content:\"StartCom\"; nocase; pcre:\"/StartCom$/\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom HTTP Logging in Suricata\nDESCRIPTION: This code snippet demonstrates how to configure custom HTTP logging in Suricata. It sets the `enabled`, `filename`, and `custom` options, along with defining a `customformat` string to specify the desired log output format.  The `append` option controls whether logs are appended to the file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/custom-http-logging.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n  - http-log:\n        enabled: yes\n        filename: http.log\n        custom: yes # enable the custom logging format (defined by custom format)\n        customformat: \"%{%D-%H:%M:%S}t.%z %{X-Forwarded-For}i %{User-agent}i %H %m %h %u %s %B %a:%p -> %A:%P\"\n        append: no\n        #extended: yes     # enable this for extended logging information\n        #filetype: regular # 'regular', 'unix_stream' or 'unix_dgram'\n```\n\n----------------------------------------\n\nTITLE: AF_PACKET IPS Configuration with eBPF\nDESCRIPTION: This YAML configuration shows how to configure Suricata to act as an IPS between two interfaces (eth0 and eth1) using AF_PACKET capture method and eBPF load balancing. It defines interfaces, threads, copy mode, eBPF lb file and other parameters for IPS operation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\naf-packet:\n  - interface: eth0\n    threads: 16\n    defrag: no\n    cluster-type: cluster_ebpf\n    ebpf-lb-file: /usr/libexec/suricata/ebpf/lb.bpf\n    cluster-id: 98\n    copy-mode: ips\n    copy-iface: eth1\n    buffer-size: 64535\n  - interface: eth1\n    threads: 16\n    cluster-id: 97\n    defrag: no\n    cluster-type: cluster_ebpf\n    ebpf-lb-file: /usr/libexec/suricata/ebpf/lb.bpf\n    copy-mode: ips\n    copy-iface: eth0\n    buffer-size: 64535\n```\n\n----------------------------------------\n\nTITLE: Matching Negotiated TLS/SSL Version in Suricata\nDESCRIPTION: These examples demonstrate how to match the negotiated TLS/SSL version using the `tls.version` keyword in Suricata. It shows how to match specific versions using both string representations (e.g., \"1.2\") and hexadecimal values (e.g., \"0x7f12\").\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.version:1.2;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.version:0x7f12;\n```\n\n----------------------------------------\n\nTITLE: Lowercasing HTTP Header Names - Suricata Rule\nDESCRIPTION: This rule utilizes the `header_lowercase` transformation to normalize HTTP/1 and HTTP/2 header names by converting them to lowercase. It ensures that rules match headers regardless of their original casing. The rule alerts when an `authorization:` header is present.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"HTTP authorization\"; http.header_names; \\\n    header_lowercase; content:\"authorization:\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Fast Log Output Configuration (YAML)\nDESCRIPTION: This configuration defines the settings for the fast.log output, which provides line-based alerts. It specifies whether the log is enabled, the filename, and whether to append to the existing file or overwrite it upon Suricata restart. The `enabled` parameter activates/deactivates the logging, `filename` sets the name of the log file, and `append` determines if the log file should be appended to or overwritten on Suricata restart.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\n  -fast:                    #The log-name.\n     enabled:yes            #This log is enabled. Set to 'no' to disable.\n     filename: fast.log     #The name of the file in the default logging directory.\n     append: yes/no         #If this option is set to yes, the last filled fast.log-file will not be\n                            #overwritten while restarting Suricata.\n```\n\n----------------------------------------\n\nTITLE: Suricata af-packet configuration in suricata.yaml\nDESCRIPTION: This snippet shows how to configure af-packet settings in Suricata's suricata.yaml file. It sets the interface, number of threads, cluster ID and type, defrag settings, mmap locking, tpacket version, ring size, and block size. Demonstrates configurations for capturing network traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\n- interface: eth1\n # Number of receive threads. \"auto\" uses the number of cores\n threads: 48 # 48 worker threads on cpus \"8-55\" above\n cluster-id: 99\n cluster-type: cluster_flow\n defrag: no\n mmap-locked: yes\n tpacket-v3: yes\n ring-size: 100000\n block-size: 1048576\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Request Headers in Lua (Table)\nDESCRIPTION: This snippet demonstrates how to retrieve all HTTP request headers as a table using the `HttpGetRequestHeaders()` function. It iterates through the headers and prints each header name and value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_16\n\nLANGUAGE: lua\nCODE:\n```\na = HttpGetRequestHeaders();\nfor n, v in pairs(a) do\n    print(n,v)\nend\n```\n\n----------------------------------------\n\nTITLE: BPF Capture Filter Example\nDESCRIPTION: This example demonstrates how to use a BPF capture filter to exclude traffic from a specific host (1.2.3.4) from being captured and processed by Suricata. This prevents inspection, logging, and recording of traffic to and from the specified IP address.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/ignoring-traffic.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nnot host 1.2.3.4\n```\n\n----------------------------------------\n\nTITLE: Blocking Rule Reload via Unix Socket\nDESCRIPTION: This command utilizes the `suricatasc` tool to initiate a blocking rule reload.  The `-c reload-rules` option instructs Suricata to reload the ruleset and block until the operation is complete. Requires `suricatasc` to be installed and configured to communicate with the Suricata Unix socket.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/rule-reload.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsuricatasc -c reload-rules\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Client ID with Content\nDESCRIPTION: This example matches the MQTT client ID using the `mqtt.connect.clientid` keyword combined with a content match. It matches when the client ID is \"myclient\".  The client ID is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.clientid; content:\"myclient\";\n```\n\n----------------------------------------\n\nTITLE: Disabling NIC offloading in suricata.yaml\nDESCRIPTION: This snippet shows how to configure disable-offloading in the suricata.yaml configuration file.  This disables or enables NIC offloading. By default offloading is disabled.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\ncapture:\n  # disable NIC offloading. It's restored when Suricata exits.\n  # Enabled by default.\n  #disable-offloading: false\n```\n\n----------------------------------------\n\nTITLE: Stripping Whitespace in file_data - Suricata Rule\nDESCRIPTION: This rule demonstrates the use of the `strip_whitespace` transformation keyword in a Suricata rule. It removes all whitespace characters from the `file_data` buffer before checking for the presence of \"window.navigate(\". This ensures that the rule will still match even if there are spaces between the terms.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (file_data; strip_whitespace; \\\n    content:\"window.navigate(\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring MQTT Logging with EVE JSON\nDESCRIPTION: This snippet configures MQTT logging using the EVE JSON output format. It allows enabling/disabling the output of passwords and limiting the size of logged strings in bytes. The size can be specified in KB, MB, or GB, with a default of 1KB. A value of 0 disables limiting. This configuration should be made in context with the app-layer configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\n        - mqtt:\n            # passwords: yes           # enable output of passwords\n            # string-log-limit: 1kb    # limit size of logged strings in bytes.\n                                       # Can be specified in kb, mb, gb. Just a number\n                                       # is parsed as bytes. Default is 1KB.\n                                       # Use a value of 0 to disable limiting.\n                                       # Note that the size is also bounded by\n                                       # the maximum parsed message size (see\n                                       # app-layer configuration)\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Tracking\nDESCRIPTION: This snippet shows the YAML configuration for host tracking within Suricata. It defines the hash table size, number of preallocated host objects, and the maximum memory usage for hosts. Adjusting these values can impact performance and resource utilization.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_35\n\nLANGUAGE: yaml\nCODE:\n```\nhost:\n  hash-size: 4096\n  prealloc: 1000\n  memcap: 32mb\n```\n\n----------------------------------------\n\nTITLE: Setting PID File Location in Suricata YAML\nDESCRIPTION: This snippet defines the location of the PID (Process ID) file for Suricata. This file is used when Suricata is run in daemon mode to store the process ID, allowing for process management. It's important to have a unique PID file for each Suricata instance.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\npid-file: /var/run/suricata.pid\n```\n\n----------------------------------------\n\nTITLE: Importing Suricata HTTP Library\nDESCRIPTION: Imports the `suricata.http` library, providing access to HTTP transaction details within Suricata Lua scripts. This is the first step to use HTTP related functionality.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_0\n\nLANGUAGE: Lua\nCODE:\n```\nlocal http = require(\"suricata.http\")\n```\n\n----------------------------------------\n\nTITLE: Matching DNS Opcode Value Range in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match a range of opcode values in the DNS header using the `dns.opcode` keyword in a Suricata rule. The opcode is an unsigned 8-bit integer representing the type of query.  This will match opcodes between 7 and 15, exclusively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.opcode:7-15;\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Response Body in Suricata\nDESCRIPTION: This Suricata rule matches on the HTTP response body. It uses the `http.response_body` keyword along with the `content` keyword to search for a specific string within the response body. The rule includes options like `flow`, `classtype`, `sid`, and `rev` for defining the flow direction, classification, rule ID, and revision number, respectively. The matching is performed on gzip decoded data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_19\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Response Body \\\n  Example\"; flow:established,to_client; :example-rule-options:`http.response_body; \\\n  content:\"Server response body\";` classtype:bad-unknown; sid:120; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Host Raw Example\nDESCRIPTION: This Suricata rule demonstrates matching the raw, unnormalized HTTP host header.  It utilizes the `http.host.raw` keyword.  The rule checks for `SuRiCaTa.Io:8445` using a hex-encoded colon.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Host Raw Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.host.raw; \\\n  content:\"SuRiCaTa.Io|3a|8445\";` bsize:16; classtype:bad-unknown; sid:124; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Example YAML Content for Suricata Address Groups\nDESCRIPTION: This YAML snippet shows an example of what `address-groups.yaml` might contain when included in a Suricata configuration, specifically defining the `HOME_NET` variable.  It provides a concrete example of how the included file defines YAML content. Requires that the root is a valid YAML document.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/includes.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n%YAML 1.1\n---\nHOME_NET: \"[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]\"\n```\n\n----------------------------------------\n\nTITLE: LDAP Bind Request Alert Rule\nDESCRIPTION: This Suricata rule alerts when an LDAP bind request operation is detected. It uses the `ldap.request.operation` keyword with the operation code `0` to identify the bind request. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP bind request\"; :example-rule-emphasis:`ldap.request.operation:0;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Reassembly Settings\nDESCRIPTION: This YAML snippet configures stream reassembly settings for Suricata. It sets the memory cap for stream reassembly, enables checksum validation, disables inline mode, and configures reassembly parameters like memory cap and depth.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\n  stream:\n    memcap: 64mb\n    checksum-validation: yes      # reject wrong csums\n    inline: no                    # no inline mode\n    reassembly:\n      memcap: 32mb\n      depth: 0                     # reassemble all of a stream\n      toserver-chunk-size: 2560\n      toclient-chunk-size: 2560\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Request Header\nDESCRIPTION: Retrieves a specific HTTP request header value by its key using the `request_header()` method on the transaction object (`tx`). The example retrieves the \"User-Agent\" header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_4\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nlocal ua = tx:request_header(\"User-Agent\")\nif ua ~= nil then\n      print(ua)\nend\n```\n\n----------------------------------------\n\nTITLE: Calculating SHA1 Hash of HTTP Request Line - Suricata Rule\nDESCRIPTION: This rule calculates the SHA-1 hash of the `http_request_line` using the `to_sha1` transformation and then checks for a specific SHA-1 hash value in the content. The content value represents the raw bytes of the SHA-1 hash.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http_request_line; to_sha1; \\\n    content:\"|54A9 7A8A B09C 1B81 3725 2214 51D3 F997 F015 9DD7|\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Analyzing DNS Application Layer Protocol Rule - JSON\nDESCRIPTION: This JSON outlines the analysis of a Suricata rule targeting the DNS application layer protocol. It specifies the rule's identifier, message, application protocol (dns), requirement (flow), and type (app_layer). The \"flags\" section details the traffic direction, while the \"lists\" section is empty, indicating that no specific content or matching criteria are defined beyond the protocol.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"raw\": \"alert dns any any -> any any (msg:\\\"app-layer, dns\\\"; sid:404;)\",\n      \"id\": 404,\n      \"gid\": 1,\n      \"rev\": 0,\n      \"msg\": \"app-layer, dns\",\n      \"app_proto\": \"dns\",\n      \"requirements\": [\n        \"flow\"\n      ],\n      \"type\": \"app_layer\",\n      \"flags\": [\n        \"src_any\",\n        \"dst_any\",\n        \"sp_any\",\n        \"dp_any\",\n        \"applayer\",\n        \"toserver\",\n        \"toclient\"\n      ],\n      \"pkt_engines\": [],\n      \"frame_engines\": [],\n      \"lists\": {}\n    }\n```\n\n----------------------------------------\n\nTITLE: Configure CPU Affinity\nDESCRIPTION: This YAML snippet configures the CPU affinity settings within Suricata, specifying which CPUs should be used for management, receive, and worker processes. This configuration helps to optimize performance by ensuring that processes are running on specific CPU cores.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/dpdk.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nthreading:\n      set-cpu-affinity: yes\n      cpu-affinity:\n        - management-cpu-set:\n            cpu: [ 0 ]  # include only these CPUs in affinity settings\n        - receive-cpu-set:\n            cpu: [ 0 ]  # include only these CPUs in affinity settings\n        - worker-cpu-set:\n            cpu: [ 2,4,6,8 ]\n```\n\n----------------------------------------\n\nTITLE: IPREP isset Rule Example\nDESCRIPTION: This Suricata rule demonstrates the usage of the 'iprep' keyword with the 'isset' operator. It blocks traffic to any IP address that has a score in the 'known-bad-hosts' category.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ip-reputation-rules.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\ndrop ip $HOME_NET any -> any any (:example-rule-options:`iprep:src,known-bad-hosts,isset;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Setting the Multi-Pattern Matcher Algorithm in Suricata\nDESCRIPTION: This code snippet demonstrates how to configure the multi-pattern matcher algorithm in Suricata using the 'mpm-algo' setting. The available algorithms are 'ac', 'hs', and 'ac-ks'. For x86_64 architectures, 'hs' (Hyperscan) is recommended for optimal performance.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_23\n\nLANGUAGE: yaml\nCODE:\n```\nmpm-algo: ac\n```\n\n----------------------------------------\n\nTITLE: Retrieving JA3 String in Lua\nDESCRIPTION: This code demonstrates how to retrieve the JA3 string using the `Ja3GetString()` function. The function returns the JA3 string or nil if not available.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_30\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    str = Ja3GetString()\n    if str == nil then\n        return\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Equality Matching (Hex)\nDESCRIPTION: This code snippet demonstrates how to match an integer value for equality using a hexadecimal representation in a Suricata rule. The `bsize` keyword specifies the integer field, and `0x13` represents the hexadecimal value. The rule will trigger if the `bsize` field's value is equal to `0x13` (decimal 19).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:=0x13;\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Detecting Login Failures After Successes\nDESCRIPTION: This example alerts if a login failure occurs after two successful logins, using the `loginsuccess` counter.  It checks if `loginsuccess` is set and equal to 2.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Login fail after two successes\";   \\\n        content:\"login failed\"; flowint:loginsuccess, isset;            \\\n        flowint:loginsuccess, =, 2;)\n```\n\n----------------------------------------\n\nTITLE: LDAP Result Code Matching - Back to Front Indexing\nDESCRIPTION: This Suricata rule alerts if the last LDAP response in the packet has a \"success\" result code.  Negative indexing allows targeting responses from the end of the array.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP success at last index\"; :example-rule-emphasis:`ldap.responses.result_code:success,-1;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Check Suricata Build Info for NFQ Support\nDESCRIPTION: This command checks if Suricata was compiled with NFQ (Netfilter Queue) support. NFQ is required for inline IPS mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --build-info\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP-DATA Command Rule\nDESCRIPTION: This rule filters FTP-DATA channels based on commands used on the FTP command channel. It supports commands like RETR (get) and STOR (put).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp-data any any -> any any (msg:\"FTP store password\"; \\\n  filestore; filename:\"password\"; \\\n  :example-rule-options:`ftpdata_command:stor;` sid:3; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata entropy rule examples\nDESCRIPTION: This example demonstrates the use of the `entropy` keyword in Suricata rules. The `entropy` keyword calculates the Shannon entropy value for content and compares it with an entropy value specified in the rule. The rule triggers if the calculated entropy value matches the criteria.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\n  entropy: 7.01\n  alert http any any -> any any (msg:\"entropy simple test\"; file.data; entropy: value >= 4; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: IP-Only IPREP Rule Example\nDESCRIPTION: This Suricata rule exemplifies using the 'iprep' keyword in an 'IP-only' rule. It alerts if the source IP has a CnC reputation score greater than 100. The rule is only checked once per flow-direction.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ip-reputation-rules.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"IPREP High Value CnC\"; iprep:src,CnC,>,100; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata rule using dataset to track user agents\nDESCRIPTION: This rule shows how to track HTTP user agents using a dataset. It adds the current user agent to the `ua-seen` dataset using the `dataset:set` keyword.  This allows detecting unique user agents.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg: \"http user-agent test\"; http.user_agent; dataset:set,ua-seen; sid:234; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with ip_proto Keyword (Numeric)\nDESCRIPTION: This example demonstrates the `ip_proto` keyword's usage with a numeric value to match IP protocol type. It alerts on IP packets with protocol number 1, which is ICMP.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"IP Packet with protocol 1\"; ip_proto:1; classtype:bad-unknown; sid:5; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Requiring the Suricata DNS library in Lua\nDESCRIPTION: This code snippet demonstrates how to import the `suricata.dns` library in a Lua script within Suricata. This library provides functions for accessing DNS transaction details.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_0\n\nLANGUAGE: Lua\nCODE:\n```\nlocal dns = require(\"suricata.dns\")\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email From Field\nDESCRIPTION: This Suricata rule alerts if an SMTP packet contains the MIME field 'from' with the specified value.  The 'email.from' keyword targets the 'From' field in the email header. The 'content' option specifies the string to match within the 'From' field. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_0\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email from\"; email.from; content:\"toto <toto@gmail.com>\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata rule using datarep with raw string\nDESCRIPTION: This example demonstrates a Suricata rule using the `datarep` keyword to check the reputation of a raw DNS query string. The rule will match if the DNS query is in the `dns_string.rep` list and its reputation value is greater than 200.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns any any -> any any (dns.query; datarep:dns_string, >, 200, load dns_string.rep, type string; sid:3;)\n```\n\n----------------------------------------\n\nTITLE: Enabling File Storage and MD5 Hashing in Suricata YAML\nDESCRIPTION: This YAML snippet configures Suricata to enable file storage, specifies the directory for storing files, and forces the calculation of MD5 checksums for extracted files. The `file-store` section enables file storage, sets the storage directory to 'filestore', and forces MD5 hash calculation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n    - file-store:\n         enabled: yes       # set to yes to enable\n         dir: filestore     # directory to store the files\n         force-hash: [md5]  # force logging of md5 checksums\n```\n\n----------------------------------------\n\nTITLE: Configuring Rx Flow Hash\nDESCRIPTION: Configures the Rx flow hash for different protocols (tcp4, udp4, tcp6, udp6) on the network interface (eth1). It utilizes either src/dst IP or src/dst IP with src/dst port for hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nfor proto in tcp4 udp4 tcp6 udp6; do\n    /usr/local/sbin/ethtool -N eth1 rx-flow-hash $proto sdfn\n done\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: vlan.id equal to 400 at the last layer\nDESCRIPTION: This Suricata rule alerts if the VLAN ID at the last layer is equal to 400. It uses the `vlan.id` keyword with the value 400 and layer -1, which represents the last layer. The rule will only trigger if the last VLAN layer has an ID of 400.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"Vlan ID is equal to 400 at the last layer\"; vlan.id:400,-1; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Analyzing HTTP Anchored Content Rule - JSON\nDESCRIPTION: This JSON provides an analysis of a Suricata rule that checks for anchored content in HTTP traffic. It details the rule's ID, message, application protocol, requirements (payload and flow), type (pkt_stream), flags, and packet engines.  The \"lists\" section outlines the content matching details, specifying the pattern \"abc\", length, depth, and other properties. The \"mpm\" section further explains the memory pattern matching engine configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"raw\": \"alert http any any -> any any (msg:\\\"http, anchored content\\\"; content:\\\"abc\\\"; depth:30; sid:603;)\",\n      \"id\": 603,\n      \"gid\": 1,\n      \"rev\": 0,\n      \"msg\": \"http, anchored content\",\n      \"app_proto\": \"http_any\",\n      \"requirements\": [\n        \"payload\",\n        \"flow\"\n      ],\n      \"type\": \"pkt_stream\",\n      \"flags\": [\n        \"src_any\",\n        \"dst_any\",\n        \"sp_any\",\n        \"dp_any\",\n        \"applayer\",\n        \"need_packet\",\n        \"need_stream\",\n        \"toserver\",\n        \"toclient\",\n        \"prefilter\"\n      ],\n      \"pkt_engines\": [\n        {\n          \"name\": \"payload\",\n          \"is_mpm\": true\n        }\n      ],\n      \"frame_engines\": [],\n      \"lists\": {\n        \"payload\": {\n          \"matches\": [\n            {\n              \"name\": \"content\",\n              \"content\": {\n                \"pattern\": \"abc\",\n                \"length\": 3,\n                \"nocase\": false,\n                \"negated\": false,\n                \"starts_with\": false,\n                \"ends_with\": false,\n                \"is_mpm\": true,\n                \"no_double_inspect\": false,\n                \"depth\": 30,\n                \"fast_pattern\": false,\n                \"relative_next\": false\n              }\n            }\n          ]\n        }\n      },\n      \"mpm\": {\n        \"buffer\": \"payload\",\n        \"pattern\": \"abc\",\n        \"length\": 3,\n        \"nocase\": false,\n        \"negated\": false,\n        \"starts_with\": false,\n        \"ends_with\": false,\n        \"is_mpm\": true,\n        \"no_double_inspect\": false,\n        \"depth\": 30,\n        \"fast_pattern\": false,\n        \"relative_next\": false\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Updating Rules with suricata-update\nDESCRIPTION: This command updates the Suricata rulesets to the latest versions. It ensures that your Suricata installation has the most up-to-date threat intelligence.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata-update\n```\n\n----------------------------------------\n\nTITLE: Suricata rule to store files matching blacklisted SHA256 checksum\nDESCRIPTION: This Suricata rule stores files whose SHA256 checksum matches an entry in the 'fileextraction-chksum.list' blacklist. It alerts on HTTP traffic and uses the `filesha256` keyword to check the SHA256 checksum against the list. If a match is found, the `filestore` keyword stores the file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/file-extraction.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert http any any -> any any (msg:\"Black list checksum match and extract SHA256\"; filesha256:fileextraction-chksum.list; filestore; sid:6; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Client ID with PCRE\nDESCRIPTION: This example shows matching the MQTT client ID using the `mqtt.connect.clientid` keyword combined with a PCRE. It matches client IDs starting with \"mosq\". The client ID is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.clientid; pcre:\"/^mosq.*/\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Example with prefilter\nDESCRIPTION: This example demonstrates using the 'prefilter' keyword. By using the 'prefilter' keyword, the TTL test (ttl:123) will be used in prefiltering instead of the single byte pattern (\"a\").  This can improve performance by filtering out packets based on TTL before content matching. Dependencies: None.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/prefilter-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (ttl:123; prefilter; content:\"a\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Rule Profiling Sort and Limit\nDESCRIPTION: This snippet shows how to configure the sorting and limit options for rule profiling output in Suricata. The `sort` option specifies the criteria for sorting the profiling statistics (e.g., `avgticks`), and the `limit` option determines the number of signatures to display in the output.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_68\n\nLANGUAGE: yaml\nCODE:\n```\nsort: avgticks\nlimit: 100\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with Large Data and Descriptor Rings\nDESCRIPTION: This command starts Suricata with a large data ring (16GB) and descriptor ring (4GB) for the Myricom card. The ``SNF_DATARING_SIZE`` and ``SNF_DESCRING_SIZE`` environment variables explicitly set the sizes of these rings, respectively. ``SNF_NUM_RINGS`` defines the number of rings, while ``SNF_FLAGS`` provides additional settings. The remaining options configure Suricata itself.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/myricom.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nSNF_NUM_RINGS=16 SNF_DATARING_SIZE=17179869184 SNF_DESCRING_SIZE=4294967296 SNF_FLAGS=0x1 suricata -c suricata.yaml -i eth5 --runmode=workers\n```\n\n----------------------------------------\n\nTITLE: Configuring force-xdp-mode in suricata.yaml\nDESCRIPTION: This snippet shows how to configure the force-xdp-mode in the suricata.yaml configuration file. The force-xdp-mode can be set to skb, drv or none. drv is the preferred mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  force-xdp-mode: <value> where: value = <skb|drv|none>\n  force-xdp-mode: drv\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: vlan.layers equal to 0\nDESCRIPTION: This Suricata rule alerts if a packet has 0 VLAN layers. It uses the `vlan.layers` keyword to match packets with a specific number of VLAN layers. This rule identifies traffic with no VLAN encapsulation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"Packet has 0 vlan layers\"; vlan.layers:0; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Netmap IPS Mode in Suricata YAML\nDESCRIPTION: This YAML configuration sets up Suricata in Netmap-based IPS mode, creating a layer 2 software bridge between two interfaces.  Packets are read from one interface and transmitted on another, allowing Suricata to block packets based on IPS policies. The `copy-mode: ips` setting enables IPS mode, and `copy-iface` specifies the interface to transmit packets to.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nnetmap:\n  - interface: igb0\n    copy-mode: ips\n    copy-iface: igb1\n  - interface: igb1\n    copy-mode: ips\n    copy-iface: igb0\n```\n\n----------------------------------------\n\nTITLE: Get Raw HTTP Request Headers\nDESCRIPTION: Retrieves the raw HTTP request headers as a string using the `request_headers_raw()` method on the transaction object (`tx`). The example checks if the headers contain \"User%-Agent: curl\" and prints them if they do.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_8\n\nLANGUAGE: Lua\nCODE:\n```\nhttp_request_headers_raw = tx:request_headers_raw()\n\nif #http_request_headers_raw > 0 then\n    if http_request_headers_raw:find(\"User%-Agent: curl\") then\n        print(http_request_headers_raw)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Configure SMB Cache Limits\nDESCRIPTION: This configuration defines cache limits for the SMB parser in Suricata. These limits control the sizes of various caches used to track data between different records and transactions. When a cache reaches its size limit, the oldest entries are automatically evicted to make room for new ones. The cache sizes are specified as integer values without units. The various parameters include GUID cache, record offset cache, tree cache, DCERPC fragment cache and session cache.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_42\n\nLANGUAGE: yaml\nCODE:\n```\nsmb:\n  max-guid-cache-size: 1024\n  max-rec-offset-cache-size: 128\n  max-tree-cache-size: 512\n  max-dcerpc-frag-cache-size: 128\n  max-session-cache-size: 512\n```\n\n----------------------------------------\n\nTITLE: Accessing HTTP Response Body Data in Lua\nDESCRIPTION: This code demonstrates how to access the HTTP response body data using the `HttpGetResponseBody()` function. It retrieves the body, iterates through the body parts, and prints each part.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_6\n\nLANGUAGE: lua\nCODE:\n```\nfunction log(args)\n    a, o, e = HttpGetResponseBody();\n    --print(\"offset \" .. o .. \" end \" .. e)\n    for n, v in ipairs(a) do\n        print(v)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Will Message with PCRE\nDESCRIPTION: This example demonstrates matching the will message in the MQTT CONNECT message using the `mqtt.connect.willmessage` keyword combined with a PCRE. It matches will messages starting with \"fooba\" followed by either \"r\" or \"z\". The will message is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.willmessage; pcre:\"/^fooba[rz]/\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Exception Policy Master Switch in Suricata YAML\nDESCRIPTION: This code snippet demonstrates how to configure the master switch for exception policies in the Suricata YAML configuration file. The `exception-policy` setting defines a common behavior for all exception policies, which can be overwritten by specific policy settings. Options include `drop-packet`, `drop-flow`, `reject`, `bypass`, `pass-packet`, `pass-flow`, `ignore`, and `auto`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/exception-policies.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Define a common behavior for all exception policies.\n# In IPS mode, the default is drop-flow. For cases when that's not possible, the\n# engine will fall to drop-packet. To fallback to old behavior (setting each of\n# them individually, or ignoring all), set this to ignore.\n# All values available for exception policies can be used, and there is one\n# extra option: auto - which means drop-flow or drop-packet (as explained above)\n# in IPS mode, and ignore in IDS mode. Exception policy values are: drop-packet,\n# drop-flow, reject, bypass, pass-packet, pass-flow, ignore (disable).\nexception-policy: auto\n```\n\n----------------------------------------\n\nTITLE: Matching domain with dotprefix and endswith - Suricata Rule\nDESCRIPTION: This rule builds on the previous `dotprefix` example but also uses the `endswith` keyword.  It ensures that the match only occurs if `.microsoft.com` is at the end of the transformed `dns.query` string, preventing matches on subdomains like `fakemicrosoft.com`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns any any -> any any (dns.query; dotprefix; \\\n    content:\".microsoft.com\"; endswith; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Check available interface cards\nDESCRIPTION: This command lists the available network interface cards on the system. It is used to identify the correct interface for Suricata to monitor. No specific dependencies are required.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nifconfig\n```\n\n----------------------------------------\n\nTITLE: ICMP Time-To-Live Exceeded Rule - Suricata\nDESCRIPTION: This Suricata rule alerts when an ICMP \"Time-To-Live Exceeded in Transit\" message is detected. It checks for ICMP type 11 and code 0, indicating that a packet's TTL has expired during transit. This is often indicative of network issues or traceroute activity. The rule assigns a message, classification, signature ID (SID), and revision number.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_23\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert icmp $HOME_NET any -> $EXTERNAL_NET any (msg:\"GPL MISC Time-To-Live Exceeded in Transit\"; :example-rule-emphasis:`icode:0;` itype:11; classtype:misc-activity; sid:2100449; rev:7;)\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Request Line\nDESCRIPTION: Retrieves the HTTP request line as a string using the `request_line()` method on the transaction object (`tx`). The example checks if the request line starts with \"GET\" and prints it if it does.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_6\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nlocal http_request_line = tx:request_line();\nif #http_request_line > 0 then\n    if http_request_line:find(\"^GET\") then\n        print(http_request_line)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Method in Suricata Rules\nDESCRIPTION: This snippet shows how to match the SIP method in a Suricata rule. The `sip.method` keyword is used to inspect the method field in a SIP request.  The `content` option specifies the method to match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.method; content:\"INVITE\";\n```\n\n----------------------------------------\n\nTITLE: Firewall Rule Example (Accept HTTP Request)\nDESCRIPTION: This example demonstrates a firewall rule that accepts HTTP requests at the 'request_line' state. It uses the 'accept:hook' action to allow the rule to accept traffic for the current hook/state and evaluate the next tables.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/firewall/firewall-design.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\naccept:hook http1:request_line ... http.uri; ...\n```\n\n----------------------------------------\n\nTITLE: Retrieving SSH Client Protocol Version in Lua\nDESCRIPTION: This code demonstrates retrieving the SSH client protocol version using the `SshGetClientProtoVersion()` function within the log function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_38\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    version = SshGetClientProtoVersion()\n    if version == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Request Method Example\nDESCRIPTION: This Suricata rule demonstrates how to detect a specific HTTP request method. It checks for a `GET` request using the `http.method` keyword. The rule applies to HTTP traffic from the home network to an external network.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Request Example\";\n```\n\n----------------------------------------\n\nTITLE: NFQ Configuration Example\nDESCRIPTION: This YAML snippet shows how to configure NFQ settings in Suricata, including mode (accept, repeat, or route), repeat-mark, repeat-mask, and route-queue. These settings control how Suricata interacts with the Netfilter queue for packet processing and re-injection.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_60\n\nLANGUAGE: yaml\nCODE:\n```\nnfq:\n   mode: accept                 #By default the packet will be accepted or dropped by Suricata\n   repeat-mark: 1               #If the mode is set to 'repeat', the packets will be marked after being\n                                #processed by Suricata.\n   repeat-mask: 1\n   route-queue: 2               #Here you can assign the queue-number of the tool that Suricata has to\n                                #send the packets to after processing them.\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Source/Destination Example\nDESCRIPTION: This example demonstrates source and destination IP addresses in a Suricata rule. $HOME_NET and $EXTERNAL_NET are variables defined in suricata.yaml that represent the local network and external networks respectively.  The rule matches traffic from $HOME_NET to $EXTERNAL_NET.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Session Present Flag\nDESCRIPTION: This example demonstrates matching the MQTT CONNACK session_present flag. It matches when the session_present flag is set to true.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.CONNACK; mqtt.connack.session_present:true;\n```\n\n----------------------------------------\n\nTITLE: Suricata auto setup configuration\nDESCRIPTION: These commands utilize Suricata's auto-setup features to simplify the configuration process.  'make install-conf' creates necessary directories and sets up suricata.yaml. 'make install-rules' downloads and configures the latest Emerging Threats ruleset. 'make install-full' combines both configurations. These commands depend on a successful 'configure && make' process.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && make install-conf\n./configure && make && make install-rules\n./configure && make && make install-full\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Request Line in Suricata Rules\nDESCRIPTION: This snippet illustrates how to match the entire SIP request line in a Suricata rule. The `sip.request_line` keyword inspects the complete request line.  The `content` option can match a partial or full request line.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.request_line; content:\"REGISTER sip:sip.url.org SIP/2.0\"\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Cookie Value\nDESCRIPTION: This Suricata rule detects a specific cookie value in an HTTP request. It uses the `http.cookie` keyword to match the value of the 'PHPSESSIONID' cookie. The `flow` keyword is used to specify that the inspection should be performed on traffic from the internal network to the external network.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_32\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Cookie Example\"; \\\n  flow:established,to_server; :example-rule-emphasis:`http.cookie; \\\n  content:\"PHPSESSIONID=123\";` bsize:14; classtype:bad-unknown; sid:80; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Raw HTTP Request Headers in Lua\nDESCRIPTION: This example demonstrates how to retrieve the raw HTTP request headers using the `HttpGetRawRequestHeaders()` function and prints the raw headers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_12\n\nLANGUAGE: lua\nCODE:\n```\nrh = HttpGetRawRequestHeaders();\nprint (\"Raw Request Headers: \" .. rh);\n```\n\n----------------------------------------\n\nTITLE: Matching DNS Opcode Value in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match a specific opcode value in the DNS header using the `dns.opcode` keyword in a Suricata rule. The opcode is an unsigned 8-bit integer representing the type of query. It shows example of matching specific opcode, negating a value, and matching a range.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.opcode:4;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: DNS Multiple Query Matching\nDESCRIPTION: This Suricata rule demonstrates the multiple buffer matching capability for DNS queries. It checks for the presence of \"example\" in the first DNS query and \".com\" in the second DNS query within the same DNS transaction. The rule will alert if both conditions are met.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/multi-buffer-matching.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns $HOME_NET any -> $EXTERNAL_NET any (msg:\"DNS Multiple Question Example Rule\"; dns.query; content:\"example\"; dns.query; content:\".com\"; classtype:misc-activity; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Alert Event Example\nDESCRIPTION: This example demonstrates the structure of an 'alert' event in Suricata's Eve JSON output. It includes fields such as action, gid, signature ID, revision, signature message, category, severity, and metadata containing details like affected product, attack target, creation and update dates, deployment, malware family, and performance impact.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"alert\": {\n    \"action\": \"allowed\",\n    \"gid\": 1,\n    \"signature_id\": 2024056,\n    \"rev\": 4,\n    \"signature\": \"ET MALWARE Win32/CryptFile2 / Revenge Ransomware Checkin M3\",\n    \"category\": \"Malware Command and Control Activity Detected\",\n    \"severity\": 1,\n    \"metadata\": {\n      \"affected_product\": [\n        \"Windows_XP_Vista_7_8_10_Server_32_64_Bit\"\n      ],\n      \"attack_target\": [\n        \"Client_Endpoint\"\n      ],\n      \"created_at\": [\n        \"2017_03_15\"\n      ],\n      \"deployment\": [\n        \"Perimeter\"\n      ],\n      \"former_category\": [\n        \"MALWARE\"\n      ],\n      \"malware_family\": [\n        \"CryptFile2\"\n      ],\n      \"performance_impact\": [\n        \"Moderate\"\n      ],\n      \"signature_severity\": [\n        \"Major\"\n      ],\n      \"updated_at\": [\n        \"2020_08_04\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring IP Defragmentation Engine in Suricata\nDESCRIPTION: This snippet configures the IP defragmentation engine in Suricata. It sets the memory cap, memory cap policy, hash size, number of trackers, maximum fragments, preallocation setting, and timeout for fragment reassembly.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_28\n\nLANGUAGE: yaml\nCODE:\n```\ndefrag:\n  memcap: 32mb\n  memcap-policy: ignore  # in IPS mode, what to do if memcap is reached\n  hash-size: 65536\n  trackers: 65535        # number of defragmented flows to follow\n  max-frags: 65535       # number of fragments do keep (higher than trackers)\n  prealloc: yes\n  timeout: 60\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with TTL Keyword\nDESCRIPTION: This example demonstrates how to use the `ttl` keyword to check for a specific IP time-to-live value in a Suricata rule. It alerts if a packet with a TTL of 0 is detected.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip $EXTERNAL_NET any -> $HOME_NET any (msg:\"IP Packet With TTL 0\"; ttl:0; classtype:misc-activity; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Request Line in Suricata\nDESCRIPTION: This Suricata rule matches on the entire HTTP request line. It uses the `http.request_line` keyword along with the `content` keyword to search for a specific request line. The rule includes options like `flow`, `bsize`, `classtype`, `sid`, and `rev` for defining the flow direction, buffer size, classification, rule ID, and revision number, respectively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Request Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.request_line; \\\n  content:\"GET /index.html HTTP/1.1\";` bsize:24; classtype:bad-unknown; \\\n  sid:60; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata rule to store files matching blacklisted SHA1 checksum\nDESCRIPTION: This Suricata rule stores files whose SHA1 checksum matches an entry in the 'fileextraction-chksum.list' blacklist. It alerts on HTTP traffic and uses the `filesha1` keyword to check the SHA1 checksum against the list. If a match is found, the `filestore` keyword stores the file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/file-extraction.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert http any any -> any any (msg:\"Black list checksum match and extract SHA1\"; filesha1:fileextraction-chksum.list; filestore; sid:5; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Response Header\nDESCRIPTION: Retrieves a specific HTTP response header value by its key using the `response_header()` method on the transaction object (`tx`). The example retrieves the \"Content-Type\" header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_5\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nlocal content_type = tx:response_header(\"Content-Type\")\nif content_type ~= nil then\n      print(content_type)\nend\n```\n\n----------------------------------------\n\nTITLE: JSON Flags Configuration for EVE JSON Output\nDESCRIPTION: This snippet configures JSON flags for the EVE output, including `preserve-order`, `compact`, `ensure-ascii`, and `escape-slash`. All of these flags are enabled by default and can be modified per EVE instance.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_11\n\nLANGUAGE: Config\nCODE:\n```\n  outputs:\n    - eve-log:\n        json:\n          # Sort object keys in the same order as they were inserted\n          preserve-order: yes\n\n          # Make the output more compact\n          compact: yes\n\n          # Escape all unicode characters outside the ASCII range\n          ensure-ascii: yes\n\n          # Escape the '/' characters in string with '\\/'\n          escape-slash: yes\n```\n\n----------------------------------------\n\nTITLE: Installing Suricata with apt-get\nDESCRIPTION: Adds the OISF Suricata stable PPA, updates the package index, and installs Suricata and the jq tool. The jq tool is helpful for parsing JSON output from Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nsudo apt-get install software-properties-common\nsudo add-apt-repository ppa:oisf/suricata-stable\nsudo apt update\nsudo apt install suricata jq\n```\n\n----------------------------------------\n\nTITLE: Initializing Suricata Lua script for DNS rule matching\nDESCRIPTION: This snippet demonstrates initializing a Lua script designed for DNS rule matching in Suricata. The `init` function returns an empty table, indicating that no specific protocol data is initially required.  The script is intended to be triggered by DNS transaction state events (request_complete or response_complete).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_2\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init (args)\n   return {}\nend\n```\n\n----------------------------------------\n\nTITLE: PCRE Keyword Example: Matching Six Numbers in Payload\nDESCRIPTION: This example shows how to use the `pcre` keyword to match six consecutive digits in the payload of a network packet. It uses a regular expression `/[0-9]{6}/` to achieve this, demonstrating basic pattern matching with PCRE.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\npcre:\"/[0-9]{6}/\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email Subject Field\nDESCRIPTION: This Suricata rule generates an alert when an SMTP packet's MIME 'Subject' field contains the specified string. The rule uses the 'email.subject' keyword to target the email's subject. The content option specifies the string to search for.  'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_1\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email subject\"; email.subject; content:\"This is a test email\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Flow Direction Matching\nDESCRIPTION: This example shows how to combine multiple flow options to match specific traffic directions, connection states, and stream characteristics. It uses `flow:to_client, established` to match packets from the server to the client in established connections.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nflow:to_client, established\n```\n\n----------------------------------------\n\nTITLE: Run Suricata with PCAP file\nDESCRIPTION: This snippet shows how to run Suricata with a configuration file and a PCAP file for analysis. The `-c` option specifies the path to the Suricata configuration file, and the `-r` option specifies the path to the PCAP file. The example uses a default configuration file and a PCAP with a timestamp in the name.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-profiling.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c /etc/suricata/suricata.yaml -r log.pcap.1304589204\n```\n\n----------------------------------------\n\nTITLE: Requires Keyword with OR Expression\nDESCRIPTION: This shows the syntax for using an *or* expression with the 'requires' keyword, allowing a rule to be enabled if either version requirement is met.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_18\n\nLANGUAGE: Suricata\nCODE:\n```\nrequires: version >= 7.0.4 < 8 | >= 8.0.3\n```\n\n----------------------------------------\n\nTITLE: Copying eBPF Filter (Bash)\nDESCRIPTION: This bash command copies the compiled eBPF filter to the Suricata eBPF directory so Suricata can load it. The eBPF program needs to be built and copied before it can be used.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n cp ebpf/vlan_filter.bpf /usr/libexec/suricata/ebpf/\n```\n\n----------------------------------------\n\nTITLE: Getting Packet Tuple (IP Version, Addresses, Protocol, Ports) in Lua\nDESCRIPTION: Retrieves a tuple containing the IP version (4 or 6), source IP address, destination IP address (as strings), IP protocol (as an integer), source port, and destination port (as integers). For ICMP, the last two values are ICMP type and code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_5\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\nipver, srcip, dstip, proto, sp, dp = p:tuple()\n```\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\nipver, srcip, dstip, proto, itype, icode = p:tuple()\nif ipver == 6 and proto == 1 then\n    -- weird, ICMPv4 on IPv6\n    return 1\nend\n```\n\n----------------------------------------\n\nTITLE: Matching JA3 string in Suricata rule\nDESCRIPTION: This example demonstrates how to construct a Suricata rule to match a specific JA3 string. The `ja3.string` keyword is used, indicating that the content should be matched against the JA3 string of the TLS client.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ja-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tls any any -> any any (msg:\"match JA3 string\"; \\\n      ja3.string; content:\"19-20-21-22\"; \\\n      sid:100002;)\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Bounce Attack Detection Rule\nDESCRIPTION: This rule detects FTP bounce attacks using the `ftpbounce` keyword.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nftpbounce\n```\n\n----------------------------------------\n\nTITLE: Unregistering Tenants via Unix Socket\nDESCRIPTION: These commands show how to unregister tenants via the Suricata Unix socket. The `unregister-tenant` command takes the tenant ID as an argument. This allows for dynamic removal of tenants.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nunregister-tenant 2\nunregister-tenant 1\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Quality of Service\nDESCRIPTION: This example demonstrates matching the MQTT Quality of Service (QoS) code using the `mqtt.qos` keyword. It matches when the QoS is 0 (fire and forget) or 2 (exactly one delivery). Valid values are 0, 1 and 2.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.qos:0;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.qos:2;\n```\n\n----------------------------------------\n\nTITLE: DHCP Renewal Time Signature Example - Suricata\nDESCRIPTION: This signature example demonstrates how to create a Suricata rule that alerts on small DHCP renewal times. It utilizes the `dhcp.renewal_time` keyword with a less-than operator to check if the renewal time is less than 3.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dhcp-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dhcp any any -> any any (msg:\"small DHCP renewal time (<3)\"; dhcp.renewal_time:<3; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: NFtables: Queue with advanced options\nDESCRIPTION: This nftables command shows how to add a rule to queue packets to multiple queues using fanout and bypass options. `num` specifies queue range. `fanout` uses CPU ID for load balancing and `bypass` accepts the packet if no program is listening on the queue.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nnft add rule filter IPS queue num 3-5 options fanout,bypass\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching exact file size\nDESCRIPTION: This Suricata rule demonstrates matching a file with a specific size using the `filesize` keyword. It alerts if a file is exactly 100 bytes in size.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesize:100;\n```\n\n----------------------------------------\n\nTITLE: Action Field Example\nDESCRIPTION: This snippet illustrates the 'action' field within the 'alert' object in Suricata's Eve JSON output.  The 'action' field indicates whether the detected traffic was 'allowed' or 'blocked'. The action is set to 'allowed' by default unless a rule specifies a 'drop' or 'reject' action, and Suricata is running in IPS mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\":\"allowed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Engine logging defaults\nDESCRIPTION: This snippet defines the default logging formats used by the Suricata engine for console and file outputs. It highlights the differences in the default format strings, with the file output including more detailed information like process ID and timestamps.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n* ``console``: ``%D: %S: %M``\n\n* ``file``: ``[%i - %m] %z %d: %S: %M``\n```\n\n----------------------------------------\n\nTITLE: Modifying Napatech Service Configuration\nDESCRIPTION: These lines configure the host buffers and timestamp clock in the `ntservice.ini` file. `HostBuffersRx` defines the number, size, and NUMA node of the host buffers, while `TimeSyncReferencePriority` sets the timestamp clock.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_5\n\nLANGUAGE: INI\nCODE:\n```\nHostBuffersRx = [4,16,-1] # [number of host buffers, Size(MB), NUMA node]\n    TimeSyncReferencePriority = OSTime\t# Timestamp clock synchronized to the OS\n```\n\n----------------------------------------\n\nTITLE: Accept HTTP traffic based on method, user-agent, status code - Suricata\nDESCRIPTION: These Suricata rules define a simple HTTP firewall ruleset. It demonstrates accepting traffic based on HTTP method (GET/POST), User-Agent (curl) and status code (200).  Each HTTP state needs an 'accept' rule to allow the traffic to proceed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/firewall/firewall-example.rst#_snippet_1\n\nLANGUAGE: suricata\nCODE:\n```\n# allow traffic before the request line is complete\n    accept:hook http1:request_started any any -> any any (sid:100;)\n    # allow GET\n    accept:hook http1:request_line any any -> any any ( \\\n            http.method; content:\"GET\"; sid:101;)\n    # or allow POST\n    accept:hook http1:request_line any any -> any any ( \\\n            http.method; content:\"POST\"; sid:102;)\n    # allow User-Agent curl\n    accept:hook http1:request_headers any any -> any any ( \\\n            http.user_agent; content:\"curl\"; sid:103;)\n    # allow the body, if any\n    accept:hook http1:request_body any any -> any any (sid:104;)\n    # allow trailers, if any\n    accept:hook http1:request_trailer any any -> any any (sid:105;)\n    # allow completion\n    accept:hook http1:request_complete any any -> any any (sid:106;)\n\n    # allow traffic before the response line is complete\n    accept:hook http1:response_started any any -> any any (sid:200;)\n    # allow the 200 ok stat code.\n    accept:hook http1:response_line any any -> any any ( \\\n            http.stat_code; content:\"200\"; sid:201;)\n    # allow all other states\n    accept:hook http1:response_headers any any -> any any (sid:202;)\n    accept:hook http1:response_body any any -> any any (sid:203;)\n    accept:hook http1:response_trailer any any -> any any (sid:204;)\n    accept:hook http1:response_complete any any -> any any (sid:205;)\n```\n\n----------------------------------------\n\nTITLE: Using suricatasc to Provide PCAP Files\nDESCRIPTION: This snippet shows how to use `suricatasc` to provide PCAP files to Suricata for processing. The `pcap-file` command adds PCAP files to a processing queue. The first argument is the path to the PCAP file and the second is the output directory for the generated logs/alerts. `pcap-file-continuous` allows specifying a directory to monitor for PCAP files.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/unix-socket.rst#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nroot@tiger:~# suricatasc\n>>> pcap-file /home/benches/file1.pcap /tmp/file1\nSuccess: Successfully added file to list\n>>> pcap-file /home/benches/file2.pcap /tmp/file2\nSuccess: Successfully added file to list\n>>> pcap-file-continuous /home/pcaps /tmp/dirout\nSuccess: Successfully added file to list\n```\n\n----------------------------------------\n\nTITLE: Initializing HTTP Logging Script\nDESCRIPTION: Initializes a Lua script to log HTTP transactions in Suricata. Sets the `protocol` requirement to \"http\", ensuring the script receives HTTP traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_1\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init (args)\n   local needs = {}\n   needs[\"protocol\"] = \"http\"\n   return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Creating a New Counter Based on Another\nDESCRIPTION: This example creates a new `flowint` counter named `cntpackets` and sets it to 0 only when `myvar` is set and equal to 3. This allows for conditional counting based on the value of another counter.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"when flowint counter is 3 create new counter\"; \\\n        content:\"Unauthorized\"; flowint:myvar, isset; flowint:myvar,==,3; \\\n        flowint:cntpackets,notset; flowint:cntpackets, =, 0;)\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Flags using Integer Value in Suricata\nDESCRIPTION: This example demonstrates matching the WebSocket flags using an 8-bit unsigned integer. The `websocket.flags` keyword examines the flags field in the WebSocket header.  Only the four upper bits are used.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.flags:128;\n```\n\n----------------------------------------\n\nTITLE: Configuring a Tenant YAML File (YAML)\nDESCRIPTION: This YAML snippet shows an example configuration for a tenant-specific YAML file. It includes settings for the default rule path, rule files, classification file, reference configuration file, and variables for address groups and port groups.  These settings are specific to each tenant.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\n# Set the default rule path here to search for the files.\n# if not set, it will look at the current working dir\ndefault-rule-path: /etc/suricata/rules\nrule-files:\n  - rules1\n\n# You can specify a threshold config file by setting \"threshold-file\"\n# to the path of the threshold config file:\n# threshold-file: /etc/suricata/threshold.config\n\nclassification-file: /etc/suricata/classification.config\nreference-config-file: /etc/suricata/reference.config\n\n# Holds variables that would be used by the engine.\nvars:\n\n  # Holds the address group vars that would be passed in a Signature.\n  # These would be retrieved during the Signature address parsing stage.\n  address-groups:\n\n    HOME_NET: \"[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]\"\n\n    EXTERNAL_NET: \"!$HOME_NET\"\n\n    ...\n\n  port-groups:\n\n    HTTP_PORTS: \"80\"\n\n    SHELLCODE_PORTS: \"!80\"\n\n    ...\n```\n\n----------------------------------------\n\nTITLE: Napatech Configuration Options in Suricata\nDESCRIPTION: This snippet showcases various Napatech configuration options available in Suricata's configuration file. These options control stream handling, hardware bypass, inline operation, port configurations, and hashmode selection for packet distribution.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\nnapatech:\n  # When use_all_streams is set to \"yes\" the initialization code will query\n  # the Napatech service for all configured streams and listen on all of them.\n  # When set to \"no\" the streams config array will be used.\n  #\n  # This option necessitates running the appropriate NTPL commands to create\n  # the desired streams prior to running Suricata.\n  #use-all-streams: no\n\n  # The streams to listen on when auto-config is disabled or when threading\n  # cpu-affinity is disabled. This can be either:\n  #   an individual stream (e.g. streams: [0])\n  # or\n  #   a range of streams (e.g. streams: [\"0-3\"])\n  #\n  streams: [\"0-3\"]\n\n  # Stream stats can be enabled to provide fine grain packet and byte counters\n  # for each thread/stream that is configured.\n  #\n  enable-stream-stats: no\n\n  # When auto-config is enabled the streams will be created and assigned\n  # automatically to the NUMA node where the thread resides. If cpu-affinity\n  # is enabled in the threading section, then the streams will be created\n  # according to the number of worker threads specified in the worker cpu set.\n  # Otherwise, the streams array is used to define the streams.\n  #\n  # This option cannot be used simultaneous with \"use-all-streams\".\n  #\n  auto-config: yes\n\n  # Enable hardware level flow bypass.\n  #\n  hardware-bypass: yes\n\n  # Enable inline operation. When enabled traffic arriving on a given port is\n  # automatically forwarded out it's peer port after analysis by Suricata.\n  # hardware-bypass must be enabled when this is enabled.\n  #\n  inline: no\n\n  # Ports indicates which napatech ports are to be used in auto-config mode.\n  # these are the port ID's of the ports that will be merged prior to the\n  # traffic being distributed to the streams.\n  #\n  # When hardware-bypass is enabled the ports must be configured as a segment\n  # specify the port(s) on which upstream and downstream traffic will arrive.\n  # This information is necessary for the hardware to properly process flows.\n  #\n  # When using a tap configuration one of the ports will receive inbound traffic\n  # for the network and the other will receive outbound traffic. The two ports on a\n  # given segment must reside on the same network adapter.\n  #\n  # When using a SPAN-port configuration the upstream and downstream traffic\n  # arrives on a single port. This is configured by setting the two sides of the\n  # segment to reference the same port.  (e.g. 0-0 to configure a SPAN port on\n  # port 0).\n  #\n  # port segments are specified in the form:\n  #    ports: [0-1,2-3,4-5,6-6,7-7]\n  #\n  # For legacy systems when hardware-bypass is disabled this can be specified in any\n  # of the following ways:\n  #\n  #   a list of individual ports (e.g. ports: [0,1,2,3])\n  #\n  #   a range of ports (e.g. ports: [0-3])\n  #\n  #   \"all\" to indicate that all ports are to be merged together\n  #   (e.g. ports: [all])\n  #\n  # This parameter has no effect if auto-config is disabled.\n  #\n  ports: [0-1,2-3]\n\n  # When auto-config is enabled the hashmode specifies the algorithm for\n  # determining to which stream a given packet is to be delivered.\n  # This can be any valid Napatech NTPL hashmode command.\n  #\n  # The most common hashmode commands are: hash2tuple, hash2tuplesorted,\n  # hash5tuple, hash5tuplesorted and roundrobin.\n  #\n  # See Napatech NTPL documentation other hashmodes and details on their use.\n  #\n  # This parameter has no effect if auto-config is disabled.\n  #\n  hashmode: hash5tuplesorted\n```\n\n----------------------------------------\n\nTITLE: Iptables Rules: Checking traffic to port 80\nDESCRIPTION: These iptables rules insert rules to send traffic with source port 80(INPUT chain) and destination port 80 (OUTPUT chain) to NFQUEUE. This is useful for monitoring traffic associated with web servers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I INPUT -p tcp --sport 80  -j NFQUEUE\nsudo iptables -I OUTPUT -p tcp --dport 80 -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Suricata rule to store PDF files (extension)\nDESCRIPTION: This Suricata rule stores files with a 'pdf' extension from HTTP traffic. It alerts on HTTP traffic and uses the `fileext` keyword to match files with the specified extension, then uses the `filestore` keyword to store the matched files. It only checks the extension and not the file content.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/file-extraction.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert http any any -> any any (msg:\"FILE PDF file claimed\"; fileext:\"pdf\"; filestore; sid:2; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for File Storage\nDESCRIPTION: This Suricata rule saves all file data for files opened/downloaded through HTTP. The `filestore` keyword triggers the file storage action.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\n  alert http any any -> any any (msg:\"FILE store all\"; filestore; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Create SSH Blacklist Rules\nDESCRIPTION: Example Suricata rules demonstrating the use of `xbits` to create a simple SSH blacklist. The first two rules set the 'badssh' xbit for the source IP when specific SSH software versions (libssh, PUTTY) are detected. The third rule drops traffic from IPs that have the 'badssh' xbit set.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/xbits.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndrop ssh any any -> $MYSERVER 22 (msg:\"DROP libssh incoming\";   \\\n  flow:to_server,established; ssh.software; content:\"libssh\";     \\\n  xbits:set, badssh, track ip_src, expire 3600; sid:4000000005;)\ndrop ssh any any -> $MYSERVER 22 (msg:\"DROP PUTTY incoming\";    \\\n  flow:to_server,established; ssh.software; content:\"PUTTY\";      \\\n  xbits:set, badssh, track ip_src, expire 3600; sid:4000000007;)\n\ndrop ssh any any -> $MYSERVER 22 (msg:\"DROP BLACKLISTED\";       \\\n  xbits:isset, badssh, track ip_src; sid:4000000006;)\n```\n\n----------------------------------------\n\nTITLE: Threshold Rule Example (backoff type)\nDESCRIPTION: This example shows the 'backoff' type, which limits alert output using a backoff algorithm. The rule uses 'stream-event:pkt_invalid_ack' and the alerts will be generated the 1st, 10th, 100th, etc. time the signature matches. It tracks by flow, with a count of 1 and a multiplier of 10.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/thresholding.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tcp any any -> any any (stream-event:pkt_invalid_ack;\n  :example-rule-emphasis:`threshold:type backoff, track by_flow, count 1, multiplier 10;`\n  sid:2210045; rev:2;)\n```\n\n----------------------------------------\n\nTITLE: Matching SIP URI in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match the SIP URI in a Suricata rule.  The `sip.uri` keyword allows matching against the URI found in a SIP request. The `content` option should contain a valid SIP URI.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.uri; content:\"sip:sip.url.org\";\n```\n\n----------------------------------------\n\nTITLE: Configuring ring-size in af-packet\nDESCRIPTION: This code snippet illustrates how to configure the `ring-size` parameter within the `af-packet` section of the `suricata.yaml` file. The `ring-size` determines the buffer size for packets per thread. A larger ring-size can help prevent packet drops when packet processing cannot keep up.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tuning-considerations.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\naf-packet:\n  - interface: eth0\n    threads: 5\n    ring-size: 100000\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Status Message in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match the SIP status message (reason phrase) in a Suricata rule. The `sip.stat_msg` keyword inspects the status message in a SIP response. The `content` option should contain a reason phrase associated with a status code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.stat_msg; content:\"Trying\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file size greater than\nDESCRIPTION: This Suricata rule demonstrates matching a file with a size greater than a specified value using the `filesize` keyword. It alerts if a file is larger than 100 megabytes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_18\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesize:>100MB;\n```\n\n----------------------------------------\n\nTITLE: Detecting Kerberos Weak Encryption Event in Suricata\nDESCRIPTION: This example demonstrates how to raise an event when weak or deprecated encryption parameters are detected in Kerberos traffic, using the `app-layer-event:krb5.weak_encryption` event in Suricata rules.  This could indicate usage of DES or key sizes smaller than 128 bits.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/kerberos-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert krb5 any any -> any any (msg:\"SURICATA Kerberos 5 weak encryption parameters\"; flow:to_client; app-layer-event:krb5.weak_encryption; classtype:protocol-command-decode; sid:2226001; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Loading nDPI plugin in suricata.yaml - YAML\nDESCRIPTION: This configuration snippet shows how to load the nDPI plugin in the `suricata.yaml` file.  This is necessary for Suricata to utilize nDPI for deep packet inspection.  The path to the `ndpi.so` library must be correct.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/plugins/ndpi.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nplugins:\n  - /usr/lib/suricata/ndpi.so\n```\n\n----------------------------------------\n\nTITLE: Creating a Suricata System User (Linux)\nDESCRIPTION: This command creates a system user named 'suricata' with no home directory and a disabled login shell. This user will be used to run the Suricata process with reduced privileges after it has been initialized as root.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nuseradd --no-create-home --system --shell /sbin/nologin suricata\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Websocket Opcode Inequality (Integer)\nDESCRIPTION: This code snippet demonstrates how to match a websocket opcode for inequality using the integer representation. `websocket.opcode:!9;` will match if the websocket opcode is not equal to 9, which corresponds to the `ping` opcode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nwebsocket.opcode:!9;\n```\n\n----------------------------------------\n\nTITLE: Suricata rule using datarep with SHA256 hash\nDESCRIPTION: This example shows a rule that uses `datarep` to check the reputation of a DNS query's SHA256 hash. It loads a SHA256 reputation list from `dns_sha256.rep` and checks if the reputation value is greater than 200.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns any any -> any any (dns.query; to_sha256; datarep:dns_sha256, >, 200, load dns_sha256.rep, type sha256; sid:2;)\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Common Section Example\nDESCRIPTION: This JSON snippet demonstrates the common structure found in all EVE log types generated by Suricata.  It highlights the consistent fields such as timestamp, flow_id, and event_type that are essential for event correlation and analysis. The `flow_id` is particularly crucial for linking related events across different log types.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\"timestamp\":\"2009-11-24T21:27:09.534255\",\"flow_id\":ID_NUMBER, \"event_type\":\"TYPE\", ...tuple... ,\"TYPE\":{ ... type specific content ... }}\n```\n\n----------------------------------------\n\nTITLE: Configuring NIC for RSS queues and symmetric hashing\nDESCRIPTION: Resets the NIC, sets up RSS queues, enables load balancing, and inserts a low-entropy Toeplitz key for symmetric hashing on a higher-end NIC (eth1). It disables receive offloading, disables adaptive control, and sets the ring RX descriptor size. Uses cluster_qm in Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nrmmod i40e && modprobe i40e\nifconfig eth1 down\n/usr/local/sbin/ethtool -L eth1 combined 16\n/usr/local/sbin/ethtool -K eth1 rxhash on\n/usr/local/sbin/ethtool -K eth1 ntuple on\nifconfig eth1 up\n/usr/local/sbin/ethtool -X eth1 hkey 6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A equal 16\n/usr/local/sbin/ethtool -A eth1 rx off \n/usr/local/sbin/ethtool -C eth1 adaptive-rx off adaptive-tx off rx-usecs 125\n/usr/local/sbin/ethtool -G eth1 rx 1024\n```\n\n----------------------------------------\n\nTITLE: Rotate Log File Configuration for EVE JSON Output\nDESCRIPTION: This snippet shows how to configure log rotation for EVE JSON output based on time intervals. It supports `minute`, `hour`, and `day` intervals. Also supports relative time specifications such as '30s', '30m', etc.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_8\n\nLANGUAGE: Config\nCODE:\n```\n  outputs:\n    - eve-log:\n        filename: eve-%Y-%m-%d-%H:%M.json\n        rotate-interval: minute\n```\n\nLANGUAGE: Config\nCODE:\n```\n  outputs:\n    - eve-log:\n        filename: eve-%Y-%m-%d-%H:%M:%S.json\n        rotate-interval: 30s\n```\n\n----------------------------------------\n\nTITLE: Matching JA3S hash in Suricata rule\nDESCRIPTION: This example illustrates how to create a Suricata rule to match a specific JA3S hash.  The `ja3s.hash` keyword is utilized, specifying that the content should be matched against the JA3S hash.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ja-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tls any any -> any any (msg:\"match JA3S hash\"; \\\n      ja3s.hash; content:\"b26c652e0a402a24b5ca2a660e84f9d5\"; \\\n      sid:100003;)\n```\n\n----------------------------------------\n\nTITLE: Configuring gro-flush-timeout in suricata.yaml\nDESCRIPTION: This snippet shows how to configure gro-flush-timeout in the suricata.yaml configuration file.  This indicates the timeout period for the watchdog timer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  gro-flush-timeout: 2000000\n```\n\n----------------------------------------\n\nTITLE: Complete FTP Log Example\nDESCRIPTION: This JSON snippet demonstrates a comprehensive FTP log entry, including all available fields. It shows the 'command', 'command_data', 'reply', 'completion_code', 'dynamic_port', 'mode', and 'reply_received' fields.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_23\n\nLANGUAGE: json\nCODE:\n```\n  \"ftp\": {\n    \"command\": \"EPRT\",\n    \"command_data\": \"|2|2a01:e34:ee97:b130:8c3e:45ea:5ac6:e301|41813|\",\n    \"reply\": [\n      \"EPRT command successful. Consider using EPSV.\"\n    ],\n    \"completion_code\": [\n      \"200\"\n    ],\n    \"dynamic_port\": 41813,\n    \"mode\": \"active\",\n    \"reply_received\": \"yes\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Filter DNS NXDOMAIN Events with jq\nDESCRIPTION: This command filters the eve.json file for DNS events with an rcode of NXDOMAIN, indicating a non-existent domain. The `-c` option makes the output compact.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-examplesjq.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntail -f eve.json|jq -c 'select(.dns.rcode==\"NXDOMAIN\")'\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Publish Message with Content\nDESCRIPTION: This example demonstrates matching the payload of a MQTT PUBLISH message using the `mqtt.publish.message` keyword combined with content matching. It requires the message type to be PUBLISH and matches payloads that start with the specified hexadecimal sequence. The publish message is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata Rule\nCODE:\n```\n# match on published JPEG images\nmqtt.type:PUBLISH; mqtt.publish.message; content:\"|FF D8 FF E0|\"; startswith;\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Media Encryption Key Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.media.encryption_key` keyword to match the Encryption key subfield in an SDP request or response. The `content` keyword specifies the encryption key string to search for, which follows the SDP scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.media.encryption_key; content:\"prompt\"\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Websocket Opcode Equality (Text)\nDESCRIPTION: This code snippet demonstrates how to match a websocket opcode based on its text representation.  `websocket.opcode:text;` matches if the websocket opcode is equal to `text`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nwebsocket.opcode:text;\n```\n\n----------------------------------------\n\nTITLE: Suricata rule to store files matching blacklisted MD5 checksum\nDESCRIPTION: This Suricata rule stores files whose MD5 checksum matches an entry in the 'fileextraction-chksum.list' blacklist. It alerts on HTTP traffic and uses the `filemd5` keyword to check the MD5 checksum against the list. If a match is found, the `filestore` keyword stores the file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/file-extraction.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert http any any -> any any (msg:\"Black list checksum match and extract MD5\"; filemd5:fileextraction-chksum.list; filestore; sid:4; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: HTTP Event Example (Extended Logging)\nDESCRIPTION: This example shows the structure of an 'http' event with extended logging enabled in Suricata's Eve JSON output.  In addition to the standard fields, it includes 'http_refer', 'http_method', 'protocol', 'status', and 'length', providing more detailed information about the HTTP transaction.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"http\": {\n      \"hostname\": \"direkte.vg.no\",\n      \"url\":\".....\",\n      \"http_user_agent\": \"<User-Agent>\",\n      \"http_content_type\": \"application\\/json\",\n      \"http_refer\": \"http:\\/\\/www.vg.no\\/\",\n      \"http_method\": \"GET\",\n      \"protocol\": \"HTTP\\/1.1\",\n      \"status\":\"200\",\n      \"length\":310\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Rules in disable.conf\nDESCRIPTION: This configuration file allows you to disable specific rules.  You can disable rules by SID, by rule file group name, or based on a regular expression matching the rule content.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n2019401                   # disable signature with this sid\ngroup:emerging-info.rules # disable this rulefile\nre:heartbleed             # disable all rules with this string\n```\n\n----------------------------------------\n\nTITLE: LDAP Search Result Done Alert Rule with Index\nDESCRIPTION: This Suricata rule alerts when an LDAP search_result_done response operation is detected at index 1. It uses the `ldap.responses.operation` keyword with the operation name `search_result_done` and index `1`. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP search response\"; :example-rule-emphasis:`ldap.responses.operation:search_result_done,1;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowbits OR Operation Example\nDESCRIPTION: This example demonstrates using the `flowbits` keyword with an OR operation using the `|` (pipe) character.  The rule alerts if either `user1` or `user2` flowbits are set. The `content` option checks for the string \"login\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"User1 or User2 logged in\"; \\\n  content:\"login\"; :example-rule-options:`flowbits:isset,user1|user2;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Password with Content\nDESCRIPTION: This example matches the MQTT password using the `mqtt.connect.password` keyword combined with a content match. It matches when the password is \"swordfish\". The password is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.password; content:\"swordfish\";\n```\n\n----------------------------------------\n\nTITLE: ICMPv6 MTU Rule - Suricata\nDESCRIPTION: This Suricata rule alerts when an ICMPv6 packet contains an MTU (Maximum Transmission Unit) value less than 1280.  It uses the `icmpv6.mtu` keyword to inspect the MTU value within the ICMPv6 header.  This can be useful for detecting MTU-related issues or attacks.  The rule assigns a signature ID (SID) and revision number.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_25\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip $EXTERNAL_NET any -> $HOME_NET any (:example-rule-emphasis:`icmpv6.mtu:<1280;` sid:1234; rev:5;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Adding to a Counter\nDESCRIPTION: This example increments the `myvar` counter by 2 whenever an \"Unauthorized\" message is detected, assuming the counter has already been initialized (i.e., `myvar` is `isset`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Adding to flowint counter\";                \\\n        content:\"Unauthorized\"; flowint:myvar,isset; flowint: myvar,+,2;)\n```\n\n----------------------------------------\n\nTITLE: Engine Analysis: Protocol Detection Only Rule\nDESCRIPTION: This JSON snippet is the Engine Analysis report for a Protocol Detection Only rule in Suricata. It includes the rule's ID, message, requirements, type (pd_only), flags, and configuration details for the packet engine and app-layer-protocol matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"raw\": \"alert tcp any any -> any any (msg:\\\"tcp, pd positive dns\\\"; app-layer-protocol:dns; sid:403;)\",\n  \"id\": 403,\n  \"gid\": 1,\n  \"rev\": 0,\n  \"msg\": \"tcp, pd positive dns\",\n  \"app_proto\": \"unknown\",\n  \"requirements\": [],\n  \"type\": \"pd_only\",\n  \"flags\": [\n    \"src_any\",\n    \"dst_any\",\n    \"sp_any\",\n    \"dp_any\",\n    \"toserver\",\n    \"toclient\"\n  ],\n  \"pkt_engines\": [\n    {\n      \"name\": \"packet\",\n      \"is_mpm\": false\n    }\n  ],\n  \"frame_engines\": [],\n  \"lists\": {\n    \"packet\": {\n      \"matches\": [\n        {\n          \"name\": \"app-layer-protocol\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accept TLS traffic based on SNI - Suricata\nDESCRIPTION: This example shows how to create a Suricata firewall based on TLS SNI (Server Name Indication).  It first establishes a 3-way handshake and established TCP connections on port 443.  Then, it applies rules to accept traffic for specific TLS SNI values ('suricata.io' or 'oisf.net') during the 'client_hello_done' state of the TLS handshake. Other TLS states are accepted without specific SNI checks.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/firewall/firewall-example.rst#_snippet_2\n\nLANGUAGE: suricata\nCODE:\n```\n# allow 3-way handshake\n    accept:hook tcp:all $HOME_NET any -> $EXTERNAL_NET 443 (flags:S; \\\n            flow:not_established; flowbits:set,syn; sid:1;)\n    accept:hook tcp:all $EXTERNAL_NET 443 -> $HOME_NET any (flags:SA; \\\n            flow:not_established; flowbits:isset,syn; flowbits:set,synack; sid:2;)\n    accept:hook tcp:all $HOME_NET any -> $EXTERNAL_NET 443 (flags:A; \\\n            flow:not_established; flowbits:isset,synack;             \\\n            flowbits:unset,syn; flowbits:unset,synack; sid:3;)\n    # allow established\n    accept:hook tcp:all $HOME_NET any <> $EXTERNAL_NET 443 (flow:established; sid:4;)\n\n    accept:hook tls:client_in_progress $HOME_NET any -> $EXTERNAL_NET any (sid:100;)\n    # allow the good sites\n    accept:hook tls:client_hello_done $HOME_NET any -> $EXTERNAL_NET any (tls.sni; \\\n            pcre:\"/^(suricata.io|oisf.net)$/\"; sid:101;)\n    accept:hook tls:client_cert_done $HOME_NET any -> $EXTERNAL_NET any (sid:102;)\n    accept:hook tls:client_handshake_done $HOME_NET any -> $EXTERNAL_NET any (sid:103;)\n    accept:hook tls:client_finished $HOME_NET any -> $EXTERNAL_NET any (sid:104;)\n\n    accept:hook tls:server_in_progress $EXTERNAL_NET any -> $HOME_NET any (sid:200;)\n    accept:hook tls:server_hello $EXTERNAL_NET any -> $HOME_NET any (sid:201;)\n    accept:hook tls:server_cert_done $EXTERNAL_NET any -> $HOME_NET any (sid:202;)\n    accept:hook tls:server_hello_done $EXTERNAL_NET any -> $HOME_NET any (sid:203;)\n    accept:hook tls:server_handshake_done $EXTERNAL_NET any -> $HOME_NET any (sid:204;)\n    accept:hook tls:server_finished $EXTERNAL_NET any -> $HOME_NET any (sid:205;)\n```\n\n----------------------------------------\n\nTITLE: Installing from Package Repositories (Fedora)\nDESCRIPTION: This command sequence installs Suricata using dnf on Fedora. It enables the Suricata COPR repository and then installs the Suricata package. Requires sudo.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_5\n\nLANGUAGE: none\nCODE:\n```\nsudo dnf install dnf-plugins-core\nsudo dnf copr enable @oisf/suricata-7.0\nsudo dnf install suricata\n```\n\n----------------------------------------\n\nTITLE: Checking NIC NUMA Node (Bash)\nDESCRIPTION: This command determines the NUMA node to which a specific network interface card (NIC) is connected. Replace `<KERNEL NAME OF THE NIC>` with the actual kernel name of the NIC (e.g., eth1). The command reads the contents of the `/sys/class/net/<NIC>/device/numa_node` file, which contains the NUMA node number.  Knowing the NIC's NUMA node is essential for allocating hugepages on the same node to avoid performance penalties.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\ncat /sys/class/net/eth1/device/numa_node\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Request Header in Lua\nDESCRIPTION: This code demonstrates how to retrieve a specific HTTP request header using the `HttpGetRequestHeader()` function. It handles cases where the header is not available and provides a default value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_8\n\nLANGUAGE: lua\nCODE:\n```\nhttp_ua = HttpGetRequestHeader(\"User-Agent\")\nif http_ua == nil then\n    http_ua = \"<useragent unknown>\"\nend\n```\n\n----------------------------------------\n\nTITLE: Enabling symmetric hashing on Intel NIC\nDESCRIPTION: This set of commands configures an Intel network card to emulate symmetric hashing. It disables the interface, sets the number of combined channels, enables rxhash and ntuple, brings the interface up, sets IRQ affinity, configures the hashing key, and displays the ethtool settings.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nifconfig eth3 down\n\nEnable symmetric hashing ::\n\nifconfig eth3 down \nethtool -L eth3 combined 16 # if you have at least 16 cores\nethtool -K eth3 rxhash on \nethtool -K eth3 ntuple on\nifconfig eth3 up\n./set_irq_affinity 0-15 eth3\nethtool -X eth3 hkey 6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A equal 16\nethtool -x eth3\nethtool -n eth3\n```\n\n----------------------------------------\n\nTITLE: Setting Default Log Directory in Suricata YAML\nDESCRIPTION: This snippet configures the default directory where Suricata stores its log files (alerts and events). The default directory is /var/log/suricata. This can be overridden using the -l command line parameter or directly in the YAML file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-log-dir: /var/log/suricata\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with Netmap Pipe\nDESCRIPTION: This command starts Suricata, instructing it to read from a Netmap pipe. The `--netmap=netmap:suricata` option tells Suricata to use Netmap for packet capture and to read from the Netmap pipe named `suricata`. This setup is used when load balancing with the `lb` tool.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --netmap=netmap:suricata\n```\n\n----------------------------------------\n\nTITLE: Viewing Suricata Statistics\nDESCRIPTION: Monitors Suricata statistics using `tail -f` to view the `stats.log` file.  This file shows metrics such as the number of packets processed and traffic type.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nsudo tail -f /var/log/suricata/stats.log\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Key Exchange Payload with Content - Suricata\nDESCRIPTION: This snippet demonstrates how to match the public key exchange payload (e.g. Diffie-Hellman) of the server or client using the `ike.key_exchange_payload` keyword and the `content` modifier in a Suricata rule. `ike.key_exchange_payload` is a sticky buffer and can be used as a fast pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nike.key_exchange_payload; content:\"|6d026d5616c45be05e5b898411e9|\"\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with 'rev' Keyword Example\nDESCRIPTION: This snippet shows a Suricata rule including the 'rev' keyword. It's convention to place 'rev' after the 'sid' keyword, commonly as the final two keywords in the rule. This allows for version control and tracking of rule updates.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: SHA-256 Hasher Usage in Lua\nDESCRIPTION: This code snippet demonstrates how to use the SHA-256 hasher in Lua. It initializes the hasher, updates it with multiple strings, and then finalizes the hash to get a hex string representation. This provides an example of incremental hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/hashlib.rst#_snippet_1\n\nLANGUAGE: Lua\nCODE:\n```\nlocal hashing = require(\"suricata.hashing\")\nhasher = hashing.sha256()\nhasher.update(\"www.suricata\")\nhasher.update(\".io\")\nhash = hasher.finalize_to_hex()\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP2 Error Code\nDESCRIPTION: This keyword is used to match the error code found in GOAWAY or RST_STREAM frames.  It helps identify specific error conditions within the HTTP2 stream. Valid error codes include NO_ERROR and INADEQUATE_SECURITY.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http2-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nhttp2.errorcode: NO_ERROR;\nhttp2.errorcode: INADEQUATE_SECURITY;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with Negated tos Keyword\nDESCRIPTION: This rule shows how to negate the `tos` keyword to match packets that do *not* have a specific TOS value. This checks if the TOS value is not 8.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"tos keyword example with negated content\"; flow:established,to_server; tos:!8; classtype:bad-unknown; sid:14; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Displaying Iptables Rules\nDESCRIPTION: This command displays the current iptables rules with verbose output and numerical addresses, showing packet and byte counters for each rule. It verifies that the rules are logging packets.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -vnL\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule using ndpi-protocol keyword\nDESCRIPTION: This Suricata rule example demonstrates the use of the `ndpi-protocol` keyword. It checks for TLS traffic on port 53.  It requires the `ndpi-protocol` keyword to be present.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/plugins/ndpi.rst#_snippet_2\n\nLANGUAGE: suricata\nCODE:\n```\nalert tcp any any -> any 53 (msg:\"TLS traffic over DNS standard port\"; requires:keyword ndpi-protocol; ndpi-protocol:TLS; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: LDAP Bind Response Alert Rule\nDESCRIPTION: This Suricata rule alerts when an LDAP bind response operation is detected. It uses the `ldap.responses.operation` keyword with the operation code `1` to identify the bind response. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP bind response\"; :example-rule-emphasis:`ldap.responses.operation:1;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Bitmask Matching (Equality)\nDESCRIPTION: This code snippet demonstrates how to match an integer value based on a bitmask. `bsize:&0xc0=0x80;` applies a bitwise AND operation between the `bsize` field and `0xc0`. The rule matches only if the result is equal to `0x80`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:&0xc0=0x80;\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Status Message with Suricata Rule\nDESCRIPTION: This Suricata rule illustrates detecting a specific HTTP status message using the `http.stat_msg` keyword. It searches for the status message \"OK\" in the HTTP response. The `flow` keyword specifies the traffic direction to be 'to_client'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_24\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Stat Message Response \\\nExample\"; flow:established,to_client; :example-rule-options:`http.stat_msg; \\\ncontent:\"OK\";` classtype:bad-unknown; sid:118; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Message Type\nDESCRIPTION: This example demonstrates matching the MQTT message type using the `mqtt.type` keyword. It matches CONNECT and PUBLISH message types, also shows how to match using integer value (2). Valid values are CONNECT, CONNACK, PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, PINGREQ, PINGRESP, DISCONNECT, AUTH and UNASSIGNED.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.type:CONNECT;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.type:PUBLISH;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.type:2;\n```\n\n----------------------------------------\n\nTITLE: Iptables: Port 80 traffic to NFQUEUE\nDESCRIPTION: These iptables rules forward all incoming traffic on source port 80 and all outgoing traffic on destination port 80 to the NFQUEUE. This allows Suricata to inspect traffic on port 80. It assumes the default queue number (0) is being used by Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I INPUT -p tcp --sport 80  -j NFQUEUE\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I OUTPUT -p tcp --dport 80 -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Setting Rule Paths in Suricata.yaml\nDESCRIPTION: This snippet shows how to define rule paths and specify rule files in Suricata's YAML configuration file.  The `default-rule-path` specifies the default directory for rule files, while the `rule-files` section lists the specific rule files to be loaded. Suricata handles decoder, stream, and HTTP events through normal rule files instead of preprocessor rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-rule-path: /etc/suricata/rules\nrule-files:\n - local.rules\n - emerging-activex.rules\n```\n\nLANGUAGE: yaml\nCODE:\n```\nrule-files:\n - decoder-events.rules\n - stream-events.rules\n - http-events.rules\n - smtp-events.rules\n```\n\n----------------------------------------\n\nTITLE: Setting Rule Paths in Snort.conf\nDESCRIPTION: This snippet shows how to define rule paths and include rule files in a Snort configuration file using `var` and `include` directives. These settings point to rule files (local rules, emerging threat rules) that will be loaded by Snort for traffic analysis.  It also specifies path variables for shared object and preprocessor rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nvar RULE_PATH ../rules\nvar SO_RULE_PATH ../so_rules\nvar PREPROC_RULE_PATH ../preproc_rules\n\ninclude $RULE_PATH/local.rules\ninclude $RULE_PATH/emerging-activex.rules\n...\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP2 Multiple Header Matching\nDESCRIPTION: This Suricata rule demonstrates multiple header matching for HTTP2 traffic. It looks for \"method|3a 20|GET\" in one HTTP request header and \"authority|3a 20|example.com\" in another header within the same HTTP2 flow. The rule will alert if both header conditions are met.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/multi-buffer-matching.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http2 any any -> any any (msg:\"HTTP2 Multiple Header Buffer Example\"; flow:established,to_server; http.request_header; content:\"method|3a 20|GET\"; http.request_header; content:\"authority|3a 20|example.com\"; classtype:misc-activity; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP CIP Class in Suricata Rules\nDESCRIPTION: The `enip.cip_class` keyword is used to match on the CIP class in CIP request path. It uses a 32-bit unsigned integer as its value. This allows matching without needing to match on cip.service.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_class:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_class:>1;\n```\n\n----------------------------------------\n\nTITLE: Matching Kerberos Message Type in Suricata\nDESCRIPTION: This example demonstrates how to match Kerberos messages based on their type using the `krb5_msg_type` keyword in Suricata rules. The keyword allows specifying integer values corresponding to Kerberos message types defined in RFC4120, such as AS-REQ (10), AS-REP (11), TGS-REQ (12), TGS-REP (13), and ERROR (30).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/kerberos-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert krb5 any any -> any any (msg:\"Kerberos 5 AS-REQ message\"; krb5_msg_type:10; sid:3; rev:1;)\n alert krb5 any any -> any any (msg:\"Kerberos 5 AS-REP message\"; krb5_msg_type:11; sid:4; rev:1;)\n alert krb5 any any -> any any (msg:\"Kerberos 5 TGS-REQ message\"; krb5_msg_type:12; sid:5; rev:1;)\n alert krb5 any any -> any any (msg:\"Kerberos 5 TGS-REP message\"; krb5_msg_type:13; sid:6; rev:1;)\n alert krb5 any any -> any any (msg:\"Kerberos 5 ERROR message\"; krb5_msg_type:30; sid:7; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file magic\nDESCRIPTION: This Suricata rule example demonstrates how to use the `file.magic` keyword to match the magic bytes of a file. It alerts if a file identified as \"executable for MS Windows\" by libmagic is seen in network traffic.  The `file.magic` keyword leverages the libmagic library to determine the file type.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nfile.magic; content:\"executable for MS Windows\";\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata engine\nDESCRIPTION: This command starts the Suricata engine with a specified configuration file and interface card.  The '-c' option specifies the path to the suricata.yaml configuration file, and the '-i' option specifies the interface to monitor. The command requires root privileges.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata -c /etc/suricata/suricata.yaml -i wlan0\n```\n\n----------------------------------------\n\nTITLE: Initializing HTTP Rule Matching Script\nDESCRIPTION: Initializes a Lua script for rule matching on HTTP requests within Suricata. Sets the `http.request_line` requirement to `true`, enabling rule matching on the HTTP request line.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_2\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init (args)\n   local needs = {}\n   needs[\"http.request_line\"] = tostring(true)\n   return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: vlan.id equal to 300 at layer 1\nDESCRIPTION: This Suricata rule example shows how to configure a rule that will alert if the VLAN ID at layer 1 is equal to 300. It uses the `vlan.id` keyword with the value `300` and specifies the layer `1`. The rule will only match traffic with a VLAN ID of 300 at the specified layer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"Vlan ID is equal to 300 at layer 1\"; vlan.id:300,1; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: IKE Logging Example\nDESCRIPTION: This JSON snippet shows an example of IKE (Internet Key Exchange) logging data generated by Suricata. It includes details about the IKE version, SPIs, message ID, exchange type, security association lifetime, encryption, hashing, authentication, Diffie-Hellman group, key length, ESN, and payloads. It also provides specific information about the client and server, such as key exchange and nonce payloads, as well as a list of vendor IDs.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_72\n\nLANGUAGE: JSON\nCODE:\n```\n  \"ike\": {\n    \"version_major\": 1,\n    \"version_minor\": 0,\n    \"init_spi\": \"8511617bfea2f172\",\n    \"resp_spi\": \"c0fc6bae013de0f5\",\n    \"message_id\": 0,\n    \"exchange_type\": 2,\n    \"exchange_type_verbose\": \"Identity Protection\",\n    \"sa_life_type\": \"LifeTypeSeconds\",\n    \"sa_life_type_raw\": 1,\n    \"sa_life_duration\": \"Unknown\",\n    \"sa_life_duration_raw\": 900,\n    \"alg_enc\": \"EncAesCbc\",\n    \"alg_enc_raw\": 7,\n    \"alg_hash\": \"HashSha2_256\",\n    \"alg_hash_raw\": 4,\n    \"alg_auth\": \"AuthPreSharedKey\",\n    \"alg_auth_raw\": 1,\n    \"alg_dh\": \"GroupModp2048Bit\",\n    \"alg_dh_raw\": 14,\n    \"sa_key_length\": \"Unknown\",\n    \"sa_key_length_raw\": 256,\n    \"alg_esn\": \"NoESN\",\n    \"payload\": [\n      \"VendorID\",\n      \"Transform\",\n      \"Proposal\",\n      \"SecurityAssociation\"\n    ],\n    \"ikev1\": {\n      \"doi\": 1,\n      \"encrypted_payloads\": false,\n      \"client\": {\n        \"key_exchange_payload\": \"0bf7907681a656aabed38fb1ba8918b10d707a8e635a...\",\n        \"key_exchange_payload_length\": 256,\n        \"nonce_payload\": \"1427d158fc1ed6bbbc1bd81e6b74960809c87d18af5f0abef14d5274ac232904\",\n        \"nonce_payload_length\": 32,\n        \"proposals\": [\n          {\n            \"sa_life_type\": \"LifeTypeSeconds\",\n            \"sa_life_type_raw\": 1,\n            \"sa_life_duration\": \"Unknown\",\n            \"sa_life_duration_raw\": 900,\n            \"alg_enc\": \"EncAesCbc\",\n            \"alg_enc_raw\": 7,\n            \"alg_hash\": \"HashSha2_256\",\n            \"alg_hash_raw\": 4,\n            \"alg_auth\": \"AuthPreSharedKey\",\n            \"alg_auth_raw\": 1,\n            \"alg_dh\": \"GroupModp2048Bit\",\n            \"alg_dh_raw\": 14,\n            \"sa_key_length\": \"Unknown\",\n            \"sa_key_length_raw\": 256\n          }\n        ]\n      },\n      \"server\": {\n        \"key_exchange_payload\": \"1e43be52b088ec840ff81865074b6d459b5ca7813b46...\",\n        \"key_exchange_payload_length\": 256,\n        \"nonce_payload\": \"04d78293ead007bc1a0f0c6c821a3515286a935af12ca50e08905b15d6c8fcd4\",\n        \"nonce_payload_length\": 32\n      },\n      \"vendor_ids\": [\n        \"4048b7d56ebce88525e7de7f00d6c2d3\",\n        \"4a131c81070358455c5728f20e95452f\",\n        \"afcad71368a1f1c96b8696fc77570100\",\n        \"7d9419a65310ca6f2c179d9215529d56\",\n        \"cd60464335df21f87cfdb2fc68b6a448\",\n        \"90cb80913ebb696e086381b5ec427b1f\"\n      ]\n    },\n  }\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Request Host in Lua\nDESCRIPTION: This snippet demonstrates how to retrieve the HTTP request host using the `HttpGetRequestHost()` function. It handles cases where the host is not available and provides a default value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_7\n\nLANGUAGE: lua\nCODE:\n```\nhttp_host = HttpGetRequestHost()\nif http_host == nil then\n    http_host = \"<hostname unknown>\"\nend\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Content-Type Header in Suricata Rules\nDESCRIPTION: This snippet illustrates how to match the SIP Content-Type header in a Suricata rule. The `sip.content_type` keyword is used to inspect the Content-Type header field. The `content` option should contain the value of the Content-Type header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.content_type; content:\"application/sdp\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata with eBPF Support (Bash)\nDESCRIPTION: This code snippet configures Suricata with eBPF support. It specifies the Clang compiler for building C sources, enables eBPF build, and sets installation directories. The `autogen.sh` script is called before the configure script to generate the configure script.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n ./autogen.sh\n\n CC=clang ./configure --prefix=/usr/ --sysconfdir=/etc/ --localstatedir=/var/ \\\n --enable-ebpf --enable-ebpf-build\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Time Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.time` keyword to match the time field in an SDP request or response. The `content` keyword specifies the time string to search for, which follows the SDP time (t=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.time; content:\"3034423619 3042462419\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Max Pending Packets in Suricata YAML\nDESCRIPTION: This snippet sets the maximum number of packets Suricata can process simultaneously. A higher value increases performance but consumes more memory. This setting directly impacts Suricata's resource usage and processing capacity.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nmax-pending-packets: 1024\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Certificate NotBefore Date in Suricata\nDESCRIPTION: This example demonstrates matching the 'NotBefore' date within a TLS certificate using the `tls_cert_notbefore` keyword in Suricata. It shows how to define a date range that the certificate's 'NotBefore' date must fall within.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"match cert NotBefore\"; \\\n    tls_cert_notbefore:1998-05-01<>2008-05-01; sid:200005;)\n```\n\n----------------------------------------\n\nTITLE: Calculating SHA256 Hash of HTTP Request Line - Suricata Rule\nDESCRIPTION: This rule calculates the SHA-256 hash of the `http_request_line` buffer using the `to_sha256` transformation. The content keyword then checks if the calculated hash matches the specified SHA-256 hash.  The SHA-256 hash is represented as a raw byte string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http_request_line; to_sha256; \\\n    content:\"|54A9 7A8A B09C 1B81 3725 2214 51D3 F997 F015 9DD7 049E E5AD CED3 945A FC79 7401|\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Getting DNS rcode as string in Lua\nDESCRIPTION: This code shows how to retrieve the DNS response code (rcode) as a string using the `rcode_string()` method on the transaction object.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_8\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nlocal rcode_string = tx:rcode_string();\nprint (rcode_string)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: All vlan.id greater than 100\nDESCRIPTION: This Suricata rule example shows how to create a rule that alerts only if all VLAN IDs are greater than 100. It uses the `vlan.id` keyword with the operator `>` and the value `100`, specifying `all` to ensure all VLAN layers must meet the condition.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"All Vlan IDs are greater than 100\"; vlan.id:>100,all; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching SSH Client HASSH String\nDESCRIPTION: This rule matches SSH connections based on the client's HASSH string (list of SSH algorithms). The `ssh.hassh.string` keyword specifies that the content matching will occur on the client HASSH string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ssh-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ssh any any -> any any (msg:\"match hassh-string\"; \\\n      ssh.hassh.string; content:\"none,zlib@openssh.com,zlib\"; \\\n      sid:1000030;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Community ID in EVE Logger - YAML\nDESCRIPTION: This YAML configuration snippet shows how to enable or disable the 'community_id' feature in Suricata's EVE logger and how to set the 'community-id-seed'. The seed value must be an unsigned 16-bit integer (0-65535) and should be the same across all tools that generate these records. Setting community-id to true enables the feature; false disables it.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_13\n\nLANGUAGE: YAML\nCODE:\n```\n  - eve-log:\n      # Community Flow ID\n      # Adds a 'community_id' field to EVE records. These are meant to give\n      # a records a predictable flow id that can be used to match records to\n      # output of other tools such as Bro.\n      #\n      # Takes a 'seed' that needs to be same across sensors and tools\n      # to make the id less predictable.\n\n      # enable/disable the community id feature.\n      community-id: false\n      # Seed value for the ID output. Valid values are 0-65535.\n      community-id-seed: 0\n```\n\n----------------------------------------\n\nTITLE: Examining Suricata Rule Message\nDESCRIPTION: This code snippet shows an example of a Suricata rule message.  The message provides a brief description of what the rule is designed to detect.  In this case, the rule is named \"ET SCAN sipscan probe\", indicating it's part of the Emerging Threats ruleset, detects a scan, specifically a sipscan probe.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/make-sense-alerts.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nmsg:\"ET SCAN sipscan probe\";\n```\n\n----------------------------------------\n\nTITLE: Enabling SWF Decompression in Suricata Libhtp Configuration\nDESCRIPTION: This configuration snippet demonstrates how to enable SWF (Flash) decompression in Suricata's libhtp configuration. It enables both deflate and lzma decompression types and sets the compression and decompression depth to 0 for unlimited data processing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_30\n\nLANGUAGE: YAML\nCODE:\n```\nswf-decompression:\n  enabled: yes\n  type: both\n  compress-depth: 0\n  decompress-depth: 0\n```\n\n----------------------------------------\n\nTITLE: Auto-Setup with configure, make, install-rules - Bash\nDESCRIPTION: This command configures, compiles, and installs Suricata, and also downloads and sets up the latest ruleset from Emerging Threats. It combines the actions of ./configure, make, and make install-rules into a single command.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && make install-rules\n```\n\n----------------------------------------\n\nTITLE: Bypass Rules Example (Suricata Rules)\nDESCRIPTION: This shows a pair of Suricata rules using the `bypass` keyword.  These rules bypass traffic identified as video or Skype by using flowbits. This allows for selective bypassing of traffic based on signature matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_11\n\nLANGUAGE: Suricata Rules\nCODE:\n```\n alert any any -> any any (msg:\"bypass video\"; flowbits:isset,traffic/label/video; noalert; bypass; sid:1000000; rev:1;)\n alert any any -> any any (msg:\"bypass Skype\"; flowbits:isset,traffic/id/skype; noalert; bypass; sid:1000001; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Executing NTPL Commands\nDESCRIPTION: These shell commands are used to delete any existing filters and assign all physical ports to stream ID 0 using the `ntpl` tool.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\n\tDelete=All\t\t\t\t# Delete any existing filters\n\tAssign[streamid=(0..3)]= all\t# Assign all physical ports to stream ID 0\n```\n\nLANGUAGE: Shell\nCODE:\n```\n\t$ /opt/napatech3/bin/ntpl -f <my_ntpl_file>\n```\n\n----------------------------------------\n\nTITLE: Checking for alerts on a flow in Lua\nDESCRIPTION: This snippet checks if the flow has triggered any alerts. It returns `true` if alerts have been generated for the flow, and `false` otherwise.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_7\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\nalerted = f:has_alerts()\n```\n\n----------------------------------------\n\nTITLE: Setting File Permissions for Suricata Run Directory\nDESCRIPTION: These commands modify the group ownership and permissions of the /var/run/suricata directory. They set the group to 'suricata' and grant read, write, and setgid permissions to the group.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nchgrp -R suricata /var/run/suricata\nchmod -R g+srw /var/run/suricata\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with AF_XDP enabled\nDESCRIPTION: These commands illustrate how to start Suricata with AF_XDP enabled, specifying the network interface to capture traffic from.  The --af-xdp=<interface> option tells Suricata to use the specified interface for AF_XDP capture.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsuricata --af-xdp=<interface>\nsuricata --af-xdp=igb0\n```\n\n----------------------------------------\n\nTITLE: Splitting Configuration with Include in Suricata YAML\nDESCRIPTION: This code shows how to use the '!include' directive to include content from another YAML file. This allows for modular configuration. The 'outputs' section content is stored in 'outputs.yaml' and included.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n# outputs.yaml\n- fast\n    enabled: yes\n    filename: fast.log\n    append: yes\n\n...\n\n```\n\nLANGUAGE: yaml\nCODE:\n```\n# suricata.yaml\n...\n\noutputs: !include outputs.yaml\n\n...\n```\n\n----------------------------------------\n\nTITLE: Retrieving JA3S Hash for Detection in Lua\nDESCRIPTION: This code demonstrates retrieving the JA3S hash for detection purposes in a Suricata Lua script, including a check for a nil value and a placeholder for matching code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_32\n\nLANGUAGE: lua\nCODE:\n```\nfunction match (args)\n    hash = Ja3SGetHash()\n    if hash == nil then\n      return 0\n    end\n\n    // matching code\n\n    return 0\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with sameip Keyword\nDESCRIPTION: This example shows how to use the `sameip` keyword in a Suricata rule to detect packets where the source and destination IP addresses are identical. It alerts on any IP packet exhibiting this characteristic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"IP Packet with the same source and destination IP\"; sameip; classtype:bad-unknown; sid:3; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Command in Suricata Rules\nDESCRIPTION: The `enip_command` keyword is used to match against the command field in the ENIP encapsulation. It supports matching against unsigned 16-bit integers or text from the enumeration. This keyword helps in identifying specific ENIP commands within network traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nenip_command:99;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip_command:list_identity;\n```\n\n----------------------------------------\n\nTITLE: Suricata af-packet Configuration (NUMA aware)\nDESCRIPTION: Configuration settings for af-packet capture in Suricata's `suricata.yaml` file. Sets interface, number of threads, cluster-id, and cluster-type to cluster_qm. It also configures defrag, memory locking, tpacket-v3, ring-size, and block-size parameters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\n- interface: eth1\n    # Number of receive threads. \"auto\" uses the number of cores\n    threads: 18 \n    cluster-id: 99\n    cluster-type: cluster_qm\n    defrag: no\n    mmap-locked: yes\n    tpacket-v3: yes\n    ring-size: 100000\n    block-size: 1048576\n  - interface: eth1\n    # Number of receive threads. \"auto\" uses the number of cores\n    threads: 18 \n    cluster-id: 99\n    cluster-type: cluster_qm\n    defrag: no\n    mmap-locked: yes\n    tpacket-v3: yes\n    ring-size: 100000\n    block-size: 1048576\n```\n\n----------------------------------------\n\nTITLE: Clearing Napatech Stream Definitions via NTPL\nDESCRIPTION: This snippet shows how to use the Napatech NTPL command-line tool to clear stream definitions.  This is useful for cleaning up stale stream configurations after abnormal Suricata termination. Requires the `ntpl` tool from the Napatech SDK.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n# /opt/napatech3/bin/ntpl -e \"delete=all\"\n```\n\n----------------------------------------\n\nTITLE: LDAP Search Result Entry Alert Rule (All)\nDESCRIPTION: This Suricata rule alerts if all responses are of type search_result_entry. It uses the `ldap.responses.operation` keyword with the operation name `search_result_entry` and index `all`. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP search response\"; :example-rule-emphasis:`ldap.responses.operation:search_result_entry,all;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Response Body\nDESCRIPTION: Retrieves the HTTP response body using the `response_body()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_15\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nhttp_response_body = tx:response_body()\nprint(http_response_body)\n```\n\n----------------------------------------\n\nTITLE: Basic C Unit Test Structure\nDESCRIPTION: This code snippet demonstrates the basic structure of a C unit test in Suricata. It includes the function signature, the use of FAIL_* and PASS macros for indicating test results. It checks various conditions and reports failures if they occur.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-c.rst#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid MyUnitTest(void)\n{\n    int n = 1;\n    void *p = NULL;\n\n    FAIL_IF(n != 1);\n    FAIL_IF_NOT(n == 1);\n    FAIL_IF_NOT_NULL(p);\n    FAIL_IF_NULL(p);\n\n    PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Location Header in Suricata\nDESCRIPTION: This Suricata rule matches on the HTTP Location header in HTTP responses. It uses the `http.location` keyword along with the `content` keyword to search for a specific string within the Location header. The rule includes options like `flow`, `bsize`, `classtype`, `sid`, and `rev` for defining the flow direction, buffer size, classification, rule ID, and revision number, respectively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_18\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Location Example\"; \\\n  flow:established,to_client; :example-rule-options:`http.location; \\\n  content:\"suricata.io\";` bsize:11; classtype:bad-unknown; sid:122; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching SSH Server HASSH MD5\nDESCRIPTION: This rule matches SSH connections based on the server's HASSH (hash of SSH algorithms) MD5 hash. The `ssh.hassh.server` keyword specifies that the content matching will occur on the server HASSH value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ssh-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ssh any any -> any any (msg:\"match SSH hash-server\"; \\\n      ssh.hassh.server; content:\"b12d2871a1189eff20364cf5333619ee\"; \\\n      sid:1000020;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Default Log Directory Configuration\nDESCRIPTION: This snippet shows how to configure the default log directory in Suricata's YAML configuration file. The `default-log-dir` option specifies the directory where Suricata will store its logs. This location can be overridden using the `-l` command-line option.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ndefault-log-dir: /var/log/suricata/\n```\n\n----------------------------------------\n\nTITLE: Setting the Number of RSS Queues for Intel X710\nDESCRIPTION: This command uses `ethtool` to set the number of combined RSS queues to 1 for the specified network interface ($DEV). This is recommended to ensure proper packet ordering and avoid issues with Suricata's traffic analysis when using non-symmetric RSS hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-capture.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nethtool -L $DEV combined 1\n```\n\n----------------------------------------\n\nTITLE: Retrieving TLS Version in Lua\nDESCRIPTION: This code demonstrates how to retrieve the negotiated TLS version using the `TlsGetVersion()` function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_20\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    version = TlsGetVersion()\n    if version then\n        -- do something\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Matching DNP3 Application Data Objects with dnp3_obj\nDESCRIPTION: This keyword matches on DNP3 application data objects based on their group and variation numbers. Both the group and variation are specified as integer values between 0 and 255.  This allows for filtering network traffic based on the specific data objects being transmitted.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dnp3-keywords.rst#_snippet_2\n\nLANGUAGE: None\nCODE:\n```\ndnp3_obj:<group>,<variation>\n```\n\n----------------------------------------\n\nTITLE: Detecting Raw HTTP Header Contents\nDESCRIPTION: This Suricata rule demonstrates matching on raw (un-normalized) HTTP header contents.  It uses the `http.header.raw` keyword to detect multiple 'User-Agent' headers. The flow keyword defines the traffic direction and uses hexadecimal representations of special characters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_34\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Raw Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.header.raw; \\\n  content:\"User-Agent|3a 20|Mozilla/5.0|0d 0a|;\"; \\\n  content:\"User-Agent|3a 20|Chrome|0d 0a|;\";` classtype:bad-unknown; sid:73; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Example JSON Output with File Metadata\nDESCRIPTION: This JSON snippet demonstrates the expected output when file storage and MD5 hashing are enabled.  It includes fields for timestamp, IPs, ports, HTTP URI, filename, magic, state, MD5, stored flag, and size.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n  { \"id\": 1, \"timestamp\": \"05\\/01\\/2012-11:10:27.693583\", \"ipver\": 4, \"srcip\": \"2.23.144.170\", \"dstip\": \"192.168.1.91\", \"protocol\": 6, \"sp\": 80, \"dp\": 51598, \"http_uri\": \"\\/en\\/US\\/prod\\/collateral\\/routers\\/ps5855\\/prod_brochure0900aecd8019dc1f.pdf\", \"http_host\": \"www.cisco.com\", \"http_referer\": \"http:\\/\\/www.google.com\\/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CDAQFjAA&url=http%3A%2F%2Fwww.cisco.com%2Fen%2FUS%2Fprod%2Fcollateral%2Frouters%2Fps5855%2Fprod_brochure0900aecd8019dc1f.pdf&ei=OqyfT9eoJubi4QTyiamhAw&usg=AFQjCNGdjDBpBDfQv2r3VogSH41V6T5x9Q\", \"filename\": \"\\/en\\/US\\/prod\\/collateral\\/routers\\/ps5855\\/prod_brochure0900aecd8019dc1f.pdf\", \"magic\": \"PDF document, version 1.6\", \"state\": \"CLOSED\", \"md5\": \"59eba188e52467adc11bf2442ee5bf57\", \"stored\": true, \"size\": 9485123 }\n  { \"id\": 12, \"timestamp\": \"05\\/01\\/2012-11:12:57.421420\", \"ipver\": 4, \"srcip\": \"2.23.144.170\", \"dstip\": \"192.168.1.91\", \"protocol\": 6, \"sp\": 80, \"dp\": 51598, \"http_uri\": \"\\/en\\/US\\/prod\\/collateral\\/routers\\/ps5855\\/prod_brochure0900aecd8019dc1f.pdf\", \"http_host\": \"www.cisco.com\", \"http_referer\": \"http:\\/\\/www.google.com\\/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CDAQFjAA&url=http%3A%2F%2Fwww.cisco.com%2Fen%2FUS%2Fprod%2Fcollateral%2Frouters%2Fps5855%2Fprod_brochure0900aecd8019dc1f.pdf&ei=OqyfT9eoJubi4QTyiamhAw&usg=AFQjCNGdjDBpBDfQv2r3VogSH41V6T5x9Q\", \"filename\": \"\\/en\\/US\\/prod\\/collateral\\/routers\\/ps5855\\/prod_brochure0900aecd8019dc1f.pdf\", \"magic\": \"PDF document, version 1.6\", \"state\": \"CLOSED\", \"md5\": \"59eba188e52467adc11bf2442ee5bf57\", \"stored\": true, \"size\": 9485123 }\n```\n\n----------------------------------------\n\nTITLE: Registering a File Logger in Suricata (C)\nDESCRIPTION: This code snippet shows the function signature for registering a file logger within Suricata. File loggers are used to log information about files. The `SCOutputRegisterFileLogger` function allows registering a custom function to handle file logging, enabling extensions to file monitoring capabilities.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/output/index.rst#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n/** \\brief Register a file logger\n *\n *  This function registers a function that is responsible for logging\n *  file related output.\n *\n *  \\param logger The logger to register.\n *\n *  \\return void\n */\n```\n\nLANGUAGE: c\nCODE:\n```\nvoid SCOutputRegisterFileLogger(void (*logger)(SCLogRecord *lr, Flow *f, FileInfo *fi, void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                     , void *data\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                     , void (*deinit)(void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                     );\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Exchange Type - Suricata\nDESCRIPTION: This snippet demonstrates how to match the Exchange Type in an IKE packet using the `ike.exchtype` keyword. The keyword accepts a numeric argument and supports qualifiers such as greater than, less than, greater than or equal, less than or equal and ranges.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nike.exchtype:5;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nike.exchtype:>=2;\n```\n\n----------------------------------------\n\nTITLE: Suppress Examples - Different Tracking\nDESCRIPTION: Demonstrates different tracking options for suppressions. Includes tracking by source with various IP address formats like subnets, IP address ranges, and variables, as well as using 'by_either' to match either source or destination IP.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nsuppress gen_id 1, sig_id 2003614, track by_src, ip 217.110.97.128/25\nsuppress gen_id 1, sig_id 2003614, track by_src, ip [192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]\nsuppress gen_id 1, sig_id 2003614, track by_src, ip $HOME_NET\nsuppress gen_id 1, sig_id 2003614, track by_either, ip 217.110.97.128/25\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Payload with PCRE in Suricata\nDESCRIPTION: This example demonstrates how to use the `websocket.payload` keyword with a PCRE expression to match specific patterns in the unmasked WebSocket payload.  The `websocket.max-payload-size` configuration in `suricata.yaml` limits the maximum payload size that is inspected. This keyword can be used as `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.payload; pcre:\"/^123[0-9]*/\";\n```\n\n----------------------------------------\n\nTITLE: Reloading Suricata rules\nDESCRIPTION: This command reloads the Suricata rules without restarting the service, using systemctl. It requires sudo privileges to execute.  This allows for dynamic updates to the rule set.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl reload suricata\n```\n\n----------------------------------------\n\nTITLE: Installing libxdp and libbpf development files on Linux\nDESCRIPTION: This command installs the necessary libxdp and libbpf development files on a Linux system using the dnf package manager. These libraries are required to compile Suricata with AF_XDP support.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndnf -y install libxdp-devel libbpf-devel\n```\n\n----------------------------------------\n\nTITLE: Building and Installing Suricata (Bash)\nDESCRIPTION: This code snippet builds and installs Suricata after configuration. It cleans the build directory, compiles the source code, installs the binaries and configuration files, updates the shared library cache, and creates a directory for eBPF files.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n make clean && make\n sudo make install-full\n sudo ldconfig\n sudo mkdir /usr/libexec/suricata/ebpf/\n```\n\n----------------------------------------\n\nTITLE: Enabling Landlock in Suricata YAML Configuration\nDESCRIPTION: This YAML snippet shows how to enable Landlock in the Suricata configuration file. It sets the `enabled` option to `yes` and defines lists of directories for `write` and `read` access. The `directories` section specifies the paths where Suricata will read and write files, crucial for proper sandboxing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/landlock.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nlandlock:\n  enabled: yes\n  directories:\n    write:\n      - /var/log/suricata/\n      - /var/run/\n    read:\n      - /usr/\n      - /etc/\n      - /etc/suricata/\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Opcode using Integer Value in Suricata\nDESCRIPTION: This example demonstrates matching the WebSocket opcode using an 8-bit unsigned integer. `websocket.opcode` uses an unsigned 8-bits integer. Only 16 values are relevant.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.opcode:1;\n```\n\n----------------------------------------\n\nTITLE: SMB Dialect Negotiation Logging Example (JSON)\nDESCRIPTION: This example demonstrates the JSON format for logging SMB dialect negotiation, crucial for understanding protocol versions. It includes transaction ID, dialect, command, status, session ID, tree ID, client dialects, and server GUID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_32\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"id\": 1,\n    \"dialect\": \"2.??\",\n    \"command\": \"SMB1_COMMAND_NEGOTIATE_PROTOCOL\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 0,\n    \"tree_id\": 0,\n    \"client_dialects\": [\n      \"PC NETWORK PROGRAM 1.0\",\n      \"LANMAN1.0\",\n      \"Windows for Workgroups 3.1a\",\n      \"LM1.2X002\",\n      \"LANMAN2.1\",\n      \"NT LM 0.12\",\n      \"SMB 2.002\",\n      \"SMB 2.??\"\n    ],\n    \"server_guid\": \"aec6e793-2b11-4019-2d95-55453a0ad2f1\"\n  }\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"id\": 2,\n    \"dialect\": \"2.10\",\n    \"command\": \"SMB2_COMMAND_NEGOTIATE_PROTOCOL\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 0,\n    \"tree_id\": 0,\n    \"client_dialects\": [\n      \"2.02\",\n      \"2.10\"\n    ],\n    \"client_guid\": \"601985d2-aad9-11e7-8494-00088bb57f27\",\n    \"server_guid\": \"aec6e793-2b11-4019-2d95-55453a0ad2f1\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Matching Packet Count in Suricata Flows\nDESCRIPTION: Demonstrates how to use the `flow.pkts` keyword in Suricata rules to match flows based on the number of packets. The direction (toclient, toserver, or either) and the number of packets are specified. The number of packets can be matched exactly or compared using operators. Note that `flow.pkts_toclient` and `flow.pkts_toserver` are supported but not preferred.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_19\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.pkts:toclient,3\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.pkts:toserver,<3\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.pkts:either,>=2\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"Flow has 20 packets in toclient dir\"; flow.pkts:toclient,20; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Logging MD5s without Storing Files\nDESCRIPTION: This YAML snippet configures Suricata to log MD5 checksums without storing the actual files. It disables the `file-store` and enables JSON output with forced MD5 hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_7\n\nLANGUAGE: YAML\nCODE:\n```\n  - file-store:\n      version: 2\n      enabled: no       # set to yes to enable\n      log-dir: files    # directory to store the files\n      force-filestore: no\n      force-hash: [md5]  # force logging of md5 checksums\n```\n\n----------------------------------------\n\nTITLE: Calculating MD5 Hash of HTTP Request Line - Suricata Rule\nDESCRIPTION: This rule calculates the MD5 hash of the `http_request_line` using the `to_md5` transformation. It then checks if the resulting hash matches a specific MD5 hash value. Note that the content value is a raw byte representation of the MD5 hash.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http_request_line; to_md5; \\\n    content:\"|54 A9 7A 8A B0 9C 1B 81 37 25 22 14 51 D3 F9 97|\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Media Session Info Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.media.session_info` keyword to match the Session information subfield in an SDP request or response. The `content` keyword specifies the session information string to search for, which follows the SDP scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.media.session_info; content:\"Session Description Protocol\"\n```\n\n----------------------------------------\n\nTITLE: POP3 Logging Example\nDESCRIPTION: This JSON snippet shows an example of how POP3 requests and responses are logged. It includes the command and its arguments within the \"request\" object, and the success status, status code, header, and data within the \"response\" object.  The \"success\" field indicates whether the POP3 response was successful (e.g., +OK), and the \"status\" field provides a status code (e.g., \"OK\" or \"ERR\").\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_79\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"pop3\": {\n      \"request\": {\n          \"command\": \"USER\",\n          \"args\": [\"user@example.com\"]\n      },\n      \"response\": {\n          \"success\": true,\n          \"status\": \"OK\",\n          \"header\": \"+OK password required for \\\"user@example.com\\\"\",\n          \"data\": []\n      }\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: PGSQL Event Example: Cancel Request\nDESCRIPTION: This example shows a PGSQL CancelRequest message sent over a different port.  It demonstrates how to correlate the request with the originating flow using process_id and secret_key from the AuthenticationOk event.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_71\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"timestamp\": \"2023-12-07T15:46:56.971150+0000\",\n      \"flow_id\": 775771889500133,\n      \"event_type\": \"pgsql\",\n      \"src_ip\": \"100.88.2.140\",\n      \"src_port\": 39706,\n      \"dest_ip\": \"100.96.199.113\",\n      \"dest_port\": 5432,\n      \"proto\": \"TCP\",\n      \"pkt_src\": \"stream (flow timeout)\",\n      \"pgsql\": {\n        \"tx_id\": 1,\n        \"request\": {\n          \"message\": \"cancel_request\",\n          \"process_id\": 28954,\n          \"secret_key\": 889887985\n        }\n      }\n   }\n```\n\n----------------------------------------\n\nTITLE: Registering a Streaming Logger in Suricata (C)\nDESCRIPTION: This code snippet shows the function signature for registering a streaming logger within Suricata. Stream loggers are used to log streaming data, such as TCP reassembled data and HTTP body data. The `SCOutputRegisterStreamingLogger` function is used to register a function for logging streams, providing visibility into streamed content.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/output/index.rst#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/** \\brief Register a streaming logger\n *\n *  This function registers a function that is responsible for logging\n *  streaming data.\n *\n *  \\param logger The logger to register.\n *\n *  \\return void\n */\n```\n\nLANGUAGE: c\nCODE:\n```\nvoid SCOutputRegisterStreamingLogger(void (*logger)(SCLogRecord *lr, Flow *f, uint8_t *data, uint32_t len, void *cbdata, void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                              , void *cbdata\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                              , void *data\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                              , void (*deinit)(void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                              );\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Session Name Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.session_name` keyword to match the session name field in an SDP request or response. The `content` keyword specifies the session name string to search for, which follows the SDP Session name (s=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.session_name; content:\"SIP call\";\n```\n\n----------------------------------------\n\nTITLE: Retrieving JA3 Hash in Lua\nDESCRIPTION: This code retrieves the JA3 hash (MD5 of the JA3 string) using the `Ja3GetHash()` function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_29\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    hash = Ja3GetHash()\n    if hash == nil then\n        return\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Iptables: Verify Rules\nDESCRIPTION: This command displays the current iptables rules, allowing you to verify that the rules have been set up correctly. The `-vnL` flags provide verbose output with packet and byte counts.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -vnL\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with Netmap Interface\nDESCRIPTION: This command starts Suricata, instructing it to read packets from the specified network interface using Netmap. The `--netmap=<interface>` option tells Suricata to use Netmap for packet capture on the given interface. The number of capture threads created depends on the RSS queues available on the network interface card (NIC).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --netmap=<interface>\n```\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --netmap=igb0\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file name\nDESCRIPTION: This Suricata rule example demonstrates how to use the `file.name` keyword to match a specific filename. It alerts if a file with the name \"examplefilename\" is detected in the network traffic. The `file.name` keyword is a sticky buffer and can be used with various payload keywords like `nocase`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nfile.name; content:\"examplefilename\";\n```\n\n----------------------------------------\n\nTITLE: DHCP Rebinding Time Signature Example - Suricata\nDESCRIPTION: This signature example demonstrates how to create a Suricata rule that alerts on small DHCP rebinding times. It utilizes the `dhcp.rebinding_time` keyword with a less-than operator to check if the rebinding time is less than 3.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dhcp-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dhcp any any -> any any (msg:\"small DHCP rebinding time (<3)\"; dhcp.rebinding_time:<3; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching DNS Rcode Value in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match a specific rcode value in the DNS header using the `dns.rcode` keyword in a Suricata rule. The rcode is an unsigned 8-bit integer representing the response code. The supported range is [0-15].\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.rcode:4;\n```\n\n----------------------------------------\n\nTITLE: Modbus Logging Example\nDESCRIPTION: This JSON snippet demonstrates an example of Modbus logging data captured by Suricata. It showcases both request and response details, including transaction IDs, protocol IDs, unit IDs, function codes, access types, categories, and error flags. The snippet provides insights into the Modbus communication between a client and a server, allowing for analysis of the Modbus protocol activity.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_73\n\nLANGUAGE: JSON\nCODE:\n```\n  \"modbus\": {\n    \"id\": 1,\n    \"request\": {\n      \"transaction_id\": 0,\n      \"protocol_id\": 0,\n      \"unit_id\": 0,\n      \"function_raw\": 1,\n      \"function_code\": \"RdCoils\",\n      \"access_type\": \"READ | COILS\",\n      \"category\": \"PUBLIC_ASSIGNED\",\n      \"error_flags\": \"NONE\",\n    },\n    \"response\": {\n      \"transaction_id\": 0,\n      \"protocol_id\": 0,\n      \"unit_id\": 0,\n      \"function_raw\": 1,\n      \"function_code\": \"RdCoils\",\n      \"access_type\": \"READ | COILS\",\n      \"category\": \"PUBLIC_ASSIGNED\",\n      \"error_flags\": \"DATA_VALUE\",\n    },\n  }\n```\n\n----------------------------------------\n\nTITLE: Rate Filter Example\nDESCRIPTION: This demonstrates an example of rate filter configuration for limiting incoming SSH connections. It sets a rate filter that drops traffic after 10 connections from the same source IP within 60 seconds, with a timeout of 300 seconds.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nrate_filter gen_id 1, sig_id 1000, track by_rule, count 100, seconds 60, \\\n  new_action alert, timeout 30\n```\n\n----------------------------------------\n\nTITLE: Analyzing Kerberos Fields in JSON\nDESCRIPTION: This snippet illustrates the structure of Kerberos fields within a JSON object, often found within SMB traffic analysis.  It contains the 'realm' and 'snames' (service names) fields, providing details about Kerberos authentication.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_46\n\nLANGUAGE: json\nCODE:\n```\n  \"smb\": {\n    \"dialect\": \"2.10\",\n    \"command\": \"SMB2_COMMAND_SESSION_SETUP\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 35184439197745,\n    \"tree_id\": 0,\n    \"kerberos\": {\n      \"realm\": \"CONTOSO.LOCAL\",\n      \"snames\": [\n        \"cifs\",\n        \"DC1.contoso.local\"\n      ]\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Matching on the Entire TCP Header with tcp.hdr in Suricata\nDESCRIPTION: This example demonstrates how to use the `tcp.hdr` keyword in a Suricata rule to match on the entire TCP header. The rule looks for the MSS option (type 2, option length 4) and uses `byte_test` to determine if the MSS value is less than 536, beginning the search after the fixed portion of the header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_18\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (flags:S,12; :example-rule-emphasis:`tcp.hdr; content:\"|02 04|\"; offset:20; byte_test:2,<,536,0,big,relative;` sid:1234; rev:5;)\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Media Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.media.media` keyword to match the Media subfield in an SDP request or response. The `content` keyword specifies the media string to search for, which follows the SDP media (m=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.media.media; content:\"audio 30000 RTP/AVP 0 8 97 2 3\"\n```\n\n----------------------------------------\n\nTITLE: Analyzing SSH Event Data in JSON\nDESCRIPTION: This snippet demonstrates the JSON structure for SSH event data, including client and server information. It contains fields such as 'proto_version', 'software_version', and 'hassh' (containing 'hash' and 'string'). Hassh must be enabled in the Suricata configuration file to populate the hassh fields.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_47\n\nLANGUAGE: json\nCODE:\n```\n  \"ssh\": {\n    \"client\": {\n        \"proto_version\": \"2.0\",\n        \"software_version\": \"OpenSSH_6.7\",\n        \"hassh\": {\n            \"hash\": \"ec7378c1a92f5a8dde7e8b7a1ddf33d1\",\n            \"string\": \"curve25519-sha256,diffie-hellman-group14-sha256,diffie-hellman-group14-sha1,ext-info-c\",\n        }\n     },\n    \"server\": {\n        \"proto_version\": \"2.0\",\n        \"software_version\": \"OpenSSH_6.7\",\n        \"hassh\": {\n            \"hash\": \"ec7378c1a92f5a8dde7e8b7a1ddf33d1\",\n            \"string\": \"curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256\",\n        }\n     }\n  }\n```\n\n----------------------------------------\n\nTITLE: DHCP Renewal Time Matching Example - Suricata\nDESCRIPTION: This example demonstrates how to match DHCP renewal time in a Suricata rule. It uses the `dhcp.renewal_time` keyword to compare the renewal time against a numerical value using various operators.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dhcp-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\ndhcp.renewal_time:3    # exactly 3\ndhcp.renewal_time:<3   # smaller than 3\ndhcp.renewal_time:>=2  # greater or equal than 2\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Random Field in Suricata\nDESCRIPTION: This example demonstrates matching the 32-byte TLS random field from client or server hello records using the `tls.random` keyword.  It uses the content keyword with a hexadecimal representation of the bytes to match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"TLS random test\"; \\\n    tls.random; content:\"|9b ce 7a 5e 57 5d 77 02 07 c2 9d be 24 01 cc f0 5d cd e1 d2 a5 86 9c 4a 3e ee 38 db 55 1a d9 bc|\"; sid: 200074;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Counting Packets Without Alerts\nDESCRIPTION: This example increments the `cntpackets` counter for each packet in the flow without generating an alert. The `noalert` keyword prevents alerts from being generated by this rule.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"count the rest without generating alerts\"; \\\n        flowint:cntpackets,isset; flowint:cntpackets, +, 1; noalert;)\n```\n\n----------------------------------------\n\nTITLE: Retrieving TLS Server Name Indication (SNI) in Lua\nDESCRIPTION: This code shows how to retrieve the Server Name Indication (SNI) from a TLS connection using the `TlsGetSNI()` function. It checks if the SNI contains a specific string ('badguys') to perform some action.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_26\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    asked_domain = TlsGetSNI()\n    if string.find(asked_domain, \"badguys\") then\n        -- ok connection to bad guys let's do something\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Matching Byte Count in Suricata Flows\nDESCRIPTION: Demonstrates how to use the `flow.bytes` keyword in Suricata rules to match flows based on the number of bytes.  The direction (toclient, toserver, or either) and the number of bytes are specified. The number of bytes can be matched exactly or compared using operators. Note that `flow.bytes_toclient` and `flow.bytes_toserver` are supported but not preferred.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_20\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.bytes:toclient,3\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.bytes:toserver,<3\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nflow.bytes:either,>=2\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"Flow has less than 2000 bytes in toserver dir\"; flow.bytes:toserver,<2000; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata rule to store all files\nDESCRIPTION: This Suricata rule stores all files from HTTP traffic. It alerts on any HTTP traffic and uses the `filestore` keyword to extract and store the files.  No specific file type or characteristic is targeted; everything is extracted.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/file-extraction.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\n  alert http any any -> any any (msg:\"FILE store all\"; filestore; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Registering HTTP Request Frames in Suricata (C)\nDESCRIPTION: This code snippet demonstrates how HTTP request frames are registered using the Frame registration functions from Suricata's C API. The `0` indicates the flow direction (`toserver`).  The length is not known at registration time. The `AppLayerFrameRegister` function registers a new application layer frame type.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n    /* app-layer-frame-documentation tag start: frame registration http request\n     * app-layer-frame-type: http_request\n     *\n     * We register the HTTP request frames to the app layer frame engine. The HTTP\n     * parser uses the Frame registration functions from the C API\n     * (``app-layer-frames.c``) directly for registering request Frames.  Here we\n     * also don't know the length yet. The ``0`` indicates flow direction:\n     * ``toserver``, and ``1`` would be used for ``toclient``:\n     *\n     * Note: the frame id will be dynamic at runtime.\n     */\n    frame_http_request_id = AppLayerFrameRegister(\n        \"http_request\",\n        PROTO_HTTP,\n        0, /* toserver */\n        AppLayerHtpFrameFree);\n\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Nonce Payload Length - Suricata\nDESCRIPTION: This snippet demonstrates how to match the length of the nonce payload using the `ike.nonce_payload_length` keyword. This keyword takes a numeric argument after a colon and supports qualifiers such as greater than, less than, greater than or equal, less than or equal and ranges.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nike.nonce_payload_length:132\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nike.nonce_payload_length:>132\n```\n\n----------------------------------------\n\nTITLE: Configuring Drop Event Logging with EVE JSON\nDESCRIPTION: This snippet configures the logging of dropped packets with the EVE JSON output.  It allows the configuration of logging alerts which caused drops, logging all dropped packets, or just the start of the flow.  It also includes whether to log the final action taken on a packet by the engine.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_4\n\nLANGUAGE: Config\nCODE:\n```\n    - drop:\n        alerts: yes      # log alerts that caused drops\n        flows: all       # start or all: 'start' logs only a single drop\n                         # per flow direction. All logs each dropped pkt.\n        # Enable logging the final action taken on a packet by the engine\n        # (will show more information in case of a drop caused by 'reject')\n        verdict: yes\n```\n\n----------------------------------------\n\nTITLE: Configuring Single NIC with Netmap TAP Mode\nDESCRIPTION: This YAML configuration sets up Suricata to run in a special inline mode, allowing the interface to still be available to the OS. It uses `copy-mode: tap` to forward traffic to another interface. The caret symbol (`^`) is used to differentiate between the original and the copied interface, creating a loopback configuration. This setup is useful for mixing Netmap with firewall setups.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nnetmap:\n  - interface: igb0\n    copy-mode: tap\n    copy-iface: igb0^\n  - interface: igb0^\n    copy-mode: tap\n    copy-iface: igb0\n```\n\n----------------------------------------\n\nTITLE: Suricata Threading Configuration for DPDK IPS\nDESCRIPTION: This YAML snippet demonstrates the threading configuration for Suricata when using DPDK in IPS mode. It sets CPU affinity for management and worker threads to improve performance by pinning them to specific CPU cores.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n    threading:\n      set-cpu-affinity: yes\n      cpu-affinity:\n        - management-cpu-set:\n            cpu: [ 0 ]\n        - worker-cpu-set:\n            cpu: [ 2,4,6,8,10,12,14,16 ]\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Bandwidth Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.bandwidth` keyword to match the bandwidth field in an SDP request or response. The `content` keyword specifies the bandwidth string to search for, which follows the SDP bandwidth (b=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.bandwidth; content:\"AS:64\"\n```\n\n----------------------------------------\n\nTITLE: Example ethtool Output\nDESCRIPTION: This is an example of the output of `ethtool -S em2`. It includes statistics related to received and transmitted packets, bytes, errors, and other network interface metrics.  It's useful for diagnosing network performance issues and packet loss.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/statistics.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nNIC statistics:\n       rx_packets: 35430208463\n       tx_packets: 216072\n       rx_bytes: 32454370137414\n       tx_bytes: 53624450\n       rx_broadcast: 17424355\n       tx_broadcast: 133508\n       rx_multicast: 5332175\n       tx_multicast: 82564\n       rx_errors: 47\n       tx_errors: 0\n       tx_dropped: 0\n       multicast: 5332175\n       collisions: 0\n       rx_length_errors: 0\n       rx_over_errors: 0\n       rx_crc_errors: 51\n       rx_frame_errors: 0\n       rx_no_buffer_count: 0\n       rx_missed_errors: 0\n       tx_aborted_errors: 0\n       tx_carrier_errors: 0\n       tx_fifo_errors: 0\n       tx_heartbeat_errors: 0\n       tx_window_errors: 0\n       tx_abort_late_coll: 0\n       tx_deferred_ok: 0\n       tx_single_coll_ok: 0\n       tx_multi_coll_ok: 0\n       tx_timeout_count: 0\n       tx_restart_queue: 0\n       rx_long_length_errors: 0\n       rx_short_length_errors: 0\n       rx_align_errors: 0\n       tx_tcp_seg_good: 0\n       tx_tcp_seg_failed: 0\n       rx_flow_control_xon: 0\n       rx_flow_control_xoff: 0\n       tx_flow_control_xon: 0\n       tx_flow_control_xoff: 0\n       rx_long_byte_count: 32454370137414\n       rx_csum_offload_good: 35270755306\n       rx_csum_offload_errors: 65076\n       alloc_rx_buff_failed: 0\n       tx_smbus: 0\n       rx_smbus: 0\n       dropped_smbus: 0\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto-config without CPU Affinity in Suricata YAML\nDESCRIPTION: This YAML snippet configures Suricata to use Napatech without CPU affinity. It disables CPU affinity, enables Napatech auto-config, specifies streams, ports, and the hashmode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_4\n\nLANGUAGE: YAML\nCODE:\n```\nthreading:\n      set-cpu-affinity: no\n        .\n        .\n        .\n    napatech:\n        auto-config: yes\n        streams: [\"0-3\"]\n        ports: [all]\n        hashmode: hash5tuplesorted\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Incrementing Login Fail Counter\nDESCRIPTION: This example demonstrates how to increment a `flowint` counter (`loginfail`) for each subsequent login failure detected in a stream, assuming the counter has already been initialized.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Counting Logins\"; content:\"login failed\"; \\\n        flowint:loginfail, isset; flowint:loginfail, +, 1; noalert;)\n```\n\n----------------------------------------\n\nTITLE: Displaying CPU Information\nDESCRIPTION: Executes the `lscpu` command to display detailed CPU architecture and NUMA node information. It is crucial for determining the number of cores, sockets, and NUMA nodes to optimize Suricata's CPU affinity settings.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nlscpu\n```\n\n----------------------------------------\n\nTITLE: QUIC Logging Example with CYU, JA3, JA4\nDESCRIPTION: This JSON snippet shows an example of QUIC logging data generated by Suricata, including CYU (Client Yet Unknown), JA3, and JA4 fingerprints. It includes the QUIC version, CYU hash and string, JA3 hash and string, and JA4 fingerprint. This log entry provides information about the QUIC connection's characteristics, aiding in the identification of different QUIC clients and potential security threats.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_74\n\nLANGUAGE: JSON\nCODE:\n```\n  \"quic\": {\n    \"version\": 1362113590,\n    \"cyu\": [\n        {\n            \"hash\": \"7b3ceb1adc974ad360cfa634e8d0a730\",\n            \"string\": \"46,PAD-SNI-STK-SNO-VER-CCS-NONC-AEAD-UAID-SCID-TCID-PDMD-SMHL-ICSL-NONP-PUBS-MIDS-SCLS-KEXS-XLCT-CSCT-COPT-CCRT-IRTT-CFCW-SFCW\"\n        }\n    ],\n    \"ja3\": {\n        \"hash\": \"324f8c50e267adba4b5dd06c964faf67\",\n        \"string\": \"771,4865-4866-4867,51-43-13-27-17513-16-45-0-10-57,29-23-24,\"\n    },\n    \"ja4\": \"q13d0310h3_55b375c5d22e_cd85d2d88918\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Tailing the Suricata fast.log file\nDESCRIPTION: This command uses 'tail' to continuously display the content of the 'fast.log' file, which contains Suricata alerts.  The '-f' flag makes 'tail' follow the file, displaying new entries as they are written.  Requires 'tail' utility to be available and Suricata to be logging to the specified file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/adding-your-own-rules.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntail -f /var/log/suricata/fast.log\n```\n\n----------------------------------------\n\nTITLE: Configuring mem-unaligned in suricata.yaml\nDESCRIPTION: This snippet shows how to configure the mem-unaligned in the suricata.yaml configuration file. This enables or disables unaligned chunk mode for AF_XDP, using hugepages for the UMEM.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  mem-unaligned: <yes/no>\n  mem-unaligned: yes\n```\n\n----------------------------------------\n\nTITLE: LDAP Request Attribute Type Matching\nDESCRIPTION: This Suricata rule alerts if an LDAP packet has the attribute type \"objectClass\" in the request. The `ldap.request.attribute_type` is a sticky buffer and can be used as `fast_pattern`. Comparison is case-sensitive.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_18\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test attribute type\"; :example-rule-emphasis:`ldap.request.attribute_type; content:\"objectClass\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: LDAP Response Attribute Type and Operation Matching\nDESCRIPTION: This Suricata rule alerts if an LDAP packet has a `search_result_entry` operation at index 1 of the responses array and contains the attribute type \"dc\". This demonstrates the combined usage of `ldap.responses.operation` with an index and `ldap.responses.attribute_type` to pinpoint a specific response and attribute.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_21\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test attribute type and operation\"; :example-rule-emphasis:`ldap.responses.operation:search_result_entry,1; ldap.responses.attribute_type; content:\"dc\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Range Matching\nDESCRIPTION: This code snippet demonstrates how to match an integer value within a specified range in a Suricata rule. `bsize:19-22;` means the rule will match if the value of the `bsize` field is between 19 (exclusive) and 22 (exclusive). Thus, 20 and 21 will match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:19-22;\n```\n\n----------------------------------------\n\nTITLE: Example VLAN to Tenant Mapping (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to map VLAN IDs to tenant IDs in the suricata.yaml file. Suricata uses the outermost VLAN ID to match the correct tenant configuration. VLAN ID values must be between 1 and 4094.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nmappings:\n- vlan-id: 1000\n  tenant-id: 1\n- vlan-id: 2000\n  tenant-id: 2\n- vlan-id: 1112\n  tenant-id: 3\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP2 Window Update Value\nDESCRIPTION: This keyword is used to match the value of the HTTP2 value field in a WINDOWUPDATE frame. It uses an unsigned 32-bit integer and supports qualifiers such as greater than (>), less than (<), and range (x-y).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http2-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nhttp2.window:1;\nhttp2.window:<100000;\n```\n\n----------------------------------------\n\nTITLE: Matching RFB Desktop Name Using Content Keyword\nDESCRIPTION: This snippet demonstrates how to use the 'rfb.name' keyword with the 'content' modifier to match a specific desktop name in an RFB handshake.  The 'rfb.name' is a 'sticky buffer' and can be used as a 'fast_pattern'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rfb-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nrfb.name; content:\"Alice's desktop\";\n```\n\n----------------------------------------\n\nTITLE: Get Raw HTTP Request URI\nDESCRIPTION: Retrieves the raw HTTP request URI using the `request_uri_raw()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_10\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nhttp_request_uri_raw = tx:request_uri_raw()\nprint(http_request_uri_raw)\n```\n\n----------------------------------------\n\nTITLE: Initializing the flow object in Lua\nDESCRIPTION: This snippet shows how to initialize the flow object for use in the script. The `flow.get()` function retrieves the current flow being processed by the Suricata engine.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Phone Number Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.phone_number` keyword to match the phone number field in an SDP request or response. The `content` keyword specifies the phone number string to search for, which follows the SDP phone number (p=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.phone_number; content:\"+1 617 555-6011 (Jane Doe)\";\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Command Data Matching Rule\nDESCRIPTION: This rule matches specific command data from an FTP client request using the `ftp.command_data` keyword.  It is also a sticky buffer and can be used as a fast pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.command_data; content:\"anonymous\";` sid: 1;)\n```\n\n----------------------------------------\n\nTITLE: Default Log Level Configuration - YAML\nDESCRIPTION: This YAML snippet showcases how to set the default log level in Suricata's configuration file. The `default-log-level` option determines the verbosity of log messages.  This level applies to all logging outputs (console, file, syslog) unless overridden in the individual output configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_48\n\nLANGUAGE: yaml\nCODE:\n```\n  logging:\n    default-log-level: info\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Sticky Buffer HTTP Response Line Inspection\nDESCRIPTION: This Suricata rule inspects the HTTP response line for the pattern '403 Forbidden'. The 'http_response_line' keyword is a 'sticky buffer', ensuring the content check is performed against the HTTP response line.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http_response_line; content:\"403 Forbidden\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Checking Suricata Log\nDESCRIPTION: Checks the Suricata log file using `tail` to verify that Suricata is running without errors. The last line of the log should indicate that the engine has started.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nsudo tail /var/log/suricata/suricata.log\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP CIP Instance in Suricata Rules\nDESCRIPTION: The `enip.cip_instance` keyword is used to match on the CIP instance in CIP request path. It uses a 32-bit unsigned integer as its value. The CIP instance identifies a specific instance of a CIP object.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_instance:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_instance:>1;\n```\n\n----------------------------------------\n\nTITLE: Prepending a Dot Prefix to DNS Query - Suricata Rule\nDESCRIPTION: This example showcases the use of the `dotprefix` transformation.  It prepends a \".\" to the `dns.query` buffer. This is useful for concise domain matching. The rule will match on `windows.update.microsoft.com` because after `dotprefix`, the content becomes `.windows.update.microsoft.com` which contains `.microsoft.com`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns any any -> any any (dns.query; dotprefix; \\\n    content:\".microsoft.com\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Key Exchange Payload Length - Suricata\nDESCRIPTION: This snippet demonstrates how to match the length of the public key exchange payload using the `ike.key_exchange_payload_length` keyword. This keyword takes a numeric argument after a colon and supports qualifiers such as greater than, less than, greater than or equal, less than or equal and ranges.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nike.key_exchange_payload_length:>132\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Revision in Suricata Rules\nDESCRIPTION: The `enip.revision` keyword is used to match on the revision in the identity message. It uses a 16-bit unsigned integer as its value. This keyword can be used to identify the specific revision of a device.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.revision:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.revision:>1;\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Reply Matching Rule\nDESCRIPTION: This rule matches specific FTP reply strings using the `ftp.reply` keyword. It does not include the completion code in the content to match upon.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.reply; content:\"Please specify the password.\";` sid: 1;)\n```\n\n----------------------------------------\n\nTITLE: Converting HTTP URI to Lowercase - Suricata Rule\nDESCRIPTION: This Suricata rule converts the `http.uri` buffer to lowercase using the `to_lowercase` transformation. After the transformation, the rule checks if the buffer contains the lowercase string \"this text has been converted to lowercase\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http.uri; to_lowercase; \\\n    content:\"this text has been converted to lowercase\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Installing IPS Dependencies - Bash\nDESCRIPTION: This command installs dependencies required for running Suricata as an IPS (Intrusion Prevention System). It installs the `libnetfilter-queue-dev`, `libnetfilter-queue1`, `libnfnetlink-dev`, and `libnfnetlink0` packages using apt-get. These libraries are required for Suricata to interact with the Linux kernel's netfilter queueing mechanism, which is used for packet modification.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get -y install libnetfilter-queue-dev libnetfilter-queue1 \\\n  libnfnetlink-dev libnfnetlink0\n```\n\n----------------------------------------\n\nTITLE: Reloading All Tenants via Unix Socket\nDESCRIPTION: This command shows how to reload all tenants via the Suricata Unix socket. The `reload-tenants` command reloads the configuration for all active tenants.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\nreload-tenants\n```\n\n----------------------------------------\n\nTITLE: Matching Re-assembled DNP3 Application Buffer with dnp3_data\nDESCRIPTION: The `dnp3_data` keyword enables content matching on the re-assembled DNP3 application buffer. This buffer is a DNP3 fragment with CRCs removed, potentially reassembled from multiple link layer frames. Subsequent content options, like `content`, will then operate on this reassembled buffer to match specific byte sequences.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dnp3-keywords.rst#_snippet_3\n\nLANGUAGE: None\nCODE:\n```\ndnp3_data;\n```\n\nLANGUAGE: None\nCODE:\n```\ndnp3_data; content:\"|c3 06|\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule using ndpi-protocol and ndpi-risk\nDESCRIPTION: This Suricata rule example demonstrates the use of both the `ndpi-protocol` and `ndpi-risk` keywords.  It detects binary application transfers over HTTP.  It requires both `ndpi-protocol` and `ndpi-risk` keywords.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/plugins/ndpi.rst#_snippet_3\n\nLANGUAGE: suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Binary application transfer over HTTP\"; requires:keyword ndpi-protocol, keyword ndpi-risk; ndpi-protocol:HTTP; ndpi-risk:NDPI_BINARY_APPLICATION_TRANSFER; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Raw HTTP Request URI in Lua\nDESCRIPTION: This code demonstrates how to retrieve the raw, unnormalized HTTP request URI using the `HttpGetRequestUriRaw()` function.  It handles cases where the URI is not available and provides a default value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_14\n\nLANGUAGE: lua\nCODE:\n```\nhttp_uri = HttpGetRequestUriRaw()\nif http_uri == nil then\n    http_uri = \"<unknown>\"\nend\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Connection Data Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.connection_data` keyword to match the connection data field in an SDP request or response. The `content` keyword specifies the connection data string to search for, which follows the SDP connection (c=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.connection_data; content:\"IN IP4 192.168.1.2\"\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: SMBv2 Version Match\nDESCRIPTION: This Suricata rule triggers an alert when SMBv2 or SMBv3 traffic is observed. The 'smb.version' keyword is set to 2, which matches both SMBv2 and SMBv3 due to their shared version identifier in the SMB header. A message and a signature ID are included for clear identification.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smb-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smb $HOME_NET any -> any any (msg:\"SMBv2 version rule\"; :example-rule-options:`smb.version:2;` sid:2;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Inequality Matching (Decimal)\nDESCRIPTION: This code snippet shows how to match for integer inequality using decimal representation. `bsize:!=20;` means the rule will match if the value of the `bsize` field is not equal to 20.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:!=20;\n```\n\n----------------------------------------\n\nTITLE: Install Hyperscan Development Package (Fedora/CentOS)\nDESCRIPTION: This command installs the Hyperscan development package on Fedora 37+ or CentOS 8+ using the DNF package manager. This package provides the necessary headers and libraries for compiling Suricata with Hyperscan support.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/hyperscan.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf install hyperscan-devel\n```\n\n----------------------------------------\n\nTITLE: Host OS Policy Configuration\nDESCRIPTION: This YAML snippet shows how to configure host OS policies in Suricata.  It allows specifying the operating system for different IP address ranges, enabling Suricata to adjust its behavior for handling fragmented packets and streams based on the host's OS.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_65\n\nLANGUAGE: yaml\nCODE:\n```\nhost-os-policy:\n  windows: [0.0.0.0/0]\n  bsd: []\n  bsd-right: []\n  old-linux: []\n  linux: [10.0.0.0/8, 192.168.1.100, \"8762:2352:6241:7245:E000:0000:0000:0000\"]\n  old-solaris: []\n  solaris: [\"::1\"]\n  hpux10: []\n  hpux11: []\n  irix: []\n  macos: []\n  vista: []\n  windows2k3: []\n```\n\n----------------------------------------\n\nTITLE: Configuring custom detection profile group sizes\nDESCRIPTION: This code snippet shows how to configure custom group sizes for toclient and toserver traffic within the `custom-values` section under `detect.profile`. This allows fine-grained control over how signatures are grouped for inspection, potentially improving performance with minimal memory increase.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tuning-considerations.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ncustom-values:\n  toclient-groups: 100\n  toserver-groups: 100\n```\n\n----------------------------------------\n\nTITLE: Enabling Rule Profiling in Suricata Configuration\nDESCRIPTION: This snippet shows how to enable rule profiling in the Suricata configuration file. Rule profiling helps determine the performance impact of individual rules. It requires Suricata to be compiled with the `--enable-profiling` flag. Enabling rule profiling impacts performance, even when disabled in the configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_67\n\nLANGUAGE: yaml\nCODE:\n```\nprofiling:\n  rules:\n    enabled: yes\n```\n\n----------------------------------------\n\nTITLE: Get Normalized HTTP Request URI\nDESCRIPTION: Retrieves the normalized HTTP request URI using the `request_uri_normalized()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_11\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nhttp_request_uri_normalized = tx:request_uri_normalized()\nprint(http_request_uri_normalized)\n```\n\n----------------------------------------\n\nTITLE: Analyzing PCAP File with Suricata\nDESCRIPTION: This command instructs Suricata to analyze a PCAP (packet capture) file. The -r flag specifies the path to the PCAP file. Suricata processes the file and outputs logs to the current working directory (CWD). Requires suricata installation and a valid pcap file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/manpages/suricata.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -r /path/to/capture.pcap\n```\n\n----------------------------------------\n\nTITLE: Getting Packet Timestamp (ISO8601 String) in Lua\nDESCRIPTION: Retrieves the packet's timestamp as a string in ISO8601 format: `2015-10-06T15:16:43.137833+0000`. This format is used by the `eve` output.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_4\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\nprint p:timestring_iso8601()\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for JA3 Detection in Lua\nDESCRIPTION: This snippet demonstrates initializing 'needs' for JA3 based detection, specifying to retrieve TLS packets to conduct analysis on.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_28\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"tls\"] = tostring(true)\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Via Header in Suricata Rules\nDESCRIPTION: This snippet shows how to match the SIP Via header in a Suricata rule. The `sip.via` keyword is used to inspect the Via header field. The `content` option should contain the value of the Via header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.via; content:\"SIP/2.0/UDP\"\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email Date Field\nDESCRIPTION: This Suricata rule is designed to alert if the 'Date' field within an SMTP packet's MIME header matches the specified value. It utilizes the 'email.date' keyword to target the email's date field. The 'content' option contains the date string to match. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_4\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email date\"; email.date; content:\"Fri, 21 Apr 2023 05:10:36 +0000\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT PUBLISH (JSON)\nDESCRIPTION: This example shows the JSON structure for logging MQTT PUBLISH messages.  It contains fields such as qos, retain, dup, topic, message_id, message, and properties.  The properties field includes content_type, correlation_data, message_expiry_interval, payload_format_indicator, response_topic, topic_alias, and userprop.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_56\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"publish\": {\n    \"qos\": 1,\n    \"retain\": false,\n    \"dup\": false,\n    \"topic\": \"topic\",\n    \"message_id\": 1,\n    \"message\": \"baa baa sheep\",\n    \"properties\": {\n      \"content_type\": \"mytype\",\n      \"correlation_data\": \"3c32aa4313b3e\",\n      \"message_expiry_interval\": 77,\n      \"payload_format_indicator\": 88,\n      \"response_topic\": \"response_topic1\",\n      \"topic_alias\": 5,\n      \"userprop\": \"userval\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Out-of-Tree: make -f Makefile.example\nDESCRIPTION: This snippet shows how to build the standalone application against the installed Suricata library, using the provided Makefile.example. This command should be executed in the directory containing `Makefile.example`.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/simple/README.md#_snippet_2\n\nLANGUAGE: makefile\nCODE:\n```\nmake -f Makefile.example\n```\n\n----------------------------------------\n\nTITLE: Analyzing Bittorrent DHT Find Node Request/Response in JSON\nDESCRIPTION: This snippet shows the JSON structure for a Bittorrent DHT 'find_node' request and a corresponding response. It includes fields such as 'transaction_id', 'client_version', 'request_type', 'request' (with 'id' and 'target'), and 'response' (with 'id'). This event type is used to locate nodes in the DHT network.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_38\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"response\": {\n      \"id\": \"42aeb304a0845b3b9ee089327b48967b8e87b2e2\"\n    }\n  }\n\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"420f0000\",\n    \"client_version\": \"5554b50c\",\n    \"request_type\": \"find_node\",\n    \"request\": {\n      \"id\": \"37579bad1bad166af4329508096fae8c553c6cf4\",\n      \"target\": \"37579bad1bad166af4329508096fae8c553c6cf4\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Reloading a Single Tenant via Unix Socket\nDESCRIPTION: These commands show how to reload a single tenant via the Suricata Unix socket. The `reload-tenant` command takes the tenant ID and optionally the path to the tenant's YAML configuration file as arguments.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\nreload-tenant 1 tenant-1.yaml\nreload-tenant 5\n```\n\n----------------------------------------\n\nTITLE: Configuring RSS Hash Function\nDESCRIPTION: Sets the RSS hash function to Toeplitz on the network interface (eth1). This function is often used to evenly distribute network traffic across multiple queues.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n/usr/local/sbin/ethtool -X eth1 hfunc toeplitz\n```\n\n----------------------------------------\n\nTITLE: Activating Landlock at Boot (Debian)\nDESCRIPTION: This snippet shows how to enable Landlock during system boot on a Debian distribution. It involves editing the `/etc/default/grub` file to add `lsm=landlock` to the `GRUB_CMDLINE_LINUX_DEFAULT` option. Afterwards, `sudo update-grub` must be run and the system rebooted for the changes to take effect.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/landlock.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nGRUB_CMDLINE_LINUX_DEFAULT=\"quiet lsm=landlock\"\n```\n\n----------------------------------------\n\nTITLE: Installing ethtool on Linux\nDESCRIPTION: Downloads, extracts, configures, and installs the ethtool utility. This is crucial for configuring network interface cards for optimal performance with Suricata. Ethtool is used to adjust various NIC settings.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://mirrors.edge.kernel.org/pub/software/network/ethtool/ethtool-5.2.tar.xz\ntar -xf ethtool-5.2.tar.xz\ncd ethtool-5.2\n./configure && make clean && make && make install\n/usr/local/sbin/ethtool --version\n```\n\n----------------------------------------\n\nTITLE: Installing gperftools-libs on Fedora\nDESCRIPTION: This command installs the gperftools-libs package on Fedora using the yum package manager. This package includes the tcmalloc library, which can be used to optimize memory allocation in applications. It requires root privileges to install packages.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tcmalloc.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyum install gperftools-libs\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Attribute Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.attribute` keyword to match the attributes field in an SDP request or response. The `content` keyword specifies the attribute string to search for, which follows the SDP attribute (a=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.attribute; content:\"sendrecv\"\n```\n\n----------------------------------------\n\nTITLE: Cloning libbpf Repository (Bash)\nDESCRIPTION: This code snippet shows how to clone the `libbpf` repository from GitHub if the package is unavailable. This is an alternative to installing using `apt`. It ensures the availability of the library if package installation fails.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n git clone https://github.com/libbpf/libbpf.git\n```\n\n----------------------------------------\n\nTITLE: Run Suricata with Multiple Queues\nDESCRIPTION: This command shows how to start Suricata to listen on multiple queues.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -q 3 -q 4 -q 5\n```\n\n----------------------------------------\n\nTITLE: Analyzing Bittorrent DHT Get Peers Response with Nodes in JSON\nDESCRIPTION: This snippet demonstrates the JSON structure of a 'get_peers' request and response where the response includes a list of 'values' containing IP addresses and ports. The request includes 'transaction_id', 'client_version', 'request_type', 'request' containing the 'id' and 'info_hash'.  The response contains the responding node 'id', 'values', and 'token'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_40\n\nLANGUAGE: json\nCODE:\n```\n   \"bittorrent_dht\": {\n    \"transaction_id\": \"44e6\",\n    \"client_version\": \"4c540126\",\n    \"request_type\": \"get_peers\",\n    \"request\": {\n      \"id\": \"41aff1580119f074e2f537f231f12adf684f0d1f\",\n      \"info_hash\": \"19a6fcfcba6cc2c6d371eb754074d095adb5d291\"\n    }\n  }\n\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"44e6\",\n    \"response\": {\n      \"id\": \"19a7c8f4f6d14d9f87a67671720633e551f30cb7\",\n      \"values\": [\n        {\n          \"ip\": \"45.22.252.153\",\n          \"port\": 36798\n        },\n        {\n          \"ip\": \"94.41.206.37\",\n          \"port\": 30850\n        },\n        {\n          \"ip\": \"84.228.120.50\",\n          \"port\": 6881\n        },\n        {\n          \"ip\": \"178.81.206.84\",\n          \"port\": 12373\n        },\n        {\n          \"ip\": \"110.188.93.186\",\n          \"port\": 22223\n        }\n      ],\n      \"token\": \"c897ee539e02a54595b4d7cfb6319ad48e71b282\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Retrieving Normalized HTTP Request URI in Lua\nDESCRIPTION: This code retrieves the normalized HTTP request URI using the `HttpGetRequestUriNormalized()` function. If the URI is not found, it defaults to '<unknown>'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_15\n\nLANGUAGE: lua\nCODE:\n```\nhttp_uri = HttpGetRequestUriNormalized()\nif http_uri == nil then\n    http_uri = \"<unknown>\"\nend\n```\n\n----------------------------------------\n\nTITLE: SMB Tree Connect (Share Open) Logging Example (JSON)\nDESCRIPTION: This snippet illustrates the JSON format for an SMB tree connect event, representing a share open operation. Key details include the transaction ID, dialect, command, status, session ID, tree ID, share name, and share type.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_31\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"id\": 3,\n    \"dialect\": \"2.10\",\n    \"command\": \"SMB2_COMMAND_TREE_CONNECT\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 4398046511121,\n    \"tree_id\": 1,\n    \"share\": \"\\\\\\\\admin-pc\\\\c$\",\n    \"share_type\": \"FILE\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with Napatech Plugin\nDESCRIPTION: This command instructs Suricata to load and use the Napatech plugin for packet capture. It sets the plugin path and specifies 'napatech' as the capture plugin.\nSOURCE: https://github.com/oisf/suricata/blob/master/plugins/napatech/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n/usr/local/suricata/bin/suricata \\\n    --set plugins.0=/usr/local/lib/suricata/napatech.so \\\n    --capture-plugin=napatech\n```\n\n----------------------------------------\n\nTITLE: Retrieving Bypassed Statistics - JSON\nDESCRIPTION: This snippet shows the JSON output from the `suricatasc` command to retrieve bypassed flow statistics for an interface. It includes the number of successful and failed IPv4 and IPv6 bypasses, as well as the map counts. It's retrieved using `suricatasc` and then `iface-bypassed-stats`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_24\n\nLANGUAGE: JSON\nCODE:\n```\n {\n     \"enp94s0np0\": {\n        \"ipv4_fail\": 0,\n        \"ipv4_maps_count\": 2303,\n        \"ipv4_success\": 4232,\n        \"ipv6_fail\": 0,\n        \"ipv6_maps_count\": 13131,\n        \"ipv6_success\": 13500\n\n     }\n }\n```\n\n----------------------------------------\n\nTITLE: Non-Blocking Rule Reload via Unix Socket\nDESCRIPTION: This command uses the `suricatasc` tool to trigger a non-blocking rule reload. The `-c ruleset-reload-nonblocking` option signals Suricata to reload the ruleset in the background, allowing the `suricatasc` command to return immediately. Requires `suricatasc` to be installed and configured for the Suricata Unix socket.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/rule-reload.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsuricatasc -c ruleset-reload-nonblocking\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT DISCONNECT (JSON)\nDESCRIPTION: This example outlines the JSON logging format for MQTT DISCONNECT messages.  The log entry contains information such as qos, retain, dup, reason_code, and an optional properties object containing session expiry interval.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_63\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"disconnect\": {\n    \"qos\": 0,\n    \"retain\": false,\n    \"dup\": false,\n    \"reason_code\": 4,\n    \"properties\": {\n      \"session_expiry_interval\": 122,\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file size range\nDESCRIPTION: This Suricata rule demonstrates matching a file with a size within a specific range using the `filesize` keyword. It alerts if a file is greater than 100 bytes and smaller than 200 bytes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesize:100<>200;\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with eBPF Filter (Bash)\nDESCRIPTION: This command line runs Suricata with specified options, including the PID file, AF_PACKET interface, and verbosity level. It allows Suricata to utilize the configured eBPF filter.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n /usr/bin/suricata --pidfile /var/run/suricata.pid  --af-packet=eth3 -vvv \n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Example with fast_pattern\nDESCRIPTION: This code snippet demonstrates the use of the 'fast_pattern' keyword in a Suricata rule.  The 'fast_pattern' keyword forces Suricata to use the content 'Badness' for the MPM, even though the 'User-Agent' content is longer. This can improve performance if 'Badness' is a less common string. Dependencies: None.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/prefilter-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\ncontent:\"User-Agent|3A|\";\ncontent:\"Badness\"; distance:0; fast_pattern;\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for Output Scripts in Lua\nDESCRIPTION: This code snippet shows how to initialize the `needs` table for output logging in a Suricata Lua script.  It sets the 'protocol' key to 'http', indicating that the script requires HTTP protocol data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"protocol\"] = \"http\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Anomaly Event Example\nDESCRIPTION: This JSON exemplifies an `anomaly` event type, detailing network anomalies detected by Suricata.  The data includes the timestamp, flow ID, packet count, source and destination IPs/ports, protocol, Ethernet details, along with specific anomaly attributes such as the application protocol, type of anomaly, event description, and affected layer. This type of log is crucial for detecting unexpected behavior.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n      \"timestamp\": \"2023-09-18T06:13:58.882971+0000\",\n      \"flow_id\": 1676750115612680,\n      \"pcap_cnt\": 2878,\n      \"event_type\": \"anomaly\",\n      \"src_ip\": \"192.168.100.237\",\n      \"src_port\": 49175,\n      \"dest_ip\": \"142.11.240.191\",\n      \"dest_port\": 35361,\n      \"proto\": \"TCP\",\n      \"pkt_src\": \"wire/pcap\",\n      \"ether\": {\n        \"src_mac\": \"12:a9:86:6c:77:de\",\n        \"dest_mac\": \"52:54:00:36:3e:ff\"\n      },\n      \"tx_id\": 3,\n      \"anomaly\": {\n        \"app_proto\": \"http\",\n        \"type\": \"applayer\",\n        \"event\": \"UNABLE_TO_MATCH_RESPONSE_TO_REQUEST\",\n        \"layer\": \"proto_parser\"\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: DHCP Rebinding Time Matching Example - Suricata\nDESCRIPTION: This example demonstrates how to match DHCP rebinding time in a Suricata rule. It uses the `dhcp.rebinding_time` keyword to compare the rebinding time against a numerical value using various operators.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dhcp-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\ndhcp.rebinding_time:3    # exactly 3\ndhcp.rebinding_time:<3   # smaller than 3\ndhcp.rebinding_time:>=2  # greater or equal than 2\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Websocket Flags Bitmask Matching\nDESCRIPTION: This code snippet shows how to match websocket flags using a bitmask. `websocket.flags:&0xc0=0x80;` matches if the result of a bitwise AND between `websocket.flags` and `0xc0` is equal to `0x80`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\nwebsocket.flags:&0xc0=0x80;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Accept Example\nDESCRIPTION: This Suricata rule shows how to match the `Accept` header in an HTTP request.  It uses the `http.accept` keyword and checks for the value `*/*`.  The `bsize` option specifies the buffer size.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Accept Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.accept; \\\n  content:\"*/*\";` bsize:3; classtype:bad-unknown; sid:91; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Chaining transformations: compress_whitespace and to_sha256 - Suricata Rule\nDESCRIPTION: This rule demonstrates chaining of Suricata transformations. It first compresses whitespace in the `http_request_line` buffer, then calculates the SHA256 hash of the resulting string, and finally checks if the hash matches the provided value. This enables matching on transformed data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http_request_line; compress_whitespace; to_sha256; \\\n    content:\"|54A9 7A8A B09C 1B81 3725 2214 51D3 F997 F015 9DD7 049E E5AD CED3 945A FC79 7401|\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Initiator SPI with Content - Suricata\nDESCRIPTION: This snippet demonstrates how to match the Initiator Security Parameter Index (SPI) in an IKE packet using the `ike.init_spi` keyword and the `content` modifier in a Suricata rule. The `content` modifier specifies the exact SPI value to look for. `ike.init_spi` is a sticky buffer and can be used as a fast pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nike.init_spi; content:\"18fe9b731f9f8034\";\n```\n\n----------------------------------------\n\nTITLE: Retrieving TLS Certificate Not Before Timestamp in Lua\nDESCRIPTION: This code retrieves the 'not before' timestamp from a TLS certificate using the `TlsGetCertNotBefore()` function.  It then compares the timestamp to the current time to determine if the certificate is not yet valid.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_24\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    notbefore = TlsGetCertNotBefore()\n    if notbefore > os.time() then\n        -- not yet valid certificate\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: MD5 Hasher Usage in Lua\nDESCRIPTION: This code snippet demonstrates how to use the MD5 hasher in Lua. It initializes the hasher, updates it with multiple strings, and then finalizes the hash to get a hex string representation. This provides an example of incremental hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/hashlib.rst#_snippet_3\n\nLANGUAGE: Lua\nCODE:\n```\nlocal hashing = require(\"suricata.hashing\")\nhasher = hashing.md5()\nhasher.update(\"www.suricata\")\nhasher.update(\".io\")\nhash = hasher.finalize_to_hex()\n```\n\n----------------------------------------\n\nTITLE: Minimal dependencies for RPM-based distributions\nDESCRIPTION: This bash script installs the minimal dependencies required to build Suricata on RPM-based distributions like AlmaLinux and RockyLinux. It uses dnf to install essential packages such as gcc, make, libpcap-devel, libyaml-devel, and others.  Requires sudo.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n../../scripts/docs-almalinux9-minimal-build.sh\n```\n\n----------------------------------------\n\nTITLE: Enable DPDK Interrupt Mode\nDESCRIPTION: This YAML snippet demonstrates how to enable interrupt mode for a specific interface in the DPDK configuration of Suricata. This allows the interface to operate in interrupt mode instead of polling mode, which can improve power efficiency. Setting `interrupt-mode` to `true` enables the feature.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/dpdk.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ndpdk:\n      eal-params:\n        proc-type: primary\n\n      interfaces:\n        - interface: 0000:3b:00.0\n          interrupt-mode: true\n          threads: 4\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Protocol String\nDESCRIPTION: This example demonstrates matching the protocol string in the MQTT CONNECT message using the `mqtt.connect.protocol_string` keyword. It matches when the protocol string is \"MQTT\" or \"MQIsdp\". The protocol string is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.protocol_string; content:\"MQTT\";\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.protocol_string; content:\"MQIsdp\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file magic with nocase\nDESCRIPTION: This Suricata rule example demonstrates matching file magic using `file.magic` with the `nocase` option. This is equivalent to using the `filemagic` keyword. It alerts when a file is identified as \"executable for MS Windows\" (case-insensitive).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nfile.magic; content:\"executable for MS Windows\"; nocase;\n```\n\n----------------------------------------\n\nTITLE: Equivalent YAML Configuration for Suricata Address Groups\nDESCRIPTION: This code snippet shows the equivalent YAML configuration if the `address-groups.yaml` content were directly embedded instead of being included via the `include` directive. It illustrates the outcome of the inclusion process. Requires a basic understanding of YAML syntax.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/includes.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  address-groups:\n    HOME_NET: \"[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]\"\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Accept-Encoding Example\nDESCRIPTION: This Suricata rule demonstrates matching the `Accept-Encoding` header in an HTTP request. It checks for the value `gzip, deflate` using the `http.accept_enc` keyword. The `bsize` option defines the buffer size for matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Accept-Encoding Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.accept_enc; \\\n  content:\"gzip, deflate\";` bsize:13; classtype:bad-unknown; sid:92; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configure Suricata with libcap-ng\nDESCRIPTION: This snippet configures Suricata with the necessary libcap-ng libraries and includes directories.  The `--with-libcap_ng-libraries` option specifies the location of the libcap-ng library files, and the `--with-libcap_ng-includes` option specifies the location of the libcap-ng header files. These options ensure that Suricata can link against and use the libcap-ng library during the build process.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/dropping-privileges.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./configure --with-libcap_ng-libraries=/usr/local/lib \\\n  --with-libcap_ng-includes=/usr/local/include\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching DCERPC Stub Data\nDESCRIPTION: This example demonstrates how to match specific stub data within a DCERPC packet using Suricata. It utilizes the `dcerpc.stub_data` keyword in conjunction with the `content` keyword to search for the byte sequence \"123456\" within the stub data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dcerpc-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\ndcerpc.stub_data; content:\"123456\";\n```\n\n----------------------------------------\n\nTITLE: Example Device to Tenant Mapping (YAML)\nDESCRIPTION: This YAML snippet demonstrates how to map network devices to tenant IDs. A single tenant can be assigned to a device. Multiple devices can have the same tenant id.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\nmappings:\n- device: ens5f0\n  tenant-id: 1\n- device: ens5f1\n  tenant-id: 3\n```\n\n----------------------------------------\n\nTITLE: LDAP Request Attribute Type and Operation Matching\nDESCRIPTION: This Suricata rule alerts if an LDAP packet has an `add_request` operation and contains the attribute type \"objectClass\". It combines `ldap.request.operation` and `ldap.request.attribute_type` to target specific LDAP add requests with a certain attribute type.  Comparison is case-sensitive.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_19\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test attribute type and operation\"; :example-rule-emphasis:`ldap.request.operation:add_request; ldap.request.attribute_type; content:\"objectClass\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Emergency Recovery Percentage in Suricata\nDESCRIPTION: This snippet configures the emergency recovery percentage for the flow engine. It specifies the percentage of preallocated flows that need to be pruned before the engine exits emergency mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_30\n\nLANGUAGE: yaml\nCODE:\n```\nemergency-recovery: 30                  #Percentage of 10000 prealloc'd flows.\n```\n\n----------------------------------------\n\nTITLE: Rust Parser Struct Declaration - Rust\nDESCRIPTION: This Rust code snippet shows the declaration of the `RustParser` struct, which contains fields for tracking the transaction completion state in both the to-server (`tx_comp_st_ts`) and to-client (`tx_comp_st_tc`) directions. These fields are of type `c_int`, representing C integers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n/// Rust parser declaration\npub struct RustParser {\n        .\n        .\n        .\n    /// Progress values at which the tx is considered complete in a direction\n    pub tx_comp_st_ts:      c_int,\n    pub tx_comp_st_tc:      c_int,\n    .\n    .\n    .\n}\n```\n\n----------------------------------------\n\nTITLE: Setting BPF filter in Suricata.yaml\nDESCRIPTION: This example configures BPF filters for packet capture within Suricata, specifically targeting traffic based on TCP protocol and port 25. The 'bpf-filter' option within the pcap configuration allows specifying a Berkeley Packet Filter (BPF) expression to filter the traffic captured by Suricata. This helps reduce the amount of data processed, improving performance by focusing only on the relevant network traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\npcap:\n  - interface: eth0\n    #buffer-size: 16777216\n    #bpf-filter: \"tcp and port 25\"\n    #checksum-checks: auto\n    #threads: 16\n    #promisc: no\n    #snaplen: 1518\n```\n\n----------------------------------------\n\nTITLE: Suricata Negated Content Match Example\nDESCRIPTION: This rule snippet demonstrates a negated content match that will return true in Suricata but not in Snort if the offset is beyond the end of the inspection buffer. The rule looks for the string 'snort' starting at offset 10 in the HTTP client body.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\ncontent:!\"snort\"; offset:10; http_client_body;\n```\n\n----------------------------------------\n\nTITLE: Matching Kerberos Server Name in Suricata\nDESCRIPTION: This example demonstrates how to match the Kerberos server name using the `krb5_sname` keyword in Suricata rules. The content option specifies the server name to search for within the Kerberos message. The comparison is case-sensitive, and the rule will match if any part of the server name matches the provided content.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/kerberos-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert krb5 any any -> any any (msg:\"Kerberos 5 krbtgt server name\"; krb5_sname; content:\"krbtgt\"; sid:5; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching Raw HTTP URI in Suricata\nDESCRIPTION: This Suricata rule matches on the raw HTTP URI without any normalization. It uses the `http.uri.raw` keyword along with the `content` keyword to search for a specific URI. The rule includes options like `flow`, `bsize`, `classtype`, `sid`, and `rev` for defining the flow direction, buffer size, classification, rule ID, and revision number, respectively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP URI Raw Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.uri.raw; \\\n  content:\"//index.html\";` bsize:12; classtype:bad-unknown; sid:4; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata Plugin in YAML\nDESCRIPTION: This YAML snippet illustrates how to configure Suricata to use a custom plugin. It involves adding the plugin's path to the `plugins` section of the `suricata.yaml` file. Subsequently, it configures an `eve-log` output, specifying the custom plugin as the `filetype` and defining which event types should be sent to the plugin.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/plugins/c-json-filetype/README.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nplugins:\n  - /usr/lib/suricata/plugins/json-filetype.so\n```\n\nLANGUAGE: YAML\nCODE:\n```\noutputs:\n  - eve-log:\n      enabled: yes\n      filetype: json-filetype-plugin\n      threaded: true\n      types:\n        - dns\n        - tls\n        - http\n```\n\n----------------------------------------\n\nTITLE: Initializing Flow String Variable\nDESCRIPTION: This Lua code initializes a Flow string variable named \"cnt\" for use in Suricata.  `needs[\"flowvar\"] = {\"cnt\"}` declares the `cnt` variable, and `needs[\"http.request_headers\"] = tostring(true)` configures the script to observe HTTP request headers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_50\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"http.request_headers\"] = tostring(true)\n    needs[\"flowvar\"] = {\"cnt\"}\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Bundling Suricata-update - Bash\nDESCRIPTION: This script bundles suricata-update.  This likely packages all the dependencies so suricata-update can be used without needing to install them manually.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/bundle.sh\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Certificate Serial Number in Suricata\nDESCRIPTION: This example demonstrates matching a specific serial number within a TLS certificate using the `tls.cert_serial` keyword in a Suricata rule. It checks for an exact match of the provided hexadecimal serial number.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"match cert serial\"; \\\n    tls.cert_serial; content:\"5C:19:B7:B1:32:3B:1C:A1\"; sid:200012;)\n```\n\n----------------------------------------\n\nTITLE: Cherry-Picking Commits with Git\nDESCRIPTION: This snippet shows how to use `git cherry-pick` to apply commits from the master branch to a backport branch. The `-x` option is used to maintain the linkage with the cherry-picked commit. This is used in the backporting process to bring commits into the new branch one at a time, starting with the oldest commit. After cherry-picking, conflicts may need to be resolved.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/backports-guide.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit cherry-pick -x commit-hash\n```\n\n----------------------------------------\n\nTITLE: Logging to a File\nDESCRIPTION: This Lua code demonstrates how to log messages to a file using `SCLogPath()`. It constructs the full file path by concatenating the log path with a filename and opens the file in append mode for writing log messages.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_52\n\nLANGUAGE: Lua\nCODE:\n```\nname = \"fast_lua.log\"\nfunction setup (args)\n    filename = SCLogPath() .. \"/\" .. name\n    file = assert(io.open(filename, \"a\"))\nend\n```\n\n----------------------------------------\n\nTITLE: Getting Raw Packet Data in Lua\nDESCRIPTION: Retrieves the entire raw packet data, including all headers (e.g., TCP, Ethernet, VLAN).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_9\n\nLANGUAGE: Lua\nCODE:\n```\nraw_packet = p:packet()\n```\n\n----------------------------------------\n\nTITLE: NFtables: Add IPS Chain\nDESCRIPTION: This nftables command adds a new chain named 'IPS' to the 'filter' table.  This chain is configured for filtering traffic on the forward hook with a priority of 10.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnft> add chain filter IPS { type filter hook forward priority 10;}\n```\n\n----------------------------------------\n\nTITLE: Example logging function using flow details in Lua\nDESCRIPTION: This snippet defines a `log` function that retrieves various flow details (timestamp, alerts, tuple, application layer protocol, timestamps, and ID) and logs specific information if the flow has triggered an alert. It writes the flow details to a file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_10\n\nLANGUAGE: lua\nCODE:\n```\nfunction log(args)\n    local f = flow.get()\n    ts = f:timestring_iso8601()\n    has_alerts = f:has_alerts()\n    ipver, srcip, dstip, proto, sp, dp = f:tuple()\n    alproto, alproto_ts, alproto_tc, alproto_orig, alproto_expect = f:app_layer_proto()\n    start_sec, start_usec, last_sec, last_usec = f:timestamps()\n    id = f:id()\n\n    if has_alerts then\n        file:write (\"[**] Start time \" .. ts .. \" [**] -> alproto \" .. alproto .. \" [**] \" .. proto .. \" [**] alerted: true\\n[**] First packet: \" .. start_sec ..\" [**] Last packet: \" .. last_sec .. \" [**] Flow id: \" .. id .. \"\\n\")\n        file:flush()\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Case Formatting Example\nDESCRIPTION: Example demonstrating proper formatting for switch statement cases. Opening brace is on the same line as the case statement.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nswitch (a) {\n    case 13: {\n        int a = bla();\n        break;\n    }\n    case 15:\n        blu();\n        break;\n    default:\n        gugus();\n}\n```\n\n----------------------------------------\n\nTITLE: Iptables Rules: Host Protection\nDESCRIPTION: These iptables rules insert rules in the INPUT and OUTPUT chains to send all incoming and outgoing traffic to the NFQUEUE. This is used when Suricata protects the host it is running on.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I INPUT -j NFQUEUE\nsudo iptables -I OUTPUT -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Matching ICMP Type Greater Than 10 using itype in Suricata\nDESCRIPTION: This example demonstrates how to use the `itype` keyword in a Suricata rule to match on ICMP types greater than 10. This allows for broader matching based on a range of ICMP types.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_21\n\nLANGUAGE: Suricata\nCODE:\n```\nitype:>10;\n```\n\n----------------------------------------\n\nTITLE: Configuring File Store (File Extraction) in Suricata (YAML)\nDESCRIPTION: This snippet shows the configuration options for the file-store output in Suricata, version 2. It enables storing extracted files to disk, sets the directory for storage, configures writing fileinfo records, forces storing of all files, overrides the global stream depth, defines the maximum number of open files for file store, and forces logging of checksums.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\n  - file-store:\n      # This configures version 2 of the file-store.\n      version: 2\n\n      enabled: no\n\n      # Set the directory for the filestore. If the path is not\n      # absolute will be be relative to the default-log-dir.\n      #dir: filestore\n\n      # Write out a fileinfo record for each occurrence of a\n      # file. Disabled by default as each occurrence is already logged\n      # as a fileinfo record to the main eve-log.\n      #write-fileinfo: yes\n\n      # Force storing of all files. Default: no.\n      #force-filestore: yes\n\n      # Override the global stream-depth for sessions in which we want\n      # to perform file extraction. Set to 0 for unlimited; otherwise,\n      # must be greater than the global stream-depth value to be used.\n      #stream-depth: 0\n\n      # Uncomment the following variable to define how many files can\n      # remain open for filestore by Suricata. Default value is 0 which\n      # means files get closed after each write\n      #max-open-files: 1000\n\n      # Force logging of checksums, available hash functions are md5,\n      # sha1 and sha256. Note that SHA256 is automatically forced by\n      # the use of this output module as it uses the SHA256 as the\n      # file naming scheme.\n      #force-hash: [sha1, md5]\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata with Napatech\nDESCRIPTION: These shell commands configure, compile, and install Suricata with Napatech support. It specifies the include and library paths for Napatech.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n\t$ ./configure --enable-napatech --with-napatech-includes=/opt/napatech3/include --with-napatech-libraries=/opt/napatech3/lib\n\t$ make\n\t$ make install-full\n```\n\n----------------------------------------\n\nTITLE: LDAP DN Match Alert Rule\nDESCRIPTION: This Suricata rule alerts if a packet has the LDAP distinguished name `uid=jdoe,ou=People,dc=example,dc=com`. It uses the `ldap.request.dn` keyword along with the `content` keyword to match the distinguished name. The `msg` option provides a descriptive message for the alert. This rule shows matching a distinguished name in a request.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAPDN\"; :example-rule-emphasis:`ldap.request.dn; content:\"uid=jdoe,ou=People,dc=example,dc=com\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching Quic CYU String in Suricata\nDESCRIPTION: This Suricata rule matches on the CYU string in Quic traffic. The `quic.cyu.string` keyword is used in conjunction with the `content` keyword.  This rule creates an alert with SID 2 if the specified string is found in the Quic CYU string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/quic-keywords.rst#_snippet_1\n\nLANGUAGE: suricata\nCODE:\n```\nalert quic any any -> any any (msg:\"QUIC CYU STRING\"; \\\n    quic.cyu.string; content:\"46,PAD-SNI-VER-CCS-UAID-TCID-PDMD-SMHL-ICSL-NONP-MIDS-SCLS-CSCT-COPT-IRTT-CFCW-SFCW\"; \\\n    sid:2;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Greater Than Matching\nDESCRIPTION: This code snippet demonstrates how to match an integer value that is greater than a specified value in a Suricata rule. `bsize:>21;` means the rule will match if the value of the `bsize` field is greater than 21.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:>21;\n```\n\n----------------------------------------\n\nTITLE: SMTP mail_from keyword example\nDESCRIPTION: This example demonstrates the usage of the `smtp.mail_from` keyword to match the parameter passed to the MAIL FROM command. The rule triggers if the MAIL FROM command contains \"spam\". `smtp.mail_from` is a sticky buffer and can be used as `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"SMTP mail from spam\"; smtp.mail_from; content:\"spam\"; sid:2; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: SMTP command_line frame example\nDESCRIPTION: This example demonstrates how to use the `smtp.command_line` frame to inspect individual lines from the client to the server.  The rule checks if the command line starts with \"MAIL FROM:\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any ( \\\n  :example-rule-options:`frame:smtp.command_line; content:\"MAIL|20|FROM:\"; startswith;` \\\n  sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Dump Ruleset Profiling Data from Suricata\nDESCRIPTION: This command dumps the ruleset profiling data from Suricata.  Profiling must be enabled at compile time using the `--enable-profiling-rules` flag. This command is sent via the Suricata unix socket.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/rule-profiling.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nsuricatasc -c ruleset-profile\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Serial in Suricata Rules\nDESCRIPTION: The `enip.serial` keyword is used to match the serial number in the identity message, using a 32-bit unsigned integer as its value. This can be used to identify specific devices.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.serial:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.serial:>1;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Definition\nDESCRIPTION: This snippet defines a Suricata rule to detect HTTP GET requests containing the word \"rule\" in the URI. It includes rule options such as message, flow, HTTP method and URI content matching, fast pattern, classification, SID, and revision.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/contribution-process.rst#_snippet_1\n\nLANGUAGE: suricata\nCODE:\n```\nalert http $HOME_NET any ->\n    $EXTERNAL_NET any (msg:\"HTTP GET Request Containing\n    Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri;\n    content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Certificate Subject with Suricata\nDESCRIPTION: This example demonstrates how to match the Subject field of a TLS/SSL certificate using the `tls.cert_subject` keyword in Suricata. It showcases the use of `content` to search for specific strings within the subject and utilizes `isdataat` and `relative` modifiers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.cert_subject; content:\"CN=*.googleusercontent.com\"; isdataat:!1,relative;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.cert_subject; content:\"google.com\"; nocase; pcre:\"/google\\.com$/\";\n```\n\n----------------------------------------\n\nTITLE: Stripping Whitespace from File Data - Suricata Rule\nDESCRIPTION: This rule demonstrates removing whitespace from the `file_data` buffer using the `strip_whitespace` transformation. It ensures that any whitespace within the buffer is removed before content matching is performed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (file_data; strip_whitespace; \\\n    content:\"window.navigate(\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configure Hyperscan MPM and SPM Algorithms (command-line)\nDESCRIPTION: This command line option sets the multi-pattern matching (mpm-algo) and single-pattern matching (spm-algo) algorithms to 'hs' (Hyperscan). This forces Suricata to use Hyperscan for pattern matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/hyperscan.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n--set mpm-algo=hs --set spm-algo=hs\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Command Data Matching Rule - anonymous\nDESCRIPTION: This rule uses `ftp.command_data` to match \"anonymous\" as command data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.command_data; content:\"anonymous\";` sid: 1;)\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Mask using Integer Value in Suricata\nDESCRIPTION: This example demonstrates matching the WebSocket mask using a 32-bit unsigned integer.  `websocket.mask` uses an unsigned 32-bits integer. The value is interpreted as big-endian.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.mask:123456;\n```\n\n----------------------------------------\n\nTITLE: Detecting Valid TLS Certificates in Suricata\nDESCRIPTION: This example demonstrates the use of the `tls_cert_valid` keyword in Suricata to check if a TLS certificate is currently valid (not expired). It only evaluates the validity date and does not perform full certificate chain validation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls_cert_valid;\n```\n\n----------------------------------------\n\nTITLE: Adding Cargo Bin to Path - Bash\nDESCRIPTION: This command adds the `${HOME}/.cargo/bin` directory to the PATH environment variable. This is needed because `cargo install` places executables there and needs to be in the path to be accessible. The second command installs the `cbindgen` crate, which is used to generate C header files from Rust code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport PATH=$PATH:${HOME}/.cargo/bin\n```\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --force cbindgen\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with VALE Interface\nDESCRIPTION: This command starts Suricata, instructing it to listen on a specified port of a VALE virtual switch using Netmap. The `--netmap=vale0:vi1` option tells Suricata to use Netmap for packet capture and to listen on port `vi1` of the `vale0` virtual switch.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --netmap=vale0:vi1\n```\n\n----------------------------------------\n\nTITLE: Getting DNS resource record name in Lua\nDESCRIPTION: This snippet shows how to retrieve the resource record name (rrname) from the first query object using the `rrname()` method on the transaction object.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_10\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nlocal rrname = tx:rrname()\nprint(rrname)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: DNS Query Sticky Buffer Classic Example\nDESCRIPTION: This Suricata rule demonstrates the traditional sticky buffer behavior.  It looks for \"example\" and \".net\" within the same `dns.query` buffer. The rule alerts if both content matches are found within the same DNS query.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/multi-buffer-matching.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns $HOME_NET any -> $EXTERNAL_NET any (msg:\"DNS Query Sticky Buffer Classic Example Rule\"; dns.query; content:\"example\"; content:\".net\"; classtype:misc-activity; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP CIP Attribute in Suricata Rules\nDESCRIPTION: The `enip.cip_attribute` keyword is used to match on the CIP attribute in different messages. It uses a 32-bit unsigned integer as its value. This allows matching without needing to match on cip.service.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_attribute:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_attribute:>1;\n```\n\n----------------------------------------\n\nTITLE: Checking PCAP File Processing Status\nDESCRIPTION: These examples show how to use `suricatasc` to check the status of PCAP file processing. `pcap-file-number` shows the number of files waiting to be processed. `pcap-file-list` displays the list of queued files. `pcap-current` shows the currently processed file. `pcap-last-processed` shows the last processed time.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/unix-socket.rst#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n>>> pcap-file-number\nSuccess: 3\n```\n\nLANGUAGE: Shell\nCODE:\n```\n>>> pcap-file-list\nSuccess: {'count': 2, 'files': ['/home/benches/file1.pcap', '/home/benches/file2.pcap']}\n```\n\nLANGUAGE: Shell\nCODE:\n```\n>>> pcap-current\nSuccess:\n\"/tmp/test.pcap\"\n```\n\nLANGUAGE: Shell\nCODE:\n```\n>>> pcap-last-processed\nSuccess:\n1509138964000\n```\n\nLANGUAGE: Shell\nCODE:\n```\n>>> pcap-interrupt\nSuccess:\n\"Interrupted\"\n```\n\n----------------------------------------\n\nTITLE: Require hashing library\nDESCRIPTION: This code snippet imports the `suricata.hashing` library in Lua, making the hashing functions available for use. This is the first step to use any hashing functions exposed by suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/hashlib.rst#_snippet_0\n\nLANGUAGE: Lua\nCODE:\n```\nlocal hashing = require(\"suricata.hashing\")\n```\n\n----------------------------------------\n\nTITLE: Installing clang-format on ubuntu\nDESCRIPTION: This bash command installs clang-format on ubuntu.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get install clang-format-9\n```\n\n----------------------------------------\n\nTITLE: Setting Stack Size for Suricata Threads\nDESCRIPTION: This snippet configures the stack size for individual threads in Suricata. It is recommended to increase the stack size to 8MB if the default value provided by the build system is insufficient.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_26\n\nLANGUAGE: yaml\nCODE:\n```\nstack-size: 8MB\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Will Message with Content\nDESCRIPTION: This example demonstrates matching the will message in the MQTT CONNECT message using the `mqtt.connect.willmessage` keyword combined with a content match. It matches when the will message is \"hunter2\". The will message is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.willmessage; content:\"hunter2\";\n```\n\n----------------------------------------\n\nTITLE: Matching SSH Server HASSH String\nDESCRIPTION: This rule matches SSH connections based on the server's HASSH string (list of SSH algorithms). The `ssh.hassh.server.string` keyword specifies that the content matching will occur on the server HASSH string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ssh-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ssh any any -> any any (msg:\"match SSH hash-server-string\"; \\\n      ssh.hassh.server.string; content:\"umac-64-etm@openssh.com,umac-128-etm@openssh.com\"; \\\n      sid:1000040;)\n```\n\n----------------------------------------\n\nTITLE: Testing Ethernet Frame Decoding in C\nDESCRIPTION: This C code snippet shows a unit test for the ``DecodeEthernet`` function in Suricata. It defines a raw Ethernet frame that is intentionally too small and checks that the decoder correctly identifies this condition by setting the ``DCE_PKT_TOO_SMALL`` event flag on the packet. It uses a packet allocation and freeing mechanism specific to Suricata's internal structures.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/testing.rst#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n    /**\n     * Test a DCE ethernet frame that is too small.\n     */\n    static int DecodeEthernetTestDceTooSmall(void)\n    {\n        uint8_t raw_eth[] = {\n            0x00, 0x10, 0x94, 0x55, 0x00, 0x01, 0x00, 0x10,\n            0x94, 0x56, 0x00, 0x01, 0x89, 0x03,\n        };\n\n        Packet *p = PacketGetFromAlloc();\n        FAIL_IF_NULL(p);\n        ThreadVars tv;\n        DecodeThreadVars dtv;\n\n        memset(&dtv, 0, sizeof(DecodeThreadVars));\n        memset(&tv,  0, sizeof(ThreadVars));\n\n        DecodeEthernet(&tv, &dtv, p, raw_eth, sizeof(raw_eth));\n\n        FAIL_IF_NOT(ENGINE_ISSET_EVENT(p, DCE_PKT_TOO_SMALL));\n\n        PacketFree(p);\n        PASS;\n    }\n```\n\n----------------------------------------\n\nTITLE: Sending USR2 Signal to Suricata\nDESCRIPTION: This command sends the USR2 signal to the Suricata process, triggering a rule reload. It uses `pidof` to determine the process ID of Suricata and then sends the signal using the `kill` command. Requires shell access and knowledge of Suricata's process ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/rule-reload.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkill -USR2 $(pidof suricata)\n```\n\n----------------------------------------\n\nTITLE: Installing Kernel Development Tools on Debian\nDESCRIPTION: This shell command installs the kernel headers, GCC, and make on a Debian based distribution. These are prerequisites for compiling and installing the Napatech kernel module.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ apt-get install linux-headers-$(uname .r) gcc make\n\t$ ./package_install_3gd.sh\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Opcode using String Representation in Suricata\nDESCRIPTION: This example demonstrates matching the WebSocket opcode using a string representation (e.g., `ping`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.opcode:ping;\n```\n\n----------------------------------------\n\nTITLE: Register State Progress Completion Status - C\nDESCRIPTION: This C code shows the function signature for `AppLayerParserRegisterStateProgressCompletionStatus`, which is used to register the state progress completion status for a given application layer protocol. The function takes the protocol, to-server (ts) completion state, and to-client (tc) completion state as arguments.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nvoid AppLayerParserRegisterStateProgressCompletionStatus(\n    AppProto alproto, const int ts, const int tc)\n```\n\n----------------------------------------\n\nTITLE: HTTP custom header logging example (Suricata 7.0)\nDESCRIPTION: This snippet shows how the same HTTP custom header configuration from above is logged in Suricata 7.0. Instead of merging, the custom headers are now logged in the `request_headers` or `response_headers` arrays within the `http` object.  This avoids potential conflicts and enables logging of multiple occurrences of the same header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade.rst#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"http\": {\n  \"hostname\": \"suricata.io\",\n  \"http_method\": \"GET\",\n  \"protocol\": \"HTTP/1/1\",\n  \"response_headers\": [\n    { \"name\": \"Server\", \"value\": \"nginx\" }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Logging RFB with VNC authentication\nDESCRIPTION: This example shows the structure of RFB (Remote Frame Buffer) event logging, which uses VNC authentication. The log includes server and client protocol versions, security type, VNC challenge and response, security result, screen sharing status, and framebuffer metadata. The 'framebuffer' object details screen properties like width, height, name, and pixel format, including bits per pixel, color depth, and endianness.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_51\n\nLANGUAGE: json\nCODE:\n```\n  \"rfb\": {\n    \"server_protocol_version\": {\n      \"major\": \"003\",\n      \"minor\": \"007\"\n    },\n    \"client_protocol_version\": {\n      \"major\": \"003\",\n      \"minor\": \"007\"\n    },\n    \"authentication\": {\n      \"security_type\": 2,\n      \"vnc\": {\n        \"challenge\": \"0805b790b58e967f2b350a0c99de3881\",\n        \"response\": \"aecb26faeaaa62179636a5934bac1078\"\n      },\n      \"security_result\": \"OK\"\n    },\n    \"screen_shared\": false,\n    \"framebuffer\": {\n      \"width\": 1280,\n      \"height\": 800,\n      \"name\": \"foobar@localhost.localdomain\",\n      \"pixel_format\": {\n        \"bits_per_pixel\": 32,\n        \"depth\": 24,\n        \"big_endian\": false,\n        \"true_color\": true,\n        \"red_max\": 255,\n        \"green_max\": 255,\n        \"blue_max\": 255,\n        \"red_shift\": 16,\n        \"green_shift\": 8,\n        \"blue_shift\": 0\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Including a YAML File Inside a Mapping in Suricata\nDESCRIPTION: This snippet shows how to include a YAML file within a mapping (dictionary) in a Suricata configuration. In this case, `address-groups.yaml`'s contents are included under the `address-groups` key. Requires valid YAML files and the `vars` section already defined in the main configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/includes.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  address-groups:\n    include: address-groups.yaml\n```\n\n----------------------------------------\n\nTITLE: Retrieving TLS Certificate Serial Number in Lua\nDESCRIPTION: This code demonstrates how to retrieve the serial number from a TLS certificate using the `TlsGetCertSerial()` function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_25\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    serial = TlsGetCertSerial()\n    if serial then\n        -- do something\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Check Hugepage Memory Information\nDESCRIPTION: These commands are used to check the total and free hugepages on the system. The first command checks globally, while the second checks per NUMA node.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/dpdk.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncat /proc/meminfo\n\n  HugePages_Total:    1024\n  HugePages_Free:     1024\n\n  # per-numa check depends on NUMA node ID, hugepage size, \n  # and nr_hugepages/free_hugepages - e.g.:\n  cat /sys/devices/system/node/node0/hugepages/hugepages-2048kB/free_hugepages\n```\n\n----------------------------------------\n\nTITLE: Command Line Interaction with suricatasc\nDESCRIPTION: These examples demonstrate how to interact with Suricata using the `suricatasc` command-line tool.  The `-c` option is used to specify the command to execute. When the command takes arguments, the entire command needs to be quoted. It shows how to get the version, uptime, and interface statistics.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/unix-socket.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nroot@debian64:~# suricatasc -c version\n{'message': '5.0.3 RELEASE', 'return': 'OK'}\nroot@debian64:~# \nroot@debian64:~# suricatasc -c uptime\n{'message': 35264, 'return': 'OK'}\nroot@debian64:~#\n```\n\nLANGUAGE: Shell\nCODE:\n```\nroot@debian64:~# suricatasc -c \"iface-stat eth0\"\n{'message': {'pkts': 5110429, 'drop': 0, 'invalid-checksums': 0}, 'return': 'OK'}\nroot@debian64:~#\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Triggering an Alert When Counters Match\nDESCRIPTION: This example generates an alert when the `cntpackets` counter reaches the value of the `maxvar` counter. Both counters must be set for the rule to match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"fire this when it reach 6\";                \\\n        flowint: cntpackets, isset;                                             \\\n        flowint: maxvar,isset; flowint: cntpackets, ==, maxvar;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with noalert Keyword\nDESCRIPTION: This rule demonstrates the use of the `noalert` keyword in a Suricata rule. When the rule matches an HTTP request with a specific user agent, it sets the `mozilla-ua` flowbit but does not generate an alert. This is useful for identifying patterns without immediately raising an alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/noalert.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http.user_agent; content:\"Mozilla/5.0\"; startwith; endswith; \\\n   flowbits:set,mozilla-ua; :example-rule-options:`noalert;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching Destination IP Address with Dataset\nDESCRIPTION: This Suricata rule utilizes the `ip.dst` keyword to match the destination IP address against a dataset named `badips`. The rule triggers if the destination IP is found within the `badips` dataset, which is of type `ip` and loaded from the `badips.list` file. This demonstrates how to check if an outbound traffic destination IP is on a bad list.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ipaddr.rst#_snippet_1\n\nLANGUAGE: suricata\nCODE:\n```\nalert tcp $HOME_NET any -> any any (msg:\"Outbound bad list\"; flow:to_server; ip.dst; dataset:isset,badips,type ip,load badips.list; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: List Hostbit via Unix Socket\nDESCRIPTION: Shows how to list hostbits associated with an IP address using the Suricata Unix socket. The command `list-hostbit` requires an IP address. The output is a JSON object containing the count and details (expire time, name) of each hostbit.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/xbits.rst#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nsuricatasc -c \"list-hostbit <ip>\"\nsuricatasc -c \"list-hostbit 1.2.3.4\"\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Certificate Fingerprint in Suricata\nDESCRIPTION: This snippet shows how to match the SHA-1 fingerprint of a TLS certificate using the `tls.cert_fingerprint` keyword in Suricata. It requires an exact, case-sensitive match of the lowercase hexadecimal fingerprint.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"match cert fingerprint\"; \\\n    tls.cert_fingerprint; \\\n    content:\"4a:a3:66:76:82:cb:6b:23:bb:c3:58:47:23:a4:63:a7:78:a4:a1:18\"; \\\n    sid:200023;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with ipv4.hdr Keyword\nDESCRIPTION: This rule uses the `ipv4.hdr` keyword to inspect the IPv4 header for a specific byte value. In this case it searches for byte 10 of the IPv4 header having value 0x06, indicating TCP protocol.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"IPv4 header keyword example\"; ipv4.hdr; content:\"|06|\"; offset:9; depth:1; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Displaying Kernel Packets Statistic in EVE JSON Format\nDESCRIPTION: Displays the number of packets captured by the kernel from the `eve.json` file using `tail -f` and `jq` to filter events by `event_type==\"stats\"` and extract the value from `.stats.capture.kernel_packets`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_11\n\nLANGUAGE: Shell\nCODE:\n```\nsudo tail -f /var/log/suricata/eve.json | jq 'select(.event_type==\"stats\")|.stats.capture.kernel_packets'\n```\n\n----------------------------------------\n\nTITLE: Configuring NIC with combined queue on low-end systems\nDESCRIPTION: Configures the number of combined channels on a lower end network interface (eth1) to 1 using ethtool. Then configures af-packet in suricata.yaml with default settings. This configuration is intended for systems where the NIC does not support symmetric hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n/usr/local/sbin/ethtool -L eth1 combined 1\n```\n\n----------------------------------------\n\nTITLE: Matching SSH Client HASSH MD5\nDESCRIPTION: This rule matches SSH connections based on the client's HASSH (hash of SSH algorithms) MD5 hash. The `ssh.hassh` keyword specifies that the content matching will occur on the HASSH value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ssh-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ssh any any -> any any (msg:\"match hassh\"; \\\n      ssh.hassh; content:\"ec7378c1a92f5a8dde7e8b7a1ddf33d1\";\\\n      sid:1000010;)\n```\n\n----------------------------------------\n\nTITLE: Example Host OS Policy Configuration\nDESCRIPTION: This YAML snippet shows an example configuration for host operating system policies. It defines different operating systems and associates them with IP addresses or network ranges. This configuration helps Suricata identify the operating systems of hosts on the network. Note the escaping of special characters is not reflected here as it's part of the yaml string value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nwindows:[]\nbsd: []\nbsd-right: []\nold-linux: []\nlinux: [10.0.0.0/8, 192.168.1.100, \"8762:2352:6241:7245:E000:0000:0000:\n  0000\"]\nold-solaris: []\nsolaris: [\"::1\"]\nhpux10: []\nhpux11: []\nirix: []\nmacos: []\nvista: []\nwindows2k3: []\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP Accept-Language Example\nDESCRIPTION: This Suricata rule demonstrates matching the `Accept-Language` header in an HTTP request. It checks for the value `en-US` using the `http.accept_lang` keyword. The `bsize` option is used to set the buffer size.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Accept-Encoding Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.accept_lang; \\\n  content:\"en-US\";` bsize:5; classtype:bad-unknown; sid:93; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Request Body\nDESCRIPTION: Retrieves the HTTP request body using the `request_body()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_14\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nhttp_request_body = tx:request_body()\nprint(http_request_body)\n```\n\n----------------------------------------\n\nTITLE: SPAN Port Configuration\nDESCRIPTION: This YAML snippet configures hardware bypass with SPAN port pairings, where each port is paired with itself.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_13\n\nLANGUAGE: YAML\nCODE:\n```\nports[0-0,1-1,2-2,3-3]\n```\n\n----------------------------------------\n\nTITLE: Displaying Network Interface Channel Parameters\nDESCRIPTION: This command uses the `ethtool` utility to display the channel parameters for a specified network interface (e.g., ens2f1). It shows the pre-set maximums and current hardware settings for RX, TX, Other, and Combined channels, providing insights into the interface's queue configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-capture.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nethtool -l ens2f1\n```\n\n----------------------------------------\n\nTITLE: Matching RFB Security Result (Not equal to 0)\nDESCRIPTION: This snippet demonstrates how to use the 'rfb.secresult' keyword to match the RFB security result. 'rfb.secresult' uses an unsigned 32-bit integer. This specific example uses negation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rfb-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nrfb.secresult: !0;\n```\n\n----------------------------------------\n\nTITLE: DHCP Lease Time Signature Example - Suricata\nDESCRIPTION: This signature example demonstrates how to create a Suricata rule that alerts on small DHCP lease times. It utilizes the `dhcp.leasetime` keyword with a less-than operator to check if the lease time is less than 3.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dhcp-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dhcp any any -> any any (msg:\"small DHCP lease time (<3)\"; dhcp.leasetime:<3; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Check Template Transaction Progress in Rust\nDESCRIPTION: This Rust function, `rs_template_tx_get_alstate_progress`, checks if a Template Protocol transaction is considered complete based on the presence of a response. It takes a raw void pointer to the transaction object and a direction flag (unused). It casts the void pointer to a `TemplateTransaction` struct. Returns 1 if the transaction has a response, 0 otherwise.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\npub extern \"C\" fn rs_template_tx_get_alstate_progress(\n    tx: *mut std::os::raw::c_void,\n    _direction: u8,\n) -> std::os::raw::c_int {\n    let tx = cast_pointer!(tx, TemplateTransaction);\n\n    // Transaction is done if we have a response.\n    if tx.response.is_some() {\n        return 1;\n    }\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Equality Matching\nDESCRIPTION: This code snippet demonstrates how to match an integer value for equality in a Suricata rule. The `bsize` keyword is used to specify the integer field to match, and the value `19` is used to specify the exact value to match. This rule will trigger only if the `bsize` field contains the value `19`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:19;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Websocket Opcode Equality (Integer)\nDESCRIPTION: This code snippet demonstrates how to match a websocket opcode using its integer value. `websocket.opcode:1;` functions the same as matching the text representation associated with that value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nwebsocket.opcode:1;\n```\n\n----------------------------------------\n\nTITLE: Preloading tcmalloc on Ubuntu to Run Suricata\nDESCRIPTION: This command runs Suricata with tcmalloc preloaded using the LD_PRELOAD environment variable. This instructs the dynamic linker to load libtcmalloc_minimal.so.4 before any other libraries, effectively replacing the default memory allocator with tcmalloc's. It requires the correct path to the tcmalloc library and the Suricata configuration file (suricata.yaml) and interface (eth0).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tcmalloc.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nLD_PRELOAD=\"/usr/lib/x86_64-linux-gnu/libtcmalloc_minimal.so.4\" suricata -c suricata.yaml -i eth0\n```\n\n----------------------------------------\n\nTITLE: DNS Query Log Example\nDESCRIPTION: This JSON snippet demonstrates the structure of a DNS query log entry in Suricata. It shows the 'type' as 'request', the DNS 'id', and an array of 'queries' containing the 'rrname' (resource record name) and 'rrtype' (resource record type).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n  \"dns\": {\n      \"version\": 3,\n      \"type\": \"request\",\n      \"id\": 16000,\n      \"queries\": [\n        {\n          \"rrname\": \"twitter.com\",\n          \"rrtype\": \"A\"\n        }\n      ]\n  }\n```\n\n----------------------------------------\n\nTITLE: Matching Quic CYU Hash in Suricata\nDESCRIPTION: This Suricata rule matches on the CYU hash within Quic traffic.  The `quic.cyu.hash` keyword is used with a content modifier to specify the hash value to look for.  The rule generates an alert with SID 1 when the specified hash is found.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/quic-keywords.rst#_snippet_0\n\nLANGUAGE: suricata\nCODE:\n```\nalert quic any any -> any any (msg:\"QUIC CYU HASH\"; \\\n    quic.cyu.hash; content:\"7b3ceb1adc974ad360cfa634e8d0a730\"; \\\n    sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Defining a Suricata Pass Rule for Inline Operation with Bypass\nDESCRIPTION: This snippet illustrates a Suricata rule with the `pass` action and `bypass` keyword in inline operation. When triggered, it instructs Napatech hardware to shunt subsequent packets of the flow from one port to its peer port, bypassing further Suricata analysis.  This requires inline operation to be configured within Suricata's Napatech configuration section.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_17\n\nLANGUAGE: suricata\nCODE:\n```\npass tcp any 443 <> any any (msg: \"SURICATA Test rule\";  bypass; sid:1000001; rev:2;)\n```\n\n----------------------------------------\n\nTITLE: Get Raw HTTP Response Headers\nDESCRIPTION: Retrieves the raw HTTP response headers as a string using the `response_headers_raw()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_9\n\nLANGUAGE: Lua\nCODE:\n```\nhttp_response_headers_raw = tx:response_headers_raw()\n\nif #http_response_headers_raw > 0 then\n      print(http_response_headers_raw)\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with ipv6.hdr Keyword\nDESCRIPTION: This rule uses the `ipv6.hdr` keyword to inspect the IPv6 header for a specific byte value. In this case, it checks if byte 7 of IPv6 header has a value of 0x06, which indicates TCP protocol.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"IPv6 header keyword example\"; ipv6.hdr; content:\"|06|\"; offset:6; depth:1; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Combined Suppress Example\nDESCRIPTION: Illustrates how suppressions can be combined with rules that already have thresholds/detection_filters configured. It presents multiple suppress rules that prevent signature 2002087 from alerting when emails originate from source IP 209.132.180.67.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nsuppress gen_id 1, sig_id 2002087, track by_src, ip 209.132.180.67\nsuppress gen_id 0, sig_id 0, track by_src, ip 209.132.180.67\nsuppress gen_id 1, sig_id 0, track by_src, ip 209.132.180.67\n```\n\n----------------------------------------\n\nTITLE: Configuring Netmap with lb on FreeBSD 11\nDESCRIPTION: This YAML configuration shows how to configure Suricata to read from a Netmap pipe when using `lb` on FreeBSD 11, where named pipes are not available. The `interface` is set to `netmap:eth0`, indicating Suricata should read from the Netmap pipe associated with interface `eth0`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nnetmap:\n  - interface: netmap:eth0\n    threads: 6\n```\n\n----------------------------------------\n\nTITLE: Configuring FTP Parser\nDESCRIPTION: This snippet showcases the YAML configuration for the FTP application layer parser in Suricata. It allows enabling/disabling the parser and setting the maximum line length for control messages. Truncated commands/replies are logged.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_36\n\nLANGUAGE: yaml\nCODE:\n```\nftp:\n  enabled: yes\n  #memcap: 64mb\n\n  # Maximum line length for control messages before they will be truncated.\n  #max-line-length: 4kb\n```\n\n----------------------------------------\n\nTITLE: Build and Install Hyperscan from Source\nDESCRIPTION: This set of commands clones the Hyperscan repository, configures the build using CMake, builds the library, and installs it to the system. This allows for a custom installation of Hyperscan from the source code. Building from source requires dependencies like boost, cmake, libpcap, pcre2, python3, ragel, and sqlite.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/hyperscan.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/intel/hyperscan\ncd hyperscan\ncmake -DBUILD_STATIC_AND_SHARED=1\ncmake --build ./\nsudo cmake --install ./\n```\n\n----------------------------------------\n\nTITLE: Matching RFB Security Type\nDESCRIPTION: This snippet demonstrates how to use the 'rfb.sectype' keyword to match a specific security type.  The 'rfb.sectype' keyword uses an unsigned 32-bit integer. This example directly matches security type '2'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rfb-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nrfb.sectype:2;\n```\n\n----------------------------------------\n\nTITLE: Updating Frame Length in Suricata (C)\nDESCRIPTION: This snippet showcases how the length of a registered frame is updated within Suricata.  The `frame->len` field is updated to reflect the actual length of the HTTP request. This is crucial for accurate parsing and analysis of the HTTP stream.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n    /* app-layer-frame-documentation tag start: updating frame->len\n     * app-layer-frame-type: http_request\n     *\n     * Later, during parsing, the frame length will be known and the ``frame->len``\n     * is updated.\n     */\n    frame->len = input_len;\n\n```\n\n----------------------------------------\n\nTITLE: Example Reference to a URL\nDESCRIPTION: This snippet demonstrates a 'reference' keyword pointing to a URL. This helps analysts investigate why a signature matched. The reference keyword can appear multiple times in a signature.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nreference:url,www.info.com\n```\n\n----------------------------------------\n\nTITLE: Forwarding Logs with Syslog Template (rsyslog)\nDESCRIPTION: This code snippet demonstrates how to configure rsyslog to forward syslog messages to a remote syslog server (10.8.75.24:514) using the previously defined 'sysklogd' template. This directs alert messages to the specified server, formatted according to the sysklogd template for compatibility.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/syslog-alerting-comp.rst#_snippet_3\n\nLANGUAGE: rsyslog\nCODE:\n```\nuser.alert @10.8.75.24:514;sysklogd\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata with Netmap Includes\nDESCRIPTION: This command configures Suricata with Netmap support, specifying the location of the Netmap include files. This is required when the Netmap includes are not in a standard location. The `--enable-netmap` flag enables Netmap support, and `--with-netmap-includes` specifies the directory containing the Netmap header files.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --enable-netmap --with-netmap-includes=/usr/local/include/netmap/\n```\n\n----------------------------------------\n\nTITLE: Analyzing Flow Event Data in JSON\nDESCRIPTION: This snippet illustrates the JSON structure for flow event data, providing network flow statistics and metadata. It contains fields like 'pkts_toserver', 'pkts_toclient', 'bytes_toserver', 'bytes_toclient', 'start', 'end', 'age', 'bypass', 'state', 'reason', 'alerted', 'action', 'tx_cnt', and 'exception_policy'. These fields provide information about the flow's direction, size, duration, state, and associated alerts or exceptions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_48\n\nLANGUAGE: json\nCODE:\n```\n  \"flow\": {\n    \"pkts_toserver\": 23,\n    \"pkts_toclient\": 21,\n    \"bytes_toserver\": 4884,\n    \"bytes_toclient\": 7392,\n    \"bypassed\": {\n      \"pkts_toserver\": 10,\n      \"pkts_toclient\": 8,\n      \"bytes_toserver\": 1305,\n      \"bytes_toclient\": 984\n    },\n    \"start\": \"2019-05-28T23:32:29.025256+0200\",\n    \"end\": \"2019-05-28T23:35:28.071281+0200\",\n    \"age\": 179,\n    \"bypass\": \"capture\",\n    \"state\": \"bypassed\",\n    \"reason\": \"timeout\",\n    \"alerted\": false,\n    \"action\": \"pass\",\n    \"exception_policy\": [\n      {\n        \"target\": \"stream_midstream\",\n        \"policy\": \"pass_flow\"\n      }\n    ]\n  }\n```\n\n----------------------------------------\n\nTITLE: IPREP isnotset Rule Example\nDESCRIPTION: This Suricata rule shows how to use the 'iprep' keyword with the 'isnotset' operator. It blocks traffic from hosts without a trust score (not part of the 'trusted-hosts' set).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ip-reputation-rules.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\ndrop ip $HOME_NET any -> any any (:example-rule-options:`iprep:src,trusted-hosts,isnotset;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Defining a Target Keyword\nDESCRIPTION: This code shows the format for defining a 'target' keyword. It specifies whether the source or destination IP is the target of the attack. If specified, the alert event is enhanced to contain information about source and target.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\ntarget:[src_ip|dest_ip]\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Origin Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.origin` keyword to match the originator field in an SDP request or response. The `content` keyword specifies the originator string to search for, which follows the SDP Origin (o=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.origin; content:\"SIPPS 105015165 105015162 IN IP4 192.168.1.2\";\n```\n\n----------------------------------------\n\nTITLE: Matching DNP3 Internal Indicator Flags with dnp3_ind\nDESCRIPTION: The `dnp3_ind` keyword matches on DNP3 internal indicator flags found in the response application header.  It takes a comma-separated list of flag names (e.g., all_stations, class_1_events) and matches if any of the listed flags are set. Multiple `dnp3_ind` keywords can be used for an AND-type match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dnp3-keywords.rst#_snippet_1\n\nLANGUAGE: None\nCODE:\n```\ndnp3_ind:<flag>{,<flag>...}\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Websocket Opcode Inequality (Text)\nDESCRIPTION: This code snippet demonstrates how to match a websocket opcode for inequality using the text representation.  `websocket.opcode:!ping;` will match if the websocket opcode is not equal to `ping`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nwebsocket.opcode:!ping;\n```\n\n----------------------------------------\n\nTITLE: Detailed DNS Answer Log Example\nDESCRIPTION: This JSON snippet shows a detailed DNS answer log entry. It includes fields like 'version', 'type', 'id', 'flags', 'qr', 'rd', 'ra', 'rcode', 'queries', and 'answers'. The 'answers' array contains detailed information about each DNS record, including 'rrname', 'rrtype', 'ttl', and 'rdata'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n  \"dns\": {\n      \"version\": 3,\n      \"type\": \"answer\",\n      \"id\": 45444,\n      \"flags\": \"8180\",\n      \"qr\": true,\n      \"rd\": true,\n      \"ra\": true,\n      \"rcode\": \"NOERROR\",\n      \"queries\": [\n        {\n          \"rrname\": \"www.suricata.io\",\n          \"rrtype\": \"A\"\n        }\n      ],\n      \"answers\": [\n        {\n          \"rrname\": \"www.suricata.io\",\n          \"rrtype\": \"CNAME\",\n          \"ttl\": 3324,\n          \"rdata\": \"suricata.io\"\n        },\n        {\n          \"rrname\": \"suricata.io\",\n          \"rrtype\": \"A\",\n          \"ttl\": 10,\n          \"rdata\": \"192.0.78.24\"\n        },\n        {\n          \"rrname\": \"suricata.io\",\n          \"rrtype\": \"A\",\n          \"ttl\": 10,\n          \"rdata\": \"192.0.78.25\"\n        }\n      ]\n  }\n```\n\n----------------------------------------\n\nTITLE: DHCP Logging Example (Extended)\nDESCRIPTION: This JSON snippet showcases a DHCP log entry captured by Suricata when extended logging is enabled. It includes detailed information such as the message type, transaction ID, client MAC address, assigned IP address, client IP address, relay IP address, next server IP address, DHCP message type, subnet mask, routers, hostname, lease time, renewal time, rebinding time, client ID, and DNS servers. This extended logging provides a complete picture of the DHCP communication.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_76\n\nLANGUAGE: JSON\nCODE:\n```\n  \"dhcp\": {\n    \"type\":\"reply\",\n    \"id\":2787908432,\n    \"client_mac\":\"54:ee:75:51:e0:66\",\n    \"assigned_ip\":\"192.168.1.120\",\n    \"client_ip\":\"0.0.0.0\",\n    \"relay_ip\":\"192.168.1.1\",\n    \"next_server_ip\":\"0.0.0.0\",\n    \"dhcp_type\":\"offer\",\n    \"subnet_mask\":\"255.255.255.0\",\n    \"routers\":[\"192.168.1.100\"],\n    \"hostname\":\"test\",\n    \"lease_time\":86400,\n    \"renewal_time\":21600,\n    \"rebinding_time\":43200,\n    \"client_id\":\"54:ee:75:51:e0:66\",\n    \"dns_servers\":[\"192.168.1.50\",\"192.168.1.49\"]\n  }\n```\n\n----------------------------------------\n\nTITLE: Matching JA4 hash in Suricata rule\nDESCRIPTION: This example demonstrates how to create a Suricata rule that matches a specific JA4 hash. The `ja4.hash` keyword is used, specifying that the content should be matched against the JA4 hash of the QUIC client.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ja-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert quic any any -> any any (msg:\"match JA4 hash\"; \\\n      ja4.hash; content:\"q13d0310h3_55b375c5d22e_cd85d2d88918\"; \\\n      sid:100001;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email URL\nDESCRIPTION: This Suricata rule triggers an alert if an email within an SMTP packet contains the specified URL. The rule uses the 'email.url' keyword to target URLs extracted from the email body. The 'content' option indicates the URL string to match. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_7\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email url\"; email.url; content:\"test-site.org/blah/123/\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email X-Mailer Field\nDESCRIPTION: This Suricata rule raises an alert if the 'X-Mailer' field of an email found in an SMTP packet matches a given value. It makes use of the 'email.x_mailer' keyword which specifically targets the X-Mailer field in email headers. The 'content' option defines the value to search for. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_6\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email x-mailer\"; email.x_mailer; content:\"Microsoft Office Outlook, Build 11.0.5510\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Timezone Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.timezone` keyword to match the timezone field in an SDP request or response. The `content` keyword specifies the timezone string to search for, which follows the SDP timezone (z=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.timezone; content:\"2882844526 -1h 2898848070 0\"\n```\n\n----------------------------------------\n\nTITLE: Matching Kerberos Ticket Encryption in Suricata\nDESCRIPTION: This example demonstrates how to match Kerberos ticket encryption types using the `krb5.ticket_encryption` keyword in Suricata rules. It shows how to match a weak encryption or specify encryption types by integer or string values. The encryption type list can be comma or space separated.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/kerberos-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nalert krb5 any any -> any any (krb5.ticket_encryption: weak; sid:1;)\n alert krb5 any any -> any any (krb5.ticket_encryption: 23; sid:2;)\n alert krb5 any any -> any any (krb5.ticket_encryption: rc4-hmac,rc4-hmac-exp; sid:3;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with ip_proto Keyword (Named)\nDESCRIPTION: This example demonstrates the `ip_proto` keyword's usage with the protocol name to match IP protocol type. It alerts on IP packets with protocol ICMP.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nip_proto:ICMP;\n```\n\n----------------------------------------\n\nTITLE: Highlighting Rule Elements in Documentation\nDESCRIPTION: This snippet demonstrates how to use custom roles to highlight specific elements (action, header, options, emphasis) within Suricata rule documentation using reStructuredText.  It uses the `example-rule` container along with roles like `example-rule-action`, `example-rule-header`, and `example-rule-options` to format and emphasize parts of the rule.  The roles must be defined before use, and the highlighted portion is surrounded by ``.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/contribution-process.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. role:: example-rule-action\n.. role:: example-rule-header\n.. role:: example-rule-options\n.. role:: example-rule-emphasis\n\nFor rule documentation, we have a special container::\n\n    example-rule\n\nThis will present the rule in a box with an easier to read font size, and also\nallows highlighting specific elements in the signature, as the names indicate\n- action, header, options, or emphasize custom portions:\n\n    - example-rule-action\n    - example-rule-header\n    - example-rule-options\n    - example-rule-emphasis\n\nWhen using these, indicate the portion to be highlighted by surrounding it with\n` . Before using them, one has to invoke the specific role, like so::\n\n    .. role:: example-rule-role\n\nIt is only necessary to invoke the role once per document. One can see these\nbeing invoked in our introduction to the rule language (see `Rules intro\n<https://raw.githubusercontent.com/OISF/suricata/master/doc/userguide/rules/intro.rst>`_).\n\nA rule example like::\n\n    .. container:: example-rule\n\n    :example-rule-action:`alert` :example-rule-header:`http $HOME_NET any ->\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: vlan.layers equal to 2 with prefilter\nDESCRIPTION: This Suricata rule uses `vlan.layers` and `prefilter` to improve performance. The rule alerts if a packet has exactly 2 VLAN layers, and the result of this check will be used as a fast pattern for matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"Packet has 2 vlan layers\"; vlan.layers:2; prefilter; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching RFB Security Type (Greater Than or Equal)\nDESCRIPTION: This snippet demonstrates how to use the 'rfb.sectype' keyword with the '>=' qualifier to match security types greater than or equal to 3. The 'rfb.sectype' keyword uses an unsigned 32-bit integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rfb-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nrfb.sectype:>=3;\n```\n\n----------------------------------------\n\nTITLE: Pcap-file Command JSON Format\nDESCRIPTION: This defines the JSON format expected for the `pcap-file` command when sent to Suricata over the Unix socket. It shows the required `output-dir` and `filename` fields, as well as the optional `tenant`, `continuous`, and `delete-when-done` fields.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/unix-socket.rst#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"command\": \"pcap-file\",\n  \"arguments\": {\n    \"output-dir\": \"path to output dir\",\n    \"filename\": \"path to file or directory to run\",\n    \"tenant\": 0,\n    \"continuous\": false,\n    \"delete-when-done\": false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Frame Length in Telnet Parser (Rust)\nDESCRIPTION: This snippet shows how to update the frame length in the Telnet parser in Rust after the length becomes known. It uses `SCAppLayerUpdateFrameLength` to update the registered frame's length.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n/* update telnet request frame_len */\nunsafe {\n    SCAppLayerUpdateFrameLength(flow, sl.ss, 0, req.buf.len() as i64);\n}\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP2 Settings Name and Value\nDESCRIPTION: This keyword allows matching on both the name and value of an HTTP2 setting from a SETTINGS frame. It supports qualifiers like greater than (>), less than (<), and range (x-y).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http2-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nhttp2.settings:SETTINGS_ENABLE_PUSH=0;\nhttp2.settings:SETTINGS_HEADER_TABLE_SIZE>4096;\n```\n\n----------------------------------------\n\nTITLE: Suricata Command Line Parameter - Log Directory Override\nDESCRIPTION: This is an example of how to use command line arguments to override the log directory specified in the suricata.yaml file.  The -l parameter specifies the directory to use.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nsuricata -c suricata.yaml -i eth0 -l /var/log/suricata-logs/\n```\n\n----------------------------------------\n\nTITLE: Initializing Streaming Data Filter (HTTP)\nDESCRIPTION: This Lua code initializes a streaming data filter for HTTP traffic in Suricata. It defines a table `needs` with `type` set to \"streaming\" and `protocol` set to \"http\". This configuration enables the script to process HTTP body data, including unzipping and dechunking.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_46\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"type\"] = \"streaming\"\n    needs[\"protocol\"] = \"http\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring AF_XDP threads in suricata.yaml\nDESCRIPTION: This snippet shows how to configure the number of threads used by AF_XDP in the suricata.yaml configuration file. The threads option can be set to a specific number or to auto, which will configure threads based on the number of RSS queues.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  threads: <number>\n  threads: auto\n  threads: 8\n```\n\n----------------------------------------\n\nTITLE: PGSQL Event Example: Authentication OK\nDESCRIPTION: This example demonstrates a PGSQL event log entry for successful authentication. It includes server parameters, process ID, and secret key which are necessary for correlating with subsequent CancelRequest messages.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_70\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"pgsql\": {\n      \"tx_id\": 3,\n      \"response\": {\n        \"message\": \"authentication_ok\",\n        \"parameter_status\": [\n          {\n            \"application_name\": \"psql\"\n          },\n          {\n            \"client_encoding\": \"UTF8\"\n          },\n          {\n            \"date_style\": \"ISO, MDY\"\n          },\n          {\n            \"integer_datetimes\": \"on\"\n          },\n          {\n            \"interval_style\": \"postgres\"\n          },\n          {\n            \"is_superuser\": \"on\"\n          },\n          {\n            \"server_encoding\": \"UTF8\"\n          },\n          {\n            \"server_version\": \"13.6 (Debian 13.6-1.pgdg110+1)\"\n          },\n          {\n            \"session_authorization\": \"rules\"\n          },\n          {\n            \"standard_conforming_strings\": \"on\"\n          },\n          {\n            \"time_zone\": \"Etc/UTC\"\n          }\n        ],\n        \"process_id\": 28954,\n        \"secret_key\": 889887985\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Pattern Strength Calculation in Suricata (C)\nDESCRIPTION: Calculates a 'Pattern Strength' score for a given byte pattern based on character diversity.  The score is used to prioritize patterns during fast pattern matching in Suricata rules. It iterates through the byte array, assigning scores based on whether a character has been seen before and its type (alpha, printable, or other).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/fast-pattern-explained.rst#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/** \\brief Predict a strength value for patterns\n *   \n *   Patterns with high character diversity score higher.\n *   Alpha chars score not so high\n *   Other printable + a few common codes a little higher\n *   Everything else highest.\n *   Longer patterns score better than short patters.\n *\n *   \\param pat pattern\n *   \\param patlen length of the pattern\n *\n *   \\retval s pattern score\n */\nuint32_t PatternStrength(uint8_t *pat, uint16_t patlen) {\n\tuint8_t a[256];\n\tmemset(&a, 0 ,sizeof(a));\n\tuint32_t s = 0;\n\tuint16_t u = 0;\n\tfor (u = 0; u < patlen; u++) {\n\t    if (a[pat[u]] == 0) {\n\t\tif (isalpha(pat[u]))\n\t\t    s += 3;\n\t\telse if (isprint(pat[u]) || pat[u] == 0x00 || pat[u] == 0x01 || pat[u] == 0xFF)\n\t\t    s += 4;\n\t\telse\n\t\t    s += 6;\n\t\ta[pat[u]] = 1;\n\t    } else {\n\t\ts++;\n\t    }\n\t}\n\treturn s;\n    }\n```\n\n----------------------------------------\n\nTITLE: Logging HTTP Data - Lua\nDESCRIPTION: This code snippet implements the `log` function, which logs HTTP transaction data to a file. It retrieves the HTTP URI, host, and User-Agent header, cleans the retrieved strings by replacing control characters, and formats the log entry with source and destination IP addresses and ports using `SCFlowTuple()` and `SCPacketTimeString()`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/lua-output.rst#_snippet_2\n\nLANGUAGE: lua\nCODE:\n```\nfunction log(args)\n    http_uri = HttpGetRequestUriRaw()\n    if http_uri == nil then\n        http_uri = \"<unknown>\"\n    end\n    http_uri = string.gsub(http_uri, \"%c\", \".\")\n\n    http_host = HttpGetRequestHost()\n    if http_host == nil then\n        http_host = \"<hostname unknown>\"\n    end\n    http_host = string.gsub(http_host, \"%c\", \".\")\n\n    http_ua = HttpGetRequestHeader(\"User-Agent\")\n    if http_ua == nil then\n        http_ua = \"<useragent unknown>\"\n    end\n    http_ua = string.gsub(http_ua, \"%g\", \".\")\n\n    timestring = SCPacketTimeString()\n    ip_version, src_ip, dst_ip, protocol, src_port, dst_port = SCFlowTuple()\n\n    file:write (timestring .. \" \" .. http_host .. \" [**] \" .. http_uri .. \" [**] \" ..\n           http_ua .. \" [**] \" .. src_ip .. \":\" .. src_port .. \" -> \" ..\n           dst_ip .. \":\" .. dst_port .. \"\\n\")\n    file:flush()\n\n    http = http + 1\nend\n```\n\n----------------------------------------\n\nTITLE: Balancing network card flow using ethtool\nDESCRIPTION: These commands configure flow balancing on a network card using ethtool. They iterate through various protocol types and set the rx-flow-hash to use source and destination IPs.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nfor proto in tcp4 udp4 ah4 esp4 sctp4 tcp6 udp6 ah6 esp6 sctp6; do \n  /sbin/ethtool -N eth3 rx-flow-hash $proto sd\n done\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with WinDivert\nDESCRIPTION: This command runs Suricata with a specified configuration file (`suricata.yaml`) and enables WinDivert. The `[filter string]` argument allows for specifying a WinDivert filter to selectively capture network traffic. An elevated command prompt or terminal is required to execute this command.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-windows.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c suricata.yaml --windivert [filter string]\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Command Matching Rule\nDESCRIPTION: This rule matches specific commands from an FTP client request using the `ftp.command` keyword. It serves as a fast pattern for identifying various FTP commands.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.command; content:\"PASS\";` sid: 1;)\n```\n\n----------------------------------------\n\nTITLE: Rust Unit Test Example\nDESCRIPTION: This Rust code demonstrates how to define a unit test within a module. It imports necessary modules and uses the `#[test]` attribute to mark a function as a test case. The test asserts the correctness of a function's output.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-rust.rst#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nmod tests {\n    use crate::nfs::rpc_records::*;\n    use nom::Err::Incomplete;\n    use nom::Needed::Size;\n\n    #[test]\n    fn test_partial_input_ok() {\n        let buf: &[u8] = &[\n            0x80, 0x00, 0x00, 0x9c, // flags\n            0x8e, 0x28, 0x02, 0x7e, // xid\n            0x00, 0x00, 0x00, 0x01, // msgtype\n            0x00, 0x00, 0x00, 0x02, // rpcver\n            0x00, 0x00, 0x00, 0x03, // program\n            0x00, 0x00, 0x00, 0x04, // progver\n            0x00, 0x00, 0x00, 0x05, // procedure\n        ];\n        let expected = RpcRequestPacketPartial {\n            hdr: RpcPacketHeader {\n                    frag_is_last: true,\n                    frag_len: 156,\n                    xid: 2384986750,\n                    msgtype: 1\n                },\n            rpcver: 2,\n            program: 3,\n            progver: 4,\n            procedure: 5\n        };\n        let r = parse_rpc_request_partial(buf);\n        match r {\n            Ok((rem, hdr)) => {\n                assert_eq!(rem.len(), 0);\n                assert_eq!(hdr, expected);\n            },\n            _ => { panic!(\"failed {:?}\",r); }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FTP State Enum - C\nDESCRIPTION: This C code defines an enum to represent the states of an FTP transaction. The states include `FTP_STATE_IN_PROGRESS`, `FTP_STATE_PORT_DONE`, and `FTP_STATE_FINISHED`, allowing Suricata to track the progress and completeness of FTP transactions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nenum {\n    FTP_STATE_IN_PROGRESS,\n    FTP_STATE_PORT_DONE,\n    FTP_STATE_FINISHED,\n};\n```\n\n----------------------------------------\n\nTITLE: Install Hyperscan Development Package (Ubuntu/Debian)\nDESCRIPTION: This command installs the Hyperscan development package on Ubuntu or Debian using the APT package manager. This package includes the header files and libraries needed to compile Suricata with Hyperscan support.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/hyperscan.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install libhyperscan-dev\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Base64 Decoding with Relative Offset (Alternative)\nDESCRIPTION: This is an alternative Suricata rule that achieves the same base64 decoding and matching as the previous example, but with a different order of keywords. The content match on \"somestring\" is still crucial for the relative offset in base64_decode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/base64-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"Example\"; content:\"somestring\"; http_uri; \\\n     base64_decode:bytes 8, offset 1, relative; \\\n     base64_data; content:\"test\"; sid:10001; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: DNS Response Parser Example in Rust\nDESCRIPTION: This code shows an example of a DNS response parser implemented in Rust for Suricata.  It is marked with `#[no_mangle]` to prevent name mangling and uses `extern \"C\"` to be callable from C code.  It adheres to the expected callback signature, taking a flow, state, parser state, input buffer, length, data, and flags as input. The function returns an `AppLayerResult`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/parser.rst#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\n    pub extern \"C\" fn rs_dns_parse_response_tcp(_flow: *const core::Flow,\n            state: *mut std::os::raw::c_void,\n            _pstate: *mut std::os::raw::c_void,\n            input: *const u8,\n            input_len: u32,\n            _data: *const std::os::raw::c_void,\n            _flags: u8)\n    -> AppLayerResult\n```\n\n----------------------------------------\n\nTITLE: Variable definition indentation example\nDESCRIPTION: Example of proper indentation for variable definitions in C, using 4-space indentation for wrapped lines.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nconst SCPlugin PluginSpec = {\n    .name = OUTPUT_NAME,\n    .author = \"Some Developer\",\n    .license = \"GPLv2\",\n    .Init = TemplateInit,\n};\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT UNSUBSCRIBE (JSON)\nDESCRIPTION: This example shows the JSON format for logging MQTT UNSUBSCRIBE messages.  It contains information about the unsubscription, including qos, retain, dup, message_id, and an array of topics to unsubscribe from.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_60\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"unsubscribe\": {\n    \"qos\": 1,\n    \"retain\": false,\n    \"dup\": false,\n    \"message_id\": 1,\n    \"topics\": [\n      \"topicX\",\n      \"topicY\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Examining all traffic with WinDivert\nDESCRIPTION: This command instructs Suricata to examine all network traffic by setting the WinDivert filter to `true`.  It requires a configuration file (`suricata.yaml`) and can be used in either normal (`--windivert`) or forward (`--windivert-forward`) mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-windows.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c suricata.yaml --windivert[-forward] true\n```\n\n----------------------------------------\n\nTITLE: Bittorrent-DHT Response Logging Example (JSON)\nDESCRIPTION: Demonstrates the JSON structure for logging a Bittorrent-DHT response. It includes fields like transaction ID and client version.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_37\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"transaction_id\": \"0c17\",\n    \"client_version\": \"5554b50c\",\n  }\n```\n\n----------------------------------------\n\nTITLE: Matching SSH Protocol Version\nDESCRIPTION: This rule matches SSH connections based on the protocol version. The `ssh.proto` keyword is used as a sticky buffer for fast pattern matching, and the `content` keyword searches for the string \"2.0\" to identify SSH version 2.0 connections.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ssh-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ssh any any -> any any (msg:\"match SSH protocol version\"; ssh.proto; content:\"2.0\"; sid:1000010;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom TLS Logging in Suricata\nDESCRIPTION: This snippet demonstrates how to enable custom TLS logging in Suricata by modifying the `tls-log` section of the `Suricata.yaml` configuration file.  It shows how to set the filename, enable appending, enable custom formatting, and define the `customformat` string using available format specifiers. The customformat string determines the structure and content of the TLS log entries.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/custom-tls-logging.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n  - tls-log:\n      enabled: yes      # Log TLS connections.\n      filename: tls.log # File to store TLS logs.\n      append: yes\n      custom: yes       # enabled the custom logging format (defined by customformat)\n      customformat: \"%{%D-%H:%M:%S}t.%z %a:%p -> %A:%P %v %n %d %D\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving TLS Certificate Not After Timestamp in Lua\nDESCRIPTION: This code demonstrates how to retrieve the 'not after' timestamp from a TLS certificate using `TlsGetCertNotAfter()`. It compares the timestamp with the current time to check if the certificate has expired.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_23\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    notafter = TlsGetCertNotAfter()\n    if notafter < os.time() then\n        -- expired certificate\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Detecting Kerberos Malformed Data Event in Suricata\nDESCRIPTION: This example shows how to trigger an event when malformed data is detected in Kerberos traffic using the `app-layer-event:krb5.malformed_data` event in Suricata rules. This event is raised when a protocol decoding error occurs.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/kerberos-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert krb5 any any -> any any (msg:\"SURICATA Kerberos 5 malformed request data\"; flow:to_server; app-layer-event:krb5.malformed_data; classtype:protocol-command-decode; sid:2226000; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Stream Checksum Validation Configuration\nDESCRIPTION: This snippet shows how to configure stream checksum validation in Suricata.  The `checksum-validation: yes` option in the `stream` section enables the rejection of packets with invalid checksums, ensuring data integrity. Alerting on bad checksums is handled via rules in Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nstream:\n  checksum-validation: yes      # reject wrong csums\n```\n\n----------------------------------------\n\nTITLE: Regular TLS Log Example\nDESCRIPTION: This JSON snippet shows a regular TLS log entry, including the 'subject' and 'issuerdn' (issuer distinguished name) fields from the TLS certificate.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_25\n\nLANGUAGE: json\nCODE:\n```\n  \"tls\": {\n      \"subject\": \"C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.google.com\",\n      \"issuerdn\": \"C=US, O=Google Inc, CN=Google Internet Authority G2\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Filtering only TCP traffic on port 80 with WinDivert\nDESCRIPTION: This command filters network traffic to only include TCP packets destined for port 80 using WinDivert.  A configuration file (`suricata.yaml`) is required.  The WinDivert filter string `\"tcp.DstPort == 80\"` ensures that only TCP traffic with a destination port of 80 is processed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-windows.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c suricata.yaml --windivert \"tcp.DstPort == 80\"\n```\n\n----------------------------------------\n\nTITLE: Threshold Rule Example\nDESCRIPTION: An example rule utilizing the 'threshold' keyword within a rule definition. The rule will only fire if 10 or more emails are sent from a host within 60 seconds.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nalert tcp any any -> any 25 (msg:\"ET POLICY Inbound Frequent Emails - Possible Spambot Inbound\"; \\\n     flow:established; content:\"mail from|3a|;\"; nocase;                                          \\\n     threshold: type threshold, track by_src, count 10, seconds 60;                              \\\n     reference:url,doc.emergingthreats.net/2002087; classtype:misc-activity; sid:2002087; rev:10;)\n```\n\n----------------------------------------\n\nTITLE: SMB1 Session Setup Logging Example (JSON)\nDESCRIPTION: This illustrates the JSON structure capturing the 'request' and 'response' fields within SMB1 session setup, which includes native OS and Lan Manager strings to identify the client and server operating systems.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_33\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"request\": {\n      \"native_os\": \"Unix\",\n      \"native_lm\": \"Samba 3.9.0-SVN-build-11572\"\n    },\n    \"response\": {\n      \"native_os\": \"Windows (TM) Code Name \\\"Longhorn\\\" Ultimate 5231\",\n      \"native_lm\": \"Windows (TM) Code Name \\\"Longhorn\\\" Ultimate 6.0\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Request Line in Lua\nDESCRIPTION: This snippet retrieves the full HTTP request line using the `HttpGetRequestLine()` function and prints its value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_10\n\nLANGUAGE: lua\nCODE:\n```\nrl = HttpGetRequestLine();\nprint (\"Request Line: \" .. rl);\n```\n\n----------------------------------------\n\nTITLE: LDAP Error Message Matching\nDESCRIPTION: This Suricata rule alerts if an LDAP packet contains the error message \"Size limit exceeded\" in any of the LDAP response messages.  The `ldap.responses.message` keyword is a sticky buffer and supports `fast_pattern`. Comparison is case-sensitive.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP error message\"; ldap.responses.message; content:\"Size limit exceeded\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for Detection Scripts in Lua\nDESCRIPTION: This code snippet demonstrates how to initialize the `needs` table in a Lua script for Suricata to enable packet detection. It sets the 'packet' key to 'true', indicating that the script requires packet data for analysis.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_0\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"packet\"] = tostring(true)\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata with Specific Clang Path (Bash)\nDESCRIPTION: This code snippet configures Suricata to use a specific Clang compiler path, even if Clang is not the default compiler for Suricata itself. This ensures the eBPF code is built with the correct compiler.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n ./configure --prefix=/usr/ --sysconfdir=/etc/ --localstatedir=/var/ \\\n --enable-ebpf --enable-ebpf-build --with-clang=/usr/bin/clang\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Capabilities in Suricata Rules\nDESCRIPTION: The `enip.capabilities` keyword is used to match on the capabilities in list services messages. It uses a 16-bit unsigned integer as its value. This can be used to identify the features supported by a service.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.capabilities:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.capabilities:>1;\n```\n\n----------------------------------------\n\nTITLE: Suricata Command to Start with Specific Rule File\nDESCRIPTION: This command starts Suricata with a specific rule file, disregarding other enabled rules. The `-c` option specifies the configuration file, `-S` specifies the rule file, and `-i` specifies the interface.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n  suricata -c /etc/suricata/suricata.yaml -S file.rules -i eth0\n```\n\n----------------------------------------\n\nTITLE: Requiring Suricata Rule Library - Lua\nDESCRIPTION: Imports the `suricata.rule` library into a Lua script, making its functions and objects available for use. This is the initial step to working with Suricata rules in Lua.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/rule.rst#_snippet_0\n\nLANGUAGE: Lua\nCODE:\n```\n  local rule = require(\"suricata.rule\")\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP2 Header Name\nDESCRIPTION: This keyword matches on the name of an HTTP2 header from a HEADER frame (or PUSH_PROMISE or CONTINUATION). It is a sticky buffer and can be used as a fast_pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http2-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nhttp2.header_name; content:\"agent\";\n```\n\n----------------------------------------\n\nTITLE: Modbus Function Matching\nDESCRIPTION: This snippet demonstrates how to match Modbus requests based on function codes, sub-function codes, or function categories (assigned, unassigned, public, user, reserved).  It uses the `function` setting of the `modbus` keyword to define the matching criteria.  The `!` sign can be used for negation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/modbus-keyword.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: function 21\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: function 4, subfunction 4\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: function assigned\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: function public\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: function user\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: function reserved\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: function !reserved\n```\n\n----------------------------------------\n\nTITLE: Suricata SSH Protocol Version Rule\nDESCRIPTION: This snippet defines a Suricata rule to match SSH protocol version 2.0. It utilizes the ssh.proto keyword and includes options for message, content matching for the SSH protocol version, and SID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/contribution-process.rst#_snippet_2\n\nLANGUAGE: suricata\nCODE:\n```\nalert ssh any any -> any any (msg:\"match SSH protocol version\";\n    ssh.proto; content:\"2.0\"; sid:1000010;)\n```\n\n----------------------------------------\n\nTITLE: HTTP custom header logging configuration\nDESCRIPTION: This snippet demonstrates how HTTP custom headers were configured in Suricata 6.0 using the `http.custom` option.  The custom headers were merged directly into the main `http` object in the EVE log.  This could lead to potential conflicts or overwrites of standard fields.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nhttp:\n  custom: [Server]\n```\n\n----------------------------------------\n\nTITLE: FTP_DATA Log Example\nDESCRIPTION: This JSON snippet exemplifies an FTP_DATA log entry. It includes the 'filename' and the associated 'command' that triggered the data transfer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_24\n\nLANGUAGE: json\nCODE:\n```\n  \"ftp_data\": {\n    \"filename\": \"temp.txt\",\n    \"command\": \"RETR\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Check Template Transaction Progress in C\nDESCRIPTION: This C function, `TemplateGetStateProgress`, checks if a Template Protocol transaction is considered complete based on the traffic direction and the presence of a response. It takes a void pointer to the transaction and a direction flag as input. It logs a notice message including the transaction ID and direction. Returns 1 if the transaction is considered complete, 0 otherwise.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nstatic int TemplateGetStateProgress(void *txv, uint8_t direction)\n{\n    TemplateTransaction *tx = txv;\n\n    SCLogNotice(\"Transaction progress requested for tx ID %\"PRIu64\n        \", direction=0x%02x\", tx->tx_id, direction);\n\n    if (direction & STREAM_TOCLIENT && tx->response_done) {\n        return 1;\n    }\n    else if (direction & STREAM_TOSERVER) {\n        /* For the template, just the existence of the transaction means the\n         * request is done. */\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Subscribe Topic\nDESCRIPTION: This example demonstrates matching a topic in a MQTT SUBSCRIBE message using the `mqtt.subscribe.topic` keyword combined with content matching. It matches when the topic is \"mytopic\". The subscribe topic is a 'sticky buffer' and supports multi-buffer matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_19\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.subscribe.topic; content:\"mytopic\";\n```\n\n----------------------------------------\n\nTITLE: Colorize JSON Output with jq\nDESCRIPTION: This command pipes the eve.json file to jq, which formats the JSON output for better readability. The `-c` option makes the output compact.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-examplesjq.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntail -f eve.json | jq -c '.'\n```\n\n----------------------------------------\n\nTITLE: Configuring busy-poll-budget in suricata.yaml\nDESCRIPTION: This snippet shows how to configure busy-poll-budget in the suricata.yaml configuration file.  This sets the budget allowed for batching of ingress frames.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  busy-poll-budget: <budget>\n  busy-poll-budget: 64\n```\n\n----------------------------------------\n\nTITLE: Configuring ARP Logging with EVE JSON\nDESCRIPTION: This snippet configures ARP logging using the EVE JSON output format. The logger is disabled by default due to the high volume of events it can generate. The `enabled` option can be set to `yes` to activate it.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\n        - arp:\n            enabled: no\n```\n\n----------------------------------------\n\nTITLE: Checking Suricata logs\nDESCRIPTION: These commands check the Suricata log files (http.log and stats.log) to verify if the engine is working correctly and inspecting traffic. `tail http.log` displays the latest HTTP traffic logs.  `tail -n 50 stats.log` displays the last 50 lines of statistics. The `-f` option provides real-time updates.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd /var/log/suricata\ntail http.log\ntail -n 50 stats.log\ntail -f http.log stats.log\n```\n\n----------------------------------------\n\nTITLE: Initializing Packet in Lua\nDESCRIPTION: Initializes a packet object `p` with the current packet being processed by the Suricata engine. This is a required step before using any of the packet access methods.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_1\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\n```\n\n----------------------------------------\n\nTITLE: Defining Frame Types Enum in C\nDESCRIPTION: This C code snippet demonstrates how to define an enum for the HTTP frame types. This enum is required when implementing frame support in C.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\ntypedef enum HttpFrameTypes {\n    HTTP_FRAME_INVALID = 0,\n    HTTP_FRAME_REQHDR,\n    HTTP_FRAME_REQBODY,\n    HTTP_FRAME_RESHDR,\n    HTTP_FRAME_RESBODY,\n    HTTP_FRAME_RAWURI,\n    HTTP_FRAME_HOSTNAME,\n    HTTP_FRAME_COOKIE,\n    HTTP_FRAME_XFF,\n    HTTP_FRAME_UA,\n    HTTP_FRAME_REFERER,\n    HTTP_FRAME_CLIENT_IP,\n    HTTP_FRAME_FULL_REQ,\n    HTTP_FRAME_FULL_RES\n} HttpFrameTypes;\n```\n\n----------------------------------------\n\nTITLE: Loading PF_RING plugin in suricata.yaml\nDESCRIPTION: This code snippet shows how to load the PF_RING plugin in the suricata.yaml configuration file. It involves adding the path to the `pfring.so` file under the `plugins` section. This is necessary for Suricata to utilize PF_RING functionality.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-pfring-plugin.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nplugins:\n  - /usr/lib/suricata/pfring.so\n```\n\n----------------------------------------\n\nTITLE: Legacy TLS Subject Matching in Suricata\nDESCRIPTION: This example demonstrates the legacy keyword `tls.subject` to match the Subject field of a TLS/SSL certificate in Suricata. Note that this keyword is case-sensitive and does not support modifiers like 'nocase'. It is recommended to use `tls.cert_subject` instead.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.subject:\"CN=*.googleusercontent.com\"\n```\n\n----------------------------------------\n\nTITLE: Enable Conditional PCAP Logging with Tag\nDESCRIPTION: This YAML snippet configures Suricata to perform conditional PCAP logging based on the 'tag' keyword. By setting `conditional: tag`, only packets tagged with the 'tag' keyword will be logged to the PCAP file. Other PCAP logging options like `limit`, `max-files`, `compression`, and `mode` are also configured.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tag.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\noutputs:\n  - pcap-log:\n      enabled: yes\n      filename: log.pcap\n      limit: 1000mb\n      max-files: 2000\n      compression: none\n      mode: normal\n      use-stream-depth: no #If set to \"yes\" packets seen after reaching stream inspection depth are ignored. \"no\" logs all packets\n      honor-pass-rules: no # If set to \"yes\", flows in which a pass rule matched will stop being logged.\n      # Use \"all\" to log all packets or use \"alerts\" to log only alerted packets and flows or \"tag\"\n      # to log only flow tagged via the \"tag\" keyword\n      conditional: tag\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with Myricom Rings\nDESCRIPTION: This command starts Suricata with Myricom ring buffer support, setting the number of rings to 8, enabling SNF flags, specifying the configuration file, interface, and run mode. The ``SNF_NUM_RINGS`` environment variable controls the number of ring buffers used by the Myricom driver. The ``SNF_FLAGS`` are used for specific configurations.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/myricom.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nSNF_NUM_RINGS=8 SNF_FLAGS=0x1 suricata -c suricata.yaml -i eth5 --runmode=workers\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata - Bash\nDESCRIPTION: This command executes the configure script, which prepares the build environment for Suricata. It checks for dependencies, sets up build options, and generates the Makefiles.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./configure\n```\n\n----------------------------------------\n\nTITLE: Initializing Output Script - Lua\nDESCRIPTION: This function initializes a Suricata Lua output script, specifying its type (packet) and filter (alerts). It sets up the script to process alert events related to packets.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/rule.rst#_snippet_1\n\nLANGUAGE: Lua\nCODE:\n```\n  function init(args)\n      return {\n          type = \"packet\",\n          filter = \"alerts\",\n      }\n  end\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with fragbits Keyword\nDESCRIPTION: This rule utilizes the `fragbits` keyword with the `M` flag (More Fragments) to detect non-fragmented packets with a fragment offset greater than zero.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"fragbits keyword example non-fragmented packet with fragment offset>0\"; fragbits:M; fragoffset:>0; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring Recursion Level for Flow Tracking in Suricata\nDESCRIPTION: This snippet shows how to configure the recursion level for flow matching in Suricata.  The `use-for-tracking` option determines whether the recursion level is used to associate incoming and outgoing flows when packets are encapsulated.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_71\n\nLANGUAGE: yaml\nCODE:\n```\ndecoder:\n  # Depending on packet pickup, incoming and outgoing tunnelled packets\n  # can be scanned before the kernel has stripped and encapsulated headers,\n  # respectively, leading to incoming and outgoing flows not being associated.\n  recursion-level:\n    use-for-tracking: true\n```\n\n----------------------------------------\n\nTITLE: C Unit Test - Configuration Override\nDESCRIPTION: This unit test from `conf-yaml-loader.c` verifies that a configuration section is correctly overridden by subsequent occurrences in the YAML configuration.  It loads a YAML string, checks if a specific value is overridden, and verifies the existence of certain nodes in the configuration tree. It relies on `SCConf` functions for managing the Suricata configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-c.rst#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/**\n * Test that a configuration section is overridden but subsequent\n * occurrences.\n */\nstatic int\nConfYamlOverrideTest(void)\n{\n    char config[] =\n        \"%YAML 1.1\\n\"\n        \"---\\n\"\n        \"some-log-dir: /var/log\\n\"\n        \"some-log-dir: /tmp\\n\"\n        \"\\n\"\n        \"parent:\\n\"\n        \"  child0:\\n\"\n        \"    key: value\\n\"\n        \"parent:\\n\"\n        \"  child1:\\n\"\n        \"    key: value\\n\"\n        ;\n    const char *value;\n\n    SCConfCreateContextBackup();\n    SCConfInit();\n\n    FAIL_IF(SCConfYamlLoadString(config, strlen(config)) != 0);\n    FAIL_IF_NOT(SCConfGet(\"some-log-dir\", &value));\n    FAIL_IF(strcmp(value, \"/tmp\") != 0);\n\n    /* Test that parent.child0 does not exist, but child1 does. */\n    FAIL_IF_NOT_NULL(SCConfGetNode(\"parent.child0\"));\n    FAIL_IF_NOT(SCConfGet(\"parent.child1.key\", &value));\n    FAIL_IF(strcmp(value, \"value\") != 0);\n\n    SCConfDeInit();\n    SCConfRestoreContextBackup();\n\n    PASS;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for TLS Protocol in Lua (Detection)\nDESCRIPTION: This snippet demonstrates how to initialize the 'needs' table to detect TLS traffic. The 'tls' key is set to true, giving the script access to TLS data for detection logic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_19\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"tls\"] = tostring(true)\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Copying XDP Filter (Bash)\nDESCRIPTION: This command copies the compiled XDP filter to the Suricata eBPF directory, allowing Suricata to load the XDP program. This step is essential for utilizing XDP-based packet processing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n cp ebpf/xdp_filter.bpf /usr/libexec/suricata/ebpf/\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata service\nDESCRIPTION: This command starts the Suricata service using systemctl. It requires sudo privileges to execute. The command initiates the Suricata intrusion detection system.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start suricata\n```\n\n----------------------------------------\n\nTITLE: Verifying Suricata Distribution File with GPG\nDESCRIPTION: This command verifies the integrity of the Suricata distribution file using the corresponding signature file. It checks if the signature is valid and if the signing key is trusted, which helps to ensure that the downloaded file is authentic and hasn't been altered. The command uses the `gpg --verify` option to perform the verification.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/verifying-source-files.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ gpg --verify suricata-7.0.5.tar.gz.sig suricata-7.0.5.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Suricata Relative PCRE Match\nDESCRIPTION: Example of a relative PCRE match in Suricata. It searches for an 8-character alphanumeric string after '.php?sign=' in the HTTP URI. Snort does not allow combining the 'relative' PCRE option ('R') with buffer options like normalized URI ('U').\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\ncontent:\".php?sign=\"; http_uri; pcre:\"/^[a-zA-Z0-9]{8}$/UR\";\n```\n\n----------------------------------------\n\nTITLE: Copying Suricata configuration files\nDESCRIPTION: These commands copy the essential Suricata configuration files (classification.config, reference.config, and suricata.yaml) from the source directory to the /etc/suricata directory.  This step is crucial for configuring Suricata. The source files are typically found in the Suricata build/installation directory. The commands require root privileges.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo cp classification.config /etc/suricata\nsudo cp reference.config /etc/suricata\nsudo cp suricata.yaml /etc/suricata\n```\n\n----------------------------------------\n\nTITLE: Retrieving SSH Server Software Version in Lua\nDESCRIPTION: This code demonstrates retrieving the SSH server software version using the function `SshGetServerSoftwareVersion()` within the log function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_37\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    software = SshGetServerSoftwareVersion()\n    if software == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating Suricata configuration file\nDESCRIPTION: These commands show how to modify the Suricata configuration file (suricata.yaml) using 'nano' or 'vim' text editors. The 'sudo' command grants administrative privileges, allowing modification of the system-wide configuration. The user should select only one editor to modify the configuration file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/adding-your-own-rules.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo nano /etc/suricata/suricata.yaml\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo vim /etc/suricata/suricata.yaml\n```\n\n----------------------------------------\n\nTITLE: LDAP Result Code Matching - Specific Index\nDESCRIPTION: This Suricata rule alerts if an LDAP packet has an \"unavailable\" result code at index 1 of the responses array. This illustrates how to specify a particular index to check for the presence of a specific result code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP result code at index 1\"; :example-rule-emphasis:`ldap.responses.result_code:unavailable,1;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: LDAP Response Count Alert Rule (0 Responses)\nDESCRIPTION: This Suricata rule alerts if a packet has 0 LDAP responses. It uses the `ldap.responses.count` keyword with the value `0`. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Packet has 0 LDAP responses\"; :example-rule-emphasis:`ldap.responses.count:0;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Defining memcap and hashsize per dataset\nDESCRIPTION: This example demonstrates how to define `memcap` and `hashsize` values for a specific dataset in the Suricata configuration. This allows fine-tuning the memory usage and performance of individual datasets.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\ndatasets:\n  ua-seen:\n    type: string\n    load: ua-seen.lst\n    memcap: 10mb\n    hashsize: 1024\n```\n\n----------------------------------------\n\nTITLE: Stopping and Disabling irqbalance Service (Bash)\nDESCRIPTION: This code snippet stops the `irqbalance` service and disables it from starting on boot.  `irqbalance` can interfere with the described setups so it is recommended to disable it. This involves using `systemctl` to manage the service.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n systemctl stop irqbalance\n systemctl disable irqbalance\n```\n\n----------------------------------------\n\nTITLE: Configure Hyperscan Caching in suricata.yaml\nDESCRIPTION: These lines configure Hyperscan's MPM caching in the `suricata.yaml` file. `sgh-mpm-caching: yes` enables caching, and `sgh-mpm-caching-path` specifies the directory where the cache files will be stored.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/hyperscan.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ndetect:\n  # Cache MPM contexts to the disk to avoid rule compilation at the startup.\n  # Cache files are created in the standard library directory.\n  sgh-mpm-caching: yes\n  sgh-mpm-caching-path: /var/lib/suricata/cache/hs\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Vendor ID in Suricata Rules\nDESCRIPTION: The `enip.vendor_id` keyword is used to match on the vendor ID in the identity message. It uses a 16-bit unsigned integer as its value. This keyword helps in identifying the manufacturer of the device.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.vendor_id:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.vendor_id:>1;\n```\n\n----------------------------------------\n\nTITLE: Updating Suricata Repository - Bash\nDESCRIPTION: This command updates the local Suricata repository with the most recent code from the remote repository. The first command changes the current directory to the 'suricata/suricata' directory inside the cloned repository. The second command pulls the latest changes from the remote repository.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncd suricata/suricata\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Analyzing NTLMSSP Fields in JSON\nDESCRIPTION: This snippet demonstrates the structure of NTLMSSP (NT LAN Manager Security Support Provider) fields within a JSON object, often found within SMB (Server Message Block) traffic analysis. It includes fields such as 'domain', 'user', 'host', and 'version' to provide information about the Windows authentication process.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_44\n\nLANGUAGE: json\nCODE:\n```\n    \"ntlmssp\": {\n      \"domain\": \"VNET3\",\n      \"user\": \"administrator\",\n      \"host\": \"BLU\",\n      \"version\": \"60.230 build 13699 rev 188\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Endswith Example\nDESCRIPTION: This example demonstrates the usage of the 'endswith' keyword in Suricata rules. It illustrates how to modify the 'content' to match exactly at the end of a buffer and provides the equivalent usage with isdataat.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_3\n\nLANGUAGE: suricata\nCODE:\n```\ncontent:\".php\"; endswith;\n```\n\nLANGUAGE: suricata\nCODE:\n```\ncontent:\".php\"; isdataat:!1,relative;\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Product Name in Suricata Rules\nDESCRIPTION: The `enip.product_name` keyword matches the product name in the identity message.  It can be used with `pcre` and `content` keywords. It is a sticky buffer and can be used as `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.product_name; pcre:\"/^123[0-9]*/\";\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.product_name; content:\"swordfish\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Packet Acquisition Configuration\nDESCRIPTION: This snippet shows a verbose configuration of Suricata for packet acquisition, using various interfaces such as `eth0`, `pfring`, `afpacket`, `nfq`, and `ipfw`. It can specify buffer sizes, BPF filters, checksum checks, threads, promiscuous mode, and snaplen. The operational mode (passive, inline, or file-based) is determined by the command-line invocation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\npcap:\n  - interface: eth0\n    #buffer-size: 16777216\n    #bpf-filter: \"tcp and port 25\"\n    #checksum-checks: auto\n    #threads: 16\n    #promisc: no\n    #snaplen: 1518\npfring:\nafpacket:\nnfq:\nipfw:\n```\n\n----------------------------------------\n\nTITLE: Function Declaration and Definition\nDESCRIPTION: Example function declaration using a NamedLikeThis() style. This example demonstrates how to declare a function using `static` and specifies parameters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_24\n\nLANGUAGE: c\nCODE:\n```\nstatic SCConfNode *SCConfGetNodeOrCreate(char *name, int final)\n```\n\n----------------------------------------\n\nTITLE: Unregistering Tenant Handlers for VLANs via Unix Socket\nDESCRIPTION: These commands show how to unregister tenant handlers for VLANs via the Suricata Unix socket. The `unregister-tenant-handler` command takes the tenant ID and VLAN ID as arguments.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nunregister-tenant-handler 4 vlan 1111\nunregister-tenant-handler 1 vlan 1000\n```\n\n----------------------------------------\n\nTITLE: Registering Callbacks in Suricata (C)\nDESCRIPTION: This code registers callback functions for specific events related to HTTP frame processing in Suricata.  These callbacks are essential for handling different stages of frame processing, such as freeing the frame after use. The actual functions implementing the callbacks need to be defined elsewhere.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\n        /* app-layer-frame-documentation tag start: registering relevant callbacks\n         * app-layer-frame-type: http_request\n         *\n         * Register relevant callbacks (note that the actual functions will also\n         * have to be written, for C):\n         */\n        AppLayerFrameCallbacksRegister(\n            frame_http_request_id,\n            AppLayerHtpFrameDataSetup,\n            AppLayerHtpFrameDataCopy,\n            AppLayerHtpFrameDataFree\n        );\n\n```\n\n----------------------------------------\n\nTITLE: Including a Single YAML File in Suricata\nDESCRIPTION: This code snippet shows how to include a single YAML file within a Suricata configuration file using the `include` keyword. The content of `filename.yaml` will be inserted at the location of this statement. No specific dependencies are required beyond a valid YAML file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/includes.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ninclude: filename.yaml\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Certificate NotAfter Date in Suricata\nDESCRIPTION: This example demonstrates matching the 'NotAfter' date within a TLS certificate using the `tls_cert_notafter` keyword in Suricata. It checks if the 'NotAfter' date is later than the specified date.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"match cert NotAfter\"; \\\n    tls_cert_notafter:>2015; sid:200006;)\n```\n\n----------------------------------------\n\nTITLE: Enabling Stream Bypass in Suricata Configuration\nDESCRIPTION: This snippet demonstrates how to enable stream bypass in Suricata's configuration file. When enabled, Suricata bypasses subsequent packets of a flow after evaluating the initial chunk, reducing CPU usage. This configuration is set within the `stream` section of the Suricata configuration file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nstream:\n  bypass: true\n```\n\n----------------------------------------\n\nTITLE: Snort Rule Example\nDESCRIPTION: This is an example Snort rule to detect traffic. It highlights how to specify ports in Snort rules, which may be different from how ports are specified in Suricata rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nalert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS ...\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with alert Keyword\nDESCRIPTION: This rule demonstrates the use of the `alert` keyword in a Suricata rule. It shows how to generate an alert even when the rule action, such as `pass`, doesn't inherently trigger alerts. This allows for an \"alert then pass\" logic where an alert is generated, and the traffic is allowed to proceed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/noalert.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\npass http any any -> any any (http.user_agent; content:\"Mozilla/5.0\"; startwith; endswith; \\\n   :example-rule-options:`alert;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Initializing Streaming Data Filter (TCP)\nDESCRIPTION: This Lua code initializes a streaming data filter for TCP traffic in Suricata. It defines a table `needs` with `type` set to \"streaming\" and `filter` set to \"tcp\". This configuration allows the script to process reassembled TCP data chunks.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_45\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"type\"] = \"streaming\"\n    needs[\"filter\"] = \"tcp\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Importing the Suricata Packet Library in Lua\nDESCRIPTION: Imports the `suricata.packet` library, making its functions available for use in a Suricata rule or script. This is the starting point for interacting with packet data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_0\n\nLANGUAGE: Lua\nCODE:\n```\nlocal packet = require(\"suricata.packet\")\n```\n\n----------------------------------------\n\nTITLE: Navigate to PCAP Subdirectory\nDESCRIPTION: This snippet demonstrates changing the current directory to a specific subdirectory containing PCAP files. This allows the user to target a specific set of capture files. The example shows navigating to a date-based directory.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-profiling.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/Desktop/2011-05-05\n```\n\n----------------------------------------\n\nTITLE: Registering a Flow Logger in Suricata (C)\nDESCRIPTION: This code snippet shows the function signature for registering a flow logger within Suricata. Flow loggers are used to log information about network flows. The `SCOutputRegisterFlowLogger` function allows registering a custom function to handle flow logging, enhancing flow monitoring capabilities.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/output/index.rst#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/** \\brief Register a flow logger\n *\n *  This function registers a function that is responsible for logging\n *  flow related output.\n *\n *  \\param logger The logger to register.\n *\n *  \\return void\n */\n```\n\nLANGUAGE: c\nCODE:\n```\nvoid SCOutputRegisterFlowLogger(void (*logger)(SCLogRecord *lr, Flow *f, void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                       , void *data\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                       , void (*deinit)(void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                       );\n```\n\n----------------------------------------\n\nTITLE: Logrotate Configuration for Suricata\nDESCRIPTION: This logrotate configuration rotates Suricata log files (*.log and *.json) located in /var/log/suricata/. After rotation, it sends a SIGHUP signal to the Suricata process using its PID to trigger Suricata to reopen the log files. It depends on the existence of a Suricata PID file, either generated by running in daemon mode or specified using the --pidfile option.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/log-rotation.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n/var/log/suricata/*.log /var/log/suricata/*.json\n{\n    rotate 3\n    missingok\n    nocompress\n    create\n    sharedscripts\n    postrotate\n            /bin/kill -HUP `cat /var/run/suricata.pid 2>/dev/null` 2>/dev/null || true\n    endscript\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Syslog Template for sysklogd (rsyslog)\nDESCRIPTION: This code snippet shows how to define a syslog template named 'sysklogd' in an rsyslog configuration file. The template specifies the format of syslog messages to match the sysklogd format. This helps ensure compatibility when forwarding logs to systems expecting the sysklogd format.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/syslog-alerting-comp.rst#_snippet_2\n\nLANGUAGE: rsyslog\nCODE:\n```\n$template sysklogd, \"<%PRI%>%syslogtag:1:32%%msg:::sp-if-no-1st-sp%%msg%\"\n```\n\n----------------------------------------\n\nTITLE: Setting File Permissions for Suricata Log Directory\nDESCRIPTION: These commands modify the group ownership and permissions of the /var/log/suricata directory. They set the group to 'suricata' and grant read and write access to the group.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nchgrp -R suricata /var/log/suricata\nchmod -R g+rw /var/log/suricata\n```\n\n----------------------------------------\n\nTITLE: Configure Modbus Stream Depth\nDESCRIPTION: This snippet demonstrates how to configure the stream depth for the Modbus parser in Suricata. Setting the stream depth to 0 configures it to unlimited as recommended by the MODBUS Messaging on TCP/IP Implementation Guide.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_44\n\nLANGUAGE: yaml\nCODE:\n```\nmodbus:\n  # Stream reassembly size for modbus, default is 0\n  stream-depth: 0\n```\n\n----------------------------------------\n\nTITLE: Initializing Suricata Lua script for DNS logging\nDESCRIPTION: This snippet shows how to initialize a Lua script for DNS protocol analysis within Suricata. It defines the `init` function to specify that the script requires DNS protocol data, enabling it to receive DNS events.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_1\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init (args)\n   local needs = {}\n   needs[\"protocol\"] = \"dns\"\n   return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Getting the flow ID in Lua\nDESCRIPTION: This snippet retrieves the unique identifier (`id`) of the flow. It demonstrates how to format the ID as a string to avoid scientific notation when printing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_8\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\nid = f:id()\nid_str = string.format(\"%.0f\", id)\nprint (\"Flow ID: \" .. id_str ..\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file extension\nDESCRIPTION: This Suricata rule example shows how to use the `fileext` keyword to match a specific file extension. It alerts if a file with the extension \".pdf\" is observed in network traffic.  `fileext` assumes `nocase` by default and doesn't allow partial matches.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nfileext:\"pdf\";\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: vlan.id equal to 300\nDESCRIPTION: This Suricata rule example demonstrates how to configure a rule that will alert if any VLAN ID is equal to 300.  It uses the `vlan.id` keyword with the value `300`. The rule checks all VLAN layers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"Vlan ID is equal to 300\"; vlan.id:300; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Flags using Bitwise AND in Suricata\nDESCRIPTION: This example illustrates how to match specific bits within the WebSocket flags using a bitwise AND operation.  `websocket.flags` uses an unsigned 8-bits integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.flags:&0x40=0x40;\n```\n\n----------------------------------------\n\nTITLE: StreamSlice Definition (Rust)\nDESCRIPTION: This code snippet defines the `StreamSlice` struct in Rust, which contains the input data to the parser and other stream-related data relevant to parsing. It is an important part of the AppLayer API.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub struct StreamSlice {\n    /// ss to use for app layer processing.\n    pub ss: *mut StreamSegment,\n    /// flow this is associated with.\n    pub flow: *mut Flow,\n    /// AL proto structure.\n    pub al: Option<AppLayerProto>,\n    /// pointer to start of current segment.\n    pub cur: *const u8,\n    /// current inspection offset.\n    pub cur_i: i64,\n    /// end of buffer.\n    pub end: *const u8,\n    /// end offset.\n    pub end_i: i64,\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving JA3S String for Detection in Lua\nDESCRIPTION: This code demonstrates retrieving the JA3S string for detection in Suricata, showcasing a function call that retrieves the string and handles nil values as well as a placeholder comment for writing detection logic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_34\n\nLANGUAGE: lua\nCODE:\n```\nfunction match (args)\n  str = Ja3SGetString()\n  if str == nil then\n    return 0\n  end\n\n  // matching code\n\n  return 0\nend\n```\n\n----------------------------------------\n\nTITLE: Negating DNS RRtype Value in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to negate matching a specific rrtype value in the DNS message using the `dns.rrtype` keyword in a Suricata rule.  The `!` character negates the match. The rrtype is an unsigned 16-bit integer representing the resource record type.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.rrtype:!0;\n```\n\n----------------------------------------\n\nTITLE: Matching Kerberos Error Code in Suricata\nDESCRIPTION: This example illustrates how to match Kerberos error messages based on their error code using the `krb5_err_code` keyword in Suricata rules.  The error code should be an integer as defined in RFC4120 section 7.5.9.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/kerberos-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert krb5 any any -> any any (msg:\"Kerberos 5 error C_PRINCIPAL_UNKNOWN\"; krb5_err_code:6; sid:6; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Building Out-of-Tree: Compile Application\nDESCRIPTION: This snippet demonstrates how to build the custom application against the installed Suricata library. It utilizes a Makefile.example and requires that libsuricata-config is in the PATH.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/custom/README.md#_snippet_3\n\nLANGUAGE: Makefile\nCODE:\n```\nmake -f Makefile.example\n```\n\n----------------------------------------\n\nTITLE: HTTP Event Example (Dump All Headers)\nDESCRIPTION: This example demonstrates an 'http' event in Suricata's Eve JSON output with the 'dump-all-headers' option set to \"both\". It includes all standard and extended logging fields, as well as the 'request_headers' field, which contains an array of objects, each representing an HTTP request header with its name and value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"http\": {\n      \"hostname\": \"test.co.uk\",\n      \"url\":\"\\/test\\/file.json\",\n      \"http_user_agent\": \"<User-Agent>\",\n      \"http_content_type\": \"application\\/json\",\n      \"http_refer\": \"http:\\/\\/www.test.com\\/\",\n      \"http_method\": \"GET\",\n      \"protocol\": \"HTTP\\/1.1\",\n      \"status\":\"200\",\n      \"length\":310,\n      \"request_headers\": [\n          {\n              \"name\": \"User-Agent\",\n              \"value\": \"Wget/1.13.4 (linux-gnu)\"\n          },\n          {\n              \"name\": \"Accept\",\n              \"value\": \"*/*\"\n          }\n\n```\n\n----------------------------------------\n\nTITLE: Matching SIP To Header in Suricata Rules\nDESCRIPTION: This snippet illustrates how to match the SIP To header in a Suricata rule. The `sip.to` keyword is used to inspect the To header field. The `content` option should contain the value of the To header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.to; content:\"user\"\n```\n\n----------------------------------------\n\nTITLE: Getting PCAP Packet Number in Lua\nDESCRIPTION: Retrieves the packet number when reading from a PCAP file. This is useful for debugging and correlating events with PCAP data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_10\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\nprint p:pcap_cnt()\n```\n\n----------------------------------------\n\nTITLE: DNP3 Function Code Matching with dnp3_func\nDESCRIPTION: This keyword allows matching on the application function code in DNP3 requests and responses. It accepts either an integer value (0-255) or a symbolic name representing the function code (e.g., confirm, read, write). The keyword is used to identify specific DNP3 operations within network traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dnp3-keywords.rst#_snippet_0\n\nLANGUAGE: None\nCODE:\n```\ndnp3_func:<value>;\n```\n\n----------------------------------------\n\nTITLE: Threshold Rule Example (both type)\nDESCRIPTION: This example demonstrates the 'both' type, combining 'threshold' and 'limit' to control alert generation. It generates at most one alert every 6 minutes if there have been 5 or more occurrences of \"SIP2.0 401 Unauthorized\" responses. It tracks by source IP, with a count of 5 and a period of 360 seconds.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/thresholding.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tcp $HOME_NET 5060 -> $EXTERNAL_NET any (msg:\"ET VOIP Multiple Unauthorized SIP Responses TCP\";\n  flow:established,from_server; content:\"SIP/2.0 401 Unauthorized\"; depth:24;\n  :example-rule-emphasis:`threshold: type both, track by_src, count 5, seconds 360;`\n  reference:url,doc.emergingthreats.net/2003194; classtype:attempted-dos; sid:2003194; rev:6;)\n```\n\n----------------------------------------\n\nTITLE: DNS Request Logging Format (Suricata 8.0)\nDESCRIPTION: This JSON snippet shows the updated DNS request logging format in Suricata 8.0. The type is now 'request', and queries are logged within a 'queries' array. Version 3 is added, with new fields like flags, rd, opcode and rcode. The format of the queries array is also described.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"dns\",\n  \"dns\": {\n    \"version\": 3,\n    \"type\": \"request\",\n    \"tx_id\": 0,\n    \"id\": 0,\n    \"flags\": \"100\",\n    \"rd\": true,\n    \"opcode\": 0,\n    \"rcode\": \"NOERROR\",\n    \"queries\": [\n      {\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"A\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Absent Example\nDESCRIPTION: This example demonstrates the usage of the 'absent' keyword in Suricata rules, checking for the absence of a sticky buffer (http.referer). It includes two scenarios: checking only for the absent buffer and checking for the absent buffer or the negated content.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_4\n\nLANGUAGE: suricata\nCODE:\n```\nalert http any any -> any any (msg:\"HTTP request without referer\";  http.referer; absent; sid:1; rev:1;)\n```\n\nLANGUAGE: suricata\nCODE:\n```\nalert http any any -> any any (msg:\"HTTP request without referer\";  http.referer; absent: or_else; content: !\"abc\"; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Docker/Podman Capabilities for Suricata\nDESCRIPTION: These capabilities are required for Suricata to function correctly within Docker or Podman containers. They grant Suricata the necessary permissions to manage network interfaces and capture network traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n--cap-add=net_admin --cap-add=net_raw --cap-add=sys_nice\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for JA3 Logging in Lua\nDESCRIPTION: This code demonstrates the proper initialization of the 'needs' table for JA3 (TLS fingerprinting) logging, setting the 'protocol' to 'tls' so data becomes available for the Lua script.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_27\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"protocol\"] = \"tls\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Suricata log directory\nDESCRIPTION: This command creates a directory for storing Suricata log files. It requires root privileges and is typically located in /var/log/suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir /var/log/suricata\n```\n\n----------------------------------------\n\nTITLE: Defining a Suricata Rule with Bypass Keyword\nDESCRIPTION: This snippet shows how to define a Suricata rule with the `bypass` keyword. When this rule is triggered, subsequent packets of the flow are automatically dropped or passed based on inline configuration, without further analysis by Suricata. This reduces CPU cycles by offloading flow handling to hardware.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_15\n\nLANGUAGE: suricata\nCODE:\n```\ndrop tcp any 443 <> any any (msg: \"SURICATA Test rule\"; bypass; sid:1000001; rev:2;)\n```\n\n----------------------------------------\n\nTITLE: Frame Registration in Telnet Parser (Rust)\nDESCRIPTION: This example shows how to use the Frame API directly to register telnet frames in Rust, including how to handle cases where the frame length is initially unknown.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet mut al = sl.al;\n    if al.is_none() {\n        al = Some(AppLayerProto::new(AppProto::Telnet));\n    }\n\n    let mut al = al.unwrap();\n    let flow = sl.flow;\n\n    /* request frames registration with unknown length */\n    al.register_frame(flow, sl, 0, -1, FrameType::Request);\n\n    if let Some(resp) = Response::parse(sl) {\n        sl.al = Some(al);\n        return Some(resp);\n    }\n\n    sl.al = Some(al);\n\n    None\n```\n\n----------------------------------------\n\nTITLE: Configuring napi-defer-hard-irq in suricata.yaml\nDESCRIPTION: This snippet shows how to configure napi-defer-hard-irq in the suricata.yaml configuration file.  This indicates the number of queue scan attempts before exiting to interrupt context.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  napi-defer-hard-irq: 2\n```\n\n----------------------------------------\n\nTITLE: Iptables: Traffic between eth0 and eth1 to NFQUEUE\nDESCRIPTION: These iptables rules forward traffic between interfaces eth0 and eth1 to the NFQUEUE. This is useful for inspecting traffic passing between two networks connected to the same machine. It assumes the default queue number (0) is being used by Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I FORWARD -i eth0 -o eth1 -j NFQUEUE\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I FORWARD -i eth1 -o eth0 -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Configuring Hardware Bypass Ports\nDESCRIPTION: This YAML snippet configures hardware bypass with specific port pairings. It specifies that ports 0 and 1 are paired, and ports 2 and 3 are paired.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_12\n\nLANGUAGE: YAML\nCODE:\n```\nnapatech:\n      hardware-bypass: true\n      ports[0-1,2-3]\n```\n\n----------------------------------------\n\nTITLE: Engine Analysis: Decoder Events Only Rule\nDESCRIPTION: This JSON snippet represents the Engine Analysis report for a Suricata rule that detects duplicated IPv6 Hop-By-Hop Options extension headers. It details the rule's ID, message, requirements, type (de_only), and packet engine configurations.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"raw\": \"alert pkthdr any any -> any any (msg:\\\"SURICATA IPv6 duplicated Hop-By-Hop Options extension header\\\"; decode-event:ipv6.exthdr_dupl_hh; classtype:protocol-command-decode; sid:1101;)\",\n  \"id\": 1101,\n  \"gid\": 1,\n  \"rev\": 0,\n  \"msg\": \"SURICATA IPv6 duplicated Hop-By-Hop Options extension header\",\n  \"app_proto\": \"unknown\",\n  \"requirements\": [\n    \"engine_event\"\n  ],\n  \"type\": \"de_only\",\n  \"flags\": [\n    \"src_any\",\n    \"dst_any\",\n    \"sp_any\",\n    \"dp_any\",\n    \"toserver\",\n    \"toclient\"\n  ],\n  \"pkt_engines\": [\n    {\n      \"name\": \"packet\",\n      \"is_mpm\": false\n    }\n  ],\n  \"frame_engines\": [],\n  \"lists\": {\n    \"packet\": {\n      \"matches\": [\n        {\n          \"name\": \"decode-event\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PF_RING Plugin in suricata.yaml\nDESCRIPTION: This YAML snippet shows how to configure the PF_RING plugin in the `suricata.yaml` configuration file. It specifies the path to the PF_RING plugin library.\nSOURCE: https://github.com/oisf/suricata/blob/master/plugins/pfring/README.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nplugins:\n  - /usr/local/lib/suricata/pfring.so\n```\n\n----------------------------------------\n\nTITLE: HTP Request Data Handler Example in C\nDESCRIPTION: This code provides an example of an application layer parser callback function in C, specifically for handling HTTP request data. It takes similar arguments as defined by `AppLayerParserFPtr` (flow, state, parser state, input buffer, length, local data, and flags) and returns an `AppLayerResult`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/parser.rst#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nstatic AppLayerResult HTPHandleRequestData(Flow *f, void *htp_state,\n            AppLayerParserState *pstate,\n            const uint8_t *input, uint32_t input_len,\n            void *local_data, const uint8_t flags);\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Affinity for Suricata Threads\nDESCRIPTION: This configuration snippet shows how to disable Suricata's automatic CPU affinity setting. Disabling this option allows the operating system to manage thread allocation to CPU cores.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_24\n\nLANGUAGE: yaml\nCODE:\n```\nset-cpu-affinity: no\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP2 Frame Type\nDESCRIPTION: This keyword allows matching on the type of frame present in an HTTP2 transaction. It's used to identify specific frame types like GOAWAY.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http2-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nhttp2.frametype:GOAWAY;\n```\n\n----------------------------------------\n\nTITLE: Registering a C Unit Test\nDESCRIPTION: This snippet shows how to register a unit test function with the Suricata testing framework using the `UtRegisterTest()` function.  This associates the test function with a name, allowing it to be invoked by the testing framework.  The arguments are the test name and the function pointer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-c.rst#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nUtRegisterTest(\"MyUnitTest\", MyUnitTest);\n```\n\n----------------------------------------\n\nTITLE: Iptables Rule: Forwarding all traffic to Suricata\nDESCRIPTION: This iptables rule inserts a rule in the FORWARD chain to send all forwarded traffic to the NFQUEUE. Suricata will then process this traffic according to its configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I FORWARD -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Verdict Field Example\nDESCRIPTION: This example shows the structure of the 'verdict' field within the Suricata Eve JSON format. The 'verdict' object provides information about the final action applied to a packet, considering all triggered signatures and other events. It includes fields for 'action' (alert, pass, drop), 'reject-target' (to_server, to_client, both), and 'reject' (an array of reject types).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"verdict\": {\n       \"action\": \"drop\",\n       \"reject-target\": \"to_client\",\n       \"reject\": \"[icmp-prohib]\"\n     }\n}\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Login Fail Counter Initialization\nDESCRIPTION: This example shows how to initialize a `flowint` counter (`loginfail`) when a login failure is detected for the first time in a stream. The counter is set to 1, and no alert is generated.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Start a login count\"; content:\"login failed\"; \\\n        flowint:loginfail, notset; flowint:loginfail, =, 1; noalert;)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Bittorrent DHT Announce Peer with Implied Port in JSON\nDESCRIPTION: This snippet illustrates the JSON for an 'announce_peer' request with an 'implied_port' parameter and the corresponding response. The request contains 'transaction_id', 'client_version', 'request_type', and 'request' including 'id', 'info_hash', 'token', 'implied_port', and 'port'. The response only includes the responder's 'id'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_42\n\nLANGUAGE: json\nCODE:\n```\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"7fe9\",\n    \"client_version\": \"4c540126\",\n    \"request_type\": \"announce_peer\",\n    \"request\": {\n      \"id\": \"51bc83f53417a62a40e8a48170cad369a13fef3c\",\n      \"info_hash\": \"19a6fcfcba6cc2c6d371eb754074d095adb5d291\",\n      \"token\": \"cacbef35\",\n      \"implied_port\": 1,\n      \"port\": 54892\n    }\n  }\n\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"7fe9\",\n    \"client_version\": \"4c54012f\",\n    \"response\": {\n      \"id\": \"19a66dece45e0288ab75d141e0255738a1ce8508\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Getting DNS recursion desired flag in Lua\nDESCRIPTION: This example demonstrates how to check the value of the recursion desired (RD) flag using the `recursion_desired()` method on the transaction object. It prints a message if the flag is set to true.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_9\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nif tx:recursion_desired() == true then\n    print (\"RECURSION DESIRED\")\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Unix Socket Communication Example\nDESCRIPTION: This demonstrates the JSON-based protocol used for communication with Suricata over the Unix socket. It shows the initial negotiation and example commands, including `iface-list`, `iface-stat`, `pcap-file` commands with the `SND` representing the sent message and `RCV` the received message.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/unix-socket.rst#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n# suricatasc\nSND: {\"version\": \"0.1\"}\nRCV: {\"return\": \"OK\"}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n>>> iface-list\nSND: {\"command\": \"iface-list\"}\nRCV: {\"message\": {\"count\": 1, \"ifaces\": [\"wlan0\"]}, \"return\": \"OK\"}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n>>> iface-stat wlan0\nSND: {\"command\": \"iface-stat\", \"arguments\": {\"iface\": \"wlan0\"}}\nRCV: {\"message\": {\"pkts\": 41508, \"drop\": 0, \"invalid-checksums\": 0}, \"return\": \"OK\"}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n>>> pcap-file /home/eric/git/oisf/benches/sandnet.pcap /tmp/bench\nSND: {\"command\": \"pcap-file\", \"arguments\": {\"output-dir\": \"/tmp/bench\", \"filename\": \"/home/eric/git/oisf/benches/sandnet.pcap\"}}\nRCV: {\"message\": \"Successfully added file to list\", \"return\": \"OK\"}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n>>> pcap-file-number\nSND: {\"command\": \"pcap-file-number\"}\nRCV: {\"message\": 1, \"return\": \"OK\"}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n>>> pcap-file-list\nSND: {\"command\": \"pcap-file-list\"}\nRCV: {\"message\": {\"count\": 1, \"files\": [\"/home/eric/git/oisf/benches/sandnet.pcap\"]}, \"return\": \"OK\"}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n>>> pcap-file-continuous /home/eric/git/oisf/benches /tmp/bench 0 true\nSND: {\"command\": \"pcap-file\", \"arguments\": {\"output-dir\": \"/tmp/bench\", \"filename\": \"/home/eric/git/oisf/benches/sandnet.pcap\", \"tenant\": 0, \"delete-when-done\": true}}\nRCV: {\"message\": \"Successfully added file to list\", \"return\": \"OK\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Address and Port Groups in Suricata.yaml\nDESCRIPTION: This snippet demonstrates how to define address and port groups in Suricata's YAML configuration file.  `address-groups` and `port-groups` are used to create reusable variables for IP addresses and port numbers, respectively. These groups are used in Suricata rules to represent network entities and improve rule readability.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nvars:\n  address-groups:\n\n    HOME_NET: \"[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]\"\n    EXTERNAL_NET: \"!$HOME_NET\"\n\n  port-groups:\n    HTTP_PORTS: \"80\"\n    SHELLCODE_PORTS: \"!80\"\n```\n\n----------------------------------------\n\nTITLE: Transaction Logging Condition Check in OutputTxLog - C\nDESCRIPTION: This C code snippet from suricata/src/output-tx.c shows how Suricata checks transaction progress against configured logging thresholds before logging an event. It compares `tx_progress_tc` and `tx_progress_ts` with `logger->tc_log_progress` and `logger->ts_log_progress` respectively. If transaction progress is less than the logging threshold, logging is skipped.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic TmEcode OutputTxLog(ThreadVars *tv, Packet *p, void *thread_data)\n{\n    .\n    .\n    .\n        if ((ts_eof && tc_eof) || last_pseudo) {\n            SCLogDebug(\"EOF, so log now\");\n        } else {\n            if (logger->LogCondition) {\n                int r = logger->LogCondition(tv, p, alstate, tx, tx_id);\n                if (r == FALSE) {\n                    SCLogDebug(\"conditions not met, not logging\");\n                    goto next_logger;\n                }\n            } else {\n                if (tx_progress_tc < logger->tc_log_progress) {\n                    SCLogDebug(\"progress not far enough, not logging\");\n                    goto next_logger;\n                }\n\n                if (tx_progress_ts < logger->ts_log_progress) {\n                    SCLogDebug(\"progress not far enough, not logging\");\n                    goto next_logger;\n                }\n            }\n         }\n    .\n    .\n    .\n}\n```\n\n----------------------------------------\n\nTITLE: DCERPC Request/Response Logging Example (JSON)\nDESCRIPTION: Demonstrates the JSON structure for logging DCERPC request/response pairs within an SMB context.  It details transaction ID, dialect, command, status, session ID, tree ID, and DCERPC-specific fields, including request/response types, opnum, stub data size, and call ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_34\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"id\": 4,\n    \"dialect\": \"unknown\",\n    \"command\": \"SMB2_COMMAND_IOCTL\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 4398046511201,\n    \"tree_id\": 0,\n    \"dcerpc\": {\n      \"request\": \"REQUEST\",\n      \"response\": \"RESPONSE\",\n      \"opnum\": 0,\n      \"req\": {\n        \"frag_cnt\": 1,\n        \"stub_data_size\": 136\n      },\n      \"res\": {\n        \"frag_cnt\": 1,\n        \"stub_data_size\": 8\n      },\n      \"call_id\": 2\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Example Packet Inspection and Logging in Lua\nDESCRIPTION: A complete example of a `match` function that retrieves packet data (payload, timestamp, IP addresses, ports, PCAP counter) and logs a notice if a specific HTTP request line is found in the payload.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_11\n\nLANGUAGE: Lua\nCODE:\n```\nfunction match (args)\n    p = packet.get()\n    payload = p:payload()\n    ts = p:timestring()\n\n    for line in payload:gmatch(\"([^\\r\\n]*)[\n]+\") do\n        if line == \"GET /index.html HTTP/1.0\" then\n            ipver, srcip, dstip, proto, sp, dp = p:tuple()\n            SCLogNotice(string.format(\"%s %s->%s %d->%d (pcap_cnt:%d) match! %s\", ts, srcip, dstip, sp, dp, p:pcap_cnt(), line));\n            return 1\n        end\n    end\n\n    return 0\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring eBPF Filter in Suricata (YAML)\nDESCRIPTION: This YAML snippet configures Suricata to use an eBPF filter. It specifies the interface, threads, cluster ID, cluster type, and the path to the eBPF filter file within the af-packet section of `suricata.yaml`. This sets up the VLAN filter.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\n  - interface: eth3\n    threads: 16\n    cluster-id: 97\n    cluster-type: cluster_flow # choose any type suitable\n    defrag: yes\n    # eBPF file containing a 'filter' function that will be inserted into the\n    # kernel and used as load balancing function\n    ebpf-filter-file:  /usr/libexec/suricata/ebpf/vlan_filter.bpf\n    ring-size: 200000\n```\n\n----------------------------------------\n\nTITLE: Import Base64 Library in Lua\nDESCRIPTION: This code snippet imports the `suricata.base64` library into a Lua script.  The library provides functions for encoding and decoding strings using Base64.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/base64.rst#_snippet_0\n\nLANGUAGE: Lua\nCODE:\n```\nlocal base64 = require(\"suricata.base64\")\n```\n\n----------------------------------------\n\nTITLE: Copying eBPF Load Balancing Filter (Bash)\nDESCRIPTION: This bash command copies the compiled eBPF load balancing filter to the Suricata eBPF directory so Suricata can load it. The eBPF program needs to be built and copied before it can be used.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n cp ebpf/lb.bpf /usr/libexec/suricata/ebpf/\n```\n\n----------------------------------------\n\nTITLE: Checking NIC Statistics with ethtool\nDESCRIPTION: This command uses ethtool to retrieve network interface card (NIC) statistics for a specific interface (em2 in this example). The output provides information about packets transmitted and received, errors, and other relevant metrics.  It can be used to identify packet loss at the NIC level.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/statistics.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# ethtool -S em2\n```\n\n----------------------------------------\n\nTITLE: Checking TCP Window Size with window Keyword in Suricata\nDESCRIPTION: This example shows how to use the `window` keyword in a Suricata rule to check for a specific TCP window size. The window size is checked against the value of 55808 in the example rule. This allows detecting unusual or malicious traffic based on abnormal window sizes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"GPL DELETED typot trojan traffic\"; flow:stateless; flags:S,12; :example-rule-emphasis:`window:55808;` reference:mcafee,100406; classtype:trojan-activity; sid:2182; rev:8;)\n```\n\n----------------------------------------\n\nTITLE: Run Suricata in NFQ mode\nDESCRIPTION: This command runs Suricata in NFQ mode, specifying the queue number to use. The queue number corresponds to the NFQUEUE target in the iptables rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata -c /etc/suricata/suricata.yaml -q 0\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Device Type in Suricata Rules\nDESCRIPTION: The `enip.device_type` keyword is used to match on the device type in the identity message. It uses a 16-bit unsigned integer as its value. The device type allows for identifying broad categories of devices.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.device_type:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.device_type:>1;\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Response Line in Suricata Rules\nDESCRIPTION: This snippet illustrates how to match the entire SIP response line in a Suricata rule. The `sip.response_line` keyword inspects the complete response line. The `content` option can match a partial or full response line.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.response_line; content:\"SIP/2.0 100 OK\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Suricata 'msg' Keyword\nDESCRIPTION: This code snippet shows the basic syntax for defining a 'msg' keyword within a Suricata rule. The 'msg' keyword provides contextual information about the signature and possible alerts. The text within the quotes is the message that will be displayed in alerts.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nmsg: \"some description\";\n```\n\n----------------------------------------\n\nTITLE: Formatting branch commits\nDESCRIPTION: This bash script formats every commit in the branch off master and rewrites history using the existing commit metadata. A new version of the branch is created first.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# In a new version of your pull request:\n$ scripts/clang-format.sh rewrite-branch\n```\n\n----------------------------------------\n\nTITLE: Iptables: TCP traffic to NFQUEUE\nDESCRIPTION: These iptables rules forward all incoming and outgoing TCP traffic to the NFQUEUE.  This allows Suricata to inspect only TCP traffic. It assumes the default queue number (0) is being used by Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I INPUT -p tcp  -j NFQUEUE\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I OUTPUT -p tcp -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Defining a Requires Keyword\nDESCRIPTION: This code demonstrates the syntax for the 'requires' keyword. It allows a rule to require specific Suricata features to be enabled, specific keywords to be available, or the Suricata version to match an expression. Rules that don't meet the requirements will be ignored.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nrequires: feature geoip, version >= 7.0.0, keyword foobar\n```\n\n----------------------------------------\n\nTITLE: Displaying GPL License Notice in Interactive Programs\nDESCRIPTION: This snippet provides a template for displaying a short notice within an interactive program indicating it comes with ABSOLUTELY NO WARRANTY and is licensed under certain conditions according to the GNU General Public License. It helps inform users of their rights and provides a way to access detailed license information.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/licenses/gnu-gpl-v2.0.rst#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nGnomovision version 69, Copyright (C) year name of author\nGnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n```\n\n----------------------------------------\n\nTITLE: Matching RFB Security Result (Unknown)\nDESCRIPTION: This snippet demonstrates how to use the 'rfb.secresult' keyword to match the RFB security result. 'rfb.secresult' uses an unsigned 32-bit integer.  Example shows direct string match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rfb-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nrfb.secresult: unknown;\n```\n\n----------------------------------------\n\nTITLE: SMB Pipe Open Logging Example (JSON)\nDESCRIPTION: This snippet shows the JSON format for logging an SMB pipe open event.  Key fields include the command, status, session ID, tree ID, filename, disposition, access type, timestamps, and a file GUID. The 'id' field represents an internal transaction ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_29\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"id\": 1,\n      \"dialect\": \"unknown\",\n      \"command\": \"SMB2_COMMAND_CREATE\",\n      \"status\": \"STATUS_SUCCESS\",\n      \"status_code\": \"0x0\",\n      \"session_id\": 4398046511201,\n      \"tree_id\": 1,\n      \"filename\": \"atsvc\",\n      \"disposition\": \"FILE_OPEN\",\n      \"access\": \"normal\",\n      \"created\": 0,\n      \"accessed\": 0,\n      \"modified\": 0,\n      \"changed\": 0,\n      \"size\": 0,\n      \"fuid\": \"0000004d-0000-0000-0005-0000ffffffff\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Installing libbpf Development Library (Bash)\nDESCRIPTION: This code snippet shows how to install the `libbpf-dev` library, which is used for interacting with eBPF and XDP, on Debian/Ubuntu systems using `apt`.  This is a required dependency for eBPF functionality in Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n  sudo apt install libbpf-dev\n```\n\n----------------------------------------\n\nTITLE: Retrieving Interface Statistics - JSON\nDESCRIPTION: This snippet shows the JSON output from the `suricatasc` command to retrieve interface statistics.  It includes the number of packets, dropped packets, bypassed packets, and invalid checksums. It is obtained using `suricatasc -c \"iface-stat enp94s0np0\" | jq`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_23\n\nLANGUAGE: JSON\nCODE:\n```\n {\n   \"message\": {\n     \"pkts\": 56529854964,\n     \"drop\": 932328611,\n     \"bypassed\": 1569467248,\n     \"invalid-checksums\": 0\n   },\n   \"return\": \"OK\"\n }\n```\n\n----------------------------------------\n\nTITLE: urilen Keyword Example\nDESCRIPTION: This example demonstrates the difference in interpreting the `urilen` keyword ranges between Snort and Suricata.  Snort includes the boundary values while Suricata excludes them. This snippet clarifies the inclusive/exclusive range interpretation for `urilen` in both systems.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nurilen:2<>10\n```\n\n----------------------------------------\n\nTITLE: Initializing Lua Output Script - Lua\nDESCRIPTION: This code snippet shows the basic structure of a Suricata Lua output script, including the `init`, `setup`, `log`, and `deinit` hook functions. The `init` function defines the required protocol for the script to hook into. The example requires the HTTP protocol.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/lua-output.rst#_snippet_0\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"protocol\"] = \"http\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Output for File Metadata\nDESCRIPTION: This YAML snippet configures Suricata to output file metadata in JSON format. It specifies the file type as 'regular' and configures the `types` section to force logging of MD5 checksums.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\n    outputs:\n      - eve-log:\n        enabled: yes\n        filetype: regular #regular|syslog|unix_dgram|unix_stream|redis\n        filename: eve.json\n        types:\n          - files:\n            force-magic: no   # force logging magic on all logged files\n            # force logging of checksums, available hash functions are md5,\n            # sha1 and sha256\n            #force-hash: [md5]\n```\n\n----------------------------------------\n\nTITLE: Enabling WinDivert during Suricata Configuration\nDESCRIPTION: These flags are used when configuring Suricata to enable WinDivert support during the compilation process.  `--enable-windivert=yes` enables WinDivert. `--with-windivert-include` specifies the directory containing WinDivert header files. `--with-windivert-libraries` specifies the directory containing WinDivert library files.  Ensure the correct paths are provided for successful compilation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-windows.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n--enable-windivert=yes --with-windivert-include=<include-dir> --with-windivert-libraries=<libraries-dir>\n```\n\n----------------------------------------\n\nTITLE: Formatting unstaged changes\nDESCRIPTION: This bash script forces formatting of unstaged changes along with the changes in staging using git clang-format.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ git clang-format --force\n# Or with script:\n$ scripts/clang-format.sh cached --force\n```\n\n----------------------------------------\n\nTITLE: Building In-Tree\nDESCRIPTION: This snippet shows how to build the custom library example within the Suricata build tree. It relies on the generated Makefile to compile the application.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/custom/README.md#_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Iptables Rules: Multiple Networks\nDESCRIPTION: These iptables rules are for forwarding traffic between two interfaces (eth0 and eth1) to the NFQUEUE. The `-i` option specifies the input interface, and the `-o` option specifies the output interface.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I FORWARD -i eth0 -o eth1 -j NFQUEUE\nsudo iptables -I FORWARD -i eth1 -o eth0 -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Checking if Landlock is Running\nDESCRIPTION: This shell command checks if Landlock is running by searching the kernel message buffer (`dmesg`) or the system journal (`journalctl`) for entries containing the word \"landlock\". It provides a way to verify that Landlock has been successfully activated at boot.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/landlock.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsudo dmesg | grep landlock || journalctl -kg landlock\n```\n\n----------------------------------------\n\nTITLE: urilen Keyword with Raw Buffer\nDESCRIPTION: This shows how to apply the `urilen` keyword to the raw buffer in Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nurilen:>20,raw;\n```\n\n----------------------------------------\n\nTITLE: Configure Suricata with Profiling\nDESCRIPTION: This snippet shows the command to configure Suricata with packet profiling enabled. The `--enable-profiling` option instructs the configure script to include profiling code in the build. This is a prerequisite for using the packet profiling features.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-profiling.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --enable-profiling\n```\n\n----------------------------------------\n\nTITLE: ICMP Broadscan Smurf Scanner Rule - Suricata\nDESCRIPTION: This Suricata rule detects a broadscan Smurf scanner by checking for specific ICMP characteristics. It looks for ICMP packets with a data size of 4 bytes, an ICMP ID of 0, an ICMP sequence number of 0, and an ICMP type of 8 (Echo Request). These characteristics are often associated with Smurf attacks, a type of distributed denial-of-service (DDoS) attack. The rule assigns a message, classification, signature ID (SID), and revision number.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_24\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert icmp $EXTERNAL_NET any -> $HOME_NET any (msg:\"GPL SCAN Broadscan Smurf Scanner\"; dsize:4; :example-rule-emphasis:`icmp_id:0;` icmp_seq:0; itype:8; classtype:attempted-recon; sid:2100478; rev:4;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: SMB file.name keyword usage\nDESCRIPTION: This Suricata rule demonstrates the use of the `file.name` keyword to match specific filenames within SMB traffic. It searches for the filename \"file.txt\" within the SMB application layer data. The rule also includes a message, classtype, SID, and revision for rule management.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smb-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smb any any -> any any (msg:\"SMB file.name usage\"; :example-rule-options:`file.name; content:\"file.txt\";` classtype:bad-unknown; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Setting Initial Counters\nDESCRIPTION: This example demonstrates setting initial values for two `flowint` counters, `myvar` and `maxvar`, to 1 and 6 respectively, when a \"GET\" request is detected. The `notset` modifier ensures the counters are only initialized once per flow.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Setting a flowint counter\"; content:\"GET\"; \\\n        flowint:myvar, notset; flowint:maxvar,notset;                           \\\n        flowint:myvar,=,1; flowint: maxvar,=,6;)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Bittorrent DHT Announce Peer Request/Response in JSON\nDESCRIPTION: This snippet showcases the JSON structure for a Bittorrent DHT 'announce_peer' request and response. The request consists of 'transaction_id', 'request_type', and 'request' containing 'id', 'info_hash', 'token', and 'port'. The response only contains the 'id'. This interaction is used to announce that a peer is serving a specific info_hash.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_41\n\nLANGUAGE: json\nCODE:\n```\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"aa\",\n    \"request_type\": \"announce_peer\",\n    \"request\": {\n      \"id\": \"abcdefghij0123456789\",\n      \"info_hash\": \"mnopqrstuvwxyz123456\",\n      \"token\": \"aoeusnth\",\n      \"port\": 6881\n    }\n  }\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"aa\",\n    \"response\": {\n      \"id\": \"mnopqrstuvwxyz123456\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: DHCP Transaction Completion State - Rust\nDESCRIPTION: This Rust code shows how the transaction completion state is set for DHCP. Both `tx_comp_st_ts` and `tx_comp_st_tc` are set to 1, indicating that the transaction is considered complete in both directions when the state reaches 1. This represents a simple transaction model.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\ntx_comp_st_ts: 1,\ntx_comp_st_tc: 1,\n```\n\n----------------------------------------\n\nTITLE: Suricata Relative Isdataat Example\nDESCRIPTION: This Suricata rule demonstrates using 'isdataat' to check for '.exe' at the end of a URI. Snort requires a PCRE for equivalent functionality in the normalized URI buffer due to differences in 'isdataat' behavior.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\".EXE File Download Request\"; flow:established,to_server; content:\"GET\"; http_method; content:\".exe\"; http_uri; isdataat:!1,relative; priority:3; sid:18332111;)\n```\n\n----------------------------------------\n\nTITLE: Tshark command to analyze traffic direction\nDESCRIPTION: This command uses tshark to capture and analyze network traffic on a specified interface for a duration of 10 seconds. It provides a summary of IP conversations, which helps identify unidirectional traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/analysis.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo tshark -i $INTERFACE -q -z conv,ip -a duration:10\n```\n\n----------------------------------------\n\nTITLE: Capturing with AF_PACKET and Setting Flow Memcap\nDESCRIPTION: This command demonstrates using `AF_PACKET` for capturing network traffic and overriding the default flow memory cap setting.  The `--af-packet` flag enables the AF_PACKET capture method, and `--set flow.memcap=1gb` sets the flow memory cap to 1GB. Requires a suricata installation with AF_PACKET support and appropriate permissions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/manpages/suricata.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --af-packet --set flow.memcap=1gb\n```\n\n----------------------------------------\n\nTITLE: Matching RFB Security Result\nDESCRIPTION: This snippet demonstrates how to use the 'rfb.secresult' keyword to match the RFB security result. 'rfb.secresult' uses an unsigned 32-bit integer. Example shows direct string match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rfb-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nrfb.secresult: ok;\n```\n\n----------------------------------------\n\nTITLE: Updating Rules after modifying enable/disable.conf\nDESCRIPTION: This command must be run after modifying `/etc/suricata/enable.conf` or `/etc/suricata/disable.conf` to apply the changes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata-update\n```\n\n----------------------------------------\n\nTITLE: Defining IP and Port Variables in Snort.conf\nDESCRIPTION: This snippet shows how to define IP and port variables in a Snort configuration file. `ipvar` is used for IP address ranges, and `portvar` defines port lists for use in rules. These variables simplify rule writing and management by providing a central place to define network parameters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nipvar HOME_NET any\nipvar EXTERNAL_NET any\n...\nportvar HTTP_PORTS [80,81,311,591,593,901,1220,1414,1741,1830,2301,2381,2809,3128,3702,4343,4848,5250,7001,7145,7510,7777,7779,8000,8008,8014,8028,8080,8088,8090,8118,8123,8180,8181,8243,8280,8800,8888,8899,9000,9080,9090,9091,9443,9999,11371,55555]\nportvar SHELLCODE_PORTS !80\n...\n```\n\n----------------------------------------\n\nTITLE: Logging RDP initial request, response and connect request\nDESCRIPTION: This example demonstrates logging of RDP events for initial request, initial response and connect request. The rdp events contain fields like tx_id, event_type, cookie, client information and channels. The 'client' object encapsulates details about the RDP client, such as version, desktop dimensions, color depth, keyboard layout, and capabilities. The 'channels' array lists the virtual channels supported by the client.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_49\n\nLANGUAGE: json\nCODE:\n```\n  \"rdp\": {\n    \"tx_id\": 0,\n    \"event_type\": \"initial_request\",\n    \"cookie\": \"A70067\"\n  }\n\n  \"rdp\": {\n    \"tx_id\": 1,\n    \"event_type\": \"initial_response\"\n  }\n\n  \"rdp\": {\n    \"tx_id\": 2,\n    \"event_type\": \"connect_request\",\n    \"client\": {\n      \"version\": \"v5\",\n      \"desktop_width\": 1152,\n      \"desktop_height\": 864,\n      \"color_depth\": 15,\n      \"keyboard_layout\": \"en-US\",\n      \"build\": \"Windows XP\",\n      \"client_name\": \"ISD2-KM84178\",\n      \"keyboard_type\": \"enhanced\",\n      \"function_keys\": 12,\n      \"product_id\": 1,\n      \"capabilities\": [\n        \"support_errinfo_pdf\"\n      ],\n      \"id\": \"55274-OEM-0011903-00107\"\n    },\n    \"channels\": [\n      \"rdpdr\",\n      \"cliprdr\",\n      \"rdpsnd\"\n    ]\n  }\n\n  \"rdp\": {\n    \"tx_id\": 3,\n    \"event_type\": \"connect_response\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Registering Tenants via Unix Socket\nDESCRIPTION: These commands show how to register tenants via the Suricata Unix socket. The `register-tenant` command takes the tenant ID and the path to the tenant's YAML configuration file as arguments. This allows for dynamic registration of tenants.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nregister-tenant 1 tenant-1.yaml\nregister-tenant 2 tenant-2.yaml\nregister-tenant 3 tenant-3.yaml\nregister-tenant 5 tenant-5.yaml\nregister-tenant 7 tenant-7.yaml\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Bitmask Matching (Inequality)\nDESCRIPTION: This code snippet demonstrates how to match an integer value based on a bitmask and inequality.  `bsize:&0xc0!=0;` applies a bitwise AND operation between `bsize` and `0xc0`.  The rule matches if the result is not equal to 0.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:&0xc0!=0;\n```\n\n----------------------------------------\n\nTITLE: Suricata af-packet Interface Configuration\nDESCRIPTION: Configures the `af-packet` section in `suricata.yaml` to specify the network interface Suricata should monitor. This example shows a basic configuration using `cluster_flow` cluster type and enabling defrag and tpacket-v3.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\naf-packet:\n    - interface: enp1s0\n      cluster-id: 99\n      cluster-type: cluster_flow\n      defrag: yes\n      tpacket-v3: yes\n```\n\n----------------------------------------\n\nTITLE: Snort http_cookie Buffer Contents\nDESCRIPTION: This example illustrates the content of the Snort `http_cookie` buffer when multiple Cookie headers are present in a request, assuming enable_cookie is set. The values are concatenated without any separator.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nmonsterelmo\n```\n\n----------------------------------------\n\nTITLE: Braces example 3\nDESCRIPTION: Example of proper brace placement for else statements.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nif (this) {\n    DoThis();\n} else {\n    DoThat();\n}\n```\n\n----------------------------------------\n\nTITLE: Running Suricata Unit Tests\nDESCRIPTION: This snippet shows how to run the Suricata unit tests. The tests are only available if Suricata was configured and built with the ``--enable-unittests`` option. An output directory must be supplied with the `-l` option.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/command-line-options.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata -u\n```\n\n----------------------------------------\n\nTITLE: Retrieving SSH Client Software Version in Lua\nDESCRIPTION: This code snippet demonstrates how to retrieve the SSH client software version using the `SshGetClientSoftwareVersion()` function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_39\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    software = SshGetClientSoftwareVersion()\n    if software == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Copyright Disclaimer Template\nDESCRIPTION: This snippet provides a template for a copyright disclaimer that an employer or school can sign to disclaim all copyright interest in a program.  This ensures that the author's rights are clearly defined and that the program can be freely distributed under the GPL.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/licenses/gnu-gpl-v2.0.rst#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nYoyodyne, Inc., hereby disclaims all copyright interest in the program\n`Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n<signature of Ty Coon>, 1 April 1989\nTy Coon, President of Vice\n```\n\n----------------------------------------\n\nTITLE: Example Suricata Commit Message\nDESCRIPTION: This snippet provides an example of a properly formatted commit message for Suricata. It includes a short subject line, a description wrapped at ~72 characters, and a reference to a bug ticket.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/code-submission-process.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\npcap/file: normalize file timestamps\n\nNormalize the timestamps that are too far in the past to epoch.\n\nBug: #6240.\n```\n\n----------------------------------------\n\nTITLE: PGSQL Event Example: Rejected SSL Handshake\nDESCRIPTION: This example illustrates a PGSQL event log entry for a rejected SSL handshake.  It demonstrates logging a failed SSL request, including the request message and response indicating that the handshake was not accepted.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_68\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"timestamp\": \"2021-11-24T16:56:19.435242+0000\",\n    \"flow_id\": 1960113262002448,\n    \"pcap_cnt\": 21,\n    \"event_type\": \"pgsql\",\n    \"src_ip\": \"172.18.0.1\",\n    \"src_port\": 54408,\n    \"dest_ip\": \"172.18.0.2\",\n    \"dest_port\": 5432,\n    \"proto\": \"TCP\",\n    \"pgsql\": {\n      \"tx_id\": 1,\n      \"request\": {\n        \"message\": \"SSL Request\"\n      },\n      \"response\": {\n        \"accepted\": false\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT UNSUBACK (JSON)\nDESCRIPTION: This example shows how MQTT UNSUBACK messages are logged in JSON format. It provides information related to the unsubscription acknowledgement, which consists of qos, retain, dup, and the message_id.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_61\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"unsuback\": {\n    \"qos\": 0,\n    \"retain\": false,\n    \"dup\": false,\n    \"message_id\": 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with NFQ\nDESCRIPTION: This command starts Suricata with the NFQ mode enabled, specifying the queue number to use. The `-c` option specifies the path to the Suricata configuration file, and the `-q` option specifies the queue number.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata -c /etc/suricata/suricata.yaml -q 0\n```\n\n----------------------------------------\n\nTITLE: Getting flow timestamp as ISO8601 string in Lua\nDESCRIPTION: This snippet retrieves the timestamp of the first packet in the flow as a string in the format `2015-10-06T15:16:43.136733+0000`. This format is used by EVE outputs. It returns a string representing the timestamp in ISO8601 format.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_4\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\nprint f:timestring_iso8601()\n```\n\n----------------------------------------\n\nTITLE: Building Out-of-Tree: make install-library and install-headers\nDESCRIPTION: These snippets show how to build the Suricata library and install it along with its headers, which is a prerequisite for building against the library in a standalone application. These are executed within the Suricata source directory.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/simple/README.md#_snippet_1\n\nLANGUAGE: makefile\nCODE:\n```\nmake install-library\n```\n\nLANGUAGE: makefile\nCODE:\n```\nmake install-headers\n```\n\n----------------------------------------\n\nTITLE: Xbits Keyword Syntax\nDESCRIPTION: Demonstrates the syntax for using the `xbits` keyword in Suricata rules. It shows how to set, unset, check if set, toggle bits, and specify the tracking method (ip_src, ip_dst, ip_pair) and expiration time. The expiration time parameter `seconds` indicates how long the bit is set for.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/xbits.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nxbits:<set|unset|isset|isnotset|toggle>,<name>,track <ip_src|ip_dst|ip_pair>;\nxbits:<set|unset|isset|toggle>,<name>,track <ip_src|ip_dst|ip_pair> \\\n    [,expire <seconds>];\nxbits:<set|unset|isset|toggle>,<name>,track <ip_src|ip_dst|ip_pair> \\\n    [,expire <seconds>];\n```\n\n----------------------------------------\n\nTITLE: Requiring the suricata.flow library in Lua\nDESCRIPTION: This snippet shows how to require the `suricata.flow` library in a Lua script, which is necessary to use the flow API functions. This step makes the `suricata.flow` module available for use in the script.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_0\n\nLANGUAGE: lua\nCODE:\n```\nlocal flow = require(\"suricata.flow\")\n```\n\n----------------------------------------\n\nTITLE: Doxygen Function Comment Example\nDESCRIPTION: Example using Doxygen style function comments. Provides details about the function's purpose, parameters, and return values.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_28\n\nLANGUAGE: c\nCODE:\n```\n/**\n * \\brief Helper function to get a node, creating it if it does not\n * exist.\n *\n * This function exits on memory failure as creating configuration\n * nodes is usually part of application initialization.\n *\n * \\param name The name of the configuration node to get.\n * \\param final Flag to set created nodes as final or not.\n *\n * \\retval The existing configuration node if it exists, or a newly\n * created node for the provided name. On error, NULL will be returned.\n */\nstatic SCConfNode *SCConfGetNodeOrCreate(char *name, int final)\n```\n\n----------------------------------------\n\nTITLE: Alignment of Trailing Comments\nDESCRIPTION: This C code snippet demonstrates how trailing comments should be aligned for consecutive lines in struct definitions and other code sections. Proper alignment enhances code readability.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_22\n\nLANGUAGE: c\nCODE:\n```\nstruct bla {\n    int a;       /* comment */\n    unsigned bb; /* comment */\n    int *ccc;    /* comment */\n};\n```\n\n----------------------------------------\n\nTITLE: Flow control example - empty function\nDESCRIPTION: This C code snippet demonstrates the correct way to declare an empty function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nvoid empty_function(void)\n{\n}\n```\n\n----------------------------------------\n\nTITLE: DNS Response Logging Format (Suricata 7.0)\nDESCRIPTION: This JSON snippet represents the DNS response logging format in Suricata 7.0.  The type is 'answer'. The rrname and rrtype are logged directly under the dns object.  The format includes fields such as event_type, dns.version, dns.type, dns.id, dns.flags, dns.qr, dns.rd, dns.ra, dns.opcode, dns.rrname, dns.rrtype, dns.rcode, and dns.answers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"dns\",\n  \"dns\": {\n    \"version\": 2,\n    \"type\": \"answer\",\n    \"id\": 0,\n    \"flags\": \"8180\",\n    \"qr\": true,\n    \"rd\": true,\n    \"ra\": true,\n    \"opcode\": 0,\n    \"rrname\": \"www.suricata.io\",\n    \"rrtype\": \"A\",\n    \"rcode\": \"NOERROR\",\n    \"answers\": [\n      {\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"CNAME\",\n        \"ttl\": 3597,\n        \"rdata\": \"suricata.io\"\n      },\n      {\n        \"rrname\": \"suricata.io\",\n        \"rrtype\": \"A\",\n        \"ttl\": 597,\n        \"rdata\": \"35.212.0.44\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: PGSQL Event Example: Authentication MD5 Password\nDESCRIPTION: This is an example of a PGSQL event showing authentication using MD5 password. The event logs the protocol version, startup parameters, and the MD5 password salt value in the response. \nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_69\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"timestamp\": \"2021-11-24T16:56:19.436228+0000\",\n    \"flow_id\": 1960113262002448,\n    \"pcap_cnt\": 25,\n    \"event_type\": \"pgsql\",\n    \"src_ip\": \"172.18.0.1\",\n    \"src_port\": 54408,\n    \"dest_ip\": \"172.18.0.2\",\n    \"dest_port\": 5432,\n    \"proto\": \"TCP\",\n    \"pgsql\": {\n      \"tx_id\": 2,\n      \"request\": {\n        \"protocol_version\": \"3.0\",\n        \"startup_parameters\": {\n          \"user\": \"rules\",\n          \"database\": \"rules\",\n          \"optional_parameters\": [\n            {\n              \"application_name\": \"psql\"\n            },\n            {\n              \"client_encoding\": \"UTF8\"\n            }\n          ]\n        }\n      },\n      \"response\": {\n        \"authentication_md5_password\": \"Z\\\\xdc\\\\xfdf\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Response Line\nDESCRIPTION: Retrieves the HTTP response line as a string using the `response_line()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_7\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nlocal http_response_line = tx:response_line();\nif #http_response_line > 0 then\n      print(http_response_line)\nend\n```\n\n----------------------------------------\n\nTITLE: Iptables: Flush All Rules\nDESCRIPTION: This command flushes all iptables rules, effectively removing any previously configured rules.  This is required to restore normal network operation if Suricata is stopped.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Setting_up_IPSinline_for_Linux.txt#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -F\n```\n\n----------------------------------------\n\nTITLE: Associating PCAP Files with Tenants via Unix Socket\nDESCRIPTION: These commands show how to associate PCAP files with specific tenants when running Suricata in Unix socket runmode (pcap processing). The `pcap-file` command takes the PCAP file path, log directory, and tenant ID as arguments.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\npcap-file traffic1.pcap /logs1/ 1\npcap-file traffic2.pcap /logs2/ 2\npcap-file traffic3.pcap /logs3/ 3\npcap-file traffic4.pcap /logs5/ 5\npcap-file traffic5.pcap /logs7/ 7\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Protocol in Suricata Rules\nDESCRIPTION: This snippet shows how to match the SIP protocol version in a Suricata rule. The `sip.protocol` keyword is used to inspect the protocol field from a SIP request or response line.  The `content` option should contain the SIP protocol version.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.protocol; content:\"SIP/2.0\"\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Protocol\nDESCRIPTION: This Suricata rule detects a specific HTTP protocol version. It uses the `http.protocol` keyword to match the string 'HTTP/1.1' in HTTP requests. The flow keyword is used to specify the direction of the traffic to inspect.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_39\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Protocol Example\"; \\\n  flow:established,to_server; :example-rule-options:`http.protocol; \\\n  content:\"HTTP/1.1\";` bsize:9; classtype:bad-unknown; sid:50; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT CONNECT Flags\nDESCRIPTION: This example demonstrates matching MQTT CONNECT flags using the `mqtt.connect.flags` keyword. It uses a comma-separated list of flags with optional negation. Valid flags are: username, password, will, will_retain and clean_session.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.flags:username,password,!will;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.flags:username,!password;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.flags:clean_session;\n```\n\n----------------------------------------\n\nTITLE: Example Statistics Log\nDESCRIPTION: This is an example of the stats.log file, showing various counters and their values. It provides insights into the performance and behavior of Suricata, including flow management, packet decoding, defragmentation, and TCP session handling.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/statistics.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n-------------------------------------------------------------------\nCounter                   | TM Name                   | Value\n-------------------------------------------------------------------\nflow_mgr.closed_pruned    | FlowManagerThread         | 154033\nflow_mgr.new_pruned       | FlowManagerThread         | 67800\nflow_mgr.est_pruned       | FlowManagerThread         | 100921\nflow.memuse               | FlowManagerThread         | 6557568\nflow.spare                | FlowManagerThread         | 10002\nflow.emerg_mode_entered   | FlowManagerThread         | 0\nflow.emerg_mode_over      | FlowManagerThread         | 0\ndecoder.pkts              | RxPcapem21                | 450001754\ndecoder.bytes             | RxPcapem21                | 409520714250\ndecoder.ipv4              | RxPcapem21                | 449584047\ndecoder.ipv6              | RxPcapem21                | 9212\ndecoder.ethernet          | RxPcapem21                | 450001754\ndecoder.raw               | RxPcapem21                | 0\ndecoder.sll               | RxPcapem21                | 0\ndecoder.tcp               | RxPcapem21                | 448124337\ndecoder.udp               | RxPcapem21                | 542040\ndecoder.sctp              | RxPcapem21                | 0\ndecoder.icmpv4            | RxPcapem21                | 82292\ndecoder.icmpv6            | RxPcapem21                | 9164\ndecoder.ppp               | RxPcapem21                | 0\ndecoder.pppoe             | RxPcapem21                | 0\ndecoder.gre               | RxPcapem21                | 0\ndecoder.vlan              | RxPcapem21                | 0\ndecoder.avg_pkt_size      | RxPcapem21                | 910\ndecoder.max_pkt_size      | RxPcapem21                | 1514\ndefrag.ipv4.fragments     | RxPcapem21                | 4\ndefrag.ipv4.reassembled   | RxPcapem21                | 1\ndefrag.ipv4.timeouts      | RxPcapem21                | 0\ndefrag.ipv6.fragments     | RxPcapem21                | 0\ndefrag.ipv6.reassembled   | RxPcapem21                | 0\ndefrag.ipv6.timeouts      | RxPcapem21                | 0\ntcp.sessions              | Detect                    | 41184\ntcp.ssn_memcap_drop       | Detect                    | 0\ntcp.pseudo                | Detect                    | 2087\ntcp.invalid_checksum      | Detect                    | 8358\ntcp.no_flow               | Detect                    | 0\ntcp.reused_ssn            | Detect                    | 11\ntcp.memuse                | Detect                    | 36175872\ntcp.syn                   | Detect                    | 85902\ntcp.synack                | Detect                    | 83385\ntcp.rst                   | Detect                    | 84326\ntcp.segment_memcap_drop   | Detect                    | 0\ntcp.stream_depth_reached  | Detect                    | 109\ntcp.reassembly_memuse     | Detect                    | 67755264\ntcp.reassembly_gap        | Detect                    | 789\ndetect.alert              | Detect                    | 14721\n```\n\n----------------------------------------\n\nTITLE: Installing tcmalloc-minimal4 on Ubuntu\nDESCRIPTION: This command installs the tcmalloc-minimal4 package on Ubuntu using the apt-get package manager. This package provides the tcmalloc library, which can be used to improve memory allocation in applications like Suricata. It requires root privileges to install packages.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tcmalloc.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\napt-get install libtcmalloc-minimal4\n```\n\n----------------------------------------\n\nTITLE: Building Out-of-Tree: Set PATH\nDESCRIPTION: This snippet demonstrates how to set the PATH environment variable to include the directory containing `libsuricata-config`. This is necessary if Suricata was installed in a non-standard location.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/custom/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nPATH=/opt/suricata/bin:$PATH make -f Makefile.example\n```\n\n----------------------------------------\n\nTITLE: Listing Available suricata-update Sources\nDESCRIPTION: This command lists the available rulesets that can be enabled with suricata-update. It displays a table of available sources including vendor and set name.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata-update list-sources\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Username\nDESCRIPTION: This example demonstrates matching the username credential in the MQTT CONNECT message using the `mqtt.connect.username` keyword. It matches when the username is \"benson\". The username is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.username; content:\"benson\";\n```\n\n----------------------------------------\n\nTITLE: Building In-Tree: make command\nDESCRIPTION: This snippet shows how to build the library example in-tree within the Suricata project. It uses the standard `make` command, assuming the Suricata build system has generated a suitable Makefile.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/simple/README.md#_snippet_0\n\nLANGUAGE: makefile\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Media Connection Data Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.media.connection_data` keyword to match the Connection data subfield in an SDP request or response. The `content` keyword specifies the connection data string to search for, which follows the SDP scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.media.connection_data; content:\"IN IP4 192.168.1.2\"\n```\n\n----------------------------------------\n\nTITLE: Getting Packet Timestamp (Legacy String) in Lua\nDESCRIPTION: Retrieves the packet's timestamp as a string in the legacy format `11/24/2009-18:57:25.179869`, which is used by `fast.log` and other legacy Suricata outputs.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_3\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\nprint p:timestring_legacy()\n```\n\n----------------------------------------\n\nTITLE: Setting up Debian backports repository (Debian 10)\nDESCRIPTION: This command sequence adds the backports repository to Debian 10 (buster), updates the package list, and installs Suricata from the backports. Requires root privileges.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_6\n\nLANGUAGE: none\nCODE:\n```\necho \"deb http://http.debian.net/debian buster-backports main\" > \\\n    /etc/apt/sources.list.d/backports.list\napt-get update\napt-get install suricata -t buster-backports\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Protocol Version in Suricata Rules\nDESCRIPTION: The `enip.protocol_version` keyword is used to match the protocol version within ENIP messages, using a 16-bit unsigned integer as its value. This is useful for identifying specific versions of the ENIP protocol being used.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.protocol_version:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.protocol_version:>1;\n```\n\n----------------------------------------\n\nTITLE: Formatting most recent commit\nDESCRIPTION: This bash script formats the code changed in the most recent commit using git clang-format. It also provides instructions on how to amend the last commit with the formatting changes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clang-format HEAD^\n# Or with script:\n$ scripts/clang-format.sh commit\n```\n\n----------------------------------------\n\nTITLE: Configuring stream bypass in suricata.yaml\nDESCRIPTION: This snippet demonstrates how to configure stream bypass in the suricata.yaml file.  By setting bypass: yes, inspection will be skipped when the stream.reassembly.depth of 1mb is reached for a flow, improving performance at the expense of deep stream inspection.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tuning-considerations.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nstream:\n  memcap: 64mb\n  checksum-validation: yes      # reject wrong csums\n  inline: auto                  # auto will use inline mode in IPS mode, yes or no set it statically\n  bypass: yes\n  reassembly:\n    memcap: 256mb\n    depth: 1mb                  # reassemble 1mb into a stream\n    toserver-chunk-size: 2560\n    toclient-chunk-size: 2560\n    randomize-chunk-size: yes\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Identity Status in Suricata Rules\nDESCRIPTION: The `enip.identity_status` keyword is used to match the status in the identity message. It uses a 16-bit unsigned integer as its value. The status provides information regarding the health or operational state of the device.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.identity_status:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.identity_status:>1;\n```\n\n----------------------------------------\n\nTITLE: Logging Truncated MQTT PUBLISH (JSON)\nDESCRIPTION: This example shows the JSON format for logging a truncated MQTT PUBLISH message when it exceeds the maximum configured length. The message contains the basics information about the event and the mqtt message, specifying the `truncated` and `skipped_length` fields.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_64\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"timestamp\": \"2020-06-23T16:25:48.729785+0200\",\n    \"flow_id\": 1872904524326406,\n    \"pcap_cnt\": 107,\n    \"event_type\": \"mqtt\",\n    \"src_ip\": \"0000:0000:0000:0000:0000:0000:0000:0001\",\n    \"src_port\": 53335,\n    \"dest_ip\": \"0000:0000:0000:0000:0000:0000:0000:0001\",\n    \"dest_port\": 1883,\n    \"proto\": \"TCP\",\n    \"mqtt\": {\n      \"publish\": {\n        \"qos\": 0,\n        \"retain\": false,\n        \"dup\": false,\n        \"truncated\": true,\n        \"skipped_length\": 100011\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Engine Analysis: IP Only Rule\nDESCRIPTION: This JSON snippet shows the Engine Analysis report for a Suricata IP Only rule. It details the rule's ID, requirements (empty array, meaning it only uses IP addresses), type (ip_only), flags, and the lists containing postmatch configurations with hostbits.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"raw\": \"alert ip any any -> any any (hostbits:set,myflow2; sid:1505;)\",\n  \"id\": 1505,\n  \"gid\": 1,\n  \"rev\": 0,\n  \"app_proto\": \"unknown\",\n  \"requirements\": [],\n  \"type\": \"ip_only\",\n  \"flags\": [\n    \"src_any\",\n    \"dst_any\",\n    \"sp_any\",\n    \"dp_any\",\n    \"toserver\",\n    \"toclient\"\n  ],\n  \"pkt_engines\": [],\n  \"frame_engines\": [],\n  \"lists\": {\n    \"postmatch\": {\n      \"matches\": [\n        {\n          \"name\": \"hostbits\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Git Commit Message Template Configuration\nDESCRIPTION: This snippet shows how to configure a git commit message template for the Suricata project. It uses the `git config` command to set the `commit.template` option to the specified file path.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/code-submission-process.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit config commit.template /path/to/suricata/git-template/commit-template.txt\n```\n\n----------------------------------------\n\nTITLE: Configuring Lua Output in YAML - YAML\nDESCRIPTION: This YAML snippet demonstrates how to enable Lua output in Suricata and specify the scripts to load. It shows the `outputs` section with the `lua` output configured to be `enabled`.  It also shows how to specify `scripts-dir` and `scripts` to load.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/lua-output.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\noutputs:\n  - lua:\n      enabled: yes\n      scripts-dir: /etc/suricata/lua-output/\n\n      # By default the Lua module search paths are empty. If you plan\n      # to use external modules these paths will need to be set. The\n      # examples below are likely suitable for finding modules\n      # installed with a package manager on a 64 bit Linux system, but\n      # may need tweaking.\n      #path: \"/usr/share/lua/5.4/?.lua;/usr/share/lua/5.4/?/init.lua;/usr/lib64/lua/5.4/?.lua;/usr/lib64/lua/5.4/?/init.lua;./?.lua;./?/init.lua\"\n      #cpath: \"/usr/lib64/lua/5.4/?.so;/usr/lib64/lua/5.4/loadall.so;./?.so\"\n\n      scripts:\n        - tcp-data.lua\n        - flow.lua\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Indentation Example\nDESCRIPTION: Example demonstrating the required indentation style for switch statements where `case` is indented from the `switch`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nswitch (ntohs(p->ethh->eth_type)) {\n    case ETHERNET_TYPE_IP:\n        DecodeIPV4(tv, dtv, p, pkt + ETHERNET_HEADER_LEN,\n                   len - ETHERNET_HEADER_LEN, pq);\n        break;\n```\n\n----------------------------------------\n\nTITLE: SSH Connection State Enum - Rust\nDESCRIPTION: This Rust code defines an enum `SSHConnectionState` to represent the different states of an SSH connection. These states are used for tracking the progress of the SSH transaction and for determining when to trigger alerts or logging. The enum values are explicitly assigned integer values.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub enum SSHConnectionState {\n    SshStateInProgress = 0,\n    SshStateBannerWaitEol = 1,\n    SshStateBannerDone = 2,\n    SshStateFinished = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Running Rust Tests with Cargo\nDESCRIPTION: This code shows how to run Rust unit tests using the `cargo test` command. It explains how to run tests for specific modules or all tests in the project. The command compiles the Rust code and executes the tests defined in the modules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-rust.rst#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ncargo test [options][testname][-- test-options]\n```\n\n----------------------------------------\n\nTITLE: LDAP Response DN and Operation Match Alert Rule\nDESCRIPTION: This Suricata rule alerts if a packet has an LDAP search result entry operation at index 1 on the responses array and contains the LDAP distinguished name `dc=example,dc=com`. It uses the `ldap.responses.operation` keyword with the operation name `search_result_entry` and index `1`, and the `ldap.responses.dn` keyword along with the `content` keyword to match the distinguished name. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAPDN and operation\"; :example-rule-emphasis:`ldap.responses.operation:search_result_entry,1; ldap.responses.dn; content:\"dc=example,dc=com\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Configuring busy-poll-time in suricata.yaml\nDESCRIPTION: This snippet shows how to configure busy-poll-time in the suricata.yaml configuration file. This sets the time in microseconds to busy poll on a blocking receive when there is no data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  busy-poll-time: <time>\n  busy-poll-time: 20\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Status in Suricata Rules\nDESCRIPTION: The `enip.status` keyword is used to match against the status field in the ENIP encapsulation, using a 32-bit unsigned integer as its value. It can be specified by the integer value or text enumeration. The status field provides information regarding the success or failure of an ENIP operation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.status:100;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.status:>106;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.status:invalid_cmd;\n```\n\n----------------------------------------\n\nTITLE: Verify Hyperscan Support in Suricata\nDESCRIPTION: This command executes Suricata with the `--build-info` option and filters the output to check if Hyperscan support is enabled. The output `Hyperscan support: yes` indicates successful Hyperscan integration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/hyperscan.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --build-info | grep Hyperscan\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP2 Priority Value\nDESCRIPTION: This keyword allows matching on the priority value within a PRIORITY or HEADERS frame. It uses an unsigned 8-bit integer and supports qualifiers like greater than (>), less than (<), and range (x-y).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http2-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nhttp2.priority:2;\nhttp2.priority:>100;\nhttp2.priority:32-64;\n```\n\n----------------------------------------\n\nTITLE: Example EVE Packet Log with Tag\nDESCRIPTION: This JSON snippet shows an example of an EVE log entry for a packet. The `event_type` is `packet`. This example demonstrates the structure of a tagged packet log entry.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tag.rst#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"timestamp\": \"2020-06-03T10:29:17.850417+0000\",\n  \"flow_id\": 1576832511820424,\n  \"event_type\": \"packet\",\n  \"src_ip\": \"192.168.0.27\",\n  \"src_port\": 54634,\n  \"dest_ip\": \"192.168.0.103\",\n  \"dest_port\": 22,\n  \"proto\": \"TCP\",\n  \"pkt_src\": \"wire/pcap\",\n  \"packet\": \"CAAn6mWJAPSNvfrHCABFAAAogkVAAIAG9rfAqAAbwKgAZ9VqABZvnJXH5Zf6aFAQEAljEwAAAAAAAAAA\",\n  \"packet_info\": {\n    \"linktype\": 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a File-data Logger in Suricata (C)\nDESCRIPTION: This code snippet shows the function signature for registering a file-data logger within Suricata. File-data loggers are used to log the actual contents of files. The `SCOutputRegisterFileDataLogger` function is used to register a function to log file data, supporting file extraction and analysis.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/output/index.rst#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/** \\brief Register a file-data logger\n *\n *  This function registers a function that is responsible for logging\n *  file-data related output.\n *\n *  \\param logger The logger to register.\n *\n *  \\return void\n */\n```\n\nLANGUAGE: c\nCODE:\n```\nvoid SCOutputRegisterFileDataLogger(void (*logger)(SCLogRecord *lr, Flow *f, FileInfo *fi, uint8_t *data, uint32_t len, void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                         , void *data\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                         , void (*deinit)(void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                         );\n```\n\n----------------------------------------\n\nTITLE: Example of Suricata Rule with Classtype\nDESCRIPTION: This snippet presents a Suricata rule that incorporates a 'classtype' keyword. This specifies the classification of the rule. It is standard practice to place 'classtype' before 'sid' and 'rev'. The priority is derived from configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Setting Default Reputation Path in Suricata\nDESCRIPTION: This configuration sets the default path where Suricata will look for the reputation files specified in the `reputation-files` directive. If a reputation file path in the `reputation-files` directive is absolute, this setting is ignored.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/reputation/ipreputation/ip-reputation-config.rst#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\ndefault-reputation-path: /etc/suricata/iprep\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email To Field\nDESCRIPTION: This Suricata rule triggers an alert if an SMTP packet contains a 'To' field in the MIME header matching the provided content. The rule employs the 'email.to' keyword to inspect the email's recipient field.  The 'content' option defines the string to match. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_2\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email to\"; email.to; content:\"172.16.92.2@linuxbox\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching Kerberos Client Name in Suricata\nDESCRIPTION: This example shows how to match the Kerberos client name using the `krb5_cname` keyword in Suricata rules. The content option specifies the client name to search for within the Kerberos message. The comparison is case-sensitive and considers each part of the client name separately.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/kerberos-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert krb5 any any -> any any (msg:\"Kerberos 5 des server name\"; krb5_cname; content:\"des\"; sid:4; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Calculate Data Usage for a Host with jq\nDESCRIPTION: This command calculates the total data usage for a specific host (192.168.1.3) based on netflow events in the eve.json file. It filters netflow events, extracts the 'bytes' field, sums them up, and formats the output using `numfmt`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-examplesjq.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntail -n500000 eve.json | jq -s 'map(select(.event_type==\"netflow\" and .dest_ip==\"192.168.1.3\").netflow.bytes)|add'|numfmt --to=iec\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Payload Content in Suricata\nDESCRIPTION: This example shows how to use the `websocket.payload` keyword to match a specific string within the unmasked WebSocket payload. This keyword is a 'sticky buffer' and can be used as a fast pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.payload content:\"swordfish\";\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT CONNECT message\nDESCRIPTION: This example demonstrates the logging structure for an MQTT CONNECT message. It captures details like the protocol string, protocol version, flags indicating the presence of username/password and will parameters, client ID, username, password (if enabled), will topic, and will message. The log provides insight into the client's connection parameters and authentication details.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_53\n\nLANGUAGE: json\nCODE:\n```\n  \"connect\": {\n    \"qos\": 0,\n    \"retain\": false,\n    \"dup\": false,\n    \"protocol_string\": \"MQTT\",\n    \"protocol_version\": 5,\n    \"flags\": {\n      \"username\": true,\n      \"password\": true,\n      \"will_retain\": false,\n      \"will\": true,\n      \"clean_session\": true\n    },\n    \"client_id\": \"client\",\n    \"username\": \"user\",\n    \"password\": \"pass\",\n    \"will\": {\n      \"topic\": \"willtopic\",\n      \"message\": \"willmessage\",\n\n```\n\n----------------------------------------\n\nTITLE: Logging HTTP2 Request and Response (JSON)\nDESCRIPTION: This example illustrates the JSON structure for logging an HTTP/2 request and response.  Each contains an array of headers, with each header containing a name and a value. The request includes headers like authority, method, path, scheme, accept, accept-encoding, and user-agent. The response includes headers such as status, server, content-length, cache-control, date, and last-modified.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_66\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"http2\": {\n    \"request\": {\n      \"headers\": [\n        {\n          \"name\": \":authority\",\n          \"value\": \"localhost:3000\"\n        },\n        {\n          \"name\": \":method\",\n          \"value\": \"GET\"\n        },\n        {\n          \"name\": \":path\",\n          \"value\": \"/doc/manual/html/index.html\"\n        },\n        {\n          \"name\": \":scheme\",\n          \"value\": \"http\"\n        },\n        {\n          \"name\": \"accept\",\n          \"value\": \"*/*\"\n        },\n        {\n          \"name\": \"accept-encoding\",\n          \"value\": \"gzip, deflate\"\n        },\n        {\n          \"name\": \"user-agent\",\n          \"value\": \"nghttp2/0.5.2-DEV\"\n        }\n      ]\n    },\n    \"response\": {\n      \"headers\": [\n        {\n          \"name\": \":status\",\n          \"value\": \"200\"\n        },\n        {\n          \"name\": \"server\",\n          \"value\": \"nghttpd nghttp2/0.5.2-DEV\"\n        },\n        {\n          \"name\": \"content-length\",\n          \"value\": \"22617\"\n        },\n        {\n          \"name\": \"cache-control\",\n          \"value\": \"max-age=3600\"\n        },\n        {\n          \"name\": \"date\",\n          \"value\": \"Sat, 02 Aug 2014 10:50:25 GMT\"\n        },\n        {\n          \"name\": \"last-modified\",\n          \"value\": \"Sat, 02 Aug 2014 07:58:59 GMT\"\n        }\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Suricata Configuration with Command Line --set\nDESCRIPTION: Shows how to override configuration values in Suricata's `suricata.yaml` file using the `--set` command line option. It allows modifying existing values, such as disabling the `eve-log` output, but does not allow adding new entries to lists. The user is directed to inspect the output of `--dump-config` to identify values that can be modified, along with their indices.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/partials/options.rst#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\n--set default-log-dir=/var/tmp\n```\n\nLANGUAGE: YAML\nCODE:\n```\n--set outputs.1.eve-log.enabled=no\n```\n\n----------------------------------------\n\nTITLE: Indentation Example\nDESCRIPTION: Example of proper indentation in C code, showcasing 4-space indentation for code blocks and 8-space indentation for wrapped function parameters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nint DecodeEthernet(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n        uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    SCPerfCounterIncr(dtv->counter_eth, tv->sc_perf_pca);\n\n    if (unlikely(len < ETHERNET_HEADER_LEN)) {\n        ENGINE_SET_INVALID_EVENT(p, ETHERNET_PKT_TOO_SMALL);\n        return TM_ECODE_FAILED;\n    }\n\n    ...\n\n    DecodeNetworkLayer(tv, dtv, SCNtohs(p->ethh->eth_type), p,\n            pkt + ETHERNET_HEADER_LEN, len - ETHERNET_HEADER_LEN);\n\n    return TM_ECODE_OK;\n}\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Example with fast_pattern chop\nDESCRIPTION: This snippet shows how to use 'fast_pattern' with the 'chop' option to select only a specific portion of a content for MPM matching.  In this example, only the last four characters of \"aaaaaaaaabc\" will be used by the MPM. The syntax is 'fast_pattern: <offset>, <length>'. Dependencies: None.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/prefilter-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\ncontent: \"aaaaaaaaabc\"; fast_pattern:8,4;\n```\n\n----------------------------------------\n\nTITLE: Modbus Unit Identifier Matching\nDESCRIPTION: This snippet shows how to match Modbus requests based on the unit identifier using the `unit` setting.  It allows matching on specific unit IDs or ranges of IDs, and can be combined with `function` and `access` settings for more specific rules. Comparison operators can be used with the unit setting.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/modbus-keyword.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10, function 21\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10, function 4, subfunction 4\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10, function assigned\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10, function !reserved\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10, access read\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10, access write coils\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit >10, access read discretes, address <100\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmodbus: unit 10<>20, access write holding, address 500, value >200\n```\n\n----------------------------------------\n\nTITLE: Testing Specific Rust Modules\nDESCRIPTION: This command runs tests for a specific module, `nfs::rpc_records`. This allows for targeted testing of individual components within the Rust codebase.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-rust.rst#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\ncargo test nfs::rpc_records\n```\n\n----------------------------------------\n\nTITLE: Finding Syslog Daemon using Init Scripts (Linux)\nDESCRIPTION: This code snippet demonstrates how to identify the syslog daemon running on a Linux system by examining the init.d directory. It lists files in the directory and greps for 'syslog' to find relevant init scripts. The script names and their contents can then be inspected to determine the specific syslog daemon in use (e.g., syslog, rsyslogd).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/syslog-alerting-comp.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd /etc/init.d\nls | grep syslog\n```\n\n----------------------------------------\n\nTITLE: Snort Packet Acquisition Configuration\nDESCRIPTION: This snippet shows how packet acquisition is configured in Snort using the `config daq` directive. This directive is used to specify the DAQ (Data Acquisition) module to use, its directory, mode, and any additional variables.  Types include `pcap`, `afpacket`, `dump`, `nfq`, `ipq`, `ipfw`, and modes are `read-file`, `passive`, or `inline`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n# Configure DAQ related options for inline operation. For more information, see README.daq\n#\n# config daq: <type>\n# config daq_dir: <dir>\n# config daq_mode: <mode>\n# config daq_var: <var>\n#\n# <type> ::= pcap | afpacket | dump | nfq | ipq | ipfw\n# <mode> ::= read-file | passive | inline\n# <var> ::= arbitrary <name>=<value passed to DAQ\n# <dir> ::= path as to where to look for DAQ module so's\n```\n\n----------------------------------------\n\nTITLE: Importing OISF Signing Key with GPG\nDESCRIPTION: This command imports the Open Information Security Foundation (OISF) signing key to the local GPG keyring, which is necessary for verifying the Suricata distribution file's signature. This allows the user to ensure the downloaded file is authentic and hasn't been tampered with. The signing key is identified by its ID: 2BA9C98CCDF1E93A.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/verifying-source-files.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ gpg --receive-keys 2BA9C98CCDF1E93A\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with Napatech\nDESCRIPTION: This shell command starts Suricata with the specified configuration file and Napatech support, running in worker mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n$ suricata -c /usr/local/etc/suricata/suricata.yaml --napatech --runmode workers\n```\n\n----------------------------------------\n\nTITLE: Braces example\nDESCRIPTION: Example of proper brace placement in C code for functions, control statements, and loops. Functions should have the opening brace on a newline, while control and loop statements should have it on the same line.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nint SomeFunction(void)\n{\n    DoSomething();\n}\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Fall Through Example\nDESCRIPTION: Example demonstrating the required comment when a switch case falls through to the next case.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nswitch (suri->run_mode) {\n    case RUNMODE_PCAP_DEV:\n    case RUNMODE_AFP_DEV:\n    case RUNMODE_PFRING:\n        /* find payload for interface and use it */\n        default_packet_size = GetIfaceMaxPacketSize(suri->pcap_dev);\n        if (default_packet_size)\n            break;\n        /* fall through */\n    default:\n        default_packet_size = DEFAULT_PACKET_SIZE;\n```\n\n----------------------------------------\n\nTITLE: Defining Suricata Signature Types in C\nDESCRIPTION: This C code snippet from `src/detect.h` defines the different signature types used by Suricata, which dictate how rules are categorized and processed. These types determine the scope of the signature action, when the rule is matched against traffic, and what data the rule matches against.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n// rule types documentation tag start: SignatureType\n\n//typedef enum {\n//    SIG_TYPE_NONE,\n//    SIG_TYPE_DEONLY,\n//    SIG_TYPE_PKT,\n//    SIG_TYPE_IPONLY,\n//    SIG_TYPE_LIKE_IPONLY,\n//    SIG_TYPE_PDONLY,\n//    SIG_TYPE_PKT_STREAM,\n//    SIG_TYPE_STREAM,\n//    SIG_TYPE_APPLAYER,\n//    SIG_TYPE_APP_TX,\n//\n//    SIG_TYPE_MAX\n//} SignatureType;\n\n// rule types documentation tag end: SignatureType\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Response Line in Lua\nDESCRIPTION: This example demonstrates how to retrieve the HTTP response line using `HttpGetResponseLine()` and prints the result.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_11\n\nLANGUAGE: lua\nCODE:\n```\nrsl = HttpGetResponseLine();\nprint (\"Response Line: \" .. rsl);\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT CONNECT Properties (JSON)\nDESCRIPTION: This example shows how MQTT CONNECT properties are logged. It includes properties such as content type, correlation data, message expiry interval, payload format indicator, response topic, user properties, and will delay interval. The structure demonstrates the logging format within the Suricata event stream.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_54\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"properties\": {\n        \"content_type\": \"mywilltype\",\n        \"correlation_data\": \"3c32aa4313b3e\",\n        \"message_expiry_interval\": 133,\n        \"payload_format_indicator\": 144,\n        \"response_topic\": \"response_topic1\",\n        \"userprop\": \"uservalue\",\n        \"will_delay_interval\": 200\n      }\n    },\n    \"properties\": {\n      \"maximum_packet_size\": 11111,\n      \"receive_maximum\": 222,\n      \"session_expiry_interval\": 555,\n      \"topic_alias_maximum\": 666,\n      \"userprop1\": \"userval1\",\n      \"userprop2\": \"userval2\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Rate Filter Configuration Syntax\nDESCRIPTION: This defines the syntax for configuring rate filters using 'rate_filter'.  Rate filters modify a rule's action when it matches. Parameters include the generator ID, signature ID, tracking method, count, seconds, new action, and timeout. The timeout parameter specifies how long the rate filter remains active.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nrate_filter: rate_filter gen_id <gid>, sig_id <sid>, track <tracker>, \\\n  count <c>, seconds <s>, new_action <action>, timeout <timeout>\n```\n\n----------------------------------------\n\nTITLE: Configuring Action Order in Suricata YAML\nDESCRIPTION: This snippet sets the order in which Suricata processes rule actions (pass, drop, reject, alert).  This determines the priority given to each action when multiple rules match a packet. The default order is pass, drop, reject, and alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\naction-order:\n - pass\n - drop\n - reject\n - alert\n```\n\n----------------------------------------\n\nTITLE: Getting flow timestamps in Lua\nDESCRIPTION: This snippet retrieves the timestamps of the first and last packets in the flow as seconds and microseconds since the epoch (1970-01-01 00:00:00 UTC). It returns four numerical values: start_sec, start_usec, last_sec, and last_usec.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_2\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\nlocal start_sec, start_usec, last_sec, last_usec = f:timestamps()\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Command Data Matching Rule - IP Address\nDESCRIPTION: This rule uses `ftp.command_data` to match an IP address and port combination: \"192,168,0,13,234,10\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.command_data; content:\"192,168,0,13,234,10\";` sid: 3;)\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Nonce Payload with Content - Suricata\nDESCRIPTION: This snippet demonstrates how to match the nonce of the server or client using the `ike.nonce_payload` keyword and the `content` modifier in a Suricata rule. `ike.nonce_payload` is a sticky buffer and can be used as a fast pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nike.nonce_payload; content:\"|6d026d5616c45be05e5b898411e9|\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata with DAG support\nDESCRIPTION: This command configures the Suricata build with Endace DAG support. It also sets the prefix, sysconfdir, and localstatedir for installation. DAG support allows Suricata to directly use the *libdag* interface for packet capture.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/endace-dag.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --enable-dag --prefix=/usr --sysconfdir=/etc --localstatedir=/var\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: DNS Request Logging Format (Suricata 7.0)\nDESCRIPTION: This JSON snippet shows the DNS request logging format in Suricata 7.0. The type is 'query', and individual queries are logged as separate events if multiple queries exist. Relevant fields include event_type, dns.type, dns.id, dns.rrname, dns.rrtype, dns.tx_id, and dns.opcode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"dns\",\n  \"dns\": {\n    \"type\": \"query\",\n    \"id\": 0,\n    \"rrname\": \"www.suricata.io\",\n    \"rrtype\": \"A\",\n    \"tx_id\": 0,\n    \"opcode\": 0\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Server Header with Suricata Rule\nDESCRIPTION: This Suricata rule shows how to detect a specific HTTP server header value using the `http.server` keyword. It searches for the string \"nginx/0.8.54\" within the HTTP server header. The `flow` keyword specifies the traffic direction to be 'to_client'. The `bsize` parameter sets the maximum buffer size.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_22\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Server Example\"; flow:established,to_client; :example-rule-options:`http.server; \\\ncontent:\"nginx/0.8.54\";` bsize:12; classtype:bad-unknown; sid:121; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Event Type Example\nDESCRIPTION: This JSON provides an illustration of a common field in EVE logs, `event_type`. It depicts how an event is categorized, thus offering an initial perspective on an entry. This is crucial for identifying the log type, allowing for proper context during analysis.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n\"event_type\":\"TYPE\"\n```\n\n----------------------------------------\n\nTITLE: GitHub Filter for New Pull Requests\nDESCRIPTION: This filter is used to identify newly created pull requests that are open, not in draft status, have not been reviewed, and are not assigned to anyone. It is used to ensure that all new PRs are assigned to a reviewer within two weeks.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/github-pr-workflow.rst#_snippet_1\n\nLANGUAGE: GitHub Query Language\nCODE:\n```\nis:pr is:open draft:false review:none sort:updated-asc no:assignee\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Password with PCRE\nDESCRIPTION: This example matches the MQTT password using the `mqtt.connect.password` keyword combined with a PCRE. It matches passwords starting with \"123\" followed by any number of digits. The password is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.password; pcre:\"/^123[0-9]*/\";\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Encryption Key Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.encryption_key` keyword to match the encryption key field in an SDP request or response. The `content` keyword specifies the encryption key string to search for, which follows the SDP key (k=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.encryption_key; content:\"prompt\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Suricata 'rev' Keyword\nDESCRIPTION: This snippet shows the syntax for the 'rev' (revision) keyword in a Suricata rule. The 'rev' keyword represents the version of a signature. This should be incremented when the rule is modified. The value must be a positive integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nrev:123;\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP File Name Rule\nDESCRIPTION: This rule utilizes the `file.name` keyword at the FTP application level to match specific file names.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp-data any any -> any any (msg:\"FTP file.name usage\"; \\\n  :example-rule-options:`file.name; content:\"file.txt\";` \\\n  classtype:bad-unknown; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: LDAP Search Result Entry Alert Rule (Last Index)\nDESCRIPTION: This Suricata rule alerts if a search_result_entry response is found at the last index. It uses the `ldap.responses.operation` keyword with the operation name `search_result_entry` and index `-1`. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP search response\"; :example-rule-emphasis:`ldap.responses.operation:search_result_entry,-1;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Raw HTTP Response Headers in Lua\nDESCRIPTION: This example demonstrates how to retrieve the raw HTTP response headers using the `HttpGetRawResponseHeaders()` function and prints the raw headers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_13\n\nLANGUAGE: lua\nCODE:\n```\nrh = HttpGetRawResponseHeaders();\nprint (\"Raw Response Headers: \" .. rh);\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: HTTP file.name Example\nDESCRIPTION: This Suricata rule demonstrates the use of the `file.name` keyword to match a specific filename in an HTTP request. The example matches the filename `picture.jpg`. The rule applies to HTTP traffic from an external network to the home network.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP file.name Example\"; \\\n  flow:established,to_client; :example-rule-options:`file.name; \\\n  content:\"picture.jpg\";` classtype:bad-unknown; sid:129; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: urilen Keyword with Normalized Buffer\nDESCRIPTION: This shows how to apply the `urilen` keyword to the normalized buffer in Snort.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nurilen:>20,norm;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Transactional HTTP Alert with Streaming Buffer Limitation\nDESCRIPTION: This Suricata rule demonstrates a limitation of transactional rules where a fast_pattern cannot be used on the client side when a streaming buffer is used on the server side. This specific rule attempts to match content \"123\" in the server's file data (file.data) and status code \"500\" on the client side, but it will refuse to load due to the fast_pattern placement.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any => any any (file.data: to_server; content: \"123\";  http.stat_code; content: \"500\"; fast_patten;)\n```\n\n----------------------------------------\n\nTITLE: HTTP Event Example (Non-Extended)\nDESCRIPTION: This example illustrates the structure of an 'http' event in Suricata's Eve JSON output without extended logging enabled. It includes fields such as hostname, URL, HTTP user agent, and HTTP content type, providing basic information about the HTTP request.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"http\": {\n      \"hostname\": \"www.digip.org\",\n      \"url\" :\"\\/jansson\\/releases\\/jansson-2.6.tar.gz\",\n      \"http_user_agent\": \"<User-Agent>\",\n      \"http_content_type\": \"application\\/x-gzip\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"http\": {\n      \"http_port\": 1337,\n      \"hostname\": \"www.test.org\",\n      \"url\" :\"\\/this\\/is\\/test.tar.gz\",\n      \"http_user_agent\": \"<User-Agent>\",\n      \"http_content_type\": \"application\\/x-gzip\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Flow control example - short function\nDESCRIPTION: This C code snippet demonstrates the correct way to declare a short function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nint short_function(void)\n{\n    return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Flow Bypassed Statistics - JSON\nDESCRIPTION: This snippet shows the JSON output from the `stats.flow_bypassed` object, containing statistics about bypassed flows. The data includes local and capture bytes/packets counters, as well as bypassed and closed flow counters.  `local_pkts` and `local_bytes` are for Suricata bypassed flows, while `pkts` and `bytes` are counters coming from the capture method.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_25\n\nLANGUAGE: JSON\nCODE:\n```\n {\n   \"local_pkts\": 0,\n   \"local_bytes\": 0,\n   \"local_capture_pkts\": 20,\n   \"local_capture_bytes\": 25000,\n   \"closed\": 84,\n   \"pkts\": 4799,\n   \"bytes\": 2975133\n }\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Counting Successful Logins\nDESCRIPTION: This example increments a `flowint` counter named `loginsuccess` whenever a successful login is detected.  No alert is generated, as the purpose is to track successful logins.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Counting Good Logins\";             \\\n        content:\"login successful\"; flowint:loginsuccess, +, 1; noalert;)\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Content-Length Header in Suricata Rules\nDESCRIPTION: This snippet shows how to match the SIP Content-Length header in a Suricata rule. The `sip.content_length` keyword is used to inspect the Content-Length header field. The `content` option should contain the value of the Content-Length header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.content_length; content:\"200\"\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Less Than Matching\nDESCRIPTION: This code snippet shows how to match an integer value that is less than a specified value. `bsize:<22;` means the rule will match if the value of the `bsize` field is less than 22.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:<22;\n```\n\n----------------------------------------\n\nTITLE: Getting flow statistics in Lua\nDESCRIPTION: This snippet retrieves packet and byte counts in both directions of the flow. It returns four numerical values representing the transmitted packets count, transmitted bytes count, received packets count, and received bytes count.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_9\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\ntscnt, tsbytes, tccnt, tcbytes = f:stats()\n```\n\n----------------------------------------\n\nTITLE: Retrieving TLS Certificate Chain in Lua\nDESCRIPTION: This code demonstrates how to retrieve the TLS certificate chain using the `TlsGetCertChain()` function. It imports the luaossl library to process the certificate data and prints the certificate information.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_22\n\nLANGUAGE: lua\nCODE:\n```\n-- Use debian lua-luaossl coming from https://github.com/wahern/luaossl\nlocal x509 = require\"openssl.x509\"\n\n   chain = TlsGetCertChain()\n   for k, v in pairs(chain) do\n      -- v.length is length of data\n      -- v.data is raw binary data of certificate\n      cert = x509.new(v[\"data\"], \"DER\")\n      print(cert:text() .. \"\\n\")\n   end\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Responder SPI with Content - Suricata\nDESCRIPTION: This snippet demonstrates how to match the Responder Security Parameter Index (SPI) in an IKE packet using the `ike.resp_spi` keyword and the `content` modifier in a Suricata rule. The `content` modifier specifies the exact SPI value to look for. `ike.resp_spi` is a sticky buffer and can be used as a fast pattern.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nike.resp_spi; content:\"a00b8ef0902bb8ec\";\n```\n\n----------------------------------------\n\nTITLE: Negating DNS Opcode Value Range in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to negate matching a range of opcode values in the DNS header using the `dns.opcode` keyword in a Suricata rule. The opcode is an unsigned 8-bit integer representing the type of query. This will not match opcodes between 7 and 15, exclusively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.opcode:!7-15;\n```\n\n----------------------------------------\n\nTITLE: Get HTTP Response Headers\nDESCRIPTION: Retrieves the HTTP response headers using the `response_headers()` method on the transaction object (`tx`).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_13\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = http.get_tx()\nhttp_response_headers = tx:response_headers()\nprint(http_response_headers)\n```\n\n----------------------------------------\n\nTITLE: Getting HTTP Transaction\nDESCRIPTION: Retrieves the current HTTP transaction using `http.get_tx()`. Checks for errors and prints any error messages. The returned transaction object (`tx`) is then used to access request and response information.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/http.rst#_snippet_3\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx, err = http.get_tx()\nif tx == err then\n    print(err)\nend\n```\n\n----------------------------------------\n\nTITLE: Matching SNMP Community String in Suricata Rules\nDESCRIPTION: This code snippet shows how to match the SNMP community string using the `snmp.community` keyword in a Suricata rule.  It utilizes the `content` keyword for matching the community string. `snmp.community` is a sticky buffer and can be used as a `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/snmp-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert snmp any any -> any any (msg:\"SNMP community private\"; snmp.community; content:\"private\"; sid:2; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Inspect Alert Payload Data with jq\nDESCRIPTION: This command extracts and decodes the payload data from alert events in the eve.json file. It filters for events of type \"alert\", extracts the \"payload\" field, and decodes it using base64.  The -r option outputs raw string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-examplesjq.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncat eve.json | jq -r -c 'select(.event_type==\"alert\")|.payload'|base64 --decode\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Mask greater than value in Suricata\nDESCRIPTION: This example demonstrates matching the WebSocket mask using greater than operator. `websocket.mask` uses an unsigned 32-bits integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.mask:>0;\n```\n\n----------------------------------------\n\nTITLE: Analyzing TCP Stream Rule with Byte Operations - JSON\nDESCRIPTION: This JSON presents the analysis of a Suricata rule that utilizes byte extraction and testing on a TCP stream. It defines the rule's attributes like ID, message, application protocol (dcerpc), requirements (payload and flow), and type (stream).  The \"lists\" section provides details about the byte_extract and byte_test operations.  Notably, the byte_test configuration includes the number of bytes, offset, and endianness.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"raw\": \"alert tcp any any -> any any (msg:\\\"byte_extract with dce\\\"; byte_extract:4,0,var,dce; byte_test:4,>,var,4,little; sid:901;)\",\n      \"id\": 901,\n      \"gid\": 1,\n      \"rev\": 0,\n      \"msg\": \"byte_extract with dce\",\n      \"app_proto\": \"dcerpc\",\n      \"requirements\": [\n        \"payload\",\n        \"flow\"\n      ],\n      \"type\": \"stream\",\n      \"flags\": [\n        \"src_any\",\n        \"dst_any\",\n        \"sp_any\",\n        \"dp_any\",\n        \"applayer\",\n        \"need_stream\",\n        \"toserver\",\n        \"toclient\"\n      ],\n      \"pkt_engines\": [\n        {\n          \"name\": \"payload\",\n          \"is_mpm\": false\n        }\n      ],\n      \"frame_engines\": [],\n      \"lists\": {\n        \"payload\": {\n          \"matches\": [\n            {\n              \"name\": \"byte_extract\"\n            },\n            {\n              \"name\": \"byte_test\",\n              \"byte_test\": {\n                \"nbytes\": 4,\n                \"offset\": 4,\n                \"base\": \"unset\",\n                \"flags\": [\n                  \"little_endian\"\n                ]\n              }\n            }\n          ]\n        }\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Repeat Time Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.repeat_time` keyword to match the repeat time field in an SDP request or response. The `content` keyword specifies the repeat time string to search for, which follows the SDP repeat time (r=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.repeat_time; content:\"604800 3600 0 90000\"\n```\n\n----------------------------------------\n\nTITLE: Checking TCP Acknowledgement Number with ack Keyword in Suricata\nDESCRIPTION: This example demonstrates how to use the `ack` keyword in a Suricata rule to check for a specific TCP acknowledgement number.  The acknowledgement number is checked against the value of 0 in the example rule. This helps in analyzing the TCP handshake and data transfer phases to identify suspicious activities.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"GPL SCAN NULL\"; flow:stateless; :example-rule-emphasis:`ack:0;` flags:0; seq:0; reference:arachnids,4; classtype:attempted-recon; sid:2100623; rev:7;)\n```\n\n----------------------------------------\n\nTITLE: Starting Napatech Service\nDESCRIPTION: This shell command starts the Napatech service, required for using Napatech hardware with Suricata. The `-m` flag might be used to specify a mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n\t$ /opt/napatech3/bin/ntstart.sh -m\n```\n\n----------------------------------------\n\nTITLE: AF_PACKET IPS Configuration\nDESCRIPTION: This YAML configuration shows how to configure Suricata to act as an IPS between two interfaces (eth0 and eth1) using AF_PACKET capture method. It defines the interfaces, threads, copy mode, and other parameters for IPS operation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\naf-packet:\n  - interface: eth0\n    threads: 1\n    defrag: no\n    cluster-type: cluster_flow\n    cluster-id: 98\n    copy-mode: ips\n    copy-iface: eth1\n    buffer-size: 64535\n  - interface: eth1\n    threads: 1\n    cluster-id: 97\n    defrag: no\n    cluster-type: cluster_flow\n    copy-mode: ips\n    copy-iface: eth0\n    buffer-size: 64535\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Reason Code\nDESCRIPTION: This example demonstrates matching the MQTT reason code using the `mqtt.reason_code` keyword. Several examples are provided which match different scenarios based on message type and reason code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\n# match on attempts to unsubscribe from a non-subscribed topic\nmqtt.type:UNSUBACK; mqtt.reason_code:17;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\n# match on publications that were accepted but there were no subscribers\nmqtt.type:PUBACK; mqtt.reason_code:16;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\n# match on connection attempts by banned clients\nmqtt.CONNACK; mqtt.reason_code:138;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\n# match on failed connection attempts due to bad credentials\nmqtt.CONNACK; mqtt.reason_code:134;\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\n# match on connections terminated by server shutdowns\nmqtt.DISCONNECT; mqtt.reason_code:139;\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with PF_RING Plugin\nDESCRIPTION: This command executes Suricata with the PF_RING plugin enabled.  It sets the plugin path, specifies the capture plugin as 'pfring-plugin', and defines the interface to capture from (eno1).\nSOURCE: https://github.com/oisf/suricata/blob/master/plugins/pfring/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n/usr/local/suricata/bin/suricata \\\n    --set plugins.0=/usr/local/lib/suricata/pfring.so \\\n    --capture-plugin=pfring-plugin \\\n    --set pfring.0.interface=eno1\n```\n\n----------------------------------------\n\nTITLE: Threshold Override Example\nDESCRIPTION: Demonstrates how global thresholds override signature settings when applied to a specific signature. This allows customization of alerting behavior based on the environment. The example showcases different threshold settings for the same signature.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nthreshold gen_id 1, sig_id 2002087, type both, track by_src, count 3, seconds 5\nthreshold gen_id 1, sig_id 2002087, type threshold, track by_src, count 10, seconds 60\nthreshold gen_id 1, sig_id 2002087, type limit, track by_src, count 1, seconds 15\n```\n\n----------------------------------------\n\nTITLE: LDAP Result Code Matching - All Responses\nDESCRIPTION: This Suricata rule alerts if all LDAP responses in the packet have a \"success\" result code.  The `all` keyword ensures that every response must have the specified result code for the rule to trigger.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test all LDAP responses have success result code\"; :example-rule-emphasis:`ldap.responses.result_code:success,all;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Registering App Layer MPM and Inspection Engines - C\nDESCRIPTION: This C code snippet shows how Suricata registers application layer MPM (Multi-Pattern Matcher) and inspection engines for file data detection. `DetectAppLayerMpmRegister` registers an MPM engine with specified flags, protocols, and callbacks. `DetectAppLayerInspectEngineRegister` registers an inspection engine with similar parameters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid DetectFiledataRegister(void)\n{\n    .\n    .\n    DetectAppLayerMpmRegister(\"file_data\", SIG_FLAG_TOSERVER, 2,\n            PrefilterMpmFiledataRegister, NULL,\n            ALPROTO_HTTP2, HTTP2StateDataClient);\n        DetectAppLayerMpmRegister(\"file_data\", SIG_FLAG_TOCLIENT, 2,\n            PrefilterMpmFiledataRegister, NULL,\n            ALPROTO_HTTP2, HTTP2StateDataServer);\n    .\n    .\n    DetectAppLayerInspectEngineRegister(\"file_data\",\n            ALPROTO_HTTP2, SIG_FLAG_TOCLIENT, HTTP2StateDataServer,\n            DetectEngineInspectFiledata, NULL);\n    DetectAppLayerInspectEngineRegister(\n                \"file_data\", ALPROTO_FTPDATA, SIG_FLAG_TOSERVER, 0, DetectEngineInspectFiledata, NULL);\n    .\n    .\n}\n```\n\n----------------------------------------\n\nTITLE: NFS Rule Example with file.name\nDESCRIPTION: This Suricata rule demonstrates the usage of the `file.name` keyword to detect specific file names in NFS traffic. The rule alerts if it finds traffic with 'file.txt' in the file name. It is important to note the 'example-rule-options' role is used for styling in the documentation but isn't part of the Suricata rule syntax.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/nfs-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert nfs any any -> any any (msg:\"NFS file.name usage\"; \\\n:example-rule-options:`file.name; content:\"file.txt\";` \\\nclasstype:bad-unknown; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Content-Length Request with Suricata Rule\nDESCRIPTION: This Suricata rule demonstrates detecting a specific HTTP content length value in a request using the `http.content_len` keyword. It searches for the value \"100\" within the Content-Length header. The `flow` keyword specifies the traffic direction to be 'to_server'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_27\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Content-Length Request \\\nExample\"; flow:established,to_server; :example-rule-options:`http.content_len; \\\ncontent:\"100\";` bsize:3; classtype:bad-unknown; sid:97; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Converting HTTP URI to Uppercase - Suricata Rule\nDESCRIPTION: This rule demonstrates the `to_uppercase` transformation, converting the `http.uri` buffer to uppercase before matching. It looks for the uppercase string \"THIS TEXT HAS BEEN CONVERTED TO UPPERCASE\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http.uri; to_uppercase; \\\n    content:\"THIS TEXT HAS BEEN CONVERTED TO UPPERCASE\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT publish with QoS 2\nDESCRIPTION: This example demonstrates logging an MQTT PUBLISH message with QoS level 2. It showcases how multiple messages in a single MQTT transaction (PUBLISH, PUBREC, PUBREL, PUBCOMP) are merged into one EVE output. The log includes the MQTT payload ('message'), along with metadata such as QoS level, retain flag, duplicate flag, and message ID. The 'topic' specifies the destination of the message.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_52\n\nLANGUAGE: json\nCODE:\n```\n  {\n    \"timestamp\": \"2020-05-19T18:00:39.016985+0200\",\n    \"flow_id\": 1454127794305760,\n    \"pcap_cnt\": 65,\n    \"event_type\": \"mqtt\",\n    \"src_ip\": \"0000:0000:0000:0000:0000:0000:0000:0001\",\n    \"src_port\": 60105,\n    \"dest_ip\": \"0000:0000:0000:0000:0000:0000:0000:0001\",\n    \"dest_port\": 1883,\n    \"proto\": \"TCP\",\n    \"mqtt\": {\n      \"publish\": {\n        \"qos\": 2,\n        \"retain\": false,\n        \"dup\": false,\n        \"topic\": \"house/bulbs/bulb1\",\n        \"message_id\": 3,\n        \"message\": \"OFF\"\n      },\n      \"pubrec\": {\n        \"qos\": 0,\n        \"retain\": false,\n        \"dup\": false,\n        \"message_id\": 3\n      },\n      \"pubrel\": {\n        \"qos\": 1,\n        \"retain\": false,\n        \"dup\": false,\n        \"message_id\": 3\n      },\n      \"pubcomp\": {\n        \"qos\": 0,\n        \"retain\": false,\n        \"dup\": false,\n        \"message_id\": 3\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Enabling DPDK support - Bash\nDESCRIPTION: This bash command is used to configure Suricata with DPDK support.  It needs to be executed before compiling Suricata to enable the DPDK capture module.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\n    ./configure --enable-dpdk\n```\n\n----------------------------------------\n\nTITLE: Example Suricata Flow Log with Exception Policy Details\nDESCRIPTION: This JSON snippet presents an example of a Suricata flow log entry, illustrating how exception policy triggers are recorded. The `exception_policy` array within the flow object lists the specific targets that triggered policies and the policies that were applied, allowing for detailed analysis of exception handling.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/exception-policies.rst#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n  \"flow\": {\n    \"pkts_toserver\": 4,\n    \"pkts_toclient\": 5,\n    \"bytes_toserver\": 495,\n    \"bytes_toclient\": 351,\n    \"start\": \"2016-07-13T22:42:07.199672+0000\",\n    \"end\": \"2016-07-13T22:42:07.573174+0000\",\n    \"age\": 0,\n    \"state\": \"new\",\n    \"reason\": \"shutdown\",\n    \"alerted\": false,\n    \"action\": \"pass\",\n    \"exception_policy\": [\n       {\n         \"target\": \"stream_midstream\",\n         \"policy\": \"pass_flow\"\n       },\n       {\n         \"target\": \"app_layer_error\",\n         \"policy\": \"ignore\"\n       }\n     ]\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for HTTP URI in Lua (Detection)\nDESCRIPTION: This code shows how to initialize the `needs` table specifically for HTTP URI detection. Setting the 'http.uri' key to 'true' allows the script to access the HTTP URI for detection logic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_5\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"http.uri\"] = tostring(true)\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: DPDK Interface Configuration\nDESCRIPTION: This YAML snippet shows the DPDK interface configuration for Suricata. It defines parameters such as interface name, number of threads, promisc mode, multicast, checksum checks, mempool size, RX/TX descriptors, copy mode (IPS), copy interface, and MTU.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\n      - interface: 0000:3b:00.0\n        threads: 4\n        promisc: true\n        multicast: true\n        checksum-checks: true\n        checksum-checks-offload: true\n        mempool-size: 262143\n        mempool-cache-size: 511\n        rx-descriptors: 4096\n        tx-descriptors: 4096\n        copy-mode: ips\n        copy-iface: 0000:3b:00.1\n        mtu: 3000\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP URI Length in Suricata\nDESCRIPTION: This Suricata rule matches on the length of the normalized HTTP URI using the `urilen` keyword.  It includes examples of matching a specific length, a length greater than a value, a length less than a value, and a length between two values.  It does not require a content match on the URI itself.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Request\"; \\\n  flow:established,to_server; :example-rule-options:`urilen:11;` \\\n  http.method; content:\"GET\"; classtype:bad-unknown; sid:40; rev:1;)\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"urilen greater than 10\"; \\\n  flow:established,to_server; :example-rule-options:`urilen:>10;` \\\n  classtype:bad-unknown; sid:41; rev:1;)\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"urilen less than 12\"; \\\n  flow:established,to_server; :example-rule-options:`urilen:<12;` \\\n  classtype:bad-unknown; sid:42; rev:1;)\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"urilen greater/less than \\\n  example\"; flow:established,to_server; :example-rule-options:`urilen:10<>12;` \\\n  classtype:bad-unknown; sid:43; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Goto Label Indentation Example\nDESCRIPTION: Example demonstrating the correct indentation level for goto labels. Labels should be at the same brace level.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nint goto_style_nested()\n{\n    if (foo()) {\n    label1:\n        bar();\n    }\n\nlabel2:\n    return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Flow Integer Variable\nDESCRIPTION: This Lua code initializes a Flow integer variable named `tls-cnt` for use in Suricata. The `needs[\"flowint\"]` entry declares that `tls-cnt` will be tracked as a flowint. The `needs[\"tls\"] tostring(true)` part seems incorrect and will probably error. It likely intended `needs[\"tls\"] = true`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_48\n\nLANGUAGE: Lua\nCODE:\n```\nfunction init(args)\n    local needs = {}\n    needs[\"tls\"] tostring(true)\n    needs[\"flowint\"] = {\"tls-cnt\"}\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Alert if State is Set (flowbits)\nDESCRIPTION: This Suricata rule generates an alert if the 'SC.EXAMPLE' flowbit is set, indicating a previous event has occurred. It monitors HTTP POST requests for established flows and requires the 'SC.EXAMPLE' flowbit to be previously set. Requires flowbits to be configured.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> $HOME_NET any (msg:\"noalert example: state use\"; flow:established,to_server; xbits:isset,SC.EXAMPLE,track ip_dst; http.method; content:\"POST\"; sid: 2; )\n```\n\n----------------------------------------\n\nTITLE: Matching RFB Desktop Name Using PCRE\nDESCRIPTION: This snippet demonstrates how to use the 'rfb.name' keyword with a Perl Compatible Regular Expression (PCRE) to match a pattern in the RFB desktop name.  The 'rfb.name' is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rfb-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nrfb.name; pcre:\"/.* \\(screen [0-9]\\)$/\";\n```\n\n----------------------------------------\n\nTITLE: Accept TCP traffic on port 80 - Suricata\nDESCRIPTION: This Suricata rule accepts all TCP traffic on port 80. It utilizes the 'accept' action with the 'hook' keyword to specify where in the traffic processing pipeline the rule should be applied. The 'tcp:all' specifies that this rule applies to all TCP packets, 'any any' specifies any source and destination IP address, and 'any 80' specifies any source port and destination port 80.  The sid (signature ID) is a unique identifier for the rule.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/firewall/firewall-example.rst#_snippet_0\n\nLANGUAGE: suricata\nCODE:\n```\naccept:hook tcp:all any any <> any 80 (sid:10;)\n```\n\n----------------------------------------\n\nTITLE: Defining a Reference Keyword\nDESCRIPTION: This shows the basic syntax for defining a 'reference' keyword within a Suricata rule. This is used to provide links or identifiers to external resources or vulnerability databases for additional context or information about the signature. The types are defined in reference.config\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nreference:type,reference\n```\n\n----------------------------------------\n\nTITLE: Example of Custom TLS Log Output\nDESCRIPTION: This snippet presents an example of the log output generated by the custom TLS logging configuration. It illustrates the format defined by the `customformat` string in the Suricata configuration. The log entry includes timestamp, client and server IP addresses and ports, TLS version, SNI, and certificate dates.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/custom-tls-logging.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n 12/03/16-19:20:14.85859 10.10.10.4:58274 -> 192.0.78.24:443 VERSION='TLS 1.2' suricata.io NOTBEFORE='2016-10-27T20:36:00' NOTAFTER='2017-01-25T20:36:00'\n```\n\n----------------------------------------\n\nTITLE: Displaying Suricata Alerts in EVE JSON Format\nDESCRIPTION: Displays Suricata alerts from the `eve.json` file using `tail -f` and `jq` to filter events by `event_type==\"alert\"`.  The jq tool parses the JSON and selects alert events.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\nsudo tail -f /var/log/suricata/eve.json | jq 'select(.event_type==\"alert\")'\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for Packet Type in Lua\nDESCRIPTION: This code snippet shows how to initialize the `needs` table for accessing raw packet data. Setting the 'type' to 'packet' provides access to the raw packet information within the Lua script.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_2\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"type\"] = \"packet\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Defining default memcap and hashsize for datasets\nDESCRIPTION: This example demonstrates how to define global default `memcap` and `hashsize` values for all datasets in the Suricata configuration. These defaults will be applied to datasets that don't explicitly define these parameters.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\ndatasets:\n  defaults:\n    memcap: 100mb\n    hashsize: 2048\n  ua-seen:\n    type: string\n    load: ua-seen.lst\n```\n\n----------------------------------------\n\nTITLE: Example of base64 decode\nDESCRIPTION: This command demonstrates how to decode the base64 encoded string from a dataset to reveal the original value (e.g., a user agent string).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_15\n\nLANGUAGE: Bash\nCODE:\n```\nbase64 -d\n```\n\n----------------------------------------\n\nTITLE: Download and Install libcap-ng\nDESCRIPTION: This snippet downloads, extracts, configures, compiles, and installs the libcap-ng library.  It fetches the library from a specified URL, extracts the archive, navigates to the extracted directory, configures the build using `./configure`, builds the library using `make`, and installs it using `make install`.  This process is necessary for Suricata to drop privileges after startup.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/dropping-privileges.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nwget http://people.redhat.com/sgrubb/libcap-ng/libcap-ng-0.7.8.tar.gz\ntar -xzvf libcap-ng-0.7.8.tar.gz\ncd libcap-ng-0.7.8\n./configure\nmake\nmake install\n```\n\n----------------------------------------\n\nTITLE: Getting DNS answers in Lua\nDESCRIPTION: This example demonstrates how to retrieve the 'answers' section of a DNS response using the `answers()` method on the transaction object. The code iterates through the answers, extracting and printing the rrname, rrtype, and ttl values.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_4\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nlocal answers = tx:answers()\nif answers ~= nil then\n    for n, t in pairs(answers) do\n        rrname = t[\"rrname\"]\n        rrtype = t[\"type\"]\n        ttl = t[\"ttl\"]\n\n        print (\"ANSWER: \" .. ts .. \" \" .. rrname .. \" [**] \" .. rrtype .. \" [**] \" ..\n               ttl .. \" [**] \" .. srcip .. \":\" .. sp .. \" -> \" ..\n               dstip .. \":\" .. dp)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Stopping irqbalance Service\nDESCRIPTION: Stops the irqbalance service. This is necessary when manually configuring IRQ affinity for NIC queues to prevent conflicts and ensure Suricata's worker threads are properly assigned to CPU cores.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nservice irqbalance stop\n```\n\n----------------------------------------\n\nTITLE: Configuring NIC with ethtool and shell scripts\nDESCRIPTION: This snippet demonstrates how to configure a NIC using ethtool and shell scripts.  It involves bringing the interface down, setting combined queues, enabling rxhash and ntuple, bringing the interface up, setting IRQ affinity, and configuring hash function and key.  The example uses 'eno6' as the interface name.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nifconfig eno6 down\n/opt/mellanox/ethtool/sbin/ethtool -L eno6 combined 15\n/opt/mellanox/ethtool/sbin/ethtool -K eno6 rxhash on\n/opt/mellanox/ethtool/sbin/ethtool -K eno6 ntuple on\nifconfig eno6 up\n/sbin/set_irq_affinity_cpulist.sh 1-7,64-71 eno6\n/opt/mellanox/ethtool/sbin/ethtool -X eno6 hfunc toeplitz\n/opt/mellanox/ethtool/sbin/ethtool -X eno6 hkey 6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Rust Test\nDESCRIPTION: These commands demonstrate how to run a specific test function by specifying the module, file name, `tests` module, and test function name. Alternatively, if the test name is unique, it can be run directly by its name.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-rust.rst#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ncargo test module::file_name::tests::test_name\n```\n\nLANGUAGE: rust\nCODE:\n```\ncargo test test_name\n```\n\n----------------------------------------\n\nTITLE: Configuring Syslog Output (Deprecated) in Suricata (YAML)\nDESCRIPTION: This snippet shows how to configure syslog output in Suricata (deprecated in Suricata 8.0 and will be removed in 9.0). It demonstrates enabling the syslog output module, setting the facility, and configuring the level of output. Options include Emergency, Alert, Critical, Error, Warning, Notice, Info, and Debug.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\n  - syslog:                       #This is a output-module to direct log-output to several directions.\n       enabled: no                #The use of this output-module is not enabled.\n       facility: local5           #In this option you can set a syslog facility.\n       level: Info                #In this option you can set the level of output. The possible levels are:\n                                  #Emergency, Alert, Critical, Error, Warning, Notice, Info and Debug.\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Duplicate HTTP Header Example\nDESCRIPTION: This Suricata rule detects duplicate HTTP headers. The example shows how Suricata normalizes multiple occurrences of the `User-Agent` header by concatenating the values with a comma and space. The rule uses `http.user_agent` to match the concatenated header value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET -> $EXTERNAL_NET (msg:\"Example Duplicate Header\"; \\\n  flow:established,to_server; :example-rule-options:`http.user_agent; \\\n  content:\"Mozilla/5.0, Chrome/121.0.0\";` classtype:bad-unknown; sid:103; \\\n  rev:1;)\n```\n\n----------------------------------------\n\nTITLE: TLS State Enum - C\nDESCRIPTION: This C code defines an enum to represent the different states of a TLS (Transport Layer Security) handshake. The states include `TLS_STATE_IN_PROGRESS`, `TLS_STATE_CERT_READY`, `TLS_HANDSHAKE_DONE`, and `TLS_STATE_FINISHED`, allowing Suricata to track the progress of TLS transactions and identify key events within the handshake process.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nenum {\n    TLS_STATE_IN_PROGRESS = 0,\n    TLS_STATE_CERT_READY = 1,\n    TLS_HANDSHAKE_DONE = 2,\n    TLS_STATE_FINISHED = 3\n};\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Certificate Chain Length in Suricata\nDESCRIPTION: This example showcases the `tls.cert_chain_len` keyword in Suricata, used to match the length of the TLS certificate chain. It utilizes various operators (<, >, <>, !) for different comparison scenarios and allows specifying an exact value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_19\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"cert chain exact value\"; \\\n tls.cert_chain_len:1; classtype:misc-activity; sid:1; rev:1;)\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"cert chain less than value\"; \\\n tls.cert_chain_len:<2; classtype:misc-activity; sid:2; rev:1;)\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"cert chain greater than value\"; \\\n tls.cert_chain_len:>0; classtype:misc-activity; sid:2; rev:1;)\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"cert chain greater than less than value\";\\\n tls.cert_chain_len:0<>2; classtype:misc-activity; sid:3; rev:1;)\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"cert chain not value\"; \\\n tls.cert_chain_len:!2; classtype:misc-activity; sid:4; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Tracking Logins and Logouts\nDESCRIPTION: This example uses `flowint` to track both login and logout events to determine the number of active logins for a user. It increments `usernamecount` on logins and decrements it on logouts, alerting only when the count is over 5.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Username Logged out\"; content:\"logout jonkman\"; \\\n        flowint: usernamecount, -, 1; flowint:usernamecount, >, 5;)\n```\n\n----------------------------------------\n\nTITLE: Setting up Lua Output Script - Lua\nDESCRIPTION: This code snippet demonstrates the `setup` function, which is called per output thread. It opens a file for logging HTTP transactions and initializes a counter. It uses `SCLogPath()` to get the log directory and `SCLogInfo()` to log a message.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/lua-output.rst#_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nfunction setup (args)\n    filename = SCLogPath() .. \"/\" .. name\n    file = assert(io.open(filename, \"a\"))\n    SCLogInfo(\"HTTP Log Filename \" .. filename)\n    http = 0\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata rule using datarep with MD5 hash\nDESCRIPTION: This example shows a rule that uses `datarep` to check the reputation of a DNS query's MD5 hash. It loads a MD5 reputation list from `dns_md5.rep` and checks if the reputation value is greater than 200.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns any any -> any any (dns.query; to_md5; datarep:dns_md5, >, 200, load dns_md5.rep, type md5, memcap 100mb, hashsize 2048; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching TLS Random Time Field in Suricata\nDESCRIPTION: This example shows how to match the first 4 bytes of the TLS random field from the client or server hello using the `tls.random_time` keyword in Suricata.  It uses the content keyword and the hexadecimal representation of the 4 bytes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_17\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"TLS random_time test\"; \\\n    tls.random_time; content:\"|9b ce 7a 5e|\"; sid: 200075;)\n```\n\n----------------------------------------\n\nTITLE: Matching SSH Software String\nDESCRIPTION: This rule matches SSH connections based on the software string present in the SSH banner. The `ssh.software` keyword acts as a sticky buffer, and the `content` keyword searches for the string \"openssh\" in a case-insensitive manner.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ssh-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ssh any any -> any any (msg:\"match SSH software string\"; ssh.software; content:\"openssh\"; nocase; sid:1000020;)\n```\n\n----------------------------------------\n\nTITLE: Matching SNMP PDU Type in Suricata Rules\nDESCRIPTION: This code snippet demonstrates how to match the SNMP PDU type using the `snmp.pdu_type` keyword in a Suricata rule. It is an integer representing the SNMP PDU type.  The keyword expects an unsigned 32-bit integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/snmp-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert snmp any any -> any any (msg:\"SNMP response\"; snmp.pdu_type:2; sid:3; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Getting DNS transaction ID in Lua\nDESCRIPTION: This code illustrates how to retrieve the DNS transaction ID (txid) from the DNS message using the `txid()` method on the transaction object.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_11\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nlocal txid = tx:txid()\nprint(txid)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Inequality Matching\nDESCRIPTION: This code snippet demonstrates how to match an integer value for inequality in a Suricata rule using the `!` operator. The `bsize` keyword specifies the integer field, and `0x14` is the hexadecimal value to check for inequality. The rule triggers if `bsize` is *not* equal to `0x14` (decimal 20).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:!0x14;\n```\n\n----------------------------------------\n\nTITLE: Suricata TLS Store Output Configuration (YAML)\nDESCRIPTION: This configuration defines the settings for the tls-store output, which stores TLS certificate chains to disk. It enables the module and sets the directory to store the certificates. This is similar to file extraction but specifically for TLS certificates.  The `enabled` parameter activates/deactivates the certificate storage.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\n  # output module to store certificates chain to disk\n  - tls-store:\n      enabled: yes\n      #certs-log-dir: certs # directory to store the certificates files\n```\n\n----------------------------------------\n\nTITLE: Disabling AF_XDP during Suricata configuration\nDESCRIPTION: This command shows how to disable AF_XDP support during the Suricata configuration process. The --disable-af-xdp flag is used to exclude AF_XDP functionality from the build.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./configure --disable-af-xdp\n```\n\n----------------------------------------\n\nTITLE: Analyzing Bittorrent DHT Get Peers Request/Response with values in JSON\nDESCRIPTION: This snippet illustrates the JSON structure for a Bittorrent DHT 'get_peers' request and its response containing a 'values' parameter (list of peers).  The request includes fields like 'transaction_id', 'client_version', 'request_type', 'request' (with 'id' and 'info_hash'). The response contains 'id', 'values' (list of IP addresses and ports), and 'token'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_39\n\nLANGUAGE: json\nCODE:\n```\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"05e4\",\n    \"client_version\": \"4c540126\",\n    \"request_type\": \"get_peers\",\n    \"request\": {\n      \"id\": \"41aff1580119f074e2f537f231f12adf684f0d1f\",\n      \"info_hash\": \"19a6fcfcba6cc2c6d371eb754074d095adb5d291\"\n    }\n  }\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"05e4\",\n    \"client_version\": \"555462d6\",\n    \"response\": {\n      \"id\": \"19a6f98be177e32e7b5bd77276d529f03e3ba8a9\",\n      \"values\": [\n        {\n          \"ip\": \"45.238.190.2\",\n          \"port\": 6881\n        },\n        {\n          \"ip\": \"185.70.52.245\",\n          \"port\": 51215\n        },\n        {\n          \"ip\": \"45.21.238.247\",\n          \"port\": 55909\n        },\n        {\n          \"ip\": \"62.28.248.195\",\n          \"port\": 6881\n        }\n      ],\n      \"token\": \"c17094641ca8844d711120baecb2b5cf25435614\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT SUBACK (JSON)\nDESCRIPTION: This example demonstrates the JSON structure for logging MQTT SUBACK messages. It includes details about the subscription acknowledgement, such as qos, retain, dup, message_id, and an array of QoS levels granted for each subscribed topic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_59\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"suback\": {\n    \"qos\": 0,\n    \"retain\": false,\n    \"dup\": false,\n    \"message_id\": 1,\n    \"qos_granted\": [\n      0,\n      0\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Remove DPDK Hugepage Files\nDESCRIPTION: This command is used to remove DPDK-related files from the hugepage-mounted directory. This is typically done when hugepages are not freed completely after Suricata and other hugepage-related applications are terminated. The `dpdk-hugepages.py` command helps to identify the mounted directory.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/dpdk.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo rm -rf /dev/hugepages/rtemap_*\n\n  # To check where hugepages are mounted:\n  dpdk-hugepages.py -s\n  # or \n  mount | grep huge\n```\n\n----------------------------------------\n\nTITLE: IDS/IPS Rule Example (Alert HTTP)\nDESCRIPTION: This example demonstrates a typical IDS/IPS rule that alerts on HTTP traffic. This is shown in comparison to the firewall rule for demonstration purposes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/firewall/firewall-design.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert http ... http.uri; ...\n```\n\n----------------------------------------\n\nTITLE: Add Hostbit via Unix Socket\nDESCRIPTION: Shows how to add a hostbit using the Suricata Unix socket.  The command `add-hostbit` requires an IP address, a bit name, and an expiration time in seconds. This allows external processes to modify Suricata's state dynamically.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/xbits.rst#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nsuricatasc -c \"add-hostbit <ip> <bit name> <expire in seconds>\"\nsuricatasc -c \"add-hostbit 1.2.3.4 blacklist 3600\"\n```\n\n----------------------------------------\n\nTITLE: Grouped DNS Answer Log Example\nDESCRIPTION: This JSON snippet presents a grouped DNS answer log entry. Instead of individual answer records, it aggregates answers by their type ('A', 'CNAME') in the 'grouped' field, providing a more compact representation. The 'version', 'type', 'id', 'flags', 'qr', 'rd', 'ra', and 'rcode' fields are also present.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n  \"dns\": {\n      \"version\": 3,\n      \"type\": \"answer\",\n      \"id\": 18523,\n      \"flags\": \"8180\",\n      \"qr\": true,\n      \"rd\": true,\n      \"ra\": true,\n      \"rcode\": \"NOERROR\",\n      \"grouped\": {\n        \"A\": [\n          \"192.0.78.24\",\n          \"192.0.78.25\"\n        ],\n        \"CNAME\": [\n          \"suricata.io\"\n        ]\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Netmap IPS Configuration - Paired Interfaces\nDESCRIPTION: This YAML snippet showcases the Netmap configuration for Suricata in IPS mode using paired network interfaces. It defines two interfaces, specifying their names, the number of threads, copy mode (IPS), and the corresponding copy interface for symmetric traffic handling.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\n netmap:\n   - interface: enp6s0f0\n     threads: auto\n     copy-mode: ips\n     copy-iface: enp6s0f1\n\n   - interface: enp6s0f1\n     threads: auto\n     copy-mode: ips\n     copy-iface: enp6s0f0\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hassh Server String in Lua\nDESCRIPTION: Gets the hassh algorithms used by the server using HasshServerGetString().\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_43\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    hassh_string = HasshServerGetString()\n    if hassh == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with specified configuration\nDESCRIPTION: This command starts Suricata with a specific configuration file and network interface. The '-c' flag specifies the configuration file path, and the '-i' flag designates the network interface for Suricata to monitor. Requires Suricata to be installed and configured. Replace wlan0 with the appropriate network interface.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/adding-your-own-rules.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c /etc/suricata/suricata.yaml -i wlan0\n```\n\n----------------------------------------\n\nTITLE: Including additional configuration files in Suricata, YAML example\nDESCRIPTION: Demonstrates how to include additional configuration files when running Suricata using the `--include` option.  Multiple files can be included in the order they are specified on the command line.  These files are loaded as if they existed at the end of the main configuration file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/partials/options.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n--include /etc/suricata/other.yaml\n```\n\nLANGUAGE: YAML\nCODE:\n```\n--include /etc/suricata/other.yaml --include /etc/suricata/extra.yaml\n```\n\n----------------------------------------\n\nTITLE: SMTP rcpt_to keyword example\nDESCRIPTION: This example shows how to use the `smtp.rcpt_to` keyword to match the parameters passed to the RCPT TO command.  The rule triggers if the RCPT TO command contains \"sensitive@target\". `smtp.rcpt_to` is a sticky and multi buffer and can be used as `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"SMTP rcpt to sensitive\"; smtp.rcpt_to; content:\"sensitive@target\"; sid:2; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Building LibHTP with FFI Support\nDESCRIPTION: This snippet shows how to build LibHTP with Foreign Function Interface (FFI) support for use in C/C++ projects. It requires cbindgen to generate headers and uses make to build the headers and shared objects.\nSOURCE: https://github.com/oisf/suricata/blob/master/rust/htp/README.md#_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\n# Install cbindgen which is required to generate headers\ncargo install --force cbindgen\n\n# Build headers and shared objects\nmake\n```\n\n----------------------------------------\n\nTITLE: Remove Hostbit via Unix Socket\nDESCRIPTION: Shows how to remove a hostbit using the Suricata Unix socket. The command `remove-hostbit` requires an IP address and a bit name.  This allows external processes to clear hostbits that were previously set.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/xbits.rst#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nsuricatasc -c \"remove-hostbit <ip> <bit name>\"\nsuricatasc -c \"remove-hostbit 1.2.3.4 blacklist\"\n```\n\n----------------------------------------\n\nTITLE: Including Multiple YAML Files in Suricata\nDESCRIPTION: This snippet demonstrates how to include multiple YAML files in a Suricata configuration.  The files listed under the `include` key will be parsed and their contents incorporated into the main configuration file in the order they are listed. Requires a valid YAML structure.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/includes.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ninclude:\n  - filename1.yaml\n  - filename2.yaml\n```\n\n----------------------------------------\n\nTITLE: Matching Raw Certificates in TLS Chain with Suricata\nDESCRIPTION: This example demonstrates matching raw byte sequences within the certificates of a TLS chain using the `tls.certs` keyword in Suricata. It shows how to search for specific hexadecimal byte patterns within the certificate data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_12\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"match bytes in TLS cert\"; tls.certs; \\\n    content:\"|06 09 2a 86|\"; sid:200070;)\n```\n\n----------------------------------------\n\nTITLE: Modifying Napatech Service Configuration with NUMA\nDESCRIPTION: These lines configure the timestamp clock and host buffers in the `ntservice.ini` file for a multi-processor system with NUMA nodes. `HostBuffersRx` defines the number, size, and NUMA node of the host buffers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_9\n\nLANGUAGE: INI\nCODE:\n```\nTimeSyncReferencePriority = OSTime\t# Timestamp clock synchronized to the OS\n    HostBuffersRx = [16,16,0],[16,16,1] # [number of host buffers, Size(MB), NUMA node]\n```\n\n----------------------------------------\n\nTITLE: Auto-Setup with configure, make, install-conf - Bash\nDESCRIPTION: This command configures, compiles, and installs Suricata, and also sets up the necessary directories and suricata.yaml configuration file. It combines the actions of ./configure, make, and sudo make install-conf into a single command.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && sudo make install-conf\n```\n\n----------------------------------------\n\nTITLE: FTP Transaction Completion State - C\nDESCRIPTION: This C code shows how the transaction completion state is registered for the FTP protocol. The `FTP_STATE_FINISHED` enum value is used for both the to-server and to-client completion states, indicating that the transaction is considered complete when the FTP state reaches `FTP_STATE_FINISHED`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nAppLayerParserRegisterStateProgressCompletionStatus(\n    ALPROTO_FTP, FTP_STATE_FINISHED, FTP_STATE_FINISHED);\n```\n\n----------------------------------------\n\nTITLE: Configure DPDK Bond Interface\nDESCRIPTION: This YAML snippet configures a DPDK bond interface within Suricata. It defines the EAL parameters, including the virtual device (`net_bonding0`) with specific mode and slave interfaces, and specifies the interface to be used for capturing traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/dpdk.rst#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ndpdk:\n      eal-params:\n        proc-type: primary\n        vdev: 'net_bonding0,mode=0,slave=0000:04:00.0,slave=0000:04:00.1'\n\n      # DPDK capture support\n      # RX queues (and TX queues in IPS mode) are assigned to cores in 1:1 ratio\n      interfaces:\n        - interface: net_bonding0 # PCIe address of the NIC port\n          # Threading: possible values are either \"auto\" or number of threads\n          # - auto takes all cores\n          # in IPS mode it is required to specify the number of cores and the\n          # numbers on both interfaces must match\n          threads: 4\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Chosen SA Attribute - Suricata\nDESCRIPTION: This snippet demonstrates how to match a specific attribute value of the Security Association (SA) chosen by the Responder using the `ike.chosen_sa_attribute` keyword. The example shows matching a specific hash algorithm and a key length for the SA. If multiple SAs are chosen, only the first SA's attributes are used.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nike.chosen_sa_attribute:alg_hash=2;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nike.chosen_sa_attribute:sa_key_length=128;\n```\n\n----------------------------------------\n\nTITLE: Matching JA3S string in Suricata rule\nDESCRIPTION: This example demonstrates creating a Suricata rule to match a particular JA3S string. The `ja3s.string` keyword is employed, indicating that the content should be matched against the JA3S string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ja-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tls any any -> any any (msg:\"match on JA3S string\"; \\\n      ja3s.string; content:\"771,23-35\"; sid:100004;)\n```\n\n----------------------------------------\n\nTITLE: Displaying All Statistics in EVE JSON Format\nDESCRIPTION: Displays all statistics from the `eve.json` file using `tail -f` and `jq` to filter events by `event_type==\"stats\"`. The jq tool parses the JSON and selects statistics events.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_12\n\nLANGUAGE: Shell\nCODE:\n```\nsudo tail -f /var/log/suricata/eve.json | jq 'select(.event_type==\"stats\")'\n```\n\n----------------------------------------\n\nTITLE: Matching TLS ALPN in Suricata\nDESCRIPTION: This example demonstrates how to match the Application-Layer Protocol Negotiation (ALPN) field in a TLS handshake using the `tls.alpn` keyword in Suricata. It checks for the presence of the \"http/1.1\" protocol.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_20\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert tls any any -> any any (msg:\"TLS ALPN test\"; \\\n    tls.alpn; content:\"http/1.1\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 data with offset and rfc2045 - Suricata Rule\nDESCRIPTION: This rule decodes a Base64 encoded string starting at offset 6 using rfc2045 mode, and checks if the decoded output matches \"foobar\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_19\n\nLANGUAGE: Suricata\nCODE:\n```\ncontent:\"/?arg=Zm 9v Ym Fy\"; from_base64: offset 6, mode rfc2045; \\\n   content:\"foobar\";\n```\n\n----------------------------------------\n\nTITLE: ARP Logging Example (Reply)\nDESCRIPTION: This JSON snippet shows an example of an ARP reply log entry captured by Suricata. It includes information about the hardware type, protocol type, opcode, source MAC address, source IP address, destination MAC address, and destination IP address. This log entry allows for tracking ARP responses on the network.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_78\n\nLANGUAGE: JSON\nCODE:\n```\n  \"arp\": {\n    \"hw_type\": \"ethernet\",\n    \"proto_type\": \"ipv4\",\n    \"opcode\": \"reply\",\n    \"src_mac\": \"00:1a:6b:6c:0c:cc\",\n    \"src_ip\": \"10.10.10.2\",\n    \"dest_mac\": \"00:1d:09:f0:92:ab\",\n    \"dest_ip\": \"10.10.10.1\"\n  }\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for Flow Type in Lua\nDESCRIPTION: This code snippet demonstrates how to initialize the `needs` table for flow-related operations in a Suricata Lua script.  By setting the 'type' key to 'flow', the script gains access to flow-related data and metadata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_3\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"type\"] = \"flow\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Matching SNMP USM Username in Suricata Rules\nDESCRIPTION: This code snippet illustrates how to match the SNMP User-based Security Model (USM) username using the `snmp.usm` keyword in a Suricata rule. It involves using the `content` keyword to match the username. `snmp.usm` is a sticky buffer and can be used as `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/snmp-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert snmp any any -> any any (msg:\"SNMP usm admin\"; snmp.usm; content:\"admin\"; sid:2; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Extended Requires Keyword Example\nDESCRIPTION: This example shows how 'requires' can be extended to multiple release branches using the OR operator (|) to ensure a rule works across different Suricata versions or feature availability.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_19\n\nLANGUAGE: Suricata\nCODE:\n```\nrequires: version >= 7.0.10 < 8 | >= 8.0.5 < 9 | >= 9.0.3\n```\n\n----------------------------------------\n\nTITLE: DCERPC Bind/BindAck Logging Example (JSON)\nDESCRIPTION: Illustrates the JSON format for logging DCERPC bind/bindack pairs. The structure includes fields related to SMB as well as DCERPC-specific details such as interfaces (UUID, version, ack result, ack reason) and the call ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_35\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"id\": 53,\n    \"dialect\": \"2.10\",\n    \"command\": \"SMB2_COMMAND_WRITE\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 35184439197745,\n    \"tree_id\": 1,\n    \"dcerpc\": {\n      \"request\": \"BIND\",\n      \"response\": \"BINDACK\",\n      \"interfaces\": [\n        {\n          \"uuid\": \"12345778-1234-abcd-ef00-0123456789ac\",\n          \"version\": \"1.0\",\n          \"ack_result\": 2,\n          \"ack_reason\": 0\n        },\n        {\n          \"uuid\": \"12345778-1234-abcd-ef00-0123456789ac\",\n          \"version\": \"1.0\",\n          \"ack_result\": 0,\n          \"ack_reason\": 0\n        },\n        {\n          \"uuid\": \"12345778-1234-abcd-ef00-0123456789ac\",\n          \"version\": \"1.0\",\n          \"ack_result\": 3,\n          \"ack_reason\": 0\n        }\n      ],\n      \"call_id\": 2\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: EVE JSON Fileinfo Event Example\nDESCRIPTION: This JSON illustrates a `fileinfo` event type, outlining the file details observed within network traffic. The data includes the timestamp, flow ID, packet count, source and destination IPs/ports, protocol, Ethernet details, along with file information attributes like the filename, size, and whether gaps exist. Also present is http info.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n      \"timestamp\": \"2023-09-18T06:13:33.903924+0000\",\n      \"flow_id\": 1676750115612680,\n      \"pcap_cnt\": 70,\n      \"event_type\": \"fileinfo\",\n      \"src_ip\": \"192.168.100.237\",\n      \"src_port\": 49175,\n      \"dest_ip\": \"142.11.240.191\",\n      \"dest_port\": 35361,\n      \"proto\": \"TCP\",\n      \"pkt_src\": \"wire/pcap\",\n      \"ether\": {\n        \"src_mac\": \"12:a9:86:6c:77:de\",\n        \"dest_mac\": \"52:54:00:36:3e:ff\"\n      },\n      \"http\": {\n        \"hostname\": \"142.11.240.191\",\n        \"http_port\": 35361,\n        \"url\": \"/\",\n        \"http_content_type\": \"text/xml\",\n        \"http_method\": \"POST\",\n        \"protocol\": \"HTTP/1.1\",\n        \"status\": 200,\n        \"length\": 212\n      },\n      \"app_proto\": \"http\",\n      \"fileinfo\": {\n        \"filename\": \"/\",\n        \"gaps\": false,\n        \"state\": \"CLOSED\",\n        \"stored\": false,\n        \"size\": 137,\n        \"tx_id\": 0\n      }\n    }\n```\n\n----------------------------------------\n\nTITLE: Frame Registration Functions in SIP (Rust)\nDESCRIPTION: These are the frame registration functions used in the SIP parser in Rust. They are used to associate specific portions of the stream with frame types.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl AppLayerProto {\n    pub fn register_frame(\n        &mut self,\n        flow: *mut Flow,\n        sl: &StreamSlice,\n        frame_start: i64,\n        frame_len: i64,\n        frame_type: FrameType,\n    ) {\n        unsafe {\n            SCAppLayerRegisterFrame(\n                flow,\n                sl.ss,\n                frame_start,\n                frame_len,\n                frame_type.into(),\n                0,\n            );\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Status Code with Suricata Rule\nDESCRIPTION: This Suricata rule demonstrates detecting a specific HTTP status code using the `http.stat_code` keyword. It searches for the status code \"200\" in the HTTP response. The `flow` keyword specifies the traffic direction to be 'to_client'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_23\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Stat Code Response \\\nExample\"; flow:established,to_client; :example-rule-options:`http.stat_code; \\\ncontent:\"200\";` classtype:bad-unknown; sid:117; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Deinitializing Lua Output Script - Lua\nDESCRIPTION: This code snippet shows the `deinit` function, which is called when the script is unloaded. It logs the total number of HTTP transactions logged and closes the log file. It uses `SCLogInfo()` to log the number of HTTP transactions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/lua-output.rst#_snippet_3\n\nLANGUAGE: lua\nCODE:\n```\nfunction deinit (args)\n    SCLogInfo (\"HTTP transactions logged: \" .. http);\n    file:close(file)\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Alerting on Excessive Login Failures\nDESCRIPTION: This example demonstrates how to generate an alert when the number of login failures in a stream exceeds a threshold (5 in this case). It checks if `loginfail` is set and greater than 5.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"More than Five login fails in a Stream\"; \\\n        content:\"login failed\"; flowint:loginfail, isset; flowint:loginfail, >, 5;)\n```\n\n----------------------------------------\n\nTITLE: Matching SNMP Version in Suricata Rules\nDESCRIPTION: This code snippet demonstrates how to match the SNMP version using the `snmp.version` keyword in a Suricata rule.  It includes examples of exact matching and comparison using operators. The keyword expects an unsigned 32-bit integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/snmp-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert snmp any any -> any any (msg:\"old SNMP version (<3)\"; snmp.version:<3; sid:1; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Will Topic with PCRE\nDESCRIPTION: This example demonstrates matching the will topic in the MQTT CONNECT message using the `mqtt.connect.willtopic` keyword combined with a PCRE. It matches will topics starting with \"hunter\" followed by any digit. The will topic is a 'sticky buffer'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_15\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.connect.willtopic; pcre:\"/^hunter[0-9]/\";\n```\n\n----------------------------------------\n\nTITLE: Disabling clang-format\nDESCRIPTION: This C code snippet demonstrates how to disable clang-format for specific sections of code using /* clang-format off */ and /* clang-format on */ comments. This is useful for code that requires manual formatting or where clang-format's output is undesirable.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n/* clang-format off */\n#define APP_LAYER_INCOMPLETE(c, n) (AppLayerResult){1, (c), (n)}\n/* clang-format on */\n```\n\n----------------------------------------\n\nTITLE: Suricata Unix Socket command: dataset-lookup\nDESCRIPTION: This example shows how to check if data exists in a dataset using the Suricata Unix socket. This command tests whether 'google.com' (base64 encoded) is present in the 'myset' dataset as a string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_13\n\nLANGUAGE: Text\nCODE:\n```\ndataset-lookup myset string Z29vZ2xlLmNvbQ==\n```\n\n----------------------------------------\n\nTITLE: Bittorrent-DHT Ping Request Logging Example (JSON)\nDESCRIPTION: Shows a JSON structure for logging a Bittorrent-DHT ping request. It includes transaction ID, client version, request type, and request details like the node ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_36\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"transaction_id\": \"0c17\",\n    \"client_version\": \"4c540126\",\n    \"request_type\": \"ping\",\n    \"request\": {\n      \"id\": \"41aff1580119f074e2f537f231f12adf684f0d1f\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Reply Matching Rule - Transfer complete\nDESCRIPTION: This rule matches the reply string indicating that a transfer is complete.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.reply; content:\"Transfer complete.\";` sid: 2;)\n```\n\n----------------------------------------\n\nTITLE: Threshold Configuration Syntax\nDESCRIPTION: This defines the syntax for configuring thresholds using 'threshold'. It allows setting thresholds, limits, or both, tracking by source, destination, rule, both, or flow.  The count and seconds parameters control when the threshold is triggered.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nthreshold gen_id <gid>, sig_id <sid>, type <threshold|limit|both>, \\\n  track <by_src|by_dst|by_rule|by_both|by_flow>, count <N>, seconds <T>\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Bidirectional Traffic Alert (TCP)\nDESCRIPTION: This Suricata rule creates two alerts for TCP traffic in both directions between the specified IP addresses and ports. Suricata duplicates the rule to cover both directions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp 1.2.3.4 any -> 5.6.7.8 80\nalert tcp 5.6.7.8 80 -> 1.2.3.4 any\n```\n\n----------------------------------------\n\nTITLE: Analyzing DCERPC App Layer Transaction Rule - JSON\nDESCRIPTION: This JSON provides the analysis of a Suricata rule focused on DCERPC application layer transactions. It contains details about the rule's ID, message, application protocol (dcerpc), requirement (flow), and type (app_tx).  The \"engines\" section details the \"dce_stub_data\" engine in both toclient and toserver directions. It specifies matching criteria, including content pattern \"abc\", byte_extract and byte_test operations. The \"relative_next\" property indicates the content matching should proceed relative to the previous match.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"raw\": \"alert tcp any any -> any any (msg:\\\"byte_extract with dce\\\"; dcerpc.stub_data; content:\\\"abc\\\"; byte_extract:4,0,var,relative; byte_test:4,>,var,4,little; sid:902;)\",\n      \"id\": 902,\n      \"gid\": 1,\n      \"rev\": 0,\n      \"msg\": \"byte_extract with dce\",\n      \"app_proto\": \"dcerpc\",\n      \"requirements\": [\n        \"flow\"\n      ],\n      \"type\": \"app_tx\",\n      \"flags\": [\n        \"src_any\",\n        \"dst_any\",\n        \"sp_any\",\n        \"dp_any\",\n        \"applayer\",\n        \"toserver\",\n        \"toclient\",\n        \"prefilter\"\n      ],\n      \"pkt_engines\": [],\n      \"frame_engines\": [],\n      \"engines\": [\n        {\n          \"name\": \"dce_stub_data\",\n          \"direction\": \"toclient\",\n          \"is_mpm\": true,\n          \"app_proto\": \"dcerpc\",\n          \"progress\": 0,\n          \"matches\": [\n            {\n              \"name\": \"content\",\n              \"content\": {\n                \"pattern\": \"abc\",\n                \"length\": 3,\n                \"nocase\": false,\n                \"negated\": false,\n                \"starts_with\": false,\n                \"ends_with\": false,\n                \"is_mpm\": true,\n                \"no_double_inspect\": false,\n                \"fast_pattern\": false,\n                \"relative_next\": true\n              }\n            },\n            {\n              \"name\": \"byte_extract\"\n            },\n            {\n              \"name\": \"byte_test\",\n              \"byte_test\": {\n                \"nbytes\": 4,\n                \"offset\": 4,\n                \"base\": \"unset\",\n                \"flags\": [\n                  \"little_endian\"\n                ]\n              }\n            }\n          ]\n        },\n        {\n          \"name\": \"dce_stub_data\",\n          \"direction\": \"toserver\",\n          \"is_mpm\": true,\n          \"app_proto\": \"dcerpc\",\n          \"progress\": 0,\n          \"matches\": [\n            {\n              \"name\": \"content\",\n              \"content\": {\n                \"pattern\": \"abc\",\n                \"length\": 3,\n                \"nocase\": false,\n                \"negated\": false,\n                \"starts_with\": false,\n                \"ends_with\": false,\n                \"is_mpm\": true,\n                \"no_double_inspect\": false,\n                \"fast_pattern\": false,\n                \"relative_next\": true\n              }\n            },\n            {\n              \"name\": \"byte_extract\"\n            },\n            {\n              \"name\": \"byte_test\",\n              \"byte_test\": {\n\n```\n\n----------------------------------------\n\nTITLE: Getting application layer protocol in Lua\nDESCRIPTION: This snippet retrieves the application layer protocol (`alproto`) from the flow as a string. If the `alproto` is unknown, it returns \"unknown\".  It also returns the alproto timestamp, transfer content, original protocol, and expected protocol for protocol changes/upgrades.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_6\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\nalproto, alproto_ts, alproto_tc, alproto_orig, alproto_expect = f:app_layer_proto()\n```\n\n----------------------------------------\n\nTITLE: BPF Capture Filter from File Example\nDESCRIPTION: This example demonstrates how to specify a BPF capture filter using a file. The filter `not host 1.2.3.4` is written to `capture-filter.bpf`, and then the `-F` option is used to tell Suricata to read the filter from the file. This allows for more complex filters to be easily managed and applied.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/ignoring-traffic.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\necho \"not host 1.2.3.4\" > capture-filter.bpf\nsuricata -i ens5f0 -F capture-filter.bpf\n```\n\n----------------------------------------\n\nTITLE: Setting File Permissions for Suricata Configuration Directory\nDESCRIPTION: These commands modify the group ownership and permissions of the /etc/suricata directory. They set the group to 'suricata' and grant read access to the group.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nchgrp -R suricata /etc/suricata\nchmod -R g+r /etc/suricata\n```\n\n----------------------------------------\n\nTITLE: IPFW Reinjection Rule\nDESCRIPTION: This YAML snippet configures Suricata to re-inject packets back into the IPFW firewall at a specified rule number. Ensure the reinjection rule comes after the rule that initially sends traffic to Suricata to prevent looping.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_61\n\nLANGUAGE: yaml\nCODE:\n```\nipfw:\n  ipfw-reinjection-rule-number: 5500\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP2 Dynamic Header Table Size\nDESCRIPTION: This keyword enables matching on the size of the HTTP2 Dynamic Headers Table. It uses an unsigned 64-bit integer and supports qualifiers like greater than (>), less than (<), and range (x-y).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http2-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nhttp2.size_update:1234;\nhttp2.size_update:>4096;\n```\n\n----------------------------------------\n\nTITLE: Configuring Napatech for Inline Operation in Suricata\nDESCRIPTION: This snippet demonstrates how to configure Napatech for inline operation within Suricata's configuration file.  Inline operation pairs ports, forwarding traffic received on one port to its peer port after inspection. Hardware bypass must be enabled for this configuration to take effect.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\nnapatech:\n  inline: enabled\n  ports[0-1, 2-3]\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Protocol Example\nDESCRIPTION: This example shows the 'http' protocol specified in a Suricata rule.  This tells Suricata to only apply this rule to HTTP traffic. The protocol is specified in the rule header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Frame Registration in SIP Parser (Rust)\nDESCRIPTION: This snippet shows how to register frames in the SIP parser using Rust. The frames are registered during the parsing of the input stream, identifying the type of traffic Suricata is inspecting.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet mut al = sl.al;\nif al.is_none() {\n    al = Some(AppLayerProto::new(AppProto::SIP));\n}\nlet mut al = al.unwrap();\n\nlet flow = sl.flow;\n\nif let Some(req) = Request::parse(sl) {\n    al.register_frame(flow, sl, 0, req.buf.len() as i64, FrameType::Pdu);\n    al.register_frame(flow, sl, 0, req.buf.len() as i64, FrameType::Request);\n\n    sl.al = Some(al);\n    return Some(req);\n} else if let Some(resp) = Response::parse(sl) {\n    al.register_frame(flow, sl, 0, resp.buf.len() as i64, FrameType::Pdu);\n    al.register_frame(flow, sl, 0, resp.buf.len() as i64, FrameType::Response);\n\n    sl.al = Some(al);\n    return Some(resp);\n}\n\nsl.al = Some(al);\n\nNone\n```\n\n----------------------------------------\n\nTITLE: Registering IKE SA Parser Unit Test\nDESCRIPTION: This code shows how the `IKEChosenSaParserTest` unit test is registered using `UtRegisterTest` inside the `IKEChosenSaRegisterTests` function.  The registration is conditionally compiled based on the `UNITTESTS` macro.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-c.rst#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nvoid IKEChosenSaRegisterTests(void)\n{\n#ifdef UNITTESTS\n    UtRegisterTest(\"IKEChosenSaParserTest\", IKEChosenSaParserTest);\n#endif /* UNITTESTS */\n\n```\n\n----------------------------------------\n\nTITLE: Configuring LibHTP Settings\nDESCRIPTION: This YAML snippet configures LibHTP settings for Suricata. It sets the default configuration, including the personality and request/response body limits, to 0.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/md5.rst#_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\n  libhtp:\n    default-config:\n      personality: IDS\n      # Can be specified in kb, mb, gb.  Just a number indicates\n      # it's in bytes.\n      request-body-limit: 0\n      response-body-limit: 0\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP CIP Extended Status in Suricata Rules\nDESCRIPTION: The `enip.cip_extendedstatus` keyword is used to match the CIP extended status. For multiple service packets, it will match on any of the statuses seen. It uses a 16-bit unsigned integer as value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_extendedstatus:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_extendedstatus:>1;\n```\n\n----------------------------------------\n\nTITLE: HTTP Request Example\nDESCRIPTION: This example HTTP request illustrates the handling of duplicate Content-Length headers by Suricata in the `http_header` buffer. It shows how Suricata concatenates the values with a comma and a space.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nGET /test.html HTTP/1.1\nContent-Length: 44\nAccept: */*\nContent-Length: 55\n```\n\n----------------------------------------\n\nTITLE: Installing Kernel Development Tools on Red Hat\nDESCRIPTION: This shell command installs the kernel development tools, GCC, and make on a Red Hat based distribution. These tools are required to compile the Napatech kernel module and install the software.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ yum install kernel-devel-$(uname -r) gcc make\n\t$ ./package_install_3gd.sh\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP headers with strip_pseudo_headers - Suricata Rule\nDESCRIPTION: This Suricata rule uses `strip_pseudo_headers` to remove HTTP/2 pseudo-headers, ensuring the rule focuses on standard headers. It checks for a specific User-Agent in the HTTP headers after stripping pseudo headers.  The rule uses `bsize` to limit the buffer size and `nocase` for case-insensitive matching.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (msg:\"HTTP ua only\"; http.header_names; \\\n   bsize:16; content:\"|0d 0a|User-Agent|0d 0a 0d 0a|\"; nocase; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Running Suricata with WinDivert in Forward Mode\nDESCRIPTION: This command runs Suricata with WinDivert in `NETWORK_FORWARD` mode, typically used on a gateway to protect the network behind it. It requires a configuration file (`suricata.yaml`) and a WinDivert filter string to define the traffic to be inspected.  This mode operates at layer 4.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-windows.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c suricata.yaml --windivert-forward [filter string]\n```\n\n----------------------------------------\n\nTITLE: Erasing all Iptables rules\nDESCRIPTION: This command flushes all rules from all iptables chains, effectively removing any configured firewall rules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -F\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Content Modifier HTTP URI Inspection\nDESCRIPTION: This Suricata rule looks for the pattern 'index.php' within the HTTP URI buffer. The 'http_uri' keyword acts as a content modifier, directing the content check to the HTTP URI.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (content:\"index.php\"; http_uri; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Example Suricata Ruleset Profiling Workflow\nDESCRIPTION: This example demonstrates a typical workflow for profiling Suricata ruleset performance. It starts profiling, waits for 30 seconds, stops profiling, and then dumps the profiling data using the suricatasc command-line tool.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/rule-profiling.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nsuricatasc -c ruleset-profile-start\nsleep 30\nsuricatasc -c ruleset-profile-stop\nsuricatasc -c ruleset-profile\n```\n\n----------------------------------------\n\nTITLE: Matching SIP User-Agent Header in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to match the SIP User-Agent header in a Suricata rule. The `sip.user_agent` keyword is used to inspect the User-Agent header field. The `content` option should contain the value of the User-Agent header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.user_agent; content:\"Asterisk\"\n```\n\n----------------------------------------\n\nTITLE: Suppress Example\nDESCRIPTION: This provides an example of suppressing alerts for a specific signature (2002087) from a specific source host (209.132.180.67). This ensures that alerts from this source are suppressed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nsuppress gen_id 1, sig_id 2002087, track by_src, ip 209.132.180.67\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for File Logging in Lua\nDESCRIPTION: This code shows how to initialize the `needs` table for file logging. Set 'type' to 'file'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_44\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs['type'] = 'file'\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for HTTP Protocol in Lua (Output)\nDESCRIPTION: This code snippet illustrates how to initialize the `needs` table to enable HTTP protocol logging. The 'protocol' key is set to 'http', allowing the script to access HTTP protocol data for logging purposes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_4\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"protocol\"] = \"http\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: Displaying NIC Queue Information\nDESCRIPTION: Uses ethtool to display information about the available queues on a specific network interface (eth1). Understanding the number of available queues is important for configuring the number of worker threads in Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n/usr/local/sbin/ethtool -l eth1\n```\n\n----------------------------------------\n\nTITLE: Preloading tcmalloc on Fedora to Run Suricata\nDESCRIPTION: This command runs Suricata with tcmalloc preloaded using the LD_PRELOAD environment variable. This directs the dynamic linker to load libtcmalloc_minimal.so.4 before any other libraries, substituting the standard memory allocator with tcmalloc. It depends on the correct path to the tcmalloc library and the Suricata configuration file (suricata.yaml) and interface (eth0).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/tcmalloc.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nLD_PRELOAD=\"/usr/lib64/libtcmalloc_minimal.so.4\" suricata -c suricata.yaml -i eth0\n```\n\n----------------------------------------\n\nTITLE: Enabling Bypass for Encrypted Flows (YAML)\nDESCRIPTION: This YAML snippet configures Suricata to bypass encrypted TLS flows by setting the `encryption-handling` option to `bypass` within the app-layer TLS protocol configuration. This is a selective bypass configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n  app-layer:\n    protocols:\n      tls:\n        enabled: yes\n        detection-ports:\n          dp: 443\n  \n        encryption-handling: bypass\n```\n\n----------------------------------------\n\nTITLE: ARP Logging Example (Request)\nDESCRIPTION: This JSON snippet presents an example of an ARP request log entry captured by Suricata. It includes information about the hardware type, protocol type, opcode, source MAC address, source IP address, destination MAC address, and destination IP address. This log entry allows for the monitoring of ARP requests on the network.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_77\n\nLANGUAGE: JSON\nCODE:\n```\n  \"arp\": {\n    \"hw_type\": \"ethernet\",\n    \"proto_type\": \"ipv4\",\n    \"opcode\": \"request\",\n    \"src_mac\": \"00:1a:6b:6c:0c:cc\",\n    \"src_ip\": \"10.10.10.2\",\n    \"dest_mac\": \"00:00:00:00:00:00\",\n    \"dest_ip\": \"10.10.10.1\"\n  }\n```\n\n----------------------------------------\n\nTITLE: SHA-1 Hasher Usage in Lua\nDESCRIPTION: This code snippet demonstrates how to use the SHA-1 hasher in Lua. It initializes the hasher, updates it with multiple strings, and then finalizes the hash to get a hex string representation. This provides an example of incremental hashing.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/hashlib.rst#_snippet_2\n\nLANGUAGE: Lua\nCODE:\n```\nlocal hashing = require(\"suricata.hashing\")\nhasher = hashing.sha1()\nhasher.update(\"www.suricata\")\nhasher.update(\".io\")\nhash = hasher.finalize_to_hex()\n```\n\n----------------------------------------\n\nTITLE: Accessing Byte Variables\nDESCRIPTION: This Lua code demonstrates how to access byte variables in Suricata using the `SCByteVarGet()` function. It retrieves the values of the byte variables at indices 0 and 1 (corresponding to `var1` and `var2` respectively) and assigns them to local variables.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_54\n\nLANGUAGE: Lua\nCODE:\n```\nfunction match(args)\n    var1 = SCByteVarGet(0)\n    var2 = SCByteVarGet(1)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Priority Keyword\nDESCRIPTION: This demonstrates the syntax for the 'priority' keyword in a Suricata rule. The value is a number from 1 to 255, with lower numbers having higher priority. This overrides priority defined by the 'classtype'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\npriority:1;\n```\n\n----------------------------------------\n\nTITLE: Matching IKE Vendor ID - Suricata\nDESCRIPTION: This snippet demonstrates how to match a Vendor ID against a list of collected Vendor IDs using the `ike.vendor` keyword.  It utilizes content matching with the hexadecimal representation of the vendor ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ike-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nike.vendor:4a131c81070358455c5728f20e95452f;\n```\n\n----------------------------------------\n\nTITLE: Registering Tenant Handlers for VLANs via Unix Socket\nDESCRIPTION: These commands show how to register tenant handlers for VLANs via the Suricata Unix socket. The `register-tenant-handler` command takes the tenant ID and VLAN ID as arguments.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/multi-tenant.rst#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nregister-tenant-handler 1 vlan 1000\n```\n\n----------------------------------------\n\nTITLE: Stop Ruleset Profiling in Suricata\nDESCRIPTION: This command stops the ruleset profiling in Suricata.  Profiling must be enabled at compile time using the `--enable-profiling-rules` flag. This command is sent via the Suricata unix socket.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/rule-profiling.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nsuricatasc -c ruleset-profile-stop\n```\n\n----------------------------------------\n\nTITLE: Start Ruleset Profiling in Suricata\nDESCRIPTION: This command starts the ruleset profiling in Suricata.  Profiling must be enabled at compile time using the `--enable-profiling-rules` flag. This command is sent via the Suricata unix socket.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/rule-profiling.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nsuricatasc -c ruleset-profile-start\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file size smaller than\nDESCRIPTION: This Suricata rule demonstrates matching a file with a size smaller than a specified value using the `filesize` keyword. It alerts if a file is smaller than 100 megabytes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_19\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesize:<100MB;\n```\n\n----------------------------------------\n\nTITLE: Configuring NIC for RSS queues and symmetric hashing (NUMA aware)\nDESCRIPTION: Resets the NIC, sets up RSS queues, enables load balancing, and inserts a low-entropy Toeplitz key for symmetric hashing on a higher-end NIC (eth1) based on the detected number of cores per NUMA node. Disables receive and transmit offloading, disables adaptive control, and sets the ring RX descriptor size.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nrmmod i40e && modprobe i40e\nifconfig eth1 down\n/usr/local/sbin/ethtool -L eth1 combined 36\n/usr/local/sbin/ethtool -K eth1 rxhash on\n/usr/local/sbin/ethtool -K eth1 ntuple on\nifconfig eth1 up\n./set_irq_affinity local eth1\n/usr/local/sbin/ethtool -X eth1 hkey 6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A:6D:5A equal 36\n/usr/local/sbin/ethtool -A eth1 rx off tx off\n/usr/local/sbin/ethtool -C eth1 adaptive-rx off adaptive-tx off rx-usecs 125\n/usr/local/sbin/ethtool -G eth1 rx 1024\nfor proto in tcp4 udp4 tcp6 udp6; do\n    echo \"/usr/local/sbin/ethtool -N eth1 rx-flow-hash $proto sdfn\"\n    /usr/local/sbin/ethtool -N eth1 rx-flow-hash $proto sdfn\n done\n```\n\n----------------------------------------\n\nTITLE: Logging Streaming Buffer Data\nDESCRIPTION: This Lua code logs data from a streaming buffer, indicating the direction of the data flow. It uses `SCStreamingBuffer()` to retrieve the data chunk, open/close flags, and direction indicators (sb_ts, sb_tc).  It includes a `hex_dump` function (not provided in the document) for displaying the data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_47\n\nLANGUAGE: Lua\nCODE:\n```\nfunction log(args)\n    -- sb_ts and sb_tc are bools indicating the direction of the data\n    data, sb_open, sb_close, sb_ts, sb_tc = SCStreamingBuffer()\n    if sb_ts then\n      print(\"->\")\n    else\n      print(\"<-\")\n    end\n    hex_dump(data)\nend\n```\n\n----------------------------------------\n\nTITLE: Perf Top Command for Suricata\nDESCRIPTION: This command uses perf to profile Suricata's performance by sampling the active process. It requires perf to be installed and debug symbols for Suricata to be available. The process ID is obtained using pidof.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/analysis.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo perf top -p $(pidof suricata)\n```\n\n----------------------------------------\n\nTITLE: Regular FTP Log Example\nDESCRIPTION: This JSON snippet illustrates a regular FTP log entry. It shows the 'command' (e.g., 'RETR'), 'command_data', 'reply' (an array of reply lines), and 'completion_code' (an array of completion codes corresponding to the reply lines).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_22\n\nLANGUAGE: json\nCODE:\n```\n  \"ftp\": {\n    \"command\": \"RETR\",\n    \"command_data\": \"100KB.zip\",\n    \"reply\": [\n      \"Opening BINARY mode data connection for 100KB.zip (102400 bytes).\",\n      \"Transfer complete.\"\n    ],\n    \"completion_code\": [\n      \"150\",\n      \"226\"\n    ],\n```\n\n----------------------------------------\n\nTITLE: DNS Response Alert Logging Format (Suricata 7.0)\nDESCRIPTION: This JSON snippet shows the DNS response alert logging format in Suricata 7.0.  The 'answer' key contains the DNS response details including version, type, id, flags, qr, rd, ra, opcode, rrname, rrtype, and rcode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"alert\",\n  \"dns\": {\n    \"answer\": {\n      \"version\": 2,\n      \"type\": \"answer\",\n      \"id\": 0,\n      \"flags\": \"8180\",\n      \"qr\": true,\n      \"rd\": true,\n      \"ra\": true,\n      \"opcode\": 0,\n      \"rrname\": \"www.suricata.io\",\n      \"rrtype\": \"A\",\n      \"rcode\": \"NOERROR\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting DNS transaction object in Lua\nDESCRIPTION: This code shows how to obtain the current DNS transaction object within a Suricata Lua script using `dns.get_tx()`. It also includes error handling to check if the transaction retrieval was successful.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_3\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx, err = dns.get_tx()\nif tx == err then\n    print(err)\nend\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: vlan.id equal to 200 at layer 1 with prefilter\nDESCRIPTION: This Suricata rule demonstrates using `vlan.id` with the `prefilter` keyword. The rule alerts if the VLAN ID at layer 1 is equal to 200 and uses the result for fast pattern matching. This will improve the rule's performance.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"Vlan ID is equal to 200 at layer 1\"; vlan.id:200,1; prefilter; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Basic Suricata Compilation from Source\nDESCRIPTION: This snippet shows the basic steps to compile and install Suricata from source. It involves extracting the source archive, navigating to the source directory, configuring the build, compiling, and installing the software. This will install Suricata into /usr/local/bin/.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_0\n\nLANGUAGE: none\nCODE:\n```\ntar xzvf suricata-7.0.0.tar.gz\ncd suricata-7.0.0\n./configure\nmake\nmake install\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Opcode greater than value in Suricata\nDESCRIPTION: This example demonstrates matching the WebSocket opcode using the greater than operator. `websocket.opcode` uses an unsigned 8-bits integer.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.opcode:>8;\n```\n\n----------------------------------------\n\nTITLE: Getting DNS queries in Lua\nDESCRIPTION: This example illustrates how to retrieve the 'queries' section of a DNS request or response using the `queries()` method. It iterates through the queries, extracting and printing the rrname and rrtype values.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_6\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nlocal queries = tx:queries();\nif queries ~= nil then\n    for n, t in pairs(queries) do\n        rrname = t[\"rrname\"]\n        rrtype = t[\"type\"]\n\n        print (\"QUERY: \" .. ts .. \" \" .. rrname .. \" [**] \" .. rrtype .. \" [**] \" ..\n               \"TODO\" .. \" [**] \" .. srcip .. \":\" .. sp .. \" -> \" ..\n               dstip .. \":\" .. dp)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Extracting Domain Name from TLS SNI - Suricata Rule\nDESCRIPTION: This rule extracts the domain name from the TLS Server Name Indication (SNI) using the `domain` transformation. It then checks if the extracted domain is present in the `domains.lst` dataset.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tls any any -> any any (tls.sni; domain; \\\n    dataset:isset,domains,type string,load domains.lst; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Iptables Rules: Checking TCP Traffic\nDESCRIPTION: These iptables rules insert rules to send only TCP traffic to the NFQUEUE. The `-p tcp` option filters traffic based on the TCP protocol.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo iptables -I INPUT -p tcp  -j NFQUEUE\nsudo iptables -I OUTPUT -p tcp -j NFQUEUE\n```\n\n----------------------------------------\n\nTITLE: Legacy TLS IssuerDN Matching in Suricata\nDESCRIPTION: This example shows the legacy keyword `tls.issuerdn` used to match the IssuerDN field of a TLS/SSL certificate in Suricata. It is case-sensitive and does not support modifiers. `tls.cert_issuer` is the recommended replacement.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/tls-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ntls.issuerdn:!\"CN=Google-Internet-Authority\"\n```\n\n----------------------------------------\n\nTITLE: Testing a Specific Rust Module\nDESCRIPTION: This command runs the unit tests specifically for the `http2` module within the Suricata Rust code. It compiles the Rust side of Suricata and executes the unit tests defined in the `http2` module.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-rust.rst#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ncargo test http2\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Action Example\nDESCRIPTION: This example shows the 'alert' action in a Suricata rule. The 'alert' action triggers an alert when the rule matches a packet.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP GET Request Containing Rule in URI\"; flow:established,to_server; http.method; content:\"GET\"; http.uri; content:\"rule\"; fast_pattern; classtype:bad-unknown; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Checking Suricata Build Information and Service Status\nDESCRIPTION: Checks the installed Suricata version and build options using `suricata --build-info`. Verifies the Suricata service status with `systemctl status suricata`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nsudo suricata --build-info\nsudo systemctl status suricata\n```\n\n----------------------------------------\n\nTITLE: Braces example 2\nDESCRIPTION: Example of proper brace placement for control statements and loops.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nif (unlikely(len < ETHERNET_HEADER_LEN)) {\n    ENGINE_SET_INVALID_EVENT(p, ETHERNET_PKT_TOO_SMALL);\n    return TM_ECODE_FAILED;\n}\n\nfor (ascii_code = 0; ascii_code < 256; ascii_code++) {\n    ctx->goto_table[ctx->state_count][ascii_code] = SC_AC_FAIL;\n}\n\nwhile (funcs != NULL) {\n    temp = funcs;\n    funcs = funcs->next;\n    SCFree(temp);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Packet Payload in Lua\nDESCRIPTION: Retrieves the payload of the packet as a string.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_8\n\nLANGUAGE: Lua\nCODE:\n```\npayload = p:payload()\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email Message-ID Field\nDESCRIPTION: This Suricata rule will generate an alert if the 'Message-Id' field in an SMTP packet's MIME data matches the provided value.  The rule leverages the 'email.message_id' keyword, focusing on the unique message identifier.  The 'content' option determines the specific value to match. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_5\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email message id\"; email.message_id; content:\"<alpine.DEB.2.00.1311261630120.9535@sd-26634.dedibox.fr>\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Transactional HTTP Alert with Directional Content Type\nDESCRIPTION: This Suricata rule matches HTTP traffic to 5.6.7.8 on port 80 and examines the content type. It looks for \"json\" in the content type of the request (to_server) and \"xml\" in the content type of the response (to_client).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any => 5.6.7.8 80 (msg:\"matching json to server and xml to client\"; sid: 1; http.content_type: to_server; content: \"json\"; http.content_type: to_client; content: \"xml\";)\n```\n\n----------------------------------------\n\nTITLE: Compiling Suricata with Myricom libpcap\nDESCRIPTION: This command configures Suricata to use the Myricom libpcap libraries and includes, specifying the installation prefix, configuration directory, and local state directory. It allows Suricata to interface with the Myricom capture card through its libpcap implementation. The ``make`` and ``sudo make install`` commands build and install Suricata after configuration.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/myricom.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --with-libpcap-includes=/opt/snf/include/ --with-libpcap-libraries=/opt/snf/lib/ --prefix=/usr --sysconfdir=/etc --localstatedir=/var\nmake\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata to Run as a Specific User in YAML\nDESCRIPTION: This YAML snippet configures Suricata to run as the 'suricata' user and group. This configuration should be placed in the Suricata configuration file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nrun-as:\n  user: suricata\n  group: suricata\n```\n\n----------------------------------------\n\nTITLE: TFTP Logging Example (JSON)\nDESCRIPTION: This example illustrates the JSON structure for TFTP logging. It includes fields like packet (operation code), file (filename), and mode, capturing details of TFTP transactions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_28\n\nLANGUAGE: json\nCODE:\n```\n{\n      \"packet\": \"write\",\n      \"file\": \"rfc1350.txt\",\n      \"mode\": \"octet\"\n   }\n```\n\n----------------------------------------\n\nTITLE: File Permissions Configuration for EVE JSON Output\nDESCRIPTION: This snippet configures the file permissions for the EVE JSON output file using the `filemode` option. The example sets the permissions to 600, which means only the owner can read and write the file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_10\n\nLANGUAGE: Config\nCODE:\n```\n  outputs:\n    - eve-log:\n        enabled: yes\n        filename: eve.json\n        filemode: 600\n```\n\n----------------------------------------\n\nTITLE: Bypassing HTTP traffic in Suricata rule\nDESCRIPTION: This Suricata rule demonstrates how to use the `bypass` keyword to exclude HTTP traffic containing \"suricata.io\" in the HTTP host from further inspection. The `bypass` keyword, which is a post-match keyword, is used to improve performance by avoiding unnecessary analysis of high-volume traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/bypass-keyword.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> any any (http.host; \\\n  content:\"suricata.io\"; :example-rule-emphasis:`bypass;` \\\n  sid:10001; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Email Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.email` keyword to match the email field in an SDP request or response. The `content` keyword specifies the email address string to search for, which follows the SDP email (e=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.email; content:\"j.doe@example.com (Jane Doe)\";\n```\n\n----------------------------------------\n\nTITLE: Installing Suricata on Arch Linux\nDESCRIPTION: This command uses the `yay` AUR helper to install the Suricata package on Arch Linux. It assumes that `yay` is already installed and configured. This command installs suricata from the Arch User Repository.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nyay -S suricata\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Example: Protocol Detection\nDESCRIPTION: This is an example Suricata rule that leverages automatic protocol detection, specifically for HTTP traffic.  Note how 'any' can be used for port specification. This rule demonstrates the recommended way to write Suricata rules for HTTP detection, where a specific port or list of ports is not required.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nalert http $HOME_NET -> $EXTERNAL_NET any ...\n```\n\n----------------------------------------\n\nTITLE: Getting DNS authorities in Lua\nDESCRIPTION: This code snippet shows how to retrieve the 'authorities' section of a DNS response using the `authorities()` method on the transaction object.  It iterates through the authority records, extracting and printing the rrname, rrtype, and ttl values.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_5\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nlocal authorities = tx:authorities();\nif authorities ~= nil then\n    for n, t in pairs(authorities) do\n        rrname = t[\"rrname\"]\n        rrtype = t[\"type\"]\n        ttl = t[\"ttl\"]\n         print (\"AUTHORITY: \" .. ts .. \" \" .. rrname .. \" [**] \" .. rrtype .. \" [**] \" ..\n               ttl .. \" [**] \" .. srcip .. \":\" .. sp .. \" -> \" ..\n               dstip .. \":\" .. dp)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Multiline Macro Definition\nDESCRIPTION: Example of a multiline macro definition. Note the escape character is aligned right-most at ColumnLimit.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_27\n\nLANGUAGE: c\nCODE:\n```\n#define MULTILINE_DEF(a, b)                                              \\\n    if ((a) > 2) {                                                       \\\n        auto temp = (b) / 2;                                             \\\n        (b) += 10;                                                       \\\n        someFunctionCall((a), (b));                                      \\n    }\n```\n\n----------------------------------------\n\nTITLE: Formatting code in staging\nDESCRIPTION: This bash script formats changes in staging using git clang-format. It can also force formatting of unstaged changes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ git clang-format\n# Or with script:\n$ scripts/clang-format.sh cached\n```\n\n----------------------------------------\n\nTITLE: Matching SDP Session Info Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.session_info` keyword to match the session information field in an SDP request or response. The `content` keyword specifies the session information string to search for, which follows the SDP Session information (i=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.session_info; content:\"Session Description Protocol\";\n```\n\n----------------------------------------\n\nTITLE: Logging HTTP2 Settings Frame (JSON)\nDESCRIPTION: This example demonstrates the JSON format for logging HTTP/2 settings frames. The settings parameter describes what is being sent.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_65\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"http2\": {\n    \"request\": {\n      \"settings\": [\n        {\n          \"settings_id\": \"SETTINGSMAXCONCURRENTSTREAMS\",\n          \"settings_value\": 100\n        },\n        {\n          \"settings_id\": \"SETTINGSINITIALWINDOWSIZE\",\n          \"settings_value\": 65535\n        }\n      ]\n    },\n    \"response\": {}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Inspection Limits and SWF Decompression\nDESCRIPTION: This snippet presents YAML configurations for HTTP inspection limits and SWF decompression within Suricata's libhtp.  It includes settings for minimal inspect size, inspect window, inline HTTP body handling, and detailed settings for SWF decompression (enabled, type, compress depth, decompress depth).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_39\n\nLANGUAGE: yaml\nCODE:\n```\n#   response-body-decompress-layer-limit:\n#                           Limit to how many layers of compression will be\n#                           decompressed. Defaults to 2.\n\n#   uri-include-all:        Include all parts of the URI. By default the\n#                           'scheme', username/password, hostname and port\n#                           are excluded.\n\n#   meta-field-limit:       Hard size limit for request and response size\n#                           limits.\n\n# inspection limits\n    request-body-minimal-inspect-size: 32kb\n    request-body-inspect-window: 4kb\n    response-body-minimal-inspect-size: 40kb\n    response-body-inspect-window: 16kb\n\n# auto will use http-body-inline mode in IPS mode, yes or no set it statically\n    http-body-inline: auto\n\n# Decompress SWF files.\n# 2 types: 'deflate', 'lzma', 'both' will decompress deflate and lzma\n# compress-depth:\n# Specifies the maximum amount of data to decompress,\n# set 0 for unlimited.\n# decompress-depth:\n# Specifies the maximum amount of decompressed data to obtain,\n# set 0 for unlimited.\n    swf-decompression:\n      enabled: yes\n      type: both\n      compress-depth: 0\n      decompress-depth: 0\n```\n\n----------------------------------------\n\nTITLE: Analyzing PCAP File with Custom Rule File\nDESCRIPTION: This command shows how to analyze a PCAP file using a custom rule file. The `-r` flag specifies the path to the PCAP file, and the `-S` flag specifies the path to the custom rule file. Suricata will use the rules in the specified file when analyzing the PCAP data. Requires suricata installation, a valid pcap file, and a valid suricata rules file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/manpages/suricata.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -r /pcap/to/capture.pcap -S /path/to/custom.rules\n```\n\n----------------------------------------\n\nTITLE: Retrieving JA3S Hash for Logging in Lua\nDESCRIPTION: This code demonstrates how to retrieve the JA3S hash using `Ja3SGetHash()` and provides an example use case for logging purposes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_31\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    hash = Ja3SGetHash()\n    if hash == nil then\n        return\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Matching TLD with dotprefix and endswith - Suricata Rule\nDESCRIPTION: This example shows how to match a specific top-level domain (TLD) using `dotprefix` and `endswith`. The rule will match on domains ending in `.co.uk`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert dns any any -> any any (dns.query; dotprefix; \\\n    content:\".co.uk\"; endswith; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Testing DNS Parser Functionality in Rust\nDESCRIPTION: This Rust code snippet demonstrates a unit test for the ``dns_parse_name`` function within the Suricata DNS parser.  It defines a raw byte array representing a DNS name and asserts that parsing this array yields the expected name string and the correct unparsed remainder. The test checks the function's ability to correctly parse a simple DNS name without pointers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/testing.rst#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n    /// Parse a simple name with no pointers.\n    #[test]\n    fn test_dns_parse_name() {\n        let buf: &[u8] = &[\n                                                0x09, 0x63, /* .......c */\n            0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2d, 0x63, 0x66, /* lient-cf */\n            0x07, 0x64, 0x72, 0x6f, 0x70, 0x62, 0x6f, 0x78, /* .dropbox */\n            0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, /* .com.... */\n        ];\n        let expected_remainder: &[u8] = &[0x00, 0x01, 0x00];\n        let (remainder,name) = dns_parse_name(buf, buf).unwrap();\n        assert_eq!(\"client-cf.dropbox.com\".as_bytes(), &name[..]);\n        assert_eq!(remainder, expected_remainder);\n    }\n```\n\n----------------------------------------\n\nTITLE: Building and Installing libbpf (Bash)\nDESCRIPTION: This code snippet builds and installs the `libbpf` library from source.  It navigates into the source directory, compiles the library using `make`, installs the library and headers, and configures `ldconfig` to find the installed library.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n cd libbpf/src/\n make && sudo make install\n\n sudo make install_headers\n sudo ldconfig\n```\n\n----------------------------------------\n\nTITLE: Creating a local rule file for Suricata\nDESCRIPTION: These commands demonstrate how to create a new rules file, 'local.rules', using either 'nano' or 'vim' text editors. The 'sudo' command is used to gain administrative privileges to create and modify the file in a system directory. The user needs to choose one editor to create the rule file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/adding-your-own-rules.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo nano local.rules\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo vim local.rules\n```\n\n----------------------------------------\n\nTITLE: Compiling Suricata - Bash\nDESCRIPTION: This command compiles the Suricata source code using the Makefiles generated by the configure script. It builds the Suricata executable and libraries.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Monitor Stats with jq\nDESCRIPTION: This command monitors the decoder statistics from the eve.json file. It filters for events of type \"stats\" and extracts the \"decoder\" field from the \"stats\" object.  The -c flag outputs compact JSON.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-examplesjq.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntail -f eve.json | jq -c 'select(.event_type==\"stats\")|.stats.decoder'\n```\n\n----------------------------------------\n\nTITLE: Run Suricata with PCAP file (Generic)\nDESCRIPTION: This snippet provides a generic example of running Suricata with a PCAP file using the `-r` option and specifying a configuration file using the `-c` option. Replace `log.pcap.(followed by the number/name of your pcap)` with the correct PCAP filename.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-profiling.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c /etc/suricata/suricata.yaml -r log.pcap.(followed by the number/name of your pcap)\n```\n\n----------------------------------------\n\nTITLE: DNS Response Alert Logging Format (Suricata 8.0)\nDESCRIPTION: This JSON snippet shows the DNS response alert logging format in Suricata 8.0.  The type is now 'response', and queries are logged within a 'queries' array, and answers in the 'answers' array. Version 3 is added and includes the tx_id field. Relevant fields include event_type, dns.version, dns.type, dns.tx_id, dns.id, dns.flags, dns.qr, dns.rd, dns.ra, dns.opcode, dns.rcode, dns.queries, and dns.answers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"alert\",\n  \"dns\": {\n    \"version\": 3,\n    \"type\": \"response\",\n    \"tx_id\": 1,\n    \"id\": 0,\n    \"flags\": \"8180\",\n    \"qr\": true,\n    \"rd\": true,\n    \"ra\": true,\n    \"opcode\": 0,\n    \"rcode\": \"NOERROR\",\n    \"queries\": [\n      {\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"A\"\n    ],\n    \"answers\": [\n      {\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"CNAME\",\n        \"ttl\": 3597,\n        \"rdata\": \"suricata.io\"\n      },\n      {\n        \"rrname\": \"suricata.io\",\n        \"rrtype\": \"A\",\n        \"ttl\": 597,\n        \"rdata\": \"35.212.0.44\"\n      }\n    ]\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Pointer Alignment Example\nDESCRIPTION: This C code snippet demonstrates right alignment for pointers in declarations. Pointers should be right-aligned for readability.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nvoid *ptr;\nvoid f(int *a, const char *b);\nvoid (*foo)(int *);\n```\n\n----------------------------------------\n\nTITLE: Flow control example - unnecessary branching\nDESCRIPTION: This C code snippet demonstrates how to avoid unnecessary branching by removing the else statement.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nif (error) {\n    goto error;\n}\n\na = b;\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration Example\nDESCRIPTION: Example showing the naming convention for variables (named_like_this) and demonstrates initializing a variable.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_25\n\nLANGUAGE: c\nCODE:\n```\nSCConfNode *parent_node = root;\n```\n\n----------------------------------------\n\nTITLE: Configuring IP Reputation Categories File in Suricata\nDESCRIPTION: This configuration specifies the file path for the IP reputation categories, mapping numbered category values to short names.  The file should be a plain text file following the required format. Changes to this file require a Suricata restart.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/reputation/ipreputation/ip-reputation-config.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nreputation-categories-file: /etc/suricata/iprep/categories.txt\n```\n\n----------------------------------------\n\nTITLE: LDAP Response Attribute Type Matching\nDESCRIPTION: This Suricata rule alerts if an LDAP packet has the attribute type \"dc\" in a response. The `ldap.responses.attribute_type` keyword is a sticky buffer and supports `fast_pattern`. Comparison is case-sensitive.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_20\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test responses attribute type\"; :example-rule-emphasis:`ldap.responses.attribute_type; content:\"dc\";` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Disabling CPU Maps and Per CPU Hash in eBPF - C\nDESCRIPTION: This snippet disables CPU maps and per-CPU hash in the eBPF code. This is necessary because CPU maps and interface redirects are not supported in Linux 4.19 and per CPU hash should not be used on the Netronome card architecture. These settings are adjusted at the beginning of the `ebpf/xdp_filter.c` file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\n #define BUILD_CPUMAP        0\n /* Increase CPUMAP_MAX_CPUS if ever you have more than 64 CPUs */\n #define CPUMAP_MAX_CPUS     64\n\n #define USE_PERCPU_HASH    0\n #define GOT_TX_PEER    0\n```\n\n----------------------------------------\n\nTITLE: SSH Transaction Completion State - Rust\nDESCRIPTION: This Rust code shows how the transaction completion state is set for SSH. Both `tx_comp_st_ts` and `tx_comp_st_tc` are set to `SSHConnectionState::SshStateFinished as i32`, indicating that the transaction is considered complete in both directions when the state reaches `SshStateFinished`. This utilizes the SSH connection state enum defined earlier.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\ntx_comp_st_ts: SSHConnectionState::SshStateFinished as i32,\ntx_comp_st_tc: SSHConnectionState::SshStateFinished as i32,\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Integer Greater Than or Equal Matching\nDESCRIPTION: This code snippet shows how to match an integer value that is greater than or equal to a specified value. `bsize:>=21;` means the rule will match if the value of the `bsize` field is greater than or equal to 21.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/integer-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nbsize:>=21;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule for Matching Email Received Field\nDESCRIPTION: This Suricata rule creates an alert when an SMTP packet's MIME header has a 'Received' field that matches the specified value.  The rule employs the 'email.received' keyword, focusing on the 'Received' field of the email.  The 'content' option determines the specific value to match. 'sid' is the rule ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/email-keywords.rst#_snippet_8\n\nLANGUAGE: suricata\nCODE:\n```\nalert smtp any any -> any any (msg:\"Test mime email received\"; email.received; content:\"from [65.201.218.30] (helo=COZOXORY.club)by 173-66-46-112.wash.fios.verizon.net with esmtpa (Exim 4.86)(envelope-from )id 71cF63a9for mirjam@abrakadabra.ch; Mon, 29 Jul 2019 17:01:45 +0000\"; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Loading Napatech Plugin in Suricata Configuration\nDESCRIPTION: This configuration snippet shows how to load the Napatech plugin in the `suricata.yaml` file.  The plugin path `/usr/lib/suricata/napatech.so` is specified under the `plugins` section. This step is necessary to enable Napatech capture support in Suricata 8.0 when upgrading from previous versions or doing a fresh install.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-napatech-plugin.rst#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nplugins:\n  - /usr/lib/suricata/napatech.so\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file name (filename keyword)\nDESCRIPTION: This Suricata rule example demonstrates the usage of `filename` keyword, which implicitly enables the `nocase` option. This rule is functionally equivalent to using `file.name` with the `nocase` modifier. The rule alerts when a filename \"examplefilename\" (case-insensitive) is found in network traffic.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_2\n\nLANGUAGE: Suricata\nCODE:\n```\nfilename:\"examplefilename\";\n```\n\n----------------------------------------\n\nTITLE: Matching SDP URI Field\nDESCRIPTION: This snippet demonstrates how to use the `sdp.uri` keyword to match the URI field in an SDP request or response. The `content` keyword specifies the URI string to search for, which follows the SDP URI (u=) scheme.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sdp-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nsdp.uri; content:\"https://www.sdp.proto\"\n```\n\n----------------------------------------\n\nTITLE: Filtering TCP and ICMP traffic with WinDivert\nDESCRIPTION: This command filters network traffic to include both TCP and ICMP packets using WinDivert. It requires a configuration file (`suricata.yaml`). The filter string `\"tcp or icmp\"` specifies that traffic matching either the TCP or ICMP protocol should be processed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-windows.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c suricata.yaml --windivert \"tcp or icmp\"\n```\n\n----------------------------------------\n\nTITLE: Correct Enum Definition\nDESCRIPTION: Example of a correct enum definition. Each value is on a separate line, with a trailing comma on the last element.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n// right\nenum {\n    VALUE_ONE,\n    VALUE_TWO, // <- force one-value-per-line\n};\n```\n\n----------------------------------------\n\nTITLE: DNS Request Alert Logging Format (Suricata 8.0)\nDESCRIPTION: This JSON snippet shows the DNS request alert logging format in Suricata 8.0. The type is now 'request', and queries are logged within a 'queries' array. Version 3 is added, with new fields like flags, rd, opcode and rcode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"alert\",\n  \"dns\": {\n    \"version\": 3,\n    \"type\": \"request\",\n    \"tx_id\": 0,\n    \"id\": 0,\n    \"flags\": \"100\",\n    \"rd\": true,\n    \"opcode\": 0,\n    \"rcode\": \"NOERROR\",\n    \"queries\": [\n      {\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"A\"\n      }\n    ],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching SIP Status Code in Suricata Rules\nDESCRIPTION: This snippet shows how to match the SIP status code in a Suricata rule. The `sip.stat_code` keyword is used to inspect the status code found in a SIP response. The `content` option should contain a valid SIP status code.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/sip-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nsip.stat_code; content:\"100\";\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Command Data Matching Rule with USER\nDESCRIPTION: This rule demonstrates matching `ftp.command_data` in conjunction with a specific FTP command (USER).\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (ftp.command; content: \"USER\"; :example-rule-options:`ftp.command_data; content:\"anonymous\";` sid: 1;)\n```\n\n----------------------------------------\n\nTITLE: Get Approved Pull Requests using GitHub CLI and jq\nDESCRIPTION: This command retrieves a list of approved pull requests using the GitHub CLI (`gh`) and processes the output with `jq`. The command first lists PRs with number and reviewDecision fields, searches for open PRs that are not drafts and lack reviews, and then filters the output to only include PRs where the reviewDecision is empty, indicating they are approved.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/github-pr-workflow.rst#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\ngh pr list --json number,reviewDecision --search \"state:open type:pr -review:none\" | jq '.[] | select(.reviewDecision==\"\")'\n```\n\n----------------------------------------\n\nTITLE: Getting Packet Destination Port in Lua\nDESCRIPTION: Retrieves the destination port of the packet as an integer, specifically for TCP, UDP, or SCTP. Returns `nil` for other protocols.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/packetlib.rst#_snippet_7\n\nLANGUAGE: Lua\nCODE:\n```\np = packet.get()\ndest_port = p:dp()\n-- not port 443\nif dest_port ~= 443 then\n    return 1\nend\n```\n\n----------------------------------------\n\nTITLE: Committing changes\nDESCRIPTION: This bash script commits the changes after using git-clang format.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ git commit --amend -a\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT SUBSCRIBE (JSON)\nDESCRIPTION: This example illustrates the JSON format for logging MQTT SUBSCRIBE messages. It contains information about the subscription, including qos, retain, dup, message_id, and an array of topics. Each topic entry contains the topic name and the requested QoS level.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_58\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"subscribe\": {\n    \"qos\": 1,\n    \"retain\": false,\n    \"dup\": false,\n    \"message_id\": 1,\n    \"topics\": [\n      {\n        \"topic\": \"topicX\",\n        \"qos\": 0\n      },\n      {\n        \"topic\": \"topicY\",\n        \"qos\": 0\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file name with nocase\nDESCRIPTION: This Suricata rule example demonstrates matching a filename using `file.name` with the `nocase` option. It achieves the same result as using the `filename` keyword. It alerts when a filename \"examplefilename\" (case-insensitive) is detected.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata\nCODE:\n```\nfile.name; content:\"examplefilename\"; nocase;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with fragoffset Keyword\nDESCRIPTION: This rule demonstrates the use of `fragoffset` keyword to match fragment offset values. It alerts if the fragment offset is greater than 0 and More Fragments bit is set.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_9\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"fragoffset keyword example invalid non-fragmented packet with fragment offset>0\"; fragbits:M; fragoffset:>0; classtype:bad-unknown; sid:13; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Decoding Base64 data with offset and mode - Suricata Rule\nDESCRIPTION: This rule decodes a Base64 encoded string starting at offset 6 using rfc4648 mode, and checks if the decoded output matches \"thisisatest\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_18\n\nLANGUAGE: Suricata\nCODE:\n```\ncontent:\"/?arg=dGhpc2lzYXRlc3QK\"; from_base64: offset 6, mode rfc4648; \\\n   content:\"thisisatest\";\n```\n\n----------------------------------------\n\nTITLE: Displaying Suricata Build Information (Prefix)\nDESCRIPTION: This command displays Suricata's build information, specifically focusing on the prefix, sysconfdir, localstatedir, and datarootdir settings.  This is useful for determining the installation locations for configuration files and data directories, which are crucial for upgrading.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ suricata --build-info|grep -A 3 '\\-\\-prefix'\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hassh Algorithms MD5 in Lua\nDESCRIPTION: This code retrieves the MD5 hash of the hassh algorithms used by the client via the `HasshGet` function in the Lua script, returns 0 when hassh is nil.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_40\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    hassh = HasshGet()\n    if hassh == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Service Name in Suricata Rules\nDESCRIPTION: The `enip.service_name` keyword is used to match the service name in list services messages. It can be combined with other keywords like `pcre` and `content`. It is a sticky buffer and can be used as `fast_pattern`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.service_name; pcre:\"/^123[0-9]*/\";\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.service_name; content:\"swordfish\";\n```\n\n----------------------------------------\n\nTITLE: Running Suricata as a Specific User via CLI Arguments\nDESCRIPTION: These command-line arguments specify the user and group Suricata will run as after initial startup. They can be used as alternatives to the configuration file settings.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/security.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n--user suricata --group suricata\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP Product Code in Suricata Rules\nDESCRIPTION: The `enip.product_code` keyword is used to match on the product code in the identity message. It uses a 16-bit unsigned integer as its value. This keyword helps in identifying the type of product.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_12\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.product_code:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.product_code:>1;\n```\n\n----------------------------------------\n\nTITLE: Cloning Suricata Repository (Bash)\nDESCRIPTION: This code snippet clones the Suricata source code from the OISF GitHub repository and initializes the submodule. It is the first step in building Suricata from source. The `bundle.sh` script initializes the submodules.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n git clone https://github.com/OISF/suricata.git\n cd suricata && ./scripts/bundle.sh\n```\n\n----------------------------------------\n\nTITLE: Example Reference to a CVE\nDESCRIPTION: This code shows a 'reference' keyword referencing a specific CVE (Common Vulnerabilities and Exposures) entry. This provides a direct link to vulnerability information, facilitating analysis.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nreference:cve,CVE-2014-1234\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Reference Example with CVE\nDESCRIPTION: This snippet demonstrates a Suricata rule referencing a Common Vulnerabilities and Exposures (CVE) identifier. This allows analysts to quickly find detailed information about a specific vulnerability associated with the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/make-sense-alerts.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n\"reference:cve,2009-3958;\"\n```\n\n----------------------------------------\n\nTITLE: Negating DNS Opcode Value in Suricata Rules\nDESCRIPTION: This snippet demonstrates how to negate matching a specific opcode value in the DNS header using the `dns.opcode` keyword in a Suricata rule.  The `!` character negates the match. The opcode is an unsigned 8-bit integer representing the type of query.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dns-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata Rule\nCODE:\n```\ndns.opcode:!0;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with ipopts Keyword\nDESCRIPTION: This example demonstrates the usage of the `ipopts` keyword to check for the presence of the timestamp option in an IP packet. It triggers an alert if the timestamp IP option is set.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_1\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip $EXTERNAL_NET any -> $HOME_NET any (msg:\"IP Packet with timestamp option\"; ipopts:ts; classtype:misc-activity; sid:2; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT CONNACK (JSON)\nDESCRIPTION: This example demonstrates the JSON structure for logging MQTT CONNACK messages. It contains fields like qos, retain, dup, session_present, return_code, and properties. It shows the fields and values associated with MQTT connection acknowledgement messages within Suricata's logging.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_55\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"connack\": {\n    \"qos\": 0,\n    \"retain\": false,\n    \"dup\": false,\n    \"session_present\": false,\n    \"return_code\": 0,\n    \"properties\": {\n      \"topic_alias_maximum\": 10\n    }\n  }\n  }\n```\n\n----------------------------------------\n\nTITLE: Suricata Flowint Counting Username Occurrences\nDESCRIPTION: This example demonstrates how to use `flowint` to count the number of times a specific username is seen in a network stream without generating alerts for each occurrence. It increments the `usernamecount` variable for each instance of \"jonkman\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/flow-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp any any -> any any (msg:\"Counting Usernames\"; content:\"jonkman\"; \\\n        flowint: usernamecount, +, 1; noalert;)\n```\n\n----------------------------------------\n\nTITLE: Installing Suricata - Bash\nDESCRIPTION: This command installs the compiled Suricata executable and libraries to the system. It requires sudo privileges. The second command updates the shared library cache.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nsudo make install\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo ldconfig\n```\n\n----------------------------------------\n\nTITLE: Matching HTTP Header Order with Distance\nDESCRIPTION: This Suricata rule checks for the presence of the 'User-Agent' header followed by the 'Host' header, without requiring them to be directly adjacent. It uses the `distance` keyword to specify a maximum distance between the matches. The flow keyword ensures server traffic is inspected.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_38\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $HOME_NET any -> $EXTERNAL_NET any (msg:\"HTTP Header Names Request \\\n  Example 4\"; flow:established,to_server; :example-rule-options:`http.header_names; \\\n  content:\"|0d 0a|Host|0d 0a|;\";` content:\"User-Agent|0d 0a|;\"; distance:-2; \\\n  classtype:bad-unknown; sid:114; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Auto-Setup with configure, make, install-full - Bash\nDESCRIPTION: This command configures, compiles, and installs Suricata, sets up the configuration file, and downloads the Emerging Threats ruleset.  It is a complete auto-setup process.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && make install-full\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP CIP Status in Suricata Rules\nDESCRIPTION: The `enip.cip_status` keyword is used to match on the CIP status, matching one of the statuses if multiple service packets are present. It utilizes an 8-bit unsigned integer as its value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_18\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_status:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.cip_status:>1;\n```\n\n----------------------------------------\n\nTITLE: Frame Callbacks Registration (Rust)\nDESCRIPTION: Frame callbacks are automatically inferred when deriving from the `AppLayerFrameType` trait in Rust, so no explicit registration is needed. The code shown here demonstrates how to obtain the frame ID by name and the FFI name from ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\npub extern \"C\" fn get_frame_id_by_name(name: *const libc::c_char) -> i32 {\n    let name = unsafe {\n        assert!(!name.is_null());\n        CStr::from_ptr(name)\n    };\n\n    let rname = name.to_str().unwrap();\n    match rname {\n        \"sip.pdu\" => FrameType::Pdu.into(),\n        \"sip.request\" => FrameType::Request.into(),\n        \"sip.response\" => FrameType::Response.into(),\n        _ => -1,\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn ffi_name_from_id(id: i32) -> *const libc::c_char {\n    let s = match id {\n        x if x == FrameType::Pdu.into() => CString::new(\"sip.pdu\").unwrap(),\n        x if x == FrameType::Request.into() => CString::new(\"sip.request\").unwrap(),\n        x if x == FrameType::Response.into() => CString::new(\"sip.response\").unwrap(),\n        _ => CString::new(\"unknown\").unwrap(),\n    };\n    s.into_raw()\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering only TCP traffic with WinDivert\nDESCRIPTION: This command filters network traffic to only include TCP packets using WinDivert. It requires a configuration file (`suricata.yaml`). The `--windivert tcp` argument specifies that only TCP traffic should be processed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-windows.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c suricata.yaml --windivert tcp\n```\n\n----------------------------------------\n\nTITLE: Registering a Suricata Plugin in C\nDESCRIPTION: This C code snippet demonstrates how to register a Suricata plugin using the `SCPluginRegister` function. It defines a `SCPlugin` struct containing the plugin's name, author, license, and initialization function. The `SCPluginRegister` function returns a pointer to this struct, making the plugin known to Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/plugins/c-json-filetype/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nconst SCPlugin PluginRegistration = {\n    .name = \"eve-filetype\",\n    .author = \"Jason Ish\",\n    .license = \"GPLv2\",\n    .Init = TemplateInit,\n};\n\nconst SCPlugin *SCPluginRegister() {\n    return &PluginRegistration;\n}\n```\n\n----------------------------------------\n\nTITLE: Example of 'gid' value in fast.log file\nDESCRIPTION: This snippet illustrates how the 'gid' (group ID) appears in Suricata's fast.log file. The 'gid' is used to group signatures and is primarily informational, influencing alert data. It is commonly set to the default value of 1.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_6\n\nLANGUAGE: log\nCODE:\n```\n07/12/2022-21:59:26.713297  [**] [1:123:1] HTTP GET Request Containing Rule in URI [**] [Classification: Potentially Bad Traffic] [Priority: 2] {TCP} 192.168.225.121:12407 -> 172.16.105.84:80\n```\n\n----------------------------------------\n\nTITLE: Logging Configuration Example - YAML\nDESCRIPTION: This YAML snippet demonstrates the logging configuration in Suricata, including setting the default log level, defining output formats (commented out), and configuring different output destinations (console, file, and syslog) with their respective parameters. It specifies whether each output is enabled, the log level, filename, syslog facility, and format.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/suricata-yaml.rst#_snippet_47\n\nLANGUAGE: yaml\nCODE:\n```\n  logging:\n    # The default log level, can be overridden in an output section.\n    # Note that debug level logging will only be emitted if Suricata was\n    # compiled with the --enable-debug configure option.\n    #\n    # This value is overridden by the SC_LOG_LEVEL env var.\n    default-log-level: notice\n\n    # The default output format.  Optional parameter, should default to\n    # something reasonable if not provided.  Can be overridden in an\n    # output section.  You can leave this out to get the default.\n    #\n    # This console log format value can be overridden by the SC_LOG_FORMAT env var.\n    #default-log-format: \"%D: %S: %M\"\n    #\n    # For the pre-7.0 log format use:\n    #default-log-format: \"[%i] %t [%S] - (%f:%l) <%d> (%n) -- \"\n\n    # A regex to filter output.  Can be overridden in an output section.\n    # Defaults to empty (no filter).\n    #\n    # This value is overridden by the SC_LOG_OP_FILTER env var.\n    default-output-filter:\n\n    # Define your logging outputs.  If none are defined, or they are all\n    # disabled you will get the default - console output.\n    outputs:\n    - console:\n        enabled: yes\n        # type: json\n    - file:\n        enabled: yes\n        level: info\n        filename: suricata.log\n        # format: \"[%i - %m] %z %d: %S: %M\"\n        # type: json\n    - syslog:\n        enabled: no\n        facility: local5\n        format: \"[%i] <%d> -- \"\n        # type: json\n```\n\n----------------------------------------\n\nTITLE: Extracting TLD from TLS SNI - Suricata Rule\nDESCRIPTION: This rule extracts the top-level domain (TLD) from the TLS Server Name Indication (SNI) using the `tld` transformation. It then checks if the extracted TLD is present in the `tlds.lst` dataset.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/transforms.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tls any any -> any any (tls.sni; tld; \\\n    dataset:isset,tlds,type string,load tlds.lst; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule with tos Keyword\nDESCRIPTION: This rule uses the `tos` keyword to match a specific TOS (Type of Service) value in the IP header. In this case it checks for a TOS value of 8.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ip any any -> any any (msg:\"tos keyword example tos value 8\"; flow:established; tos:8; classtype:not-suspicious; sid:123; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Complete SMB with NTLMSSP in JSON\nDESCRIPTION: This snippet showcases a more complete example of SMB (Server Message Block) data including NTLMSSP (NT LAN Manager Security Support Provider) information, along with request and response details. Fields include 'dialect', 'command', 'status', 'session_id', 'tree_id', 'ntlmssp', 'request' (with 'native_os' and 'native_lm'), and 'response' (with 'native_os' and 'native_lm').\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_45\n\nLANGUAGE: json\nCODE:\n```\n  \"smb\": {\n    \"id\": 3,\n    \"dialect\": \"NT LM 0.12\",\n    \"command\": \"SMB1_COMMAND_SESSION_SETUP_ANDX\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 2048,\n    \"tree_id\": 0,\n    \"ntlmssp\": {\n      \"domain\": \"VNET3\",\n      \"user\": \"administrator\",\n      \"host\": \"BLU\",\n      \"version\": \"60.230 build 13699 rev 188\"\n    },\n    \"request\": {\n      \"native_os\": \"Unix\",\n      \"native_lm\": \"Samba 3.9.0-SVN-build-11572\"\n    },\n    \"response\": {\n      \"native_os\": \"Windows (TM) Code Name \\\"Longhorn\\\" Ultimate 5231\",\n      \"native_lm\": \"Windows (TM) Code Name \\\"Longhorn\\\" Ultimate 6.0\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining a Metadata Keyword\nDESCRIPTION: This shows the syntax of the 'metadata' keyword. The format is free-form, but sticking to [key, value] pairs is recommended. Suricata can include these in eve alerts.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nmetadata: key value;\nmetadata: key value, key value;\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with Debugging Enabled\nDESCRIPTION: This command starts Suricata with debugging information enabled for the Myricom card. ``SNF_DEBUG_MASK=3`` enables debugging, and ``SNF_DEBUG_FILENAME`` specifies the output file for debug logs. The ``SNF_DATARING_SIZE`` and ``SNF_DESCRING_SIZE`` define the sizes of the respective rings, and ``SNF_NUM_RINGS`` sets the number of rings. The command then runs Suricata with the specified options.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/myricom.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nSNF_NUM_RINGS=16 SNF_DATARING_SIZE=17179869184 SNF_DESCRING_SIZE=4294967296 SNF_FLAGS=0x1 SNF_DEBUG_MASK=3 SNF_DEBUG_FILENAME=\"/tmp/snf.out\" suricata -c suricata.yaml -i eth5 --runmode=workers\n```\n\n----------------------------------------\n\nTITLE: Viewing Suricata Fast Log\nDESCRIPTION: Monitors the `fast.log` file for alerts using `tail -f`. This is used in conjunction with the `curl` command to trigger a specific Suricata rule.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\nsudo tail -f /var/log/suricata/fast.log\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with Netmap on FreeBSD 11\nDESCRIPTION: This command starts Suricata in Netmap mode on FreeBSD 11, where the interface is configured through the YAML file. This example uses the `--netmap` option without a specific interface, relying on the configuration in the `netmap` block in the Suricata YAML configuration file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --netmap\n```\n\n----------------------------------------\n\nTITLE: Adding GPL License Notices to a New Program\nDESCRIPTION: This snippet provides a template for adding the necessary copyright and licensing notices to the start of each source file in a new program to indicate it is licensed under the GNU General Public License version 2 or later. It ensures users are aware of their rights and obligations regarding redistribution and modification of the software.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/licenses/gnu-gpl-v2.0.rst#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n<one line to give the program's name and a brief idea of what it does.>\nCopyright (C) <year>  <name of author>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n```\n\n----------------------------------------\n\nTITLE: Matching ICMP Code Greater Than 5 using icode in Suricata\nDESCRIPTION: This example shows how to use the `icode` keyword in a Suricata rule to match on ICMP codes greater than 5.  This allows for filtering specific ICMP message details based on their codes.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_22\n\nLANGUAGE: Suricata\nCODE:\n```\nicode:>5;\n```\n\n----------------------------------------\n\nTITLE: DNS Request Alert Logging Format (Suricata 7.0)\nDESCRIPTION: This JSON snippet shows the DNS request alert logging format in Suricata 7.0.  The 'query' key contains a list of DNS queries.  The alert event type includes the dns object with fields such as query.type, query.id, query.rrname, query.rrtype, query.tx_id, and query.opcode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"alert\",\n  \"dns\": {\n    \"query\": [\n      {\n        \"type\": \"query\",\n        \"id\": 0,\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"A\",\n        \"tx_id\": 0,\n        \"opcode\": 0\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: DHCP Lease Time Matching Example - Suricata\nDESCRIPTION: This example demonstrates how to match DHCP lease time in a Suricata rule. It uses the `dhcp.leasetime` keyword to compare the lease time against a numerical value using various operators.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/dhcp-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\ndhcp.leasetime:3    # exactly 3\ndhcp.leasetime:<3   # smaller than 3\ndhcp.leasetime:>=2  # greater or equal than 2\n```\n\n----------------------------------------\n\nTITLE: Starting Load Balancer (lb) for Netmap\nDESCRIPTION: This command starts the `lb` (load balance) tool, directing traffic from the specified interface (`eth0`) to multiple instances of Suricata and Zeek. `-i eth0` specifies the input interface. `-p suricata:6` and `-p zeek:6` configure `lb` to forward traffic to 6 instances of Suricata and 6 instances of Zeek respectively.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlb -i eth0 -p suricata:6 -p zeek:6\n```\n\n----------------------------------------\n\nTITLE: Minimal dependencies for Ubuntu/Debian\nDESCRIPTION: This bash script installs the minimal dependencies required to build Suricata on Ubuntu/Debian systems.  It uses apt-get to install essential packages such as build-essential, libpcre3-dev, libyaml-dev, zlib1g-dev, and others. Requires sudo.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/install.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n../../scripts/docs-ubuntu-debian-minimal-build.sh\n```\n\n----------------------------------------\n\nTITLE: NFtables: Queue packets between interfaces\nDESCRIPTION: These nftables commands add rules to queue packets exchanged between eth0 and eth1 to Netfilter queue.  iif and oif options are used to define the input and output interfaces.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nnft> add rule filter IPS iif eth0 oif eth1 queue\nnft> add rule filter IPS iif eth1 oif eth0 queue\n```\n\n----------------------------------------\n\nTITLE: Restarting Napatech Service\nDESCRIPTION: These shell commands stop and start the Napatech service. This is required after modifying the `ntservice.ini` configuration file. The `-m` flag might specify a particular mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n\t$ /opt/napatech3/bin/ntstop.sh\n\t$ /opt/napatech3/bin/ntstart.sh\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT AUTH (JSON)\nDESCRIPTION: This example demonstrates the JSON structure for logging MQTT AUTH messages (MQTT 5.0). It includes the reason_code and properties. This structure shows authentication-related information logged by Suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_62\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"auth\": {\n    \"qos\": 0,\n    \"retain\": false,\n    \"dup\": false,\n    \"reason_code\": 16\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching SSH Header Frame\nDESCRIPTION: This rule matches SSH packets based on the content of the SSH record header, specifically looking for a message code of 0x15 (decimal 21). The `frame` keyword specifies the SSH record header (ssh.record.hdr), the `content` keyword searches for the hexadecimal value 0x15, the `endswith` keyword ensures the match occurs at the end of the buffer, and the `bsize` keyword limits the search to 6 bytes, which is the length of the SSH record header.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ssh-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ssh any any -> any any (msg:\"hdr frame new keys\"; frame:ssh.record.hdr; content: \"|15||\"; endswith; bsize: 6; sid:2;)\n```\n\n----------------------------------------\n\nTITLE: Defining Suricata Signature Properties in C\nDESCRIPTION: This C code snippet from `src/detect-engine.c` defines signature properties. These properties, along with the signature type, influence how Suricata processes and acts upon matching traffic. Specifically, it highlights the relationship between action scope and signature properties.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n// rule types documentation tag start: SignatureProperties\n\n//typedef enum {\n//    SIG_PROPERTY_NONE          = 0,\n//    SIG_PROPERTY_FLOW          = (1 << 0),\n//    SIG_PROPERTY_PACKET        = (1 << 1),\n//    SIG_PROPERTY_STREAM        = (1 << 2),\n//    SIG_PROPERTY_APP_LAYER     = (1 << 3),\n//    SIG_PROPERTY_APP_TX        = (1 << 4),\n//    SIG_PROPERTY_IPONLY        = (1 << 5),\n//\n//    SIG_PROPERTY_MAX\n//} SignatureProperty;\n\n// rule types documentation tag end: SignatureProperties\n```\n\n----------------------------------------\n\nTITLE: TCP Stream Rule Example - Suricata\nDESCRIPTION: This example demonstrates how to create a Suricata rule that only inspects the reassembled TCP stream. The `tcp-stream` keyword ensures the rule operates on the complete TCP stream.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp-stream ...\n```\n\n----------------------------------------\n\nTITLE: Checking NFQ Support in Suricata Build\nDESCRIPTION: This command is used to verify if NFQ (Netfilter Queue) support is enabled in the Suricata build. The output will list the build information, including whether NFQ is present.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsuricata --build-info\n```\n\n----------------------------------------\n\nTITLE: GitHub Filter for Draft Pull Requests\nDESCRIPTION: This filter is used to identify draft pull requests in the GitHub repository. It selects open PRs that are marked as drafts and sorts them by the last updated date in ascending order. This allows for easy identification of draft PRs that require feedback or further work.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/github-pr-workflow.rst#_snippet_0\n\nLANGUAGE: GitHub Query Language\nCODE:\n```\nis:pr is:open draft:true sort:updated-asc\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Response Line with Suricata Rule\nDESCRIPTION: This Suricata rule illustrates detecting a specific HTTP response line using the `http.response_line` keyword. It searches for the exact string \"HTTP/1.1 200 OK\" in the HTTP response line. The `flow` keyword specifies the traffic direction to be 'to_client'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_21\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Response Line \\\nExample\"; flow:established,to_client; :example-rule-options:`http.response_line; \\\ncontent:\"HTTP/1.1 200 OK\";` classtype:bad-unknown; sid:119; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Requires Keyword with AND Expression\nDESCRIPTION: This shows the syntax for using an *and* expression with the 'requires' keyword to specify a version range.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_17\n\nLANGUAGE: Suricata\nCODE:\n```\nrequires: version >= 7.0.4 < 8\n```\n\n----------------------------------------\n\nTITLE: Disabling Decoder Alerts in Snort.conf\nDESCRIPTION: This snippet illustrates how to disable specific decoder alerts in Snort using `config disable_*_alerts` directives. This is useful for suppressing noisy or irrelevant alerts related to protocol decoding and TCP options, reducing false positives and improving performance. These configurations disable specific decoder alerts by type.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/snort-to-suricata.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n# Stop generic decode events:\nconfig disable_decode_alerts\n\n# Stop Alerts on experimental TCP options\nconfig disable_tcpopt_experimental_alerts\n\n# Stop Alerts on obsolete TCP options\nconfig disable_tcpopt_obsolete_alerts\n\n# Stop Alerts on T/TCP alerts\nconfig disable_tcpopt_ttcp_alerts\n\n# Stop Alerts on all other TCPOption type events:\nconfig disable_tcpopt_alerts\n\n# Stop Alerts on invalid ip options\nconfig disable_ipopt_alerts\n```\n\n----------------------------------------\n\nTITLE: Matching WebSocket Flags using String Representation in Suricata\nDESCRIPTION: This example demonstrates matching WebSocket flags using string representations like `fin` and `comp`. The `!` prefix negates a flag.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/websocket-keywords.rst#_snippet_4\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nwebsocket.flags:fin,!comp;\n```\n\n----------------------------------------\n\nTITLE: Matching MQTT Protocol Version\nDESCRIPTION: This example shows how to match the MQTT protocol version using the `mqtt.protocol_version` keyword. It matches when the protocol version is exactly 5. The keyword uses an unsigned 8-bit integer representation.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/mqtt-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nmqtt.protocol_version:5;\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule Startswith Example\nDESCRIPTION: This example demonstrates the usage of the 'startswith' keyword in Suricata rules. It shows how to modify the 'content' to match exactly at the beginning of a buffer. It provides an equivalent example using 'depth' and 'offset'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/payload-keywords.rst#_snippet_2\n\nLANGUAGE: suricata\nCODE:\n```\ncontent:\"GET|20|\"; startswith;\n```\n\nLANGUAGE: suricata\nCODE:\n```\ncontent:\"GET|20|\"; depth:4; offset:0;\n```\n\n----------------------------------------\n\nTITLE: Creating Suricata Directory - Bash\nDESCRIPTION: This command creates a directory named 'suricata' (or 'oisf') where the Suricata source code will be downloaded and built. The second command changes the current directory to the newly created 'suricata' (or 'oisf') directory.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmkdir suricata  # mkdir oisf\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd suricata  # cd oisf\n```\n\n----------------------------------------\n\nTITLE: Configuring Napatech Plugin in suricata.yaml\nDESCRIPTION: This YAML snippet demonstrates how to configure the Napatech plugin within the Suricata configuration file. It specifies the path to the Napatech plugin library.\nSOURCE: https://github.com/oisf/suricata/blob/master/plugins/napatech/README.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nplugins:\n  - /usr/local/lib/suricata/napatech.so\n```\n\n----------------------------------------\n\nTITLE: Resumed TLS Session Log Example\nDESCRIPTION: This JSON snippet displays a TLS log entry for a resumed session. The presence of the 'session_resumed': true field indicates that the TLS session was resumed, and therefore no certificate information is included.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_26\n\nLANGUAGE: json\nCODE:\n```\n  \"tls\": {\n      \"session_resumed\": true\n  }\n```\n\n----------------------------------------\n\nTITLE: Running autogen.sh - Bash\nDESCRIPTION: This command executes the autogen.sh script. This script prepares the build environment by generating the configure script from the Autoconf files. It must be run after cloning the repository and before running the configure script.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./autogen.sh\n```\n\n----------------------------------------\n\nTITLE: Suricata Upstart Init Script\nDESCRIPTION: This Upstart configuration file (`/etc/init/suricata.conf`) manages the Suricata daemon on Ubuntu systems. It defines the service description, start and stop runlevels, process expectation, and the execution command for Suricata, including specifying the configuration file and interface.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/initscripts.rst#_snippet_0\n\nLANGUAGE: Upstart\nCODE:\n```\n# suricata\ndescription \"Intrusion Detection System Daemon\"\nstart on runlevel [2345]\nstop on runlevel [!2345]\nexpect fork\nexec suricata -D --pidfile /var/run/suricata.pid -c /etc/suricata/suricata.yaml -i eth1\n```\n\n----------------------------------------\n\nTITLE: Configuring enable-busy-poll in suricata.yaml\nDESCRIPTION: This snippet shows how to configure enable-busy-poll in the suricata.yaml configuration file. This enables or disables busy polling.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/af-xdp.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\naf-xdp:\n  enable-busy-poll: <yes/no>\n  enable-busy-poll: yes\n```\n\n----------------------------------------\n\nTITLE: Matching ENIP State in Suricata Rules\nDESCRIPTION: The `enip.state` keyword is used to match on the state in the identity message, using an 8-bit unsigned integer as its value. The state indicates the current operational phase of the device.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/enip-keyword.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.state:1;\n```\n\nLANGUAGE: Suricata\nCODE:\n```\nenip.state:>1;\n```\n\n----------------------------------------\n\nTITLE: DPDK IPS Configuration\nDESCRIPTION: This YAML configuration shows how to configure Suricata for DPDK IPS mode between two network interfaces. Packets received on one interface are transmitted by the other. It defines EAL parameters, interfaces, threads, promisc mode, and other DPDK-specific settings.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/setting-up-ipsinline-for-linux.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\ndpdk:\n  eal-params:\n    proc-type: primary\n\n  interfaces:\n  - interface: 0000:3b:00.1\n    threads: 4\n    promisc: true\n    multicast: true\n    checksum-checks: true\n    checksum-checks-offload: true\n    mempool-size: 262143\n    mempool-cache-size: 511\n    rx-descriptors: 4096\n    tx-descriptors: 4096\n    copy-mode: ips\n    copy-iface: 0000:3b:00.0\n    mtu: 3000\n```\n\n----------------------------------------\n\nTITLE: Analyzing Suricata Rule with References\nDESCRIPTION: This code snippet shows an example Suricata rule with multiple references. These references are URLs that provide more context and information about the threat the rule detects. The rule checks for Adobe 0day Shovelware activity by examining HTTP GET requests for specific URIs and content.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/make-sense-alerts.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nalert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS \\\n    (msg:\"ET CURRENT_EVENTS Adobe 0day Shovelware\"; \\\n    flow:established,to_server; content:\"GET \"; nocase; depth:4; \\\n    content:!\"|0d 0a|Referer\\:\"; nocase; \\\n    uricontent:\"/ppp/listdir.php?dir=\"; \\\n    pcre:\"/\\/[a-z]{2}\\/[a-z]{4}01\\/ppp\\/listdir\\.php\\?dir=/U\"; \\\n    classtype:trojan-activity; \\\n    reference:url,isc.sans.org/diary.html?storyid=7747; \\\n    reference:url,doc.emergingthreats.net/2010496; \\\n    reference:url,www.emergingthreats.net/cgi-bin/cvsweb.cgi/sigs/CURRENT_EVENTS/CURRENT_Adobe; \\\n    sid:2010496; rev:2;)\n```\n\n----------------------------------------\n\nTITLE: Getting Rule Instance - Lua\nDESCRIPTION: Obtains a rule object from the `suricata.rule` library, providing access to the attributes and methods associated with the current rule being processed. The `get_rule()` function returns a representation of the current rule.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/rule.rst#_snippet_2\n\nLANGUAGE: Lua\nCODE:\n```\n  local sig = rule.get_rule()\n```\n\n----------------------------------------\n\nTITLE: Analyzing Bittorrent DHT Error Responses in JSON\nDESCRIPTION: This snippet presents examples of Bittorrent DHT error responses in JSON format. Each error response contains 'transaction_id' and an 'error' object including 'num' (error code) and 'msg' (error message). This is useful for debugging Bittorrent DHT interactions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_43\n\nLANGUAGE: json\nCODE:\n```\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"aa\",\n    \"error\": {\n      \"num\": 201,\n      \"msg\": \"A Generic Error Ocurred\"\n    }\n  }\n  \"bittorrent_dht\": {\n    \"transaction_id\": \"aa\",\n    \"error\": {\n      \"num\": 203,\n      \"msg\": \"Malformed Packet\"\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: SMB File/Pipe Close Logging Example (JSON)\nDESCRIPTION: This example captures the JSON format for logging an SMB file or pipe close event, focusing on the transaction ID, dialect, command, status, session ID, and tree ID.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_30\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"id\": 15,\n    \"dialect\": \"2.10\",\n    \"command\": \"SMB2_COMMAND_CLOSE\",\n    \"status\": \"STATUS_SUCCESS\",\n    \"status_code\": \"0x0\",\n    \"session_id\": 4398046511121,\n    \"tree_id\": 1,\n  }\n```\n\n----------------------------------------\n\nTITLE: Running Custom Library\nDESCRIPTION: This snippet shows how to run the compiled custom library example.  It takes Suricata command-line arguments before `--` and a PCAP filename after `--`.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/custom/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./custom -l . -- filename.pcap\n```\n\n----------------------------------------\n\nTITLE: Update Suricata from Git\nDESCRIPTION: This snippet shows how to update the Suricata source code from a Git repository. It assumes you've already cloned the repository. It navigates to the suricata directory, pulls the latest changes, and continues with any necessary build steps not explicitly shown here.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-profiling.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd suricata/suricata\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Cloning Suricata Repository - Bash\nDESCRIPTION: This command clones the Suricata Git repository from GitHub into the current directory. The second command changes the directory into the newly cloned `suricata` folder.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/installation-from-git.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/OISF/suricata.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd suricata\n```\n\n----------------------------------------\n\nTITLE: GitHub Filter for Pull Requests with Changes Requested\nDESCRIPTION: This filter identifies pull requests that are open, not in draft status, and have changes requested. The results are sorted by the last updated date in ascending order, helping reviewers prioritize PRs needing revisions.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/github-pr-workflow.rst#_snippet_2\n\nLANGUAGE: GitHub Query Language\nCODE:\n```\nis:pr is:open draft:false sort: updated-asc review:changes-requested\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hassh Algorithms String in Lua\nDESCRIPTION: Retrieves the hassh algorithms used by the client with the `HasshGetString` function, returns 0 if hassh is nil.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_41\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    hassh_string = HasshGetString()\n    if hassh == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Updating suricata-update Sources\nDESCRIPTION: This command fetches the master index from the OISF hosts, providing a list of available rulesets that can be enabled. It's a prerequisite to listing available sources.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/suricata-update.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo suricata-update update-sources\n```\n\n----------------------------------------\n\nTITLE: Retrieving SSH Server Protocol Version in Lua\nDESCRIPTION: This snippet shows how to retrieve the SSH server protocol version using the `SshGetServerProtoVersion()` function.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_36\n\nLANGUAGE: lua\nCODE:\n```\nfunction log (args)\n    version = SshGetServerProtoVersion()\n    if version == nil then\n        return 0\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Suricata configuration directory\nDESCRIPTION: This command creates a directory for storing Suricata configuration files.  It requires root privileges and is typically located in /etc/suricata.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/Basic_Setup.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir /etc/suricata\n```\n\n----------------------------------------\n\nTITLE: Example Suricata Alert\nDESCRIPTION: This is an example output from Suricata's alert log. It shows the timestamp, alert message, classification, priority, protocol, and source/destination IP addresses and ports.  It is representative of the type of output written to the fast.log file when a Suricata rule triggers.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rule-management/adding-your-own-rules.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n09/15/2011-16:50:27.725288  [**] [1:1:1] Do not read gossip during work [**]\n[Classification: Potential Corporate Privacy Violation] [Priority: 1] {TCP} 192.168.0.32:55604 -> 68.67.185.210:80\n```\n\n----------------------------------------\n\nTITLE: Suppress Configuration Syntax\nDESCRIPTION: This defines the syntax for configuring suppressions using 'suppress'. Suppressions prevent alerts for specific rules or hosts/networks.  Tracking options include by_src, by_dst, and by_either, with IP addresses or subnets specified for suppression.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nsuppress gen_id <gid>, sig_id <sid>\nsuppress gen_id <gid>, sig_id <sid>, track <by_src|by_dst|by_either>, ip <ip|subnet|addressvar>\n```\n\n----------------------------------------\n\nTITLE: Suppress Rule Example\nDESCRIPTION: This suppression example converts a rule to \"noalert\", meaning the rule will never alert in any case. If the rule sets a flowbit, that will still happen.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/configuration/global-thresholds.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nsuppress gen_id 1, sig_id 2002087\n```\n\n----------------------------------------\n\nTITLE: Packet Loss Statistics Output\nDESCRIPTION: This is an example output showing packet loss statistics reported by Suricata at shutdown.  It shows the total number of packets and bytes processed, along with the number of dropped packets reported by pcap.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/statistics.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[18088] 30/5/2012 -- 07:39:18 - (RxPcapem21) Packets 451595939, bytes 410869083410\n[18088] 30/5/2012 -- 07:39:18 - (RxPcapem21) Pcap Total:451674222 Recv:451596129 Drop:78093 (0.0%).\n```\n\n----------------------------------------\n\nTITLE: Building Out-of-Tree: PATH modification\nDESCRIPTION: This snippet demonstrates how to modify the PATH environment variable to include the directory containing `libsuricata-config`, which is necessary if Suricata was installed in a non-standard location. This ensures that the build process can find the Suricata library and headers.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/simple/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nPATH=/opt/suricata/bin:$PATH make -f Makefile.example\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with 16 Myricom Rings\nDESCRIPTION: This command starts Suricata with 16 ring buffers for the Myricom card. It specifies the number of rings using the ``SNF_NUM_RINGS`` environment variable.  The other parameters configure the Suricata process and define the interface and the running mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/myricom.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nSNF_NUM_RINGS=16 SNF_FLAGS=0x1 suricata -c suricata.yaml -i eth5 --runmode=workers\n```\n\n----------------------------------------\n\nTITLE: Multiple Variable Declarations\nDESCRIPTION: Example of declaring multiple consecutive variables with comments. Note the coding style guide recommends `AlignConsecutiveAssignments` and `AlignConsecutiveDeclarations` be set to false.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_23\n\nLANGUAGE: c\nCODE:\n```\nint a = 13;           /* comment */\nint32_t abc = 1312;   /* comment */\nint abcdefghikl = 13; /* comment */\n```\n\n----------------------------------------\n\nTITLE: Getting DNS rcode as integer in Lua\nDESCRIPTION: This snippet demonstrates how to obtain the DNS response code (rcode) as an integer using the `rcode()` method on the transaction object.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/dns.rst#_snippet_7\n\nLANGUAGE: Lua\nCODE:\n```\nlocal tx = dns.get_tx()\nlocal rcode = tx:rcode()\nprint (rcode)\n```\n\n----------------------------------------\n\nTITLE: Checking TCP Sequence Number with seq Keyword in Suricata\nDESCRIPTION: This example demonstrates how to use the `seq` keyword in a Suricata rule to check for a specific TCP sequence number.  The sequence number is checked against the value of 0 in the example rule. This is useful for detecting specific communication patterns or anomalies within a TCP stream.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/header-keywords.rst#_snippet_14\n\nLANGUAGE: Suricata\nCODE:\n```\nalert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:\"GPL SCAN NULL\"; flow:stateless; ack:0; flags:0; :example-rule-emphasis:`seq:0;` reference:arachnids,4; classtype:attempted-recon; sid:2100623; rev:7;)\n```\n\n----------------------------------------\n\nTITLE: RDP logging with TLS handshake and server support info\nDESCRIPTION: This example shows RDP event logging during a transition to TLS. The server supports 'extended_client_data' and uses the 'hybrid' protocol. The 'x509_serials' field contains a list of observed certificate serial numbers during the TLS handshake. These logs capture key aspects of the RDP connection setup, including server capabilities and encryption details.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_50\n\nLANGUAGE: json\nCODE:\n```\n  \"rdp\": {\n    \"tx_id\": 0,\n    \"event_type\": \"initial_request\",\n    \"cookie\": \"AWAKECODI\"\n  }\n\n  \"rdp\": {\n    \"tx_id\": 1,\n    \"event_type\": \"initial_response\",\n    \"server_supports\": [\n      \"extended_client_data\"\n    ],\n    \"protocol\": \"hybrid\"\n  }\n\n  \"rdp\": {\n    \"tx_id\": 2,\n    \"event_type\": \"tls_handshake\",\n    \"x509_serials\": [\n      \"16ed2aa0495f259d4f5d99edada570d1\"\n    ]\n  }\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: SMBv1 Version Match\nDESCRIPTION: This Suricata rule generates an alert when SMBv1 traffic is detected. It utilizes the 'smb.version' keyword with a value of 1 to specifically identify SMBv1 transactions. The rule includes a message and a signature ID for easy identification.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smb-keywords.rst#_snippet_0\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smb $HOME_NET any -> any any (msg:\"SMBv1 version rule\"; :example-rule-options:`smb.version:1;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Disable Alert and Set State (flowbits)\nDESCRIPTION: This Suricata rule sets a flowbit without generating an alert. It monitors HTTP GET requests and sets the 'SC.EXAMPLE' flowbit for established flows. The 'noalert' keyword prevents alert generation. It requires flowbits to be configured.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/intro.rst#_snippet_11\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http any any -> $HOME_NET any (msg:\"noalert example: set state\"; flow:established,to_server; xbits:set,SC.EXAMPLE,track ip_dst, expire 10; noalert; http.method; content:\"GET\"; sid:1; )\n```\n\n----------------------------------------\n\nTITLE: LDAP Bind Response Alert Rule with Operation Name\nDESCRIPTION: This Suricata rule alerts when an LDAP bind response operation is detected. It uses the `ldap.responses.operation` keyword with the operation name `bind_response` to identify the bind response. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_3\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP bind response\"; :example-rule-emphasis:`ldap.responses.operation:bind_response;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: Matching file extension with partial match using file.name\nDESCRIPTION: This Suricata rule demonstrates matching a file extension using the `file.name` keyword and allowing a partial match. It alerts if a file with an extension that starts with \".pd\" is detected.  Unlike the `fileext` keyword, this approach enables partial matches on the file extension.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nfile.name; content:\".pd\";\n```\n\n----------------------------------------\n\nTITLE: DNS Response Logging Format (Suricata 8.0)\nDESCRIPTION: This JSON snippet represents the DNS response logging format in Suricata 8.0.  The type is 'response', and queries are placed in the 'queries' array. Version 3 is added and includes the tx_id field. Relevant fields such as event_type, dns.version, dns.type, dns.tx_id, dns.id, dns.flags, dns.qr, dns.rd, dns.ra, dns.opcode, dns.rcode, dns.queries, and dns.answers are present.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade/8.0-dns-logging-changes.rst#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"event_type\": \"dns\",\n  \"dns\": {\n    \"version\": 3,\n    \"type\": \"response\",\n    \"tx_id\": 1,\n    \"id\": 0,\n    \"flags\": \"8180\",\n    \"qr\": true,\n    \"rd\": true,\n    \"ra\": true,\n    \"opcode\": 0,\n    \"rcode\": \"NOERROR\",\n    \"queries\": [\n      {\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"A\"\n      }\n    ],\n    \"answers\": [\n      {\n        \"rrname\": \"www.suricata.io\",\n        \"rrtype\": \"CNAME\",\n        \"ttl\": 3597,\n        \"rdata\": \"suricata.io\"\n      },\n      {\n        \"rrname\": \"suricata.io\",\n        \"rrtype\": \"A\",\n        \"ttl\": 597,\n        \"rdata\": \"35.212.0.44\"\n      }\n    ],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Filename Date Modifiers for EVE JSON Output\nDESCRIPTION: This snippet configures the filename of the EVE JSON output to include a date modifier. It uses the `strftime` function to add epoch time to the filename. All date modifiers supported by the C library are supported.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-output.rst#_snippet_6\n\nLANGUAGE: Config\nCODE:\n```\n   outputs:\n     - eve-log:\n         filename: eve-%s.json\n```\n\n----------------------------------------\n\nTITLE: Find Top 10 Destination Ports with jq\nDESCRIPTION: This command identifies the top 10 destination ports from flow events in the eve.json file.  It filters for flow events, extracts the protocol and destination port, sorts them, counts unique occurrences, sorts by count in descending order, and displays the top 10.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-examplesjq.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncat eve.json | jq -c 'select(.event_type==\"flow\")|[.proto, .dest_port]'|sort |uniq -c|sort -nr|head -n10\n```\n\n----------------------------------------\n\nTITLE: Configuring Suricata with nDPI support - Console\nDESCRIPTION: This command configures Suricata to build with nDPI support.  It specifies the location of the nDPI source code.  Requires nDPI to be installed.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/plugins/ndpi.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n./configure --enable-ndpi --with-ndpi=/home/user/src/nDPI\n```\n\n----------------------------------------\n\nTITLE: Braces example 4\nDESCRIPTION: Example of proper brace placement for structs, unions and enums.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nunion {\n    TCPVars tcpvars;\n    ICMPV4Vars icmpv4vars;\n    ICMPV6Vars icmpv6vars;\n} l4vars;\n\nstruct {\n    uint8_t type;\n    uint8_t code;\n} icmp_s;\n\nenum {\n    DETECT_TAG_TYPE_SESSION,\n    DETECT_TAG_TYPE_HOST,\n    DETECT_TAG_TYPE_MAX\n};\n```\n\n----------------------------------------\n\nTITLE: SMTP response_line frame example\nDESCRIPTION: This example shows how to use the `smtp.response_line` frame to inspect individual lines from the server to the client. The rule checks if the response line starts with \"354 go ahead\".\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_5\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any ( \\\n  :example-rule-options:`frame:smtp.response_line; content:\"354 go ahead\"; startswith;` \\\n  sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: vlan.layers greater than 1\nDESCRIPTION: This Suricata rule alerts if a packet has more than 1 VLAN layer.  It uses the `vlan.layers` keyword with the operator `>` and the value `1` to specify that the packet must have more than one VLAN layer to trigger the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/vlan-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ip any any -> any any (msg:\"Packet has more than 1 vlan layer\"; vlan.layers:>1; sid:1;)\n```\n\n----------------------------------------\n\nTITLE: SMTP data frame example\nDESCRIPTION: This example demonstrates how to use the `smtp.data` frame to inspect the DATA portion of the SMTP communication. The rule checks if \"Reply-To:\" is present, and if \"Subject\" is found immediately after.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/smtp-keywords.rst#_snippet_6\n\nLANGUAGE: Suricata\nCODE:\n```\nalert smtp any any -> any any ( \\\n  :example-rule-options:`frame:smtp.data; content:\"Reply-To:\"; startswith; content:\"Subject\"; distance:0;` \\\n  sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Initializing Needs for TLS Protocol in Lua (Output)\nDESCRIPTION: This code shows how to initialize the 'needs' table for TLS protocol output logging. The 'protocol' key is set to 'tls', enabling the script to access TLS protocol data for logging.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_18\n\nLANGUAGE: lua\nCODE:\n```\nfunction init (args)\n    local needs = {}\n    needs[\"protocol\"] = \"tls\"\n    return needs\nend\n```\n\n----------------------------------------\n\nTITLE: AppLayerParserFPtr Definition in C\nDESCRIPTION: This code defines the function pointer type `AppLayerParserFPtr` for application layer parser callbacks in Suricata. It takes a flow, protocol state, parser state, data buffer, buffer length, local storage, and flags as input. It returns an `AppLayerResult` to indicate the parsing status.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/parser.rst#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef AppLayerResult (*AppLayerParserFPtr)(Flow *f, void *protocol_state,\n            AppLayerParserState *pstate,\n            const uint8_t *buf, uint32_t buf_len,\n            void *local_storage, const uint8_t flags);\n```\n\n----------------------------------------\n\nTITLE: Finding Network Interface IP Address\nDESCRIPTION: Uses the `ip addr` command to determine the available network interfaces and their IP addresses.  The IP address and interface name are needed to configure Suricata's HOME_NET variable and interface settings.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/quickstart.rst#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ ip addr\n```\n\n----------------------------------------\n\nTITLE: Logging MQTT PUBACK (JSON)\nDESCRIPTION: This example illustrates the JSON format for logging MQTT PUBACK messages.  It includes fields like qos, retain, dup, message_id, and reason_code. It gives insight into how acknowledgement messages are represented within Suricata's MQTT logging.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_57\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"puback\": {\n    \"qos\": 0,\n    \"retain\": false,\n    \"dup\": false,\n    \"message_id\": 1,\n    \"reason_code\": 16\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting HTTP Content-Length Response with Suricata Rule\nDESCRIPTION: This Suricata rule shows how to detect a specific HTTP content length value in a response using the `http.content_len` keyword. It searches for the value \"20\" within the Content-Length header. The `flow` keyword specifies the traffic direction to be 'to_client'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/http-keywords.rst#_snippet_28\n\nLANGUAGE: Suricata\nCODE:\n```\nalert http $EXTERNAL_NET any -> $HOME_NET any (msg:\"HTTP Content-Length Response \\\nExample\"; flow:established,to_client; :example-rule-options:`http.content_len; \\\ncontent:\"20\";` bsize:2; classtype:bad-unknown; sid:98; rev:1;)\n```\n\n----------------------------------------\n\nTITLE: Starting Suricata with DAG interface\nDESCRIPTION: This command starts Suricata with the DAG interface specified. The `-c` option specifies the Suricata configuration file.  The `--dag` option specifies the DAG stream to use. The format is 'card_number:stream_number'.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/endace-dag.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsuricata -c suricata.yaml --dag 0:0\n```\n\n----------------------------------------\n\nTITLE: Registering a Transaction Logger in Suricata (C)\nDESCRIPTION: This code snippet shows the function signature for registering a transaction logger within Suricata. Transaction loggers are used to log application layer transactions. The `SCOutputRegisterTxLogger` function is used to register a function for logging transactions, however it cannot be registered from a plugin at this time.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/output/index.rst#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/** \\brief Register a transaction logger\n *\n *  This function registers a function that is responsible for logging\n *  transaction related output.\n *\n *  \\param logger The logger to register.\n *\n *  \\return void\n */\n```\n\nLANGUAGE: c\nCODE:\n```\nvoid SCOutputRegisterTxLogger(void (*logger)(SCLogRecord *lr, Flow *f, TxData *tx, void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                     , void *data\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                     , void (*deinit)(void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                     );\n```\n\n----------------------------------------\n\nTITLE: LDAP Result Code Matching - Any Index\nDESCRIPTION: This Suricata rule alerts if an LDAP packet has a \"success\" result code at any index in the responses array. It demonstrates the basic usage of the `ldap.responses.result_code` keyword without specifying an index, meaning it will match if the result code is present in any of the responses.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP result code\"; :example-rule-emphasis:`ldap.responses.result_code:0;` sid:1;)\n```\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Test LDAP result code\"; :example-rule-emphasis:`ldap.responses.result_code:success,any;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: LDAP Response Count Alert Rule (More Than 2 Responses)\nDESCRIPTION: This Suricata rule alerts if a packet has more than 2 LDAP responses. It uses the `ldap.responses.count` keyword with the operator `>` and the value `2`. The `msg` option provides a descriptive message for the alert.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ldap-keywords.rst#_snippet_8\n\nLANGUAGE: Suricata Rule\nCODE:\n```\nalert ldap any any -> any any (msg:\"Packet has more than 2 LDAP responses\"; :example-rule-emphasis:`ldap.responses.count:>2;` sid:1;)\n```\n\n----------------------------------------\n\nTITLE: Retrieving HTTP Response Headers in Lua (Table)\nDESCRIPTION: This code shows how to retrieve all HTTP response headers as a table using the `HttpGetResponseHeaders()` function. The code then iterates through the table and prints each header and its corresponding value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/lua-functions.rst#_snippet_17\n\nLANGUAGE: lua\nCODE:\n```\na = HttpGetResponseHeaders();\nfor n, v in pairs(a) do\n    print(n,v)\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Netmap with lb in Suricata YAML\nDESCRIPTION: This YAML configuration configures Suricata to read from a Netmap pipe created by the `lb` tool. The `interface` is set to `netmap:suricata`, indicating that Suricata should read from a Netmap pipe named 'suricata'. The `threads` parameter specifies the number of threads to use for packet capture.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nnetmap:\n  - interface: netmap:suricata\n    threads: 6\n```\n\n----------------------------------------\n\nTITLE: Flow control example\nDESCRIPTION: This C code snippet demonstrates correct flow control. Conditions and statements should not be on the same line. Short or empty functions and structs should not be on one line.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nif (a)\n    b = a; // <- right\n\nfor (int i = 0; i < 32; ++i)\n    f(i); // <- right\n```\n\n----------------------------------------\n\nTITLE: Setting RSS Queue Numbers in eBPF - C\nDESCRIPTION: This snippet shows how to set the number of RSS queues in the eBPF filter code.  This value must match the number of threads configured in the Suricata `af-packet` interface and should be a power of 2 as of Linux 4.19.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\n #define RSS_QUEUE_NUMBERS   32\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Command Data Matching Rule - temp.txt\nDESCRIPTION: This rule uses `ftp.command_data` to match \"temp.txt\" as command data.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_7\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.command_data; content:\"temp.txt\";` sid: 2;)\n```\n\n----------------------------------------\n\nTITLE: Creating VALE Virtual Switch and Ports\nDESCRIPTION: These commands create a VALE virtual switch named \"vale0\" and two virtual ports \"vi0\" and \"vi1\", then attach them to the switch. `vale-ctl -n vi0` creates a new virtual port.  `vale-ctl -a vale0:vi0` adds the port to the specified VALE switch.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/netmap.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nvale-ctl -n vi0\nvale-ctl -a vale0:vi0\nvale-ctl -n vi1\nvale-ctl -a vale0:vi1\n```\n\n----------------------------------------\n\nTITLE: Unittest Data Array Example (Correct)\nDESCRIPTION: Example demonstrating correct unittest formatting. The data array includes an explanatory comment that contains the readable content of the message.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nint SMTPParserTest14(void)\n{\n    /* 220 mx.google.com ESMTP d15sm986283wfl.6<CR><LF> */\n    static uint8_t welcome_reply[] = { 0x32, 0x32, 0x30, 0x20,\n```\n\n----------------------------------------\n\nTITLE: DCERPC Transaction Completion State - C\nDESCRIPTION: This C code shows how the transaction completion status is registered for the DCERPC protocol. Both the to-server and to-client completion states are set to 1, indicating a simple completion model where a state of 1 signifies transaction completion.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/transactions.rst#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nAppLayerParserRegisterStateProgressCompletionStatus(ALPROTO_DCERPC, 1, 1);\n```\n\n----------------------------------------\n\nTITLE: Getting flow timestamp as legacy string in Lua\nDESCRIPTION: This snippet retrieves the timestamp of the first packet in the flow as a string in the format `11/24/2009-18:57:25.179869`. This is the format used in `fast.log` and `http.log` legacy outputs. It returns a string representing the timestamp.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/lua/libs/flowlib.rst#_snippet_3\n\nLANGUAGE: lua\nCODE:\n```\nf = flow.get()\nprint f:timestring_legacy()\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Features with Requires Keyword\nDESCRIPTION: This demonstrates requiring multiple features using the 'requires' keyword by using multiple 'feature' sub-keywords.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/meta.rst#_snippet_16\n\nLANGUAGE: Suricata\nCODE:\n```\nrequires: feature geoip, feature lua\n```\n\n----------------------------------------\n\nTITLE: HTTP custom header logging example (Suricata 6.0)\nDESCRIPTION: This snippet presents an example of the EVE log output in Suricata 6.0 when using the `http.custom` configuration. The custom 'Server' header is merged directly into the 'http' object.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/upgrade.rst#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"http\": {\n  \"hostname\": \"suricata.io\",\n  \"http_method\": \"GET\",\n  \"protocol\": \"HTTP/1/1\",\n  \"server\": \"nginx\",\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Navigate to PCAP directory\nDESCRIPTION: This snippet changes the current directory to a location where PCAP files are stored. This is necessary to easily specify the PCAP file when running Suricata. The example shows navigating to the user's Desktop.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/packet-profiling.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd  ~/Desktop\n```\n\n----------------------------------------\n\nTITLE: Building Out-of-Tree: Install Library and Headers\nDESCRIPTION: This snippet shows how to build and install the Suricata library and headers. This is a prerequisite for building the custom application out-of-tree.\nSOURCE: https://github.com/oisf/suricata/blob/master/examples/lib/custom/README.md#_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\nmake install-library\nmake install-headers\n```\n\n----------------------------------------\n\nTITLE: Installing Clang Compiler (Bash)\nDESCRIPTION: This code snippet shows how to install the Clang compiler, which is required for building eBPF programs, on Debian/Ubuntu systems. Clang version 3.9 or greater is required. The package is installed via `apt`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/ebpf-xdp.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n sudo apt install clang\n```\n\n----------------------------------------\n\nTITLE: Suricata FTP Reply Matching Rule - Opening BINARY mode\nDESCRIPTION: This rule matches the reply string related to opening a binary mode data connection.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/ftp-keywords.rst#_snippet_10\n\nLANGUAGE: Suricata\nCODE:\n```\nalert ftp any any -> any any (:example-rule-options:`ftp.reply; content:\"Opening BINARY mode data connection for temp.\";` sid: 1;)\n```\n\n----------------------------------------\n\nTITLE: PGSQL Event Example with SELECT Query\nDESCRIPTION: This example demonstrates a PGSQL event log entry for a SimpleQuery transaction. It shows the structure of the event, including the request (SELECT statement) and response (field count, data rows, etc.) fields.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_67\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"timestamp\": \"2021-11-24T16:56:24.403417+0000\",\n    \"flow_id\": 1960113262002448,\n    \"pcap_cnt\": 780,\n    \"event_type\": \"pgsql\",\n    \"src_ip\": \"172.18.0.1\",\n    \"src_port\": 54408,\n    \"dest_ip\": \"172.18.0.2\",\n    \"dest_port\": 5432,\n    \"proto\": \"TCP\",\n    \"pgsql\": {\n      \"tx_id\": 4,\n      \"request\": {\n        \"simple_query\": \"select * from rule limit 5000;\"\n      },\n      \"response\": {\n        \"field_count\": 7,\n        \"data_rows\": 5000,\n        \"data_size\": 3035751,\n        \"command_completed\": \"SELECT 5000\"\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Snort Relative Isdataat Example\nDESCRIPTION: To check for '.exe' at the end of a URI in Snort, a PCRE is required, demonstrating the difference in how Snort handles the normalized URI buffer compared to Suricata's 'isdataat' keyword.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_10\n\nLANGUAGE: Snort\nCODE:\n```\npcre:\"/\\x2Eexe$/U\";\n```\n\n----------------------------------------\n\nTITLE: EVE JSON PCAP File Info Example\nDESCRIPTION: This JSON demonstrates `pcap_cnt` and `pcap_filename` fields. If Suricata processes a pcap file, additional fields are appended into the log. The first, `pcap_cnt`, represents the packet number in the pcap file, while `pcap_filename` is the path and filename of the pcap file.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/eve/eve-json-format.rst#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n\"pcap_cnt\": 123\n```\n\nLANGUAGE: JSON\nCODE:\n```\n\"pcap_filename\":\"/path/to/file.pcap\"\n```\n\n----------------------------------------\n\nTITLE: Suricata http_cookie Buffer Contents\nDESCRIPTION: This example demonstrates the content of the Suricata `http_cookie` buffer when multiple Cookie headers are present in a request. The values are concatenated with a comma and a space.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/differences-from-snort.rst#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nmonster, elmo\n```\n\n----------------------------------------\n\nTITLE: Formatting changes by commit on branch\nDESCRIPTION: This bash script formats all changes by commits on the branch using git clang-format. first_commit_on_your_branch^ should be used, not master.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Format all changes by commits on your branch:\n$ git clang-format first_commit_on_your_branch^\n# Or with script:\n$ scripts/clang-format.sh branch\n```\n\n----------------------------------------\n\nTITLE: Suricata Rule: File SHA1 Whitelisting\nDESCRIPTION: This Suricata rule example demonstrates using the `filesha1` keyword with negation (`!`) for whitelisting files based on their SHA1 hash. The file 'sha1-whitelist' contains a list of SHA1 hashes that are considered safe. The rule will not alert if a file's SHA1 hash matches an entry in this whitelist.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/file-keywords.rst#_snippet_13\n\nLANGUAGE: Suricata\nCODE:\n```\nfilesha1:!sha1-whitelist;\n```\n\n----------------------------------------\n\nTITLE: File-store v1 Configuration Example\nDESCRIPTION: This YAML snippet shows an example of a Suricata file-store configuration in version 1. It includes options for enabling the file-store, setting the log directory, forcing magic and hash logging, controlling stream depth, managing the waldo file, and configuring file writing behavior.  It demonstrates the older configuration style that needs to be updated.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/file-extraction/config-update.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n  - file-store:\n      enabled: yes        # set to yes to enable\n      log-dir: files      # directory to store the files\n      force-magic: no     # force logging magic on all stored files\n      force-hash: [md5]   # force logging of md5 checksums\n      force-filestore: no # force storing of all files\n      stream-depth: 1mb   # reassemble 1mb into a stream, set to no to disable\n      waldo: file.waldo   # waldo file to store the file_id across runs\n      max-open-files: 0   # how many files to keep open (O means none)\n      write-meta: yes     # write a .meta file if set to yes\n      include-pid: yes    # include the pid in filenames if set to yes.\n```\n\n----------------------------------------\n\nTITLE: Example of dataset content with string type\nDESCRIPTION: This shows an example entry in a dataset file with `string` type. The string is base64 encoded. The base64 decoding reveals the original value.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/datasets.rst#_snippet_14\n\nLANGUAGE: Text\nCODE:\n```\nTW96aWxsYS80LjAgKGNvbXBhdGlibGU7ICk=\n```\n\n----------------------------------------\n\nTITLE: NIC load balancing configuration with ethtool\nDESCRIPTION: This snippet shows how to configure NIC load balancing using ethtool. It iterates through different protocols (tcp4, udp4, tcp6, udp6) and sets the rx-flow-hash for each protocol using the 'sdfn' hash type.  'eth1' is used as the interface in this example.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/performance/high-performance-config.rst#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nfor proto in tcp4 udp4 tcp6 udp6; do\n   /usr/local/sbin/ethtool -N eth1 rx-flow-hash $proto sdfn\ndone\n```\n\n----------------------------------------\n\nTITLE: Defining Frame Types Enum in Rust\nDESCRIPTION: This code snippet demonstrates how to define an enum for frame types in Rust. The enum is derived from `AppLayerFrameType`, which is crucial for frame registration and callback inference.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/app-layer/app-layer-frames.rst#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub enum FrameType {\n    Pdu,\n    Request,\n    Response,\n}\n\nimpl AppLayerFrameType for FrameType {\n    fn to_static_str(&self) -> &'static str {\n        match self {\n            FrameType::Pdu => \"sip.pdu\",\n            FrameType::Request => \"sip.request\",\n            FrameType::Response => \"sip.response\",\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding LibHTP as a dependency using Cargo\nDESCRIPTION: This snippet demonstrates how to add LibHTP as a dependency to a Rust project using Cargo. It specifies the htp crate and version 2.0.0. The minimum supported Rust version is 1.58.1.\nSOURCE: https://github.com/oisf/suricata/blob/master/rust/htp/README.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n[dependencies]\nhtp = \"2.0.0\"\n```\n\n----------------------------------------\n\nTITLE: List Hostbit Response Example\nDESCRIPTION: Illustrates the JSON response format when listing hostbits via the Suricata Unix socket. The response includes a count of hostbits and an array of hostbit objects, each containing the 'expire' time (in seconds) and 'name' of the bit.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/xbits.rst#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"message\":\n    {\n       \"count\": 1,\n       \"hostbits\":\n            [{\n                \"expire\": 89,\n                \"name\": \"blacklist\"\n            }]\n    },\n    \"return\": \"OK\"\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Packet Logger in Suricata (C)\nDESCRIPTION: This code snippet shows the function signature for registering a packet logger within Suricata. Packet loggers are used to log alerts related to network packets. The `SCOutputRegisterPacketLogger` function is used to register a custom packet logger, enabling extensions to Suricata's alerting mechanism.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/extending/output/index.rst#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/** \\brief Register a packet logger\n *\n *  This function registers a function that is responsible for logging\n *  packet related output.\n *\n *  \\param logger The logger to register.\n *\n *  \\return void\n */\n```\n\nLANGUAGE: c\nCODE:\n```\nvoid SCOutputRegisterPacketLogger(void (*logger)(SCLogRecord *lr, Packet *p, void *data)\n\n```\n\nLANGUAGE: c\nCODE:\n```\n                         , void *data\n```\n\nLANGUAGE: c\nCODE:\n```\n                         , void (*deinit)(void *data)\n```\n\nLANGUAGE: c\nCODE:\n```\n                         );\n```\n\n----------------------------------------\n\nTITLE: Configuring Manual Configuration in Suricata YAML\nDESCRIPTION: This YAML snippet disables Napatech auto-config and specifies the streams that Suricata will use in manual configuration mode.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/capture-hardware/napatech.rst#_snippet_10\n\nLANGUAGE: YAML\nCODE:\n```\nnapatech:\n      auto-config: no\n      streams: [\"0-3\"]\n```\n\n----------------------------------------\n\nTITLE: Inspecting Init Script for Syslog Daemon (Linux)\nDESCRIPTION: This code snippet illustrates how to examine the contents of a syslog daemon's init script (e.g., rsyslogd) using `less`. This allows one to identify the specific syslog daemon and its configuration details by looking for comment lines or the binaries that are started.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/output/syslog-alerting-comp.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nless rsyslogd\n```\n\n----------------------------------------\n\nTITLE: Incorrect Enum Definition\nDESCRIPTION: Example of an incorrect enum definition as it is defined on a single line. Each value should be on a separate line.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_29\n\nLANGUAGE: c\nCODE:\n```\nenum { VALUE_ONE, VALUE_TWO };  // <- wrong\n```\n\n----------------------------------------\n\nTITLE: Formatting a whole file\nDESCRIPTION: This bash command formats a whole file with clang-format.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ clang-format -i {file}\n```\n\n----------------------------------------\n\nTITLE: Check formatting\nDESCRIPTION: This bash script checks if branch changes' formatting is correct.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ scripts/clang-format.sh check-branch\n```\n\n----------------------------------------\n\nTITLE: GitHub Filter for Approved Pull Requests\nDESCRIPTION: This filter identifies pull requests that are open, are pull requests, and have been approved. This is used to find pull requests ready for merging.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/contributing/github-pr-workflow.rst#_snippet_4\n\nLANGUAGE: GitHub Query Language\nCODE:\n```\nis:open is:pr review:approved\n```\n\n----------------------------------------\n\nTITLE: Installing clang and git-clang-format on fedora\nDESCRIPTION: This bash command installs clang and git-clang-format packages on Fedora.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo dnf install clang git-clang-format\n```\n\n----------------------------------------\n\nTITLE: Goto Statement Usage Example\nDESCRIPTION: Example demonstrating the recommended usage of goto statements for error handling. This example shows how to use goto to jump to an error label to free allocated memory.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nstatic DetectFileextData *DetectFileextParse (char *str)\n{\n    DetectFileextData *fileext = NULL;\n\n    fileext = SCMalloc(sizeof(DetectFileextData));\n    if (unlikely(fileext == NULL))\n        goto error;\n\n    memset(fileext, 0x00, sizeof(DetectFileextData));\n\n    if (DetectContentDataParse(\"fileext\", str, &fileext->ext, &fileext->len, &fileext->flags) == -1) {\n        goto error;\n    }\n\n    return fileext;\n\nerror:\n    if (fileext != NULL)\n        DetectFileextFree(fileext);\n    return NULL;\n}\n```\n\n----------------------------------------\n\nTITLE: C Unit Test - IKE SA Parser\nDESCRIPTION: This unit test from `detect-ike-chosen-sa.c` tests the parsing of IKE Chosen SA data. It parses a string containing SA parameters, checks if the parsed values are correct, and then frees the allocated resources using `DetectIkeChosenSaFree`. It makes sure to define the test within `#ifdef UNITTESTS`.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/unittests-c.rst#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#ifdef UNITTESTS\n.\n.\n.\nstatic int IKEChosenSaParserTest(void)\n{\n    DetectIkeChosenSaData *de = NULL;\nde = DetectIkeChosenSaParse(\"alg_hash=2\");\n\n    FAIL_IF_NULL(de);\n    FAIL_IF(de->sa_value != 2);\n    FAIL_IF(strcmp(de->sa_type, \"alg_hash\") != 0);\n\n    DetectIkeChosenSaFree(NULL, de);\n    PASS;\n}\n\n#endif /* UNITTESTS */\n```\n\n----------------------------------------\n\nTITLE: Macro Definition Examples\nDESCRIPTION: Examples of macro definitions using ALL_CAPS_WITH_UNDERSCORES. The values are aligned and parameters are enclosed in parentheses.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_26\n\nLANGUAGE: c\nCODE:\n```\n#define ACTION_ALERT       0x01\n#define ACTION_DROP        0x02\n#define ACTION_REJECT      0x04\n#define ACTION_REJECT_DST  0x08\n#define ACTION_REJECT_BOTH 0x10\n#define ACTION_PASS        0x20\n```\n\n----------------------------------------\n\nTITLE: Engine Analysis: IP Only Rule with Negated Address\nDESCRIPTION: This JSON represents the Engine Analysis report for a Suricata IP Only rule that contains negated IP addresses. Key details include the rule ID, message, type (like_ip_only), flags, and an empty lists section.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/rules/rule-types.rst#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"raw\": \"alert tcp [10.0.0.0/8,!10.10.10.10] any -> [10.0.0.0/8,!10.10.10.10] any (msg:\\\"tcp, has negated IP address\\\"; sid:305;)\",\n  \"id\": 305,\n  \"gid\": 1,\n  \"rev\": 0,\n  \"msg\": \"tcp, has negated IP address\",\n  \"app_proto\": \"unknown\",\n  \"requirements\": [],\n  \"type\": \"like_ip_only\",\n  \"flags\": [\n    \"sp_any\",\n    \"dp_any\",\n    \"toserver\",\n    \"toclient\"\n  ],\n  \"pkt_engines\": [],\n  \"frame_engines\": [],\n  \"lists\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Unittest Data Array Example (Incorrect)\nDESCRIPTION: Example demonstrating incorrect unittest formatting. The data array lacks an explanatory comment describing the content of the message.\nSOURCE: https://github.com/oisf/suricata/blob/master/doc/userguide/devguide/codebase/code-style.rst#_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nint SMTPProcessDataChunkTest02(void)\n{\n    char mimemsg[] = {0x4D, 0x49, 0x4D, 0x45, 0x2D, 0x56, 0x65, 0x72,\n```"
  }
]