[
  {
    "owner": "colour-science",
    "repo": "colour",
    "content": "TITLE: RGB to Prismatic Conversion in Python\nDESCRIPTION: Demonstrates converting RGB color values to Prismatic color space values using the `colour.RGB_to_Prismatic` function. The function takes an RGB triplet as input and returns the corresponding Prismatic values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_81\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_to_Prismatic([0.25, 0.50, 0.75])\n```\n\n----------------------------------------\n\nTITLE: Importing Colour Science Library in Python\nDESCRIPTION: This snippet demonstrates how to import the colour-science library in Python. It is the first step to use any of the functions provided by this library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport colour\n```\n\n----------------------------------------\n\nTITLE: Chromatic Adaptation using different methods in Python\nDESCRIPTION: Shows how to perform chromatic adaptation using the `colour.chromatic_adaptation` function. It converts XYZ values from one illuminant to another (D65 to A). It also lists the available chromatic adaptation methods in the library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nXYZ = [0.20654008, 0.12197225, 0.05136952]\nD65 = colour.CCS_ILLUMINANTS[\"CIE 1931 2 Degree Standard Observer\"][\"D65\"]\nA = colour.CCS_ILLUMINANTS[\"CIE 1931 2 Degree Standard Observer\"][\"A\"]\ncolour.chromatic_adaptation(XYZ, colour.xy_to_XYZ(D65), colour.xy_to_XYZ(A))\n\nsorted(colour.CHROMATIC_ADAPTATION_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Converting CIE XYZ to sRGB in Python\nDESCRIPTION: This snippet shows how to convert CIE XYZ tristimulus values to sRGB colourspace values. It first scales the XYZ values from the [0, 100] domain to the [0, 1] domain required by the XYZ_to_sRGB function, and then performs the conversion.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n    # The output domain of *colour.sd_to_XYZ* is [0, 100] and the input\n    # domain of *colour.XYZ_to_sRGB* is [0, 1]. It needs to be accounted for,\n    # thus the input *CIE XYZ* tristimulus values are scaled.\n    RGB = colour.XYZ_to_sRGB(XYZ / 100)\n    print(RGB)\n```\n\n----------------------------------------\n\nTITLE: Converting XYZ to xy Chromaticity Coordinates in Python\nDESCRIPTION: This snippet converts CIE XYZ tristimulus values to CIE xy chromaticity coordinates using the XYZ_to_xy function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n    # Computing *CIE xy* chromaticity coordinates for the *neutral 5 (.70 D)* patch.\n    xy = colour.XYZ_to_xy(XYZ)\n    print(xy)\n```\n\n----------------------------------------\n\nTITLE: Colour Correction in Python\nDESCRIPTION: Demonstrates colour correction using `colour.colour_correction`. It corrects RGB values based on a transformation matrix and a reference matrix. Requires RGB values, a source transformation matrix and a target or reference matrix.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport colour\nimport numpy as np\n\nRGB = [0.17224810, 0.09170660, 0.06416938]\nM_T = np.random.random((24, 3))\nM_R = M_T + (np.random.random((24, 3)) - 0.5) * 0.5\ncolour.colour_correction(RGB, M_T, M_R)\n\nsorted(colour.COLOUR_CORRECTION_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Convert Spectral Distribution to XYZ Python\nDESCRIPTION: This snippet demonstrates how to convert a spectral distribution to XYZ tristimulus values. It uses the `sd_to_XYZ` function and retrieves a spectral distribution from a predefined dictionary. The `colour` library is required for this conversion. The input is a spectral distribution and the output is XYZ tristimulus values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ncolour.sd_to_XYZ(colour.SDS_LIGHT_SOURCES[\"Neodimium Incandescent\"])\n```\n\n----------------------------------------\n\nTITLE: XYZ to Lab Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to CIE L*a*b* color space values using the `colour.XYZ_to_Lab` function. This function takes an XYZ triplet as input and returns the corresponding L*a*b* values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_Lab([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Importing Colour Plotting Module\nDESCRIPTION: This code snippet imports the plotting module from the Colour library and applies a default colour style. It also generates and displays a plot of the visible spectrum using the library's built-in functions.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom colour.plotting import *\n\ncolour_style()\n\nplot_visible_spectrum()\n```\n\n----------------------------------------\n\nTITLE: XYZ to RGB Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to RGB color space values using the `colour.XYZ_to_RGB` function. It requires specifying illuminants and a transformation matrix. The function takes an XYZ triplet, illuminant values, a matrix, and a chromatic adaptation transform as input and returns the corresponding RGB values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_82\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.21638819, 0.12570000, 0.03847493]\nilluminant_XYZ = [0.34570, 0.35850]\nilluminant_RGB = [0.31270, 0.32900]\nchromatic_adaptation_transform = \"Bradford\"\nmatrix_XYZ_to_RGB = [\n    [3.24062548, -1.53720797, -0.49862860],\n    [-0.96893071, 1.87575606, 0.04151752],\n    [0.05571012, -0.20402105, 1.05699594],\n]\ncolour.XYZ_to_RGB(\n    XYZ,\n    illuminant_XYZ,\n    illuminant_RGB,\n    matrix_XYZ_to_RGB,\n    chromatic_adaptation_transform,\n)\n```\n\n----------------------------------------\n\nTITLE: RGB to ICtCp Conversion in Python\nDESCRIPTION: Demonstrates converting RGB color values to ICtCp color encoding values using the `colour.RGB_to_ICtCp` function. The function takes an RGB triplet as input and returns the corresponding ICtCp values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_78\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_to_ICtCp([0.45620519, 0.03081071, 0.04091952])\n```\n\n----------------------------------------\n\nTITLE: Calculating Colour Rendering Index using Python\nDESCRIPTION: This code calculates the Colour Rendering Index (CRI) for a given illuminant ('FL2') using the `colour.colour_rendering_index` function. CRI is a metric that quantifies the ability of a light source to reveal the colours of various objects faithfully in comparison to an ideal or natural light source.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\ncolour.colour_rendering_index(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: Reading an Image in Python\nDESCRIPTION: Demonstrates reading an image file using the `colour.read_image` function. The resulting RGB data is stored in the `RGB` variable, and its shape (dimensions) is accessed to get the image's width, height, and number of color channels.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nRGB = colour.read_image(\"Ishihara_Colour_Blindness_Test_Plate_3.png\")\nRGB.shape\n```\n\n----------------------------------------\n\nTITLE: Applying a Look-Up Table in Python\nDESCRIPTION: Demonstrates how to apply a Look-Up Table (LUT) to an RGB color value using the `LUT.apply` method. The LUT transforms the input RGB values to the output color space.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nRGB = [0.17224810, 0.09170660, 0.06416938]\nLUT.apply(RGB)\n```\n\n----------------------------------------\n\nTITLE: XYZ to ProLab Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to ProLab color space values using the `colour.XYZ_to_ProLab` function. This function takes an XYZ triplet as input and returns the corresponding ProLab values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_73\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_ProLab([0.51634019, 0.15469500, 0.06289579])\n```\n\n----------------------------------------\n\nTITLE: Convert Multi-Spectral Data to XYZ Python\nDESCRIPTION: This snippet converts multi-spectral data to XYZ tristimulus values using the `msds_to_XYZ` function. It demonstrates how to process a set of spectral distributions and obtain corresponding XYZ values. It uses Integration method with specified shape.  The snippet requires the `numpy` and `colour` libraries.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nmsds = np.array(\n        [\n            [\n                [\n                    0.01367208,\n                    0.09127947,\n                    0.01524376,\n                    0.02810712,\n                    0.19176012,\n                    0.04299992,\n                ],\n                [\n                    0.00959792,\n                    0.25822842,\n                    0.41388571,\n                    0.22275120,\n                    0.00407416,\n                    0.37439537,\n                ],\n                [\n                    0.01791409,\n                    0.29707789,\n                    0.56295109,\n                    0.23752193,\n                    0.00236515,\n                    0.58190280,\n                ],\n            ],\n            [\n                [\n                    0.01492332,\n                    0.10421912,\n                    0.02240025,\n                    0.03735409,\n                    0.57663846,\n                    0.32416266,\n                ],\n                [\n                    0.04180972,\n                    0.26402685,\n                    0.03572137,\n                    0.00413520,\n                    0.41808194,\n                    0.24696727,\n                ],\n                [\n                    0.00628672,\n                    0.11454948,\n                    0.02198825,\n                    0.39906919,\n                    0.63640803,\n                    0.01139849,\n                ],\n            ],\n            [\n                [\n                    0.04325933,\n                    0.26825359,\n                    0.23732357,\n                    0.05175860,\n                    0.01181048,\n                    0.08233768,\n                ],\n                [\n                    0.02484169,\n                    0.12027161,\n                    0.00541695,\n                    0.00654612,\n                    0.18603799,\n                    0.36247808,\n                ],\n                [\n                    0.03102159,\n                    0.16815442,\n                    0.37186235,\n                    0.08610666,\n                    0.00413520,\n                    0.78492409,\n                ],\n            ],\n            [\n                [\n                    0.11682307,\n                    0.78883040,\n                    0.74468607,\n                    0.83375293,\n                    0.90571451,\n                    0.70054168,\n                ],\n                [\n                    0.06321812,\n                    0.41898224,\n                    0.15190357,\n                    0.24591440,\n                    0.55301750,\n                    0.00657664,\n                ],\n                [\n                    0.00305180,\n                    0.11288624,\n                    0.11357290,\n                    0.12924391,\n                    0.00195315,\n                    0.21771573,\n                ],\n            ],\n        ]\n    )\n    colour.msds_to_XYZ(\n        msds,\n        method=\"Integration\",\n        shape=colour.SpectralShape(400, 700, 60),\n    )\n```\n\n----------------------------------------\n\nTITLE: Compute Dominant Wavelength Python\nDESCRIPTION: This snippet computes the dominant wavelength for a given colour and whitepoint. It requires the `colour` library. The input is a colour in xy chromaticity coordinates and a whitepoint in xy chromaticity coordinates. The result is the dominant wavelength, xy coordinates of the dominant wavelength, and xy coordinates of the complementary wavelength.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nxy = [0.54369557, 0.32107944]\nxy_n = [0.31270000, 0.32900000]\ncolour.dominant_wavelength(xy, xy_n)\n```\n\n----------------------------------------\n\nTITLE: XYZ to xyY Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to CIE xyY color space values using the `colour.XYZ_to_xyY` function. This function takes an XYZ triplet as input and returns the corresponding xyY values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_55\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_xyY([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Calculating Delta E in Python\nDESCRIPTION: Demonstrates how to calculate the Delta E (color difference) between two Lab color values using the `colour` library. This involves defining two Lab color values (Lab_1 and Lab_2) and using the `colour.delta_E` function to compute the color difference between them.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nLab_1 = [100.00000000, 21.57210357, 272.22819350]\nLab_2 = [100.00000000, 426.67945353, 72.39590835]\ncolour.delta_E(Lab_1, Lab_2)\n```\n\n----------------------------------------\n\nTITLE: Normalised Primary Matrix in Python\nDESCRIPTION: Demonstrates calculating the normalised primary matrix from a set of primaries and a whitepoint, used for RGB color space derivation, using `colour.normalised_primary_matrix`. The parameters `p` represent the xy chromaticity coordinates of the red, green, and blue primaries, followed by the luminance of red, green, and blue primaries. `w` represents the xy chromaticity coordinates of the whitepoint.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_83\n\nLANGUAGE: python\nCODE:\n```\np = [0.73470, 0.26530, 0.00000, 1.00000, 0.00010, -0.07700]\nw = [0.32168, 0.33767]\ncolour.normalised_primary_matrix(p, w)\n```\n\n----------------------------------------\n\nTITLE: XYZ to CAM02UCS Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to CAM02-UCS color space values using the `colour.XYZ_to_CIECAM02` and `colour.JMh_CIECAM02_to_CAM02UCS` functions. This function chain involves first converting XYZ to CIECAM02 specification, then converting the JMh components to CAM02UCS. It also shows the direct conversion using the `XYZ_to_CAM02UCS` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\nsurround = colour.VIEWING_CONDITIONS_CIECAM02[\"Average\"]\nspecification = colour.XYZ_to_CIECAM02(XYZ, XYZ_w, L_A, Y_b, surround)\nJMh = (specification.J, specification.M, specification.h)\ncolour.JMh_CIECAM02_to_CAM02UCS(JMh)\n```\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008, 0.12197225, 0.05136952]\nXYZ_w = [95.05 / 100, 100.00 / 100, 108.88 / 100]\ncolour.XYZ_to_CAM02UCS(XYZ, XYZ_w=XYZ_w, L_A=L_A, Y_b=Y_b)\n```\n\n----------------------------------------\n\nTITLE: XYZ to hdr-IPT Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to hdr-IPT color space values using the `colour.XYZ_to_hdr_IPT` function. This function takes an XYZ triplet as input and returns the corresponding hdr-IPT values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_68\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_hdr_IPT([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Reading a Spectral Image in Python\nDESCRIPTION: Demonstrates how to read a spectral image using the `colour.read_spectral_image_Fichet2021` function. This function reads a spectral image file (in this case, \"Polarised.exr\") and returns a dictionary-like object containing the spectral components. The keys of this object represent the different spectral components (e.g., S0, S1, S2, S3).\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\ncomponents = colour.read_spectral_image_Fichet2021(\"Polarised.exr\")\nlist(components.keys())\n```\n\n----------------------------------------\n\nTITLE: XYZ to ICaCb Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to ICaCb color space values using the `XYZ_to_ICaCb` function.  The function takes an XYZ triplet as input and returns the corresponding ICaCb values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nXYZ_to_ICaCb(np.array([0.20654008, 0.12197225, 0.05136952]))\n```\n\n----------------------------------------\n\nTITLE: Automatic Colour Conversion in Python\nDESCRIPTION: This snippet shows how to automatically convert a spectral distribution to sRGB using the `colour.convert` function. It takes a spectral distribution, input color space, and output color space as parameters and provides verbose output of the conversion path.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nsd = colour.SDS_COLOURCHECKERS[\"ColorChecker N Ohta\"][\"dark skin\"]\ncolour.convert(sd, \"Spectral Distribution\", \"sRGB\", verbose={\"mode\": \"Short\"})\n```\n\n----------------------------------------\n\nTITLE: ACES Input Transform Matrix Calculation in Python\nDESCRIPTION: Calculates the ACES input device transform (IDT) matrix. It uses camera sensitivities and an illuminant to compute the transformation matrix.  This function `colour.matrix_idt` requires spectral sensitivities and a spectral illuminant distribution.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nsensitivities = colour.MSDS_CAMERA_SENSITIVITIES[\"Nikon 5100 (NPL)\"]\nilluminant = colour.SDS_ILLUMINANTS[\"D55\"]\ncolour.matrix_idt(sensitivities, illuminant)\n```\n\n----------------------------------------\n\nTITLE: Lab to DIN99 Conversion in Python\nDESCRIPTION: Demonstrates converting CIE L*a*b* color space values to DIN99 color space values using the `colour.Lab_to_DIN99` function. The function takes a Lab triplet as input and returns the corresponding DIN99 values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nLab = [41.52787529, 52.63858304, 26.92317922]\ncolour.Lab_to_DIN99(Lab)\n```\n\n----------------------------------------\n\nTITLE: Perform Colour Correction Python\nDESCRIPTION: This snippet demonstrates how to perform colour correction using the colour library. It takes an RGB colour, a transformation matrix, and a reference matrix as input.  It requires the `numpy` and `colour` libraries. The output is the colour corrected RGB values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nRGB = [0.17224810, 0.09170660, 0.06416938]\nM_T = np.random.random((24, 3))\nM_R = M_T + (np.random.random((24, 3)) - 0.5) * 0.5\ncolour.colour_correction(RGB, M_T, M_R)\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic Operations on Spectral Distributions in Python\nDESCRIPTION: This snippet demonstrates how to perform arithmetic operations such as addition, multiplication, and division on spectral distributions. It initializes a spectral distribution and performs several arithmetic operations, including addition with a scalar, multiplication with a scalar, multiplication with an array, and multiplication with constant spectral distributions.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n    sd = colour.SpectralDistribution(\n        {\n            410: 0.25,\n            420: 0.50,\n            430: 0.75,\n            440: 1.0,\n            450: 0.75,\n            460: 0.50,\n            480: 0.25,\n        }\n    )\n\n    print((sd.copy() + 1).values)\n    print((sd.copy() * 2).values)\n    print((sd * [0.35, 1.55, 0.75, 2.55, 0.95, 0.65, 0.15]).values)\n    print((sd * colour.sd_constant(2, sd.shape) * colour.sd_constant(3, sd.shape)).values)\n```\n\n----------------------------------------\n\nTITLE: Creating SpectralDistribution in Python\nDESCRIPTION: This code snippet demonstrates how to create a `SpectralDistribution` object in the `colour` library using a sample dataset.  It shows how to define the spectral data as a dictionary, where keys are wavelengths and values are corresponding spectral values, and then creates a `SpectralDistribution` object with the defined data and a name. The `repr` function is used to print the representation of the created object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Defining a sample spectral distribution data.\ndata_sample = {\n    380: 0.048,\n    385: 0.051,\n    390: 0.055,\n    395: 0.060,\n    400: 0.065,\n    405: 0.068,\n    410: 0.068,\n    415: 0.067,\n    420: 0.064,\n    425: 0.062,\n    430: 0.059,\n    435: 0.057,\n    440: 0.055,\n    445: 0.054,\n    450: 0.053,\n    455: 0.053,\n    460: 0.052,\n    465: 0.052,\n    470: 0.052,\n    475: 0.053,\n    480: 0.054,\n    485: 0.055,\n    490: 0.057,\n    495: 0.059,\n    500: 0.061,\n    505: 0.062,\n    510: 0.065,\n    515: 0.067,\n    520: 0.070,\n    525: 0.072,\n    530: 0.074,\n    535: 0.075,\n    540: 0.076,\n    545: 0.078,\n    550: 0.079,\n    555: 0.082,\n    560: 0.087,\n    565: 0.092,\n    570: 0.100,\n    575: 0.107,\n    580: 0.115,\n    585: 0.122,\n    590: 0.129,\n    595: 0.134,\n    600: 0.138,\n    605: 0.142,\n    610: 0.146,\n    615: 0.150,\n    620: 0.154,\n    625: 0.158,\n    630: 0.163,\n    635: 0.167,\n    640: 0.173,\n    645: 0.180,\n    650: 0.188,\n    655: 0.196,\n    660: 0.204,\n    665: 0.213,\n    670: 0.222,\n    675: 0.231,\n    680: 0.242,\n    685: 0.251,\n    690: 0.261,\n    695: 0.271,\n    700: 0.282,\n    705: 0.294,\n    710: 0.305,\n    715: 0.318,\n    720: 0.334,\n    725: 0.354,\n    730: 0.372,\n    735: 0.392,\n    740: 0.409,\n    745: 0.420,\n    750: 0.436,\n    755: 0.450,\n    760: 0.462,\n    765: 0.465,\n    770: 0.448,\n    775: 0.432,\n    780: 0.421,\n}\n\nsd = colour.SpectralDistribution(data_sample, name=\"Sample\")\nprint(repr(sd))\n```\n\n----------------------------------------\n\nTITLE: XYZ to IgPgTg Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to IgPgTg color space values using the `colour.XYZ_to_IgPgTg` function. This function takes an XYZ triplet as input and returns the corresponding IgPgTg values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_64\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_IgPgTg([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: XYZ to CAM16UCS Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to CAM16-UCS color space values using the `colour.XYZ_to_CAM16` and `colour.JMh_CAM16_to_CAM16UCS` functions. This function chain involves first converting XYZ to CAM16 specification, then converting the JMh components to CAM16UCS. It also shows the direct conversion using the `XYZ_to_CAM16UCS` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\nsurround = colour.VIEWING_CONDITIONS_CAM16[\"Average\"]\nspecification = colour.XYZ_to_CAM16(XYZ, XYZ_w, L_A, Y_b, surround)\nJMh = (specification.J, specification.M, specification.h)\ncolour.JMh_CAM16_to_CAM16UCS(JMh)\n```\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008, 0.12197225, 0.05136952]\nXYZ_w = [95.05 / 100, 100.00 / 100, 108.88 / 100]\ncolour.XYZ_to_CAM16UCS(XYZ, XYZ_w=XYZ_w, L_A=L_A, Y_b=Y_b)\n```\n\n----------------------------------------\n\nTITLE: Compute Lightness Python\nDESCRIPTION: This snippet calculates the lightness value from a given luminance value using the CIE 1976 formula by default.  It requires the `colour` library. The input is a luminance value and the output is a lightness value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ncolour.lightness(12.19722535)\n```\n\n----------------------------------------\n\nTITLE: Chromatic Adaptation in Python\nDESCRIPTION: This code shows how to perform chromatic adaptation using the `colour.chromatic_adaptation` function. It converts XYZ values from one illuminant to another, using the Von Kries transform by default.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nXYZ = [0.20654008, 0.12197225, 0.05136952]\nD65 = colour.CCS_ILLUMINANTS[\"CIE 1931 2 Degree Standard Observer\"][\"D65\"]\nA = colour.CCS_ILLUMINANTS[\"CIE 1931 2 Degree Standard Observer\"][\"A\"]\ncolour.chromatic_adaptation(XYZ, colour.xy_to_XYZ(D65), colour.xy_to_XYZ(A))\n```\n\n----------------------------------------\n\nTITLE: Install Colour Science Library using pip in Bash\nDESCRIPTION: This command installs the Colour Science library and its primary dependencies from the Python Package Index using pip. The '--user' flag installs the package in the user's home directory.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_133\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install --user colour-science\n```\n\n----------------------------------------\n\nTITLE: Automatic Colour Conversion Graph with Illuminant\nDESCRIPTION: Illustrates how to convert a spectral distribution to sRGB colourspace, specifying the illuminant.  This is a modification of the previous example adding the `sd_to_XYZ` parameter for illuminant control.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nilluminant = colour.SDS_ILLUMINANTS[\"FL2\"]\ncolour.convert(\n    sd,\n    \"Spectral Distribution\",\n    \"sRGB\",\n    sd_to_XYZ={\"illuminant\": illuminant},\n)\n```\n\n----------------------------------------\n\nTITLE: Compute Luminous Flux Python\nDESCRIPTION: This snippet calculates the luminous flux of a given spectral distribution. It utilizes a predefined light source spectral distribution.  It requires the `colour` library and a SpectralDistribution object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nsd = colour.SDS_LIGHT_SOURCES[\"Neodimium Incandescent\"]\ncolour.luminous_flux(sd)\n```\n\n----------------------------------------\n\nTITLE: Converting a List of xyY Tuples to XYZ in Colour\nDESCRIPTION: This example demonstrates converting a list of xyY tuples to XYZ values. It shows support for a list containing multiple xyY tuples, demonstrating n-dimensional array support. It imports the `colour` module and calls the `xyY_to_XYZ` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nxyY = [\n    (0.4316, 0.3777, 0.1008),\n    (0.4316, 0.3777, 0.1008),\n    (0.4316, 0.3777, 0.1008),\n]\ncolour.xyY_to_XYZ(xyY)\n```\n\nLANGUAGE: text\nCODE:\n```\narray([[ 0.11518475,  0.1008    ,  0.05089373],\n       [ 0.11518475,  0.1008    ,  0.05089373],\n       [ 0.11518475,  0.1008    ,  0.05089373]])\n```\n\n----------------------------------------\n\nTITLE: Converting UV to Correlated Colour Temperature\nDESCRIPTION: Converts CIE 1976 *uv* chromaticity coordinates to Correlated Colour Temperature (CCT) in Kelvin and *Duv*. This function takes *uv* coordinates as input and returns an array containing the CCT and *Duv* values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_111\n\nLANGUAGE: python\nCODE:\n```\ncolour.uv_to_CCT([0.1978, 0.3122])\n```\n\n----------------------------------------\n\nTITLE: Automatic Colour Conversion Graph in Python\nDESCRIPTION: Demonstrates automatic colour conversion using the `colour.convert` function. It shows how to convert a spectral distribution to sRGB colourspace, with optional verbosity and the ability to specify the illuminant for the conversion.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nsd = colour.SDS_COLOURCHECKERS[\"ColorChecker N Ohta\"][\"dark skin\"]\ncolour.convert(sd, \"Spectral Distribution\", \"sRGB\", verbose={\"mode\": \"Short\"})\n```\n\n----------------------------------------\n\nTITLE: Listing Available Colour Rendering Index Methods\nDESCRIPTION: Lists the available methods for calculating the Colour Rendering Index (CRI). This function returns a sorted list of strings, each representing a different method that can be used to compute the CRI.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_106\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.COLOUR_RENDERING_INDEX_METHODS)\n```\n\n----------------------------------------\n\nTITLE: RGB to HSV Conversion in Python\nDESCRIPTION: Demonstrates converting RGB color values to HSV color space values using the `colour.RGB_to_HSV` function. The function takes an RGB triplet as input and returns the corresponding HSV values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_79\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_to_HSV([0.45620519, 0.03081071, 0.04091952])\n```\n\n----------------------------------------\n\nTITLE: Compute Yellowness Index Python\nDESCRIPTION: This snippet computes the yellowness index for a given XYZ tristimulus value. It utilizes the default ASTM D1925 method. It requires the `colour` library. The input is XYZ tristimulus values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [95.00000000, 100.00000000, 105.00000000]\ncolour.yellowness(XYZ)\n```\n\n----------------------------------------\n\nTITLE: Listing Chromatic Adaptation Methods\nDESCRIPTION: This snippet lists the available chromatic adaptation methods in the colour-science library using the `colour.CHROMATIC_ADAPTATION_METHODS` constant.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nsorted(colour.CHROMATIC_ADAPTATION_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Listing Delta E Methods in Python\nDESCRIPTION: Shows how to retrieve a sorted list of available Delta E calculation methods within the `colour` library. This is done by accessing the `colour.DELTA_E_METHODS` attribute and sorting the resulting list.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.DELTA_E_METHODS)\n```\n\n----------------------------------------\n\nTITLE: XYZ to Hunter Lab Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to Hunter L,a,b color scale values using the `colour.XYZ_to_Hunter_Lab` function.  The XYZ values are first scaled by 100. The function takes an XYZ triplet as input and returns the corresponding Hunter Lab values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_69\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\ncolour.XYZ_to_Hunter_Lab(XYZ)\n```\n\n----------------------------------------\n\nTITLE: Kernel Interpolation in Python\nDESCRIPTION: Demonstrates kernel interpolation using `colour.KernelInterpolator`.  It interpolates values at specified points based on given x and y data.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\ny = [5.9200, 9.3700, 10.8135, 4.5100, 69.5900, 27.8007, 86.0500]\nx = range(len(y))\ncolour.KernelInterpolator(x, y)([0.25, 0.75, 5.50])\n```\n\n----------------------------------------\n\nTITLE: CIECAM16 Colour Appearance Model in Python\nDESCRIPTION: Demonstrates the CIECAM16 colour appearance model using `colour.XYZ_to_CIECAM16`. Converts XYZ values to CIECAM16 parameters, similar to CIECAM02, requiring whitepoint XYZ, adapting luminance and background luminance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\ncolour.XYZ_to_CIECAM16(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Listing OETFs - Colour Science (Python)\nDESCRIPTION: This snippet retrieves a sorted list of Optical-Electrical Transfer Functions (OETFs) available in the `colour` library. OETFs define the relationship between linear light and the corresponding electrical signal, used in encoding color information for display or storage.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_85\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.OETFS)\n```\n\n----------------------------------------\n\nTITLE: XYZ to Hunter Rdab Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to Hunter Rd,a,b color scale values using the `colour.XYZ_to_Hunter_Rdab` function. The XYZ values are first scaled by 100.  The function takes an XYZ triplet as input and returns the corresponding Hunter Rdab values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\ncolour.XYZ_to_Hunter_Rdab(XYZ)\n```\n\n----------------------------------------\n\nTITLE: Spectral Distribution to XYZ Conversion in Python\nDESCRIPTION: Demonstrates converting a spectral distribution to XYZ tristimulus values using `colour.sd_to_XYZ`. It takes a spectral distribution as input and returns the corresponding XYZ values.  It also lists available `SPECTRAL_TO_XYZ_METHODS`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\ncolour.sd_to_XYZ(colour.SDS_LIGHT_SOURCES[\"Neodimium Incandescent\"])\n\nsorted(colour.SPECTRAL_TO_XYZ_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Using Domain-Range Scale Context Manager in Python\nDESCRIPTION: This snippet demonstrates how to temporarily override the Colour domain-range scale using the `colour.domain_range_scale` context manager. This ensures that functions within the context use the specified scale.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nwith colour.domain_range_scale(\"1\"):\n    colour.adaptation.chromatic_adaptation_CIE1994(XYZ_1, xy_o1, xy_o2, Y_o, E_o1, E_o2)\n```\n\n----------------------------------------\n\nTITLE: Changing Interpolator for Spectral Distribution in Python\nDESCRIPTION: This snippet demonstrates how to change the interpolator used for a spectral distribution using the `interpolate` method. It sets the interpolator to `colour.LinearInterpolator` while interpolating the copied spectral distribution to a new shape from 400 to 700 with an interval of 10. The `sd_copy` object is modified in place.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# Changing interpolator while trimming the copied spectral distribution.\nsd_copy.interpolate(\n    colour.SpectralShape(400, 700, 10),\n    interpolator=colour.LinearInterpolator,\n)\n```\n\n----------------------------------------\n\nTITLE: Compute Luminous Efficiency Python\nDESCRIPTION: This snippet calculates the luminous efficiency of a given spectral distribution. It uses a predefined light source spectral distribution. It requires the `colour` library and a SpectralDistribution object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nsd = colour.SDS_LIGHT_SOURCES[\"Neodimium Incandescent\"]\ncolour.luminous_efficiency(sd)\n```\n\n----------------------------------------\n\nTITLE: CAM16 Colour Appearance Model in Python\nDESCRIPTION: Demonstrates the CAM16 colour appearance model using `colour.XYZ_to_CAM16`. Converts XYZ values to CAM16 parameters, requiring whitepoint XYZ, adapting luminance and background luminance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\ncolour.XYZ_to_CAM16(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Calculating Colour Quality Scale with CIE Illuminant\nDESCRIPTION: Calculates the Colour Quality Scale (CQS) for a given spectral distribution (SDS). The function takes the SDS of an illuminant as input and returns the CQS value, quantifying the illuminant's overall colour quality.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_103\n\nLANGUAGE: python\nCODE:\n```\ncolour.colour_quality_scale(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: XYZ to Luv Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to CIE L*u*v* color space values using the `colour.XYZ_to_Luv` function. This function takes an XYZ triplet as input and returns the corresponding L*u*v* values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_57\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_Luv([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Compute Blackbody Spectral Radiance Python\nDESCRIPTION: This snippet calculates the spectral distribution of a blackbody radiator at a given temperature. The example uses a temperature of 5000K. The `colour` library is required.  The output is the spectral distribution.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ncolour.sd_blackbody(5000)\n```\n\n----------------------------------------\n\nTITLE: Calculating Spectral Similarity Index\nDESCRIPTION: Calculates the Spectral Similarity Index (SSI) between two spectral distributions. This function takes two SDSs as input and returns the SSI value, quantifying the similarity between the two spectra.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_107\n\nLANGUAGE: python\nCODE:\n```\ncolour.spectral_similarity_index(\n        colour.SDS_ILLUMINANTS[\"C\"], colour.SDS_ILLUMINANTS[\"D65\"]\n    )\n```\n\n----------------------------------------\n\nTITLE: Calculating Colour Rendering Index with CIE Illuminant\nDESCRIPTION: Calculates the Colour Rendering Index (CRI) for a given spectral distribution (SDS). The function takes the SDS of an illuminant as input and returns the CRI value, quantifying the illuminant's ability to render colours accurately compared to a reference illuminant.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_105\n\nLANGUAGE: python\nCODE:\n```\ncolour.colour_rendering_index(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: Compute Whiteness Index Python\nDESCRIPTION: This snippet computes the whiteness index for a given XYZ tristimulus value relative to a reference whitepoint. It utilizes the default CIE 2004 method. It requires the `colour` library. The inputs are XYZ tristimulus values and XYZ tristimulus values of the reference whitepoint.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [95.00000000, 100.00000000, 105.00000000]\nXYZ_0 = [94.80966767, 100.00000000, 107.30513595]\ncolour.whiteness(XYZ, XYZ_0)\n```\n\n----------------------------------------\n\nTITLE: XYZ to Jzazbz Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to Jzazbz color space values using the `colour.XYZ_to_Jzazbz` function. This function takes an XYZ triplet as input and returns the corresponding Jzazbz values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_66\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_Jzazbz([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Normalising Spectral Distribution in Python\nDESCRIPTION: This snippet normalizes a spectral distribution. The normalise function is called without arguments to normalize to a maximum value of 1. It is then called with an argument to normalize to a specific maximum value, in this case 100.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n    print(sd.normalise().values)\n    print(sd.normalise(100).values)\n```\n\n----------------------------------------\n\nTITLE: Compute Luminous Efficacy Python\nDESCRIPTION: This snippet calculates the luminous efficacy of a given spectral distribution. It uses a predefined light source spectral distribution. It requires the `colour` library and a SpectralDistribution object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nsd = colour.SDS_LIGHT_SOURCES[\"Neodimium Incandescent\"]\ncolour.luminous_efficacy(sd)\n```\n\n----------------------------------------\n\nTITLE: Colour Blindness Simulation in Python\nDESCRIPTION: Demonstrates simulating anomalous trichromacy using the Machado2009 method. Requires LMS colour matching functions and an anomaly vector for the degree of colour vision deficiency.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport colour\nimport numpy as np\n\ncmfs = colour.colorimetry.MSDS_CMFS_LMS[\"Stockman & Sharpe 2 Degree Cone Fundamentals\"]\ncolour.msds_cmfs_anomalous_trichromacy_Machado2009(cmfs, np.array([15, 0, 0]))[450]\n```\n\n----------------------------------------\n\nTITLE: List Yellowness Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available yellowness index computation methods from the `colour` library.  It shows the different yellowness formulas available. It requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.YELLOWNESS_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Converting xyY to Munsell Colour using Python\nDESCRIPTION: This code converts a colour specified in xyY coordinates ([0.38736945, 0.35751656, 0.59362000]) to its corresponding Munsell colour notation using the `colour.xyY_to_munsell_colour` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ncolour.xyY_to_munsell_colour([0.38736945, 0.35751656, 0.59362000])\n```\n\n----------------------------------------\n\nTITLE: Plot Planckian Locus in Chromaticity Diagram (Python)\nDESCRIPTION: Plots the Planckian locus in a CIE 1960 UCS chromaticity diagram, showing the path of blackbody radiation. The plot includes illuminants A, B, and C.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_88\n\nLANGUAGE: python\nCODE:\n```\nplot_planckian_locus_in_chromaticity_diagram_CIE1960UCS([\"A\", \"B\", \"C\"])\n```\n\n----------------------------------------\n\nTITLE: Converting xyY to Munsell Colour - Colour Science (Python)\nDESCRIPTION: This snippet converts a color specified in CIE xyY coordinates to its corresponding Munsell color notation using the `xyY_to_munsell_colour` function from the `colour` library. It uses the default settings for illuminant.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_98\n\nLANGUAGE: python\nCODE:\n```\ncolour.xyY_to_munsell_colour([0.38736945, 0.35751656, 0.59362000])\n```\n\n----------------------------------------\n\nTITLE: XYZ to hdr-CIELab Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to hdr-CIELAB color space values using the `colour.XYZ_to_hdr_CIELab` function. This function takes an XYZ triplet as input and returns the corresponding hdr-CIELAB values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_67\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_hdr_CIELab([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: List Luminance Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available luminance computation methods from the `colour` library. It showcases various algorithms available for luminance calculation. It requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.LUMINANCE_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Converting Munsell Colour to xyY using Python\nDESCRIPTION: This code converts a Munsell colour notation (\"4.2YR 8.1/5.3\") to its corresponding xyY coordinates using the `colour.munsell_colour_to_xyY` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ncolour.munsell_colour_to_xyY(\"4.2YR 8.1/5.3\")\n```\n\n----------------------------------------\n\nTITLE: Plot RGB Chromaticities in Chromaticity Diagram (Python)\nDESCRIPTION: Plots RGB chromaticities in a CIE 1931 chromaticity diagram, showcasing the gamut of a given RGB colourspace against other colourspaces and the pointer gamut. It plots random RGB values in a CIE 1931 diagram, shows the pointer gamut, and compares against ACEScg and S-Gamut colourspaces.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_83\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\n    RGB = np.random.random((32, 32, 3))\n    plot_RGB_chromaticities_in_chromaticity_diagram_CIE1931(\n        RGB,\n        \"ITU-R BT.709\",\n        colourspaces=[\"ACEScg\", \"S-Gamut\"],\n        show_pointer_gamut=True,\n    )\n```\n\n----------------------------------------\n\nTITLE: Plot Multi Luminous Efficiency Functions (Python)\nDESCRIPTION: Plots multiple luminous efficiency functions, including mesopic, photopic, and scotopic functions. This example shows the luminous efficiency functions and customizes plot parameters for y-axis labels, legend location, and margins.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_79\n\nLANGUAGE: python\nCODE:\n```\nsd_mesopic_luminous_efficiency_function = (\n        colour.sd_mesopic_luminous_efficiency_function(0.2)\n    )\n    plot_multi_sds(\n        (\n            sd_mesopic_luminous_efficiency_function,\n            colour.colorimetry.SDS_LEFS_PHOTOPIC[\"CIE 1924 Photopic Standard Observer\"],\n            colour.colorimetry.SDS_LEFS_SCOTOPIC[\"CIE 1951 Scotopic Standard Observer\"],\n        ),\n        y_label=\"Luminous Efficiency\",\n        legend_location=\"upper right\",\n        y_tighten=True,\n        margins=(0, 0, 0, 0.1),\n    )\n```\n\n----------------------------------------\n\nTITLE: Comparing Interpolated Spectral Distribution in Python\nDESCRIPTION: This snippet demonstrates how to compare an interpolated spectral distribution with the original one using `plot_multi_sds`. It takes a list of spectral distributions to plot, and bounding box arguments that define the region of the plot to focus on.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Comparing the interpolated spectral distribution with the original one.\nplot_multi_sds([sd, sd_copy], bounding_box=[730, 780, 0.25, 0.5])\n```\n\n----------------------------------------\n\nTITLE: Compute Luminance Python\nDESCRIPTION: This snippet calculates the luminance value from a given lightness value using the CIE 1976 formula by default.  It requires the `colour` library. The input is a lightness value and the output is a luminance value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\ncolour.luminance(41.52787585)\n```\n\n----------------------------------------\n\nTITLE: Compute Correlated Colour Temperature (Python)\nDESCRIPTION: Computes the correlated color temperature (CCT) from given *uv* chromaticity coordinates using the `colour.uv_to_CCT` function. It takes *uv* coordinates as input and returns the CCT and Duv values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_60\n\nLANGUAGE: python\nCODE:\n```\ncolour.uv_to_CCT([0.1978, 0.3122])\n```\n\n----------------------------------------\n\nTITLE: Converting Munsell Colour to xyY - Colour Science (Python)\nDESCRIPTION: This snippet converts a color specified in Munsell color notation to its corresponding CIE xyY coordinates using the `munsell_colour_to_xyY` function from the `colour` library. It represents the inverse operation of the previous snippet.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_99\n\nLANGUAGE: python\nCODE:\n```\ncolour.munsell_colour_to_xyY(\"4.2YR 8.1/5.3\")\n```\n\n----------------------------------------\n\nTITLE: Listing Colour Datasets in Python\nDESCRIPTION: This code snippet shows how to list the available datasets within the `colour.colorimetry.datasets` module using the `__all__` attribute.  The `pprint` function is used to pretty-print the list for better readability. This helps to discover available spectral datasets for colorimetric computations.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npprint(colour.colorimetry.datasets.__all__)\n```\n\n----------------------------------------\n\nTITLE: Plot Multi Colour Checker Spectral Distributions (Python)\nDESCRIPTION: Plots the spectral distributions of multiple color checker patches from the BabelColor Average dataset. The example plots the spectral distributions of colors from the BabelColor Average dataset, using the color checker's colors for the plot.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_80\n\nLANGUAGE: python\nCODE:\n```\nfrom colour.characterisation.dataset.colour_checkers.sds import (\n        COLOURCHECKER_INDEXES_TO_NAMES_MAPPING,\n    )\n\n    plot_multi_sds(\n        [\n            colour.SDS_COLOURCHECKERS[\"BabelColor Average\"][value]\n            for key, value in sorted(COLOURCHECKER_INDEXES_TO_NAMES_MAPPING.items())\n        ],\n        plot_kwargs={\n            \"use_sd_colours\": True,\n        },\n        title=(\"BabelColor Average - \" \"Spectral Distributions\"),\n    )\n```\n\n----------------------------------------\n\nTITLE: Plotting Multiple Colour Checker Spectral Distributions\nDESCRIPTION: Plots multiple spectral distributions from a colour checker dataset. The function retrieves spectral distributions for all patches in the 'BabelColor Average' colour checker and plots them, using spectral distribution colours.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_124\n\nLANGUAGE: python\nCODE:\n```\nfrom colour.characterisation.dataset.colour_checkers.sds import (\n        COLOURCHECKER_INDEXES_TO_NAMES_MAPPING,\n    )\n\nplot_multi_sds(\n        [\n            colour.SDS_COLOURCHECKERS[\"BabelColor Average\"][value]\n            for key, value in sorted(COLOURCHECKER_INDEXES_TO_NAMES_MAPPING.items())\n        ],\n        plot_kwargs={\n            \"use_sd_colours\": True,\n        },\n        title=(\"BabelColor Average - \" \"Spectral Distributions\"),\n    )\n```\n\n----------------------------------------\n\nTITLE: Converting XYZ to Spectral Distribution\nDESCRIPTION: Converts XYZ tristimulus values to a spectral distribution (SDS) using a reflectance recovery method. This function takes XYZ values as input and returns an SDS representing the spectral reflectance of a surface that would produce those XYZ values under a given illuminant.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_108\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_sd([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Listing Munsell Value Methods - Colour Science (Python)\nDESCRIPTION: This snippet retrieves a sorted list of available methods for calculating Munsell value in the `colour` library. Different methods use different equations or look-up tables to determine the Munsell value from a given luminance value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_97\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.MUNSELL_VALUE_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Automatic Colour Conversion with Illuminant\nDESCRIPTION: This example demonstrates how to convert a spectral distribution to sRGB while specifying the illuminant. The `sd_to_XYZ` parameter allows you to provide additional parameters for the conversion.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nilluminant = colour.SDS_ILLUMINANTS[\"FL2\"]\ncolour.convert(\n    sd,\n    \"Spectral Distribution\",\n    \"sRGB\",\n    sd_to_XYZ={\"illuminant\": illuminant},\n)\n```\n\n----------------------------------------\n\nTITLE: Listing XY to CCT Conversion Methods\nDESCRIPTION: Lists available methods for converting CIE 1931 *xy* chromaticity coordinates to Correlated Colour Temperature (CCT). The function returns a sorted list of strings, each representing a different conversion method.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_113\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.XY_TO_CCT_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Converting xyY to XYZ with a List in Colour\nDESCRIPTION: This example demonstrates how to convert from xyY chromaticity coordinates and luminance to XYZ tristimulus values using a list as input. It imports the `colour` module and calls the `xyY_to_XYZ` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nxyY = [0.4316, 0.3777, 0.1008]\ncolour.xyY_to_XYZ(xyY)\n```\n\nLANGUAGE: text\nCODE:\n```\narray([ 0.11518475,  0.1008    ,  0.05089373])\n```\n\n----------------------------------------\n\nTITLE: Listing Colour Rendering Index Methods using Python\nDESCRIPTION: This code snippet retrieves and sorts the available methods for calculating the Colour Rendering Index (CRI) using `colour.COLOUR_RENDERING_INDEX_METHODS`. These methods represent different standards for computing CRI.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.COLOUR_RENDERING_INDEX_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Mocking Scipy using mock_scipy_for_colour Function\nDESCRIPTION: This Python snippet shows a more concise method to mock Scipy using the `mock_scipy_for_colour` function. It imports the function from `mock_for_colour`, calls it to mock Scipy, and then imports Colour and performs the same xyY to XYZ conversion as the previous example. It provides a simplified way to use the mocking mechanism.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/advanced.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom mock_for_colour import mock_scipy_for_colour\n\nmock_scipy_for_colour()\n\nimport colour\n\nxyY = (0.4316, 0.3777, 0.1008)\ncolour.xyY_to_XYZ(xyY)\n```\n\n----------------------------------------\n\nTITLE: Plotting Spectral Distribution in Python\nDESCRIPTION: This code snippet demonstrates how to plot a sample spectral distribution using the `plot_single_sd` function.  It requires the `colour` library to be installed. The function takes a spectral distribution object as input and generates a plot.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Plotting the sample spectral distribution.\nplot_single_sd(sd)\n```\n\n----------------------------------------\n\nTITLE: Accessing Colorimetry API\nDESCRIPTION: This code snippet accesses and pretty-prints the __all__ attribute of the colour.colorimetry sub-package, displaying the public API related to spectral computations and other colorimetry-related functionality.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npprint(colour.colorimetry.__all__)\n```\n\n----------------------------------------\n\nTITLE: Listing Reflectance Recovery Methods using Python\nDESCRIPTION: This code snippet retrieves and sorts the available methods for reflectance recovery using `colour.REFLECTANCE_RECOVERY_METHODS`.  These methods are algorithms designed to estimate the spectral reflectance of a surface from other colourimetric data.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.REFLECTANCE_RECOVERY_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Converting Spectral Distribution to CIE XYZ Tristimulus Values in Python\nDESCRIPTION: This snippet demonstrates how to convert a spectral distribution to CIE XYZ tristimulus values. It initializes a spectral distribution, defines colour matching functions (CMFs), and an illuminant. Then, it uses the sd_to_XYZ function to calculate the XYZ values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n    sd = colour.SpectralDistribution(data_sample)\n    cmfs = colour.MSDS_CMFS[\"CIE 1931 2 Degree Standard Observer\"]\n    illuminant = colour.SDS_ILLUMINANTS[\"D65\"]\n\n    # Calculating the sample spectral distribution *CIE XYZ* tristimulus values.\n    XYZ = colour.sd_to_XYZ(sd, cmfs, illuminant)\n    print(XYZ)\n```\n\n----------------------------------------\n\nTITLE: List Multi-Spectral Data to XYZ Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available multi-spectral data to XYZ conversion methods. It provides an overview of available algorithms. It requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.MSDS_TO_XYZ_METHODS)\n```\n\n----------------------------------------\n\nTITLE: List Contrast Sensitivity Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available contrast sensitivity function computation methods from the `colour` library. It shows the available algorithms for computing contrast sensitivity. It requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.CONTRAST_SENSITIVITY_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Calculating Rayleigh Scattering using Python\nDESCRIPTION: This snippet calculates the spectral distribution of Rayleigh scattering using the `colour.sd_rayleigh_scattering()` function.  Rayleigh scattering is the scattering of electromagnetic radiation (including light) by particles of a wavelength comparable to or smaller than the wavelength of the radiation.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\ncolour.sd_rayleigh_scattering()\n```\n\n----------------------------------------\n\nTITLE: Compute RGB Colourspace Volume (Python)\nDESCRIPTION: Computes the volume of a given RGB colourspace using a Monte Carlo method. The code uses the `colour.RGB_colourspace_volume_MonteCarlo` function with the sRGB colourspace to estimate the colour volume.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_66\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_colourspace_volume_MonteCarlo(colour.RGB_COLOURSPACE_RGB[\"sRGB\"])\n```\n\n----------------------------------------\n\nTITLE: Spectral Distribution Value Retrieval\nDESCRIPTION: This code demonstrates how to retrieve a spectral distribution value at a specific wavelength using direct indexing. It initializes a SpectralDistribution object with wavelength-value pairs and then accesses the value at wavelength 555.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndata = {\n    500: 0.0651,\n    520: 0.0705,\n    540: 0.0772,\n    560: 0.0870,\n    580: 0.1128,\n    600: 0.1360,\n}\nsd = colour.SpectralDistribution(data)\nsd[555]\n```\n\n----------------------------------------\n\nTITLE: Calculating Colour Fidelity Index with CIE Illuminant\nDESCRIPTION: Calculates the Colour Fidelity Index (CFI) for a given spectral distribution (SDS). This function takes the spectral distribution of an illuminant as input and returns the CFI value, quantifying the illuminant's ability to accurately render colours.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_101\n\nLANGUAGE: python\nCODE:\n```\ncolour.colour_fidelity_index(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: List Colour Correction Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available colour correction methods from the `colour` library. It shows the different algorithms available for colour correction, such as 'Cheung 2004', 'Finlayson 2015', and 'Vandermonde'. It requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.COLOUR_CORRECTION_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Plot Corresponding Chromaticities Prediction (Python)\nDESCRIPTION: Plots corresponding chromaticities prediction using specified chromatic adaptation model and dataset. This example creates a plot to show how chromaticities are predicted to change under different viewing conditions.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_82\n\nLANGUAGE: python\nCODE:\n```\nplot_corresponding_chromaticities_prediction(2, \"Von Kries\", \"Bianco 2010\")\n```\n\n----------------------------------------\n\nTITLE: CIECAM02 Colour Appearance Model in Python\nDESCRIPTION: Demonstrates the CIECAM02 colour appearance model using `colour.XYZ_to_CIECAM02`. It converts XYZ values to CIECAM02 parameters given whitepoint XYZ, adapting luminance and background luminance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\ncolour.XYZ_to_CIECAM02(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Plot Multi Blackbody Spectral Distributions (Python)\nDESCRIPTION: Plots multiple blackbody spectral distributions for temperatures ranging from 1000K to 14000K. It plots blackbody spectral distributions, normalizes their colors, and adjusts the legend location and bounding box.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_77\n\nLANGUAGE: python\nCODE:\n```\nblackbody_sds = [\n        colour.sd_blackbody(i, colour.SpectralShape(1, 10001, 10))\n        for i in range(1000, 15000, 1000)\n    ]\n    plot_multi_sds(\n        blackbody_sds,\n        y_label=\"W / (sr m$^2$) / m\",\n        plot_kwargs={\"use_sd_colours\": True, \"normalise_sd_colours\": True},\n        legend_location=\"upper right\",\n        bounding_box=(0, 1250, 0, 2.5e6),\n    )\n```\n\n----------------------------------------\n\nTITLE: Listing Available Colour Quality Scale Methods\nDESCRIPTION: Lists the available methods for calculating the Colour Quality Scale (CQS). This function returns a sorted list of strings, each representing a different method that can be used to compute the CQS.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_104\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.COLOUR_QUALITY_SCALE_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Converting XYZ to Spectral Distribution using Python\nDESCRIPTION: This code snippet converts XYZ tristimulus values ([0.20654008, 0.12197225, 0.05136952]) to a spectral distribution using the `colour.XYZ_to_sd` function. This function attempts to recover a spectral distribution from its corresponding XYZ values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_sd([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Simulate Anomalous Trichromacy Python\nDESCRIPTION: This snippet demonstrates how to simulate anomalous trichromacy using the colour library. It imports the necessary modules and uses the `msds_cmfs_anomalous_trichromacy_Machado2009` function to calculate the colour appearance for a given anomalous observer. It requires the `numpy` and `colour` libraries. The code calculates the colorimetric data at 450nm for a specific anomalous trichromat.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\ncmfs = colour.colorimetry.MSDS_CMFS_LMS[\"Stockman & Sharpe 2 Degree Cone Fundamentals\"]\ncolour.msds_cmfs_anomalous_trichromacy_Machado2009(cmfs, np.array([15, 0, 0]))[450]\n```\n\n----------------------------------------\n\nTITLE: Calculating Munsell Value using Python\nDESCRIPTION: This code snippet demonstrates the calculation of a Munsell value from a given lightness value (12.23634268) using the `colour.munsell_value` function. The Munsell value represents the perceived lightness of a colour in the Munsell colour system.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ncolour.munsell_value(12.23634268)\n```\n\n----------------------------------------\n\nTITLE: Calculating Colour Fidelity Index using Python\nDESCRIPTION: This code calculates the Colour Fidelity Index (CFI) for a given illuminant ('FL2') using the `colour.colour_fidelity_index` function. CFI is a metric that measures the colour rendering accuracy of a light source.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\ncolour.colour_fidelity_index(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: Listing Colour Encoding Transfer Functions in text\nDESCRIPTION: This code snippet displays a list of common colour encoding transfer functions, such as 'ACEScc', 'ACEScct', 'sRGB', and others. These transfer functions are used to map linear light values to non-linear colour values for efficient storage and display.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_17\n\nLANGUAGE: text\nCODE:\n```\n['ACEScc',\n 'ACEScct',\n 'ACESproxy',\n 'ARIB STD-B67',\n 'ARRI LogC3',\n 'ARRI LogC4',\n 'Apple Log Profile',\n 'Blackmagic Film Generation 5',\n 'Canon Log',\n 'Canon Log 2',\n 'Canon Log 3',\n 'Cineon',\n 'D-Log',\n 'DCDM',\n 'DICOM GSDF',\n 'DaVinci Intermediate',\n 'ERIMM RGB',\n 'F-Log',\n 'F-Log2',\n 'Filmic Pro 6',\n 'Gamma 2.2',\n 'Gamma 2.4',\n 'Gamma 2.6',\n 'ITU-R BT.1886',\n 'ITU-R BT.2020',\n 'ITU-R BT.2100 HLG',\n 'ITU-R BT.2100 PQ',\n 'ITU-R BT.601',\n 'ITU-R BT.709',\n 'ITU-T H.273 IEC 61966-2',\n 'ITU-T H.273 Log',\n 'ITU-T H.273 Log Sqrt',\n 'ITU-T H.273 ST.428-1',\n 'L-Log',\n 'Log2',\n 'Log3G10',\n 'Log3G12',\n 'N-Log',\n 'PLog',\n 'Panalog',\n 'ProPhoto RGB',\n 'Protune',\n 'REDLog',\n 'REDLogFilm',\n 'RIMM RGB',\n 'ROMM RGB',\n 'S-Log',\n 'S-Log2',\n 'S-Log3',\n 'SMPTE 240M',\n 'ST 2084',\n 'T-Log',\n 'V-Log',\n 'ViperLog',\n 'sRGB']\n```\n\n----------------------------------------\n\nTITLE: Plotting Chromaticity Coordinates on CIE 1931 Diagram in Python\nDESCRIPTION: This snippet demonstrates plotting chromaticity coordinates on the CIE 1931 chromaticity diagram. It first plots the diagram, then adds the xy coordinates as a data point, and annotates the plot.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n    import matplotlib.pyplot as plt\n\n    # Plotting the *CIE 1931 Chromaticity Diagram*.\n    # The argument *show=False* is passed so that the plot doesn't get\n    # displayed and can be used as a basis for other plots.\n    plot_chromaticity_diagram_CIE1931(show=False)\n\n    # Plotting the *CIE xy* chromaticity coordinates.\n    x, y = xy\n    plt.plot(x, y, \"o-\", color=\"white\")\n\n    # Annotating the plot.\n    plt.annotate(\n        patch_sd.name.title(),\n        xy=xy,\n        xytext=(-50, 30),\n        textcoords=\"offset points\",\n        arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3, rad=-0.2\"),\n    )\n\n    # Displaying the plot.\n    render(\n        show=True,\n        limits=(-0.1, 0.9, -0.1, 0.9),\n        x_tighten=True,\n        y_tighten=True,\n    )\n```\n\n----------------------------------------\n\nTITLE: Calculating Munsell Value - Colour Science (Python)\nDESCRIPTION: This snippet calculates the Munsell value for a given luminance value using the default method within the `colour` library. The Munsell value represents the perceived lightness of a color.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_96\n\nLANGUAGE: python\nCODE:\n```\ncolour.munsell_value(12.23634268)\n```\n\n----------------------------------------\n\nTITLE: RGB to YCbCr Conversion in Python\nDESCRIPTION: Demonstrates converting RGB color values to YCbCr color encoding values using the `colour.RGB_to_YCbCr` function. The function takes an RGB triplet as input and returns the corresponding YCbCr values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_76\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_to_YCbCr([1.0, 1.0, 1.0])\n```\n\n----------------------------------------\n\nTITLE: Describing ITU-T H.273 Colour Primaries - Colour Science (Python)\nDESCRIPTION: This snippet uses the `describe_video_signal_colour_primaries` function from the `colour` library to retrieve a description of the colour primaries corresponding to a specific code (in this case, 1) as defined in the ITU-T H.273 standard.  The output includes the colour primaries, whitepoint, and the NPM (Normalised Primary Matrix).\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_91\n\nLANGUAGE: python\nCODE:\n```\ncolour.models.describe_video_signal_colour_primaries(1)\n```\n\n----------------------------------------\n\nTITLE: Plot Single SD Colour Rendering Index Bars (Python)\nDESCRIPTION: Plots the Colour Rendering Index (CRI) bars for a single spectral distribution. This example plots the CRI values for the illuminant FL2.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_84\n\nLANGUAGE: python\nCODE:\n```\nplot_single_sd_colour_rendering_index_bars(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: Accessing Function Docstrings\nDESCRIPTION: This code snippet demonstrates how to access the docstring of a specific function within the Colour library. It retrieves and prints the docstring for the CCT_to_uv_Ohno2013 function, which converts correlated colour temperature to CIE UCS colourspace uv chromaticity coordinates.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(colour.temperature.CCT_to_uv_Ohno2013.__doc__)\n```\n\n----------------------------------------\n\nTITLE: Plotting Single Colour Swatch in Python\nDESCRIPTION: This snippet demonstrates how to plot a single colour swatch using the colour-science library. It creates a ColourSwatch object with RGB values and a title, and then plots it using the plot_single_colour_swatch function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n    # Plotting the *sRGB* colourspace colour of the *Sample* spectral distribution.\n    plot_single_colour_swatch(ColourSwatch(RGB, \"Sample\"), text_kwargs={\"size\": \"x-large\"})\n```\n\n----------------------------------------\n\nTITLE: Listing RGB Colourspaces in Python\nDESCRIPTION: Shows how to retrieve a sorted list of available RGB colourspaces within the `colour` library. This is done by accessing the `colour.RGB_COLOURSPACES` attribute and sorting the resulting list.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_84\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.RGB_COLOURSPACES)\n```\n\n----------------------------------------\n\nTITLE: Aligning Spectral Distribution to a Specific Shape in Python\nDESCRIPTION: This snippet aligns a spectral distribution by first interpolating it and then extrapolating as needed to match a specified shape. The interpolate function is used to refine the spectral distribution within its original bounds, and then align extrapolates the data to fit a new spectral shape.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n    # Aligning the cloned sample spectral distribution.\n    # The spectral distribution is first trimmed as above.\n    sd_copy.interpolate(colour.SpectralShape(400, 700, 1))\n    sd_copy.align(colour.SpectralShape(340, 830, 5))\n    sd_copy[340], sd_copy[830]\n```\n\n----------------------------------------\n\nTITLE: Import Plotting Namespace (Python)\nDESCRIPTION: Imports all objects from the `colour.plotting` namespace and applies the default colour style.  The colour_style() function configures the default plotting styles.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_74\n\nLANGUAGE: python\nCODE:\n```\nfrom colour.plotting import *\n\ncolour_style()\n```\n\n----------------------------------------\n\nTITLE: Spectral Distribution Arithmetic Operations in Python\nDESCRIPTION: This snippet demonstrates various arithmetic operations on spectral distributions, including multiplication and addition. It requires the `colour` library to be installed. The code creates a ones-filled spectral distribution and then performs multiplication by a constant and addition with another ones-filled spectral distribution, printing the results at wavelength 400.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsd1 = colour.sd_ones()\nprint('\"Ones Filled Spectral Distribution\"')\nprint(sd1[400])\n\nprint('\\n\"x2 Constant Multiplied\"')\nprint((sd1 * 2)[400])\n\nprint('\\n\"+ Spectral Distribution\"')\nprint((sd1 + colour.sd_ones())[400])\n```\n\n----------------------------------------\n\nTITLE: XYZ to Oklab Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to Oklab color space values using the `colour.XYZ_to_Oklab` function. This function takes an XYZ triplet as input and returns the corresponding Oklab values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_71\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_Oklab([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Listing EOTFs - Colour Science (Python)\nDESCRIPTION: This snippet retrieves a sorted list of Electrical-Optical Transfer Functions (EOTFs) available in the `colour` library. EOTFs define the relationship between an electrical signal and the corresponding light output, used in decoding color information for display.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_86\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.EOTFS)\n```\n\n----------------------------------------\n\nTITLE: Anomalous Trichromacy Matrix Python\nDESCRIPTION: This snippet demonstrates how to compute the colour transformation matrix for anomalous trichromacy using the colour library. It uses the `matrix_anomalous_trichromacy_Machado2009` function to compute the matrix given colour matching functions, display primaries and the degree of anomaly. The snippet requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nprimaries = colour.MSDS_DISPLAY_PRIMARIES[\"Apple Studio Display\"]\nd_LMS = (15, 0, 0)\ncolour.matrix_anomalous_trichromacy_Machado2009(cmfs, primaries, d_LMS)\n```\n\n----------------------------------------\n\nTITLE: Colour Blindness Matrix Generation in Python\nDESCRIPTION: Demonstrates generating a colour blindness simulation matrix. It computes the transformation matrix used to simulate anomalous trichromacy for the Machado2009 method using colour matching functions and display primaries. It requires LMS colour matching functions, display primaries and an anomaly vector.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport colour\nimport numpy as np\n\ncmfs = colour.colorimetry.MSDS_CMFS_LMS[\"Stockman & Sharpe 2 Degree Cone Fundamentals\"]\nprimaries = colour.MSDS_DISPLAY_PRIMARIES[\"Apple Studio Display\"]\nd_LMS = (15, 0, 0)\ncolour.matrix_anomalous_trichromacy_Machado2009(cmfs, primaries, d_LMS)\n```\n\n----------------------------------------\n\nTITLE: Plot RGB Colourspace Section (Python)\nDESCRIPTION: Plots a section of a given RGB colourspace, allowing customization of section colors and opacity.  The section colours are set to RGB and opacity to 0.15 for the sRGB colourspace.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_87\n\nLANGUAGE: python\nCODE:\n```\nplot_RGB_colourspace_section(\"sRGB\", section_colours=\"RGB\", section_opacity=0.15)\n```\n\n----------------------------------------\n\nTITLE: Listing Reflectance Recovery Methods\nDESCRIPTION: Lists available reflectance recovery methods used to estimate a spectral distribution from XYZ tristimulus values. The function returns a sorted list of strings, each representing a different reflectance recovery method.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_109\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.REFLECTANCE_RECOVERY_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Plot Single SD Colour Rendition Report in Python\nDESCRIPTION: This snippet generates a colour rendition report for the 'FL2' illuminant using the ANSI/IES TM-30-18 method. It showcases the library's functionality for generating comprehensive colour rendition reports.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_129\n\nLANGUAGE: python\nCODE:\n```\nplot_single_sd_colour_rendition_report(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: Checking Spectral Distribution Uniformity in Python\nDESCRIPTION: This snippet demonstrates how to check the uniformity of a spectral distribution using the `is_uniform()` method. It requires a spectral distribution object named `sd` to be defined. The method returns a boolean indicating whether the wavelengths are uniformly spaced.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Checking the sample spectral distribution uniformity.\nprint(sd.is_uniform())\n```\n\n----------------------------------------\n\nTITLE: Plot Single Illuminant Spectral Distribution (Python)\nDESCRIPTION: Plots the spectral distribution of a single illuminant. This example plots the spectral distribution for the illuminant \"FL1\".\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_76\n\nLANGUAGE: python\nCODE:\n```\nplot_single_illuminant_sd(\"FL1\")\n```\n\n----------------------------------------\n\nTITLE: XYZ to IPT Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to IPT color space values using the `colour.XYZ_to_IPT` function. This function takes an XYZ triplet as input and returns the corresponding IPT values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_65\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_IPT([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: RGB to IHLS Conversion in Python\nDESCRIPTION: Demonstrates converting RGB color values to IHLS color space values using the `colour.RGB_to_IHLS` function. The function takes an RGB triplet as input and returns the corresponding IHLS values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_80\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_to_IHLS([0.45620519, 0.03081071, 0.04091952])\n```\n\n----------------------------------------\n\nTITLE: Plot Planckian Locus in CIE 1960 UCS Diagram in Python\nDESCRIPTION: This snippet plots the Planckian locus in the CIE 1960 UCS chromaticity diagram for illuminants A, B, and C. It showcases the library's functionality for visualizing colour temperature data.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_132\n\nLANGUAGE: python\nCODE:\n```\nplot_planckian_locus_in_chromaticity_diagram_CIE1960UCS([\"A\", \"B\", \"C\"])\n```\n\n----------------------------------------\n\nTITLE: Retrieving Multiple Wavelength Values\nDESCRIPTION: This snippet shows how to retrieve spectral distribution values for multiple wavelengths simultaneously. It passes a tuple of wavelengths to the SpectralDistribution object to obtain the corresponding values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nsd[(555.0, 556.25, 557.5, 558.75, 560.0)]\n```\n\n----------------------------------------\n\nTITLE: Calculating Spectral Similarity Index using Python\nDESCRIPTION: This code calculates the Spectral Similarity Index (SSI) between two illuminants ('C' and 'D65') using the `colour.spectral_similarity_index` function.  SSI provides a measure of how closely two spectral power distributions resemble each other.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\ncolour.spectral_similarity_index(\n    colour.SDS_ILLUMINANTS[\"C\"], colour.SDS_ILLUMINANTS[\"D65\"]\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Colour Quality Scale Methods using Python\nDESCRIPTION: This code snippet retrieves and sorts the available methods for calculating the Colour Quality Scale (CQS) using `colour.COLOUR_QUALITY_SCALE_METHODS`.  These methods represent different algorithms or standards for computing CQS.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.COLOUR_QUALITY_SCALE_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Available CCT Methods (Text)\nDESCRIPTION: Displays the list of available methods for `colour.UV_TO_CCT_METHODS`. The output shows a list of string values that represents names of available methods to compute CCT from uv chromaticity coordinates.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_63\n\nLANGUAGE: text\nCODE:\n```\n['Krystek 1985', 'Ohno 2013', 'Planck 1900', 'Robertson 1968', 'ohno2013', 'robertson1968']\n```\n\n----------------------------------------\n\nTITLE: Listing ITU-T H.273 Transfer Characteristics - Colour Science (Python)\nDESCRIPTION: This snippet retrieves the keys for the `TRANSFER_CHARACTERISTICS_ITUTH273` dictionary in the `colour` library.  This dictionary maps integer codes to transfer characteristic (gamma) definitions as specified in the ITU-T H.273 standard.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_92\n\nLANGUAGE: python\nCODE:\n```\ncolour.TRANSFER_CHARACTERISTICS_ITUTH273.keys()\n```\n\n----------------------------------------\n\nTITLE: Calculating Colour Quality Scale using Python\nDESCRIPTION: This code calculates the Colour Quality Scale (CQS) for a given illuminant ('FL2') using the `colour.colour_quality_scale` function. CQS is a metric used to assess the colour rendering properties of a light source.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\ncolour.colour_quality_scale(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: XYZ to Yrg Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to Yrg color space values using the `colour.XYZ_to_Yrg` function. This function takes an XYZ triplet as input and returns the corresponding Yrg values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_75\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_Yrg([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Listing OOTFs - Colour Science (Python)\nDESCRIPTION: This snippet retrieves a sorted list of Opto-Optical Transfer Functions (OOTFs) available in the `colour` library. OOTFs define transformations that apply adjustments to the image or video signal to optimize its appearance on a particular display.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_87\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.OOTFS)\n```\n\n----------------------------------------\n\nTITLE: Listing UV to CCT Conversion Methods\nDESCRIPTION: Lists available methods for converting CIE 1976 *uv* chromaticity coordinates to Correlated Colour Temperature (CCT). The function returns a sorted list of strings, each representing a different conversion method.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_112\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.UV_TO_CCT_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Slicing with Full Range\nDESCRIPTION: This snippet shows how to retrieve all values in a SpectralDistribution using a slice with no start or stop values. This returns the values in the same way as `sd.values`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nsd[:]\n```\n\n----------------------------------------\n\nTITLE: Extrapolating Spectral Distribution with Linear Method in Python\nDESCRIPTION: This snippet extrapolates a spectral distribution using the Linear method. It creates a copy of an existing spectral distribution, defines a spectral shape, and then extrapolates the copied distribution to match the new shape. The extrapolator_kwargs argument specifies the method and right value for extrapolation.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n    # Extrapolating the copied sample spectral distribution with *Linear* method.\n    sd_copy.extrapolate(\n        colour.SpectralShape(340, 830, 1),\n        extrapolator_kwargs={\"method\": \"Linear\", \"right\": 0},\n    )\n    sd_copy[340], sd_copy[830]\n```\n\n----------------------------------------\n\nTITLE: Plotting Single Colour Matching Functions\nDESCRIPTION: Plots single colour matching functions. The function takes the name of a colour matching functions (CMFs) dataset as input, such as 'Stockman & Sharpe 2 Degree Cone Fundamentals' and generates a plot showing the spectral sensitivity curves.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_122\n\nLANGUAGE: python\nCODE:\n```\nplot_single_cmfs(\n        \"Stockman & Sharpe 2 Degree Cone Fundamentals\",\n        y_label=\"Sensitivity\",\n        bounding_box=(390, 870, 0, 1.1),\n    )\n```\n\n----------------------------------------\n\nTITLE: Accessing Colour Cache Registry with Python\nDESCRIPTION: This Python snippet demonstrates how to access and print the internal cache registry of the Colour library using the `colour.utilities.CACHE_REGISTRY` object.  It shows how to import the Colour library and then print the cache registry to the console.  This registry is used to improve performance by caching results of computations.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/advanced.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nprint(colour.utilities.CACHE_REGISTRY)\n```\n\n----------------------------------------\n\nTITLE: Displaying Colour Fidelity Index Methods List as Text\nDESCRIPTION: This text block shows the output from `sorted(colour.COLOUR_FIDELITY_INDEX_METHODS)`, displaying the available methods for computing Colour Fidelity Index. The methods include 'ANSI/IES TM-30-18' and 'CIE 2017'.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_43\n\nLANGUAGE: text\nCODE:\n```\n['ANSI/IES TM-30-18', 'CIE 2017']\n```\n\n----------------------------------------\n\nTITLE: Calculating RGB Colourspace Volume\nDESCRIPTION: Calculates the volume of an RGB colourspace using the Monte Carlo method. The function takes an RGB colourspace object as input and returns the estimated volume of the colourspace.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_114\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_colourspace_volume_MonteCarlo(colour.RGB_COLOURSPACE_RGB[\"sRGB\"])\n```\n\n----------------------------------------\n\nTITLE: Compute ACES Input Transform Python\nDESCRIPTION: This snippet computes the ACES Input Device Transform (IDT) matrix using camera sensitivities and an illuminant. It leverages the `colour` library. It requires the `colour` library and `sensitivities` and `illuminant` objects.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nsensitivities = colour.MSDS_CAMERA_SENSITIVITIES[\"Nikon 5100 (NPL)\"]\nilluminant = colour.SDS_ILLUMINANTS[\"D55\"]\ncolour.matrix_idt(sensitivities, illuminant)\n```\n\n----------------------------------------\n\nTITLE: Plotting Multiple Blackbody Spectral Distributions\nDESCRIPTION: Plots multiple blackbody spectral distributions for a range of temperatures. The function creates a list of blackbody SDSs for temperatures from 1000K to 14000K in 1000K increments and then plots them together, using SD colours and normalising them.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_121\n\nLANGUAGE: python\nCODE:\n```\nblackbody_sds = [\n        colour.sd_blackbody(i, colour.SpectralShape(1, 10001, 10))\n        for i in range(1000, 15000, 1000)\n    ]\nplot_multi_sds(\n        blackbody_sds,\n        y_label=\"W / (sr m$^2$) / m\",\n        plot_kwargs={\"use_sd_colours\": True, \"normalise_sd_colours\": True},\n        legend_location=\"upper right\",\n        bounding_box=(0, 1250, 0, 2.5e6),\n    )\n```\n\n----------------------------------------\n\nTITLE: ArbitraryPrecisionMapping Demo with key_decimals=10\nDESCRIPTION: This example shows how the `ArbitraryPrecisionMapping` class handles keys with high decimal precision. It shows the keys when key_decimals is set to 10.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndata_1 = {0.1999999998: \"Nemo\", 0.2000000000: \"John\"}\napm_1 = ArbitraryPrecisionMapping(data_1, key_decimals=10)\ntuple(apm_1.keys())\n```\n\nLANGUAGE: text\nCODE:\n```\n(0.1999999998, 0.2)\n```\n\n----------------------------------------\n\nTITLE: Plot RGB Chromaticities in CIE 1931 Diagram in Python\nDESCRIPTION: This snippet generates a random RGB array and plots its chromaticities in the CIE 1931 chromaticity diagram, comparing it with different colourspaces. It demonstrates how to visualize RGB data in a standard chromaticity diagram using the Colour Science library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_127\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nRGB = np.random.random((32, 32, 3))\nplot_RGB_chromaticities_in_chromaticity_diagram_CIE1931(\n    RGB,\n    \"ITU-R BT.709\",\n    colourspaces=[\"ACEScg\", \"S-Gamut\", \"Pointer Gamut\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Video Signal Colour Primaries Description as Text\nDESCRIPTION: This text block shows the output from `colour.models.describe_video_signal_colour_primaries(1)`. The output displays the colour primaries' coordinates, whitepoint information, Normalised Primary Matrix (NPM) and its inverse, as well as relevant FFmpeg constants.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_21\n\nLANGUAGE: text\nCODE:\n```\n===============================================================================\n*                                                                             *\n*   Colour Primaries: 1                                                       *\n*   -------------------                                                       *\n*                                                                             *\n*   Primaries        : [[ 0.64  0.33]                                         *\n*                       [ 0.3   0.6 ]                                         *\n*                       [ 0.15  0.06]]                                        *\n*   Whitepoint       : [ 0.3127  0.329 ]                                      *\n*   Whitepoint Name  : D65                                                    *\n*   NPM              : [[ 0.4123908   0.35758434  0.18048079]                 *\n*                       [ 0.21263901  0.71516868  0.07219232]                 *\n*                       [ 0.01933082  0.11919478  0.95053215]]                *\n*   NPM -1           : [[ 3.24096994 -1.53738318 -0.49861076]                 *\n*                       [-0.96924364  1.8759675   0.04155506]                 *\n*                       [ 0.05563008 -0.20397696  1.05697151]]                *\n*   FFmpeg Constants : ['AVCOL_PRI_BT709', 'BT709']                           *\n*                                                                             *\n===============================================================================\n```\n\n----------------------------------------\n\nTITLE: Multi-Spectral Computations example in Python\nDESCRIPTION: Demonstrates an example use case with multi-spectral computations.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport colour\n\nmsds = np.array(\n        [\n            [\n                [\n                    0.01367208,\n                    0.09127947,\n                    0.01524376,\n                    0.02810712,\n                    0.19176012,\n                    0.04299992,\n                ],\n                [\n                    0.00959792,\n                    0.25822842,\n                    0.41388571,\n                    0.22275120,\n                    0.00407416,\n                    0.37439537,\n                ],\n                [\n                    0.01791409,\n                    0.29707789,\n                    0.56295109,\n                    0.23752193,\n                    0.00236515,\n                    0.58190280,\n                ],\n            ],\n            [\n                [\n                    0.01492332,\n                    0.10421912,\n                    0.02240025,\n                    0.03735409,\n                    0.57663846,\n                    0.32416266,\n                ],\n                [\n                    0.04180972,\n                    0.26402685,\n                    0.03572137,\n                    0.00413520,\n                    0.41808194,\n                    0.24696727,\n                ],\n                [\n                    0.00628672,\n                    0.11454948,\n```\n\n----------------------------------------\n\nTITLE: Plot Single SD Colour Rendering Index Bars in Python\nDESCRIPTION: This snippet plots the colour rendering index (CRI) bars for the 'FL2' illuminant. It showcases the library's capability to visualize CRI data for a given spectral distribution.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_128\n\nLANGUAGE: python\nCODE:\n```\nplot_single_sd_colour_rendering_index_bars(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: XYZ to CAM16 Conversion Output\nDESCRIPTION: Output of the XYZ to CAM16 conversion, generating a `CAM_Specification_CAM16` object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_18\n\nLANGUAGE: Text\nCODE:\n```\nCAM_Specification_CAM16(J=33.880368498111686, C=69.444353357408033, h=19.510887327451748, s=64.03612114840314, Q=176.03752758512178, M=72.18638534116765, H=399.52975599115319, HC=None)\n```\n\n----------------------------------------\n\nTITLE: Generating Geometry Primitives\nDESCRIPTION: Generates a geometry primitive, such as a grid or cube. The function takes the name of the primitive as input and returns vertex data and indices required for rendering.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_115\n\nLANGUAGE: python\nCODE:\n```\ncolour.primitive(\"Grid\")\n```\n\n----------------------------------------\n\nTITLE: Plotting sRGB Colour of a Colour Rendition Chart Patch in Python\nDESCRIPTION: This snippet demonstrates how to plot the sRGB colour of a specific patch from a colour rendition chart. It retrieves the spectral distribution of the patch, converts it to XYZ, then to sRGB, and plots it as a colour swatch.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n    # Plotting the *sRGB* colourspace colour of *neutral 5 (.70 D)* patch.\n    patch_name = \"neutral 5 (.70 D)\"\n    patch_sd = colour.SDS_COLOURCHECKERS[\"ColorChecker N Ohta\"][patch_name]\n    XYZ = colour.sd_to_XYZ(patch_sd, cmfs, illuminant)\n    RGB = colour.XYZ_to_sRGB(XYZ / 100)\n\n    plot_single_colour_swatch(\n        ColourSwatch(RGB, patch_name.title()), text_kwargs={\"size\": \"x-large\"}\n    )\n```\n\n----------------------------------------\n\nTITLE: Recovering Camera Sensitivities from RGB\nDESCRIPTION: Recovers camera RGB sensitivities from RGB values, an illuminant, and reflectances. This involves spectral up-sampling and uses Jiang2013 method. It uses predefined datasets for illuminant D65, Nikon 5100 camera sensitivities, and BabelColor Average colour checker reflectances. It converts reflectances and camera sensitivities to a multi-spectral distribution (MSDS) and estimates camera sensitivities from RGB values, spectral data and Dyer basis functions.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_110\n\nLANGUAGE: python\nCODE:\n```\nilluminant = colour.colorimetry.SDS_ILLUMINANTS[\"D65\"]\nsensitivities = colour.characterisation.MSDS_CAMERA_SENSITIVITIES[\"Nikon 5100 (NPL)\"]\nreflectances = [\n        sd.copy().align(colour.recovery.SPECTRAL_SHAPE_BASIS_FUNCTIONS_DYER2017)\n        for sd in colour.characterisation.SDS_COLOURCHECKERS[\"BabelColor Average\"].values()\n    ]\nreflectances = colour.colorimetry.sds_and_msds_to_msds(reflectances)\nRGB = colour.colorimetry.msds_to_XYZ(\n        reflectances,\n        method=\"Integration\",\n        cmfs=sensitivities,\n        illuminant=illuminant,\n        k=0.01,\n        shape=colour.recovery.SPECTRAL_SHAPE_BASIS_FUNCTIONS_DYER2017,\n    )\ncolour.recovery.RGB_to_msds_camera_sensitivities_Jiang2013(\n        RGB,\n        illuminant,\n        reflectances,\n        colour.recovery.BASIS_FUNCTIONS_DYER2017,\n        colour.recovery.SPECTRAL_SHAPE_BASIS_FUNCTIONS_DYER2017,\n    )\n```\n\n----------------------------------------\n\nTITLE: Listing Colourspace Models in Python\nDESCRIPTION: This snippet displays a list of colourspace models available in the Colour-Science library that interact directly with the CIE XYZ colourspace. The pprint function is used to print the list in a readable format.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n    # Displaying objects interacting directly with the *CIE XYZ* colourspace.\n    pprint(colour.COLOURSPACE_MODELS)\n```\n\n----------------------------------------\n\nTITLE: Plotting a Single Colour Checker in Python\nDESCRIPTION: This snippet generates a plot of a complete colour checker chart. The plot_single_colour_checker function is called with the name of the desired colour checker and optional keyword arguments to customise the plot appearance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n    plot_single_colour_checker(\n        colour_checker=\"ColorChecker 2005\", text_kwargs={\"visible\": False}\n    )\n```\n\n----------------------------------------\n\nTITLE: Hellwig2022 Colour Appearance Model in Python\nDESCRIPTION: Demonstrates the Hellwig2022 colour appearance model using `colour.XYZ_to_Hellwig2022`. Converts XYZ values to Hellwig2022 parameters, requiring whitepoint XYZ, adapting luminance and background luminance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\ncolour.XYZ_to_Hellwig2022(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Describing ITU-T H.273 Matrix Coefficients - Colour Science (Python)\nDESCRIPTION: This snippet uses the `describe_video_signal_matrix_coefficients` function from the `colour` library to retrieve a description of the matrix coefficients corresponding to a specific code (in this case, 1) as defined in the ITU-T H.273 standard. The output includes the matrix coefficients and FFmpeg constants.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_95\n\nLANGUAGE: python\nCODE:\n```\ncolour.models.describe_video_signal_matrix_coefficients(1)\n```\n\n----------------------------------------\n\nTITLE: Generate Primitive Vertices (Python)\nDESCRIPTION: Generates the vertices for a specific primitive. This example creates vertices for a 'Quad MPL' primitive using the `colour.primitive_vertices` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_72\n\nLANGUAGE: python\nCODE:\n```\ncolour.primitive_vertices(\"Quad MPL\")\n```\n\n----------------------------------------\n\nTITLE: XYZ to ZCAM Conversion in Python\nDESCRIPTION: Conversion from XYZ to ZCAM color appearance model using the function `colour.XYZ_to_ZCAM`. Requires XYZ values, whitepoint, adapting luminance, and background luminance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_23\n\nLANGUAGE: Python\nCODE:\n```\ncolour.XYZ_to_ZCAM(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Plotting the Visible Spectrum\nDESCRIPTION: Plots the visible spectrum using a specified colour matching function.  The function takes the name of a colour matching function (CMF) dataset as input, such as 'CIE 1931 2 Degree Standard Observer', and generates a plot showing the spectral sensitivity curves.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_119\n\nLANGUAGE: python\nCODE:\n```\nplot_visible_spectrum(\"CIE 1931 2 Degree Standard Observer\")\n```\n\n----------------------------------------\n\nTITLE: Reading a Look-Up Table in Python\nDESCRIPTION: Demonstrates how to read a Look-Up Table (LUT) file using the `colour.read_LUT` function. The LUT is then printed to the console, displaying its dimensions, domain, and size.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nLUT = colour.read_LUT(\"ACES_Proxy_10_to_ACES.cube\")\nprint(LUT)\n```\n\n----------------------------------------\n\nTITLE: Plot Single Colour Checker (Python)\nDESCRIPTION: Plots a single color checker chart, such as ColorChecker 2005. The text labels are disabled to show only the colored patches in the plot.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_81\n\nLANGUAGE: python\nCODE:\n```\nplot_single_colour_checker(\"ColorChecker 2005\", text_kwargs={\"visible\": False})\n```\n\n----------------------------------------\n\nTITLE: Listing Available Colour Fidelity Index Methods\nDESCRIPTION: Lists the available methods for calculating the Colour Fidelity Index.  This function returns a sorted list of strings, each representing a different method that can be used to compute the CFI.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_102\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.COLOUR_FIDELITY_INDEX_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Mocking Scipy for Colour with Python\nDESCRIPTION: This Python snippet demonstrates how to mock the Scipy library and its submodules to allow partial usage of the Colour library without a full Scipy installation. This is useful in environments where Scipy is difficult to install. It iterates through a list of Scipy modules, replacing them with mock objects, before importing Colour and performing a calculation.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/advanced.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom mock_for_colour import MockModule\n\nfor module in (\n    \"scipy\",\n    \"scipy.interpolate\",\n    \"scipy.linalg\",\n    \"scipy.ndimage\",\n    \"scipy.ndimage.filters\",\n    \"scipy.spatial\",\n    \"scipy.spatial.distance\",\n    \"scipy.optimize\",\n):\n    sys.modules[str(module)] = MockModule(str(module))\n\nimport colour\n\nxyY = (0.4316, 0.3777, 0.1008)\ncolour.xyY_to_XYZ(xyY)\n```\n\n----------------------------------------\n\nTITLE: Plot RGB Colourspace Section in Python\nDESCRIPTION: This snippet plots a section of the 'sRGB' colourspace with specified colours and opacity. It demonstrates the library's ability to visualize colourspaces with custom styling.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_131\n\nLANGUAGE: python\nCODE:\n```\nplot_RGB_colourspace_section(\"sRGB\", section_colours=\"RGB\", section_opacity=0.15)\n```\n\n----------------------------------------\n\nTITLE: XYZ to CIECAM02 Conversion in Python\nDESCRIPTION: This snippet shows how to convert XYZ values to CIECAM02 color appearance model parameters using `colour.XYZ_to_CIECAM02`. It requires XYZ values, whitepoint XYZ, adapting luminance, and background luminance as inputs.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\ncolour.XYZ_to_CIECAM02(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Listing CCTF Encodings - Colour Science (Python)\nDESCRIPTION: This snippet retrieves a sorted list of Code Component Transfer Functions (CCTFs) available in the `colour` library. CCTFs are used in color encoding and decoding processes and define the relationship between code values and color values. CCTFs are used in image and video compression and color management systems.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_89\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.CCTF_ENCODINGS)\n```\n\n----------------------------------------\n\nTITLE: Exploring Spectral Distribution Attributes in Colour with IPython\nDESCRIPTION: This example shows how to use IPython or Jupyter Notebook's auto-completion feature to discover spectral distribution related attributes within the `colour` module. It imports the `colour` module and lists the attributes starting with `SD`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nIn [2]: colour.SD\n                      SD_GAUSSIAN_METHODS   SD_TO_XYZ_METHODS     SDS_ILLUMINANTS       SDS_LIGHT_SOURCES\n                      SD_MULTI_LEDS_METHODS SDS_COLOURCHECKERS    SDS_LEFS\n                      SD_SINGLE_LED_METHODS SDS_FILTERS           SDS_LENSES\n```\n\n----------------------------------------\n\nTITLE: Getting the Current Domain-Range Scale\nDESCRIPTION: This code shows how to retrieve the current domain-range scale using the `colour.get_domain_range_scale()` function. This is important for understanding how the Colour library is interpreting and outputting values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\ncolour.get_domain_range_scale()\n```\n\n----------------------------------------\n\nTITLE: Listing Colour Rendition Charts in Python\nDESCRIPTION: This snippet demonstrates how to access the keys for colour rendition charts chromaticity coordinates and spectral distributions available in the colour.characterisation sub-package. It prints sorted lists of the keys using the CCS_COLOURCHECKERS and SDS_COLOURCHECKERS dictionaries.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n    # Colour rendition charts chromaticity coordinates.\n    print(sorted(colour.characterisation.CCS_COLOURCHECKERS.keys()))\n\n    # Colour rendition charts spectral distributions.\n    print(sorted(colour.characterisation.SDS_COLOURCHECKERS.keys()))\n```\n\n----------------------------------------\n\nTITLE: Getting Current Safe Division Mode in Python\nDESCRIPTION: This snippet retrieves the currently configured safe division mode using `colour.algebra.get_sdiv_mode`.  The safe division mode controls how division by zero is handled.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ncolour.algebra.get_sdiv_mode()\n```\n\n----------------------------------------\n\nTITLE: Plot Single SD Colour Rendition Report (Python)\nDESCRIPTION: Plots a color rendition report for a single spectral distribution, providing detailed color rendition metrics. This example plots the color rendition report for the illuminant FL2.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_85\n\nLANGUAGE: python\nCODE:\n```\nplot_single_sd_colour_rendition_report(colour.SDS_ILLUMINANTS[\"FL2\"])\n```\n\n----------------------------------------\n\nTITLE: XYZ to Kim2009 Conversion in Python\nDESCRIPTION: Shows how to convert XYZ to Kim2009 color appearance model, requiring XYZ values, whitepoint, and adapting luminance. Uses `colour.XYZ_to_Kim2009`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\ncolour.XYZ_to_Kim2009(XYZ, XYZ_w, L_A)\n```\n\n----------------------------------------\n\nTITLE: Plotting a Single Colour Checker\nDESCRIPTION: Plots a single colour checker using a predefined layout. The function takes the name of a colour checker as input and generates a plot showing the colour patches of the colour checker.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_125\n\nLANGUAGE: python\nCODE:\n```\nplot_single_colour_checker(\"ColorChecker 2005\", text_kwargs={\"visible\": False})\n```\n\n----------------------------------------\n\nTITLE: Extrapolating Spectral Distribution in Python\nDESCRIPTION: This snippet demonstrates how to extrapolate a copied spectral distribution using `extrapolate()`. It requires a spectral distribution object named `sd_copy` to be defined. The code then prints the extrapolated values at wavelengths 340 and 830.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Extrapolating the copied sample spectral distribution.\nsd_copy.extrapolate(colour.SpectralShape(340, 830, 1))\nsd_copy[340], sd_copy[830]\n```\n\n----------------------------------------\n\nTITLE: Describing Video Signal Colour Primaries using Python\nDESCRIPTION: This code uses the `colour.models.describe_video_signal_colour_primaries(1)` function to output detailed information about the video signal colour primaries represented by the integer '1'. This includes the primaries' coordinates, whitepoint information, NPM (Normalised Primary Matrix) and its inverse, as well as FFmpeg constants.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ncolour.models.describe_video_signal_colour_primaries(1)\n```\n\n----------------------------------------\n\nTITLE: Setting the Domain-Range Scale to '1'\nDESCRIPTION: This example sets the domain-range scale to '1' and calls `chromatic_adaptation_CIE1994` with appropriately scaled input values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ncolour.set_domain_range_scale(\"1\")\n\nXYZ_1 = [0.2800, 0.2126, 0.0527]\nY_o = 0.2\ncolour.adaptation.chromatic_adaptation_CIE1994(XYZ_1, xy_o1, xy_o2, Y_o, E_o1, E_o2)\n```\n\n----------------------------------------\n\nTITLE: List Whiteness Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available whiteness index computation methods from the `colour` library. It showcases different whiteness formulas. It requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.WHITENESS_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Compute Contrast Sensitivity Function Python\nDESCRIPTION: This snippet computes the contrast sensitivity function (CSF) value for given spatial frequency (u), background luminance (X_0), and eccentricity (E).  It uses the default 'Barten 1999' method. It requires the `colour` library.  The output is the CSF value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\ncolour.contrast_sensitivity_function(u=4, X_0=60, E=65)\n```\n\n----------------------------------------\n\nTITLE: Calculating Rayleigh Scattering Spectral Distribution - Colour Science (Python)\nDESCRIPTION: This snippet calculates the spectral distribution of Rayleigh scattering using the `sd_rayleigh_scattering` function from the `colour` library. Rayleigh scattering describes the scattering of electromagnetic radiation (including light) by particles of a wavelength much smaller than the wavelength of the radiation. The spectral distribution represents the intensity of scattering at different wavelengths.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_100\n\nLANGUAGE: python\nCODE:\n```\ncolour.sd_rayleigh_scattering()\n```\n\n----------------------------------------\n\nTITLE: Listing ITU-T H.273 Matrix Coefficients with Python\nDESCRIPTION: This snippet retrieves and displays the keys representing the matrix coefficients defined within the `colour.MATRIX_COEFFICIENTS_ITUTH273` dictionary. This dictionary maps integer codes to specific matrix coefficients used in colour space transformations as defined by the ITU-T H.273 standard.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ncolour.MATRIX_COEFFICIENTS_ITUTH273.keys()\n```\n\n----------------------------------------\n\nTITLE: Plot Visible Spectrum (Python)\nDESCRIPTION: Plots the visible spectrum using a specified observer. This example uses the \"CIE 1931 2 Degree Standard Observer\" to generate the plot.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_75\n\nLANGUAGE: python\nCODE:\n```\nplot_visible_spectrum(\"CIE 1931 2 Degree Standard Observer\")\n```\n\n----------------------------------------\n\nTITLE: List Available CCT Methods (Python)\nDESCRIPTION: Lists the available methods for computing Correlated Color Temperature. This example sorts and prints the available methods for calculating CCT using the `colour.UV_TO_CCT_METHODS` attribute.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.UV_TO_CCT_METHODS)\n```\n\n----------------------------------------\n\nTITLE: List Available XY to CCT Methods (Python)\nDESCRIPTION: Lists the available methods for converting *xy* chromaticity coordinates to Correlated Color Temperature (CCT). This example sorts and prints the available methods for calculating CCT from *xy* using the `colour.XY_TO_CCT_METHODS` attribute.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.XY_TO_CCT_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Recovering Camera RGB Sensitivities with Python\nDESCRIPTION: This code demonstrates a process for recovering camera RGB sensitivities using the Jiang2013 method.  It involves setting up the illuminant, sensitivities, and reflectances, converting reflectances to RGB, and then applying the recovery function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nilluminant = colour.colorimetry.SDS_ILLUMINANTS[\"D65\"]\nsensitivities = colour.characterisation.MSDS_CAMERA_SENSITIVITIES[\"Nikon 5100 (NPL)\"]\nreflectances = [\n    sd.copy().align(colour.recovery.SPECTRAL_SHAPE_BASIS_FUNCTIONS_DYER2017)\n    for sd in colour.characterisation.SDS_COLOURCHECKERS[\"BabelColor Average\"].values()\n]\nreflectances = colour.colorimetry.sds_and_msds_to_msds(reflectances)\nRGB = colour.colorimetry.msds_to_XYZ(\n    reflectances,\n    method=\"Integration\",\n    cmfs=sensitivities,\n    illuminant=illuminant,\n    k=0.01,\n    shape=colour.recovery.SPECTRAL_SHAPE_BASIS_FUNCTIONS_DYER2017,\n)\ncolour.recovery.RGB_to_msds_camera_sensitivities_Jiang2013(\n    RGB,\n    illuminant,\n    reflectances,\n    colour.recovery.BASIS_FUNCTIONS_DYER2017,\n```\n\n----------------------------------------\n\nTITLE: ArbitraryPrecisionMapping Demo with key_decimals=7\nDESCRIPTION: This example demonstrates the `ArbitraryPrecisionMapping` class with key_decimals set to 7. It showcases how different precision settings affect the keys stored in the mapping.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\napm_2 = ArbitraryPrecisionMapping(data_1, key_decimals=7)\ntuple(apm_2.keys())\n```\n\nLANGUAGE: text\nCODE:\n```\n(0.2,)\n```\n\n----------------------------------------\n\nTITLE: RGB Colourspace Volume Output (Text)\nDESCRIPTION: Shows the calculated volume of the sRGB colourspace using Monte Carlo simulation. The value represents the approximate volume in a specific color space, such as the *CIE L\\*a\\*b\\** colourspace.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_67\n\nLANGUAGE: text\nCODE:\n```\n821958.30000000005\n```\n\n----------------------------------------\n\nTITLE: Describing ITU-T H.273 Transfer Characteristics - Colour Science (Python)\nDESCRIPTION: This snippet uses the `describe_video_signal_transfer_characteristics` function from the `colour` library to retrieve a description of the transfer characteristics corresponding to a specific code (in this case, 1) as defined in the ITU-T H.273 standard. The output includes the transfer function and FFmpeg constants.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_93\n\nLANGUAGE: python\nCODE:\n```\ncolour.models.describe_video_signal_transfer_characteristics(1)\n```\n\n----------------------------------------\n\nTITLE: Plotting a Single Illuminant Spectral Distribution\nDESCRIPTION: Plots the spectral distribution of a single illuminant. The function takes the name of an illuminant (e.g., 'FL1') as input and generates a plot showing the spectral power distribution of that illuminant.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_120\n\nLANGUAGE: python\nCODE:\n```\nplot_single_illuminant_sd(\"FL1\")\n```\n\n----------------------------------------\n\nTITLE: XYZ to OSA UCS Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to OSA UCS color space values using the `colour.XYZ_to_OSA_UCS` function. The XYZ values are first scaled by 100. The function takes an XYZ triplet as input and returns the corresponding OSA UCS values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_72\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\ncolour.XYZ_to_OSA_UCS(XYZ)\n```\n\n----------------------------------------\n\nTITLE: Video Signal Transfer Characteristics Description as Text\nDESCRIPTION: This text block shows the output from `colour.models.describe_video_signal_transfer_characteristics(1)`. The output displays the transfer function and relevant FFmpeg constants associated with the transfer characteristics.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_25\n\nLANGUAGE: text\nCODE:\n```\n===============================================================================\n*                                                                             *\n*   Transfer Characteristics: 1                                               *\n*   ---------------------------                                               *\n*                                                                             *\n*   Function         : <function oetf_BT709 at 0x165bb3550>                   *\n*   FFmpeg Constants : ['AVCOL_TRC_BT709', 'BT709']                           *\n*                                                                             *\n===============================================================================\n```\n\n----------------------------------------\n\nTITLE: Listing Available Primitive Generation Methods\nDESCRIPTION: Lists the available methods for generating geometry primitives. This function returns a sorted list of strings, where each string corresponds to the name of a supported primitive.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_116\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.PRIMITIVE_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Listing ITU-T H.273 Colour Primaries - Colour Science (Python)\nDESCRIPTION: This snippet retrieves the keys for the `COLOUR_PRIMARIES_ITUTH273` dictionary in the `colour` library. This dictionary maps integer codes to colour primary definitions as specified in the ITU-T H.273 standard for video signal type identification.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_90\n\nLANGUAGE: python\nCODE:\n```\ncolour.COLOUR_PRIMARIES_ITUTH273.keys()\n```\n\n----------------------------------------\n\nTITLE: Plot Single Colour Matching Functions (Python)\nDESCRIPTION: Plots single colour matching functions for the specified observer. This example plots the Stockman & Sharpe 2 Degree Cone Fundamentals colour matching functions.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_78\n\nLANGUAGE: python\nCODE:\n```\nplot_single_cmfs(\n        \"Stockman & Sharpe 2 Degree Cone Fundamentals\",\n        y_label=\"Sensitivity\",\n        bounding_box=(390, 870, 0, 1.1),\n    )\n```\n\n----------------------------------------\n\nTITLE: XYZ to Hellwig2022 Conversion in Python\nDESCRIPTION: This snippet demonstrates converting XYZ values to Hellwig2022 color appearance model parameters using the `colour.XYZ_to_Hellwig2022` function.  It takes XYZ values, whitepoint XYZ, adapting luminance, and background luminance as inputs.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\ncolour.XYZ_to_Hellwig2022(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: xyY to Munsell Colour Conversion Result as Text\nDESCRIPTION: This text block shows the output from the `colour.xyY_to_munsell_colour([0.38736945, 0.35751656, 0.59362000])` function, which converts xyY coordinates to Munsell notation.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_35\n\nLANGUAGE: text\nCODE:\n```\n'4.2YR 8.1/5.3'\n```\n\n----------------------------------------\n\nTITLE: Automatic Colour Conversion Output\nDESCRIPTION: This is the output of the colour conversion example. It shows the conversion path used and the resulting sRGB values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n===============================================================================\n*                                                                             *\n*   [ Conversion Path ]                                                       *\n*                                                                             *\n*   \"sd_to_XYZ\" --> \"XYZ_to_sRGB\"                                             *\n*                                                                             *\n===============================================================================\narray([ 0.49034776,  0.30185875,  0.23587685])\n```\n\n----------------------------------------\n\nTITLE: XYZ to CIECAM16 Conversion in Python\nDESCRIPTION: This example converts XYZ values to CIECAM16 parameters. It's similar to CIECAM02 and uses the `colour.XYZ_to_CIECAM16` function with the same input parameters.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\ncolour.XYZ_to_CIECAM16(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Kim2009 Colour Appearance Model in Python\nDESCRIPTION: Demonstrates the Kim2009 colour appearance model using `colour.XYZ_to_Kim2009`. Converts XYZ values to Kim2009 parameters, requiring whitepoint XYZ and adapting luminance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\ncolour.XYZ_to_Kim2009(XYZ, XYZ_w, L_A)\n```\n\n----------------------------------------\n\nTITLE: Plot Corresponding Chromaticities Prediction in Python\nDESCRIPTION: This snippet plots corresponding chromaticities prediction using the 'Von Kries' chromatic adaptation model and 'Bianco 2010' dataset. It is a simple example showcasing the plotting functionality of the Colour Science library related to chromatic adaptation.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_126\n\nLANGUAGE: python\nCODE:\n```\nplot_corresponding_chromaticities_prediction(2, \"Von Kries\", \"Bianco 2010\")\n```\n\n----------------------------------------\n\nTITLE: Converting Reshaped NumPy Array of xyY Values to XYZ in Colour\nDESCRIPTION: This example shows how the `colour` library can handle reshaped NumPy arrays. It takes the NumPy array `xyY` from the previous example, reshapes it, and then converts it to XYZ values. Demonstrates n-dimensional array support with reshaping.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncolour.xyY_to_XYZ(xyY.reshape([2, 3, 3]))\n```\n\nLANGUAGE: text\nCODE:\n```\narray([[[ 0.11518475,  0.1008    ,  0.05089373],\n         [ 0.11518475,  0.1008    ,  0.05089373],\n         [ 0.11518475,  0.1008    ,  0.05089373]],\n\n        [[ 0.11518475,  0.1008    ,  0.05089373],\n         [ 0.11518475,  0.1008    ,  0.05089373],\n         [ 0.11518475,  0.1008    ,  0.05089373]]])\n```\n\n----------------------------------------\n\nTITLE: Rayleigh Scattering Spectral Distribution as Text\nDESCRIPTION: This text block shows the output from the `colour.sd_rayleigh_scattering()` function, displaying the spectral distribution of Rayleigh scattering as a `SpectralDistribution` object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_39\n\nLANGUAGE: text\nCODE:\n```\nSpectralDistribution([[  3.60000000e+02,   5.60246579e-01],\n                          [  3.61000000e+02,   5.53748137e-01],\n                          [  3.62000000e+02,   5.47344692e-01],\n                          ...\n                          [  7.78000000e+02,   2.37790178e-02],\n                          [  7.79000000e+02,   2.36559421e-02],\n                          [  7.80000000e+02,   2.35336632e-02]],\n                         SpragueInterpolator,\n                         {},\n                         Extrapolator,\n                         {'method': 'Constant', 'left': None, 'right': None})\n```\n\n----------------------------------------\n\nTITLE: XYZ to UVW Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to CIE 1964 U*V*W* color space values using the `colour.XYZ_to_UVW` function. The XYZ values are first scaled by 100 before conversion. The function takes an XYZ triplet as input and returns the corresponding UVW values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\ncolour.XYZ_to_UVW(XYZ)\n```\n\n----------------------------------------\n\nTITLE: Munsell Colour to xyY Conversion Result as Text\nDESCRIPTION: This text block shows the output from the `colour.munsell_colour_to_xyY(\"4.2YR 8.1/5.3\")` function, which converts a Munsell colour to xyY coordinates.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_37\n\nLANGUAGE: text\nCODE:\n```\narray([ 0.38736945,  0.35751656,  0.59362   ])\n```\n\n----------------------------------------\n\nTITLE: Describing Video Signal Transfer Characteristics using Python\nDESCRIPTION: This code uses the `colour.models.describe_video_signal_transfer_characteristics(1)` function to output detailed information about the video signal transfer characteristics represented by the integer '1'. This includes the transfer function itself and relevant FFmpeg constants.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ncolour.models.describe_video_signal_transfer_characteristics(1)\n```\n\n----------------------------------------\n\nTITLE: ZCAM Colour Appearance Model in Python\nDESCRIPTION: Demonstrates the ZCAM colour appearance model using `colour.XYZ_to_ZCAM`. Converts XYZ values to ZCAM parameters, requiring whitepoint XYZ, adapting luminance and background luminance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nXYZ = [0.20654008 * 100, 0.12197225 * 100, 0.05136952 * 100]\nXYZ_w = [95.05, 100.00, 108.88]\nL_A = 318.31\nY_b = 20.0\ncolour.XYZ_to_ZCAM(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Defining Constant Spectral Distribution in Python\nDESCRIPTION: This snippet demonstrates how to define constant, zeros-filled, and ones-filled spectral distributions using `colour.sd_constant`, `colour.sd_zeros`, and `colour.sd_ones` respectively. It requires the `colour` library to be installed. The code then prints the shape and value at a specific wavelength (400 nm) for each distribution.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Defining a constant spectral distribution.\nsd_constant = colour.sd_constant(100)\nprint('\"Constant Spectral Distribution\"')\nprint(sd_constant.shape)\nprint(sd_constant[400])\n\n# Defining a zeros filled spectral distribution.\nprint('\\n\"Zeros Filled Spectral Distribution\"')\nsd_zeros = colour.sd_zeros()\nprint(sd_zeros.shape)\nprint(sd_zeros[400])\n\n# Defining a ones filled spectral distribution.\nprint('\\n\"Ones Filled Spectral Distribution\"')\nsd_ones = colour.sd_ones()\nprint(sd_ones.shape)\nprint(sd_ones[400])\n```\n\n----------------------------------------\n\nTITLE: List Spectral to XYZ Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available spectral to XYZ conversion methods from the `colour` library. It provides an overview of the different algorithms available. The snippet requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.SPECTRAL_TO_XYZ_METHODS)\n```\n\n----------------------------------------\n\nTITLE: XYZ to Spectral Distribution Conversion Result as Text\nDESCRIPTION: This text block shows the output from the `colour.XYZ_to_sd([0.20654008, 0.12197225, 0.05136952])` function, displaying the recovered spectral distribution.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_55\n\nLANGUAGE: text\nCODE:\n```\nSpectralDistribution([[  3.60000000e+02,   8.52694330e-02],\n                          [  3.65000000e+02,   8.52203359e-02],\n                          [  3.70000000e+02,   8.52841304e-02],\n                          ...\n                          [  7.70000000e+02,   4.46546872e-01],\n                          [  7.75000000e+02,   4.46638451e-01],\n                          [  7.80000000e+02,   4.46641739e-01]],\n                         SpragueInterpolator,\n                         {},\n                         Extrapolator,\n                         {'method': 'Constant', 'left': None, 'right': None})\n```\n\n----------------------------------------\n\nTITLE: Video Signal Matrix Coefficients Description as Text\nDESCRIPTION: This text block shows the output from `colour.models.describe_video_signal_matrix_coefficients(1)`. The output displays the matrix coefficients and relevant FFmpeg constants.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_29\n\nLANGUAGE: text\nCODE:\n```\n===============================================================================\n*                                                                             *\n*   Matrix Coefficients: 1                                                    *\n*   ----------------------                                                    *\n*                                                                             *\n*   Matrix Coefficients : [ 0.2126  0.0722]                                   *\n*   FFmpeg Constants    : ['AVCOL_SPC_BT709', 'BT709']                        *\n*                                                                             *\n===============================================================================\n```\n\n----------------------------------------\n\nTITLE: Kernel Interpolation in Python\nDESCRIPTION: This snippet demonstrates the use of `colour.KernelInterpolator` for interpolating data. It creates an interpolator object with x and y values and then uses it to interpolate at specified x values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ny = [5.9200, 9.3700, 10.8135, 4.5100, 69.5900, 27.8007, 86.0500]\nx = range(len(y))\ncolour.KernelInterpolator(x, y)([0.25, 0.75, 5.50])\n```\n\n----------------------------------------\n\nTITLE: XYZ to IPT Ragoo2021 Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to Ragoo and Farup (2021) Optimised IPT color space values using the `colour.XYZ_to_IPT_Ragoo2021` function. This function takes an XYZ triplet as input and returns the corresponding IPT Ragoo2021 values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_74\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_IPT_Ragoo2021([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Creating Constant Spectral Distribution with Custom Shape in Python\nDESCRIPTION: This snippet demonstrates how to create a constant spectral distribution with a user-defined shape using `colour.sd_ones`. It requires the `colour` library to be installed. The code creates a spectral distribution with a shape from 400 to 700 with an interval of 5 and then accesses the value at wavelength 450.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ncolour.sd_ones(colour.SpectralShape(400, 700, 5))[450]\n```\n\n----------------------------------------\n\nTITLE: Plot Visible Spectrum Section (Python)\nDESCRIPTION: Plots a section of the visible spectrum, allowing customization of section colors and opacity.  The section colours are set to RGB and opacity to 0.15.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_86\n\nLANGUAGE: python\nCODE:\n```\nplot_visible_spectrum_section(section_colours=\"RGB\", section_opacity=0.15)\n```\n\n----------------------------------------\n\nTITLE: Listing Log Encodings - Colour Science (Python)\nDESCRIPTION: This snippet retrieves a sorted list of logarithmic encoding schemes available in the `colour` library. Log encoding is used to compress high dynamic range signals for efficient storage and transmission, especially in professional video workflows.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_88\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.LOG_ENCODINGS)\n```\n\n----------------------------------------\n\nTITLE: Displaying Munsell Value Methods List as Text\nDESCRIPTION: This text block shows the output from `sorted(colour.MUNSELL_VALUE_METHODS)`, displaying the available methods for computing Munsell value. The methods include 'ASTM D1535', 'Ladd 1955', and others.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_33\n\nLANGUAGE: text\nCODE:\n```\n['ASTM D1535',\n 'Ladd 1955',\n 'McCamy 1987',\n 'Moon 1943',\n 'Munsell 1933',\n 'Priest 1920',\n 'Saunderson 1944',\n 'astm2008']\n```\n\n----------------------------------------\n\nTITLE: Displaying ITU-T H.273 Matrix Coefficients Keys as text\nDESCRIPTION: This text block shows the output keys from the `colour.MATRIX_COEFFICIENTS_ITUTH273.keys()` function in text format. The keys represent different matrix coefficient configurations as defined in ITU-T H.273.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_27\n\nLANGUAGE: text\nCODE:\n```\ndict_keys([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n```\n\n----------------------------------------\n\nTITLE: Listing ITU-T H.273 Transfer Characteristics with Python\nDESCRIPTION: This snippet retrieves and displays the keys representing the transfer characteristics defined within the `colour.TRANSFER_CHARACTERISTICS_ITUTH273` dictionary. The dictionary maps integer codes to specific transfer functions as defined by the ITU-T H.273 standard.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ncolour.TRANSFER_CHARACTERISTICS_ITUTH273.keys()\n```\n\n----------------------------------------\n\nTITLE: Copying and Interpolating Spectral Distribution in Python\nDESCRIPTION: This snippet demonstrates how to copy and interpolate a spectral distribution using the `copy()` and `interpolate()` methods. It requires the `colour` library to be installed. The code copies the spectral distribution, interpolates it to a new shape from 400 to 770 with an interval of 1, and then accesses the value at wavelength 401.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Copying the sample spectral distribution.\nsd_copy = sd.copy()\n\n# Interpolating the copied sample spectral distribution.\nsd_copy.interpolate(colour.SpectralShape(400, 770, 1))\nsd_copy[401]\n```\n\n----------------------------------------\n\nTITLE: Accessing Signal Values at Arbitrary Points in Python\nDESCRIPTION: This snippet shows how to access the range values of a continuous signal at arbitrary domain points.  It generates random domain points and uses them as indices to retrieve corresponding range values from the Signal object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n    # Returning the corresponding range *y* variable for any arbitrary independent domain *x* variable.\n    signal[np.random.uniform(0, 9, 10)]\n```\n\n----------------------------------------\n\nTITLE: Creating and Representing a Continuous Signal in Python\nDESCRIPTION: This snippet demonstrates creating and representing a continuous signal using the colour.continuous.Signal class. It creates a Signal object from a numpy array and prints its representation, showing the data and interpolator/extrapolator settings.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n    import numpy as np\n\n    range_ = np.linspace(10, 100, 10)\n    signal = colour.continuous.Signal(range_)\n    print(repr(signal))\n```\n\n----------------------------------------\n\nTITLE: Displaying ITU-T H.273 Transfer Characteristics Keys as text\nDESCRIPTION: This text block shows the output keys from the `colour.TRANSFER_CHARACTERISTICS_ITUTH273.keys()` function in text format. The keys represent different transfer characteristic configurations as defined in ITU-T H.273.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_23\n\nLANGUAGE: text\nCODE:\n```\ndict_keys([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n```\n\n----------------------------------------\n\nTITLE: Setting Values Indirectly\nDESCRIPTION: This code demonstrates the correct method for setting values in the `SpectralDistribution`. The values are accessed, modified, and then reassigned back to the `values` property.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nvalues = sd.values\nvalues[0] = 0\nsd.values = values\nsd.values\n```\n\n----------------------------------------\n\nTITLE: Importing Colour Library\nDESCRIPTION: This code snippet imports the main Colour library and prints the first five elements of its public API's __all__ attribute, followed by an ellipsis, to indicate that there are more elements.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nprint(colour.__all__[:5] +  [\"...\"])\n```\n\n----------------------------------------\n\nTITLE: Listing ITU-T H.273 Matrix Coefficients - Colour Science (Python)\nDESCRIPTION: This snippet retrieves the keys for the `MATRIX_COEFFICIENTS_ITUTH273` dictionary in the `colour` library. This dictionary maps integer codes to matrix coefficient definitions as specified in the ITU-T H.273 standard.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_94\n\nLANGUAGE: python\nCODE:\n```\ncolour.MATRIX_COEFFICIENTS_ITUTH273.keys()\n```\n\n----------------------------------------\n\nTITLE: XYZ to UCS Conversion in Python\nDESCRIPTION: Demonstrates converting CIE XYZ color space values to CIE 1960 UCS color space values using the `colour.XYZ_to_UCS` function. This function takes an XYZ triplet as input and returns the corresponding UCS values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_58\n\nLANGUAGE: python\nCODE:\n```\ncolour.XYZ_to_UCS([0.20654008, 0.12197225, 0.05136952])\n```\n\n----------------------------------------\n\nTITLE: Get Primitive Vertices Methods\nDESCRIPTION: Retrieves and lists the available primitive vertices methods for generating 3D geometry. It lists the methods available for creating vertices for different primitive shapes, such as Cube MPL, Grid MPL, Quad MPL, and Sphere.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_89\n\nLANGUAGE: text\nCODE:\n```\n['Cube MPL', 'Grid MPL', 'Quad MPL', 'Sphere']\n```\n\n----------------------------------------\n\nTITLE: Modifying Spectral Distribution Values\nDESCRIPTION: This example demonstrates how to modify the values within a SpectralDistribution indirectly, by accessing the 'values' property, modifying the copy, and then assigning the copy back to the 'values' property. Direct modifications to the wavelength and values properties are not supported.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndata = {\n    500: 0.0651,\n    520: 0.0705,\n    540: 0.0772,\n    560: 0.0870,\n    580: 0.1128,\n    600: 0.1360,\n}\nsd = colour.SpectralDistribution(data)\n# Note: The wavelength 500nm is at index 0.\nsd.values[0] = 0\nsd[500]\n```\n\n----------------------------------------\n\nTITLE: Generating Geometry Primitive Vertices\nDESCRIPTION: Generates vertices for a specified geometry primitive based on the MPL implementation. The function takes the name of the primitive as input and returns an array of vertex positions.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_117\n\nLANGUAGE: python\nCODE:\n```\ncolour.primitive_vertices(\"Quad MPL\")\n```\n\n----------------------------------------\n\nTITLE: Example Output of Current Safe Division Mode\nDESCRIPTION: This example shows the default safe division mode.  It is set to 'Ignore Zero Conversion' which means divide by zero operations occur silently and produce zero values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_25\n\nLANGUAGE: text\nCODE:\n```\n'Ignore Zero Conversion'\n```\n\n----------------------------------------\n\nTITLE: Slicing Spectral Distribution by Index\nDESCRIPTION: This example demonstrates how to retrieve spectral distribution values using slicing. When a slice is used, the values for the corresponding wavelength *indexes* are returned, not values interpolated at given wavelengths.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nsd[0:3]\n```\n\n----------------------------------------\n\nTITLE: Converting NumPy Array of xyY Values to XYZ in Colour\nDESCRIPTION: This example showcases how to use NumPy arrays with the `colour` module for converting xyY to XYZ. It first creates a NumPy array of xyY values and then uses `colour.xyY_to_XYZ` to perform the conversion. It demonstrates the n-dimensional array support.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nxyY = np.array([0.4316, 0.3777, 0.1008])\nxyY = np.tile(xyY, (6, 1))\ncolour.xyY_to_XYZ(xyY)\n```\n\nLANGUAGE: text\nCODE:\n```\narray([[ 0.11518475,  0.1008    ,  0.05089373],\n       [ 0.11518475,  0.1008    ,  0.05089373],\n       [ 0.11518475,  0.1008    ,  0.05089373],\n       [ 0.11518475,  0.1008    ,  0.05089373],\n       [ 0.11518475,  0.1008    ,  0.05089373],\n       [ 0.11518475,  0.1008    ,  0.05089373]])\n```\n\n----------------------------------------\n\nTITLE: Setting the Domain-Range Scale to '1'\nDESCRIPTION: This example shows how to switch the domain-range scale to '1' and demonstrates the effect on the output of `chromatic_adaptation_CIE1994`. The input values are scaled appropriately to work within the [0, 1] domain.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nXYZ_1 = [28.00, 21.26, 5.27]\nxy_o1 = [0.4476, 0.4074]\nxy_o2 = [0.3127, 0.3290]\nY_o = 20\nE_o1 = 1000\nE_o2 = 1000\ncolour.adaptation.chromatic_adaptation_CIE1994(XYZ_1, xy_o1, xy_o2, Y_o, E_o1, E_o2)\n```\n\n----------------------------------------\n\nTITLE: Using SpectralShape with Iteration in Python\nDESCRIPTION: This snippet demonstrates how to create a `colour.SpectralShape` object and iterate over its wavelengths.  It requires the `colour` library to be installed. The code creates a spectral shape from 0 to 10 with an interval of 1 and prints each wavelength in the range.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Using *colour.SpectralShape* with iteration.\nshape = colour.SpectralShape(start=0, end=10, interval=1)\nfor wavelength in shape:\n    print(wavelength)\n\n# *colour.SpectralShape.wavelengths* property is providing the complete\n# range of wavelengths.\nshape = colour.SpectralShape(0, 10, 0.5)\nshape.wavelengths\n```\n\n----------------------------------------\n\nTITLE: RGB to YCoCg Conversion in Python\nDESCRIPTION: Demonstrates converting RGB color values to YCoCg color encoding values using the `colour.RGB_to_YCoCg` function. The function takes an RGB triplet as input and returns the corresponding YCoCg values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_77\n\nLANGUAGE: python\nCODE:\n```\ncolour.RGB_to_YCoCg([0.75, 0.75, 0.0])\n```\n\n----------------------------------------\n\nTITLE: Example of Colour Cache Registry Output\nDESCRIPTION: This text snippet shows example output from printing the Colour cache registry. The output is a dictionary showing the cache keys (related to different functionalities) and the number of items currently stored in each cache. It provides insights into which aspects of Colour are using caching.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/advanced.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n{'colour.colorimetry.spectrum._CACHE_RESHAPED_SDS_AND_MSDS': '0 item(s)',\n 'colour.colorimetry.tristimulus_values._CACHE_LAGRANGE_INTERPOLATING_COEFFICIENTS': '0 '\n                                                                                         'item(s)',\n 'colour.colorimetry.tristimulus_values._CACHE_SD_TO_XYZ': '0 item(s)',\n 'colour.colorimetry.tristimulus_values._CACHE_TRISTIMULUS_WEIGHTING_FACTORS': '0 '\n                                                                                   'item(s)',\n 'colour.quality.cfi2017._CACHE_TCS_CIE2017': '0 item(s)',\n 'colour.volume.macadam_limits._CACHE_OPTIMAL_COLOUR_STIMULI_XYZ': '0 item(s)',\n 'colour.volume.macadam_limits._CACHE_OPTIMAL_COLOUR_STIMULI_XYZ_TRIANGULATIONS': '0 '\n                                                                                      'item(s)',\n 'colour.volume.spectrum._CACHE_OUTER_SURFACE_XYZ': '0 item(s)',\n 'colour.volume.spectrum._CACHE_OUTER_SURFACE_XYZ_POINTS': '0 item(s)'}\n```\n\n----------------------------------------\n\nTITLE: Representing Spectral Shape in Python\nDESCRIPTION: This snippet demonstrates how to represent the spectral shape of a `colour.SpectralShape` object using `repr()`. It requires a `colour.SpectralShape` object named `sd.shape` to be defined, which contains information about the start, end, and interval of the spectral data. It provides a string representation of the object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nrepr(sd.shape)\n```\n\n----------------------------------------\n\nTITLE: Plotting Luminous Efficiency Functions\nDESCRIPTION: Plots luminous efficiency functions (LEFs). This function plots the mesopic luminous efficiency function along with the CIE 1924 photopic and CIE 1951 scotopic standard observer functions.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_123\n\nLANGUAGE: python\nCODE:\n```\nsd_mesopic_luminous_efficiency_function = (\n        colour.sd_mesopic_luminous_efficiency_function(0.2)\n    )\nplot_multi_sds(\n        (\n            sd_mesopic_luminous_efficiency_function,\n            colour.colorimetry.SDS_LEFS_PHOTOPIC[\"CIE 1924 Photopic Standard Observer\"],\n            colour.colorimetry.SDS_LEFS_SCOTOPIC[\"CIE 1951 Scotopic Standard Observer\"],\n        ),\n        y_label=\"Luminous Efficiency\",\n        legend_location=\"upper right\",\n        y_tighten=True,\n        margins=(0, 0, 0, 0.1),\n    )\n```\n\n----------------------------------------\n\nTITLE: Setting Safe Division Mode to Ignore Zero Conversion\nDESCRIPTION: This snippet sets the safe division mode to \"Ignore Zero Conversion\" and then calculates UCS to uv coordinates with a zero vector.  With this mode, the division by zero will not trigger a runtime warning and will result in zero values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ncolour.algebra.set_sdiv_mode(\"Ignore Zero Conversion\")\ncolour.UCS_to_uv([0, 0, 0])\n```\n\n----------------------------------------\n\nTITLE: Accessing Colour Sub-Package APIs\nDESCRIPTION: This code iterates through a list of Colour sub-packages, printing the first five elements of each sub-package's public API. It uses the getattr() method to access the sub-package's __all__ attribute.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pprint import pprint\n\nfor sub_package in (\n    \"adaptation\",\n    \"algebra\",\n    \"appearance\",\n    \"biochemistry\",\n    \"blindness\",\n    \"characterisation\",\n    \"colorimetry\",\n    \"constants\",\n    \"continuous\",\n    \"contrast\",\n    \"corresponding\",\n    \"difference\",\n    \"geometry\",\n    \"graph\",\n    \"hints\",\n    \"io\",\n    \"models\",\n    \"notation\",\n    \"phenomena\",\n    \"plotting\",\n    \"quality\",\n    \"recovery\",\n    \"temperature\",\n    \"utilities\",\n    \"volume\",\n):\n    print(sub_package.title())\n    pprint(getattr(colour, sub_package).__all__[:5] + [\"...\"])\n    print(\"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Example Output of Chromatic Adaptation\nDESCRIPTION: This is an example output of a chromatic adaptation calculation. It shows the resulting adapted XYZ values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_23\n\nLANGUAGE: text\nCODE:\n```\n[ 0.24033795  0.21156212  0.17643012]\n```\n\n----------------------------------------\n\nTITLE: List Lightness Methods Python\nDESCRIPTION: This snippet retrieves and sorts the available lightness computation methods from the `colour` library. It showcases the various algorithms available. It requires the `colour` library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.LIGHTNESS_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Example Output with Numpy Safe Division Mode\nDESCRIPTION: This example shows the output when safe division mode is set to \"Numpy\". A runtime warning is displayed, and the result contains NaN values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_27\n\nLANGUAGE: text\nCODE:\n```\n/Users/kelsolaar/Documents/Development/colour-science/colour/colour/algebra/common.py:317: RuntimeWarning: invalid value encountered in true_divide\n  c = a / b\narray([ nan,  nan])\n```\n\n----------------------------------------\n\nTITLE: Colour Fidelity Index Result as Text\nDESCRIPTION: This text block shows the output from the `colour.colour_fidelity_index(colour.SDS_ILLUMINANTS[\"FL2\"])` function, presenting the computed Colour Fidelity Index value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_41\n\nLANGUAGE: text\nCODE:\n```\n70.120824401428848\n```\n\n----------------------------------------\n\nTITLE: Listing Colour Fidelity Index Methods using Python\nDESCRIPTION: This code snippet retrieves and sorts the available methods for calculating the Colour Fidelity Index (CFI) using `colour.COLOUR_FIDELITY_INDEX_METHODS`. These methods represent different algorithms or standards for computing CFI.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.COLOUR_FIDELITY_INDEX_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Generate Geometry Primitive (Python)\nDESCRIPTION: Generates a geometry primitive using the `colour.primitive` function. The function takes the name of the primitive as input and returns the vertices and faces of the geometry.  In this example a Grid primitive is generated.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_68\n\nLANGUAGE: python\nCODE:\n```\ncolour.primitive(\"Grid\")\n```\n\n----------------------------------------\n\nTITLE: Spectral Similarity Index Result as Text\nDESCRIPTION: This text block shows the output from the `colour.spectral_similarity_index(colour.SDS_ILLUMINANTS[\"C\"], colour.SDS_ILLUMINANTS[\"D65\"])` function, presenting the computed Spectral Similarity Index value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_53\n\nLANGUAGE: text\nCODE:\n```\n94.0\n```\n\n----------------------------------------\n\nTITLE: Exploring RGB Colourspace Objects in Colour with IPython\nDESCRIPTION: This example shows how to use IPython or Jupyter Notebook's auto-completion feature to discover RGB colourspace related objects within the `colour.models` module. It lists the attributes starting with `RGB_COLOURSPACE`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nIn [2]: colour.models.RGB_COLOURSPACE\n                             RGB_COLOURSPACE_ACES2065_1           RGB_COLOURSPACE_ACESPROXY            RGB_COLOURSPACE_APPLE_RGB            RGB_COLOURSPACE_BT470_525\n                             RGB_COLOURSPACE_ACESCC               RGB_COLOURSPACE_ADOBE_RGB1998        RGB_COLOURSPACE_BEST_RGB             RGB_COLOURSPACE_BT470_625\n                             RGB_COLOURSPACE_ACESCCT              RGB_COLOURSPACE_ADOBE_WIDE_GAMUT_RGB RGB_COLOURSPACE_BETA_RGB             RGB_COLOURSPACE_BT709                >\n                             RGB_COLOURSPACE_ACESCG               RGB_COLOURSPACE_ARRI_WIDE_GAMUT_3    RGB_COLOURSPACE_BT2020               RGB_COLOURSPACE_CIE_RGB\n```\n\n----------------------------------------\n\nTITLE: Describing Video Signal Matrix Coefficients using Python\nDESCRIPTION: This code uses the `colour.models.describe_video_signal_matrix_coefficients(1)` function to output detailed information about the video signal matrix coefficients represented by the integer '1'. This includes the matrix coefficients themselves and relevant FFmpeg constants.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ncolour.models.describe_video_signal_matrix_coefficients(1)\n```\n\n----------------------------------------\n\nTITLE: Geometry Primitive Output (Text)\nDESCRIPTION: Outputs the vertices, UV coordinates, normals, colors, faces, and outline edges of a generated 'Grid' geometry primitive. This output describes the structure of the generated grid, including vertex positions, texture coordinates, surface normals, color data, and connectivity information to form faces and outlines.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_69\n\nLANGUAGE: text\nCODE:\n```\n (array([ ([-0.5,  0.5,  0. ], [ 0.,  1.], [ 0.,  0.,  1.], [ 0.,  1.,  0.,  1.]),\n           ([ 0.5,  0.5,  0. ], [ 1.,  1.], [ 0.,  0.,  1.], [ 1.,  1.,  0.,  1.]),\n           ([-0.5, -0.5,  0. ], [ 0.,  0.], [ 0.,  0.,  1.], [ 0.,  0.,  0.,  1.]),\n           ([ 0.5, -0.5,  0. ], [ 1.,  0.], [ 0.,  0.,  1.], [ 1.,  0.,  0.,  1.])],\n          dtype=[('position', '<f4', (3,)), ('uv', '<f4', (2,)), ('normal', '<f4', (3,)), ('colour', '<f4', (4,))]), array([[0, 2, 1],\n           [2, 3, 1]], dtype=uint32), array([[0, 2],\n           [2, 3],\n           [3, 1],\n           [1, 0]], dtype=uint32))\n```\n\n----------------------------------------\n\nTITLE: Chromatic Adaptation Output\nDESCRIPTION: This is the output of the chromatic adaptation function. It shows the adapted XYZ values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_6\n\nLANGUAGE: Text\nCODE:\n```\narray([ 0.25331034,  0.13765286,  0.01543185])\n```\n\n----------------------------------------\n\nTITLE: Exploring Spectral Distribution Objects in Colour with IPython\nDESCRIPTION: This example shows how to use IPython or Jupyter Notebook's auto-completion feature to discover spectral distribution related objects within the `colour` module. It imports the `colour` module and lists the attributes starting with `sd_`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nIn [1]: import colour\n\nIn [2]: colour.sd_\n sd_blackbody()                            sd_gaussian()                             sd_rayleigh_scattering()                  sd_zeros\n sd_CIE_illuminant_D_series()              sd_mesopic_luminous_efficiency_function() sd_single_led()\n sd_CIE_standard_illuminant_A()            sd_multi_leds()                           sd_to_aces_relative_exposure_values()\n sd_constant()                             sd_ones()                                 sd_to_XYZ\n```\n\n----------------------------------------\n\nTITLE: Primitive Vertices Output (Text)\nDESCRIPTION: Displays the array of vertices for the generated primitive i.e. Quad MPL. This output represents the 3D coordinates of each vertex in the primitive, defining its shape.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_73\n\nLANGUAGE: text\nCODE:\n```\narray([[ 0.,  0.,  0.],\n           [ 1.,  0.,  0.],\n           [ 1.,  1.,  0.],\n           [ 0.,  1.,  0.]])\n```\n\n----------------------------------------\n\nTITLE: Accessing Spectral Distribution Value at Specific Wavelength in Colour\nDESCRIPTION: This example demonstrates how to access the value of a spectral distribution at a specific wavelength using the `colour` library. It creates a `SpectralDistribution` object with sample data and then retrieves the value at wavelength 555.5.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndata = {\n    500: 0.0651,\n    520: 0.0705,\n    540: 0.0772,\n    560: 0.0870,\n    580: 0.1128,\n    600: 0.1360,\n}\nsd = colour.SpectralDistribution(data)\nsd[555.5]\n```\n\nLANGUAGE: text\nCODE:\n```\n0.083453673782958995\n```\n\n----------------------------------------\n\nTITLE: Listing ITU-T H.273 Colour Primaries with Python\nDESCRIPTION: This snippet retrieves and displays the keys representing the colour primaries defined within the `colour.COLOUR_PRIMARIES_ITUTH273` dictionary. This dictionary maps integer codes to the specific colour primary definitions as per ITU-T H.273 standard.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ncolour.COLOUR_PRIMARIES_ITUTH273.keys()\n```\n\n----------------------------------------\n\nTITLE: Colour Rendering Index Result as Text\nDESCRIPTION: This text block shows the output from the `colour.colour_rendering_index(colour.SDS_ILLUMINANTS[\"FL2\"])` function, presenting the computed Colour Rendering Index value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_49\n\nLANGUAGE: text\nCODE:\n```\n64.233724121664793\n```\n\n----------------------------------------\n\nTITLE: Available XY to CCT Methods (Text)\nDESCRIPTION: Displays the list of available methods for `colour.XY_TO_CCT_METHODS`. The output shows a list of string values that represents names of available methods to compute CCT from xy chromaticity coordinates.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_65\n\nLANGUAGE: text\nCODE:\n```\n['CIE Illuminant D Series',\n     'Hernandez 1999',\n     'Kang 2002',\n     'McCamy 1992',\n     'daylight',\n     'hernandez1999',\n     'kang2002',\n     'mccamy1992']\n```\n\n----------------------------------------\n\nTITLE: Displaying ITU-T H.273 Colour Primaries keys as text\nDESCRIPTION: This snippet displays the keys returned by the colour.COLOUR_PRIMARIES_ITUTH273.keys() function in text format. The keys represent different colour primary configurations as defined in ITU-T H.273.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_19\n\nLANGUAGE: text\nCODE:\n```\ndict_keys([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 22, 23])\n```\n\n----------------------------------------\n\nTITLE: Displaying Colour Rendering Index Methods List as Text\nDESCRIPTION: This text block shows the output from `sorted(colour.COLOUR_RENDERING_INDEX_METHODS)`, displaying the available methods for computing Colour Rendering Index. The methods include 'CIE 1995' and 'CIE 2024'.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_51\n\nLANGUAGE: text\nCODE:\n```\n['CIE 1995', 'CIE 2024']\n```\n\n----------------------------------------\n\nTITLE: Importing Plotting Namespace\nDESCRIPTION: Imports all objects from the `colour.plotting` namespace, making them available for use in plotting operations. Then applies the default colour style.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_118\n\nLANGUAGE: python\nCODE:\n```\nfrom colour.plotting import *\n\ncolour_style()\n```\n\n----------------------------------------\n\nTITLE: Install Colour Science Library using conda in Bash\nDESCRIPTION: This command installs the Colour Science library from the conda-forge channel using conda. Conda is a package, dependency and environment management for any languagePython, R, Ruby, Lua, Scala, Java, JavaScript, C/ C++, FORTRAN.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_134\n\nLANGUAGE: bash\nCODE:\n```\n$ conda install -c conda-forge colour-science\n```\n\n----------------------------------------\n\nTITLE: Displaying Reflectance Recovery Methods List as Text\nDESCRIPTION: This text block shows the output from `sorted(colour.REFLECTANCE_RECOVERY_METHODS)`, displaying the available methods for reflectance recovery. The methods include 'Jakob 2019', 'Mallett 2019', etc.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_57\n\nLANGUAGE: text\nCODE:\n```\n['Jakob 2019', 'Mallett 2019', 'Meng 2015', 'Otsu 2018', 'Smits 1999']\n```\n\n----------------------------------------\n\nTITLE: XYZ to CIECAM02 Conversion Output\nDESCRIPTION: This is the output for the XYZ to CIECAM02 conversion. It returns a `CAM_Specification_CIECAM02` object containing the computed parameters.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_14\n\nLANGUAGE: Text\nCODE:\n```\nCAM_Specification_CIECAM02(J=34.434525727858997, C=67.365010921125915, h=22.279164147957076, s=62.814855853327131, Q=177.47124941102123, M=70.024939419291385, H=2.689608534423904, HC=None)\n```\n\n----------------------------------------\n\nTITLE: Sprague Interpolation in Python\nDESCRIPTION: Demonstrates Sprague interpolation using `colour.SpragueInterpolator`. Similar to kernel interpolation, it interpolates values at specific points based on given x and y data, but using the Sprague method.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\ny = [5.9200, 9.3700, 10.8135, 4.5100, 69.5900, 27.8007, 86.0500]\nx = range(len(y))\ncolour.SpragueInterpolator(x, y)([0.25, 0.75, 5.50])\n```\n\n----------------------------------------\n\nTITLE: Displaying Colour Quality Scale Methods List as Text\nDESCRIPTION: This text block shows the output from `sorted(colour.COLOUR_QUALITY_SCALE_METHODS)`, displaying the available methods for computing Colour Quality Scale. The methods include 'NIST CQS 7.4' and 'NIST CQS 9.0'.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_47\n\nLANGUAGE: text\nCODE:\n```\n['NIST CQS 7.4', 'NIST CQS 9.0']\n```\n\n----------------------------------------\n\nTITLE: XYZ to CAM16 Conversion in Python\nDESCRIPTION: Similar to CIECAM16 and CIECAM02, this converts XYZ to CAM16 using `colour.XYZ_to_CAM16` with the same inputs.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\ncolour.XYZ_to_CAM16(XYZ, XYZ_w, L_A, Y_b)\n```\n\n----------------------------------------\n\nTITLE: Printing Available Interpolators in Python\nDESCRIPTION: This snippet demonstrates how to print a list of available interpolators in the `colour.algebra.interpolation` module. It uses a list comprehension to filter the exports and identify those containing \"Interpolator\" in their names. The pprint function is used for pretty printing the resulting list.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\npprint(\n    [\n        export\n        for export in colour.algebra.interpolation.__all__\n        if \"Interpolator\" in export\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Munsell Value Result as Text\nDESCRIPTION: This text block shows the output from the `colour.munsell_value(12.23634268)` function, which calculates the Munsell value corresponding to the given lightness value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_31\n\nLANGUAGE: text\nCODE:\n```\n4.0824437076525664\n```\n\n----------------------------------------\n\nTITLE: Listing Munsell Value Methods using Python\nDESCRIPTION: This code snippet retrieves and sorts the available methods for calculating Munsell value using `colour.MUNSELL_VALUE_METHODS`. These methods represent different algorithms or formulas for computing Munsell value from lightness.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.MUNSELL_VALUE_METHODS)\n```\n\n----------------------------------------\n\nTITLE: Kernel Interpolation Output\nDESCRIPTION: This is the output of the kernel interpolation, returning the interpolated y values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_10\n\nLANGUAGE: Text\nCODE:\n```\narray([  6.18062083,   8.08238488,  57.85783403])\n```\n\n----------------------------------------\n\nTITLE: Converting xyY to XYZ with a Tuple in Colour\nDESCRIPTION: This example demonstrates how to convert from xyY chromaticity coordinates and luminance to XYZ tristimulus values using a tuple as input. It imports the `colour` module and calls the `xyY_to_XYZ` function.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport colour\n\nxyY = (0.4316, 0.3777, 0.1008)\ncolour.xyY_to_XYZ(xyY)\n```\n\nLANGUAGE: text\nCODE:\n```\narray([ 0.11518475,  0.1008    ,  0.05089373])\n```\n\n----------------------------------------\n\nTITLE: Displaying Spectral Distribution Shape in Python\nDESCRIPTION: This snippet demonstrates how to display the shape of a spectral distribution using the `shape` attribute. It requires a spectral distribution object named `sd` to be defined. The output is the shape of the spectral distribution, represented as a tuple.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Displaying the sample spectral distribution shape.\nprint(sd.shape)\n```\n\n----------------------------------------\n\nTITLE: Example Output with Ignore Zero Conversion\nDESCRIPTION: This example shows the output when safe division mode is set to \"Ignore Zero Conversion\". The result is an array of zeros, as NaN values are converted to zeros.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_29\n\nLANGUAGE: text\nCODE:\n```\narray([ 0.,  0.])\n```\n\n----------------------------------------\n\nTITLE: Triggering a Warning with Incorrectly Scaled Values\nDESCRIPTION: This code demonstrates the warning that occurs when calling `chromatic_adaptation_CIE1994` with values that are not correctly scaled for the current domain-range scale. It resets the domain-range scale to 'Reference' and then calls the function with values scaled for the '1' domain.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ncolour.set_domain_range_scale(\"Reference\")\n\ncolour.adaptation.chromatic_adaptation_CIE1994(XYZ_1, xy_o1, xy_o2, Y_o, E_o1, E_o2)\n```\n\n----------------------------------------\n\nTITLE: Automatic Colour Conversion with Illuminant Output\nDESCRIPTION: This is the output from the automatic colour conversion example with illuminant specified. It shows the array output of the conversion.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_4\n\nLANGUAGE: Text\nCODE:\n```\narray([ 0.47924575,  0.31676968,  0.17362725])\n```\n\n----------------------------------------\n\nTITLE: Colour Quality Scale Result as Text\nDESCRIPTION: This text block shows the output from the `colour.colour_quality_scale(colour.SDS_ILLUMINANTS[\"FL2\"])` function, presenting the computed Colour Quality Scale value.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_45\n\nLANGUAGE: text\nCODE:\n```\n64.111822015662824\n```\n\n----------------------------------------\n\nTITLE: XYZ to Kim2009 Conversion Output\nDESCRIPTION: The result of converting XYZ to Kim2009 is a `CAM_Specification_Kim2009` object with the calculated parameters.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_22\n\nLANGUAGE: Text\nCODE:\n```\nCAM_Specification_Kim2009(J=19.879918542450937, C=55.83905525087696, h=22.013388165090031, s=112.9797935493912, Q=36.309026130161513, M=46.346415858227871, H=2.3543198369639753, HC=None)\n```\n\n----------------------------------------\n\nTITLE: XYZ to ZCAM Conversion Output\nDESCRIPTION: The output is a `CAM_Specification_ZCAM` object after converting XYZ to ZCAM, displaying the model's parameters.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_24\n\nLANGUAGE: Text\nCODE:\n```\nCAM_Specification_ZCAM(J=38.347186278956357, C=21.121389892085183, h=33.711578931095183, s=81.444585609489536, Q=76.986725284523772, M=42.403805833900513, H=0.45779200212217158, HC=None, V=43.623590687423551, K=43.20894953152817, W=34.829588380192149)\n```\n\n----------------------------------------\n\nTITLE: Sprague Interpolation Output\nDESCRIPTION: This is the output of the sprague interpolation, showing the interpolated y values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_12\n\nLANGUAGE: Text\nCODE:\n```\narray([  6.72951612,   7.81406251,  43.77379185])\n```\n\n----------------------------------------\n\nTITLE: TODO: Consider MutableMapping usage (plotting)\nDESCRIPTION: This task suggests considering using \"MutableMapping\" in `colour/plotting/common.py`. It implies that the current data structure might benefit from the features and behavior of a MutableMapping object.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_32\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Consider using \"MutableMapping\" here.\n```\n\n----------------------------------------\n\nTITLE: TODO: Generalise polynomial expansion\nDESCRIPTION: This task involves generalizing the polynomial expansion functionality within `colour/characterisation/correction.py`. This suggests that the current implementation might be limited and could benefit from increased flexibility.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_34\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Generalise polynomial expansion.\n```\n\n----------------------------------------\n\nTITLE: Example Output of Colour Calculation with Mocking Function\nDESCRIPTION: This text snippet shows the output from running the Colour calculation using the `mock_scipy_for_colour` mocking function.  It's the same result as the previous example, confirming the mocking approach works as intended for the xyY to XYZ conversion. This confirms that even with mocked Scipy, parts of the Colour library can still function properly.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/advanced.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\narray([ 0.11518475,  0.1008    ,  0.05089373])\n```\n\n----------------------------------------\n\nTITLE: TODO: Investigate Windows array behaviour\nDESCRIPTION: This task suggests investigating the array behaviour on Windows systems within the `colour/utilities/array.py` file, implying potential platform-specific issues or inconsistencies.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_27\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Investigate behaviour on Windows.\n```\n\n----------------------------------------\n\nTITLE: TODO: Remove 'colour.sd_blackbody' warning\nDESCRIPTION: This task involves removing the warning related to the `colour.sd_blackbody` definition in `colour/characterisation/aces_it.py`. This likely means the underlying issue causing the warning has been resolved or addressed.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Remove when removing the \"colour.sd_blackbody\" definition warning.\n```\n\n----------------------------------------\n\nTITLE: Available Primitive Methods (Text)\nDESCRIPTION: Displays the list of available primitive methods. This shows a list of string values representing names of available primitives to be generated, like 'Cube' and 'Grid'.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_71\n\nLANGUAGE: text\nCODE:\n```\n['Cube', 'Grid']\n```\n\n----------------------------------------\n\nTITLE: TODO: Revisit Protocol usage (hints)\nDESCRIPTION: This task suggests revisiting the use of Protocol within `colour/hints/__init__.py`. This could involve evaluating whether Protocol is being used effectively and whether any adjustments are needed for type hinting.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_38\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Revisit to use Protocol.\n```\n\n----------------------------------------\n\nTITLE: TODO: Check for extrapolator compatibility (signal)\nDESCRIPTION: This task advises to check for extrapolator compatibility within `colour/continuous/signal.py`. It implies there may be compatibility issues or limitations between different extrapolators and signal types.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_37\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Check for extrapolator compatibility.\n```\n\n----------------------------------------\n\nTITLE: TODO: Refactor Munsell implementation\nDESCRIPTION: This task suggests considering refactoring the implementation of the Munsell notation functionality in `colour/notation/munsell.py`. This could involve improving the code's structure, efficiency, or maintainability.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_35\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Consider refactoring implementation.\n```\n\n----------------------------------------\n\nTITLE: TODO: Reinstate CTL test coverage\nDESCRIPTION: This task involves reinstating code coverage for CTL tests (`colour/io/tests/test_ctl.py`) once \"ctlrender\" is trivially available cross-platform. It's similar to the TODO item in `colour/io/ctl.py`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Reinstate coverage when \"ctlrender\" is tivially available cross-platform.\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement hue composition computation (LLAB)\nDESCRIPTION: This task involves implementing the hue composition calculation in the LLAB appearance model, located in `colour/appearance/llab.py`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement hue composition computation.\n```\n\n----------------------------------------\n\nTITLE: TODO: Reassess Matplotlib issue\nDESCRIPTION: This task advises reassessing a situation based on https://github.com/matplotlib/matplotlib/issues/1077 within `colour/plotting/common.py`, suggesting a potential workaround or dependency on a fix in Matplotlib.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_31\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Reassess according to https://github.com/matplotlib/matplotlib/issues/1077\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement TOML support for verbose module\nDESCRIPTION: This task involves implementing support for \"pyproject.toml\" files in the verbose module (`colour/utilities/verbose.py`) when TOML support becomes available in the Python standard library. It also notes that some clauses are not reached during continuous integration.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_23\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement support for \"pyproject.toml\" file whenever \"TOML\" is supported in the standard library. NOTE: A few clauses are not reached and a few packages are not available during continuous integration and are thus ignored for coverage.\n```\n\n----------------------------------------\n\nTITLE: TODO: Consider ordered set usage (network)\nDESCRIPTION: This task suggests considering the use of an ordered set instead of a dictionary in the network module (`colour/utilities/network.py`) for maintaining order and uniqueness of elements.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_24\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Consider using an ordered set instead of a dict.\n```\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Consider using ordered set.\n```\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Consider using ordered set.\n```\n\n----------------------------------------\n\nTITLE: TODO: Filter colour models (plotting)\nDESCRIPTION: This task involves filtering appropriate colour models for plotting purposes in `colour/plotting/models.py`. The comment also mentions the need for \"dtype=object\" for ragged array support in NumPy 1.24.0.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_29\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Filter appropriate colour models. NOTE: \"dtype=object\" is required for ragged array support in \"Numpy\" 1.24.0.\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement hue quadrature & composition (Nayatani95)\nDESCRIPTION: This task involves implementing hue quadrature and composition calculations within the Nayatani95 appearance model in `colour/appearance/nayatani95.py`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement hue quadrature & composition computation.\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement bi-spectral component integration\nDESCRIPTION: This task suggests implementing support for integrating a bi-spectral component within `colour/io/fichet2021.py`. This could involve handling spectral data with two independent variables.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement support for integration of bi-spectral component.\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement re-binning component with non-uniform interval\nDESCRIPTION: This task suggests implementing support for re-binning a spectral component with a non-uniform interval in `colour/io/fichet2021.py`. This would allow for flexible spectral data handling.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement support for re-binning component with non-uniform interval.\n```\n\n----------------------------------------\n\nTITLE: Listing Chromatic Adaptation Methods Output\nDESCRIPTION: This is the output of the `sorted` function on the available chromatic adaptation methods in colour science library.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_8\n\nLANGUAGE: Text\nCODE:\n```\n['CIE 1994', 'CMCCAT2000', 'Fairchild 1990', 'Von Kries', 'Zhai 2018', 'vK20']\n```\n\n----------------------------------------\n\nTITLE: TODO: Investigate components usage (Nayatani95)\nDESCRIPTION: This task suggests investigating the usage of components, specifically `M_RG` and `M_YB`, in the Nayatani95 appearance model within `colour/appearance/nayatani95.py`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Investigate components usage. M_RG, M_YB = tsplit(colourfulness_components(C_RG, C_YB, brightness_ideal_white))\n```\n\n----------------------------------------\n\nTITLE: Example Spectrometer Data\nDESCRIPTION: This shows an example of spectrometer data with floating point wavelengths. This is from an Ocean Insight (Optics) STS-VIS spectrometer.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nData from Subt2_14-36-15-210.txt Node\n\nDate: Sat Nov 17 14:36:15 NZDT 2018\nUser: kelsolaar\nSpectrometer: S12286\nTrigger mode: 0\nResolution mode: 1024 pixels\nIntegration Time (sec): 5.000000E0\nScans to average: 3\nNonlinearity correction enabled: true\nBoxcar width: 3\nBaseline correction enabled: true\nXAxis mode: Wavelengths\nNumber of Pixels in Spectrum: 1024\n# >>>>>Begin Spectral Data<<<<<\n338.028\t279.71\n338.482\t285.43\n338.936\t291.33\n...\n821.513\t3112.65\n822.008\t3133.74\n822.503\t3107.11\n```\n\n----------------------------------------\n\nTITLE: XYZ to CIECAM16 Conversion Output\nDESCRIPTION: Output of the CIECAM16 Conversion. It returns a `CAM_Specification_CIECAM16` object containing the computed parameters.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_16\n\nLANGUAGE: Text\nCODE:\n```\nCAM_Specification_CIECAM16(J=33.880368498111686, C=69.444353357408033, h=19.510887327451748, s=64.03612114840314, Q=176.03752758512178, M=72.18638534116765, H=399.52975599115319, HC=None)\n```\n\n----------------------------------------\n\nTITLE: TODO: Check for interpolator compatibility (signal)\nDESCRIPTION: This task advises to check for interpolator compatibility within `colour/continuous/signal.py`. It implies there may be compatibility issues or limitations between different interpolators and signal types.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_36\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Check for interpolator compatibility.\n```\n\n----------------------------------------\n\nTITLE: List Available Primitive Methods (Python)\nDESCRIPTION: Lists the available methods for generating geometry primitives. This example sorts and prints the available primitive generation methods using the `colour.PRIMITIVE_METHODS` attribute.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nsorted(colour.PRIMITIVE_METHODS)\n```\n\n----------------------------------------\n\nTITLE: TODO: Investigate conversion graph build API\nDESCRIPTION: This task suggests investigating the API to trigger the conversion graph build within the `colour/plotting/graph.py` file. This could involve exploring ways to initiate or control the graph generation process.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_30\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Investigate API to trigger the conversion graph build.\n```\n\n----------------------------------------\n\nTITLE: TODO: Annotate with Union type (array)\nDESCRIPTION: This task suggests adding a type annotation using `Union[Literal['ignore', 'reference', '1', '100'], str]` in `colour/utilities/array.py` when Python 3.7 support is dropped. This will improve type hinting and code clarity.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_28\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Annotate with \"Union[Literal['ignore', 'reference', '1', '100'], str]\" when Python 3.7 is dropped.\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement hue composition computation (RLAB)\nDESCRIPTION: This task requires implementing the hue composition calculation in the RLAB appearance model, found in `colour/appearance/rlab.py`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement hue composition computation.\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement solid control flow (network)\nDESCRIPTION: This task involves implementing a solid control flow based processing system using a stack in the network module (`colour/utilities/network.py`). This aims to improve the structure and maintainability of the network processing logic.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_25\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement solid control flow based processing using a stack.\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement whiteness-blackness computation (Hunt)\nDESCRIPTION: This task involves implementing the whiteness-blackness :math:`Q_{wb}` computation in the Hunt appearance model within `colour/appearance/hunt.py`.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement whiteness-blackness :math:`Q_{wb}` computation.\n```\n\n----------------------------------------\n\nTITLE: TODO: Simplify RGB derivation test\nDESCRIPTION: This task recommends simplifying a complex test within `colour/models/rgb/tests/test_derivation.py`. The comment suggests that the test is overly complicated and should be refactored for better readability and maintainability.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_22\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Simplify that monster.\n```\n\n----------------------------------------\n\nTITLE: TODO: Remove deprecated RGB colourspace tests\nDESCRIPTION: This task indicates the removal of tests related to deprecated signature support within the `colour/models/rgb/tests/test_rgb_colourspace.py` file. These tests are no longer relevant as the deprecated functionality is being removed.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Remove tests when dropping deprecated signature support.\n```\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Remove tests when dropping deprecated signature support.\n```\n\n----------------------------------------\n\nTITLE: TODO: Investigate tristimulus vectorisation\nDESCRIPTION: This task recommends investigating the possibility of vectorizing the code for calculating tristimulus values in `colour/colorimetry/tristimulus_values.py`. Vectorization can potentially improve performance.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Investigate code vectorisation.\n```\n\n----------------------------------------\n\nTITLE: TODO: Investigate OpenImageIO image behaviour\nDESCRIPTION: This task suggests investigating the behavior of \"OIIO\" (OpenImageIO) when reading images in `colour/io/tests/test_image.py`. It highlights a discrepancy where a maximum pixel value of 1.0 is not equal to 15360.0 as expected, indicating a potential issue with data type handling or scaling.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Investigate \"OIIO\" behaviour here: 1.0 != 15360.0 image = read_image_OpenImageIO( os.path.join(ROOT_RESOURCES, 'Colour_Logo.png'), 'float16') self.assertIs(image.dtype, np.dtype('float16')) self.assertEqual(np.min(image), 0.0) self.assertEqual(np.max(image), 1.0)\n```\n\n----------------------------------------\n\nTITLE: TODO: Compute hue composition (CIECAM16)\nDESCRIPTION: This task involves implementing hue composition calculation within the `colour/appearance/ciecam16.py` file. This is a component of the CIECAM16 appearance model.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Compute hue composition.\n```\n\n----------------------------------------\n\nTITLE: TODO: Compute hue composition (Hellwig2022)\nDESCRIPTION: This task involves implementing hue composition calculation within the `colour/appearance/hellwig2022.py` file. This is a component of the Hellwig2022 appearance model.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Compute hue composition.\n```\n\n----------------------------------------\n\nTITLE: TODO: Remove NumPy issue workaround\nDESCRIPTION: This task involves removing a workaround in `colour/utilities/array.py` that addresses a specific NumPy issue (https://github.com/numpy/numpy/issues/5718) once that issue is resolved in NumPy.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_26\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Remove when https://github.com/numpy/numpy/issues/5718 is addressed.\n```\n\n----------------------------------------\n\nTITLE: Example Output of Colour Calculation without Scipy\nDESCRIPTION: This text snippet shows example output from running a Colour calculation after mocking Scipy.  The calculation converts xyY chromaticity coordinates to XYZ tristimulus values. The example demonstrates that some parts of Colour library are still functional even without full Scipy installation.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/advanced.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\narray([ 0.11518475,  0.1008    ,  0.05089373])\n```\n\n----------------------------------------\n\nTITLE: TODO: Investigate RGB derivation ndarray return\nDESCRIPTION: This task suggests investigating whether the RGB derivation functions in `colour/models/rgb/derivation.py` should return an ndarray (NumPy array) with primaries and the whitepoint stacked together. This could affect the structure of the output data.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Investigate if we return an ndarray here with primaries and whitepoint stacked together.\n```\n\n----------------------------------------\n\nTITLE: TODO: Reinstate CTL coverage\nDESCRIPTION: This task involves reinstating code coverage for the CTL module (`colour/io/ctl.py`) once the \"ctlrender\" tool is trivially available across different platforms.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Reinstate coverage when \"ctlrender\" is trivially available cross-platform.\n```\n\n----------------------------------------\n\nTITLE: XYZ to Hellwig2022 Conversion Output\nDESCRIPTION: This is the output of the XYZ to Hellwig2022 conversion.  It returns a `CAM_Specification_Hellwig2022` object containing the computed parameters.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_20\n\nLANGUAGE: Text\nCODE:\n```\nCAM_Specification_Hellwig2022(J=33.880368498111686, C=37.579419116276348, h=19.510887327451748, s=109.33343382561695, Q=45.34489577734751, M=49.577131618021212, H=399.52975599115319, HC=None, J_HK=39.41741758094139, Q_HK=52.755585941150315)\n```\n\n----------------------------------------\n\nTITLE: TODO: Compute hue composition (CIECAM02)\nDESCRIPTION: This task involves implementing hue composition calculation within the `colour/appearance/ciecam02.py` file. This is a component of the CIECAM02 appearance model.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Compute hue composition.\n```\n\n----------------------------------------\n\nTITLE: TODO: Revisit interpolator application on non-uniform x\nDESCRIPTION: This task suggests revisiting whether the interpolator can be applied on a non-uniform \"x\" independent variable in `colour/algebra/tests/test_interpolation.py`. This would involve assessing the interpolator's capabilities and limitations with non-uniformly spaced data points.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_39\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Revisit if the interpolator can be applied on non-uniform \"x\" independent variable.\n```\n\n----------------------------------------\n\nTITLE: TODO: Remove legacy printing support\nDESCRIPTION: This task involves removing legacy printing support within the `colour/__init__.py` file. It suggests that the current printing implementation might be outdated and should be replaced or removed.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Remove legacy printing support when deemed appropriate.\n```\n\n----------------------------------------\n\nTITLE: TODO: Compute hue composition (CAM16)\nDESCRIPTION: This task involves implementing hue composition calculation within the `colour/appearance/cam16.py` file. This is a component of the CAM16 appearance model.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Compute hue composition.\n```\n\n----------------------------------------\n\nTITLE: TODO: Investigate Eigen value sensitivity on ARM\nDESCRIPTION: This task involves investigating why the last eigen value in `colour/recovery/tests/test_jiang2013.py` seems to be very sensitive and produce differences on ARM architectures.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Last eigen value seems to be very sensitive and produce differences on ARM.\n```\n\n----------------------------------------\n\nTITLE: Output of CCT Computation (Text)\nDESCRIPTION: Displays the output of the correlated color temperature (CCT) computation. The array shows the CCT value (approximately 6507.47) and a Duv value (approximately 0.0032).\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_61\n\nLANGUAGE: text\nCODE:\n```\narray([  6.50747479e+03,   3.22334634e-03])\n```\n\n----------------------------------------\n\nTITLE: TODO: Support fractional spectrum interval\nDESCRIPTION: This task suggests adding support for fractional intervals, such as 0.1, when defining spectra in `colour/colorimetry/spectrum.py`. Currently, the interval might be limited to integer values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Provide support for fractional interval like 0.1, etc...\n```\n\n----------------------------------------\n\nTITLE: Plot Visible Spectrum Section in Python\nDESCRIPTION: This snippet plots a section of the visible spectrum with specified colours and opacity. It demonstrates the library's ability to visualize spectral data with custom styling.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_130\n\nLANGUAGE: python\nCODE:\n```\nplot_visible_spectrum_section(section_colours=\"RGB\", section_opacity=0.15)\n```\n\n----------------------------------------\n\nTITLE: TODO: Implement hue quadrature & composition (Hunt)\nDESCRIPTION: This task suggests implementing hue quadrature and composition calculations in `colour/appearance/hunt.py` as part of the Hunt appearance model.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Implement hue quadrature & composition computation.\n```\n\n----------------------------------------\n\nTITLE: Define RGB Camera Sensitivities (Text)\nDESCRIPTION: Defines RGB camera sensitivities using numerical values. The code defines a matrix with wavelength values and corresponding sensitivity values for red, green, and blue channels, using SpragueInterpolator for interpolation, Extrapolator for extrapolation and defines the method to be constant.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/index.rst#_snippet_59\n\nLANGUAGE: text\nCODE:\n```\nRGB_CameraSensitivities([[  4.00000000e+02,   7.04378461e-03,   9.21260449e-03,\n                               -7.64080878e-03],\n                             [  4.10000000e+02,  -8.76715607e-03,   1.12726694e-02,\n                                6.37434190e-03],\n                             [  4.20000000e+02,   4.58126856e-02,   7.18000418e-02,\n                                4.00001696e-01],\n                             ...\n                             [  6.80000000e+02,   4.00195568e-02,   5.55512389e-03,\n                                1.36794925e-03],\n                             [  6.90000000e+02,  -4.32240535e-03,   2.49731193e-03,\n                                3.80303275e-04],\n                             [  7.00000000e+02,  -6.00395414e-03,   1.54678227e-03,\n                                5.40394352e-04]],\n                            ['red', 'green', 'blue'],\n                            SpragueInterpolator,\n                            {},\n                            Extrapolator,\n                            {'method': 'Constant', 'left': None, 'right': None})\n```\n\n----------------------------------------\n\nTITLE: Setting Safe Division Mode and Calculating UCS to uv\nDESCRIPTION: This snippet sets the safe division mode to \"Numpy\" and then calculates UCS to uv coordinates with a zero vector.  This triggers a NumPy runtime warning because of the division by zero which \"Numpy\" mode allows.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/basics.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ncolour.algebra.set_sdiv_mode(\"Numpy\")\ncolour.UCS_to_uv([0, 0, 0])\n```\n\n----------------------------------------\n\nTITLE: Sprague Interpolation in Python\nDESCRIPTION: This code demonstrates Sprague interpolation using `colour.SpragueInterpolator`. It is similar to the Kernel interpolation but uses the Sprague method.\nSOURCE: https://github.com/colour-science/colour/blob/develop/README.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ny = [5.9200, 9.3700, 10.8135, 4.5100, 69.5900, 27.8007, 86.0500]\nx = range(len(y))\ncolour.SpragueInterpolator(x, y)([0.25, 0.75, 5.50])\n```\n\n----------------------------------------\n\nTITLE: Configuring Colour Environment Variables via JSON\nDESCRIPTION: This JSON snippet shows how to configure Colour environment variables using a JSON file (``~/.colour-science/colour-science.jenv``). It specifies settings such as enabling traceback for warnings by setting the `COLOUR_SCIENCE__COLOUR__SHOW_WARNINGS_WITH_TRACEBACK` variable to \"True\". The file is read by Colour to customize its runtime behavior.  It's a mapping of environment variable names to string values.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/advanced.rst#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"COLOUR_SCIENCE__COLOUR__SHOW_WARNINGS_WITH_TRACEBACK\": \"True\"\n}\n```\n\n----------------------------------------\n\nTITLE: TODO: Remove OCIO test limitation\nDESCRIPTION: This task suggests removing a test limitation in `colour/io/tests/test_ocio.py` when a \"Pypi\" wheel compatible with \"ARM\" on \"macOS\" is released. This indicates a temporary workaround for a platform-specific issue.\nSOURCE: https://github.com/colour-science/colour/blob/develop/TODO.rst#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\n# TODO: Remove when \"Pypi\" wheel compatible with \"ARM\" on \"macOS\" is released.\n```\n\n----------------------------------------\n\nTITLE: Printing Default Spectral Shape in Python\nDESCRIPTION: This snippet demonstrates how to print the default spectral shape used by the `colour` library using `colour.SPECTRAL_SHAPE_DEFAULT`. It shows the default start, end, and interval values for spectral data.\nSOURCE: https://github.com/colour-science/colour/blob/develop/docs/tutorial.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(repr(colour.SPECTRAL_SHAPE_DEFAULT))\n```"
  }
]