[
  {
    "owner": "pterm",
    "repo": "pterm",
    "content": "TITLE: Installing PTerm CLI Framework - Shell\nDESCRIPTION: Shows the shell command required to add the PTerm package to a Go module-enabled project. It ensures the PTerm library is available for import and use within Go CLI applications. No additional dependencies are required beyond having a Go environment with module support enabled.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo get github.com/pterm/pterm\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple Live Spinners and Progress Bars with Pterm MultiPrinter in Go\nDESCRIPTION: This Go code snippet demonstrates initializing and managing multiple concurrent live terminal elements using `pterm.DefaultMultiPrinter`. It creates two spinners and five progress bars, each with its own writer obtained from the multi-printer. The program then starts the multi-printer, simulates updates to the elements within a loop (incrementing progress bars and changing spinner states based on iteration count), and finally stops the multi-printer. It depends on the `time` and `github.com/pterm/pterm` packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/multiple-live-printers/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer for managing multiple printers\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create two spinners with their own writers\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create five progress bars with their own writers and a total of 100\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Increment progress bars and spinners based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment progress bar 1 every iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 to progress bar 2 every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment progress bar 3 every 5th iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment progress bar 4 every 10th iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment progress bar 5 every 3rd iteration\n\t\t}\n\n\t\tif i%50 == 0 {\n\t\t\tspinner1.Success(\"Spinner 1 is done!\") // Mark spinner 1 as successful every 50th iteration\n\t\t}\n\n\t\tif i%60 == 0 {\n\t\t\tspinner2.Fail(\"Spinner 2 failed!\") // Mark spinner 2 as failed every 60th iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Sleep for 50 milliseconds between each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Prefixed Log Messages with PTerm in Go\nDESCRIPTION: This Go snippet uses the PTerm library to print various levels of log messages, including debug, info, success, warning, error, and fatal messages. It first enables debug messages globally and demonstrates printing messages with corresponding prefixes. The snippet also shows how to include source line numbers in logs and how to temporarily disable program termination on fatal messages for safer CI runs. Dependencies include the github.com/pterm/pterm package. Inputs are string messages, and outputs are formatted console prints with appropriate prefixes and optional line numbers.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/prefix/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Enable debug messages in PTerm.\n\tpterm.EnableDebugMessages()\n\n\t// Print a debug message with PTerm.\n\tpterm.Debug.Println(\"Hello, World!\")\n\n\t// Print an informational message with PTerm.\n\tpterm.Info.Println(\"Hello, World!\")\n\n\t// Print a success message with PTerm.\n\tpterm.Success.Println(\"Hello, World!\")\n\n\t// Print a warning message with PTerm.\n\tpterm.Warning.Println(\"Hello, World!\")\n\n\t// Print an error message with PTerm. This will also display the filename and line number in the terminal.\n\tpterm.Error.Println(\"Errors show the filename and linenumber inside the terminal!\")\n\n\t// Print an informational message with PTerm, with line number.\n\t// This demonstrates that other PrefixPrinters can also display line numbers.\n\tpterm.Info.WithShowLineNumber().Println(\"Other PrefixPrinters can do that too!\")\n\n\t// Temporarily set Fatal to false, so that the CI won't crash.\n\t// This will print a fatal message with PTerm, but won't terminate the program.\n\tpterm.Fatal.WithFatal(false).Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring a PTerm-based slog Logger in Go\nDESCRIPTION: This snippet demonstrates setting up a custom slog handler using the PTerm library, creating a new slog logger with it, and initially logging a debug message that is suppressed by default. It then shows changing the log level to debug to enable debug messages and logging different message types including info, warning, and error. Dependencies include the 'github.com/pterm/pterm' package and Go's 'log/slog'.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/slog/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log/slog\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a new slog handler with the default PTerm logger\n\thandler := pterm.NewSlogHandler(&pterm.DefaultLogger)\n\n\t// Create a new slog logger with the handler\n\tlogger := slog.New(handler)\n\n\t// Log a debug message (won't show by default)\n\tlogger.Debug(\"This is a debug message that won't show\")\n\n\t// Change the log level to debug to enable debug messages\n\tpterm.DefaultLogger.Level = pterm.LogLevelDebug\n\n\t// Log a debug message (will show because debug level is enabled)\n\tlogger.Debug(\"This is a debug message\", \"changedLevel\", true)\n\n\t// Log an info message\n\tlogger.Info(\"This is an info message\")\n\n\t// Log a warning message\n\tlogger.Warn(\"This is a warning message\")\n\n\t// Log an error message\n\tlogger.Error(\"This is an error message\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Managing Concurrent Spinners and Progress Bars with PTerm in Go\nDESCRIPTION: This Go snippet demonstrates how to use the PTerm library to manage multiple concurrent spinners and progress bars through a multi-printer. It initializes two spinners and five progress bars, each with their own output writers, and updates them asynchronously in a loop, simulating task progress and status. Dependencies: github.com/pterm/pterm. All printers are started and stopped using the multi-printer instance, and various increment conditions illustrate independent live updates. No external parameters are required; designed to be run as a standalone demo.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_51\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer for managing multiple printers\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create two spinners with their own writers\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create five progress bars with their own writers and a total of 100\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Increment progress bars and spinners based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment progress bar 1 every iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 to progress bar 2 every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment progress bar 3 every 5th iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment progress bar 4 every 10th iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment progress bar 5 every 3rd iteration\n\t\t}\n\n\t\tif i%50 == 0 {\n\t\t\tspinner1.Success(\"Spinner 1 is done!\") // Mark spinner 1 as successful every 50th iteration\n\t\t}\n\n\t\tif i%60 == 0 {\n\t\t\tspinner2.Fail(\"Spinner 2 failed!\") // Mark spinner 2 as failed every 60th iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Sleep for 50 milliseconds between each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PTerm Features in Go Demo Application\nDESCRIPTION: This primary snippet is an entire Go program designed to sequentially demonstrate features of the PTerm library. It includes setup routines, flag parsing for speed or intro skipping, and showcases for structured logging, progress bars, spinners, live updating areas, table rendering, truecolor/RGB features, customization of boxes and area printers, as well as theming support. The program requires PTerm, PTerm putils, and Go standard library packages for execution. Input parameters include the 'speedup' and 'skip-intro' flags; the functions expect no additional inputs. The output consists of formatted CLI demonstrations. Limitations include being tied to the PTerm library and a terminal environment.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_34\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"flag\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\n// Speed the demo up, by setting this flag.\n// Usefull for debugging.\n// Example:\n//\n//\tgo run main.go -speedup\nvar speedup = flag.Bool(\"speedup\", false, \"Speed up the demo\")\nvar skipIntro = flag.Bool(\"skip-intro\", false, \"Skips the intro\")\nvar second = time.Second\n\nvar pseudoProgramList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\tsetup() // Setup the demo (flags etc.)\n\n\t// Show intro\n\tif !*skipIntro {\n\t\tintroScreen()\n\t\tclear()\n\t}\n\n\tshowcase(\"Structured Logging\", 5, func() {\n\t\tlogger := pterm.DefaultLogger.\n\t\t\tWithLevel(pterm.LogLevelTrace)\n\n\t\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t\ttime.Sleep(time.Second * 3)\n\n\t\tinterstingStuff := map[string]any{\n\t\t\t\"when were crayons invented\":  \"1903\",\n\t\t\t\"what is the meaning of life\": 42,\n\t\t\t\"is this interesting\":         true,\n\t\t}\n\t\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\t\ttime.Sleep(time.Second * 3)\n\n\t\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\t})\n\n\tshowcase(\"Progress bar\", 2, func() {\n\t\tpb, _ := pterm.DefaultProgressbar.WithTotal(len(pseudoProgramList)).WithTitle(\"Installing stuff\").Start()\n\t\tfor i := 0; i < pb.Total; i++ {\n\t\t\tpb.UpdateTitle(\"Installing \" + pseudoProgramList[i])\n\t\t\tif pseudoProgramList[i] == \"pseudo-minecraft\" {\n\t\t\t\tpterm.Warning.Println(\"Could not install pseudo-minecraft\\nThe company policy forbids games.\")\n\t\t\t} else {\n\t\t\t\tpterm.Success.Println(\"Installing \" + pseudoProgramList[i])\n\t\t\t}\n\t\t\tpb.Increment()\n\t\t\ttime.Sleep(second / 2)\n\t\t}\n\t\tpb.Stop()\n\t})\n\n\tshowcase(\"Spinner\", 2, func() {\n\t\tlist := pseudoProgramList[7:]\n\t\tspinner, _ := pterm.DefaultSpinner.Start(\"Installing stuff\")\n\t\tfor i := 0; i < len(list); i++ {\n\t\t\tspinner.UpdateText(\"Installing \" + list[i])\n\t\t\tif list[i] == \"pseudo-minecraft\" {\n\t\t\t\tpterm.Warning.Println(\"Could not install pseudo-minecraft\\nThe company policy forbids games.\")\n\t\t\t} else {\n\t\t\t\tpterm.Success.Println(\"Installing \" + list[i])\n\t\t\t}\n\t\t\ttime.Sleep(second)\n\t\t}\n\t\tspinner.Success()\n\t})\n\n\tshowcase(\"Live Output\", 2, func() {\n\t\tpterm.Info.Println(\"You can use an Area to display changing output:\")\n\t\tpterm.Println()\n\t\tarea, _ := pterm.DefaultArea.WithCenter().Start() // Start the Area printer, with the Center option.\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender() // Save current time in str.\n\t\t\tarea.Update(str)                                                                                              // Update Area contents.\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t\tarea.Stop()\n\t})\n\n\tshowcase(\"Tables\", 4, func() {\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\ttd := [][]string{\n\t\t\t{\"Library\", \"Description\"},\n\t\t\t{\"PTerm\", \"Make beautiful CLIs\"},\n\t\t\t{\"Testza\", \"Programmer friendly test framework\"},\n\t\t\t{\"Cursor\", \"Move the cursor around the terminal\"},\n\t\t}\n\t\ttable, _ := pterm.DefaultTable.WithHasHeader().WithData(td).Srender()\n\t\tboxedTable, _ := pterm.DefaultTable.WithHasHeader().WithData(td).WithBoxed().Srender()\n\t\tpterm.DefaultCenter.Println(table)\n\t\tpterm.DefaultCenter.Println(boxedTable)\n\t})\n\n\tshowcase(\"TrueColor Support\", 7, func() {\n\t\tfrom := pterm.NewRGB(0, 255, 255) // This RGB value is used as the gradients start point.\n\t\tto := pterm.NewRGB(255, 0, 255)   // This RGB value is used as the gradients first point.\n\n\t\tstr := \"If your terminal has TrueColor support, you can use RGB colors!\\nYou can even fade them :)\\n\\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\"\n\t\tstrs := strings.Split(str, \"\")\n\t\tvar fadeInfo string // String which will be used to print info.\n\t\t// For loop over the range of the string length.\n\t\tfor i := 0; i < len(str); i++ {\n\t\t\t// Append faded letter to info string.\n\t\t\tfadeInfo += from.Fade(0, float32(len(str)), float32(i), to).Sprint(strs[i])\n\t\t}\n\t\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(fadeInfo)\n\t})\n\n\tshowcase(\"Fully Customizable\", 2, func() {\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\ttext := \"All printers are fully customizable!\"\n\t\tarea := pterm.DefaultArea.WithCenter()\n\t\tarea.Update(pterm.DefaultBox.Sprintln(text))\n\t\ttime.Sleep(second)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopLeft().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopCenter().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopRight().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomRight().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomCenter().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomLeft().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgCyan)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgRed)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgGreen)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).\n\t\t\tWithBottomPadding(1).\n\t\t\tWithLeftPadding(1).\n\t\t\tWithRightPadding(1).\n\t\t\tWithHorizontalString(\"═\").\n\t\t\tWithVerticalString(\"║\").\n\t\t\tWithBottomLeftCornerString(\"╗\").\n\t\t\tWithBottomRightCornerString(\"╔\").\n\t\t\tWithTopLeftCornerString(\"╝\").\n\t\t\tWithTopRightCornerString(\"╚\").\n\t\t\tSprintln(text))\n\t\tarea.Stop()\n\t})\n\n\tshowcase(\"Themes\", 2, func() {\n\t\tpterm.Info.Println(\"You can change the color theme of PTerm easily to fit your needs!\\nThis is the default one:\")\n\t\ttime.Sleep(second / 2)\n\t\t// Print every value of the default theme with its own style.\n\t\tv := reflect.ValueOf(pterm.ThemeDefault)\n\t\ttypeOfS := v.Type()\n\n\t\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\t\tif ok {\n\t\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t\t}\n\t\t}\n\t})\n\n\tshowcase(\"And much more!\", 3, func() {\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\tbox := pterm.DefaultBox.\n\t\t\tWithBottomPadding(1).\n\t\t\tWithTopPadding(1).\n\t\t\tWithLeftPadding(3).\n\t\t\tWithRightPadding(3).\n\t\t\tSprintf(\"Have fun exploring %s!\", pterm.Cyan(\"PTerm\"))\n\t\tpterm.DefaultCenter.Println(box)\n\t})\n}\n\nfunc setup() {\n\tflag.Parse()\n\tif *speedup {\n\t\tsecond = time.Millisecond * 200\n\t}\n}\n\nfunc introScreen() {\n\tptermLogo, _ := pterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.NewStyle(pterm.FgLightCyan)),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.NewStyle(pterm.FgLightMagenta))).\n\t\tSrender()\n\n\tpterm.DefaultCenter.Print(ptermLogo)\n\n\tpterm.DefaultCenter.Print(pterm.DefaultHeader.WithFullWidth().WithBackgroundStyle(pterm.NewStyle(pterm.BgLightBlue)).WithMargin(10).Sprint(\"PTDP - PTerm Demo Program\"))\n\n\tpterm.Info.Println(\"This animation was generated with the latest version of PTerm!\" +\n\t\t\"\\nPTerm works on nearly every terminal and operating system.\" +\n\t\t\"\\nIt's super easy to use!\" +\n\t\t\"\\nIf you want, you can customize everything :)\" +\n\t\t\"\\nYou can see the code of this demo in the \" + pterm.LightMagenta(\"./_examples/demo\") + \" directory.\" +\n```\n\n----------------------------------------\n\nTITLE: Logging with PTerm: Demo Flow (Go)\nDESCRIPTION: Demonstrates a complete logging flow using `pterm.DefaultLogger` with various log levels (Trace, Debug, Info, Warn, Error, Fatal). It shows how to add arguments using `logger.Args` and `logger.ArgsFromMap` and includes pauses to simulate real-world execution pacing. Notes that PTerm automatically wraps long log messages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with trace level\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace level message\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Define a map with interesting stuff\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a warning level message\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an error level message\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message with a long text that will be automatically wrapped\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a fatal level message\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n// Function to pause the execution for 3 seconds\nfunc sleep() {\n\ttime.Sleep(time.Second * 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Spinners Simultaneously with PTerm Multi Printer in Go\nDESCRIPTION: This code demonstrates the creation of multiple concurrent spinners managed through a PTerm MultiPrinter, allowing simultaneous display and independent control of each spinner. It shows how to initialize, start, update, and stop multiple spinners with success, failure, and warning statuses, highlighting concurrent terminal animations.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/spinner/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer for concurrent spinners.\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create and start spinner 1 with a dedicated writer.\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\n\t// Create and start spinner 2 with a dedicated writer.\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create and start spinner 3 with a dedicated writer.\n\tspinner3, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 3\")\n\n\t// Start the multi printer to display all spinners.\n\tmulti.Start()\n\n\ttime.Sleep(time.Millisecond * 1000) // Wait 1 second.\n\n\t// Mark spinner 1 as successful.\n\tspinner1.Success(\"Spinner 1 is done!\")\n\n\ttime.Sleep(time.Millisecond * 750) // Wait 750ms.\n\n\t// Mark spinner 2 as failed.\n\tspinner2.Fail(\"Spinner 2 failed!\")\n\n\ttime.Sleep(time.Millisecond * 500) // Wait 500ms.\n\n\t// Mark spinner 3 with a warning.\n\tspinner3.Warning(\"Spinner 3 has a warning!\")\n\n\t// Stop the multi printer, ending all spinners.\n\tmulti.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Different Logging Levels with PTerm Logger\nDESCRIPTION: Shows a comprehensive demo of PTerm's logger functionality with various logging levels. The example creates a logger with trace level and demonstrates trace, debug, info, warn, error, and fatal logging with arguments and automatic text wrapping.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_46\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with trace level\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace level message\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Define a map with interesting stuff\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a warning level message\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an error level message\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message with a long text that will be automatically wrapped\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a fatal level message\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n// Function to pause the execution for 3 seconds\nfunc sleep() {\n\ttime.Sleep(time.Second * 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing a Single Spinner with Status Updates in Go using PTerm\nDESCRIPTION: This snippet demonstrates how to initialize multiple spinners with different statuses (info, success, warning, fail), update spinner messages dynamically, and customize the appearance of the spinner's prefix in Go using PTerm. It highlights handling spinner lifecycle events and modifying spinner properties during execution.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/spinner/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create and start a fork of the default spinner.\n\tspinnerInfo, _ := pterm.DefaultSpinner.Start(\"Some informational action...\")\n\ttime.Sleep(time.Second * 2) // Simulate 2 seconds of processing.\n\tspinnerInfo.Info()          // Resolve spinner with information message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerSuccess, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will succeed)\")\n\ttime.Sleep(time.Second * 2) // Simulate 2 seconds of processing.\n\tspinnerSuccess.Success()    // Resolve spinner with success message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerWarning, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will warn)\")\n\ttime.Sleep(time.Second * 2) // Simulate 2 seconds of processing.\n\tspinnerWarning.Warning()    // Resolve spinner with warning message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerFail, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will fail)\")\n\ttime.Sleep(time.Second * 2) // Simulate 2 seconds of processing.\n\tspinnerFail.Fail()          // Resolve spinner with error message.\n\n\t// Create and start a spinner with custom info printer for no change.\n\tspinnerNochange, _ := pterm.DefaultSpinner.Start(\"Checking something important... (will result in no change)\")\n\t// Replace the InfoPrinter with a custom \"NOCHG\" one\n\tspinnerNochange.InfoPrinter = &pterm.PrefixPrinter{\n\t\tMessageStyle: &pterm.Style{pterm.FgLightBlue},\n\t\tPrefix: pterm.Prefix{\n\t\t\tStyle: &pterm.Style{pterm.FgBlack, pterm.BgLightBlue},\n\t\t\tText:  \" NOCHG \",\n\t\t},\n\t}\n\ttime.Sleep(time.Second * 2)                     // Simulate 2 seconds of processing.\n\tspinnerNochange.Info(\"No change were required\") // Resolve spinner with message.\n\n\t// Create and start a spinner that updates text dynamically.\n\tspinnerLiveText, _ := pterm.DefaultSpinner.Start(\"Doing a lot of stuff...\")\n\ttime.Sleep(time.Second)                         // 1 second delay.\n\tspinnerLiveText.UpdateText(\"It's really much\")   // Update spinner text.\n\ttime.Sleep(time.Second)                         // 1 second delay.\n\tspinnerLiveText.UpdateText(\"We're nearly done!\") // Update spinner text.\n\ttime.Sleep(time.Second)                         // 1 second delay.\n\tspinnerLiveText.Success(\"Finally!\")             // Resolve with success message.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Password Input with Masked Characters in Go using PTerm\nDESCRIPTION: Demonstrates how to create an interactive text input with masked characters for password input. The example creates a password prompt, collects user input with a mask, and logs the received input (for demonstration purposes only).\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_45\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create an interactive text input with a mask for password input\n\tpasswordInput := pterm.DefaultInteractiveTextInput.WithMask(\"*\")\n\n\t// Show the password input prompt and store the result\n\tresult, _ := passwordInput.Show(\"Enter your password\")\n\n\t// Get the default logger from PTerm\n\tlogger := pterm.DefaultLogger\n\n\t// Log the received password (masked)\n\t// Note: In a real-world application, you should never log passwords\n\tlogger.Info(\"Password received\", logger.Args(\"password\", result))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating masked password input with PTerm in Go\nDESCRIPTION: Demonstrates how to use PTerm to create an interactive text input with input masking for password entry. The input field masks user-typed characters with a specified mask symbol (e.g., '*'). The example displays the prompt, captures the masked input, and logs it using PTerm's default logger. It requires the github.com/pterm/pterm package and uses WithMask for masking input.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create an interactive text input with a mask for password input\n\tpasswordInput := pterm.DefaultInteractiveTextInput.WithMask(\"*\")\n\n\t// Show the password input prompt and store the result\n\tresult, _ := passwordInput.Show(\"Enter your password\")\n\n\t// Get the default logger from PTerm\n\tlogger := pterm.DefaultLogger\n\n\t// Log the received password (masked)\n\t// Note: In a real-world application, you should never log passwords\n\tlogger.Info(\"Password received\", logger.Args(\"password\", result))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Various Pterm Spinner Features in Go\nDESCRIPTION: This Go code demonstrates using the `pterm` library to display spinners for background tasks. It shows how to start a default spinner using `pterm.DefaultSpinner.Start()`, simulate work with `time.Sleep()`, and resolve it with different statuses (`Info()`, `Success()`, `Warning()`, `Fail()`). Additionally, it illustrates customizing the info message prefix by modifying `InfoPrinter` and updating the spinner's text dynamically during execution using `UpdateText()`. Requires the `github.com/pterm/pterm` package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/spinner/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create and start a fork of the default spinner.\n\tspinnerInfo, _ := pterm.DefaultSpinner.Start(\"Some informational action...\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerInfo.Info()          // Resolve spinner with information message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerSuccess, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will succeed)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerSuccess.Success()    // Resolve spinner with success message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerWarning, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will warn)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerWarning.Warning()    // Resolve spinner with warning message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerFail, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will fail)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerFail.Fail()          // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerNochange, _ := pterm.DefaultSpinner.Start(\"Checking something important... (will result in no change)\")\n\t// Replace the InfoPrinter with a custom \"NOCHG\" one\n\tspinnerNochange.InfoPrinter = &pterm.PrefixPrinter{\n\t\tMessageStyle: &pterm.Style{pterm.FgLightBlue},\n\t\tPrefix: pterm.Prefix{\n\t\t\tStyle: &pterm.Style{pterm.FgBlack, pterm.BgLightBlue},\n\t\t\tText:  \" NOCHG \",\n\t\t},\n\t}\n\ttime.Sleep(time.Second * 2)                     // Simulate 3 seconds of processing something.\n\tspinnerNochange.Info(\"No change were required\") // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerLiveText, _ := pterm.DefaultSpinner.Start(\"Doing a lot of stuff...\")\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"It's really much\")   // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"We're nearly done!\") // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.Success(\"Finally!\")              // Resolve spinner with success message.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Outputting Prefixed Log Messages with PTerm in Go\nDESCRIPTION: This Go code demonstrates emitting log messages with various prefixes—debug, info, success, warning, error, and fatal—using PTerm's PrefixPrinters. It includes enabling debug messages, printing messages with and without line numbers, and demonstrates terminal features like displaying filename and line number for errors. Dependencies: github.com/pterm/pterm. Fatal is temporarily made non-fatal to prevent process exit, useful for CI runs. Parameters are mainly the log message text; all output is terminal-based.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_55\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Enable debug messages in PTerm.\n\tpterm.EnableDebugMessages()\n\n\t// Print a debug message with PTerm.\n\tpterm.Debug.Println(\"Hello, World!\")\n\n\t// Print an informational message with PTerm.\n\tpterm.Info.Println(\"Hello, World!\")\n\n\t// Print a success message with PTerm.\n\tpterm.Success.Println(\"Hello, World!\")\n\n\t// Print a warning message with PTerm.\n\tpterm.Warning.Println(\"Hello, World!\")\n\n\t// Print an error message with PTerm. This will also display the filename and line number in the terminal.\n\tpterm.Error.Println(\"Errors show the filename and linenumber inside the terminal!\")\n\n\t// Print an informational message with PTerm, with line number.\n\t// This demonstrates that other PrefixPrinters can also display line numbers.\n\tpterm.Info.WithShowLineNumber().Println(\"Other PrefixPrinters can do that too!\")\n\n\t// Temporarily set Fatal to false, so that the CI won't crash.\n\t// This will print a fatal message with PTerm, but won't terminate the program.\n\tpterm.Fatal.WithFatal(false).Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Managing multiple progress bars concurrently with pterm in Go\nDESCRIPTION: This code creates five independent progress bars with a total of 100 units each, managed through a multi printer for concurrent terminal display. Each progress bar advances based on different conditions in a loop, demonstrating simultaneous progress updates and control flow. It showcases pterm's multi printer and progress bar features for multi-task visualizations. Dependencies include pterm library and standard time package. Inputs are progress increments, and outputs are multi-progress bars displayed and updated in real-time.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/progressbar/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer instance from the default one\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create five progress bars with a total of 100 units each, and assign each a new writer from the multi printer\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Loop to increment progress bars based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment the first progress bar at each iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 units to the second progress bar at every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment the third progress bar at every fifth iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment the fourth progress bar at every tenth iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment the fifth progress bar at every third iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Pause for 50 milliseconds at each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating an Interactive Multiselect with Fuzzy Search in Go\nDESCRIPTION: Demonstrates how to create an interactive multiselect component with PTerm that includes fuzzy searching capability. The example creates 100 basic options plus 5 additional options highlighting the fuzzy search feature.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_multiselect/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options.\n\tvar options []string\n\n\t// Populate the options slice with 100 options.\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Add 5 more options to the slice, indicating the availability of fuzzy searching.\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive multiselect to present the options to the user and capture their selections.\n\t// The Show() method displays the options and waits for user input.\n\tselectedOptions, _ := pterm.DefaultInteractiveMultiselect.WithOptions(options).Show()\n\n\t// Print the selected options, highlighted in green.\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a pterm Logger with Caller Information in Go\nDESCRIPTION: This snippet initializes a pterm logger with Trace level and caller info, then logs messages at various levels with additional contextual arguments. It demonstrates enhancing logs with extra data, including maps, and shows that long logs are auto-wrapped. The fatal log terminates the application.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/with-caller/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and caller information\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithCaller()\n\n\t// Log a trace message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log an info message with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Downloading File with Default Progressbar - PTerm PUtils - Go\nDESCRIPTION: Downloads a file from a URL to a specified output path, displaying progress using a default PTerm progress bar. Returns an error if the download fails.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nfunc DownloadFileWithDefaultProgressbar(title, outputPath, url string, mode os.FileMode) error\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PTerm Logger Levels and Features (Go)\nDESCRIPTION: This Go snippet initializes the default pterm logger, sets its level to Trace, and logs messages at various severity levels (Trace, Debug, Info, Warn, Error, Fatal). It shows how to include structured data in logs using `logger.Args` and `logger.ArgsFromMap` and demonstrates automatic text wrapping for long messages. The `sleep` function is used to pause execution, making the demo flow visible.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with trace level\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace level message\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Define a map with interesting stuff\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a warning level message\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an error level message\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message with a long text that will be automatically wrapped\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a fatal level message\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n// Function to pause the execution for 3 seconds\nfunc sleep() {\n\ttime.Sleep(time.Second * 3)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and updating a progress bar for simulated downloads in Go using pterm\nDESCRIPTION: This snippet initializes a single progress bar with a total count based on a list of fake application names, simulating download operations with delays. It updates the progress bar title dynamically to reflect the current operation and prints success messages for each step. The progress bar advances with each simulated download, demonstrating pterm's progress bar capabilities for sequential task tracking. Dependencies include the pterm library and the Go standard library for strings and time. Inputs include the list of application names; outputs are console updates showing progress and success messages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/progressbar/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\n// Slice of strings representing names of pseudo applications to be downloaded.\nvar fakeInstallList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-dops pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\t// Create a progressbar with the total steps equal to the number of items in fakeInstallList.\n\t// Set the initial title of the progressbar to \"Downloading stuff\".\n\tp, _ := pterm.DefaultProgressbar.WithTotal(len(fakeInstallList)).WithTitle(\"Downloading stuff\").Start()\n\n\t// Loop over each item in the fakeInstallList.\n\tfor i := 0; i < p.Total; i++ {\n\t\t// Simulate a slow download for the 7th item.\n\t\tif i == 6 {\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t}\n\n\t\t// Update the title of the progressbar with the current item being downloaded.\n\t\tp.UpdateTitle(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Print a success message for the current download. This will be printed above the progressbar.\n\t\tpterm.Success.Println(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Increment the progressbar by one to indicate progress.\n\t\tp.Increment()\n\n\t\t// Pause for 350 milliseconds to simulate the time taken for each download.\n\t\ttime.Sleep(time.Millisecond * 350)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing multi-level logging with PTerm in Go\nDESCRIPTION: Shows how to create a logger with trace level and use different logging levels (trace, debug, info, warn, error, fatal). The example also demonstrates automatic text wrapping for long log messages and passing arguments to log entries.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_53\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with trace level\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace level message\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Define a map with interesting stuff\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a warning level message\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an error level message\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log an info level message with a long text that will be automatically wrapped\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 3 seconds\n\tsleep()\n\n\t// Log a fatal level message\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n// Function to pause the execution for 3 seconds\nfunc sleep() {\n\ttime.Sleep(time.Second * 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Go's slog with PTerm for Structured Logging\nDESCRIPTION: Shows how to use Go's structured logging (slog) with PTerm. The example creates a slog handler using PTerm's logger, demonstrates different log levels, and shows how to enable debug logging by changing the logger's level.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_66\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"log/slog\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a new slog handler with the default PTerm logger\n\thandler := pterm.NewSlogHandler(&pterm.DefaultLogger)\n\n\t// Create a new slog logger with the handler\n\tlogger := slog.New(handler)\n\n\t// Log a debug message (won't show by default)\n\tlogger.Debug(\"This is a debug message that won't show\")\n\n\t// Change the log level to debug to enable debug messages\n\tpterm.DefaultLogger.Level = pterm.LogLevelDebug\n\n\t// Log a debug message (will show because debug level is enabled)\n\tlogger.Debug(\"This is a debug message\", \"changedLevel\", true)\n\n\t// Log an info message\n\tlogger.Info(\"This is an info message\")\n\n\t// Log a warning message\n\tlogger.Warn(\"This is a warning message\")\n\n\t// Log an error message\n\tlogger.Error(\"This is an error message\")\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Paragraph Max Width in Go with pterm\nDESCRIPTION: This Go snippet illustrates how to customize the maximum line width for the pterm paragraph printer using `WithMaxWidth()`. It prints a long string wrapped at a maximum of 60 characters per line and compares it to printing the same text using the standard `pterm.Println`. This requires the `github.com/pterm/pterm` package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/paragraph/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a long text to be printed as a paragraph.\n\tlongText := \"This is a custom paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text as a paragraph with a custom maximal width of 60 characters.\n\tpterm.DefaultParagraph.WithMaxWidth(60).Println(longText)\n\n\t// Print a line space to separate the paragraph from the following text.\n\tpterm.Println()\n\n\t// Define another long text to be printed without a paragraph printer.\n\tlongTextWithoutParagraph := \"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text without using a paragraph printer.\n\tpterm.Println(longTextWithoutParagraph)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Masked Password Input with PTerm in Go\nDESCRIPTION: This snippet demonstrates how to create a password input that masks user input with asterisks for security. It uses PTerm's DefaultInteractiveTextInput with a mask character, prompts the user for their password, and logs the received input. This would be useful for CLI applications requiring secure credential entry.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/password/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create an interactive text input with a mask for password input\n\tpasswordInput := pterm.DefaultInteractiveTextInput.WithMask(\"*\")\n\n\t// Show the password input prompt and store the result\n\tresult, _ := passwordInput.Show(\"Enter your password\")\n\n\t// Get the default logger from PTerm\n\tlogger := pterm.DefaultLogger\n\n\t// Log the received password (masked)\n\t// Note: In a real-world application, you should never log passwords\n\tlogger.Info(\"Password received\", logger.Args(\"password\", result))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Multi-Line Interactive Text Input with PTerm in Go\nDESCRIPTION: This snippet demonstrates how to create a multi-line enabled interactive text input using PTerm, collect user input, and display the result. It uses the DefaultInteractiveTextInput with multi-line support to allow users to enter multiple lines of text in a single input session.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/multi-line/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a default interactive text input with multi-line enabled.\n\t// This allows the user to input multiple lines of text.\n\ttextInput := pterm.DefaultInteractiveTextInput.WithMultiLine()\n\n\t// Show the text input to the user and store the result.\n\t// The second return value (an error) is ignored with '_'.\n\tresult, _ := textInput.Show()\n\n\t// Print a blank line for better readability in the output.\n\tpterm.Println()\n\n\t// Print the user's input prefixed with an informational message.\n\t// The '%s' placeholder is replaced with the user's input.\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Basic Text with PTerm in Go\nDESCRIPTION: This code uses PTerm's DefaultBasicText to print plain and colored text in the terminal. It demonstrates simple printing as well as more complex text outputs using the LightMagenta style, suitable for highlighting or segmenting parts of the message. Only PTerm is needed as a dependency. The Println calls are direct and use string concatenation for styling. Input: plain strings or concats with color functions. Output: colored/uncolored terminal text. Great for use in progress indicators or section headings.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_16\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// The DefaultBasicText is a basic text printer provided by PTerm.\n\t// It is used to print text without any special formatting.\n\tpterm.DefaultBasicText.Println(\"Default basic text printer.\")\n\n\t// The DefaultBasicText can be used in any context that requires a TextPrinter.\n\t// Here, we're using it with the LightMagenta function to color a portion of the text.\n\tpterm.DefaultBasicText.Println(\"Can be used in any\" + pterm.LightMagenta(\" TextPrinter \") + \"context.\")\n\n\t// The DefaultBasicText is also useful for resolving progress bars and spinners.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating an Interactive Multiselect Prompt with PTerm in Go\nDESCRIPTION: This Go snippet demonstrates initializing and displaying an interactive multiselect prompt using the pterm library. It first creates a slice of strings containing numerous options, then uses `pterm.DefaultInteractiveMultiselect.WithOptions()` to configure the prompt with these options. Finally, it calls `Show()` to display the interactive prompt to the user and captures the selected options, which are then printed to the console. Requires the `github.com/pterm/pterm` package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_multiselect/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options.\n\tvar options []string\n\n\t// Populate the options slice with 100 options.\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Add 5 more options to the slice, indicating the availability of fuzzy searching.\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive multiselect to present the options to the user and capture their selections.\n\t// The Show() method displays the options and waits for user input.\n\tselectedOptions, _ := pterm.DefaultInteractiveMultiselect.WithOptions(options).Show()\n\n\t// Print the selected options, highlighted in green.\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Interactive Text Input Prompt with PTerm in Go\nDESCRIPTION: This Go code snippet uses the PTerm library to display an interactive, single-line text input prompt in the terminal. It imports the necessary packages, creates the interactive input, and captures the user's response in the variable 'result'. After a blank line for formatting, it prints the entered input with an info-level message. Dependencies include the 'github.com/pterm/pterm' package. The input is a string entered by the user, and the output is the same string shown as a confirmation message. This snippet assumes execution in a terminal environment capable of handling interactive prompts.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Formatted Tables in Go using PTerm\nDESCRIPTION: Demonstrates how to create and render formatted tables with headers using PTerm's Table component. The example shows two tables with different data, including multi-line cells and Unicode characters.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_63\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the first table\n\ttableData1 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData1).Render()\n\n\tpterm.Println() // Blank line\n\n\t// Define the data for the second table\n\ttableData2 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create another table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData2).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Generating and Printing Fading Colors with pterm in Go\nDESCRIPTION: This Go snippet demonstrates how to create a color gradient using pterm's RGB colors and the Fade method. It initializes start (cyan) and end (magenta) colors, determines the terminal height, and then iterates, calculating a fade factor to generate intermediate colors which are used to print lines of text, creating a vertical gradient effect. Requires the `github.com/pterm/pterm` library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/fade-colors/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"RGB colors only work in Terminals which support TrueColor.\")\n\n\t// Define the start and end points for the color gradient.\n\tstartColor := pterm.NewRGB(0, 255, 255) // Cyan\n\tendColor := pterm.NewRGB(255, 0, 255)   // Magenta\n\n\t// Get the terminal height to determine the gradient range.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the range of the terminal height to create a color gradient.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Calculate the fade factor for the current step in the gradient.\n\t\tfadeFactor := float32(i) / float32(terminalHeight-2)\n\n\t\t// Create a color that represents the current step in the gradient.\n\t\tcurrentColor := startColor.Fade(0, 1, fadeFactor, endColor)\n\n\t\t// Print a string with the current color.\n\t\tcurrentColor.Println(\"Hello, World!\")\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Progress Bars in Go using PTerm\nDESCRIPTION: Demonstrates how to create and control multiple progress bars simultaneously using PTerm's MultiPrinter. The example creates five progress bars with different increment patterns and displays them concurrently.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_57\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer instance from the default one\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create five progress bars with a total of 100 units each, and assign each a new writer from the multi printer\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Loop to increment progress bars based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment the first progress bar at each iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 units to the second progress bar at every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment the third progress bar at every fifth iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment the fourth progress bar at every tenth iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment the fifth progress bar at every third iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Pause for 50 milliseconds at each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PTerm Logger with JSON Formatter\nDESCRIPTION: Shows how to use PTerm's logger with a JSON formatter for structured logging output. The example creates a logger with trace level and JSON formatter, then demonstrates various logging levels with arguments.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_49\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and JSON formatter\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithFormatter(pterm.LogFormatterJSON)\n\n\t// Log a Trace level message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a Debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log Info, Warn, Error, and Fatal level messages with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: JSON-formatted logging with PTerm in Go\nDESCRIPTION: Demonstrates how to configure PTerm's logger to output logs in JSON format. The example shows how to create a JSON logger with trace level and log messages at various severity levels with additional structured data.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_56\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and JSON formatter\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithFormatter(pterm.LogFormatterJSON)\n\n\t// Log a Trace level message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a Debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log Info, Warn, Error, and Fatal level messages with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Prefixed Messages with Debug and Error Levels Using PTerm in Go\nDESCRIPTION: Shows how to enable debug messages and print various prefixed message types such as debug, info, success, warning, error, and fatal using the PTerm library. It includes displaying line numbers and disabling fatal termination for CI environments. The primary dependency is the \"github.com/pterm/pterm\" package. Inputs are log messages; outputs are colorized and prefixed terminal prints with optional file location metadata.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_62\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Enable debug messages in PTerm.\n\tpterm.EnableDebugMessages()\n\n\t// Print a debug message with PTerm.\n\tpterm.Debug.Println(\"Hello, World!\")\n\n\t// Print an informational message with PTerm.\n\tpterm.Info.Println(\"Hello, World!\")\n\n\t// Print a success message with PTerm.\n\tpterm.Success.Println(\"Hello, World!\")\n\n\t// Print a warning message with PTerm.\n\tpterm.Warning.Println(\"Hello, World!\")\n\n\t// Print an error message with PTerm. This will also display the filename and line number in the terminal.\n\tpterm.Error.Println(\"Errors show the filename and linenumber inside the terminal!\")\n\n\t// Print an informational message with PTerm, with line number.\n\t// This demonstrates that other PrefixPrinters can also display line numbers.\n\tpterm.Info.WithShowLineNumber().Println(\"Other PrefixPrinters can do that too!\")\n\n\t// Temporarily set Fatal to false, so that the CI won't crash.\n\t// This will print a fatal message with PTerm, but won't terminate the program.\n\tpterm.Fatal.WithFatal(false).Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Custom Checkmarks in Interactive Multiselect with PTerm in Go\nDESCRIPTION: This snippet illustrates customizing the checkmark symbols in a PTerm interactive multiselect prompt. Five options are presented without fuzzy filtering, and checkmarks for selected and unselected options are set to green '+' and red '-' respectively. The selected options are then printed in green. Required dependencies are the github.com/pterm/pterm and fmt packages. Inputs are user selections, output is printed green-colored selections.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_39\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and define the checkmark symbols\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithCheckmark(&pterm.Checkmark{Checked: pterm.Green(\"+\"), Unchecked: pterm.Red(\"-\")})\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Single-Line Interactive Text Input Prompt using PTerm in Go\nDESCRIPTION: This snippet creates and displays a single-line interactive text input prompt using PTerm's DefaultInteractiveTextInput. After user input, the result is printed with info prefix. It depends on github.com/pterm/pterm. The input is freeform user text; the output is the printed captured text.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_42\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Single Line Text Input with PTerm - Go\nDESCRIPTION: Demonstrates single line text input collection in the terminal using PTerm's DefaultInteractiveTextInput and Show(). Suitable for capturing arbitrary string input from users. Requires github.com/pterm/pterm. Outputs the user-entered string. Used where simple text responses are needed in CLI tools.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_49\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Interactive Spinners with Different States in Go using PTerm\nDESCRIPTION: Shows how to create and manage spinners with different resolution states (info, success, warning, fail) and how to update spinner text while it's running. The example demonstrates creating multiple spinners and resolving them with different messages.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_60\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create and start a fork of the default spinner.\n\tspinnerInfo, _ := pterm.DefaultSpinner.Start(\"Some informational action...\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerInfo.Info()          // Resolve spinner with information message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerSuccess, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will succeed)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerSuccess.Success()    // Resolve spinner with success message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerWarning, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will warn)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerWarning.Warning()    // Resolve spinner with warning message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerFail, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will fail)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerFail.Fail()          // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerNochange, _ := pterm.DefaultSpinner.Start(\"Checking something important... (will result in no change)\")\n\t// Replace the InfoPrinter with a custom \"NOCHG\" one\n\tspinnerNochange.InfoPrinter = &pterm.PrefixPrinter{\n\t\tMessageStyle: &pterm.Style{pterm.FgLightBlue},\n\t\tPrefix: pterm.Prefix{\n\t\t\tStyle: &pterm.Style{pterm.FgBlack, pterm.BgLightBlue},\n\t\t\tText:  \" NOCHG \",\n\t\t},\n\t}\n\ttime.Sleep(time.Second * 2)                     // Simulate 3 seconds of processing something.\n\tspinnerNochange.Info(\"No change were required\") // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerLiveText, _ := pterm.DefaultSpinner.Start(\"Doing a lot of stuff...\")\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"It's really much\")   // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"We're nearly done!\") // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.Success(\"Finally!\")              // Resolve spinner with success message.\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Basic Text Using PTerm DefaultBasicText Printer in Go\nDESCRIPTION: This snippet demonstrates the use of the DefaultBasicText printer from the PTerm library to print text without special formatting and with color enhancement on parts of the text in Go. It depends on the \"github.com/pterm/pterm\" package and requires importing it. The snippet shows how to print plain text and how to embed colored text segments using the LightMagenta function. The input is plain strings and colored string returns; the output is printed console text. It is also noted that DefaultBasicText is compatible with contexts requiring a TextPrinter interface and can help in progress bars and spinner rendering.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/basictext/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// The DefaultBasicText is a basic text printer provided by PTerm.\n\t// It is used to print text without any special formatting.\n\tpterm.DefaultBasicText.Println(\"Default basic text printer.\")\n\n\t// The DefaultBasicText can be used in any context that requires a TextPrinter.\n\t// Here, we're using it with the LightMagenta function to color a portion of the text.\n\tpterm.DefaultBasicText.Println(\"Can be used in any\" + pterm.LightMagenta(\" TextPrinter \") + \"context.\")\n\n\t// The DefaultBasicText is also useful for resolving progress bars and spinners.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Including Caller Information in PTerm Logs\nDESCRIPTION: Demonstrates how to enable caller information in PTerm logs to track the source of log messages. The example configures a logger with trace level and caller information, then shows various logging levels with arguments.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_50\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and caller information\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithCaller()\n\n\t// Log a trace message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log an info message with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting PTerm Logs as JSON (Go)\nDESCRIPTION: Shows how to configure `pterm.DefaultLogger` to output logs in JSON format using `WithFormatter(pterm.LogFormatterJSON)`. Includes examples of logging messages at various levels with arguments, demonstrating the resulting structured JSON output instead of the default console format.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and JSON formatter\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithFormatter(pterm.LogFormatterJSON)\n\n\t// Log a Trace level message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a Debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log Info, Warn, Error, and Fatal level messages with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PTerm slog Handler and Logger in Go\nDESCRIPTION: This code demonstrates setting up a custom slog handler using PTerm's default logger, creating a slog.Logger, and performing various log operations. It illustrates how to configure log levels and output different message severities, serving as an example for structured logging with PTerm and slog.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/slog/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log/slog\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a new slog handler with the default PTerm logger\n\thandler := pterm.NewSlogHandler(&pterm.DefaultLogger)\n\n\t// Create a new slog logger with the handler\n\tlogger := slog.New(handler)\n\n\t// Log a debug message (won't show by default)\n\tlogger.Debug(\"This is a debug message that won't show\")\n\n\t// Change the log level to debug to enable debug messages\n\tpterm.DefaultLogger.Level = pterm.LogLevelDebug\n\n\t// Log a debug message (will show because debug level is enabled)\n\tlogger.Debug(\"This is a debug message\", \"changedLevel\", true)\n\n\t// Log an info message\n\tlogger.Info(\"This is an info message\")\n\n\t// Log a warning message\n\tlogger.Warn(\"This is a warning message\")\n\n\t// Log an error message\n\tlogger.Error(\"This is an error message\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering Panels with PTerm in Go\nDESCRIPTION: This code demonstrates how to define and render a 2D grid of text panels using PTerm library. It shows how to create panels with different content types including plain text, styled headers, colored text, and multi-line content. The panels are rendered with a custom padding of 5 units.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/panel/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define panels in a 2D grid system\n\tpanels := pterm.Panels{\n\t\t{\n\t\t\t{Data: \"This is the first panel\"},\n\t\t\t{Data: pterm.DefaultHeader.Sprint(\"Hello, World!\")},\n\t\t\t{Data: \"This\\npanel\\ncontains\\nmultiple\\nlines\"},\n\t\t},\n\t\t{\n\t\t\t{Data: pterm.Red(\"This is another\\npanel line\")},\n\t\t\t{Data: \"This is the second panel\\nwith a new line\"},\n\t\t},\n\t}\n\n\t// Render the panels with a padding of 5\n\t_ = pterm.DefaultPanel.WithPanels(panels).WithPadding(5).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Negative Value Bar Charts using PTerm in Go\nDESCRIPTION: This Go code illustrates the creation of both vertical and horizontal bar charts using the PTerm library, specifically for datasets containing only negative values. It defines an array of bars with labels and negative values, then uses chaining methods (WithBars, WithShowValue, WithHorizontal) and Render to output the charts. Dependencies include the PTerm library (github.com/pterm/pterm). Parameters include the bar label strings and integer values for each bar. The input is a static bar list with negative integers, and the output is a console-rendered bar chart. This example requires Go and the PTerm library, and is intended for console applications; visual or SVG outputs are not covered.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/negative-values/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars with negative values.\n\t// Each bar is represented by a struct with a label and a value.\n\tnegativeBars := pterm.Bars{\n\t\t{Label: \"Bar 1\", Value: -5},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Longer Label\", Value: -7},\n\t}\n\n\t// Print an informational message to the console.\n\tpterm.Info.Println(\"Chart example with negative only values (bars use 100% of chart area)\")\n\n\t// Create a vertical bar chart with the defined bars.\n\t// The WithShowValue() option is used to display the value of each bar in the chart.\n\t// The Render() method is called to draw the chart.\n\t_ = pterm.DefaultBarChart.WithBars(negativeBars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The WithHorizontal() option is used to orient the chart horizontally.\n\t// The WithShowValue() option and Render() method are used in the same way as before.\n\t_ = pterm.DefaultBarChart.WithHorizontal().WithBars(negativeBars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Clearing the terminal screen with ANSI escape codes in Go\nDESCRIPTION: Defines a function to clear the terminal screen by printing ANSI escape sequences that reset the cursor position to the home position and clear the screen buffer. This method is simple and works on most terminals supporting ANSI codes. No external dependencies besides standard Go packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/demo/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nfunc clear() {\n\tprint(\"\\033[H\\033[2J\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Printing Sections with pterm in Go\nDESCRIPTION: This code snippet demonstrates how to create hierarchical sections with different levels using pterm's DefaultSection and print them to the console. It also shows printing informational messages with pterm.Info. The snippet relies on the pterm library and is intended for command-line interface (CLI) output formatting, illustrating basic usage patterns for sections and info messages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/section/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a section with level one and print it.\n\tpterm.DefaultSection.Println(\"This is a section!\")\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"And here is some text.\\nThis text could be anything.\\nBasically it's just a placeholder\")\n\n\t// Create a section with level two and print it.\n\tpterm.DefaultSection.WithLevel(2).Println(\"This is another section!\")\n\n\t// Print another informational message.\n\tpterm.Info.Println(\"And this is\\nmore placeholder text\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Live Printers Using PTerm's MultiPrinter in Go\nDESCRIPTION: This snippet demonstrates how to create and manage multiple live terminal components (spinners and progress bars) simultaneously using PTerm's MultiPrinter. It shows how to initialize different types of printers, associate them with a multi-printer, and update them at different rates based on conditional logic.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/multiple-live-printers/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer for managing multiple printers\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create two spinners with their own writers\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create five progress bars with their own writers and a total of 100\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Increment progress bars and spinners based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment progress bar 1 every iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 to progress bar 2 every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment progress bar 3 every 5th iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment progress bar 4 every 10th iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment progress bar 5 every 3rd iteration\n\t\t}\n\n\t\tif i%50 == 0 {\n\t\t\tspinner1.Success(\"Spinner 1 is done!\") // Mark spinner 1 as successful every 50th iteration\n\t\t}\n\n\t\tif i%60 == 0 {\n\t\t\tspinner2.Fail(\"Spinner 2 failed!\") // Mark spinner 2 as failed every 60th iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Sleep for 50 milliseconds between each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Using PTerm DefaultBasicText to Print Basic and Colored Text in Go\nDESCRIPTION: This code initializes the default basic text printer provided by the PTerm library in Go. It demonstrates printing plain text and colored text using the DefaultBasicText instance. Dependencies include the 'github.com/pterm/pterm' package, and the core functions are Println for output. The code aims to simplify text output in CLI applications, supporting colored formatting and UI components like progress bars.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/basictext/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// The DefaultBasicText is a basic text printer provided by PTerm.\n\t// It is used to print text without any special formatting.\n\tpterm.DefaultBasicText.Println(\"Default basic text printer.\")\n\n\t// The DefaultBasicText can be used in any context that requires a TextPrinter.\n\t// Here, we're using it with the LightMagenta function to color a portion of the text.\n\tpterm.DefaultBasicText.Println(\"Can be used in any\" + pterm.LightMagenta(\" TextPrinter \") + \"context.\")\n\n\t// The DefaultBasicText is also useful for resolving progress bars and spinners.\n}\n```\n\n----------------------------------------\n\nTITLE: Structured Logging with pterm Logger in Go\nDESCRIPTION: Sets up and demonstrates various levels of structured logging using pterm's Logger, including trace, debug, info, warn, and error levels. Each log entry includes associated key-value arguments for structured context. Dependencies include github.com/pterm/pterm.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"flag\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\n// Speed the demo up, by setting this flag.\n// Usefull for debugging.\n// Example:\n//\n// go run main.go -speedup\nvar speedup = flag.Bool(\"speedup\", false, \"Speed up the demo\")\nvar skipIntro = flag.Bool(\"skip-intro\", false, \"Skips the intro\")\nvar second = time.Second\n\nvar pseudoProgramList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \\\n\t\"pseudo-git pseudo-vsc pseudo-in.../* truncated for brevity */\n\nfunc main() {\n\tsetup() // Setup the demo (flags etc.)\n\n\t// Show intro\n\tif !*skipIntro {\n\t\tintroScreen()\n\t\tclear()\n\t}\n\n\tshowcase(\"Structured Logging\", 5, func() {\n\t\tlogger := pterm.DefaultLogger.\n\t\t\tWithLevel(pterm.LogLevelTrace)\n\n\t\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t\ttime.Sleep(time.Second * 3)\n\n\t\tinterstingStuff := map[string]any{\n\t\t\t\"when were crayons invented\":  \"1903\",\n\t\t\t\"what is the meaning of life\": 42,\n\t\t\t\"is this interesting\": true,\n\t\t}\n\t\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\t\ttime.Sleep(time.Second * 3)\n\n\t\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\t})\n\n\t// Additional showcase functions omitted for brevity\n}\n\n```\n\n----------------------------------------\n\nTITLE: Print Default and Full-Width Header using pterm Go\nDESCRIPTION: This snippet demonstrates how to use the default header style provided by the pterm library and how to print a header that spans the full width of the terminal. It serves as a basic introduction to using pterm headers.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_35\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default header.\n\t// This uses the default settings of PTerm to print a header.\n\tpterm.DefaultHeader.Println(\"This is the default header!\")\n\n\t// Print a spacer line for better readability.\n\tpterm.Println()\n\n\t// Print a full-width header.\n\t// This uses the WithFullWidth() option of PTerm to print a header that spans the full width of the terminal.\n\tpterm.DefaultHeader.WithFullWidth().Println(\"This is a full-width header.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Paragraph Output with PTerm in Go\nDESCRIPTION: Demonstrates how to use the PTerm library's DefaultParagraph to print a long block of text as a paragraph with intelligent word-based splitting and custom line width. The snippet requires the github.com/pterm/pterm library to be installed and uses the WithMaxWidth method to specify a line length of 60 characters. It contrasts this formatted output with the default Println method to show the difference in readability when handling long strings.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/paragraph/customized/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a long text to be printed as a paragraph.\n\tlongText := \"This is a custom paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text as a paragraph with a custom maximal width of 60 characters.\n\tpterm.DefaultParagraph.WithMaxWidth(60).Println(longText)\n\n\t// Print a line space to separate the paragraph from the following text.\n\tpterm.Println()\n\n\t// Define another long text to be printed without a paragraph printer.\n\tlongTextWithoutParagraph := \"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text without using a paragraph printer.\n\tpterm.Println(longTextWithoutParagraph)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Boxed Table in Go using PTerm\nDESCRIPTION: Shows how to create a boxed table with headers using the PTerm library. The example defines table data with headers and rows, and displays it with a border around the entire table.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_72\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Live Printers with PTerm in Go\nDESCRIPTION: Demonstrates creating and managing multiple concurrent live printers, including spinners and progress bars, using the PTerm library in Go. The example initializes a multi-printer to handle multiple output streams concurrently, creates two spinners and five progress bars each with their own writers, and updates them based on iteration conditions. Dependencies include the \"github.com/pterm/pterm\" package and the standard \"time\" package for delays. Inputs include iteration count and conditions for incrementing progress bars or marking spinner status. Outputs are dynamic terminal UI components that reflect progress and spinner states until completion.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_58\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer for managing multiple printers\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create two spinners with their own writers\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create five progress bars with their own writers and a total of 100\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Increment progress bars and spinners based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment progress bar 1 every iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 to progress bar 2 every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment progress bar 3 every 5th iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment progress bar 4 every 10th iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment progress bar 5 every 3rd iteration\n\t\t}\n\n\t\tif i%50 == 0 {\n\t\t\tspinner1.Success(\"Spinner 1 is done!\") // Mark spinner 1 as successful every 50th iteration\n\t\t}\n\n\t\tif i%60 == 0 {\n\t\t\tspinner2.Fail(\"Spinner 2 failed!\") // Mark spinner 2 as failed every 60th iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Sleep for 50 milliseconds between each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing and Controlling Pterm Progressbar in Go\nDESCRIPTION: This snippet initializes a Pterm progress bar with a total number of steps corresponding to the length of a predefined list of pseudo-application names. It updates the progress bar's title dynamically to reflect the current item being \"downloaded\". Each iteration simulates varying download duration, including an intentional delay on the seventh item. Success messages print above the progress bar indicating individual download completions. Dependencies include the github.com/pterm/pterm package and standard Go libraries strings and time. Inputs include the fakeInstallList defining the download targets. Outputs are progress bar visual updates and printed success messages in the terminal. This setup is ideal for demonstrating or simulating progress tracking in CLI applications but does not perform actual network operations.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/progressbar/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\n// Slice of strings representing names of pseudo applications to be downloaded.\nvar fakeInstallList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-dops pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\t// Create a progressbar with the total steps equal to the number of items in fakeInstallList.\n\t// Set the initial title of the progressbar to \"Downloading stuff\".\n\tp, _ := pterm.DefaultProgressbar.WithTotal(len(fakeInstallList)).WithTitle(\"Downloading stuff\").Start()\n\n\t// Loop over each item in the fakeInstallList.\n\tfor i := 0; i < p.Total; i++ {\n\t\t// Simulate a slow download for the 7th item.\n\t\tif i == 6 {\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t}\n\n\t\t// Update the title of the progressbar with the current item being downloaded.\n\t\tp.UpdateTitle(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Print a success message for the current download. This will be printed above the progressbar.\n\t\tpterm.Success.Println(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Increment the progressbar by one to indicate progress.\n\t\tp.Increment()\n\n\t\t// Pause for 350 milliseconds to simulate the time taken for each download.\n\t\ttime.Sleep(time.Millisecond * 350)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Select Prompt with Many Options Using PTerm - Go\nDESCRIPTION: Builds an interactive select prompt for choosing a single option from a list of over 100 items (with fuzzy search support), leveraging PTerm's DefaultInteractiveSelect. Demonstrates setting up an option slice and capturing the user's selection for display. Requires github.com/pterm/pterm. Outputs the selected option in green. Appropriate for applications requiring efficient navigation and selection from lengthy lists.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_48\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Generate 100 options and add them to the options slice\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Generate 5 additional options with a specific message and add them to the options slice\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive select feature to present the options to the user and capture their selection\n\t// The Show() method displays the options and waits for the user's input\n\tselectedOption, _ := pterm.DefaultInteractiveSelect.WithOptions(options).Show()\n\n\t// Display the selected option to the user with a green color for emphasis\n\tpterm.Info.Printfln(\"Selected option: %s\", pterm.Green(selectedOption))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using the default logger with PTerm in Go\nDESCRIPTION: Shows how to use PTerm's default logger with various logging levels. The example demonstrates logging with different severity levels, passing arguments to log entries, and using maps to provide structured data in logs.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_55\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace message with additional arguments.\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff.\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map.\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Log an info message with additional arguments.\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments.\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments.\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 2 seconds.\n\ttime.Sleep(time.Second * 2)\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering a Boxed Table with Header Using pterm in Go\nDESCRIPTION: This code initializes a table with header row and multiple data entries, including non-ASCII characters, and renders it as a boxed table in the terminal. Dependencies include the pterm library from GitHub, and the key functions involve setting data, enabling header and box styles, and rendering the table.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/boxed/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\tboardData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(boardData).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Tables with pterm in Go\nDESCRIPTION: Demonstrates the creation of two simple tables using the pterm library. It initializes table data using `pterm.TableData` (a slice of slices of strings) and then renders the tables using `pterm.DefaultTable.WithHasHeader().WithData().Render()`. A blank line is printed between the tables using `pterm.Println()`.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the first table\n\ttableData1 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData1).Render()\n\n\tpterm.Println() // Blank line\n\n\t// Define the data for the second table\n\ttableData2 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create another table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData2).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Multiselect with Large Option Set in PTerm - Go\nDESCRIPTION: Implements an interactive multiselect prompt that lets users choose multiple items from a large set (100+ options) in the terminal, with support for fuzzy searching. Utilizes PTerm's DefaultInteractiveMultiselect and WithOptions, requiring github.com/pterm/pterm. Outputs the slice of selected options, formatted in green. Useful for scenarios needing multi-selection from dynamically generated lists.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_45\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options.\n\tvar options []string\n\n\t// Populate the options slice with 100 options.\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Add 5 more options to the slice, indicating the availability of fuzzy searching.\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive multiselect to present the options to the user and capture their selections.\n\t// The Show() method displays the options and waits for user input.\n\tselectedOptions, _ := pterm.DefaultInteractiveMultiselect.WithOptions(options).Show()\n\n\t// Print the selected options, highlighted in green.\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Default Table from Struct Slice - PTerm PUtils - Go\nDESCRIPTION: Creates and returns a PTerm TablePrinter populated automatically from a slice of structs. Uses default table settings.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nfunc DefaultTableFromStructSlice(structSlice any) *pterm.TablePrinter\n```\n\n----------------------------------------\n\nTITLE: Implementing an Interactive Select Menu with Fuzzy Searching in Go using PTerm\nDESCRIPTION: This code demonstrates how to create an interactive select menu with PTerm that enables users to choose from a large set of options. It generates 100 numbered options plus 5 additional fuzzy search examples, presents them in an interactive menu, and then displays the selected option with colored output.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_select/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Generate 100 options and add them to the options slice\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Generate 5 additional options with a specific message and add them to the options slice\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive select feature to present the options to the user and capture their selection\n\t// The Show() method displays the options and waits for the user's input\n\tselectedOption, _ := pterm.DefaultInteractiveSelect.WithOptions(options).Show()\n\n\t// Display the selected option to the user with a green color for emphasis\n\tpterm.Info.Printfln(\"Selected option: %s\", pterm.Green(selectedOption))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a masked password input with PTerm in Go\nDESCRIPTION: Demonstrates how to create an interactive password input field with a mask character to hide the entered text. The example shows initialization, display of the prompt, and logging the received password.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_52\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create an interactive text input with a mask for password input\n\tpasswordInput := pterm.DefaultInteractiveTextInput.WithMask(\"*\")\n\n\t// Show the password input prompt and store the result\n\tresult, _ := passwordInput.Show(\"Enter your password\")\n\n\t// Get the default logger from PTerm\n\tlogger := pterm.DefaultLogger\n\n\t// Log the received password (masked)\n\t// Note: In a real-world application, you should never log passwords\n\tlogger.Info(\"Password received\", logger.Args(\"password\", result))\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Horizontal Bar Charts with PTerm in Go\nDESCRIPTION: Shows how to create and render bar charts in horizontal orientation by chaining WithHorizontal with WithBars and Render methods of PTerm. Requires the PTerm library and bar data slice; chart is output horizontally, with each bar's value determining its length. Inputs are the bar labels and values; outputs are displayed on the command line.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is displayed horizontally\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).WithHorizontal().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Fullscreen Centered Dynamic Area in Go with PTerm\nDESCRIPTION: Creates a fullscreen centered area that updates dynamically with changing content. The example shows a counter that increments every second for 5 iterations, with content centered in the fullscreen area.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize a new PTerm area with fullscreen and center options\n\t// The Start() function returns the created area and an error (ignored here)\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\n\t// Loop 5 times to demonstrate dynamic content update\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count\n\t\t// The Sprintf function is used to format the string with the count\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done\n\t// This will clear the area and return the terminal to its normal state\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts with Negative Values Only Using PTerm in Go\nDESCRIPTION: Demonstrates how to render bar charts where all bar values are negative, using PTerm's Bars type. Defines bars with negative values and renders charts both vertically and horizontally with values shown using WithShowValue and WithHorizontal options. Uses 'github.com/pterm/pterm' package. This snippet highlights PTerm rendering behavior for charts with only negative values where bars occupy the entire chart area.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_13\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars with negative values.\n\t// Each bar is represented by a struct with a label and a value.\n\tnegativeBars := pterm.Bars{\n\t\t{Label: \"Bar 1\", Value: -5},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Longer Label\", Value: -7},\n\t}\n\n\t// Print an informational message to the console.\n\tpterm.Info.Println(\"Chart example with negative only values (bars use 100% of chart area)\")\n\n\t// Create a vertical bar chart with the defined bars.\n\t// The WithShowValue() option is used to display the value of each bar in the chart.\n\t// The Render() method is called to draw the chart.\n\t_ = pterm.DefaultBarChart.WithBars(negativeBars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The WithHorizontal() option is used to orient the chart horizontally.\n\t// The WithShowValue() option and Render() method are used in the same way as before.\n\t_ = pterm.DefaultBarChart.WithHorizontal().WithBars(negativeBars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Horizontal Bar Chart Showing Values Using PTerm in Go\nDESCRIPTION: Builds upon the horizontal bar chart example by additionally enabling display of each bar's numeric value using WithShowValue(). Bars are defined as a slice of pterm.Bar structs. Uses DefaultBarChart chained methods: WithBars, WithHorizontal, WithShowValue, and Render from 'github.com/pterm/pterm'. Outputs a horizontal bar chart with each bar's value visible on the terminal output, facilitating easier data interpretation.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and displays the value of each bar\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating Area with Big Text - PTerm - Go\nDESCRIPTION: This Go snippet demonstrates using PTerm's Area printer to dynamically update a centered section of the terminal. It prints an initial message, starts a centered area, and then repeatedly updates the area content with the current time formatted as large text using PTerm's BigText functionality, pausing for one second between updates. The area is stopped after the loop finishes.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print an informational message using PTerm's Info printer.\n\t// This message will stay in place while the area updates.\n\tpterm.Info.Println(\"The previous text will stay in place, while the area updates.\")\n\n\t// Print two new lines as spacer.\n\tpterm.Print(\"\\n\\n\")\n\n\t// Start the Area printer from PTerm's DefaultArea, with the Center option.\n\t// The Area printer allows us to update a specific area of the console output.\n\t// The returned 'area' object is used to control the area updates.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 10 times to update the area with the current time.\n\tfor i := 0; i < 10; i++ {\n\t\t// Get the current time, format it as \"15:04:05\" (hour:minute:second), and convert it to a string.\n\t\t// Then, create a BigText from the time string using PTerm's DefaultBigText and putils NewLettersFromString.\n\t\t// The Srender() function is used to save the BigText as a string.\n\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender()\n\n\t\t// Update the Area contents with the current time string.\n\t\tarea.Update(str)\n\n\t\t// Sleep for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the Area printer after all updates are done.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Text Input with Default Value Using PTerm - Go\nDESCRIPTION: Implements a single line text input prompt in the terminal with a pre-filled default value ('Some default value'), using DefaultInteractiveTextInput.WithDefaultValue and Show(). Depends on github.com/pterm/pterm. Outputs the input string or the default value if unchanged. Great for enhancing usability when defaults are expected.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_50\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"Some default value\").Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive selection with PTerm in Go\nDESCRIPTION: This snippet initializes a slice of selectable string options, including a large list and some with fuzzy searching hints, then uses PTerm's DefaultInteractiveSelect component to display the options to the user and capture the selected option. It requires the PTerm library (github.com/pterm/pterm) and the standard fmt package. The snippet demonstrates terminal UI interaction with options, input capture, and styled output. Selected option is printed with green color emphasis using PTerm's styling. Input consists of user selection from the options list; output is a printed confirmation message.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_select/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Generate 100 options and add them to the options slice\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Generate 5 additional options with a specific message and add them to the options slice\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive select feature to present the options to the user and capture their selection\n\t// The Show() method displays the options and waits for the user's input\n\tselectedOption, _ := pterm.DefaultInteractiveSelect.WithOptions(options).Show()\n\n\t// Display the selected option to the user with a green color for emphasis\n\tpterm.Info.Printfln(\"Selected option: %s\", pterm.Green(selectedOption))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Right-Aligning Text in pterm Tables (Go)\nDESCRIPTION: Shows how to right-align the text content within all cells of a pterm table. This is achieved by calling the `WithRightAlignment()` method on the `pterm.DefaultTable` object before rendering. The example creates a table with a header and right-aligned data.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/README.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and the text in the cells is right-aligned.\n\t// The Render() method is used to print the table to the console.\n\tpterm.DefaultTable.WithHasHeader().WithRightAlignment().WithData(tableData).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode and Printing Various Message Types with PTerm in Go\nDESCRIPTION: This snippet demonstrates initializing debug mode in PTerm and printing messages of different severity levels, such as debug, info, success, warning, error, and customized info with line numbers. It also shows how to modify behavior to prevent program termination on fatal messages. Dependencies include the 'github.com/pterm/pterm' package, and the code assumes proper setup of the environment. Inputs are message strings; outputs are formatted logs in the terminal, with optional line numbers and controlled fatal behavior.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/prefix/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Enable debug messages in PTerm.\n\tpterm.EnableDebugMessages()\n\n\t// Print a debug message with PTerm.\n\tpterm.Debug.Println(\"Hello, World!\")\n\n\t// Print an informational message with PTerm.\n\tpterm.Info.Println(\"Hello, World!\")\n\n\t// Print a success message with PTerm.\n\tpterm.Success.Println(\"Hello, World!\")\n\n\t// Print a warning message with PTerm.\n\tpterm.Warning.Println(\"Hello, World!\")\n\n\t// Print an error message with PTerm. This will also display the filename and line number in the terminal.\n\tpterm.Error.Println(\"Errors show the filename and linenumber inside the terminal!\")\n\n\t// Print an informational message with PTerm, with line number.\n\t// This demonstrates that other PrefixPrinters can also display line numbers.\n\tpterm.Info.WithShowLineNumber().Println(\"Other PrefixPrinters can do that too!\")\n\n\t// Temporarily set Fatal to false, so that the CI won't crash.\n\t// This will print a fatal message with PTerm, but won't terminate the program.\n\tpterm.Fatal.WithFatal(false).Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Heatmap with PTerm Library in Go\nDESCRIPTION: This snippet defines a heatmap visualization in Go using the pterm package. It initializes a two-dimensional float32 slice representing the heatmap data points, and specifies string slices to label the X and Y axes of the heatmap. The DefaultHeatmap object is configured with the data and axis labels, RGB coloring is enabled to enhance visual clarity, and finally the heatmap is rendered to the terminal. Dependencies include the github.com/pterm/pterm package. Inputs are numeric float32 arrays for heatmap values and string arrays for axis labels. The output is a colored heatmap display in the terminal. The snippet assumes the terminal supports RGB coloring for optimal appearance.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap. Each sub-array represents a row in the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the labels for the X and Y axes of the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Create a heatmap with the defined data and axis labels, and enable RGB colors.\n\t// Then render the heatmap.\n\tpterm.DefaultHeatmap.WithAxisData(headerData).WithData(data).WithEnableRGB().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Theme Styles in Go using PTerm\nDESCRIPTION: Demonstrates how to access and display all available theme styles in the PTerm library. The example uses reflection to iterate through the default theme's styles and prints each style name using its own formatting.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_75\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"reflect\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Print an informational message about the default theme styles.\n\tpterm.Info.Println(\"These are the default theme styles.\\nYou can modify them easily to your personal preference,\\nor create new themes from scratch :)\")\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Get the value and type of the default theme.\n\tv := reflect.ValueOf(pterm.ThemeDefault)\n\ttypeOfS := v.Type()\n\n\t// Check if the type of the default theme is 'pterm.Theme'.\n\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t// Iterate over each field in the default theme.\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t// Try to convert the field to 'pterm.Style'.\n\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\tif ok {\n\t\t\t\t// Print the field name using its own style.\n\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t}\n\t\t\t// Pause for a quarter of a second to make the output easier to read.\n\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Indented Bullet Lists with PTerm in Go\nDESCRIPTION: Illustrates how to define and print a multi-level bullet list using PTerm's DefaultBulletList. It shows manual creation of bullet list items with levels 0 to 2 and rendering them. Additionally, it demonstrates parsing a multi-line indented string to a bullet list with custom indentation. Dependencies are the PTerm core and putils packages. Inputs include bullet list items and indented strings; outputs are rendered hierarchical bullet lists.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_24\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{Level: 0, Text: \"Level 0\"}, // Level 0 item\n\t\t{Level: 1, Text: \"Level 1\"}, // Level 1 item\n\t\t{Level: 2, Text: \"Level 2\"}, // Level 2 item\n\t}\n\n\t// Use the default bullet list style to render the list items.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n\n\t// Define a string with different levels of indentation.\n\ttext := `0\n 1\n  2\n   3`\n\n\t// Convert the indented string to a bullet list and render it.\n\tputils.BulletListFromString(text, \" \").Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Positioning Box Titles in Go using pterm\nDESCRIPTION: This Go snippet illustrates how to add and position titles on pterm boxes. It first creates a base padded box, then generates multiple boxes using `Sprint`, applying the same title (`WithTitle`) but varying its position with methods like `WithTitleTopCenter`, `WithTitleTopRight`, `WithTitleBottomRight`, etc. Finally, it arranges these boxes in a grid layout using `pterm.DefaultPanel.WithPanels` and renders it.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with specified padding\n\tpaddedBox := pterm.DefaultBox.WithLeftPadding(4).WithRightPadding(4).WithTopPadding(1).WithBottomPadding(1)\n\n\t// Define a title for the box\n\ttitle := pterm.LightRed(\"I'm a box!\")\n\n\t// Create boxes with the title positioned differently and containing different content\n\tbox1 := paddedBox.WithTitle(title).Sprint(\"Hello, World!\\n      1\")                         // Title at default position (top left)\n\tbox2 := paddedBox.WithTitle(title).WithTitleTopCenter().Sprint(\"Hello, World!\\n      2\")    // Title at top center\n\tbox3 := paddedBox.WithTitle(title).WithTitleTopRight().Sprint(\"Hello, World!\\n      3\")     // Title at top right\n\tbox4 := paddedBox.WithTitle(title).WithTitleBottomRight().Sprint(\"Hello, World!\\n      4\")  // Title at bottom right\n\tbox5 := paddedBox.WithTitle(title).WithTitleBottomCenter().Sprint(\"Hello, World!\\n      5\") // Title at bottom center\n\tbox6 := paddedBox.WithTitle(title).WithTitleBottomLeft().Sprint(\"Hello, World!\\n      6\")   // Title at bottom left\n\tbox7 := paddedBox.WithTitle(title).WithTitleTopLeft().Sprint(\"Hello, World!\\n      7\")      // Title at top left\n\n\t// Render the boxes in a panel layout\n\tpterm.DefaultPanel.WithPanels([][]pterm.Panel{\n\t\t{{box1}, {box2}, {box3}},\n\t\t{{box4}, {box5}, {box6}},\n\t\t{{box7}},\n\t}).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Table with Alternate Row Styling in Go using PTerm\nDESCRIPTION: Demonstrates creating a table with alternate row styling using the PTerm library. The example defines table data with headers and rows, and applies a dark gray background style to alternate rows.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_71\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\talternateStyle := pterm.NewStyle(pterm.BgDarkGray)\n\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).WithAlternateRowStyle(alternateStyle).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Paragraphs and Plain Text with PTerm in Go\nDESCRIPTION: This snippet illustrates how to print paragraphs and standard text using the PTerm library in Go. It uses the DefaultParagraph printer to handle word wrapping and line breaking, and contrasts this with printing plain text via the standard Println method (without intelligent splitting). Dependencies: github.com/pterm/pterm. The paragraph text is split at spaces, making it ideal for continuous text, and the example shows optional adjustment of line width. Accepts no inputs and prints results to the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_53\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Using the default paragraph printer to print a long text.\n\t// The text is split at the spaces, which is useful for continuous text of all kinds.\n\t// The line width can be manually adjusted if needed.\n\tpterm.DefaultParagraph.Println(\"This is the default paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n\n\t// Printing a line space for separation.\n\tpterm.Println()\n\n\t// Printing a long text without using the paragraph printer.\n\t// The default Println() function is used here, which does not provide intelligent splitting.\n\tpterm.Println(\"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling multi-line interactive text input with PTerm in Go\nDESCRIPTION: Shows how to enable multi-line input mode for an interactive text input using PTerm, allowing users to input multiple lines. The snippet constructs the input prompt with multi-line enabled, displays it, captures the resulting text, and prints it with an informational message. It depends on the github.com/pterm/pterm package and uses WithMultiLine for configuration.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a default interactive text input with multi-line enabled.\n\t// This allows the user to input multiple lines of text.\n\ttextInput := pterm.DefaultInteractiveTextInput.WithMultiLine()\n\n\t// Show the text input to the user and store the result.\n\t// The second return value (an error) is ignored with '_'.\n\tresult, _ := textInput.Show()\n\n\t// Print a blank line for better readability in the output.\n\tpterm.Println()\n\n\t// Print the user's input prefixed with an informational message.\n\t// The '%s' placeholder is replaced with the user's input.\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Multi-Line Interactive Text Input with PTerm in Go\nDESCRIPTION: This snippet enables multi-line input mode on PTerm's interactive text input prompt, allowing users to enter several lines of text before submitting. The captured multi-line input is then printed with a prefixed informational message. It requires github.com/pterm/pterm. Input is multi-line user text; output is printed multi-line response.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_44\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a default interactive text input with multi-line enabled.\n\t// This allows the user to input multiple lines of text.\n\ttextInput := pterm.DefaultInteractiveTextInput.WithMultiLine()\n\n\t// Show the text input to the user and store the result.\n\t// The second return value (an error) is ignored with '_'.\n\tresult, _ := textInput.Show()\n\n\t// Print a blank line for better readability in the output.\n\tpterm.Println()\n\n\t// Print the user's input prefixed with an informational message.\n\t// The '%s' placeholder is replaced with the user's input.\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Text in PTerm Default Box - Go\nDESCRIPTION: This Go snippet illustrates how to print a message inside PTerm's default box. It imports the PTerm library (`github.com/pterm/pterm`) and uses the `pterm.DefaultBox.Println` method, which conveniently handles the entire process of displaying the box, printing the content, and closing the box.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/default/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with PTerm and print a message in it.\n\t// The DefaultBox.Println method automatically starts, prints the message, and stops the box.\n\tpterm.DefaultBox.Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Multiselect with Large Option Set Using PTerm in Go\nDESCRIPTION: This snippet shows how to present a large list of options (100+5 with fuzzy search indication) to the user for multiple selections using PTerm's DefaultInteractiveMultiselect. It initializes options, uses Show() to display and capture selected options, then prints the selections in green color. It depends on github.com/pterm/pterm and fmt packages. Inputs are the user selections from terminal prompt; output is the printed selected options.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_38\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options.\n\tvar options []string\n\n\t// Populate the options slice with 100 options.\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Add 5 more options to the slice, indicating the availability of fuzzy searching.\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive multiselect to present the options to the user and capture their selections.\n\t// The Show() method displays the options and waits for user input.\n\tselectedOptions, _ := pterm.DefaultInteractiveMultiselect.WithOptions(options).Show()\n\n\t// Print the selected options, highlighted in green.\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Populating Table from Struct Slice - PTerm PUtils - Go\nDESCRIPTION: Populates an existing PTerm TablePrinter instance with data extracted automatically from a slice of structs. Returns the modified TablePrinter.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_17\n\nLANGUAGE: Go\nCODE:\n```\nfunc TableFromStructSlice(tablePrinter pterm.TablePrinter, structSlice any) *pterm.TablePrinter\n```\n\n----------------------------------------\n\nTITLE: Implementing an Interactive Confirmation Dialog with PTerm in Go\nDESCRIPTION: This snippet demonstrates how to show an interactive confirmation dialog using PTerm, process the user's response, and display it with appropriate formatting. It includes a utility function that converts boolean results to colored 'Yes' or 'No' text output.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_confirm/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Show an interactive confirmation dialog and get the result.\n\tresult, _ := pterm.DefaultInteractiveConfirm.Show()\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Print the user's answer in a formatted way.\n\tpterm.Info.Printfln(\"You answered: %s\", boolToText(result))\n}\n\n// boolToText converts a boolean value to a colored text.\n// If the value is true, it returns a green \"Yes\".\n// If the value is false, it returns a red \"No\".\nfunc boolToText(b bool) string {\n\tif b {\n\t\treturn pterm.Green(\"Yes\")\n\t}\n\treturn pterm.Red(\"No\")\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Centered Area - PTerm - Go\nDESCRIPTION: This Go snippet illustrates how to use PTerm's Area printer to create and update a section centered in the terminal. It starts a centered area, then iterates 5 times, updating the area's content with a simple counter message. A one-second pause is included between updates to show the dynamic effect. The area is stopped upon loop completion.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area in the center of the terminal.\n\t// The Start() function returns the created area and an error.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 5 times to simulate a dynamic update.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second to simulate a time-consuming task.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Default Big Text using PTerm in Go\nDESCRIPTION: This snippet demonstrates the basic usage of pterm's big text renderer. It takes a standard string, converts it into the required `putils.Letters` format using `LettersFromString`, and then renders it using the `pterm.DefaultBigText` renderer. This produces a large text output using the default pterm styling.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bigtext/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define the text to be rendered\n\tvar text = \"PTerm\"\n\n\t// Convert the text into a format suitable for PTerm\n\tvar letters = putils.LettersFromString(text)\n\n\t// Render the text using PTerm's default big text style\n\tpterm.DefaultBigText.WithLetters(letters).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Default Area - PTerm - Go\nDESCRIPTION: This Go snippet shows the basic usage of PTerm's DefaultArea printer. It starts a default area, loops 5 times, and in each iteration, updates the area's content with a message containing a counter. A one-second delay is added between updates to visualize the dynamic changes. The area is properly stopped at the end to clean up.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area and get a reference to it.\n\t// The second return value is an error which is ignored here.\n\tarea, _ := pterm.DefaultArea.Start()\n\n\t// Loop 5 times\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area dynamically.\n\t\t// Here we're just displaying the current count.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\t// This will clean up and free resources used by the area.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Continue Prompt in Go using PTerm\nDESCRIPTION: This snippet demonstrates how to use PTerm's DefaultInteractiveContinue to pause program execution until the user presses Enter. It creates the prompt, displays it to the user, waits for input, and then shows what the user entered (which is typically empty for a continue prompt).\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_continue/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive continue prompt with default settings\n\t// This will pause the program execution until the user presses enter\n\t// The message displayed is \"Press 'Enter' to continue...\"\n\tprompt := pterm.DefaultInteractiveContinue\n\n\t// Show the prompt and wait for user input\n\t// The returned result is the user's input (should be empty as it's a continue prompt)\n\t// The second return value is an error which is ignored here\n\tresult, _ := prompt.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's input with an info prefix\n\t// As this is a continue prompt, the input should be empty\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Multiple Progress Bars with PTerm in Go\nDESCRIPTION: This code snippet demonstrates setting up and running five concurrent progress bars in Go using the PTerm library. It initializes a multi printer instance to manage multiple progress bar outputs concurrently, and creates five progress bars each with a total of 100 units, with each bar assigned a unique writer from the multi printer. The snippet runs a loop from 1 to 100 increments, applying conditional increments to specific progress bars based on iteration count (e.g., every 2nd, 3rd, 5th, and 10th iteration), pausing 50 milliseconds each cycle to visually animate progress. It finally stops the multi printer to complete output. Dependencies include the PTerm library and Go's time package; inputs include the increment logic and total units for bars, and outputs are terminal-rendered progress bars updating in real-time.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/progressbar/multiple/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer instance from the default one\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create five progress bars with a total of 100 units each, and assign each a new writer from the multi printer\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Loop to increment progress bars based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment the first progress bar at each iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 units to the second progress bar at every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment the third progress bar at every fifth iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment the fourth progress bar at every tenth iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment the fifth progress bar at every third iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Pause for 50 milliseconds at each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Confirmation Dialog with PTerm - Go\nDESCRIPTION: Shows usage of PTerm's interactive confirm prompt, allowing users to answer a yes/no question in the terminal. Uses DefaultInteractiveConfirm.Show() to capture input and display the result in colored text, requiring the github.com/pterm/pterm dependency. Expects no parameters unless customizing. Outputs colored 'Yes' or 'No' based on user selection. Intended for CLI workflows where binary user input is needed.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_43\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Show an interactive confirmation dialog and get the result.\n\tresult, _ := pterm.DefaultInteractiveConfirm.Show()\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Print the user's answer in a formatted way.\n\tpterm.Info.Printfln(\"You answered: %s\", boolToText(result))\n}\n\n// boolToText converts a boolean value to a colored text.\n// If the value is true, it returns a green \"Yes\".\n// If the value is false, it returns a red \"No\".\nfunc boolToText(b bool) string {\n\tif b {\n\t\treturn pterm.Green(\"Yes\")\n\t}\n\treturn pterm.Red(\"No\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying a dynamic spinner countdown with Pterm in Go\nDESCRIPTION: This snippet initializes a spinner UI element using Pterm with a timer hidden and automatic removal upon completion. It starts a 15-second countdown, updating the spinner text every second to reflect the remaining time in seconds, correctly handling singular and plural forms. The spinner stops when the countdown reaches zero. Dependencies include the Pterm library, the strconv package for integer-to-string conversion, and time.Sleep for timing control.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/demo/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nintroSpinner, _ := pterm.DefaultSpinner.WithShowTimer(false).WithRemoveWhenDone(true).Start(\"Waiting for 15 seconds...\")\ntime.Sleep(second)\nfor i := 14; i > 0; i-- {\n\tif i > 1 {\n\t\tintroSpinner.UpdateText(\"Waiting for \" + strconv.Itoa(i) + \" seconds...\")\n\t} else {\n\t\tintroSpinner.UpdateText(\"Waiting for \" + strconv.Itoa(i) + \" second...\")\n\t}\n\ttime.Sleep(second)\n}\nintroSpinner.Stop()\n```\n\n----------------------------------------\n\nTITLE: Rendering PTerm Bar Chart Demo in Go\nDESCRIPTION: This snippet demonstrates rendering basic vertical and horizontal bar charts using PTerm. It defines bar data as a slice of `pterm.Bar` structs and then renders the default vertical chart and a horizontal variation using `pterm.DefaultBarChart.WithBars().Render()` and `pterm.DefaultBarChart.WithHorizontal().WithBars().Render()`.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the bars for the chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 5},\n\t\t{Label: \"Bar 2\", Value: 3},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"Chart example with positive only values (bars use 100% of chart area)\")\n\n\t// Create a bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n\n\t// Create a horizontal bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, the chart is made horizontal with the WithHorizontal option, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating Fullscreen Area - PTerm - Go\nDESCRIPTION: This Go snippet demonstrates using PTerm's Area printer to create and update a fullscreen section of the terminal. It starts a fullscreen area, iterates 5 times, updating the area's content with a simple counter message. A one-second delay is included between updates. The area is stopped after the loop finishes.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen area. This will return an area instance and an error.\n\t// The underscore (_) is used to ignore the error.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().Start()\n\n\t// Loop 5 times to update the area content.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Leveled List to Tree Using PTerm and PUtils in Go\nDESCRIPTION: This code shows how to convert a flat leveled list into a tree structure using PTerm and PUtils packages in Go. Dependencies are \"github.com/pterm/pterm\" and \"github.com/pterm/pterm/putils\". It defines a LeveledList representing hierarchical items such as directories, transforms it to a tree node root, sets the root text, and renders the tree using the default PTerm tree printer. Inputs are hardcoded; the result is a printed tree structure. The approach is suitable for visualizing nested data from flat lists.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_70\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a leveled list to represent the structure of the directories.\n\tleveledList := pterm.LeveledList{\n\t\t{Level: 0, Text: \"C:\"},\n\t\t{Level: 1, Text: \"Users\"},\n\t\t{Level: 1, Text: \"Windows\"},\n\t\t{Level: 1, Text: \"Programs\"},\n\t\t{Level: 1, Text: \"Programs(x86)\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 0, Text: \"D:\"},\n\t\t{Level: 0, Text: \"E:\"},\n\t\t{Level: 1, Text: \"Movies\"},\n\t\t{Level: 1, Text: \"Music\"},\n\t\t{Level: 2, Text: \"LinkinPark\"},\n\t\t{Level: 1, Text: \"Games\"},\n\t\t{Level: 2, Text: \"Shooter\"},\n\t\t{Level: 3, Text: \"CallOfDuty\"},\n\t\t{Level: 3, Text: \"CS:GO\"},\n\t\t{Level: 3, Text: \"Battlefield\"},\n\t\t{Level: 4, Text: \"Battlefield 1\"},\n\t\t{Level: 4, Text: \"Battlefield 2\"},\n\t\t{Level: 0, Text: \"F:\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 2, Text: \"dops\"},\n\t\t{Level: 2, Text: \"PTerm\"},\n\t}\n\n\t// Convert the leveled list into a tree structure.\n\troot := putils.TreeFromLeveledList(leveledList)\n\troot.Text = \"Computer\" // Set the root node text.\n\n\t// Render the tree structure using the default tree printer.\n\tpterm.DefaultTree.WithRoot(root).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering and Configuring Box Printers in PTrem (Go)\nDESCRIPTION: These snippets implement the box printer, which renders styled boxes around console output with custom formatting. Methods include configuration setters (e.g., SetTitle, SetStyle), render functions, and internal logic for sizing and border drawing. Dependencies include previously defined themes and color types. Parameters control box style, padding, and content. Output is formatted box sections in terminal UI, constrained by ASCII/Unicode box drawing capabilities.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_20\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Adding a title to a box printer\nfunc (b *BoxPrinter) SetTitle(title string) {\n\tb.Title = title\n}\n\n```\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Rendering the box\nfunc (b *BoxPrinter) Render(text string) {\n\t// Drawing box logic\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Printing a Default Box with PTerm in Go\nDESCRIPTION: Demonstrates how to create and print a default styled box using the PTerm library. The snippet uses the DefaultBox.Println method which encapsulates the process of starting, printing the message \"Hello, World!\", and stopping the box rendering. No additional configuration or dependencies beyond PTerm are required.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_22\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with PTerm and print a message in it.\n\t// The DefaultBox.Println method automatically starts, prints the message, and stops the box.\n\tpterm.DefaultBox.Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating pterm Styles in Go\nDESCRIPTION: This Go program illustrates how to define and use custom text styles with the pterm library. It creates two distinct styles—'primary' with light cyan foreground, gray background, and bold text, and 'secondary' with light green foreground, white background, and italic text—and then prints the same string using each style to demonstrate the formatting differences.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/style/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a primary style with light cyan foreground, gray background, and bold text\n\tprimary := pterm.NewStyle(pterm.FgLightCyan, pterm.BgGray, pterm.Bold)\n\n\t// Define a secondary style with light green foreground, white background, and italic text\n\tsecondary := pterm.NewStyle(pterm.FgLightGreen, pterm.BgWhite, pterm.Italic)\n\n\t// Print \"Hello, World!\" with the primary style\n\tprimary.Println(\"Hello, World!\")\n\n\t// Print \"Hello, World!\" with the secondary style\n\tsecondary.Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Applying Custom Styles in PTerm\nDESCRIPTION: Demonstrates how to create and apply custom text styles in PTerm. The example defines two styles: a primary style with light cyan foreground, gray background, and bold text; and a secondary style with light green foreground, white background, and italic text.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_69\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a primary style with light cyan foreground, gray background, and bold text\n\tprimary := pterm.NewStyle(pterm.FgLightCyan, pterm.BgGray, pterm.Bold)\n\n\t// Define a secondary style with light green foreground, white background, and italic text\n\tsecondary := pterm.NewStyle(pterm.FgLightGreen, pterm.BgWhite, pterm.Italic)\n\n\t// Print \"Hello, World!\" with the primary style\n\tprimary.Println(\"Hello, World!\")\n\n\t// Print \"Hello, World!\" with the secondary style\n\tsecondary.Println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing and Printing Headers with pterm in Go\nDESCRIPTION: This Go code snippet demonstrates how to customize and print console headers using the pterm library. It shows modifying the `DefaultHeader` with chained methods for margin, background, and text styles, and also creating a new `HeaderPrinter` instance with specific style configurations. Both methods are used to print styled headers to the terminal. Requires the `pterm` library (`github.com/pterm/pterm`).\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/header/custom/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Customize the DefaultHeader with a cyan background, black text, and a margin of 15.\n\tpterm.DefaultHeader.WithMargin(15).WithBackgroundStyle(pterm.NewStyle(pterm.BgCyan)).WithTextStyle(pterm.NewStyle(pterm.FgBlack)).Println(\"This is a custom header!\")\n\n\t// Define a new HeaderPrinter with a red background, black text, and a margin of 20.\n\tnewHeader := pterm.HeaderPrinter{\n\t\tTextStyle:       pterm.NewStyle(pterm.FgBlack),\n\t\tBackgroundStyle: pterm.NewStyle(pterm.BgRed),\n\t\tMargin:          20,\n\t}\n\n\t// Print the custom header using the new HeaderPrinter.\n\tnewHeader.Println(\"This is a custom header!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using PTerm Logger with JSON Format in Go\nDESCRIPTION: This snippet demonstrates initializing a pterm logger with a Trace level and JSON formatter, and then logging messages at various levels (Trace, Debug, Info, Warn, Error, Fatal) with attached key-value arguments and map-based arguments. It shows how to enrich log entries with structured data.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/json/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and JSON formatter\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithFormatter(pterm.LogFormatterJSON)\n\n\t// Log a Trace level message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a Debug level message with arguments from the map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log Info, Warn, Error, and Fatal level messages with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Concurrent Progress Bars in Go with PTerm\nDESCRIPTION: Demonstrates how to create and manage multiple progress bars simultaneously using PTerm's MultiPrinter. The example creates five progress bars that increment at different rates based on various conditions with a 50ms delay between updates.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_64\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer instance from the default one\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create five progress bars with a total of 100 units each, and assign each a new writer from the multi printer\n\tpb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 1\")\n\tpb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 2\")\n\tpb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 3\")\n\tpb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 4\")\n\tpb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start(\"Progressbar 5\")\n\n\t// Start the multi printer\n\tmulti.Start()\n\n\t// Loop to increment progress bars based on certain conditions\n\tfor i := 1; i <= 100; i++ {\n\t\tpb1.Increment() // Increment the first progress bar at each iteration\n\n\t\tif i%2 == 0 {\n\t\t\tpb2.Add(3) // Add 3 units to the second progress bar at every even iteration\n\t\t}\n\n\t\tif i%5 == 0 {\n\t\t\tpb3.Increment() // Increment the third progress bar at every fifth iteration\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tpb4.Increment() // Increment the fourth progress bar at every tenth iteration\n\t\t}\n\n\t\tif i%3 == 0 {\n\t\t\tpb5.Increment() // Increment the fifth progress bar at every third iteration\n\t\t}\n\n\t\ttime.Sleep(time.Millisecond * 50) // Pause for 50 milliseconds at each iteration\n\t}\n\n\t// Stop the multi printer\n\tmulti.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Paragraphs with PTerm in Go\nDESCRIPTION: Demonstrates usage of the default paragraph printer in PTerm to output long blocks of text with intelligent word splitting based on spaces and line width. Also contrasts with default Println behavior which does not perform automatic splitting. The core dependency is the \"github.com/pterm/pterm\" package. Inputs are long text strings, and output is formatted, wrapped paragraph text rendered to the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_60\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Using the default paragraph printer to print a long text.\n\t// The text is split at the spaces, which is useful for continuous text of all kinds.\n\t// The line width can be manually adjusted if needed.\n\tpterm.DefaultParagraph.Println(\"This is the default paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n\n\t// Printing a line space for separation.\n\tpterm.Println()\n\n\t// Printing a long text without using the paragraph printer.\n\t// The default Println() function is used here, which does not provide intelligent splitting.\n\tpterm.Println(\"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying a Progress Bar with Dynamic Titles Using PTerm in Go\nDESCRIPTION: Provides an example of a downloading simulation that displays a progress bar updated dynamically with titles representing current tasks. It uses a slice of strings naming fictitious applications, sleeps to simulate download delay, and prints success messages above the progress bar. Core dependencies include the \"github.com/pterm/pterm\" package, as well as Go's standard \"strings\" and \"time\" packages. The input is the list of items to be downloaded, and the output is a terminal UX with a progress bar and status messages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_63\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\n// Slice of strings representing names of pseudo applications to be downloaded.\nvar fakeInstallList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-dops pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\t// Create a progressbar with the total steps equal to the number of items in fakeInstallList.\n\t// Set the initial title of the progressbar to \"Downloading stuff\".\n\tp, _ := pterm.DefaultProgressbar.WithTotal(len(fakeInstallList)).WithTitle(\"Downloading stuff\").Start()\n\n\t// Loop over each item in the fakeInstallList.\n\tfor i := 0; i < p.Total; i++ {\n\t\t// Simulate a slow download for the 7th item.\n\t\tif i == 6 {\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t}\n\n\t\t// Update the title of the progressbar with the current item being downloaded.\n\t\tp.UpdateTitle(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Print a success message for the current download. This will be printed above the progressbar.\n\t\tpterm.Success.Println(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Increment the progressbar by one to indicate progress.\n\t\tp.Increment()\n\n\t\t// Pause for 350 milliseconds to simulate the time taken for each download.\n\t\ttime.Sleep(time.Millisecond * 350)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering a Custom Heatmap with Axis Labels and Colors Using pterm in Go\nDESCRIPTION: This Go code demonstrates how to render a customizable heatmap in the terminal using the pterm library. It defines multidimensional data, sets custom axis labels, and configures the heatmap appearance with specific color schemes using WithColors(). The code requires the github.com/pterm/pterm package, and expects float32 matrices as input for data, as well as corresponding axis label arrays; output is the rendered heatmap in the terminal, limited to terminals with basic color support.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/custom_colors/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, and render it\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithLegend(false).\n\t\tWithColors(pterm.BgBlue, pterm.BgRed, pterm.BgGreen, pterm.BgYellow).\n\t\tWithLegend().\n\t\tRender()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Default PTerm Logger Configuration\nDESCRIPTION: Demonstrates the default configuration of PTerm's logger with various logging levels. The example creates a logger with trace level and shows how to use different logging levels with arguments and map data.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_48\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace message with additional arguments.\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff.\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map.\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Log an info message with additional arguments.\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments.\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments.\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 2 seconds.\n\ttime.Sleep(time.Second * 2)\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Standard Logging Levels and Arguments with PTerm (Go)\nDESCRIPTION: Provides a basic example of using `pterm.DefaultLogger` to log messages at different levels (Trace, Debug, Info, Warn, Error, Fatal). Demonstrates adding simple key-value arguments using `logger.Args` and logging a map's contents using `logger.ArgsFromMap`. Shows PTerm's automatic text wrapping for long messages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace message with additional arguments.\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff.\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map.\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Log an info message with additional arguments.\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments.\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments.\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 2 seconds.\n\ttime.Sleep(time.Second * 2)\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Demo Flags and Timing in Go\nDESCRIPTION: This snippet configures command-line flags for speedup and intro skipping and sets up demo timing via a variable. The setup function checks these flags and adjusts the 'second' duration variable used throughout the demo. Requires the standard 'flag' and 'time' packages, and expects the global variables for flags and timing to be declared.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/demo/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc setup() {\n\tflag.Parse()\n\tif *speedup {\n\t\tsecond = time.Millisecond * 200\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Box Layouts with PTerm in Go\nDESCRIPTION: This Go snippet demonstrates how to create and render multiple text boxes with titles (using the PTerm DefaultBox style), arrange them into a 2D grid using the Panel component, and display the combined layout inside a parent box with a title positioned at the bottom right. Dependencies include PTerm and appropriate import of its package. The panels are created by passing their content to the WithPanels method, and the rendered output is displayed using Println. Inputs include text strings and optional titles; the function outputs visually arranged boxes in the terminal. Works only in terminals supporting monospaced SVG rendering.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_19\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"This might not be rendered correctly on GitHub,\\nbut it will work in a real terminal.\\nThis is because GitHub does not use a monospaced font by default for SVGs\")\n\n\t// Create three panels with text, some of them with titles.\n\t// The panels are created using the DefaultBox style.\n\tpanel1 := pterm.DefaultBox.Sprint(\"Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit,\\nsed do eiusmod tempor incididunt\\nut labore et dolore\\nmagna aliqua.\")\n\tpanel2 := pterm.DefaultBox.WithTitle(\"title\").Sprint(\"Ut enim ad minim veniam,\\nquis nostrud exercitation\\nullamco laboris\\nnisi ut aliquip\\nex ea commodo\\nconsequat.\")\n\tpanel3 := pterm.DefaultBox.WithTitle(\"bottom center title\").WithTitleBottomCenter().Sprint(\"Duis aute irure\\ndolor in reprehenderit\\nin voluptate velit esse cillum\\ndolore eu fugiat\\nnulla pariatur.\")\n\n\t// Combine the panels into a layout using the DefaultPanel style.\n\t// The layout is a 2D grid, with each row being an array of panels.\n\t// In this case, the first row contains panel1 and panel2, and the second row contains only panel3.\n\tpanels, _ := pterm.DefaultPanel.WithPanels(pterm.Panels{\n\t\t{{Data: panel1}, {Data: panel2}},\n\t\t{{Data: panel3}},\n\t}).Srender()\n\n\t// Print the panels layout inside a box with a title.\n\t// The box is created using the DefaultBox style, with the title positioned at the bottom right.\n\tpterm.DefaultBox.WithTitle(\"Lorem Ipsum\").WithTitleBottomRight().WithRightPadding(0).WithBottomPadding(0).Println(panels)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Centering Text - PTerm PUtils - Go\nDESCRIPTION: Centers the provided text string within the terminal width. Returns the centered string, which can then be printed.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc CenterText(text string) string\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple pterm Spinners in Go\nDESCRIPTION: This Go snippet demonstrates how to run multiple pterm spinners concurrently. It utilizes the pterm.DefaultMultiPrinter to manage output streams for each spinner, allowing them to animate simultaneously. Each spinner is started, the MultiPrinter is activated, and then individual spinners are stopped with different status messages (Success, Fail, Warning) before the MultiPrinter is stopped.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/spinner/multiple/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer. This allows multiple spinners to print simultaneously.\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create and start spinner 1 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 1\".\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\n\t// Create and start spinner 2 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 2\".\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create and start spinner 3 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 3\".\n\tspinner3, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 3\")\n\n\t// Start the multi printer. This will start printing all the spinners.\n\tmulti.Start()\n\n\t// Wait for 1 second.\n\ttime.Sleep(time.Millisecond * 1000)\n\n\t// Stop spinner 1 with a success message.\n\tspinner1.Success(\"Spinner 1 is done!\")\n\n\t// Wait for 750 milliseconds.\n\ttime.Sleep(time.Millisecond * 750)\n\n\t// Stop spinner 2 with a failure message.\n\tspinner2.Fail(\"Spinner 2 failed!\")\n\n\t// Wait for 500 milliseconds.\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Stop spinner 3 with a warning message.\n\tspinner3.Warning(\"Spinner 3 has a warning!\")\n\n\t// Stop the multi printer. This will stop printing all the spinners.\n\tmulti.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Running Function with Default Spinner - PTerm PUtils - Go\nDESCRIPTION: Executes a provided function `f` while displaying a default PTerm spinner with an initial text. The spinner automatically stops when the function completes.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\nfunc RunWithDefaultSpinner(initzialSpinnerText string, f func(spinner *pterm.SpinnerPrinter) error) error\n```\n\n----------------------------------------\n\nTITLE: Including Caller Information in PTerm Logs (Go)\nDESCRIPTION: Explains how to configure `pterm.DefaultLogger` to automatically include the source file and line number of the logging call using `WithCaller()`. Demonstrates logging at various levels with arguments, showing how the caller location is added as metadata to each log entry.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/README.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and caller information\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithCaller()\n\n\t// Log a trace message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log an info message with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Interactive Confirmation Prompt with PTerm in Go\nDESCRIPTION: This snippet implements an interactive confirmation prompt using PTerm's DefaultInteractiveConfirm. It displays a yes/no prompt, captures the boolean user response, converts it to colored text ('Yes' in green or 'No' in red), and prints it. Dependencies include the github.com/pterm/pterm module. The input is the user's confirmation, and output is the formatted confirmation result printed to the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_36\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Show an interactive confirmation dialog and get the result.\n\tresult, _ := pterm.DefaultInteractiveConfirm.Show()\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Print the user's answer in a formatted way.\n\tpterm.Info.Printfln(\"You answered: %s\", boolToText(result))\n}\n\n// boolToText converts a boolean value to a colored text.\n// If the value is true, it returns a green \"Yes\".\n// If the value is false, it returns a red \"No\".\nfunc boolToText(b bool) string {\n\tif b {\n\t\treturn pterm.Green(\"Yes\")\n\t}\n\treturn pterm.Red(\"No\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Paragraph Printing in Go with pterm\nDESCRIPTION: This Go code snippet demonstrates using `pterm.DefaultParagraph.Println` to print long strings with intelligent word wrapping based on spaces. It contrasts this with the standard `pterm.Println`, which does not automatically wrap text. The example requires the `github.com/pterm/pterm` package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/paragraph/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Using the default paragraph printer to print a long text.\n\t// The text is split at the spaces, which is useful for continuous text of all kinds.\n\t// The line width can be manually adjusted if needed.\n\tpterm.DefaultParagraph.Println(\"This is the default paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n\n\t// Printing a line space for separation.\n\tpterm.Println()\n\n\t// Printing a long text without using the paragraph printer.\n\t// The default Println() function is used here, which does not provide intelligent splitting.\n\tpterm.Println(\"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and rendering a right-aligned table with pterm in Go\nDESCRIPTION: This code snippet constructs a table with headers and multiple rows containing user data, then displays it with right-aligned text in the console using the pterm library. It sets up table data, applies header and right alignment options, and calls Render() to output the table.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/right-alignment/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and the text in the cells is right-aligned.\n\t// The Render() method is used to print the table to the console.\n\tpterm.DefaultTable.WithHasHeader().WithRightAlignment().WithData(tableData).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Right-Aligned Table Using PTerm in Go\nDESCRIPTION: This code demonstrates rendering a table with right-aligned cell text and header using the PTerm library in Go. It imports \"github.com/pterm/pterm\", defines table data, applies right alignment, enables the header, and renders the table. Inputs are statically defined; the output is a right-aligned table rendered to the console. No user input or external setup is needed apart from PTerm installation.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_67\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and the text in the cells is right-aligned.\n\t// The Render() method is used to print the table to the console.\n\tpterm.DefaultTable.WithHasHeader().WithRightAlignment().WithData(tableData).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Single Selection Menu Using PTerm in Go\nDESCRIPTION: This example uses PTerm's interactive select feature to present a list of 105 options (100 base options plus 5 indicating fuzzy search). The user selects a single option which is then printed in green text. It requires github.com/pterm/pterm and fmt packages. The input is the user's selection, and output is the printed confirmation of the selected option.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_41\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Generate 100 options and add them to the options slice\n\tfor i := 0; i < 100; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Generate 5 additional options with a specific message and add them to the options slice\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"You can use fuzzy searching (%d)\", i))\n\t}\n\n\t// Use PTerm's interactive select feature to present the options to the user and capture their selection\n\t// The Show() method displays the options and waits for the user's input\n\tselectedOption, _ := pterm.DefaultInteractiveSelect.WithOptions(options).Show()\n\n\t// Display the selected option to the user with a green color for emphasis\n\tpterm.Info.Printfln(\"Selected option: %s\", pterm.Green(selectedOption))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Interactive Text Input with Default Value in Go using PTerm\nDESCRIPTION: This code snippet demonstrates how to create and display an interactive text input field with a pre-populated default value using the PTerm library. It initializes the default interactive text input, sets a default value, displays it to the user, captures their input, and then prints the result.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/default-value/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"Some default value\").Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Boxed Tables with pterm in Go\nDESCRIPTION: Shows how to render a table enclosed within a box using the pterm library. It utilizes the `WithBoxed()` method in conjunction with `WithHasHeader()` and `WithData()` on the `pterm.DefaultTable` object before calling `Render()`.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Heatmap with No RGB, No Legend, and Axis Data Using pterm in Go\nDESCRIPTION: This example renders a heatmap without RGB color support and disables the legend, while displaying X and Y axis labels. It also disables boxed borders for a simpler look. An informational message is printed before rendering. The snippet requires pterm and takes 2D float32 input data with axis labels, resulting in a terminal heatmap without RGB colors and legend.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/README.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and no legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the specified data and options, and render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(headerData).WithLegend(false).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying and Inspecting pterm Default Theme Styles Using Reflection in Go\nDESCRIPTION: This code snippet prints an informational message about pterm's default theme styles, then uses reflection to examine each field of the theme, printing their names with styling. It includes a delay between outputs to improve readability. Dependencies include the pterm library and the standard reflect and time packages. Key parameters include theme style fields to inspect and the delay duration. Input is the default theme object; output is styled field names printed to the console.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/theme/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"reflect\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Print an informational message about the default theme styles.\n\tpterm.Info.Println(\"These are the default theme styles.\\nYou can modify them easily to your personal preference,\\nor create new themes from scratch :)\")\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Get the value and type of the default theme.\n\tv := reflect.ValueOf(pterm.ThemeDefault)\n\ttypeOfS := v.Type()\n\n\t// Check if the type of the default theme is 'pterm.Theme'.\n\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t// Iterate over each field in the default theme.\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t// Try to convert the field to 'pterm.Style'.\n\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\tif ok {\n\t\t\t\t// Print the field name using its own style.\n\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t}\n\t\t\t// Pause for a quarter of a second to make the output easier to read.\n\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t}\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Heatmap Without Grid Lines in pterm Using Go\nDESCRIPTION: This snippet creates a heatmap with RGB color enabled and axis labels but disables the grid lines for a cleaner appearance. The boxed border is also disabled, and a legend is included. It prints an informational message before rendering. The snippet requires pterm and expects 2D float32 data input with axis labels, outputting a heatmap without grid lines.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis data for the heatmap.\n\taxisData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, then render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(axisData).WithEnableRGB().WithLegend().WithGrid(false).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering a Styled Table Using pterm in Go\nDESCRIPTION: This Go code defines a styled table with headers and multiple rows, applies an alternate row background color for improved readability, and renders it in the terminal. It depends on the pterm library, specifically the NewStyle and DefaultTable functionalities, to customize style and layout.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/alternate-row-style/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\talternateStyle := pterm.NewStyle(pterm.BgDarkGray)\n\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).WithAlternateRowStyle(alternateStyle).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering ASCII Tables in the Terminal with PTerm in Go\nDESCRIPTION: This snippet shows the creation of a table printer capable of formatting and displaying 2D tabular data in the terminal. It iterates over rows and columns, applies column spacing, and formats each row with PTerm's color or style options. Requires PTerm and Go's formatting capabilities. Inputs include a 2D string array for table data. Outputs are formatted table rows printed to the terminal, suitable for structured data presentation.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\n// TablePrinter prints ASCII tables\nfunc (t *TablePrinter) Render(data [][]string) error {\n\tfor _, row := range data {\n\t\tfmt.Println(strings.Join(row, \" | \"))\n\t}\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts Using Pterm in Go\nDESCRIPTION: These snippets implement bar chart rendering functionality in Go as part of the Pterm terminal UI library. They provide methods to generate and draw bar charts with various styling and value parameters. Dependencies include terminal color support and correctly sized bar elements. Inputs typically include datasets for the bars, configuration options for colors, dimensions, and labels. Outputs produce styled visual bar chart terminal output. Limitations involve terminal size constraints and character-width considerations.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_14\n\nLANGUAGE: Go\nCODE:\n```\npackage pterm\n\n// Example function to draw a bar chart (partial snippet)  \nfunc (b *BarChart) Render() error {\n\t// Setup bar chart properties and draw bars\n\t// Use terminal colors and styles from Pterm\n\t// Iterate over data and render bars accordingly\n\treturn nil\n}\n\n// Additional methods to calculate bar widths, colors, and rendering support\nfunc calculateBarWidth(value int, max int) int {\n\t// Implementation details\n\treturn 0\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering and Updating Progress Bars in Go\nDESCRIPTION: This snippet includes functionality to initialize, render, and dynamically update a progress bar in a terminal interface using Go. It depends on Go’s standard libraries for formatting and possibly concurrency primitives for real-time updates. The key parameters include progress values, width, and visual styles. Inputs are progress increments or total counts, while outputs are terminal-rendered progress bars. Limitations include terminal compatibility and handling of concurrent updates.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:218.2,218.23\ngithub.com/pterm/pterm/progressbar_printer.go:222.2,226.39\ngithub.com/pterm/pterm/progressbar_printer.go:230.2,231.26\ngithub.com/pterm/pterm/progressbar_printer.go:237.2,237.16\ngithub.com/pterm/pterm/progressbar_printer.go:240.2,240.10\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:175.25,177.3\ngithub.com/pterm/pterm/progressbar_printer.go:178.23,180.3\ngithub.com/pterm/pterm/progressbar_printer.go:181.18,183.3\ngithub.com/pterm/pterm/progressbar_printer.go:189.21,191.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:191.8,191.44\ngithub.com/pterm/pterm/progressbar_printer.go:191.44,193.3\ngithub.com/pterm/pterm/progressbar_printer.go:193.8,195.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:206.17,208.3\ngithub.com/pterm/pterm/progressbar_printer.go:209.17,211.3\ngithub.com/pterm/pterm/progressbar_printer.go:215.22,217.3\ngithub.com/pterm/pterm/progressbar_printer.go:218.23,220.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:226.39,228.3\ngithub.com/pterm/pterm/progressbar_printer.go:231.26,233.3\ngithub.com/pterm/pterm/progressbar_printer.go:233.8,235.3\ngithub.com/pterm/pterm/progressbar_printer.go:237.16,239.3\ngithub.com/pterm/pterm/progressbar_printer.go:244.65,245.18\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:249.2,252.26\ngithub.com/pterm/pterm/progressbar_printer.go:255.2,255.10\ngithub.com/pterm/pterm/progressbar_printer.go:245.18,247.3\ngithub.com/pterm/pterm/progressbar_printer.go:252.26,254.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:259.66,260.30\ngithub.com/pterm/pterm/progressbar_printer.go:263.2,269.16\ngithub.com/pterm/pterm/progressbar_printer.go:260.30,262.3\ngithub.com/pterm/pterm/progressbar_printer.go:273.66,274.17\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:277.2,278.22\ngithub.com/pterm/pterm/progressbar_printer.go:284.2,284.15\ngithub.com/pterm/pterm/progressbar_printer.go:274.17,276.3\ngithub.com/pterm/pterm/progressbar_printer.go:278.22,281.3\ngithub.com/pterm/pterm/progressbar_printer.go:281.8,283.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:290.66,294.2\ngithub.com/pterm/pterm/progressbar_printer.go:299.65,303.2\ngithub.com/pterm/pterm/progressbar_printer.go:306.61,308.2\ngithub.com/pterm/pterm/progressbar_printer.go:310.56,313.2\n```\n\n----------------------------------------\n\nTITLE: Creating Colored Tables and Styled Text Output with PTerm in Go\nDESCRIPTION: Illustrates how to create a table with various foreground and background colors using PTerm's DefaultTable. It also shows printing of inline colored strings and nested color usage. Additionally, it creates a custom style combining background, foreground colors, and bold font, then prints styled text using that style. Dependencies are PTerm core. Inputs are string data and style configurations; outputs are colored tables and styled terminal text.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_27\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a table with different foreground and background colors.\n\tpterm.DefaultTable.WithData([][]string{\n\t\t{pterm.FgBlack.Sprint(\"Black\"), pterm.FgRed.Sprint(\"Red\"), pterm.FgGreen.Sprint(\"Green\"), pterm.FgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.FgLightRed.Sprint(\"Light Red\"), pterm.FgLightGreen.Sprint(\"Light Green\"), pterm.FgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.BgBlack.Sprint(\"Black\"), pterm.BgRed.Sprint(\"Red\"), pterm.BgGreen.Sprint(\"Green\"), pterm.BgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.BgLightRed.Sprint(\"Light Red\"), pterm.BgLightGreen.Sprint(\"Light Green\"), pterm.BgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.FgBlue.Sprint(\"Blue\"), pterm.FgMagenta.Sprint(\"Magenta\"), pterm.FgCyan.Sprint(\"Cyan\"), pterm.FgWhite.Sprint(\"White\")},\n\t\t{pterm.FgLightBlue.Sprint(\"Light Blue\"), pterm.FgLightMagenta.Sprint(\"Light Magenta\"), pterm.FgLightCyan.Sprint(\"Light Cyan\"), pterm.FgLightWhite.Sprint(\"Light White\")},\n\t\t{pterm.BgBlue.Sprint(\"Blue\"), pterm.BgMagenta.Sprint(\"Magenta\"), pterm.BgCyan.Sprint(\"Cyan\"), pterm.BgWhite.Sprint(\"White\")},\n\t\t{pterm.BgLightBlue.Sprint(\"Light Blue\"), pterm.BgLightMagenta.Sprint(\"Light Magenta\"), pterm.BgLightCyan.Sprint(\"Light Cyan\"), pterm.BgLightWhite.Sprint(\"Light White\")},\n\t}).Render() // Render the table.\n\n\tpterm.Println()\n\n\t// Print words in different colors.\n\tpterm.Println(pterm.Red(\"Hello, \") + pterm.Green(\"World\") + pterm.Cyan(\"!\"))\n\tpterm.Println(pterm.Red(\"Even \" + pterm.Cyan(\"nested \") + pterm.Green(\"colors \") + \"are supported!\"))\n\n\tpterm.Println()\n\n\t// Create a new style with a red background, light green foreground, and bold text.\n\tstyle := pterm.NewStyle(pterm.BgRed, pterm.FgLightGreen, pterm.Bold)\n\t// Print text using the created style.\n\tstyle.Println(\"This text uses a style and is bold and light green with a red background!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using pterm DefaultInteractiveContinue Prompt in Go\nDESCRIPTION: This Go snippet demonstrates how to use the `pterm.DefaultInteractiveContinue` to pause program execution and wait for the user to press the Enter key. It initializes the default prompt, shows it to the user, and then prints a message confirming the input (which is expected to be empty for a continue prompt). The code requires the `github.com/pterm/pterm` library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_continue/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive continue prompt with default settings\n\t// This will pause the program execution until the user presses enter\n\t// The message displayed is \"Press 'Enter' to continue...\"\n\tprompt := pterm.DefaultInteractiveContinue\n\n\t// Show the prompt and wait for user input\n\t// The returned result is the user's input (should be empty as it's a continue prompt)\n\t// The second return value is an error which is ignored here\n\tresult, _ := prompt.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's input with an info prefix\n\t// As this is a continue prompt, the input should be empty\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n```\n\n----------------------------------------\n\nTITLE: Printing a full-width header with pterm in Go\nDESCRIPTION: This snippet showcases how to print a header that spans the entire width of the terminal by using the WithFullWidth() option of pterm's DefaultHeader. It helps create prominent headers for improved UI clarity in terminal applications, requiring the pterm library as dependency.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/header/demo/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a full-width header.\n\t// This uses the WithFullWidth() option of PTerm to print a header that spans the full width of the terminal.\n\tpterm.DefaultHeader.WithFullWidth().Println(\"This is a full-width header.\")\n}\n```\n\n----------------------------------------\n\nTITLE: Downloading File with Custom Progressbar - PTerm PUtils - Go\nDESCRIPTION: Downloads a file from a URL to a specified output path, utilizing a provided PTerm ProgressbarPrinter instance to show progress. Returns an error on failure.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\nfunc DownloadFileWithProgressbar(progressbar *pterm.ProgressbarPrinter, outputPath, url string, mode os.FileMode) error\n```\n\n----------------------------------------\n\nTITLE: Rendering Table with Multiple Lines Per Cell Using PTerm in Go\nDESCRIPTION: This snippet shows how to create a table where some cells contain newlines using the PTerm library. Dependency is the \"github.com/pterm/pterm\" package. It specifies data with embedded '\\n' characters, sets up table formatting including separators, enables the header row, and renders the result. Inputs are hardcoded, and output is a formatted table supporting multi-line cells in the terminal. No external configuration is required.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_66\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\tdata := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create and render the table.\n\t// The options are chained in a single line for simplicity.\n\t// The table has a header, a row separator, and a header row separator.\n\tpterm.DefaultTable.WithHasHeader().WithRowSeparator(\"-\").WithHeaderRowSeparator(\"-\").WithData(data).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Table with Multiple Lines in Go using PTerm\nDESCRIPTION: Demonstrates creating a table with multi-line content in cells using the PTerm library. The example shows how newlines within cell content are properly displayed and how to add row separators.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_73\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\tdata := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create and render the table.\n\t// The options are chained in a single line for simplicity.\n\t// The table has a header, a row separator, and a header row separator.\n\tpterm.DefaultTable.WithHasHeader().WithRowSeparator(\"-\").WithHeaderRowSeparator(\"-\").WithData(data).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Bar Chart in Fullscreen Area - PTerm - Go\nDESCRIPTION: This Go snippet illustrates how to display and update a dynamic bar chart within a fullscreen, centered area using PTerm. It starts the area, schedules its stop with `defer`, and then loops 10 times. In each iteration, it generates a new set of bars using the `dynamicBars` helper function (which makes some bars grow), renders the bar chart to a string, and updates the area with this string. It pauses briefly between updates.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen centered area.\n\t// This area will be used to display the bar chart.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\t// Ensure the area stops updating when we're done.\n\tdefer area.Stop()\n\n\t// Loop to update the bar chart 10 times.\n\tfor i := 0; i < 10; i++ {\n\t\t// Create a new bar chart with dynamic bars.\n\t\t// The bars will change based on the current iteration.\n\t\tbarchart := pterm.DefaultBarChart.WithBars(dynamicBars(i))\n\t\t// Render the bar chart to a string.\n\t\t// This string will be used to update the area.\n\t\tcontent, _ := barchart.Srender()\n\t\t// Update the area with the new bar chart.\n\t\tarea.Update(content)\n\t\t// Wait for half a second before the next update.\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\n// dynamicBars generates a set of bars for the bar chart.\n// The bars will change based on the current iteration.\nfunc dynamicBars(i int) pterm.Bars {\n\treturn pterm.Bars{\n\t\t{Label: \"A\", Value: 10},     // A static bar.\n\t\t{Label: \"B\", Value: 20 * i}, // A bar that grows with each iteration.\n\t\t{Label: \"C\", Value: 30},     // Another static bar.\n\t\t{Label: \"D\", Value: 40 + i}, // A bar that grows slowly with each iteration.\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Text Styles in Go using PTerm\nDESCRIPTION: Shows how to create and apply custom text styles using PTerm's Style functionality. The example defines primary and secondary styles with different colors and text attributes, then applies them to text output.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_62\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a primary style with light cyan foreground, gray background, and bold text\n\tprimary := pterm.NewStyle(pterm.FgLightCyan, pterm.BgGray, pterm.Bold)\n\n\t// Define a secondary style with light green foreground, white background, and italic text\n\tsecondary := pterm.NewStyle(pterm.FgLightGreen, pterm.BgWhite, pterm.Italic)\n\n\t// Print \"Hello, World!\" with the primary style\n\tprimary.Println(\"Hello, World!\")\n\n\t// Print \"Hello, World!\" with the secondary style\n\tsecondary.Println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Styling and Printing Terminal Output with PTerm in Go\nDESCRIPTION: This snippet shows how to create and use custom styles for terminal output using the PTerm Go library. Dependencies include the PTerm library (github.com/pterm/pterm). It defines two style objects:\nprimary (light cyan foreground, gray background, bold) and secondary (light green foreground, white background, italic), and prints messages using each. Inputs are style attributes; outputs are colorized and formatted text in the terminal. The code assumes that the PTerm library is properly installed and available.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/style/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a primary style with light cyan foreground, gray background, and bold text\n\tprimary := pterm.NewStyle(pterm.FgLightCyan, pterm.BgGray, pterm.Bold)\n\n\t// Define a secondary style with light green foreground, white background, and italic text\n\tsecondary := pterm.NewStyle(pterm.FgLightGreen, pterm.BgWhite, pterm.Italic)\n\n\t// Print \"Hello, World!\" with the primary style\n\tprimary.Println(\"Hello, World!\")\n\n\t// Print \"Hello, World!\" with the secondary style\n\tsecondary.Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering pterm Table with Multi-line Cells (Go)\nDESCRIPTION: This Go snippet demonstrates how to create and display a formatted table using the `pterm` library. It defines `pterm.TableData` containing strings with newline characters (`\\n`), showcasing the library's ability to render multiple lines within a single table cell. The code configures the default table renderer to include a header and row separators before rendering the defined data. Requires the `github.com/pterm/pterm` dependency.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/multiple-lines/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\tdata := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create and render the table.\n\t// The options are chained in a single line for simplicity.\n\t// The table has a header, a row separator, and a header row separator.\n\tpterm.DefaultTable.WithHasHeader().WithRowSeparator(\"-\").WithHeaderRowSeparator(\"-\").WithData(data).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Updating a Dynamic Terminal Area with PTerm in Go\nDESCRIPTION: This snippet demonstrates how to initialize, update, and stop a default area in PTerm. It creates a terminal area that displays a counter that increments every second for 5 iterations, showing how content can be dynamically updated in the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/default/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area and get a reference to it.\n\t// The second return value is an error which is ignored here.\n\tarea, _ := pterm.DefaultArea.Start()\n\n\t// Loop 5 times\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area dynamically.\n\t\t// Here we're just displaying the current count.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\t// This will clean up and free resources used by the area.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Default Terminal Area with PTerm in Go\nDESCRIPTION: This snippet demonstrates creating a standard PTerm area using `pterm.DefaultArea.Start()`. It shows how to update the area's content dynamically within a loop, pausing between updates, and finally stopping the area using `area.Stop()` to restore the terminal state.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area and get a reference to it.\n\t// The second return value is an error which is ignored here.\n\tarea, _ := pterm.DefaultArea.Start()\n\n\t// Loop 5 times\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area dynamically.\n\t\t// Here we're just displaying the current count.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\t// This will clean up and free resources used by the area.\n\tarea.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating Terminal Area with Current Time Using PTerm - Go\nDESCRIPTION: Demonstrates usage of PTerm's Area and BigText printers to continuously update a designated area in the terminal with the current time displayed as large ASCII art text. The example initializes an Area printer centered on the terminal, loops 10 times to update the area each second with the formatted time using BigText letters, and stops the printer after completion. This snippet requires the Go 'time' package and the PTerm packages 'pterm' and 'pterm/putils'. It is intended for terminals supporting ANSI escape sequences. The output is a visually dynamic CLI clock without clearing the entire terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print an informational message using PTerm's Info printer.\n\t// This message will stay in place while the area updates.\n\tpterm.Info.Println(\"The previous text will stay in place, while the area updates.\")\n\n\t// Print two new lines as spacer.\n\tpterm.Print(\"\\n\\n\")\n\n\t// Start the Area printer from PTerm's DefaultArea, with the Center option.\n\t// The Area printer allows us to update a specific area of the console output.\n\t// The returned 'area' object is used to control the area updates.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 10 times to update the area with the current time.\n\tfor i := 0; i < 10; i++ {\n\t\t// Get the current time, format it as \"15:04:05\" (hour:minute:second), and convert it to a string.\n\t\t// Then, create a BigText from the time string using PTerm's DefaultBigText and putils NewLettersFromString.\n\t\t// The Srender() function is used to save the BigText as a string.\n\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender()\n\n\t\t// Update the Area contents with the current time string.\n\t\tarea.Update(str)\n\n\t\t// Sleep for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the Area printer after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Managing Spinner States and Text Updates in PTerm\nDESCRIPTION: Demonstrates various spinner functionalities including different resolution states (info, success, warning, fail), customizing info printer, and updating spinner text during execution. Each spinner simulates processing for 2 seconds before resolving.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_67\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create and start a fork of the default spinner.\n\tspinnerInfo, _ := pterm.DefaultSpinner.Start(\"Some informational action...\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerInfo.Info()          // Resolve spinner with information message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerSuccess, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will succeed)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerSuccess.Success()    // Resolve spinner with success message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerWarning, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will warn)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerWarning.Warning()    // Resolve spinner with warning message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerFail, _ := pterm.DefaultSpinner.Start(\"Doing something important... (will fail)\")\n\ttime.Sleep(time.Second * 2) // Simulate 3 seconds of processing something.\n\tspinnerFail.Fail()          // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerNochange, _ := pterm.DefaultSpinner.Start(\"Checking something important... (will result in no change)\")\n\t// Replace the InfoPrinter with a custom \"NOCHG\" one\n\tspinnerNochange.InfoPrinter = &pterm.PrefixPrinter{\n\t\tMessageStyle: &pterm.Style{pterm.FgLightBlue},\n\t\tPrefix: pterm.Prefix{\n\t\t\tStyle: &pterm.Style{pterm.FgBlack, pterm.BgLightBlue},\n\t\t\tText:  \" NOCHG \",\n\t\t},\n\t}\n\ttime.Sleep(time.Second * 2)                     // Simulate 3 seconds of processing something.\n\tspinnerNochange.Info(\"No change were required\") // Resolve spinner with error message.\n\n\t// Create and start a fork of the default spinner.\n\tspinnerLiveText, _ := pterm.DefaultSpinner.Start(\"Doing a lot of stuff...\")\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"It's really much\")   // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.UpdateText(\"We're nearly done!\") // Update spinner text.\n\ttime.Sleep(time.Second)                          // Simulate 2 seconds of processing something.\n\tspinnerLiveText.Success(\"Finally!\")              // Resolve spinner with success message.\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Alternate Rows in pterm Tables (Go)\nDESCRIPTION: Illustrates how to apply a distinct style to alternate rows in a pterm table. It defines a style using `pterm.NewStyle` with a background color (`pterm.BgDarkGray`) and applies it using the `WithAlternateRowStyle()` method. The example also shows creating a boxed table with a header.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\talternateStyle := pterm.NewStyle(pterm.BgDarkGray)\n\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).WithAlternateRowStyle(alternateStyle).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Table with Alternate Row Style Using PTerm in Go\nDESCRIPTION: This snippet demonstrates how to render a table with alternate row styling using the PTerm library in Go. Dependencies include the \"github.com/pterm/pterm\" package. It defines table data, applies a dark gray background to alternate rows, uses the table header and boxed layout, and renders the table to the console. Inputs are hardcoded table rows; output is a styled table in terminal. No external configuration is needed beyond PTerm import.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_64\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\talternateStyle := pterm.NewStyle(pterm.BgDarkGray)\n\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).WithAlternateRowStyle(alternateStyle).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Multi-line Cells in pterm Tables (Go)\nDESCRIPTION: Demonstrates creating a pterm table that correctly handles cells containing multiple lines of text (using '\\n'). This example configures the table with a header (`WithHasHeader()`) and custom row separators (`WithRowSeparator(\"-\")`, `WithHeaderRowSeparator(\"-\")`) before rendering.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\tdata := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create and render the table.\n\t// The options are chained in a single line for simplicity.\n\t// The table has a header, a row separator, and a header row separator.\n\tpterm.DefaultTable.WithHasHeader().WithRowSeparator(\"-\").WithHeaderRowSeparator(\"-\").WithData(data).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Confirmation Dialog in Go Using pterm\nDESCRIPTION: This snippet shows how to create an interactive confirmation dialog with pterm, capture the user's response, and display it with colored text. It relies on the pterm library for console UI elements and colored output. Includes a helper function to convert boolean responses into colored 'Yes'/'No' strings.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_confirm/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Show an interactive confirmation dialog and get the result.\n\tresult, _ := pterm.DefaultInteractiveConfirm.Show()\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Print the user's answer in a formatted way.\n\tpterm.Info.Printfln(\"You answered: %s\", boolToText(result))\n}\n\n// boolToText converts a boolean value to a colored text.\n// If the value is true, it returns a green \"Yes\".\n// If the value is false, it returns a red \"No\".\nfunc boolToText(b bool) string {\n\tif b {\n\t\treturn pterm.Green(\"Yes\")\n\t}\n\treturn pterm.Red(\"No\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Simple BarChart with Values Using PTerm in Go\nDESCRIPTION: This example shows how to present a basic vertical bar chart in the terminal using the PTerm library in Go. The bars are defined as a slice of pterm.Bar structs, each providing a label and integer value. WithShowValue ensures that each bar visibly displays its numerical value. After configuring the chart via method chaining on DefaultBarChart, Render outputs the chart. Dependency: github.com/pterm/pterm. Input: slice of bars with integer values. Output: vertical ASCII/Unicode art bar chart with labeled values. Intended for use in monospaced terminal UIs.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_15\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of bars for the bar chart. Each bar is represented by a struct\n\t// with a Label and a Value. The Label is a string that represents the name of the bar,\n\t// and the Value is an integer that represents the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined bars using the DefaultBarChart object from PTerm.\n\t// Chain the WithBars method to set the bars of the chart.\n\t// Chain the WithShowValue method to display the value of each bar on the chart.\n\t// Finally, call the Render method to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Colored Tables and Styled Text with PTerm in Go\nDESCRIPTION: This Go snippet demonstrates how to use the PTerm library to render a table with multiple foreground and background color combinations and to print colorized and styled text to the terminal. It requires the github.com/pterm/pterm package as a dependency. Key functions include WithData() for setting table data, colors such as FgRed, FgGreen, etc. for text coloring, and NewStyle() for custom style creation. The snippet expects no external input and outputs formatted, colored terminal text; it is intended as a demonstration or visual test, not for production use.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a table with different foreground and background colors.\n\tpterm.DefaultTable.WithData([][]string{\n\t\t{pterm.FgBlack.Sprint(\"Black\"), pterm.FgRed.Sprint(\"Red\"), pterm.FgGreen.Sprint(\"Green\"), pterm.FgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.FgLightRed.Sprint(\"Light Red\"), pterm.FgLightGreen.Sprint(\"Light Green\"), pterm.FgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.BgBlack.Sprint(\"Black\"), pterm.BgRed.Sprint(\"Red\"), pterm.BgGreen.Sprint(\"Green\"), pterm.BgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.BgLightRed.Sprint(\"Light Red\"), pterm.BgLightGreen.Sprint(\"Light Green\"), pterm.BgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.FgBlue.Sprint(\"Blue\"), pterm.FgMagenta.Sprint(\"Magenta\"), pterm.FgCyan.Sprint(\"Cyan\"), pterm.FgWhite.Sprint(\"White\")},\n\t\t{pterm.FgLightBlue.Sprint(\"Light Blue\"), pterm.FgLightMagenta.Sprint(\"Light Magenta\"), pterm.FgLightCyan.Sprint(\"Light Cyan\"), pterm.FgLightWhite.Sprint(\"Light White\")},\n\t\t{pterm.BgBlue.Sprint(\"Blue\"), pterm.BgMagenta.Sprint(\"Magenta\"), pterm.BgCyan.Sprint(\"Cyan\"), pterm.BgWhite.Sprint(\"White\")},\n\t\t{pterm.BgLightBlue.Sprint(\"Light Blue\"), pterm.BgLightMagenta.Sprint(\"Light Magenta\"), pterm.BgLightCyan.Sprint(\"Light Cyan\"), pterm.BgLightWhite.Sprint(\"Light White\")},\n\t}).Render() // Render the table.\n\n\tpterm.Println()\n\n\t// Print words in different colors.\n\tpterm.Println(pterm.Red(\"Hello, \") + pterm.Green(\"World\") + pterm.Cyan(\"!\"))\n\tpterm.Println(pterm.Red(\"Even \" + pterm.Cyan(\"nested \") + pterm.Green(\"colors \") + \"are supported!\"))\n\n\tpterm.Println()\n\n\t// Create a new style with a red background, light green foreground, and bold text.\n\tstyle := pterm.NewStyle(pterm.BgRed, pterm.FgLightGreen, pterm.Bold)\n\t// Print text using the created style.\n\tstyle.Println(\"This text uses a style and is bold and light green with a red background!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Go-based Logging with pterm Library Demonstrating Multiple Log Levels and Argument Handling\nDESCRIPTION: This code initializes a pterm logger with trace level, then logs messages at various severity levels (trace, debug, info, warning, error, fatal). It shows how to include contextual arguments using pterm's Args and ArgsFromMap functions, and how long logs are automatically wrapped. It also demonstrates logging with different data types and terminates the process after a fatal log. Dependencies include github.com/pterm/pterm, and the program uses the time package to pause execution.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/default/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Log a trace message with additional arguments.\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff.\n\tinterstingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map.\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\n\t// Log an info message with additional arguments.\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments.\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments.\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Pause for 2 seconds.\n\ttime.Sleep(time.Second * 2)\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing pterm Headers with Styles and Margins (Go)\nDESCRIPTION: This example illustrates two ways to customize pterm headers: using modification methods like `WithMargin()`, `WithBackgroundStyle()`, and `WithTextStyle()` on `DefaultHeader`, or by creating and configuring a new `HeaderPrinter` instance with specific styles and margins. Requires the `github.com/pterm/pterm` library and `pterm.NewStyle`. Customization options include text color (`Fg*`), background color (`Bg*`), and padding (`Margin`).\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/header/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Customize the DefaultHeader with a cyan background, black text, and a margin of 15.\n\tpterm.DefaultHeader.WithMargin(15).WithBackgroundStyle(pterm.NewStyle(pterm.BgCyan)).WithTextStyle(pterm.NewStyle(pterm.FgBlack)).Println(\"This is a custom header!\")\n\n\t// Define a new HeaderPrinter with a red background, black text, and a margin of 20.\n\tnewHeader := pterm.HeaderPrinter{\n\t\tTextStyle:       pterm.NewStyle(pterm.FgBlack),\n\t\tBackgroundStyle: pterm.NewStyle(pterm.BgRed),\n\t\tMargin:          20,\n\t}\n\n\t// Print the custom header using the new HeaderPrinter.\n\tnewHeader.Println(\"This is a custom header!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Tree from a Leveled List in Go using PTerm\nDESCRIPTION: Demonstrates how to create a tree structure from a leveled list using PTerm. The example defines a hierarchical directory structure as a leveled list and converts it to a tree before rendering.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_77\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a leveled list to represent the structure of the directories.\n\tleveledList := pterm.LeveledList{\n\t\t{Level: 0, Text: \"C:\"},\n\t\t{Level: 1, Text: \"Users\"},\n\t\t{Level: 1, Text: \"Windows\"},\n\t\t{Level: 1, Text: \"Programs\"},\n\t\t{Level: 1, Text: \"Programs(x86)\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 0, Text: \"D:\"},\n\t\t{Level: 0, Text: \"E:\"},\n\t\t{Level: 1, Text: \"Movies\"},\n\t\t{Level: 1, Text: \"Music\"},\n\t\t{Level: 2, Text: \"LinkinPark\"},\n\t\t{Level: 1, Text: \"Games\"},\n\t\t{Level: 2, Text: \"Shooter\"},\n\t\t{Level: 3, Text: \"CallOfDuty\"},\n\t\t{Level: 3, Text: \"CS:GO\"},\n\t\t{Level: 3, Text: \"Battlefield\"},\n\t\t{Level: 4, Text: \"Battlefield 1\"},\n\t\t{Level: 4, Text: \"Battlefield 2\"},\n\t\t{Level: 0, Text: \"F:\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 2, Text: \"dops\"},\n\t\t{Level: 2, Text: \"PTerm\"},\n\t}\n\n\t// Convert the leveled list into a tree structure.\n\troot := putils.TreeFromLeveledList(leveledList)\n\troot.Text = \"Computer\" // Set the root node text.\n\n\t// Render the tree structure using the default tree printer.\n\tpterm.DefaultTree.WithRoot(root).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts with PTerm in Go\nDESCRIPTION: This Go code sample demonstrates how to define a series of labeled bars and render them as both vertical and horizontal bar charts using the PTerm terminal UI library. It requires the 'github.com/pterm/pterm' package as a dependency. The key steps include preparing an array of pterm.Bar structs with label and value, using PTerm's DefaultBarChart, and chain-calling configuration methods (WithBars, WithHorizontal) before rendering. Expected input is a fixed set of labeled bars, and the output is the graphical representation in the terminal. The code is designed for illustrative/demo use, outputs only to the terminal, and assumes the chart data is positive-only.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the bars for the chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 5},\n\t\t{Label: \"Bar 2\", Value: 3},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"Chart example with positive only values (bars use 100% of chart area)\")\n\n\t// Create a bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n\n\t// Create a horizontal bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, the chart is made horizontal with the WithHorizontal option, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Showing single-line interactive text input with PTerm in Go\nDESCRIPTION: Demonstrates how to create and display a basic interactive single-line text input using the PTerm library. The snippet captures the user's input and prints it with an informational prefix. It depends on the github.com/pterm/pterm package and uses the default interactive text input configuration without customization.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting default value for interactive text input with PTerm in Go\nDESCRIPTION: Illustrates how to initialize an interactive single-line text input with a default value pre-filled using PTerm. This example shows the prompt to the user, captures the input (or default if unchanged), and prints the result. It requires the github.com/pterm/pterm package and uses the WithDefaultValue method to set an initial input string.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_textinput/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"Some default value\").Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Mixed-Value Bar Charts with Pterm\nDESCRIPTION: This Go program demonstrates creating and rendering bar charts with mixed positive and negative values using the pterm library. It defines a slice of `pterm.Bar` structs, populates it with labels and corresponding positive/negative values, and then uses `pterm.DefaultBarChart` to render both a vertical and a horizontal chart displaying these values. The `WithShowValue()` method ensures the numeric value is displayed for each bar.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/mixed-values/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars for the chart.\n\t// Each bar has a label and a value.\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 2},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Bar 3\", Value: -2},\n\t\t{Label: \"Bar 4\", Value: 5},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print a section header.\n\t// This is useful for separating different parts of the output.\n\tpterm.DefaultSection.Println(\"Chart example with mixed values (note screen space usage in case when ABSOLUTE values of negative and positive parts are differ too much)\")\n\n\t// Create a bar chart with the defined bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).WithShowValue().Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Multiselect with Custom Key Bindings Using PTerm in Go\nDESCRIPTION: This snippet customizes the confirmation and selection keys in a PTerm interactive multiselect prompt by setting Enter as confirm and Space as select keys. Five options are presented without filter. It depends on github.com/pterm/pterm and atomicgo.dev/keyboard/keys packages. Inputs are user selections via keyboard keys, output prints selected options highlighted in green.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_40\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and set the keys for confirming and selecting options\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithKeyConfirm(keys.Enter).\n\t\tWithKeySelect(keys.Space)\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering a Custom Header with PTerm in Go\nDESCRIPTION: This snippet implements a header printer that displays stylized headers in the terminal. It handles text alignment, padding, and color formatting using PTerm's color options. The primary dependencies are the PTerm library and Go's standard library. The key parameter is the header text, with optional style configurations. The output is a visually distinct header line, suitable for section separation or highlighting.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\n// HeaderPrinter prints a styled header\nfunc (p *HeaderPrinter) Render(message string) error {\n\t// Apply alignment, padding, and color based on options\n\tformatted := p.applyStyle(message)\n\tfmt.Println(formatted)\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a Static Tree Structure Using PTerm in Go\nDESCRIPTION: This snippet demonstrates rendering a static tree structure with nested nodes using PTerm in Go. It imports \"github.com/pterm/pterm\", defines a hierarchical tree node object with parent, child, and grandchild elements, and renders the root node using the default tree printer. Inputs are hardcoded tree nodes, and output is a visual tree displayed in the terminal. No external files or user input are required.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_69\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a tree structure using pterm.TreeNode\n\ttree := pterm.TreeNode{\n\t\t// The top node of the tree\n\t\tText: \"Top node\",\n\t\t// The children of the top node\n\t\tChildren: []pterm.TreeNode{{\n\t\t\t// A child node\n\t\t\tText: \"Child node\",\n\t\t\t// The children of the child node\n\t\t\tChildren: []pterm.TreeNode{\n\t\t\t\t// Grandchildren nodes\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t},\n\t\t}},\n\t}\n\n\t// Render the tree with the defined structure as the root\n\tpterm.DefaultTree.WithRoot(tree).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Vertical Bar Chart Showing Values Using PTerm in Go\nDESCRIPTION: Generates a vertical bar chart where the numeric values of each bar are displayed alongside the bars. Bars are defined as a slice of pterm.Bar structs with labels and integer values. Uses PTerm's DefaultBarChart with methods WithBars, WithShowValue, and Render. Requires 'github.com/pterm/pterm'. Outputs a vertical bar chart with values visible for enhanced readability.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_14\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of bars for the bar chart. Each bar is represented by a struct\n\t// with a Label and a Value. The Label is a string that represents the name of the bar,\n\t// and the Value is an integer that represents the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined bars using the DefaultBarChart object from PTerm.\n\t// Chain the WithBars method to set the bars of the chart.\n\t// Chain the WithShowValue method to display the value of each bar on the chart.\n\t// Finally, call the Render method to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Horizontal Bar Chart with Values using Pterm in Go\nDESCRIPTION: This Go code snippet demonstrates how to create and render a horizontal bar chart using the pterm library. It initializes a slice of `pterm.Bar` structs containing label-value pairs. Then, it configures `pterm.DefaultBarChart` to use this data, display horizontally (`WithHorizontal`), show the value next to each bar (`WithShowValue`), and finally renders the chart to the console.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/horizontal-show-value/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and displays the value of each bar\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithShowValue().Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Keyboard Keys for PTerm's Interactive Multiselect\nDESCRIPTION: Demonstrates how to configure custom keyboard keys for PTerm's interactive multiselect component. This example sets Enter as the confirmation key and Space as the selection key, while disabling the filter functionality.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_multiselect/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and set the keys for confirming and selecting options\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithKeyConfirm(keys.Enter).\n\t\tWithKeySelect(keys.Space)\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Multi-Line Text Input with PTerm - Go\nDESCRIPTION: Shows collection of multi-line text input from the terminal using PTerm by enabling multi-line mode on DefaultInteractiveTextInput. Requires github.com/pterm/pterm. Expects the user to enter multiple lines of text, which are captured and displayed. Particularly suited for note-taking or collecting long-form input in CLI interfaces.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_51\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a default interactive text input with multi-line enabled.\n\t// This allows the user to input multiple lines of text.\n\ttextInput := pterm.DefaultInteractiveTextInput.WithMultiLine()\n\n\t// Show the text input to the user and store the result.\n\t// The second return value (an error) is ignored with '_'.\n\tresult, _ := textInput.Show()\n\n\t// Print a blank line for better readability in the output.\n\tpterm.Println()\n\n\t// Print the user's input prefixed with an informational message.\n\t// The '%s' placeholder is replaced with the user's input.\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Default Bar Chart with pterm in Go\nDESCRIPTION: This snippet demonstrates the process of creating a default bar chart using the pterm Go library. It involves defining a slice of `pterm.Bar` structs, where each struct holds a label and value, and then utilizing the `pterm.DefaultBarChart` object with the `WithBars` and `Render` methods to output the chart to the console. It requires the `github.com/pterm/pterm` package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/default/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart. Each bar is represented by a `pterm.Bar` struct.\n\t// The `Label` field represents the label of the bar, and the `Value` field represents the value of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Use the `DefaultBarChart` from the `pterm` package to create a bar chart.\n\t// The `WithBars` method is used to set the bars of the chart.\n\t// The `Render` method is used to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering a Custom Tree Structure with pterm in Go\nDESCRIPTION: This example demonstrates how to manually create a hierarchical tree structure by defining a root node with nested child and grandchild nodes using pterm.TreeNode in Go. It shows the setup of nodes with text labels and how to use pterm's DefaultTree printer with the .WithRoot() method to render the constructed tree in the terminal. The snippet requires the pterm library and its TreeNode type. Input consists of explicitly defined tree nodes; output is the visual tree shown in the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/tree/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a tree structure using pterm.TreeNode\n\ttree := pterm.TreeNode{\n\t\t// The top node of the tree\n\t\tText: \"Top node\",\n\t\t// The children of the top node\n\t\tChildren: []pterm.TreeNode{{\n\t\t\t// A child node\n\t\t\tText: \"Child node\",\n\t\t\t// The children of the child node\n\t\t\tChildren: []pterm.TreeNode{\n\t\t\t\t// Grandchildren nodes\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t},\n\t\t}},\n\t}\n\n\t// Render the tree with the defined structure as the root\n\tpterm.DefaultTree.WithRoot(tree).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating and Printing Multi-Color Gradient Text Using PTerm in Go\nDESCRIPTION: This Go code snippet utilizes the PTerm library to create and print strings with multi-point RGB gradient fading effects. It defines six RGB colors representing gradient stops and applies the Fade method across individual characters of a given string to show a color gradient. Then, it prints 'Hello, World!' lines for the terminal height with colors fading through the defined RGB points. Dependencies include the PTerm library and a terminal that supports TrueColor. Inputs include the target string and the terminal height, and the output is colored text printed to the terminal with smooth multi-color fade effects.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/fade-multiple-colors/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB values for gradient points.\n\tstartColor := pterm.NewRGB(0, 255, 255)\n\tfirstPoint := pterm.NewRGB(255, 0, 255)\n\tsecondPoint := pterm.NewRGB(255, 0, 0)\n\tthirdPoint := pterm.NewRGB(0, 255, 0)\n\tendColor := pterm.NewRGB(255, 255, 255)\n\n\t// Define the string to be printed.\n\tstr := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstrs := strings.Split(str, \"\")\n\n\t// Initialize an empty string for the faded info.\n\tvar fadeInfo string\n\n\t// Loop over the string length to create a gradient effect.\n\tfor i := 0; i < len(str); i++ {\n\t\t// Append each character of the string with a faded color to the info string.\n\t\tfadeInfo += startColor.Fade(0, float32(len(str)), float32(i), firstPoint).Sprint(strs[i])\n\t}\n\n\t// Print the info string with gradient effect.\n\tpterm.Info.Println(fadeInfo)\n\n\t// Get the terminal height.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the terminal height to print \"Hello, World!\" with a gradient effect.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Print the string with a color that fades from startColor to endColor.\n\t\tstartColor.Fade(0, float32(terminalHeight-2), float32(i), firstPoint, secondPoint, thirdPoint, endColor).Println(\"Hello, World!\")\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Horizontal Bar Chart Using PTerm in Go\nDESCRIPTION: Demonstrates creating a horizontal bar chart by defining bars and chaining WithHorizontal() to orient the chart horizontally. Uses PTerm's DefaultBarChart with WithBars, WithHorizontal, and Render methods. Required dependency is 'github.com/pterm/pterm'. Input is a slice of pterm.Bar structs with labels and values; output is a horizontally oriented bar chart rendered to the terminal. Useful for visualizing data horizontally.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_10\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is displayed horizontally\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).WithHorizontal().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Vertical Bar Chart Using PTerm in Go\nDESCRIPTION: Creates a vertical bar chart by defining a slice of bars with labels and values. Uses PTerm's DefaultBarChart with the WithBars method to set the data bars and the Render method to display the chart. Requires the 'github.com/pterm/pterm' package. Input is a slice of pterm.Bar structs; output is a rendered bar chart in the terminal. This snippet demonstrates the basic usage for vertical bar charts without additional display options.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart. Each bar is represented by a `pterm.Bar` struct.\n\t// The `Label` field represents the label of the bar, and the `Value` field represents the value of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Use the `DefaultBarChart` from the `pterm` package to create a bar chart.\n\t// The `WithBars` method is used to set the bars of the chart.\n\t// The `Render` method is used to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering a Basic Bar Chart with PTerm in Go\nDESCRIPTION: Displays a simple vertical bar chart using PTerm with a predefined list of bars. Dependencies include the PTerm package; bars are given as slices of structs with label and value. Only default appearance is configured; output is rendered directly in the terminal window.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart. Each bar is represented by a `pterm.Bar` struct.\n\t// The `Label` field represents the label of the bar, and the `Value` field represents the value of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Use the `DefaultBarChart` from the `pterm` package to create a bar chart.\n\t// The `WithBars` method is used to set the bars of the chart.\n\t// The `Render` method is used to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Concurrent Spinners in Go using PTerm\nDESCRIPTION: Demonstrates how to create and manage multiple spinners running concurrently using PTerm's MultiPrinter. The example creates three spinners that run simultaneously and are resolved with different status messages at different times.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_61\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer. This allows multiple spinners to print simultaneously.\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create and start spinner 1 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 1\".\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\n\t// Create and start spinner 2 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 2\".\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create and start spinner 3 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 3\".\n\tspinner3, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 3\")\n\n\t// Start the multi printer. This will start printing all the spinners.\n\tmulti.Start()\n\n\t// Wait for 1 second.\n\ttime.Sleep(time.Millisecond * 1000)\n\n\t// Stop spinner 1 with a success message.\n\tspinner1.Success(\"Spinner 1 is done!\")\n\n\t// Wait for 750 milliseconds.\n\ttime.Sleep(time.Millisecond * 750)\n\n\t// Stop spinner 2 with a failure message.\n\tspinner2.Fail(\"Spinner 2 failed!\")\n\n\t// Wait for 500 milliseconds.\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Stop spinner 3 with a warning message.\n\tspinner3.Warning(\"Spinner 3 has a warning!\")\n\n\t// Stop the multi printer. This will stop printing all the spinners.\n\tmulti.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering PTerm Bar Chart with Custom Height in Go\nDESCRIPTION: This snippet demonstrates creating and rendering a vertical PTerm bar chart with a specified height. It defines the bar data and then uses `pterm.DefaultBarChart.WithBars().WithHeight().Render()` to display the chart, limiting its vertical size.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of Bar structs. Each struct represents a bar in the chart.\n\t// The Label field is the name of the bar and the Value field is the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create and render a bar chart with the defined bars and a height of 5.\n\t// The WithBars method is used to set the bars of the chart.\n\t// The WithHeight method is used to set the height of the chart.\n\t// The Render method is used to display the chart in the terminal.\n\tpterm.DefaultBarChart.WithBars(bars).WithHeight(5).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts with Mixed Positive and Negative Values Using PTerm in Go\nDESCRIPTION: Examples for displaying bar charts that include both positive and negative values using PTerm. This snippet creates both vertical and horizontal charts, displays bar values, and demonstrates how screen space is divided between positive and negative bars. Requires PTerm and an array of bars containing both positive and negative values; visual sizing depends on range and sign of input values.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars for the chart.\n\t// Each bar has a label and a value.\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 2},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Bar 3\", Value: -2},\n\t\t{Label: \"Bar 4\", Value: 5},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print a section header.\n\t// This is useful for separating different parts of the output.\n\tpterm.DefaultSection.Println(\"Chart example with mixed values (note screen space usage in case when ABSOLUTE values of negative and positive parts are differ too much)\")\n\n\t// Create a bar chart with the defined bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Function with Custom Spinner - PTerm PUtils - Go\nDESCRIPTION: Executes a provided function `f` and manages the lifecycle of a given PTerm SpinnerPrinter instance. The spinner stops automatically upon function completion.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_13\n\nLANGUAGE: Go\nCODE:\n```\nfunc RunWithSpinner(spinner *pterm.SpinnerPrinter, f func(spinner *pterm.SpinnerPrinter) error) error\n```\n\n----------------------------------------\n\nTITLE: Creating Padded Boxes with Titles and Positioning using PTerm in Go\nDESCRIPTION: Shows how to create boxes with custom padding and titles in various positions using the PTerm library. It demonstrates setting left, right, top, and bottom padding, applying a styled title in different positions (top left, top center, top right, bottom right, bottom center, bottom left), and rendering all boxes in a panel layout. Dependencies include PTerm for box manipulation and panel rendering. Inputs are textual content and style definitions; outputs are visually composed boxes with titles.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_23\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with specified padding\n\tpaddedBox := pterm.DefaultBox.WithLeftPadding(4).WithRightPadding(4).WithTopPadding(1).WithBottomPadding(1)\n\n\t// Define a title for the box\n\ttitle := pterm.LightRed(\"I'm a box!\")\n\n\t// Create boxes with the title positioned differently and containing different content\n\tbox1 := paddedBox.WithTitle(title).Sprint(\"Hello, World!\\n      1\")                         // Title at default position (top left)\n\tbox2 := paddedBox.WithTitle(title).WithTitleTopCenter().Sprint(\"Hello, World!\\n      2\")    // Title at top center\n\tbox3 := paddedBox.WithTitle(title).WithTitleTopRight().Sprint(\"Hello, World!\\n      3\")     // Title at top right\n\tbox4 := paddedBox.WithTitle(title).WithTitleBottomRight().Sprint(\"Hello, World!\\n      4\")  // Title at bottom right\n\tbox5 := paddedBox.WithTitle(title).WithTitleBottomCenter().Sprint(\"Hello, World!\\n      5\") // Title at bottom center\n\tbox6 := paddedBox.WithTitle(title).WithTitleBottomLeft().Sprint(\"Hello, World!\\n      6\")   // Title at bottom left\n\tbox7 := paddedBox.WithTitle(title).WithTitleTopLeft().Sprint(\"Hello, World!\\n      7\")      // Title at top left\n\n\t// Render the boxes in a panel layout\n\tpterm.DefaultPanel.WithPanels([][]pterm.Panel{\n\t\t{{box1}, {box2}, {box3}},\n\t\t{{box4}, {box5}, {box6}},\n\t\t{{box7}},\n\t}).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Color Gradients with RGB in PTerm\nDESCRIPTION: Demonstrates how to create color gradients using RGB colors in terminals that support TrueColor. The example creates a color fade from cyan to magenta across the terminal height, showing how to implement smooth color transitions.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"RGB colors only work in Terminals which support TrueColor.\")\n\n\t// Define the start and end points for the color gradient.\n\tstartColor := pterm.NewRGB(0, 255, 255) // Cyan\n\tendColor := pterm.NewRGB(255, 0, 255)   // Magenta\n\n\t// Get the terminal height to determine the gradient range.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the range of the terminal height to create a color gradient.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Calculate the fade factor for the current step in the gradient.\n\t\tfadeFactor := float32(i) / float32(terminalHeight-2)\n\n\t\t// Create a color that represents the current step in the gradient.\n\t\tcurrentColor := startColor.Fade(0, 1, fadeFactor, endColor)\n\n\t\t// Print a string with the current color.\n\t\tcurrentColor.Println(\"Hello, World!\")\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Foreground and Background Coloring with PTerm in Go\nDESCRIPTION: This snippet showcases creation of color tables and printing stylized text with different foreground and background colors using PTerm. It uses chained Sprint/Println methods for coloring strings, displays a table of color variants, and demonstrates nested coloring and custom styles (including background, foreground, and bold attributes). Dependencies are limited to PTerm. Inputs are text segments and color/style choices, and outputs are numerous colorized texts and tables in the terminal. No external configuration required.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_26\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a table with different foreground and background colors.\n\tpterm.DefaultTable.WithData([][]string{\n\t\t{pterm.FgBlack.Sprint(\"Black\"), pterm.FgRed.Sprint(\"Red\"), pterm.FgGreen.Sprint(\"Green\"), pterm.FgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.FgLightRed.Sprint(\"Light Red\"), pterm.FgLightGreen.Sprint(\"Light Green\"), pterm.FgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.BgBlack.Sprint(\"Black\"), pterm.BgRed.Sprint(\"Red\"), pterm.BgGreen.Sprint(\"Green\"), pterm.BgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.BgLightRed.Sprint(\"Light Red\"), pterm.BgLightGreen.Sprint(\"Light Green\"), pterm.BgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.FgBlue.Sprint(\"Blue\"), pterm.FgMagenta.Sprint(\"Magenta\"), pterm.FgCyan.Sprint(\"Cyan\"), pterm.FgWhite.Sprint(\"White\")},\n\t\t{pterm.FgLightBlue.Sprint(\"Light Blue\"), pterm.FgLightMagenta.Sprint(\"Light Magenta\"), pterm.FgLightCyan.Sprint(\"Light Cyan\"), pterm.FgLightWhite.Sprint(\"Light White\")},\n\t\t{pterm.BgBlue.Sprint(\"Blue\"), pterm.BgMagenta.Sprint(\"Magenta\"), pterm.BgCyan.Sprint(\"Cyan\"), pterm.BgWhite.Sprint(\"White\")},\n\t\t{pterm.BgLightBlue.Sprint(\"Light Blue\"), pterm.BgLightMagenta.Sprint(\"Light Magenta\"), pterm.BgLightCyan.Sprint(\"Light Cyan\"), pterm.BgLightWhite.Sprint(\"Light White\")},\n\t}).Render() // Render the table.\n\n\tpterm.Println()\n\n\t// Print words in different colors.\n\tpterm.Println(pterm.Red(\"Hello, \") + pterm.Green(\"World\") + pterm.Cyan(\"!\"))\n\tpterm.Println(pterm.Red(\"Even \" + pterm.Cyan(\"nested \") + pterm.Green(\"colors \") + \"are supported!\"))\n\n\tpterm.Println()\n\n\t// Create a new style with a red background, light green foreground, and bold text.\n\tstyle := pterm.NewStyle(pterm.BgRed, pterm.FgLightGreen, pterm.Bold)\n\t// Print text using the created style.\n\tstyle.Println(\"This text uses a style and is bold and light green with a red background!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Fade Color Gradient in Terminal with TrueColor Support using PTerm in Go\nDESCRIPTION: Demonstrates rendering a vertical color gradient in the terminal using PTerm's RGB color capabilities, which require TrueColor support. It defines a start color (cyan) and an end color (magenta) and fades between them over the height of the terminal minus two lines. For each step, it calculates the fade and prints a colored \"Hello, World!\" message. Dependencies include PTerm core. Inputs derive from terminal height; output is a visually fading color text column.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_29\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"RGB colors only work in Terminals which support TrueColor.\")\n\n\t// Define the start and end points for the color gradient.\n\tstartColor := pterm.NewRGB(0, 255, 255) // Cyan\n\tendColor := pterm.NewRGB(255, 0, 255)   // Magenta\n\n\t// Get the terminal height to determine the gradient range.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the range of the terminal height to create a color gradient.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Calculate the fade factor for the current step in the gradient.\n\t\tfadeFactor := float32(i) / float32(terminalHeight-2)\n\n\t\t// Create a color that represents the current step in the gradient.\n\t\tcurrentColor := startColor.Fade(0, 1, fadeFactor, endColor)\n\n\t\t// Print a string with the current color.\n\t\tcurrentColor.Println(\"Hello, World!\")\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Big Text with Multiple Styles using PTerm in Go\nDESCRIPTION: This snippet demonstrates creating large text using pterm with various styles. It shows rendering 'PTerm' with the default theme, applying custom colors to individual letters using FgCyan and FgLightMagenta styles, and applying a specific RGB color (gold). The output is printed directly to the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bigtext/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Create a large text with the LetterStyle from the standard theme.\n\t// This is useful for creating title screens.\n\tpterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Render()\n\n\t// Create a large text with differently colored letters.\n\t// Here, the first letter 'P' is colored cyan and the rest 'Term' is colored light magenta.\n\t// This can be used to highlight specific parts of the text.\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle()),\n\t).Render()\n\n\t// Create a large text with a specific RGB color.\n\t// This can be used when you need a specific color that is not available in the standard colors.\n\t// Here, the color is gold (RGB: 255, 215, 0).\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithRGB(\"PTerm\", pterm.NewRGB(255, 215, 0)),\n\t).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Styled Big Text with PTerm in Go\nDESCRIPTION: This Go code demonstrates using the `pterm` library to render large text ('big text'). It shows three examples: rendering text using the default style, rendering text with different styles applied to different parts ('P' in cyan, 'Term' in light magenta), and rendering text with a specific RGB color (gold). It utilizes `pterm.DefaultBigText`, `putils.LettersFromString`, `putils.LettersFromStringWithStyle`, and `putils.LettersFromStringWithRGB`. Dependencies include the `pterm` library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bigtext/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Create a large text with the LetterStyle from the standard theme.\n\t// This is useful for creating title screens.\n\tpterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Render()\n\n\t// Create a large text with differently colored letters.\n\t// Here, the first letter 'P' is colored cyan and the rest 'Term' is colored light magenta.\n\t// This can be used to highlight specific parts of the text.\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle()),\n\t).Render()\n\n\t// Create a large text with a specific RGB color.\n\t// This can be used when you need a specific color that is not available in the standard colors.\n\t// Here, the color is gold (RGB: 255, 215, 0).\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithRGB(\"PTerm\", pterm.NewRGB(255, 215, 0)),\n\t).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Generating BigText Banners with Custom Styles Using PTerm in Go\nDESCRIPTION: The snippet demonstrates large stylized text rendering with the PTerm library, including using default and custom styles and RGB color. It leverages the putils.LettersFromString functions to convert strings and apply styles (standard, color-specific, and RGB). Requires github.com/pterm/pterm and github.com/pterm/pterm/putils as dependencies. All configurations are rendered via the WithLetters and Render chain. Input: strings and style/color information. Output: big ASCII/Unicode banners intended for headers or visual emphasis in CLI tools.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_17\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Create a large text with the LetterStyle from the standard theme.\n\t// This is useful for creating title screens.\n\tpterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Render()\n\n\t// Create a large text with differently colored letters.\n\t// Here, the first letter 'P' is colored cyan and the rest 'Term' is colored light magenta.\n\t// This can be used to highlight specific parts of the text.\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle()),\n\t).Render()\n\n\t// Create a large text with a specific RGB color.\n\t// This can be used when you need a specific color that is not available in the standard colors.\n\t// Here, the color is gold (RGB: 255, 215, 0).\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithRGB(\"PTerm\", pterm.NewRGB(255, 215, 0)),\n\t).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Intro Spinner with PTerm\nDESCRIPTION: Demonstrates the usage of a PTerm spinner to show a waiting process. It updates the spinner text periodically and automatically removes the spinner once stopped. Depends on the 'pterm' and 'time' packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\n\t\t\"\\n\" +\n\t\t\"\\nThis demo was updated at: \" + pterm.Green(time.Now().Format(\"02 Jan 2006 - 15:04:05 MST\")))\n\tpterm.Println()\n\tintroSpinner, _ := pterm.DefaultSpinner.WithShowTimer(false).WithRemoveWhenDone(true).Start(\"Waiting for 15 seconds...\")\n\ttime.Sleep(second)\n\tfor i := 14; i > 0; i-- {\n\t\tif i > 1 {\n\t\t\tintroSpinner.UpdateText(\"Waiting for \" + strconv.Itoa(i) + \" seconds...\")\n\t\t} else {\n\t\t\tintroSpinner.UpdateText(\"Waiting for \" + strconv.Itoa(i) + \" second...\")\n\t\t}\n\t\ttime.Sleep(second)\n\t}\n\tintroSpinner.Stop()\n```\n\n----------------------------------------\n\nTITLE: Rendering PTerm Horizontal Bar Chart with Custom Width in Go\nDESCRIPTION: This snippet demonstrates creating and rendering a horizontal PTerm bar chart with a specified width. It defines the bar data and uses `pterm.DefaultBarChart.WithBars().WithHorizontal().WithWidth().Render()` to display the chart, controlling its horizontal extent.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and has a width of 5\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithWidth(5).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Bullet Lists with PTerm in Go\nDESCRIPTION: This snippet demonstrates two methods for generating and rendering nested bullet lists using the pterm library. It shows how to create lists programmatically using `pterm.BulletListItem` structs with specified levels and how to parse indented text into a list using `putils.BulletListFromString` by specifying the indentation delimiter. The code requires the `pterm` and `pterm/putils` packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bulletlist/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{Level: 0, Text: \"Level 0\"}, // Level 0 item\n\t\t{Level: 1, Text: \"Level 1\"}, // Level 1 item\n\t\t{Level: 2, Text: \"Level 2\"}, // Level 2 item\n\t}\n\n\t// Use the default bullet list style to render the list items.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n\n\t// Define a string with different levels of indentation.\n\ttext := `0\n 1\n  2\n   3`\n\n\t// Convert the indented string to a bullet list and render it.\n\tputils.BulletListFromString(text, \" \").Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Bar Chart with Custom Height in Go using PTerm\nDESCRIPTION: Shows how to create a bar chart with a custom height using PTerm. The example defines nine bars with different values and renders them with a fixed height of 5 units.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of Bar structs. Each struct represents a bar in the chart.\n\t// The Label field is the name of the bar and the Value field is the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create and render a bar chart with the defined bars and a height of 5.\n\t// The WithBars method is used to set the bars of the chart.\n\t// The WithHeight method is used to set the height of the chart.\n\t// The Render method is used to display the chart in the terminal.\n\tpterm.DefaultBarChart.WithBars(bars).WithHeight(5).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Centering Text Blocks and Big ASCII Letters with PTerm in Go\nDESCRIPTION: Shows usage of PTerm for printing multi-line text blocks centered in the terminal. It includes printing a regular multi-line string centered as a block and also generating large ASCII art text ('BigLetters') with PTerm, displaying it centered. Additionally, it demonstrates an option to center each line of a multi-line string separately. Dependencies include PTerm core and putils for letter parsing. Inputs are strings; outputs are centered text outputs.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_26\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print a block of text centered in the terminal\n\tpterm.DefaultCenter.Println(\"This text is centered!\\nIt centers the whole block by default.\\nIn that way you can do stuff like this:\")\n\n\t// Generate BigLetters and store in 's'\n\ts, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Srender()\n\n\t// Print the BigLetters 's' centered in the terminal\n\tpterm.DefaultCenter.Println(s)\n\n\t// Print each line of the text separately centered in the terminal\n\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(\"This text is centered!\\nBut each line is\\ncentered\\nseparately\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Default PTerm Error Prefix in Go\nDESCRIPTION: This Go snippet demonstrates how to use the pterm library to print error messages. It initially prints an error using the default pterm.Error configuration and subsequently shows how to override the default prefix text and style for pterm.Error by assigning a new pterm.Prefix struct, affecting all future uses of pterm.Error. This requires importing the \"github.com/pterm/pterm\" package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/override-default-printers/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default error message with PTerm's built-in Error style.\n\tpterm.Error.Println(\"This is the default Error\")\n\n\t// Override the default error prefix with a new text and style.\n\tpterm.Error.Prefix = pterm.Prefix{Text: \"OVERRIDE\", Style: pterm.NewStyle(pterm.BgCyan, pterm.FgRed)}\n\n\t// Print the error message again, this time with the overridden prefix.\n\tpterm.Error.Println(\"This is the default Error after the prefix was overridden\")\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Bullet Lists in Terminal using Go\nDESCRIPTION: This snippet implements a bullet list printer that formats and prints a list of items with bullet points in a terminal environment. Dependencies include standard Go formatting utilities. The key parameters involve list item strings and bullet styles/icons. Inputs are arrays or slices of strings representing list items, and outputs are styled, bulleted text blocks suitable for CLI applications. The printer supports customization and ensures clean terminal display with consistent indentations.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/bulletlist_printer.go:11.77,13.25\ngithub.com/pterm/pterm/bulletlist_printer.go:16.2,16.42\ngithub.com/pterm/pterm/bulletlist_printer.go:13.25,15.3\ngithub.com/pterm/pterm/bulletlist_printer.go:20.78,26.2\ngithub.com/pterm/pterm/bulletlist_printer.go:38.62,41.2\ngithub.com/pterm/pterm/bulletlist_printer.go:44.63,47.2\ngithub.com/pterm/pterm/bulletlist_printer.go:50.69,53.2\ngithub.com/pterm/pterm/bulletlist_printer.go:56.67,59.2\ngithub.com/pterm/pterm/bulletlist_printer.go:62.71,65.2\ngithub.com/pterm/pterm/bulletlist_printer.go:68.74,70.2\ngithub.com/pterm/pterm/bulletlist_printer.go:89.81,92.2\ngithub.com/pterm/pterm/bulletlist_printer.go:95.75,98.2\ngithub.com/pterm/pterm/bulletlist_printer.go:101.73,104.2\ngithub.com/pterm/pterm/bulletlist_printer.go:107.77,110.2\ngithub.com/pterm/pterm/bulletlist_printer.go:113.82,116.2\ngithub.com/pterm/pterm/bulletlist_printer.go:119.43,124.2\ngithub.com/pterm/pterm/bulletlist_printer.go:127.54,129.31\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/bulletlist_printer.go:150.2,150.17\ngithub.com/pterm/pterm/bulletlist_printer.go:129.31,130.28\ngithub.com/pterm/pterm/bulletlist_printer.go:137.3,137.30\ngithub.com/pterm/pterm/bulletlist_printer.go:144.3,144.24\ngithub.com/pterm/pterm/bulletlist_printer.go:130.28,131.26\ngithub.com/pterm/pterm/bulletlist_printer.go:131.26,133.5\ngithub.com/pterm/pterm/bulletlist_printer.go:133.10,135.5\ngithub.com/pterm/pterm/bulletlist_printer.go:137.30,138.28\ngithub.com/pterm/pterm/bulletlist_printer.go:138.28,140.5\ngithub.com/pterm/pterm/bulletlist_printer.go:140.10,142.5\ngithub.com/pterm/pterm/bulletlist_printer.go:144.24,146.4\ngithub.com/pterm/pterm/bulletlist_printer.go:146.9,148.4\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-Point Color Gradients with PTerm in Go\nDESCRIPTION: Shows how to create complex color gradients with multiple color points using PTerm's RGB functionality. This example demonstrates creating a gradient that transitions through several colors across the terminal height and applying a gradient to text.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB values for gradient points.\n\tstartColor := pterm.NewRGB(0, 255, 255)\n\tfirstPoint := pterm.NewRGB(255, 0, 255)\n\tsecondPoint := pterm.NewRGB(255, 0, 0)\n\tthirdPoint := pterm.NewRGB(0, 255, 0)\n\tendColor := pterm.NewRGB(255, 255, 255)\n\n\t// Define the string to be printed.\n\tstr := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstrs := strings.Split(str, \"\")\n\n\t// Initialize an empty string for the faded info.\n\tvar fadeInfo string\n\n\t// Loop over the string length to create a gradient effect.\n\tfor i := 0; i < len(str); i++ {\n\t\t// Append each character of the string with a faded color to the info string.\n\t\tfadeInfo += startColor.Fade(0, float32(len(str)), float32(i), firstPoint).Sprint(strs[i])\n\t}\n\n\t// Print the info string with gradient effect.\n\tpterm.Info.Println(fadeInfo)\n\n\t// Get the terminal height.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the terminal height to print \"Hello, World!\" with a gradient effect.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Print the string with a color that fades from startColor to endColor.\n\t\tstartColor.Fade(0, float32(terminalHeight-2), float32(i), firstPoint, secondPoint, thirdPoint, endColor).Println(\"Hello, World!\")\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Heatmap Visualization with PTerm in Go\nDESCRIPTION: This snippet demonstrates how to create a heatmap in the terminal using PTerm's heatmap component. It defines a matrix of float32 values representing heatmap data alongside X and Y axis labels. The heatmap is rendered without boxed layout, RGB colors, or legends, showing a basic color-coded table. The key inputs are the 2D data array and axis labels, with output being the printed heatmap visualization in the terminal. Dependencies include the github.com/pterm/pterm module.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_35\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and no legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the specified data and options, and render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(headerData).WithLegend(false).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Colored Large Text Using PTerm BigText in Go\nDESCRIPTION: Example usage of PTerm's DefaultBigText combined with putils for styling big letters where different text fragments are assigned different colors. Specifically renders 'P' in cyan and 'Term' in light magenta, then outputs the styled big text to the terminal. Requires 'github.com/pterm/pterm' and 'github.com/pterm/pterm/putils'. Useful for emphasizing terminal text decoratively.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_17\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Initialize a big text display with the letters \"P\" and \"Term\"\n\t// \"P\" is displayed in cyan and \"Term\" is displayed in light magenta\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle())).\n\t\tRender() // Render the big text to the terminal\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Custom RGB Text with PTerm in Go\nDESCRIPTION: This snippet demonstrates how to print terminal text and backgrounds with user-defined RGB colors using the PTerm library in Go. It creates new RGB color objects with specific values and prints text with those foreground or background colors. Dependencies include the PTerm Go package, and the main parameters are the red, green, and blue values (0-255), with an optional boolean to set background coloring. Inputs are hardcoded color values in the function calls, and output is colored text or colored backgrounds in the terminal. Compatible with environments supporting 24-bit terminal colors; output depends on terminal capabilities.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/print-color-rgb/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a new RGB color with values 178, 44, 199.\n\t// This color will be used for the text.\n\tpterm.NewRGB(178, 44, 199).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 15, 199, 209.\n\t// This color will be used for the text.\n\tpterm.NewRGB(15, 199, 209).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 201, 144, 30.\n\t// This color will be used for the background.\n\t// The 'true' argument indicates that the color is for the background.\n\tpterm.NewRGB(201, 144, 30, true).Println(\"This text is printed with a custom RGB background!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering 2D Panel Layouts with PTerm in Go\nDESCRIPTION: This Go code demonstrates how to define and render panels arranged in a 2D grid using the PTerm library. It creates panel data with text and styled headers, then renders the grid layout with a padding of 5 between panels. Dependencies: github.com/pterm/pterm. The panels can contain plain text or colored/styled content, and the output is rendered directly to the terminal. It requires no parameters and can serve as a standalone panel demonstration.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_52\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define panels in a 2D grid system\n\tpanels := pterm.Panels{\n\t\t{\n\t\t\t{Data: \"This is the first panel\"},\n\t\t\t{Data: pterm.DefaultHeader.Sprint(\"Hello, World!\")},\n\t\t\t{Data: \"This\\npanel\\ncontains\\nmultiple\\nlines\"},\n\t\t},\n\t\t{\n\t\t\t{Data: pterm.Red(\"This is another\\npanel line\")},\n\t\t\t{Data: \"This is the second panel\\nwith a new line\"},\n\t\t},\n\t}\n\n\t// Render the panels with a padding of 5\n\t_ = pterm.DefaultPanel.WithPanels(panels).WithPadding(5).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Boxes With Custom Titles and Padding Using PTerm in Go\nDESCRIPTION: This Go snippet demonstrates dynamic creation of seven boxes with a custom title and varying title positions (top left, top center, top right, bottom right, bottom center, bottom left, and again top left) using PTerm. It applies padding on all sides and colorizes the title with pterm.LightRed. Boxes are arranged into a 2D panel layout and rendered collectively. Requires the PTerm package. Key parameters include padding, title content, box content, and title position methods. Outputs a structured visual panel in the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_22\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with specified padding\n\tpaddedBox := pterm.DefaultBox.WithLeftPadding(4).WithRightPadding(4).WithTopPadding(1).WithBottomPadding(1)\n\n\t// Define a title for the box\n\ttitle := pterm.LightRed(\"I'm a box!\")\n\n\t// Create boxes with the title positioned differently and containing different content\n\tbox1 := paddedBox.WithTitle(title).Sprint(\"Hello, World!\\n      1\")                         // Title at default position (top left)\n\tbox2 := paddedBox.WithTitle(title).WithTitleTopCenter().Sprint(\"Hello, World!\\n      2\")    // Title at top center\n\tbox3 := paddedBox.WithTitle(title).WithTitleTopRight().Sprint(\"Hello, World!\\n      3\")     // Title at top right\n\tbox4 := paddedBox.WithTitle(title).WithTitleBottomRight().Sprint(\"Hello, World!\\n      4\")  // Title at bottom right\n\tbox5 := paddedBox.WithTitle(title).WithTitleBottomCenter().Sprint(\"Hello, World!\\n      5\") // Title at bottom center\n\tbox6 := paddedBox.WithTitle(title).WithTitleBottomLeft().Sprint(\"Hello, World!\\n      6\")   // Title at bottom left\n\tbox7 := paddedBox.WithTitle(title).WithTitleTopLeft().Sprint(\"Hello, World!\\n      7\")      // Title at top left\n\n\t// Render the boxes in a panel layout\n\tpterm.DefaultPanel.WithPanels([][]pterm.Panel{\n\t\t{{box1}, {box2}, {box3}},\n\t\t{{box4}, {box5}, {box6}},\n\t\t{{box7}},\n\t}).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Advanced RGB Color Styling with Foreground and Background in PTerm\nDESCRIPTION: Demonstrates complex RGB color styling with both foreground and background colors. This example shows how to create colored text with fading effects and how to apply styles like bold and italic to specific parts of the text.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors\n\twhite := pterm.NewRGB(255, 255, 255)\n\tgrey := pterm.NewRGB(128, 128, 128)\n\tblack := pterm.NewRGB(0, 0, 0)\n\tred := pterm.NewRGB(255, 0, 0)\n\tpurple := pterm.NewRGB(255, 0, 255)\n\tgreen := pterm.NewRGB(0, 255, 0)\n\n\t// Define strings to be printed\n\tstr1 := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstr2 := \"The background and foreground colors can be customized individually.\"\n\tstr3 := \"Styles can also be applied. For example: Bold or Italic.\"\n\n\t// Print first string with color fading from white to purple\n\tprintFadedString(str1, white, purple, grey, black)\n\n\t// Print second string with color fading from purple to red\n\tprintFadedString(str2, black, purple, red, red)\n\n\t// Print third string with color fading from white to green and style changes\n\tprintStyledString(str3, white, green, red, black)\n}\n\n// printFadedString prints a string with color fading effect\nfunc printFadedString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n// printStyledString prints a string with color fading and style changes\nfunc printStyledString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tboldStr := strings.Split(\"Bold\", \"\")\n\titalicStr := strings.Split(\"Italic\", \"\")\n\tbold, italic := 0, 0\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Check if the next letters are \"Bold\" or \"Italic\" and add the corresponding style\n\t\tif bold < len(boldStr) && i+len(boldStr)-bold <= len(strs) && strings.Join(strs[i:i+len(boldStr)-bold], \"\") == strings.Join(boldStr[bold:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Bold)\n\t\t\tbold++\n\t\t} else if italic < len(italicStr) && i+len(italicStr)-italic < len(strs) && strings.Join(strs[i:i+len(italicStr)-italic], \"\") == strings.Join(italicStr[italic:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Italic)\n\t\t\titalic++\n\t\t}\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n```\n\n----------------------------------------\n\nTITLE: Centering Text Output using PTerm in Go\nDESCRIPTION: This Go snippet demonstrates various text centering techniques using the pterm library. It shows how to center an entire block of text, how to center dynamically generated large text (BigLetters), and how to center each line of a multi-line string independently. It utilizes `pterm.DefaultCenter` and `pterm.DefaultBigText`.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/center/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print a block of text centered in the terminal\n\tpterm.DefaultCenter.Println(\"This text is centered!\\nIt centers the whole block by default.\\nIn that way you can do stuff like this:\")\n\n\t// Generate BigLetters and store in 's'\n\ts, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Srender()\n\n\t// Print the BigLetters 's' centered in the terminal\n\tpterm.DefaultCenter.Println(s);\n\n\t// Print each line of the text separately centered in the terminal\n\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(\"This text is centered!\\nBut each line is\\ncentered\\nseparately\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Customized Bullet Lists with Styles in pterm (Go)\nDESCRIPTION: This snippet demonstrates creating a bullet list with custom styles for text and bullet symbols, including different colors and symbols at various list levels. Dependencies include the 'pterm' package. The example assigns specific styles and symbols to list items, then renders the styled list, showcasing flexibility in list appearance customization.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bulletlist/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different styles and levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{\n\t\t\tLevel:       0,                            // Level 0 (top level)\n\t\t\tText:        \"Blue\",                       // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgBlue), // Text color\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgRed),  // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       1,                                  // Level 1 (sub-item)\n\t\t\tText:        \"Green\",                            // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgGreen),      // Text color\n\t\t\tBullet:      \"-\",                                // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgLightWhite), // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       2,                              // Level 2 (sub-sub-item)\n\t\t\tText:        \"Cyan\",                         // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgCyan),   // Text color\n\t\t\tBullet:      \">\",                            // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgYellow), // Bullet color\n\t\t},\n\t}\n\n\t// Create a bullet list with the defined items and render it.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing a default header using pterm in Go\nDESCRIPTION: This snippet demonstrates how to print a simple, default-styled header using pterm's DefaultHeader.Println method. It requires the pterm library imported as github.com/pterm/pterm and outputs a header with default styling. No additional configuration is needed for the default header.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/header/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default header.\n\t// This uses the default settings of PTerm to print a header.\n\tpterm.DefaultHeader.Println(\"This is the default header!\")\n\n\t// Print a spacer line for better readability.\n\tpterm.Println()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Displaying Custom Checkmark Multiselect in pterm (Go)\nDESCRIPTION: This snippet demonstrates how to configure and display an interactive multiselect using the pterm library in Go. It populates a list of options, disables the built-in filter, customizes the checkmark symbols (using '+' for checked and '-' for unchecked), displays the selection interface to the user, and prints the final selected options. Requires the 'github.com/pterm/pterm' library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_multiselect/custom-checkmarks/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and define the checkmark symbols\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithCheckmark(&pterm.Checkmark{Checked: pterm.Green(\"+\"), Unchecked: pterm.Red(\"-\")})\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Leveled List to Tree Node - PTerm PUtils - Go\nDESCRIPTION: Transforms a PTerm LeveledList structure into a PTerm TreeNode, which is the format used for printing tree structures in the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_18\n\nLANGUAGE: Go\nCODE:\n```\nfunc TreeFromLeveledList(leveledListItems pterm.LeveledList) pterm.TreeNode\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering Custom Width Horizontal Bar Chart with pterm in Go\nDESCRIPTION: This Go snippet demonstrates how to initialize data for a bar chart using `[]pterm.Bar` and then configure and render a horizontal bar chart using `pterm.DefaultBarChart`. It specifically sets a custom width for the chart using the `WithWidth` method and displays it in the terminal via the `Render` function. Requires the pterm library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/custom-width/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and has a width of 5\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithWidth(5).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integer in Go\nDESCRIPTION: Generates a pseudo-random integer within a specified range (inclusive). It seeds the random number generator using the current time to ensure different results on subsequent runs. Requires the 'math/rand' and 'time' packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nfunc randomInt(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Average Execution Time - PTerm PUtils - Go\nDESCRIPTION: Measures the execution time of a given function when run a specified number of times and prints the average duration. The function `f` must accept an integer index.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\nfunc PrintAverageExecutionTime(count int, f func(i int) error) error\n```\n\n----------------------------------------\n\nTITLE: Using Custom RGB Colors in PTerm\nDESCRIPTION: Shows how to create and use custom RGB colors for both text and background in PTerm. This example demonstrates creating three different RGB colors and applying them to text output, including one as a background color.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a new RGB color with values 178, 44, 199.\n\t// This color will be used for the text.\n\tpterm.NewRGB(178, 44, 199).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 15, 199, 209.\n\t// This color will be used for the text.\n\tpterm.NewRGB(15, 199, 209).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 201, 144, 30.\n\t// This color will be used for the background.\n\t// The 'true' argument indicates that the color is for the background.\n\tpterm.NewRGB(201, 144, 30, true).Println(\"This text is printed with a custom RGB background!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Terminal Output Areas in Go\nDESCRIPTION: This snippet provides the implementation of area printers that manage grouped terminal output regions for better structuring and updating of multiline outputs. It requires Go’s formatting and possibly concurrency handling. Inputs include content strings or lines to be printed, while outputs are organized terminal areas that can be refreshed or cleared. The areas help maintain sections of terminal output independently, useful for dynamic CLI tools.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/area_printer.go:28.43,30.2\ngithub.com/pterm/pterm/area_printer.go:33.65,36.2\ngithub.com/pterm/pterm/area_printer.go:39.61,42.2\ngithub.com/pterm/pterm/area_printer.go:45.57,48.2\ngithub.com/pterm/pterm/area_printer.go:52.51,53.19\ngithub.com/pterm/pterm/area_printer.go:57.2,60.14\ngithub.com/pterm/pterm/area_printer.go:64.2,64.18\ngithub.com/pterm/pterm/area_printer.go:82.2,82.20\ngithub.com/pterm/pterm/area_printer.go:53.19,56.3\ngithub.com/pterm/pterm/area_printer.go:60.14,62.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/area_printer.go:64.18,72.15\ngithub.com/pterm/pterm/area_printer.go:77.3,77.29\ngithub.com/pterm/pterm/area_printer.go:72.15,75.4\ngithub.com/pterm/pterm/area_printer.go:77.29,80.4\ngithub.com/pterm/pterm/area_printer.go:86.72,95.2\ngithub.com/pterm/pterm/area_printer.go:99.36,101.22\ngithub.com/pterm/pterm/area_printer.go:104.2,104.12\ngithub.com/pterm/pterm/area_printer.go:101.22,103.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/area_printer.go:110.60,114.2\ngithub.com/pterm/pterm/area_printer.go:119.59,123.2\ngithub.com/pterm/pterm/area_printer.go:128.31,130.2\n```\n\n----------------------------------------\n\nTITLE: Customizing Bullet List Styles with PTerm in Go\nDESCRIPTION: This Go snippet shows how to create a bullet list with PTerm where each bullet item can have custom foreground and bullet colors, text styles, levels, and bullet symbols. Uses NewStyle to define colors and assigns symbols like '-', '>' for different levels. Dependencies include only PTerm, and key parameters are item levels, styles, text, and bullet characters. Output is a colored and hierarchically-structured bullet list. Suitable for highlighting different sections or priorities in the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_24\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different styles and levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{\n\t\t\tLevel:       0,                            // Level 0 (top level)\n\t\t\tText:        \"Blue\",                       // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgBlue), // Text color\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgRed),  // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       1,                                  // Level 1 (sub-item)\n\t\t\tText:        \"Green\",                            // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgGreen),      // Text color\n\t\t\tBullet:      \"-\",                                // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgLightWhite), // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       2,                              // Level 2 (sub-sub-item)\n\t\t\tText:        \"Cyan\",                         // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgCyan),   // Text color\n\t\t\tBullet:      \">\",                            // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgYellow), // Bullet color\n\t\t},\n\t}\n\n\t// Create a bullet list with the defined items and render it.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Logging with caller information in PTerm for Go\nDESCRIPTION: Shows how to enable caller information in PTerm logs to track the source of log entries. The example demonstrates creating a logger with trace level and caller information, then logs messages at various severity levels.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_57\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with Trace level and caller information\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace).WithCaller()\n\n\t// Log a trace message with additional arguments\n\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\n\t// Create a map of interesting stuff\n\tinterestingStuff := map[string]any{\n\t\t\"when were crayons invented\":  \"1903\",\n\t\t\"what is the meaning of life\": 42,\n\t\t\"is this interesting\":         true,\n\t}\n\n\t// Log a debug message with arguments from a map\n\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interestingStuff))\n\n\t// Log an info message with additional arguments\n\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\n\t// Log a warning message with additional arguments\n\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\n\t// Log an error message with additional arguments\n\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\n\t// Log an info message with additional arguments. PTerm will automatically wrap long logs.\n\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\n\t// Log a fatal message with additional arguments. This will terminate the process.\n\tlogger.Fatal(\"Oh no, this process is getting killed!\", logger.Args(\"fatal\", true))\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Separated Values to TableData - PTerm PUtils - Go\nDESCRIPTION: Parses a string into PTerm TableData using custom value and row separators. Provides flexibility for formats other than standard CSV/TSV.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_15\n\nLANGUAGE: Go\nCODE:\n```\nfunc TableDataFromSeparatedValues(text, valueSeparator, rowSeparator string) (td pterm.TableData)\n```\n\n----------------------------------------\n\nTITLE: Rendering a Custom Height Bar Chart with pterm in Go\nDESCRIPTION: This snippet initializes a slice of pterm.Bar structs with labels and values, representing the data for the bar chart. It then configures the default bar chart renderer from the pterm library, setting the bars using `WithBars` and specifying the total height of the chart using `WithHeight(5)`. Finally, the `Render` method displays the chart in the terminal. This requires the `github.com/pterm/pterm` dependency.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/custom-height/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of Bar structs. Each struct represents a bar in the chart.\n\t// The Label field is the name of the bar and the Value field is the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create and render a bar chart with the defined bars and a height of 5.\n\t// The WithBars method is used to set the bars of the chart.\n\t// The WithHeight method is used to set the height of the chart.\n\t// The Render method is used to display the chart in the terminal.\n\tpterm.DefaultBarChart.WithBars(bars).WithHeight(5).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Horizontal Bar Charts with Visible Values with PTerm in Go\nDESCRIPTION: Demonstrates how to display each bar's value alongside horizontal bars in a bar chart using PTerm's WithShowValue and WithHorizontal methods. Dependencies include PTerm and correct bar data; calling WithShowValue toggles the display of values. Input is an array of bars, output is a terminal chart with value annotations.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and displays the value of each bar\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Fading RGB Colors and Styles in Go with pterm\nDESCRIPTION: This Go example demonstrates how to create text with fading foreground and background colors using the pterm library. It defines several RGB colors, then uses the `printFadedString` function to apply a gradient between two foreground and two background colors character by character. The `printStyledString` function extends this by applying Bold and Italic styles to specific words within the faded text.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors\n\twhite := pterm.NewRGB(255, 255, 255)\n\tgrey := pterm.NewRGB(128, 128, 128)\n\tblack := pterm.NewRGB(0, 0, 0)\n\tred := pterm.NewRGB(255, 0, 0)\n\tpurple := pterm.NewRGB(255, 0, 255)\n\tgreen := pterm.NewRGB(0, 255, 0)\n\n\t// Define strings to be printed\n\tstr1 := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstr2 := \"The background and foreground colors can be customized individually.\"\n\tstr3 := \"Styles can also be applied. For example: Bold or Italic.\"\n\n\t// Print first string with color fading from white to purple\n\tprintFadedString(str1, white, purple, grey, black)\n\n\t// Print second string with color fading from purple to red\n\tprintFadedString(str2, black, purple, red, red)\n\n\t// Print third string with color fading from white to green and style changes\n\tprintStyledString(str3, white, green, red, black)\n}\n\n// printFadedString prints a string with color fading effect\nfunc printFadedString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n// printStyledString prints a string with color fading and style changes\nfunc printStyledString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tboldStr := strings.Split(\"Bold\", \"\")\n\titalicStr := strings.Split(\"Italic\", \"\")\n\tbold, italic := 0, 0\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Check if the next letters are \"Bold\" or \"Italic\" and add the corresponding style\n\t\tif bold < len(boldStr) && i+len(boldStr)-bold <= len(strs) && strings.Join(strs[i:i+len(boldStr)-bold], \"\") == strings.Join(boldStr[bold:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Bold)\n\t\t\tbold++\n\t\t} else if italic < len(italicStr) && i+len(italicStr)-italic < len(strs) && strings.Join(strs[i:i+len(italicStr)-italic], \"\") == strings.Join(italicStr[italic:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Italic)\n\t\t\titalic++\n\t\t}\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Horizontal Bar Chart with PTerm in Go\nDESCRIPTION: This Go snippet shows how to use the PTerm library to create and render a horizontal bar chart in a terminal application. It defines a slice of pterm.Bar structs with categorical labels and integer values, configures the chart for horizontal orientation, and calls Render() to display it. PTerm must be installed as a dependency, and input data should be provided as a slice of pterm.Bar with 'Label' and 'Value' fields. The output is an interactive or static terminal bar chart, and the example is suitable for tabular categorical data visualization on the command line.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/horizontal/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is displayed horizontally\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).WithHorizontal().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Centered Terminal Area with PTerm in Go\nDESCRIPTION: This snippet initializes and starts a PTerm area centered in the terminal. It demonstrates dynamically updating the area's content within a loop using `area.Update()` and `pterm.Sprintf()`, pausing between updates with `time.Sleep()`, and finally stopping the area with `area.Stop()` to clean up resources.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area in the center of the terminal.\n\t// The Start() function returns the created area and an error.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 5 times to simulate a dynamic update.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second to simulate a time-consuming task.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Bullet List from String - PTerm PUtils - Go\nDESCRIPTION: Creates a PTerm BulletListPrinter from a single string input, allowing easy printing of a one-item bullet list. It requires the string content and padding.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nfunc BulletListFromString(s string, padding string) pterm.BulletListPrinter\n```\n\n----------------------------------------\n\nTITLE: Showcasing PTerm Feature with Header and Delay\nDESCRIPTION: A helper function to present different PTerm features in a structured way. It displays a header using PTerm, waits briefly, executes a provided function ('content') which is expected to display something using PTerm, waits for a specified duration, and finally clears the screen. Requires 'pterm' and 'time' packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc showcase(title string, seconds int, content func()) {\n\tpterm.DefaultHeader.WithBackgroundStyle(pterm.NewStyle(pterm.BgLightBlue)).WithFullWidth().Println(title)\n\tpterm.Println()\n\ttime.Sleep(second / 2)\n\tcontent()\n\ttime.Sleep(second * time.Duration(seconds))\n\tprint(\"\\033[H\\033[2J\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Default Area in PTerm for Dynamic Content Updates in Go\nDESCRIPTION: Demonstrates the basic usage of PTerm's DefaultArea to create a dynamically updating area in the terminal. The example shows a counter that updates every second for 5 iterations.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area and get a reference to it.\n\t// The second return value is an error which is ignored here.\n\tarea, _ := pterm.DefaultArea.Start()\n\n\t// Loop 5 times\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area dynamically.\n\t\t// Here we're just displaying the current count.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\t// This will clean up and free resources used by the area.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Progress Bar Updates with Stepwise Downloads using PTerm in Go\nDESCRIPTION: This snippet shows how to simulate a sequence of downloads using a PTerm progress bar in Go. A progress bar is initialized to match the number of pseudo applications, the bar updates its title and progress for each faux download, and enhanced behavior is shown for specific steps (e.g., longer sleep for item 7). Dependencies: github.com/pterm/pterm and standard libraries. Expects no input and outputs progress and status messages to the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_56\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\n// Slice of strings representing names of pseudo applications to be downloaded.\nvar fakeInstallList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-dops pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\t// Create a progressbar with the total steps equal to the number of items in fakeInstallList.\n\t// Set the initial title of the progressbar to \"Downloading stuff\".\n\tp, _ := pterm.DefaultProgressbar.WithTotal(len(fakeInstallList)).WithTitle(\"Downloading stuff\").Start()\n\n\t// Loop over each item in the fakeInstallList.\n\tfor i := 0; i < p.Total; i++ {\n\t\t// Simulate a slow download for the 7th item.\n\t\tif i == 6 {\n\t\t\ttime.Sleep(time.Second * 3)\n\t\t}\n\n\t\t// Update the title of the progressbar with the current item being downloaded.\n\t\tp.UpdateTitle(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Print a success message for the current download. This will be printed above the progressbar.\n\t\tpterm.Success.Println(\"Downloading \" + fakeInstallList[i])\n\n\t\t// Increment the progressbar by one to indicate progress.\n\t\tp.Increment()\n\n\t\t// Pause for 350 milliseconds to simulate the time taken for each download.\n\t\ttime.Sleep(time.Millisecond * 350)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Centering Terminal Output with pterm in Go\nDESCRIPTION: This Go program demonstrates centering text in the terminal using the pterm library. It first prints a multi-line string centered as a single block using `pterm.DefaultCenter.Println`. Then, it generates large ASCII text using `pterm.DefaultBigText` and centers that output. Finally, it shows how to center each line of a multi-line string individually using `pterm.DefaultCenter.WithCenterEachLineSeparately().Println`. The program requires the `pterm` library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/center/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print a block of text centered in the terminal\n\tpterm.DefaultCenter.Println(\"This text is centered!\\nIt centers the whole block by default.\\nIn that way you can do stuff like this:\")\n\n\t// Generate BigLetters and store in 's'\n\ts, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Srender()\n\n\t// Print the BigLetters 's' centered in the terminal\n\tpterm.DefaultCenter.Println(s)\n\n\t// Print each line of the text separately centered in the terminal\n\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(\"This text is centered!\\nBut each line is\\ncentered\\nseparately\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Box Layouts with Panels in Go using pterm\nDESCRIPTION: This Go snippet demonstrates creating a complex layout using pterm. It initializes several boxes (`pterm.DefaultBox`), some with titles (`WithTitle`, `WithTitleBottomCenter`), and arranges them into a grid using `pterm.DefaultPanel.WithPanels`. The final layout is rendered (`Srender`) and printed inside another box with a bottom-right title (`WithTitleBottomRight`).\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"This might not be rendered correctly on GitHub,\\nbut it will work in a real terminal.\\nThis is because GitHub does not use a monospaced font by default for SVGs\")\n\n\t// Create three panels with text, some of them with titles.\n\t// The panels are created using the DefaultBox style.\n\tpanel1 := pterm.DefaultBox.Sprint(\"Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit,\\nsed do eiusmod tempor incididunt\\nut labore et dolore\\nmagna aliqua.\")\n\tpanel2 := pterm.DefaultBox.WithTitle(\"title\").Sprint(\"Ut enim ad minim veniam,\\nquis nostrud exercitation\\nullamco laboris\\nnisi ut aliquip\\nex ea commodo\\nconsequat.\")\n\tpanel3 := pterm.DefaultBox.WithTitle(\"bottom center title\").WithTitleBottomCenter().Sprint(\"Duis aute irure\\ndolor in reprehenderit\\nin voluptate velit esse cillum\\ndolore eu fugiat\\nnulla pariatur.\")\n\n\t// Combine the panels into a layout using the DefaultPanel style.\n\t// The layout is a 2D grid, with each row being an array of panels.\n\t// In this case, the first row contains panel1 and panel2, and the second row contains only panel3.\n\tpanels, _ := pterm.DefaultPanel.WithPanels(pterm.Panels{\n\t\t{{Data: panel1}, {Data: panel2}},\n\t\t{{Data: panel3}},\n\t}).Srender()\n\n\t// Print the panels layout inside a box with a title.\n\t// The box is created using the DefaultBox style, with the title positioned at the bottom right.\n\tpterm.DefaultBox.WithTitle(\"Lorem Ipsum\").WithTitleBottomRight().WithRightPadding(0).WithBottomPadding(0).Println(panels)\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing CSV to TableData - PTerm PUtils - Go\nDESCRIPTION: Parses a comma-separated values (CSV) string into the PTerm TableData structure, suitable for printing tables.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_14\n\nLANGUAGE: Go\nCODE:\n```\nfunc TableDataFromCSV(csv string) (td pterm.TableData)\n```\n\n----------------------------------------\n\nTITLE: Printing Informational Messages and Boxed Panels Using Pterm in Go\nDESCRIPTION: This snippet shows how to use the Pterm library in Go to print informational messages and create multiple panels styled with DefaultBox. Panels are optionally titled and positioned with customizable title locations. The panels are then combined into a 2D grid layout using the DefaultPanel style, and the final grouped panels are printed inside a titled box with the title positioned at the bottom right. Key functions include Info.Println for messages, DefaultBox.Sprint to create box-styled text blocks, WithTitle and WithTitleBottomCenter for titling options, and DefaultPanel.WithPanels to arrange multiple panels. The snippet requires the \"github.com/pterm/pterm\" package and targets terminal environments supporting Pterm's styling capabilities.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"This might not be rendered correctly on GitHub,\\nbut it will work in a real terminal.\\nThis is because GitHub does not use a monospaced font by default for SVGs\")\n\n\t// Create three panels with text, some of them with titles.\n\t// The panels are created using the DefaultBox style.\n\tpanel1 := pterm.DefaultBox.Sprint(\"Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit,\\nsed do eiusmod tempor incididunt\\nut labore et dolore\\nmagna aliqua.\")\n\tpanel2 := pterm.DefaultBox.WithTitle(\"title\").Sprint(\"Ut enim ad minim veniam,\\nquis nostrud exercitation\\nullamco laboris\\nnisi ut aliquip\\nex ea commodo\\nconsequat.\")\n\tpanel3 := pterm.DefaultBox.WithTitle(\"bottom center title\").WithTitleBottomCenter().Sprint(\"Duis aute irure\\ndolor in reprehenderit\\nin voluptate velit esse cillum\\ndolore eu fugiat\\nnulla pariatur.\")\n\n\t// Combine the panels into a layout using the DefaultPanel style.\n\t// The layout is a 2D grid, with each row being an array of panels.\n\t// In this case, the first row contains panel1 and panel2, and the second row contains only panel3.\n\tpanels, _ := pterm.DefaultPanel.WithPanels(pterm.Panels{\n\t\t{{Data: panel1}, {Data: panel2}},\n\t\t{{Data: panel3}},\n\t}).Srender()\n\n\t// Print the panels layout inside a box with a title.\n\t// The box is created using the DefaultBox style, with the title positioned at the bottom right.\n\tpterm.DefaultBox.WithTitle(\"Lorem Ipsum\").WithTitleBottomRight().WithRightPadding(0).WithBottomPadding(0).Println(panels)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing TextPrinter Template in Go\nDESCRIPTION: A template for creating a new TextPrinter in PTerm. It includes the basic structure with methods like Sprint, Sprintln, Sprintf, Print, Println, and Printf that need to be implemented for any text printer.\nSOURCE: https://github.com/pterm/pterm/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage pterm\n\ntype TemplatePrinter struct{\n\t// TODO: Add printer settings here\n}\n\n// Sprint formats using the default formats for its operands and returns the resulting string.\n// Spaces are added between operands when neither is a string.\nfunc (p TemplatePrinter) Sprint(a ...any) string {\n\tpanic(\"write printer code here\")\n}\n\n// Sprintln formats using the default formats for its operands and returns the resulting string.\n// Spaces are always added between operands and a newline is appended.\nfunc (p TemplatePrinter) Sprintln(a ...any) string {\n\treturn Sprintln(p.Sprint(a...))\n}\n\n// Sprintf formats according to a format specifier and returns the resulting string.\nfunc (p TemplatePrinter) Sprintf(format string, a ...any) string {\n\treturn p.Sprint(Sprintf(format, a...))\n}\n\n// Print formats using the default formats for its operands and writes to standard output.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\nfunc (p TemplatePrinter) Print(a ...any) *TextPrinter {\n\tPrint(p.Sprint(a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n\n// Println formats using the default formats for its operands and writes to standard output.\n// Spaces are always added between operands and a newline is appended.\n// It returns the number of bytes written and any write error encountered.\nfunc (p TemplatePrinter) Println(a ...any) *TextPrinter {\n\tPrintln(p.Sprint(a...))\n    tp := TextPrinter(p)\n    return &tp\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\nfunc (p TemplatePrinter) Printf(format string, a ...any) *TextPrinter {\n\tPrint(p.Sprintf(format, a...))\n\ttp := TextPrinter(p)\n\treturn &tp\n}\n```\n\n----------------------------------------\n\nTITLE: Converting HEX to PTerm RGB - PTerm PUtils - Go\nDESCRIPTION: Converts a hexadecimal color string (e.g., \"#FF0000\") into a PTerm RGB structure. Returns the RGB color and an error if the conversion fails.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\nfunc RGBFromHEX(hex string) (pterm.RGB, error)\n```\n\n----------------------------------------\n\nTITLE: Creating a Right-Aligned Table in Go using PTerm\nDESCRIPTION: Shows how to create a table with right-aligned text in all cells using the PTerm library. The example defines table data with headers and rows and applies right alignment to all cells.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_74\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and the text in the cells is right-aligned.\n\t// The Render() method is used to print the table to the console.\n\tpterm.DefaultTable.WithHasHeader().WithRightAlignment().WithData(tableData).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Heatmap Colors Without RGB in pterm Using Go\nDESCRIPTION: This example illustrates how to customize heatmap colors using predefined background colors instead of RGB, making the output compatible with all terminals. It disables boxed styling, disables the legend, and sets axis labels. The snippet also includes an informational print message before rendering. Dependencies include pterm for rendering with custom colors. Inputs are a 2D float32 slice for data and axis labels; output is a colored heatmap without RGB colors.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, and render it\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithLegend(false).\n\t\tWithColors(pterm.BgBlue, pterm.BgRed, pterm.BgGreen, pterm.BgYellow).\n\t\tWithLegend().\n\t\tRender()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a PTerm Heatmap Without Grid in Go\nDESCRIPTION: This snippet demonstrates how to create a heatmap visualization without grid lines using the PTerm library. It defines numerical data, configures axis labels, and renders a heatmap with RGB colors, a legend, and disabled grid lines.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/no_grid/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis data for the heatmap.\n\taxisData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, then render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(axisData).WithEnableRGB().WithLegend().WithGrid(false).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering Tables with Headers Using pterm in Go\nDESCRIPTION: This snippet defines two separate tables with headers and data, then renders them using pterm's DefaultTable configuration. The first table includes various sample data with an empty note field, while the second table demonstrates multiline cell entries. The purpose is to showcase how to initialize tables, assign headers and data, and display them in a command-line interface.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/table/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the first table\n\ttableData1 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData1).Render()\n\n\tpterm.Println() // Blank line\n\n\t// Define the data for the second table\n\ttableData2 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create another table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData2).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Controlling Terminal Output with PTerm in Go\nDESCRIPTION: Demonstrates how to disable and enable terminal output dynamically during a loop using PTerm's DisableOutput and EnableOutput functions. The program prints progress messages and conditionally suspends printing to the terminal when disabled. It requires the PTerm library and is useful for temporarily suppressing output during execution.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_27\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Loop from 0 to 14\n\tfor i := 0; i < 15; i++ {\n\t\tswitch i {\n\t\tcase 5:\n\t\t\t// At the 5th iteration, print a message and disable the output\n\t\t\tpterm.Info.Println(\"Disabled Output!\")\n\t\t\tpterm.DisableOutput()\n\t\tcase 10:\n\t\t\t// At the 10th iteration, enable the output and print a message\n\t\t\tpterm.EnableOutput()\n\t\t\tpterm.Info.Println(\"Enabled Output!\")\n\t\t}\n\n\t\t// Print a progress message for each iteration\n\t\tpterm.Printf(\"Printing something... [%d/%d]\\n\", i, 15)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Padding to Boxes with PTerm in Go\nDESCRIPTION: This Go snippet shows how to create a box with custom padding on all sides using the PTerm DefaultBox component. Method chaining is used to set right, left, top, and bottom padding before printing 'Hello, World!' inside the box. Requires importing PTerm. No additional parameters are required except for the content to print. The box output is displayed in a terminal, giving extra space around the content as specified by padding values.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_20\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with custom padding options and print \"Hello, World!\" inside it.\n\tpterm.DefaultBox.WithRightPadding(10).WithLeftPadding(10).WithTopPadding(2).WithBottomPadding(2).Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Use Custom RGB Color Range for Heatmap using pterm Go\nDESCRIPTION: This snippet demonstrates how to define and apply a custom range of RGB colors for the pterm heatmap. This allows for more granular control over the color mapping of data values compared to the default color spectrum. Note that RGB support is terminal-dependent.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_40\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\taxisLabels := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Define the color range for the heatmap.\n\trgbRange := []pterm.RGB{\n\t\tpterm.NewRGB(0, 0, 255),\n\t\tpterm.NewRGB(255, 0, 0),\n\t\tpterm.NewRGB(0, 255, 0),\n\t\tpterm.NewRGB(255, 255, 0),\n\t}\n\n\t// Create and render the heatmap.\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(axisLabels).\n\t\tWithEnableRGB().\n\t\tWithRGBRange(rgbRange...).\n\t\tRender()\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Bullet List Styles with PTerm in Go\nDESCRIPTION: Demonstrates how to create a bullet list with custom bullet symbols and text styles for different levels using the PTerm library. Each bullet list item specifies a level, text content, custom bullet characters, and styles for bullet and text colors. The output is a styled, hierarchical bullet list. Dependencies include PTerm core. Inputs are a slice of BulletListItem structs; output is a rendered bullet list with styles.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_25\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different styles and levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{\n\t\t\tLevel:       0,                            // Level 0 (top level)\n\t\t\tText:        \"Blue\",                       // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgBlue), // Text color\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgRed),  // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       1,                                  // Level 1 (sub-item)\n\t\t\tText:        \"Green\",                            // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgGreen),      // Text color\n\t\t\tBullet:      \"-\",                                // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgLightWhite), // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       2,                              // Level 2 (sub-sub-item)\n\t\t\tText:        \"Cyan\",                         // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgCyan),   // Text color\n\t\t\tBullet:      \">\",                            // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgYellow), // Bullet color\n\t\t},\n\t}\n\n\t// Create a bullet list with the defined items and render it.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Heatmap Using pterm in Go\nDESCRIPTION: This snippet demonstrates how to create a simple heatmap using the pterm library in Go. It defines a 2D float32 slice to represent the heatmap data and specifies axis labels for both X and Y axes. The heatmap is rendered with RGB color support enabled. Required dependency is the pterm package. It expects the input data as rows of float32 values and outputs a rendered heatmap to the terminal with axis labels and RGB coloring.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap. Each sub-array represents a row in the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the labels for the X and Y axes of the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Create a heatmap with the defined data and axis labels, and enable RGB colors.\n\t// Then render the heatmap.\n\tpterm.DefaultHeatmap.WithAxisData(headerData).WithData(data).WithEnableRGB().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Dynamic Bar Chart in a Fullscreen Area with PTerm in Go\nDESCRIPTION: Creates a fullscreen centered area displaying a bar chart that updates dynamically. The bar chart displays four bars with different update patterns, refreshing every half second for 10 iterations.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen centered area.\n\t// This area will be used to display the bar chart.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\t// Ensure the area stops updating when we're done.\n\tdefer area.Stop()\n\n\t// Loop to update the bar chart 10 times.\n\tfor i := 0; i < 10; i++ {\n\t\t// Create a new bar chart with dynamic bars.\n\t\t// The bars will change based on the current iteration.\n\t\tbarchart := pterm.DefaultBarChart.WithBars(dynamicBars(i))\n\t\t// Render the bar chart to a string.\n\t\t// This string will be used to update the area.\n\t\tcontent, _ := barchart.Srender()\n\t\t// Update the area with the new bar chart.\n\t\tarea.Update(content)\n\t\t// Wait for half a second before the next update.\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\n// dynamicBars generates a set of bars for the bar chart.\n// The bars will change based on the current iteration.\nfunc dynamicBars(i int) pterm.Bars {\n\treturn pterm.Bars{\n\t\t{Label: \"A\", Value: 10},     // A static bar.\n\t\t{Label: \"B\", Value: 20 * i}, // A bar that grows with each iteration.\n\t\t{Label: \"C\", Value: 30},     // Another static bar.\n\t\t{Label: \"D\", Value: 40 + i}, // A bar that grows slowly with each iteration.\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Padding to Boxes in Go using pterm\nDESCRIPTION: This Go snippet shows how to customize the padding of a box using the pterm library. It utilizes `pterm.DefaultBox` and chains padding methods (`WithRightPadding`, `WithLeftPadding`, `WithTopPadding`, `WithBottomPadding`) before printing content within the box using `Println`.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with custom padding options and print \"Hello, World!\" inside it.\n\tpterm.DefaultBox.WithRightPadding(10).WithLeftPadding(10).WithTopPadding(2).WithBottomPadding(2).Println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Customize Heatmap Colors and Legend using pterm Go\nDESCRIPTION: This snippet demonstrates advanced customization of the pterm heatmap. It shows how to provide a specific set of standard terminal colors (non-RGB) to be used for the heatmap cells instead of the default spectrum. It also enables the display of a legend.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_38\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, and render it\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithLegend(false).\n\t\tWithColors(pterm.BgBlue, pterm.BgRed, pterm.BgGreen, pterm.BgYellow).\n\t\tWithLegend().\n\t\tRender()\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Dynamic Bar Chart in PTerm Fullscreen Centered Area in Go\nDESCRIPTION: This snippet combines PTerm's Area and BarChart features to display a bar chart that updates dynamically within a fullscreen and centered area. It defines a helper function `dynamicBars` to generate changing bar data, renders the bar chart to a string using `barchart.Srender()`, and updates the area's content with the rendered chart string.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen centered area.\n\t// This area will be used to display the bar chart.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\t// Ensure the area stops updating when we're done.\n\tdefer area.Stop()\n\n\t// Loop to update the bar chart 10 times.\n\tfor i := 0; i < 10; i++ {\n\t\t// Create a new bar chart with dynamic bars.\n\t\t// The bars will change based on the current iteration.\n\t\tbarchart := pterm.DefaultBarChart.WithBars(dynamicBars(i))\n\t\t// Render the bar chart to a string.\n\t\t// This string will be used to update the area.\n\t\tcontent, _ := barchart.Srender()\n\t\t// Update the area with the new bar chart.\n\t\tarea.Update(content)\n\t\t// Wait for half a second before the next update.\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\n// dynamicBars generates a set of bars for the bar chart.\n// The bars will change based on the current iteration.\nfunc dynamicBars(i int) pterm.Bars {\n\treturn pterm.Bars{\n\t\t{Label: \"A\", Value: 10},     // A static bar.\n\t\t{Label: \"B\", Value: 20 * i}, // A bar that grows with each iteration.\n\t\t{Label: \"C\", Value: 30},     // Another static bar.\n\t\t{Label: \"D\", Value: 40 + i}, // A bar that grows slowly with each iteration.\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an Area Demo with BigText Clock Display in Go\nDESCRIPTION: Creates a demo of PTerm's Area functionality by displaying a persistent info message while updating a BigText clock in a defined area. The clock updates every second for 10 iterations.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\ttime\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print an informational message using PTerm's Info printer.\n\t// This message will stay in place while the area updates.\n\tpterm.Info.Println(\"The previous text will stay in place, while the area updates.\")\n\n\t// Print two new lines as spacer.\n\tpterm.Print(\"\\n\\n\")\n\n\t// Start the Area printer from PTerm's DefaultArea, with the Center option.\n\t// The Area printer allows us to update a specific area of the console output.\n\t// The returned 'area' object is used to control the area updates.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 10 times to update the area with the current time.\n\tfor i := 0; i < 10; i++ {\n\t\t// Get the current time, format it as \"15:04:05\" (hour:minute:second), and convert it to a string.\n\t\t// Then, create a BigText from the time string using PTerm's DefaultBigText and putils NewLettersFromString.\n\t\t// The Srender() function is used to save the BigText as a string.\n\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender()\n\n\t\t// Update the Area contents with the current time string.\n\t\tarea.Update(str)\n\n\t\t// Sleep for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the Area printer after all updates are done.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Centering Text in the Terminal using PTerm in Go\nDESCRIPTION: This snippet defines a component for rendering text centered horizontally in the terminal. It measures the terminal width and pads the message left and right to centralize the output. Dependencies include PTerm for managing output and querying terminal dimensions. Function accepts a string and optional padding, and prints the centered result. The output is the input text, visually centered in the terminal window.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\n// CenterPrinter prints centered text\nfunc (c *CenterPrinter) Render(message string) error {\n\twidth := pterm.GetTerminalWidth()\n\tpadding := (width - len(message)) / 2\n\tfmt.Printf(\"%s%s\\n\", strings.Repeat(\" \", padding), message)\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Box with Custom Padding in Go using PTerm\nDESCRIPTION: This snippet demonstrates how to use PTerm to create a box with custom padding values on all sides. It imports the PTerm library and uses the DefaultBox object with chained padding methods to configure spacing around the text content.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/custom-padding/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with custom padding options and print \"Hello, World!\" inside it.\n\tpterm.DefaultBox.WithRightPadding(10).WithLeftPadding(10).WithTopPadding(2).WithBottomPadding(2).Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing and managing a fullscreen area using pterm in Go\nDESCRIPTION: This code snippet shows how to create a fullscreen area using the pterm library in Go, update its content dynamically in a loop with delays, and finally stop the area. It requires the pterm package and utilizes time.Sleep for timing control. The example demonstrates real-time terminal interface updates with simple string formatting.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/fullscreen/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen area. This will return an area instance and an error.\n\t// The underscore (_) is used to ignore the error.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().Start()\n\n\t// Loop 5 times to update the area content.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Panels with PTerm in Go\nDESCRIPTION: Shows how to create and render panels arranged in a 2D grid using the PTerm library. The example initializes panels containing strings, including multiline content and colored text, places them into a nested 2D slice, and renders them with padding applied. The main dependency is the \"github.com/pterm/pterm\" package. Inputs are panel data strings, some formatted with colors or headers, and output is a formatted panel display in the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_59\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define panels in a 2D grid system\n\tpanels := pterm.Panels{\n\t\t{\n\t\t\t{Data: \"This is the first panel\"},\n\t\t\t{Data: pterm.DefaultHeader.Sprint(\"Hello, World!\")},\n\t\t\t{Data: \"This\\npanel\\ncontains\\nmultiple\\nlines\"},\n\t\t},\n\t\t{\n\t\t\t{Data: pterm.Red(\"This is another\\npanel line\")},\n\t\t\t{Data: \"This is the second panel\\nwith a new line\"},\n\t\t},\n\t}\n\n\t// Render the panels with a padding of 5\n\t_ = pterm.DefaultPanel.WithPanels(panels).WithPadding(5).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Custom Padding with Box Printer in PTerm for Go\nDESCRIPTION: Shows how to create a single boxed message in the terminal with custom padding on all sides using PTerm. The DefaultBox object is configured using WithRightPadding, WithLeftPadding, WithTopPadding, and WithBottomPadding to surround 'Hello, World!' with extra space. The Println function outputs the padded box. Input: raw string for content. Output: visually padded ASCII/Unicode box. Dependencies: github.com/pterm/pterm. Intended for visually highlighting text within the CLI with spacing customization.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with custom padding options and print \"Hello, World!\" inside it.\n\tpterm.DefaultBox.WithRightPadding(10).WithLeftPadding(10).WithTopPadding(2).WithBottomPadding(2).Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating Fullscreen Centered Area - PTerm - Go\nDESCRIPTION: This Go snippet shows how to use PTerm's Area printer to create an area that occupies the full terminal and is centered within it. It starts the area, loops 5 times, and updates the area's content with a message displaying a counter and a fixed line. A one-second pause is included between updates. The area is stopped when the loop completes.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/README.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize a new PTerm area with fullscreen and center options\n\t// The Start() function returns the created area and an error (ignored here)\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\n\t// Loop 5 times to demonstrate dynamic content update\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count\n\t\t// The Sprintf function is used to format the string with the count\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done\n\t// This will clear the area and return the terminal to its normal state\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Color Tables with PTerm in Go\nDESCRIPTION: Demonstrates how to create a table with different foreground and background colors using PTerm. The example also shows how to print colored text with nested color combinations and create custom styles with multiple properties.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a table with different foreground and background colors.\n\tpterm.DefaultTable.WithData([][]string{\n\t\t{pterm.FgBlack.Sprint(\"Black\"), pterm.FgRed.Sprint(\"Red\"), pterm.FgGreen.Sprint(\"Green\"), pterm.FgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.FgLightRed.Sprint(\"Light Red\"), pterm.FgLightGreen.Sprint(\"Light Green\"), pterm.FgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.BgBlack.Sprint(\"Black\"), pterm.BgRed.Sprint(\"Red\"), pterm.BgGreen.Sprint(\"Green\"), pterm.BgYellow.Sprint(\"Yellow\")},\n\t\t{\"\", pterm.BgLightRed.Sprint(\"Light Red\"), pterm.BgLightGreen.Sprint(\"Light Green\"), pterm.BgLightYellow.Sprint(\"Light Yellow\")},\n\t\t{pterm.FgBlue.Sprint(\"Blue\"), pterm.FgMagenta.Sprint(\"Magenta\"), pterm.FgCyan.Sprint(\"Cyan\"), pterm.FgWhite.Sprint(\"White\")},\n\t\t{pterm.FgLightBlue.Sprint(\"Light Blue\"), pterm.FgLightMagenta.Sprint(\"Light Magenta\"), pterm.FgLightCyan.Sprint(\"Light Cyan\"), pterm.FgLightWhite.Sprint(\"Light White\")},\n\t\t{pterm.BgBlue.Sprint(\"Blue\"), pterm.BgMagenta.Sprint(\"Magenta\"), pterm.BgCyan.Sprint(\"Cyan\"), pterm.BgWhite.Sprint(\"White\")},\n\t\t{pterm.BgLightBlue.Sprint(\"Light Blue\"), pterm.BgLightMagenta.Sprint(\"Light Magenta\"), pterm.BgLightCyan.Sprint(\"Light Cyan\"), pterm.BgLightWhite.Sprint(\"Light White\")},\n\t}).Render() // Render the table.\n\n\tpterm.Println()\n\n\t// Print words in different colors.\n\tpterm.Println(pterm.Red(\"Hello, \") + pterm.Green(\"World\") + pterm.Cyan(\"!\"))\n\tpterm.Println(pterm.Red(\"Even \" + pterm.Cyan(\"nested \") + pterm.Green(\"colors \") + \"are supported!\"))\n\n\tpterm.Println()\n\n\t// Create a new style with a red background, light green foreground, and bold text.\n\tstyle := pterm.NewStyle(pterm.BgRed, pterm.FgLightGreen, pterm.Bold)\n\t// Print text using the created style.\n\tstyle.Println(\"This text uses a style and is bold and light green with a red background!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Error Printer Prefix in PTerm with Go\nDESCRIPTION: Shows how to override the default prefix of PTerm's error printer by setting a custom prefix text and style. The example prints an error message before and after overriding the prefix to illustrate the effect. Depends on the PTerm library for terminal styling.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_31\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default error message with PTerm's built-in Error style.\n\tpterm.Error.Println(\"This is the default Error\")\n\n\t// Override the default error prefix with a new text and style.\n\tpterm.Error.Prefix = pterm.Prefix{Text: \"OVERRIDE\", Style: pterm.NewStyle(pterm.BgCyan, pterm.FgRed)}\n\n\t// Print the error message again, this time with the overridden prefix.\n\tpterm.Error.Println(\"This is the default Error after the prefix was overridden\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Centered Dynamic Area in Go using PTerm\nDESCRIPTION: Demonstrates how to create a centered area in the terminal that dynamically updates its content. The area displays a counter that increments every second for 5 iterations.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area in the center of the terminal.\n\t// The Start() function returns the created area and an error.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 5 times to simulate a dynamic update.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second to simulate a time-consuming task.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fullscreen Dynamic Area in Go with PTerm\nDESCRIPTION: Demonstrates how to create a fullscreen area that updates dynamically. The example shows a counter that increments every second for 5 iterations, displaying the updated content in a fullscreen area.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen area. This will return an area instance and an error.\n\t// The underscore (_) is used to ignore the error.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().Start()\n\n\t// Loop 5 times to update the area content.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Tree Structure in Go using PTerm\nDESCRIPTION: Shows how to create a hierarchical tree structure with PTerm. The example defines a tree with a top node, child node, and several grandchild nodes, then renders it with the default tree renderer.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_76\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a tree structure using pterm.TreeNode\n\ttree := pterm.TreeNode{\n\t\t// The top node of the tree\n\t\tText: \"Top node\",\n\t\t// The children of the top node\n\t\tChildren: []pterm.TreeNode{{\n\t\t\t// A child node\n\t\t\tText: \"Child node\",\n\t\t\t// The children of the child node\n\t\t\tChildren: []pterm.TreeNode{\n\t\t\t\t// Grandchildren nodes\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t\t{Text: \"Grandchild node\"},\n\t\t\t},\n\t\t}},\n\t}\n\n\t// Render the tree with the defined structure as the root\n\tpterm.DefaultTree.WithRoot(tree).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Section Headers and Info Messages with PTerm in Go\nDESCRIPTION: This Go code demonstrates initializing a CLI application using the PTerm library to print formatted section headers and informational messages. The snippet depends on importing \"github.com/pterm/pterm\" and requires Go Modules for package management. Section headers are created with DefaultSection.Print or DefaultSection.WithLevel(level).Println, while Info.Println outputs styled informational text. Inputs are static string messages; outputs are styled text in the terminal. Useful for improving console application UX, this example is limited to simple output formatting without interactive features.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/section/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a section with level one and print it.\n\tpterm.DefaultSection.Println(\"This is a section!\")\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"And here is some text.\\nThis text could be anything.\\nBasically it's just a placeholder\")\n\n\t// Create a section with level two and print it.\n\tpterm.DefaultSection.WithLevel(2).Println(\"This is another section!\")\n\n\t// Print another informational message.\n\tpterm.Info.Println(\"And this is\\nmore placeholder text\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Bullet Lists With PTerm in Go\nDESCRIPTION: This snippet demonstrates two methods for displaying hierarchical bullet lists using PTerm in Go: first by creating explicit BulletListItem entries with levels and then by parsing a multi-line string with indentation. It uses both DefaultBulletList for rendering and putils.BulletListFromString for conversion from string to list. Key inputs are the items or string, and outputs are indented, stylized bullet lists rendered in the terminal. Dependencies include both 'github.com/pterm/pterm' and 'github.com/pterm/pterm/putils'.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_23\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{Level: 0, Text: \"Level 0\"}, // Level 0 item\n\t\t{Level: 1, Text: \"Level 1\"}, // Level 1 item\n\t\t{Level: 2, Text: \"Level 2\"}, // Level 2 item\n\t}\n\n\t// Use the default bullet list style to render the list items.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n\n\t// Define a string with different levels of indentation.\n\ttext := `0\n 1\n  2\n   3`\n\n\t// Convert the indented string to a bullet list and render it.\n\tputils.BulletListFromString(text, \" \").Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering a Bar Chart with Visible Values in Go using PTerm\nDESCRIPTION: This code snippet demonstrates how to create a bar chart with visible numerical values for each bar. It defines a slice of Bar structs with Label and Value properties, then renders them using PTerm's DefaultBarChart with the WithShowValue option enabled.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/show-value/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of bars for the bar chart. Each bar is represented by a struct\n\t// with a Label and a Value. The Label is a string that represents the name of the bar,\n\t// and the Value is an integer that represents the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined bars using the DefaultBarChart object from PTerm.\n\t// Chain the WithBars method to set the bars of the chart.\n\t// Chain the WithShowValue method to display the value of each bar on the chart.\n\t// Finally, call the Render method to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Printing a Simple Default Box in Go using pterm\nDESCRIPTION: This Go snippet demonstrates the most basic usage of the pterm box component. It imports the `pterm` library and uses `pterm.DefaultBox.Println` to print a simple string enclosed within a default styled box to the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with PTerm and print a message in it.\n\t// The DefaultBox.Println method automatically starts, prints the message, and stops the box.\n\tpterm.DefaultBox.Println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Default Box with PTerm in Go\nDESCRIPTION: This Go example illustrates how to print a basic box around a message using PTerm's DefaultBox.Println method. It requires only the PTerm library with DefaultBox imported, and prints 'Hello, World!' inside a standard bordered box. No custom styling or additional parameters are used, showing the minimal implementation for boxed terminal output. The box automatically manages layout and border drawing.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with PTerm and print a message in it.\n\t// The DefaultBox.Println method automatically starts, prints the message, and stops the box.\n\tpterm.DefaultBox.Println(\"Hello, World!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Constructing and Rendering a Tree Structure Using pterm in Go\nDESCRIPTION: This snippet defines a hierarchical tree structure with a root node, a child, and multiple grandchildren using pterm.TreeNode, then renders the tree with pterm's rendering functions. Dependencies include the pterm library, which must be imported. The main function initializes the tree and displays it in the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/tree/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a tree structure using pterm.TreeNode\n\t tree := pterm.TreeNode{\n\t\t// The top node of the tree\n\t\t Text: \"Top node\",\n\t\t// The children of the top node\n\t\t Children: []pterm.TreeNode{{\n\t\t\t// A child node\n\t\t\t Text: \"Child node\",\n\t\t\t// The children of the child node\n\t\t\t Children: []pterm.TreeNode{\n\t\t\t\t// Grandchildren nodes\n\t\t\t\t {Text: \"Grandchild node\"},\n\t\t\t\t {Text: \"Grandchild node\"},\n\t\t\t\t {Text: \"Grandchild node\"},\n\t\t\t },\n\t\t }},\n\n\t// Render the tree with the defined structure as the root\n\t pterm.DefaultTree.WithRoot(tree).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Mixed Value BarCharts (Vertical and Horizontal) with PTerm in Go\nDESCRIPTION: This code shows how to create bar charts using PTerm, supporting both positive and negative values. The example builds both vertical and horizontal bar charts from an array of labeled bars with mixed positive and negative values. PTerm's WithShowValue property displays each bar's value directly on the chart, and Render is called on each. pterm.DefaultSection.Println is used to add a descriptive header. Prerequisite: PTerm must be installed. Input is any []pterm.Bar with integer values. Output is a bar chart in the terminal. Constraints: Visualization can become awkward if positive/negative values are disproportionate.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_13\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars for the chart.\n\t// Each bar has a label and a value.\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 2},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Bar 3\", Value: -2},\n\t\t{Label: \"Bar 4\", Value: 5},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print a section header.\n\t// This is useful for separating different parts of the output.\n\tpterm.DefaultSection.Println(\"Chart example with mixed values (note screen space usage in case when ABSOLUTE values of negative and positive parts are differ too much)\")\n\n\t// Create a bar chart with the defined bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering Bullet Lists with Default Styling in pterm (Go)\nDESCRIPTION: This snippet illustrates defining a simple bullet list with multiple indentation levels and converting an indented string into a bullet list using pterm's default style. Dependencies include the 'pterm' package and its utilities. The code demonstrates setting up list items with different levels and rendering the list accordingly. It also shows converting an indented string into a bullet list for rendering.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bulletlist/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{Level: 0, Text: \"Level 0\"}, // Level 0 item\n\t\t{Level: 1, Text: \"Level 1\"}, // Level 1 item\n\t\t{Level: 2, Text: \"Level 2\"}, // Level 2 item\n\t}\n\n\t// Use the default bullet list style to render the list items.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n\n\t// Define a string with different levels of indentation.\n\ttext := `0\n 1\n  2\n   3`\n\n\t// Convert the indented string to a bullet list and render it.\n\tputils.BulletListFromString(text, \" \").Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Long Text with pterm Paragraph Printer (Go)\nDESCRIPTION: This Go code demonstrates the `pterm.DefaultParagraph` printer's ability to wrap long text at word boundaries for better readability. It contrasts this with the standard `pterm.Println` function, which does not provide intelligent wrapping. The code imports the `pterm` library and uses its default paragraph printer and standard print function to output example text strings.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/paragraph/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Using the default paragraph printer to print a long text.\n\t// The text is split at the spaces, which is useful for continuous text of all kinds.\n\t// The line width can be manually adjusted if needed.\n\tpterm.DefaultParagraph.Println(\"This is the default paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n\n\t// Printing a line space for separation.\n\tpterm.Println()\n\n\t// Printing a long text without using the paragraph printer.\n\t// The default Println() function is used here, which does not provide intelligent splitting.\n\tpterm.Println(\"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\")\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Styled Headers in Go for Terminal Output\nDESCRIPTION: This snippet defines header printers to render styled header text blocks in terminal applications using Go. It commonly uses Go’s string manipulation and styling utilities. Key parameters include text content, styles/colors, and formatting width. Inputs are strings for header lines, while outputs are prominently styled headers for CLI output. It improves readability and structure by differentiating header text from regular output with formatting enhancements.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/header_printer.go:35.67,38.2\ngithub.com/pterm/pterm/header_printer.go:41.73,44.2\ngithub.com/pterm/pterm/header_printer.go:47.62,50.2\ngithub.com/pterm/pterm/header_printer.go:53.64,56.2\ngithub.com/pterm/pterm/header_printer.go:59.74,62.2\ngithub.com/pterm/pterm/header_printer.go:66.56,67.15\ngithub.com/pterm/pterm/header_printer.go:71.2,71.24\ngithub.com/pterm/pterm/header_printer.go:74.2,74.30\ngithub.com/pterm/pterm/header_printer.go:78.2,85.17\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts with Mixed Positive and Negative Values Using PTerm in Go\nDESCRIPTION: Illustrates rendering bar charts containing both positive and negative values, demonstrating how PTerm handles bars extending in opposite directions. Bars are defined with labels and values, including negative numbers. Uses DefaultBarChart with WithBars and WithShowValue to render charts both vertically and horizontally (using WithHorizontal). Requires 'github.com/pterm/pterm'. Outputs bar charts that clearly display negative and positive bar values with corresponding labels.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_12\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars for the chart.\n\t// Each bar has a label and a value.\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 2},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Bar 3\", Value: -2},\n\t\t{Label: \"Bar 4\", Value: 5},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print a section header.\n\t// This is useful for separating different parts of the output.\n\tpterm.DefaultSection.Println(\"Chart example with mixed values (note screen space usage in case when ABSOLUTE values of negative and positive parts are differ too much)\")\n\n\t// Create a bar chart with the defined bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The chart will display the value of each bar.\n\t// The Render() function is called to display the chart.\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Converting Leveled List to Directory Tree and Rendering with Pterm in Go\nDESCRIPTION: This Go snippet defines a leveled list where each item has a nesting level and text representing directory names. It uses the putils.TreeFromLeveledList function from the Pterm library to transform this flat hierarchy into a tree data structure. After setting the root node's text, it renders the tree using pterm.DefaultTree's Render method, which prints the directory structure visually in the terminal. The snippet requires the Pterm library and its utilities packages. Expected input is a slice of pterm.LeveledListItem specifying levels and texts; the output is a printed tree structure. No special error handling or constraints are present in this simple example.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/tree/from-leveled-list/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a leveled list to represent the structure of the directories.\n\tleveledList := pterm.LeveledList{\n\t\t{Level: 0, Text: \"C:\"},\n\t\t{Level: 1, Text: \"Users\"},\n\t\t{Level: 1, Text: \"Windows\"},\n\t\t{Level: 1, Text: \"Programs\"},\n\t\t{Level: 1, Text: \"Programs(x86)\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 0, Text: \"D:\"},\n\t\t{Level: 0, Text: \"E:\"},\n\t\t{Level: 1, Text: \"Movies\"},\n\t\t{Level: 1, Text: \"Music\"},\n\t\t{Level: 2, Text: \"LinkinPark\"},\n\t\t{Level: 1, Text: \"Games\"},\n\t\t{Level: 2, Text: \"Shooter\"},\n\t\t{Level: 3, Text: \"CallOfDuty\"},\n\t\t{Level: 3, Text: \"CS:GO\"},\n\t\t{Level: 3, Text: \"Battlefield\"},\n\t\t{Level: 4, Text: \"Battlefield 1\"},\n\t\t{Level: 4, Text: \"Battlefield 2\"},\n\t\t{Level: 0, Text: \"F:\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 2, Text: \"dops\"},\n\t\t{Level: 2, Text: \"PTerm\"},\n\t}\n\n\t// Convert the leveled list into a tree structure.\n\troot := putils.TreeFromLeveledList(leveledList)\n\troot.Text = \"Computer\" // Set the root node text.\n\n\t// Render the tree structure using the default tree printer.\n\tpterm.DefaultTree.WithRoot(root).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Concurrent Spinners in PTerm\nDESCRIPTION: Shows how to display multiple spinners simultaneously using PTerm's MultiPrinter. The example creates three spinners and resolves them one by one with different status messages (success, fail, warning) while maintaining concurrent display.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_68\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a multi printer. This allows multiple spinners to print simultaneously.\n\tmulti := pterm.DefaultMultiPrinter\n\n\t// Create and start spinner 1 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 1\".\n\tspinner1, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 1\")\n\n\t// Create and start spinner 2 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 2\".\n\tspinner2, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 2\")\n\n\t// Create and start spinner 3 with a new writer from the multi printer.\n\t// The spinner will display the message \"Spinner 3\".\n\tspinner3, _ := pterm.DefaultSpinner.WithWriter(multi.NewWriter()).Start(\"Spinner 3\")\n\n\t// Start the multi printer. This will start printing all the spinners.\n\tmulti.Start()\n\n\t// Wait for 1 second.\n\ttime.Sleep(time.Millisecond * 1000)\n\n\t// Stop spinner 1 with a success message.\n\tspinner1.Success(\"Spinner 1 is done!\")\n\n\t// Wait for 750 milliseconds.\n\ttime.Sleep(time.Millisecond * 750)\n\n\t// Stop spinner 2 with a failure message.\n\tspinner2.Fail(\"Spinner 2 failed!\")\n\n\t// Wait for 500 milliseconds.\n\ttime.Sleep(time.Millisecond * 500)\n\n\t// Stop spinner 3 with a warning message.\n\tspinner3.Warning(\"Spinner 3 has a warning!\")\n\n\t// Stop the multi printer. This will stop printing all the spinners.\n\tmulti.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Updating a Centered Terminal Area with Pterm in Go\nDESCRIPTION: This snippet illustrates the use of the Pterm library to create a centered terminal area that can dynamically update its content. It starts an area positioned at the center of the terminal, then iteratively updates this area five times with a formatted count message, and finally stops the area. Dependencies include the Pterm package and Go's standard time package. The main parameters involve the positional configuration of the area (centered) and the content string to update. Expected input is an internal loop counter, and output is a real-time terminal display update. Limitation: error handling for the area start is ignored (error discarded).\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/center/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new default area in the center of the terminal.\n\t// The Start() function returns the created area and an error.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 5 times to simulate a dynamic update.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second to simulate a time-consuming task.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Boxed Table Using PTerm in Go\nDESCRIPTION: This code illustrates how to render a boxed table with a header using the PTerm library in Go. The dependency is the \"github.com/pterm/pterm\" package. The snippet sets up the table data, specifies the boxed layout and header row, and renders the table. Key input is the predefined table data; output is a boxed table in terminal. All configuration is managed via method chaining on the PTerm Table object.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_65\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the table.\n\t// Each inner slice represents a row in the table.\n\t// The first row is considered as the header of the table.\n\ttableData := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with the defined data.\n\t// The table has a header and is boxed.\n\t// Finally, render the table to print it.\n\tpterm.DefaultTable.WithHasHeader().WithBoxed().WithData(tableData).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Key Styles in pterm Logger (Go)\nDESCRIPTION: This Go code snippet demonstrates how to customize the display styles for specific keys in log messages using the pterm library. It initializes a default logger, defines custom styles using `pterm.NewStyle`, overwrites existing key styles with `WithKeyStyles`, and appends a new style for a specific key using `AppendKeyStyle`. The example logs messages showing the applied styles.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/custom-key-styles/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Define a new style for the \"priority\" key.\n\tpriorityStyle := map[string]pterm.Style{\n\t\t\"priority\": *pterm.NewStyle(pterm.FgRed),\n\t}\n\n\t// Overwrite all key styles with the new map.\n\tlogger = logger.WithKeyStyles(priorityStyle)\n\n\t// Log an info message. The \"priority\" key will be displayed in red.\n\tlogger.Info(\"The priority key should now be red\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n\n\t// Define a new style for the \"foo\" key.\n\tfooStyle := *pterm.NewStyle(pterm.FgBlue)\n\n\t// Append the new style to the existing ones.\n\tlogger.AppendKeyStyle(\"foo\", fooStyle)\n\n\t// Log another info message. The \"foo\" key will be displayed in blue.\n\tlogger.Info(\"The foo key should now be blue\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Converting String to PTerm Letters with Style - PTerm PUtils - Go\nDESCRIPTION: Converts a string into PTerm Letters, applying a predefined PTerm Style to the characters. Allows custom styling beyond simple color.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\nfunc LettersFromStringWithStyle(text string, style *pterm.Style) pterm.Letters\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing a Fullscreen Centered Area in Go with PTerm\nDESCRIPTION: This snippet demonstrates how to initialize a fullscreen centered area using PTerm, update its content dynamically in a loop, and properly clean up when finished. It creates an area that displays a counter that increments every second, showing how terminal UIs can be updated in real-time.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/fullscreen-center/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize a new PTerm area with fullscreen and center options\n\t// The Start() function returns the created area and an error (ignored here)\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\n\t// Loop 5 times to demonstrate dynamic content update\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count\n\t\t// The Sprintf function is used to format the string with the count\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done\n\t// This will clear the area and return the terminal to its normal state\n\tarea.Stop()\n}\n```\n\n----------------------------------------\n\nTITLE: Updating pterm Area with Dynamic Bar Chart (Go)\nDESCRIPTION: This Go snippet initializes a fullscreen, centered pterm area and then enters a loop to repeatedly update a bar chart displayed within that area. The `dynamicBars` function generates changing data for the chart based on the loop iteration. The chart is rendered to a string and used to update the area, demonstrating dynamic visualization.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/dynamic-chart/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen centered area.\n\t// This area will be used to display the bar chart.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\t// Ensure the area stops updating when we're done.\n\tdefer area.Stop()\n\n\t// Loop to update the bar chart 10 times.\n\tfor i := 0; i < 10; i++ {\n\t\t// Create a new bar chart with dynamic bars.\n\t\t// The bars will change based on the current iteration.\n\t\tbarchart := pterm.DefaultBarChart.WithBars(dynamicBars(i))\n\t\t// Render the bar chart to a string.\n\t\t// This string will be used to update the area.\n\t\tcontent, _ := barchart.Srender()\n\t\t// Update the area with the new bar chart.\n\t\tarea.Update(content)\n\t\t// Wait for half a second before the next update.\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}\n\n// dynamicBars generates a set of bars for the bar chart.\n// The bars will change based on the current iteration.\nfunc dynamicBars(i int) pterm.Bars {\n\treturn pterm.Bars{\n\t\t{Label: \"A\", Value: 10},     // A static bar.\n\t\t{Label: \"B\", Value: 20 * i}, // A bar that grows with each iteration.\n\t\t{Label: \"C\", Value: 30},     // Another static bar.\n\t\t{Label: \"D\", Value: 40 + i}, // A bar that grows slowly with each iteration.\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Parsing TSV to TableData - PTerm PUtils - Go\nDESCRIPTION: Parses a tab-separated values (TSV) string into the PTerm TableData structure, ready for table printing.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_16\n\nLANGUAGE: Go\nCODE:\n```\nfunc TableDataFromTSV(csv string) (td pterm.TableData)\n```\n\n----------------------------------------\n\nTITLE: Creating Formatted Tables with PTerm\nDESCRIPTION: Shows how to create and display formatted tables using PTerm. The example creates two tables with headers: one containing basic contact information, and another demonstrating how newlines within cells are handled in the table rendering.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_70\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the first table\n\ttableData1 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\", \"Note\"},\n\t\t{\"Paul\", \"Dean\", \"augue@velitAliquam.co.uk\", \"\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\", \"这是一个测试, haha!\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\", \"just a test, hey!\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\", \"\"},\n\t}\n\n\t// Create a table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData1).Render()\n\n\tpterm.Println() // Blank line\n\n\t// Define the data for the second table\n\ttableData2 := pterm.TableData{\n\t\t{\"Firstname\", \"Lastname\", \"Email\"},\n\t\t{\"Paul\\n\\nNewline\", \"Dean\", \"augue@velitAliquam.co.uk\"},\n\t\t{\"Callie\", \"Mckay\", \"nunc.sed@est.com\\nNewline\"},\n\t\t{\"Libby\", \"Camacho\", \"lobortis@semper.com\"},\n\t\t{\"张\", \"小宝\", \"zhang@example.com\"},\n\t}\n\n\t// Create another table with a header and the defined data, then render it\n\tpterm.DefaultTable.WithHasHeader().WithData(tableData2).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Big Text Using pterm Library in Go\nDESCRIPTION: This Go code demonstrates how to render large stylized text in the terminal using the pterm library. It converts a string into letter components suitable for big text display and then renders it with default styling. Dependencies include github.com/pterm/pterm and github.com/pterm/pterm/putils; the code assumes these packages are installed. The key steps involve creating a string, transforming it into big letter format, and rendering the output. The program produces a stylized ASCII text display for the input string.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bigtext/default/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define the text to be rendered\n\tvar text = \"PTerm\"\n\n\t// Convert the text into a format suitable for PTerm\n\tvar letters = putils.LettersFromString(text)\n\n\t// Render the text using PTerm's default big text style\n\tpterm.DefaultBigText.WithLetters(letters).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Multiselect with Custom Checkmarks in PTerm - Go\nDESCRIPTION: Customizes the interactive multiselect prompt to use user-defined symbols for selected and unselected states ('+' in green for checked and '-' in red for unchecked). Shows the configuration and rendering of the multiselect with PTerm, without the filter enabled. Relies on github.com/pterm/pterm. Outputs the selected options in green. Suitable for UIs needing visual customization of selection states.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_46\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and define the checkmark symbols\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithCheckmark(&pterm.Checkmark{Checked: pterm.Green(\"+\"), Unchecked: pterm.Red(\"-\")})\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering a Heatmap with Custom Axis in PTerm - Go\nDESCRIPTION: Demonstrates how to render a heatmap in the terminal using PTerm in Go. It defines a 2D float32 data array and corresponding axis labels, disables RGB coloring, hides the legend, and displays the heatmap with boxed output turned off. Dependencies include the github.com/pterm/pterm module. Inputs: float32 data and axis labels. Output: heatmap rendered to the terminal. Requires a terminal supporting colored output, but avoids RGB colors for broad compatibility.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_42\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and no legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the specified data and options, and render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(headerData).WithLegend(false).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Drawing Bar Charts in the Terminal using PTerm in Go\nDESCRIPTION: This code implements a bar chart printer to visualize numerical data as horizontal bars in the terminal. It calculates proportional bar lengths based on maximum value and prints each bar label and value alongside visual blocks. Dependencies include PTerm and possibly unicode block characters for bar representation. Inputs are an array of labels and corresponding values. Output is a row for each data point with a proportional bar, suitable for terminal-based data trends.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_13\n\nLANGUAGE: Go\nCODE:\n```\n// BarChartPrinter prints horizontal bar charts\nfunc (b *BarChartPrinter) Render(labels []string, values []int) error {\n\tmax := b.maxValue(values)\n\tfor i, label := range labels {\n\t\tbarLen := values[i] * 50 / max\n\t\tfmt.Printf(\"%s [%s] %d\\n\", label, strings.Repeat(\"█\", barLen), values[i])\n\t}\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Default BigText Banner Using PTerm in Go\nDESCRIPTION: Displays a large sized textual banner in the terminal using PTerm, in a single consistent style. The example includes converting a plain string to the necessary letter format with putils.LettersFromString, then rendering it using DefaultBigText and Render. Dependencies: github.com/pterm/pterm and putils. Input: any string. Output: monospaced ASCII-art-like large text, used for visual emphasis at the CLI. No color customization applied.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_19\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define the text to be rendered\n\tvar text = \"PTerm\"\n\n\t// Convert the text into a format suitable for PTerm\n\tvar letters = putils.LettersFromString(text)\n\n\t// Render the text using PTerm's default big text style\n\tpterm.DefaultBigText.WithLetters(letters).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Fullscreen Terminal Area with PTerm in Go\nDESCRIPTION: This snippet demonstrates how to create a PTerm area that occupies the entire terminal screen using `pterm.DefaultArea.WithFullscreen().Start()`. It then shows how to dynamically update the content of this fullscreen area within a loop and stop it when finished.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Start a new fullscreen area. This will return an area instance and an error.\n\t// The underscore (_) is used to ignore the error.\n\tarea, _ := pterm.DefaultArea.WithFullscreen().Start()\n\n\t// Loop 5 times to update the area content.\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count.\n\t\t// The Sprintf function is used to format the string.\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Updating Dynamic Console Area with Animated Clock using PTerm in Go\nDESCRIPTION: This snippet creates a console application using the Go programming language and the PTerm library to display a live-updating digital clock within a fixed console area. It starts by printing a steady informational message, creates a centered area for dynamic content, and updates this area every second with the current time rendered in large ASCII art style using PTerm's big text functionality. The snippet requires the 'github.com/pterm/pterm' and 'github.com/pterm/pterm/putils' packages. Key parameters include the format string '15:04:05' for time display and the area object which controls output updates. The output is the repeated update of the console's area with time in big letters, running for 10 seconds before stopping. The snippet demonstrates controlled concurrent updates and styled console text rendering capabilities and is limited to console environments supporting PTerm styling.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/area/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print an informational message using PTerm's Info printer.\n\t// This message will stay in place while the area updates.\n\tpterm.Info.Println(\"The previous text will stay in place, while the area updates.\")\n\n\t// Print two new lines as spacer.\n\tpterm.Print(\"\\n\\n\")\n\n\t// Start the Area printer from PTerm's DefaultArea, with the Center option.\n\t// The Area printer allows us to update a specific area of the console output.\n\t// The returned 'area' object is used to control the area updates.\n\tarea, _ := pterm.DefaultArea.WithCenter().Start()\n\n\t// Loop 10 times to update the area with the current time.\n\tfor i := 0; i < 10; i++ {\n\t\t// Get the current time, format it as \"15:04:05\" (hour:minute:second), and convert it to a string.\n\t\t// Then, create a BigText from the time string using PTerm's DefaultBigText and putils NewLettersFromString.\n\t\t// The Srender() function is used to save the BigText as a string.\n\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender()\n\n\t\t// Update the Area contents with the current time string.\n\t\tarea.Update(str)\n\n\t\t// Sleep for a second before the next update.\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the Area printer after all updates are done.\n\tarea.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Sections with Different Levels in Go using PTerm\nDESCRIPTION: Shows how to create and display sections with different heading levels using PTerm's DefaultSection component. The example demonstrates level one and level two sections with informational text between them.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_58\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a section with level one and print it.\n\tpterm.DefaultSection.Println(\"This is a section!\")\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"And here is some text.\\nThis text could be anything.\\nBasically it's just a placeholder\")\n\n\t// Create a section with level two and print it.\n\tpterm.DefaultSection.WithLevel(2).Println(\"This is another section!\")\n\n\t// Print another informational message.\n\tpterm.Info.Println(\"And this is\\nmore placeholder text\")\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts with Positive Values Using PTerm in Go\nDESCRIPTION: Demonstrates how to create bar charts with only positive values using PTerm in Go, including both vertical and horizontal orientations. Requires the PTerm library and defines bars with labels and values. Outputs the rendered chart in the terminal; label and value configuration is essential, and only non-negative values will be visualized.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the bars for the chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 5},\n\t\t{Label: \"Bar 2\", Value: 3},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"Chart example with positive only values (bars use 100% of chart area)\")\n\n\t// Create a bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n\n\t// Create a horizontal bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, the chart is made horizontal with the WithHorizontal option, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Applying RGB Color Styles in Go with pterm\nDESCRIPTION: This Go code demonstrates creating and applying reusable text styles with custom RGB foreground and background colors using pterm. It defines foreground and background RGB values, creates a `pterm.RGBStyle` using `pterm.NewRGBStyle()`, prints text with the base style, and then adds `pterm.Bold` and `pterm.Italic` options to the style for subsequent print calls.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_34\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors for foreground and background.\n\tforegroundRGB := pterm.RGB{R: 187, G: 80, B: 0}\n\tbackgroundRGB := pterm.RGB{R: 0, G: 50, B: 123}\n\n\t// Create a new RGB style with the defined foreground and background colors.\n\trgbStyle := pterm.NewRGBStyle(foregroundRGB, backgroundRGB)\n\n\t// Print a string with the custom RGB style.\n\trgbStyle.Println(\"This text is not styled.\")\n\n\t// Add the 'Bold' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Bold).Println(\"This text is bold.\")\n\n\t// Add the 'Italic' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Italic).Println(\"This text is italic.\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Styled Paragraph Printing and Text Wrapping with Pterm in Go\nDESCRIPTION: This code provides functionality for printing and formatting paragraphs with styling in terminal applications using Pterm in Go. It manages text wrapping, indentation, and colorization. Dependencies include terminal width calculations and ANSI escape codes for colors. Key parameters include the paragraph text, indentation level, and style configuration objects. Outputs are formatted paragraphs with proper wrapping and color applied to terminal output. It handles multi-line text and various terminal constraints.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_15\n\nLANGUAGE: Go\nCODE:\n```\npackage pterm\n\n// ParagraphPrinter handles printing paragraphs with styles\nfunc (pp *ParagraphPrinter) Print(text string) {\n\t// Wrap text based on terminal width\n\t// Apply styles including colors and indentation\n\t// Print to stdout with proper formatting\n}\n\n// Support functions for wrapping and styling text\nfunc wrapText(text string, width int) []string {\n\t// Logic to split text into lines\n\treturn []string{}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Terminal Color and Styling Management with Pterm in Go\nDESCRIPTION: This component manages terminal text coloring and styles using ANSI escape codes through the Pterm library in Go. It supports different colors for foreground, background, and effects like bold and underline. Dependencies include terminal emulator support for ANSI codes and platform compatibility. Parameters include color codes and style options to apply to strings. Outputs are strings with appropriately embedded ANSI codes that produce styled terminal text. Constraints include terminal capabilities and potential color clashes.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_17\n\nLANGUAGE: Go\nCODE:\n```\npackage pterm\n\n// Color represents terminal color configuration\nfunc (c Color) Sprint(text string) string {\n\t// Wrap text with ANSI escape sequences for color\n\treturn \"\"\n}\n\n// Methods to create and combine different styles\nfunc NewStyle(options ...StyleOption) Style {\n\treturn Style{}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Printers in PTerm\nDESCRIPTION: Demonstrates how to override PTerm's default printers by customizing their prefix and style. This example shows how to change the default Error printer's prefix text and styling properties.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default error message with PTerm's built-in Error style.\n\tpterm.Error.Println(\"This is the default Error\")\n\n\t// Override the default error prefix with a new text and style.\n\tpterm.Error.Prefix = pterm.Prefix{Text: \"OVERRIDE\", Style: pterm.NewStyle(pterm.BgCyan, pterm.FgRed)}\n\n\t// Print the error message again, this time with the overridden prefix.\n\tpterm.Error.Println(\"This is the default Error after the prefix was overridden\")\n}\n```\n\n----------------------------------------\n\nTITLE: Building Multiple Boxed Panels with Custom Titles Using PTerm in Go\nDESCRIPTION: Demonstrates advanced layout composition using multiple panels and boxes from PTerm. Three panel boxes are created with custom titles, then arranged in a 2D grid layout via DefaultPanel.WithPanels, and finally wrapped again in a titled box. Custom placement for titles (bottom center and bottom right) and padding adjustments are shown. Inputs: raw strings for content. Outputs: a composite ASCII/Unicode layout visualized in the terminal. Requires monospaced terminal for correct rendering. All layout functions are chained. Prerequisites: only PTerm needed.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_20\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"This might not be rendered correctly on GitHub,\\nbut it will work in a real terminal.\\nThis is because GitHub does not use a monospaced font by default for SVGs\")\n\n\t// Create three panels with text, some of them with titles.\n\t// The panels are created using the DefaultBox style.\n\tpanel1 := pterm.DefaultBox.Sprint(\"Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit,\\nsed do eiusmod tempor incididunt\\nut labore et dolore\\nmagna aliqua.\")\n\tpanel2 := pterm.DefaultBox.WithTitle(\"title\").Sprint(\"Ut enim ad minim veniam,\\nquis nostrud exercitation\\nullamco laboris\\nnisi ut aliquip\\nex ea commodo\\nconsequat.\")\n\tpanel3 := pterm.DefaultBox.WithTitle(\"bottom center title\").WithTitleBottomCenter().Sprint(\"Duis aute irure\\ndolor in reprehenderit\\nin voluptate velit esse cillum\\ndolore eu fugiat\\nnulla pariatur.\")\n\n\t// Combine the panels into a layout using the DefaultPanel style.\n\t// The layout is a 2D grid, with each row being an array of panels.\n\t// In this case, the first row contains panel1 and panel2, and the second row contains only panel3.\n\tpanels, _ := pterm.DefaultPanel.WithPanels(pterm.Panels{\n\t\t{{Data: panel1}, {Data: panel2}},\n\t\t{{Data: panel3}},\n\t}).Srender()\n\n\t// Print the panels layout inside a box with a title.\n\t// The box is created using the DefaultBox style, with the title positioned at the bottom right.\n\tpterm.DefaultBox.WithTitle(\"Lorem Ipsum\").WithTitleBottomRight().WithRightPadding(0).WithBottomPadding(0).Println(panels)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Multiselect with Custom Keyboard Bindings in PTerm - Go\nDESCRIPTION: Shows how to configure keyboard shortcuts for confirming and selecting options in a PTerm multiselect prompt using atomicgo.dev/keyboard/keys. Disables filtering and sets custom keys for user actions. Depends on both github.com/pterm/pterm and atomicgo.dev/keyboard/keys. Outputs user's selected options in green. Enables more accessible or specialized CLI workflows.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_47\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and set the keys for confirming and selecting options\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithKeyConfirm(keys.Enter).\n\t\tWithKeySelect(keys.Space)\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Interactive Continue Prompt Using PTerm - Go\nDESCRIPTION: Presents an interactive continue prompt in the terminal where execution pauses until the user presses Enter. Built with PTerm's DefaultInteractiveContinue and Show(), this snippet highlights the simplicity of using PTerm for flow control in CLI apps. Requires github.com/pterm/pterm. Outputs the entered result (expected to be empty), suitable for step-by-step interactive scripts.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_44\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive continue prompt with default settings\n\t// This will pause the program execution until the user presses enter\n\t// The message displayed is \"Press 'Enter' to continue...\"\n\tprompt := pterm.DefaultInteractiveContinue\n\n\t// Show the prompt and wait for user input\n\t// The returned result is the user's input (should be empty as it's a continue prompt)\n\t// The second return value is an error which is ignored here\n\tresult, _ := prompt.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's input with an info prefix\n\t// As this is a continue prompt, the input should be empty\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Animating Spinner Printers in PTrem (Go)\nDESCRIPTION: These snippets control the spinner printer, which provides animated spinner graphics in the terminal UI. Methods address setting spinner style, updating frames, starting/stopping animation, and printing output. Dependencies include concurrency primitives for handling animation and timer events. Key parameters are spinner character sets, update intervals, and styling information. Output is a live-updating spinner, limited by terminal refresh rates and text encoding.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Spinner printer start animation method\nfunc (s *SpinnerPrinter) Start() {\n\t// Begin animation goroutine\n}\n\n```\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Update spinner frame method\nfunc (s *SpinnerPrinter) UpdateText(text string) {\n\ts.Text = text\n\t// Redraw logic\n}\n\n```\n\n----------------------------------------\n\nTITLE: Dynamically Controlling pterm Output in Go\nDESCRIPTION: This Go program uses the pterm library to demonstrate conditional output control. It iterates 15 times, disables pterm output at the 5th iteration using `pterm.DisableOutput()`, and re-enables it at the 10th iteration using `pterm.EnableOutput()`. Informational messages announce the changes, and a progress message attempts to print on each iteration, illustrating the effect of disabling/enabling output. Requires the `github.com/pterm/pterm` package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/disable-output/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Loop from 0 to 14\n\tfor i := 0; i < 15; i++ {\n\t\tswitch i {\n\t\tcase 5:\n\t\t\t// At the 5th iteration, print a message and disable the output\n\t\t\tpterm.Info.Println(\"Disabled Output!\")\n\t\t\tpterm.DisableOutput()\n\t\tcase 10:\n\t\t\t// At the 10th iteration, enable the output and print a message\n\t\t\tpterm.EnableOutput()\n\t\t\tpterm.Info.Println(\"Enabled Output!\")\n\t\t}\n\n\t\t// Print a progress message for each iteration\n\t\tpterm.Printf(\"Printing something... [%d/%d]\\n\", i, 15)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Fullscreen Centered Terminal Area with PTerm in Go\nDESCRIPTION: This snippet demonstrates creating a PTerm area that is both fullscreen and centered using `pterm.DefaultArea.WithFullscreen().WithCenter().Start()`. It illustrates dynamically updating the area's content within a loop and stopping it afterwards to clear the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize a new PTerm area with fullscreen and center options\n\t// The Start() function returns the created area and an error (ignored here)\n\tarea, _ := pterm.DefaultArea.WithFullscreen().WithCenter().Start()\n\n\t// Loop 5 times to demonstrate dynamic content update\n\tfor i := 0; i < 5; i++ {\n\t\t// Update the content of the area with the current count\n\t\t// The Sprintf function is used to format the string with the count\n\t\tarea.Update(pterm.Sprintf(\"Current count: %d\\nAreas can update their content dynamically!\", i))\n\n\t\t// Pause for a second\n\t\ttime.Sleep(time.Second)\n\t}\n\n\t// Stop the area after all updates are done\n\t// This will clear the area and return the terminal to its normal state\n\tarea.Stop()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Controlling Output Enablement Status Dynamically with PTerm in Go\nDESCRIPTION: Illustrates enabling and disabling terminal output dynamically within a loop using PTerm. It prints informational messages when output is disabled or enabled at specific loop iterations (5 and 10). Between these events, it prints progress messages. This snippet requires PTerm core. Inputs are loop counters; outputs are conditional terminal prints depending on output state.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_28\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Loop from 0 to 14\n\tfor i := 0; i < 15; i++ {\n\t\tswitch i {\n\t\tcase 5:\n\t\t\t// At the 5th iteration, print a message and disable the output\n\t\t\tpterm.Info.Println(\"Disabled Output!\")\n\t\t\tpterm.DisableOutput()\n\t\tcase 10:\n\t\t\t// At the 10th iteration, enable the output and print a message\n\t\t\tpterm.EnableOutput()\n\t\t\tpterm.Info.Println(\"Enabled Output!\")\n\t\t}\n\n\t\t// Print a progress message for each iteration\n\t\tpterm.Printf(\"Printing something... [%d/%d]\\n\", i, 15)\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Disable Grid Lines for Heatmap using pterm Go\nDESCRIPTION: This snippet demonstrates how to render a pterm heatmap without the default grid lines separating the cells. This can be useful for a more compact visual representation of the data. It includes data definition, axis labels, and enabling RGB colors.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_41\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis data for the heatmap.\n\taxisData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options, then render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(axisData).WithEnableRGB().WithLegend().WithGrid(false).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Large Styled Text Using PTerm BigText in Go\nDESCRIPTION: Shows how to render large decorative text in the terminal using PTerm's DefaultBigText feature along with the putils package for letter conversion and styling. Provides examples for rendering a basic large text string, a combination of differently colored letters, and text colored with a specific RGB value. Requires 'github.com/pterm/pterm' and 'github.com/pterm/pterm/putils'. Outputs large ASCII-art style text suitable for titles or splash screens.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_16\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Create a large text with the LetterStyle from the standard theme.\n\t// This is useful for creating title screens.\n\tpterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Render()\n\n\t// Create a large text with differently colored letters.\n\t// Here, the first letter 'P' is colored cyan and the rest 'Term' is colored light magenta.\n\t// This can be used to highlight specific parts of the text.\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle()),\n\t).Render()\n\n\t// Create a large text with a specific RGB color.\n\t// This can be used when you need a specific color that is not available in the standard colors.\n\t// Here, the color is gold (RGB: 255, 215, 0).\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithRGB(\"PTerm\", pterm.NewRGB(255, 215, 0)),\n\t).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Converting and Rendering a Leveled List as a Tree with pterm in Go\nDESCRIPTION: This snippet illustrates converting a leveled list representing directory levels into a tree structure using pterm's utility function TreeFromLeveledList. The code defines a sequence of levels and associated directory names, converts them into a tree, assigns a root node label, and renders the resulting tree using pterm's DefaultTree. It depends on the pterm and pterm/putils packages. Inputs are the leveled list entries with levels and text; output is a hierarchical tree rendering in the terminal. The snippet demonstrates structured data conversion and printing with pterm utilities.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/tree/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define a leveled list to represent the structure of the directories.\n\tleveledList := pterm.LeveledList{\n\t\t{Level: 0, Text: \"C:\"},\n\t\t{Level: 1, Text: \"Users\"},\n\t\t{Level: 1, Text: \"Windows\"},\n\t\t{Level: 1, Text: \"Programs\"},\n\t\t{Level: 1, Text: \"Programs(x86)\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 0, Text: \"D:\"},\n\t\t{Level: 0, Text: \"E:\"},\n\t\t{Level: 1, Text: \"Movies\"},\n\t\t{Level: 1, Text: \"Music\"},\n\t\t{Level: 2, Text: \"LinkinPark\"},\n\t\t{Level: 1, Text: \"Games\"},\n\t\t{Level: 2, Text: \"Shooter\"},\n\t\t{Level: 3, Text: \"CallOfDuty\"},\n\t\t{Level: 3, Text: \"CS:GO\"},\n\t\t{Level: 3, Text: \"Battlefield\"},\n\t\t{Level: 4, Text: \"Battlefield 1\"},\n\t\t{Level: 4, Text: \"Battlefield 2\"},\n\t\t{Level: 0, Text: \"F:\"},\n\t\t{Level: 1, Text: \"dev\"},\n\t\t{Level: 2, Text: \"dops\"},\n\t\t{Level: 2, Text: \"PTerm\"},\n\t}\n\n\t// Convert the leveled list into a tree structure.\n\troot := putils.TreeFromLeveledList(leveledList)\n\troot.Text = \"Computer\" // Set the root node text.\n\n\t// Render the tree structure using the default tree printer.\n\tpterm.DefaultTree.WithRoot(root).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Rendering a Styled Bullet List in Go Using pterm\nDESCRIPTION: This snippet initializes a list of BulletListItem objects with varying styles and nesting levels, then renders the list using pterm's DefaultBulletList. It requires the pterm library as a dependency and demonstrates customizing bullet and text styles for hierarchical list items.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bulletlist/customized/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a list of bullet list items with different styles and levels.\n\tbulletListItems := []pterm.BulletListItem{\n\t\t{\n\t\t\tLevel:       0,                            // Level 0 (top level)\n\t\t\tText:        \"Blue\",                       // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgBlue), // Text color\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgRed),  // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       1,                                  // Level 1 (sub-item)\n\t\t\tText:        \"Green\",                            // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgGreen),      // Text color\n\t\t\tBullet:      \"-\",                                // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgLightWhite), // Bullet color\n\t\t},\n\t\t{\n\t\t\tLevel:       2,                              // Level 2 (sub-sub-item)\n\t\t\tText:        \"Cyan\",                         // Text to display\n\t\t\tTextStyle:   pterm.NewStyle(pterm.FgCyan),   // Text color\n\t\t\tBullet:      \">\",                            // Custom bullet symbol\n\t\t\tBulletStyle: pterm.NewStyle(pterm.FgYellow), // Bullet color\n\t\t},\n\t}\n\n\t// Create a bullet list with the defined items and render it.\n\tpterm.DefaultBulletList.WithItems(bulletListItems).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom RGB Styles with Bold and Italic Options in Go Using PTerm\nDESCRIPTION: Demonstrates creating an RGB style with specified foreground and background colors and printing text with this style. It also shows how to add Bold and Italic styling options to the RGB style before printing. This example requires the PTerm library and a terminal supporting TrueColor.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_33\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors for foreground and background.\n\tforegroundRGB := pterm.RGB{R: 187, G: 80, B: 0}\n\tbackgroundRGB := pterm.RGB{R: 0, G: 50, B: 123}\n\n\t// Create a new RGB style with the defined foreground and background colors.\n\trgbStyle := pterm.NewRGBStyle(foregroundRGB, backgroundRGB)\n\n\t// Print a string with the custom RGB style.\n\trgbStyle.Println(\"This text is not styled.\")\n\n\t// Add the 'Bold' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Bold).Println(\"This text is bold.\")\n\n\t// Add the 'Italic' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Italic).Println(\"This text is italic.\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Printer Prefixes in Go with pterm\nDESCRIPTION: This Go snippet demonstrates how to customize the default output of pterm printers, specifically `pterm.Error`. It first prints an error message using the default settings, then overrides the `Prefix` property with custom text (\"OVERRIDE\") and style (red text on a cyan background) before printing the error message again to show the change.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_32\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default error message with PTerm's built-in Error style.\n\tpterm.Error.Println(\"This is the default Error\")\n\n\t// Override the default error prefix with a new text and style.\n\tpterm.Error.Prefix = pterm.Prefix{Text: \"OVERRIDE\", Style: pterm.NewStyle(pterm.BgCyan, pterm.FgRed)}\n\n\t// Print the error message again, this time with the overridden prefix.\n\tpterm.Error.Println(\"This is the default Error after the prefix was overridden\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Go's slog Package with PTerm Logging\nDESCRIPTION: Demonstrates how to use PTerm as a handler for Go's slog package. The example shows logging at different levels (debug, info, warning, error) and how to change the log level to control which messages are displayed.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_59\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"log/slog\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create a new slog handler with the default PTerm logger\n\thandler := pterm.NewSlogHandler(&pterm.DefaultLogger)\n\n\t// Create a new slog logger with the handler\n\tlogger := slog.New(handler)\n\n\t// Log a debug message (won't show by default)\n\tlogger.Debug(\"This is a debug message that won't show\")\n\n\t// Change the log level to debug to enable debug messages\n\tpterm.DefaultLogger.Level = pterm.LogLevelDebug\n\n\t// Log a debug message (will show because debug level is enabled)\n\tlogger.Debug(\"This is a debug message\", \"changedLevel\", true)\n\n\t// Log an info message\n\tlogger.Info(\"This is an info message\")\n\n\t// Log a warning message\n\tlogger.Warn(\"This is a warning message\")\n\n\t// Log an error message\n\tlogger.Error(\"This is an error message\")\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Logger Key Styles in PTerm\nDESCRIPTION: Shows how to customize the styles of specific keys in the PTerm logger. The example demonstrates creating custom styles for keys, overwriting all key styles, and appending new styles to existing ones.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_47\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Define a new style for the \"priority\" key.\n\tpriorityStyle := map[string]pterm.Style{\n\t\t\"priority\": *pterm.NewStyle(pterm.FgRed),\n\t}\n\n\t// Overwrite all key styles with the new map.\n\tlogger = logger.WithKeyStyles(priorityStyle)\n\n\t// Log an info message. The \"priority\" key will be displayed in red.\n\tlogger.Info(\"The priority key should now be red\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n\n\t// Define a new style for the \"foo\" key.\n\tfooStyle := *pterm.NewStyle(pterm.FgBlue)\n\n\t// Append the new style to the existing ones.\n\tlogger.AppendKeyStyle(\"foo\", fooStyle)\n\n\t// Log another info message. The \"foo\" key will be displayed in blue.\n\tlogger.Info(\"The foo key should now be blue\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Applying RGB Color Fading with Style Options in Go Using PTerm\nDESCRIPTION: Prints multiple strings with individually faded foreground and background RGB colors combined with text styles like Bold and Italic. It defines utility functions that split strings and apply fading colors to each character, with checks for specific style keywords to apply the corresponding text styles. This implementation depends on the PTerm library and terminal TrueColor support.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_29\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors\n\twhite := pterm.NewRGB(255, 255, 255)\n\tgrey := pterm.NewRGB(128, 128, 128)\n\tblack := pterm.NewRGB(0, 0, 0)\n\tred := pterm.NewRGB(255, 0, 0)\n\tpurple := pterm.NewRGB(255, 0, 255)\n\tgreen := pterm.NewRGB(0, 255, 0)\n\n\t// Define strings to be printed\n\tstr1 := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstr2 := \"The background and foreground colors can be customized individually.\"\n\tstr3 := \"Styles can also be applied. For example: Bold or Italic.\"\n\n\t// Print first string with color fading from white to purple\n\tprintFadedString(str1, white, purple, grey, black)\n\n\t// Print second string with color fading from purple to red\n\tprintFadedString(str2, black, purple, red, red)\n\n\t// Print third string with color fading from white to green and style changes\n\tprintStyledString(str3, white, green, red, black)\n}\n\n// printFadedString prints a string with color fading effect\nfunc printFadedString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n// printStyledString prints a string with color fading and style changes\nfunc printStyledString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tboldStr := strings.Split(\"Bold\", \"\")\n\titalicStr := strings.Split(\"Italic\", \"\")\n\tbold, italic := 0, 0\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Check if the next letters are \"Bold\" or \"Italic\" and add the corresponding style\n\t\tif bold < len(boldStr) && i+len(boldStr)-bold <= len(strs) && strings.Join(strs[i:i+len(boldStr)-bold], \"\") == strings.Join(boldStr[bold:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Bold)\n\t\t\tbold++\n\t\t} else if italic < len(italicStr) && i+len(italicStr)-italic < len(strs) && strings.Join(strs[i:i+len(italicStr)-italic], \"\") == strings.Join(italicStr[italic:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Italic)\n\t\t\titalic++\n\t\t}\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Horizontal BarChart with Values Using PTerm in Go\nDESCRIPTION: This snippet demonstrates creating a horizontal bar chart using the PTerm library, where each bar displays its respective value. The data is defined as a slice of pterm.Bar structs, each with a label and value. Only the PTerm library is required. The main method chains WithBars, WithHorizontal, and WithShowValue, finishing with Render to produce the output. The chart is rendered to the CLI and is suitable for datasets where the horizontal arrangement and visible values are desired. Inputs include any slice of pterm.Bar, and output is textual graphical bar chart. Constraints: suitable for monospaced terminal environments.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and displays the value of each bar\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customize pterm Header Style and Create New Printer in Go\nDESCRIPTION: This snippet illustrates two ways to customize headers in pterm. It shows how to modify the default header's style (background, text color) and margin, and how to define a completely new HeaderPrinter instance with specific styling for reuse.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_36\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Customize the DefaultHeader with a cyan background, black text, and a margin of 15.\n\tpterm.DefaultHeader.WithMargin(15).WithBackgroundStyle(pterm.NewStyle(pterm.BgCyan)).WithTextStyle(pterm.NewStyle(pterm.FgBlack)).Println(\"This is a custom header!\")\n\n\t// Define a new HeaderPrinter with a red background, black text, and a margin of 20.\n\tnewHeader := pterm.HeaderPrinter{\n\t\tTextStyle:       pterm.NewStyle(pterm.FgBlack),\n\t\tBackgroundStyle: pterm.NewStyle(pterm.BgRed),\n\t\tMargin:          20,\n\t}\n\n\t// Print the custom header using the new HeaderPrinter.\n\tnewHeader.Println(\"This is a custom header!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive TextPrinter Testing Template in Go\nDESCRIPTION: A template for thoroughly testing all methods of a PTerm TextPrinter, including Print, Printf, Println, Sprint, Sprintf, and Sprintln methods to ensure proper functionality.\nSOURCE: https://github.com/pterm/pterm/blob/master/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc TestTemplatePrinterPrintMethods(t *testing.T) { // TODO: Replace \"Template\" with actual printer name.\n\tp := DefaultTemplate // TODO: Replace \"Template\" with actual printer name.\n\n\tt.Run(\"Print\", func(t *testing.T) {\n\t\ttestPrintContains(t, func(w io.Writer, a any) {\n\t\t\tp.Print(a)\n\t\t})\n\t})\n\n\tt.Run(\"Printf\", func(t *testing.T) {\n\t\ttestPrintfContains(t, func(w io.Writer, format string, a any) {\n\t\t\tp.Printf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Println\", func(t *testing.T) {\n\t\ttestPrintlnContains(t, func(w io.Writer, a any) {\n\t\t\tp.Println(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprint\", func(t *testing.T) {\n\t\ttestSprintContains(t, func(a any) string {\n\t\t\treturn p.Sprint(a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintf\", func(t *testing.T) {\n\t\ttestSprintfContains(t, func(format string, a any) string {\n\t\t\treturn p.Sprintf(format, a)\n\t\t})\n\t})\n\n\tt.Run(\"Sprintln\", func(t *testing.T) {\n\t\ttestSprintlnContains(t, func(a any) string {\n\t\t\treturn p.Sprintln(a)\n\t\t})\n\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Paragraph Wrapping Width with PTerm in Go\nDESCRIPTION: This snippet demonstrates customizing paragraph line width with the PTerm library in Go. It initializes a paragraph printer with a maximum width (set to 60 characters) for precise text wrapping, prints a sample long text using this setting, and then prints other long text as plain output for comparison. Dependencies: github.com/pterm/pterm. The main parameters are the maximum line width for the paragraph, and both styles are displayed for contrast. No input parameters; direct terminal output.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_54\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a long text to be printed as a paragraph.\n\tlongText := \"This is a custom paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text as a paragraph with a custom maximal width of 60 characters.\n\tpterm.DefaultParagraph.WithMaxWidth(60).Println(longText)\n\n\t// Print a line space to separate the paragraph from the following text.\n\tpterm.Println()\n\n\t// Define another long text to be printed without a paragraph printer.\n\tlongTextWithoutParagraph := \"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text without using a paragraph printer.\n\tpterm.Println(longTextWithoutParagraph)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Styled RGB Color Fading Text with Bold and Italic in Go using pterm\nDESCRIPTION: Extends RGB color fading printing by detecting keywords \"Bold\" and \"Italic\" in the string and applying the corresponding text styles dynamically. It iterates over the string characters, applies fading colors, and conditionally adds bold or italic styles using pterm's style options. Requires pterm library and terminals supporting TrueColor and styling.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/fade-colors-rgb-style/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// printStyledString prints a string with color fading and style changes\nfunc printStyledString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tboldStr := strings.Split(\"Bold\", \"\")\n\titalicStr := strings.Split(\"Italic\", \"\")\n\tbold, italic := 0, 0\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Check if the next letters are \"Bold\" or \"Italic\" and add the corresponding style\n\t\tif bold < len(boldStr) && i+len(boldStr)-bold <= len(strs) && strings.Join(strs[i:i+len(boldStr)-bold], \"\") == strings.Join(boldStr[bold:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Bold)\n\t\t\tbold++\n\t\t} else if italic < len(italicStr) && i+len(italicStr)-italic < len(strs) && strings.Join(strs[i:i+len(italicStr)-italic], \"\") == strings.Join(italicStr[italic:], \"\") {\n\t\t\tstyle = style.AddOptions(pterm.Italic)\n\t\t\titalic++\n\t\t}\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Applying Custom RGB Styles with PTerm in Go\nDESCRIPTION: This Go snippet demonstrates how to define RGB colors for foreground and background using PTerm, construct a new RGB text style, and print styled output in the terminal. It sequentially applies styling options such as bold and italic to the text by leveraging PTerm's AddOptions method. Dependencies include the PTerm Go library (imported via github.com/pterm/pterm), and primary parameters involve the RGB values for color configuration. The input is static text strings, and the output is styled terminal text. The demonstration assumes PTerm is installed and the program is run in a compatible terminal; the public API limits advanced color support to terminals that support RGB colors.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/print-color-rgb-style/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors for foreground and background.\n\tforegroundRGB := pterm.RGB{R: 187, G: 80, B: 0}\n\tbackgroundRGB := pterm.RGB{R: 0, G: 50, B: 123}\n\n\t// Create a new RGB style with the defined foreground and background colors.\n\trgbStyle := pterm.NewRGBStyle(foregroundRGB, backgroundRGB)\n\n\t// Print a string with the custom RGB style.\n\trgbStyle.Println(\"This text is not styled.\")\n\n\t// Add the 'Bold' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Bold).Println(\"This text is bold.\")\n\n\t// Add the 'Italic' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Italic).Println(\"This text is italic.\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Default Big Text Using PTerm in Go\nDESCRIPTION: Shows rendering big ASCII-style text with PTerm by converting a normal string into PTerm's letter format using putils.LettersFromString and then rendering it with DefaultBigText. Requires 'github.com/pterm/pterm' and 'github.com/pterm/pterm/putils'. This creates large text output suitable for titles or important notices in terminal applications.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_18\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Define the text to be rendered\n\tvar text = \"PTerm\"\n\n\t// Convert the text into a format suitable for PTerm\n\tvar letters = putils.LettersFromString(text)\n\n\t// Render the text using PTerm's default big text style\n\tpterm.DefaultBigText.WithLetters(letters).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Customized Paragraphs with PTerm in Go\nDESCRIPTION: Illustrates customizing the paragraph printer by setting a maximal line width, then printing text using this configuration. It shows the effectiveness of word splitting and wrapping versus basic Println output. This example depends on the \"github.com/pterm/pterm\" package. Inputs include long text strings, and outputs are terminal-rendered formatted paragraphs with specified maximum width.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_61\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a long text to be printed as a paragraph.\n\tlongText := \"This is a custom paragraph printer. As you can see, no words are separated, \" +\n\t\t\"but the text is split at the spaces. This is useful for continuous text of all kinds. You can manually change the line width if you want to.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text as a paragraph with a custom maximal width of 60 characters.\n\tpterm.DefaultParagraph.WithMaxWidth(60).Println(longText)\n\n\t// Print a line space to separate the paragraph from the following text.\n\tpterm.Println()\n\n\t// Define another long text to be printed without a paragraph printer.\n\tlongTextWithoutParagraph := \"This text is written with the default Println() function. No intelligent splitting here.\" +\n\t\t\"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\"\n\n\t// Print the long text without using a paragraph printer.\n\tpterm.Println(longTextWithoutParagraph)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Applying RGB Color Styles with pterm in Go\nDESCRIPTION: This Go snippet demonstrates the process of applying custom RGB color styles to console output using the pterm library. It involves defining specific foreground and background colors using `pterm.RGB` structs, creating a new style with `pterm.NewRGBStyle`, and then using the style's print methods (`Println`). The example also shows how to add style options like `pterm.Bold` and `pterm.Italic` to the existing style before printing.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors for foreground and background.\n\tforegroundRGB := pterm.RGB{R: 187, G: 80, B: 0}\n\tbackgroundRGB := pterm.RGB{R: 0, G: 50, B: 123}\n\n\t// Create a new RGB style with the defined foreground and background colors.\n\trgbStyle := pterm.NewRGBStyle(foregroundRGB, backgroundRGB)\n\n\t// Print a string with the custom RGB style.\n\trgbStyle.Println(\"This text is not styled.\")\n\n\t// Add the 'Bold' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Bold).Println(\"This text is bold.\")\n\n\t// Add the 'Italic' option to the RGB style and print a string with this style.\n\trgbStyle.AddOptions(pterm.Italic).Println(\"This text is italic.\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts with Value Display Enabled Using PTerm in Go\nDESCRIPTION: Shows how to display the numeric value of each bar directly on a bar chart using the WithShowValue method in PTerm. Requires PTerm, a slice of bar structs (label and value), and renders the value annotations in the terminal. Only value display functionality is customized; chart uses default orientation.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of bars for the bar chart. Each bar is represented by a struct\n\t// with a Label and a Value. The Label is a string that represents the name of the bar,\n\t// and the Value is an integer that represents the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined bars using the DefaultBarChart object from PTerm.\n\t// Chain the WithBars method to set the bars of the chart.\n\t// Chain the WithShowValue method to display the value of each bar on the chart.\n\t// Finally, call the Render method to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Vertical and Horizontal Bar Charts in Go with PTerm\nDESCRIPTION: Demonstrates how to create both vertical and horizontal bar charts using PTerm. The example creates three bars with different values and displays them first as a vertical chart and then as a horizontal chart.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the bars for the chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"Bar 1\", Value: 5},\n\t\t{Label: \"Bar 2\", Value: 3},\n\t\t{Label: \"Longer Label\", Value: 7},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"Chart example with positive only values (bars use 100% of chart area)\")\n\n\t// Create a bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n\n\t// Create a horizontal bar chart with the defined bars and render it\n\t// The DefaultBarChart is used as a base, the chart is made horizontal with the WithHorizontal option, and the bars are added with the WithBars option\n\t// The Render function is then called to display the chart\n\tpterm.DefaultBarChart.WithHorizontal().WithBars(bars).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-Point Color Fades in Go with pterm\nDESCRIPTION: This Go code demonstrates creating gradient color effects across multiple specified RGB color points using the pterm library. It first applies a two-point fade character by character to a string. Then, it demonstrates a fade across five color points (`startColor`, `firstPoint`, `secondPoint`, `thirdPoint`, `endColor`) applied line by line for the height of the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_31\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB values for gradient points.\n\tstartColor := pterm.NewRGB(0, 255, 255)\n\tfirstPoint := pterm.NewRGB(255, 0, 255)\n\tsecondPoint := pterm.NewRGB(255, 0, 0)\n\tthirdPoint := pterm.NewRGB(0, 255, 0)\n\tendColor := pterm.NewRGB(255, 255, 255)\n\n\t// Define the string to be printed.\n\tstr := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstrs := strings.Split(str, \"\")\n\n\t// Initialize an empty string for the faded info.\n\tvar fadeInfo string\n\n\t// Loop over the string length to create a gradient effect.\n\tfor i := 0; i < len(str); i++ {\n\t\t// Append each character of the string with a faded color to the info string.\n\t\tfadeInfo += startColor.Fade(0, float32(len(str)), float32(i), firstPoint).Sprint(strs[i])\n\t}\n\n\t// Print the info string with gradient effect.\n\tpterm.Info.Println(fadeInfo)\n\n\t// Get the terminal height.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the terminal height to print \"Hello, World!\" with a gradient effect.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Print the string with a color that fades from startColor to endColor.\n\t\tstartColor.Fade(0, float32(terminalHeight-2), float32(i), firstPoint, secondPoint, thirdPoint, endColor).Println(\"Hello, World!\")\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering 2D Panels Using Pterm Library in Go\nDESCRIPTION: Defines a 2D grid of text panels using pterm.Panels with different content types including plain strings, multi-line strings, and styled headers. Utilizes pterm.DefaultPanel to render the panel grid with specified padding. Requires the pterm library imported as 'github.com/pterm/pterm'. The 'panels' variable organizes panel cells in nested slices, each with a Data field representing the text. The Render method outputs the formatted panel layout to the terminal. Padding of 5 spaces is applied around each panel to improve readability. Inputs are hardcoded panel contents; output is terminal-rendered panel layout.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/panel/demo/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define panels in a 2D grid system\n\tpanels := pterm.Panels{\n\t\t{\n\t\t\t{Data: \"This is the first panel\"},\n\t\t\t{Data: pterm.DefaultHeader.Sprint(\"Hello, World!\")},\n\t\t\t{Data: \"This\\npanel\\ncontains\\nmultiple\\nlines\"},\n\t\t},\n\t\t{\n\t\t\t{Data: pterm.Red(\"This is another\\npanel line\")},\n\t\t\t{Data: \"This is the second panel\\nwith a new line\"},\n\t\t},\n\t}\n\n\t// Render the panels with a padding of 5\n\t_ = pterm.DefaultPanel.WithPanels(panels).WithPadding(5).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Text with Custom RGB Foreground and Background Colors in Go Using PTerm\nDESCRIPTION: Shows how to create new RGB colors for foreground text and background, and print strings with these custom colors using PTerm's NewRGB method. The example prints text with specified RGB values for text color and background, requiring a TrueColor-compatible terminal and the PTerm library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_32\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a new RGB color with values 178, 44, 199.\n\t// This color will be used for the text.\n\tpterm.NewRGB(178, 44, 199).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 15, 199, 209.\n\t// This color will be used for the text.\n\tpterm.NewRGB(15, 199, 209).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 201, 144, 30.\n\t// This color will be used for the background.\n\t// The 'true' argument indicates that the color is for the background.\n\tpterm.NewRGB(201, 144, 30, true).Println(\"This text is printed with a custom RGB background!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing log key styles with PTerm in Go\nDESCRIPTION: Demonstrates how to customize the styling of keys in log entries using PTerm. The example shows how to define styles for specific keys, overwrite all key styles, and append new styles to existing ones.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_54\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Define a new style for the \"priority\" key.\n\tpriorityStyle := map[string]pterm.Style{\n\t\t\"priority\": *pterm.NewStyle(pterm.FgRed),\n\t}\n\n\t// Overwrite all key styles with the new map.\n\tlogger = logger.WithKeyStyles(priorityStyle)\n\n\t// Log an info message. The \"priority\" key will be displayed in red.\n\tlogger.Info(\"The priority key should now be red\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n\n\t// Define a new style for the \"foo\" key.\n\tfooStyle := *pterm.NewStyle(pterm.FgBlue)\n\n\t// Append the new style to the existing ones.\n\tlogger.AppendKeyStyle(\"foo\", fooStyle)\n\n\t// Log another info message. The \"foo\" key will be displayed in blue.\n\tlogger.Info(\"The foo key should now be blue\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive Text Input with Default Value Using PTerm in Go\nDESCRIPTION: This example extends the interactive text input prompt by setting a default value shown to the user. The user can edit or accept the default. Result is printed after input. Dependent on github.com/pterm/pterm. Input is user text with pre-filled default; output is the printed response.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_43\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive text input with single line input mode and show it\n\tresult, _ := pterm.DefaultInteractiveTextInput.WithDefaultValue(\"Some default value\").Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's answer with an info prefix\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Progress Bar Printer: Rendering Progress Bars in Go\nDESCRIPTION: This collection of functions manages progress bar rendering, updating, and layout within the terminal UI. They handle progress calculations, display updates, and user interactions, supporting multiple progress bar instances with customizable styles and behaviors. Dependencies include style configurations and internal progress tracking variables.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/progressbar_printer.go:63.72,66.2  ... (truncated for brevity)\n```\n\n----------------------------------------\n\nTITLE: Printing Text with Custom RGB Colors in Go with pterm\nDESCRIPTION: This Go example shows how to print text to the terminal using specific RGB colors for foreground and background with the pterm library. It uses `pterm.NewRGB(r, g, b)` to create foreground colors and `pterm.NewRGB(r, g, b, true)` to create a background color, then calls `Println` on the resulting color object.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_33\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a new RGB color with values 178, 44, 199.\n\t// This color will be used for the text.\n\tpterm.NewRGB(178, 44, 199).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 15, 199, 209.\n\t// This color will be used for the text.\n\tpterm.NewRGB(15, 199, 209).Println(\"This text is printed with a custom RGB!\")\n\n\t// Create a new RGB color with values 201, 144, 30.\n\t// This color will be used for the background.\n\t// The 'true' argument indicates that the color is for the background.\n\tpterm.NewRGB(201, 144, 30, true).Println(\"This text is printed with a custom RGB background!\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing Default and Full-Width pterm Headers (Go)\nDESCRIPTION: This snippet demonstrates how to print standard and full-width headers using the default configuration of the pterm library. It shows the basic usage of `pterm.DefaultHeader` and how to apply the `WithFullWidth()` option. Requires the `github.com/pterm/pterm` library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/header/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Print a default header.\n\t// This uses the default settings of PTerm to print a header.\n\tpterm.DefaultHeader.Println(\"This is the default header!\")\n\n\t// Print a spacer line for better readability.\n\tpterm.Println()\n\n\t// Print a full-width header.\n\t// This uses the WithFullWidth() option of PTerm to print a header that spans the full width of the terminal.\n\tpterm.DefaultHeader.WithFullWidth().Println(\"This is a full-width header.\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Log Key Styles with PTerm (Go)\nDESCRIPTION: Illustrates how to apply custom styles to specific keys within log message arguments using `pterm.WithKeyStyles` and `pterm.AppendKeyStyle`. Shows how to define custom `pterm.Style` objects and associate them with argument keys to change their color or other formatting in the log output.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/logger/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a logger with a level of Trace or higher.\n\tlogger := pterm.DefaultLogger.WithLevel(pterm.LogLevelTrace)\n\n\t// Define a new style for the \"priority\" key.\n\tpriorityStyle := map[string]pterm.Style{\n\t\t\"priority\": *pterm.NewStyle(pterm.FgRed),\n\t}\n\n\t// Overwrite all key styles with the new map.\n\tlogger = logger.WithKeyStyles(priorityStyle)\n\n\t// Log an info message. The \"priority\" key will be displayed in red.\n\tlogger.Info(\"The priority key should now be red\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n\n\t// Define a new style for the \"foo\" key.\n\tfooStyle := *pterm.NewStyle(pterm.FgBlue)\n\n\t// Append the new style to the existing ones.\n\tlogger.AppendKeyStyle(\"foo\", fooStyle)\n\n\t// Log another info message. The \"foo\" key will be displayed in blue.\n\tlogger.Info(\"The foo key should now be blue\", logger.Args(\"priority\", \"low\", \"foo\", \"bar\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Bar Chart Width and Orientation with PTerm in Go\nDESCRIPTION: Illustrates how to set a custom width and horizontal orientation for a bar chart with PTerm. Requires the PTerm library, defines multiple bars, configures the chart to be horizontal with a width of five columns, and renders the chart. Only the width and orientation are adjusted; bar data is provided as input.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and has a width of 5\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithWidth(5).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Sections with Different Levels in PTerm\nDESCRIPTION: Demonstrates how to create and display sections with different heading levels in PTerm. The example creates a top-level section and a level-2 section, with informational text displayed between sections.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_65\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a section with level one and print it.\n\tpterm.DefaultSection.Println(\"This is a section!\")\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"And here is some text.\\nThis text could be anything.\\nBasically it's just a placeholder\")\n\n\t// Create a section with level two and print it.\n\tpterm.DefaultSection.WithLevel(2).Println(\"This is another section!\")\n\n\t// Print another informational message.\n\tpterm.Info.Println(\"And this is\\nmore placeholder text\")\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing PTerm Demo Application in Go\nDESCRIPTION: This snippet defines the main program structure for the demo, initializes configuration flags, sets up prerequisite data structures and variables, and orchestrates the sequential demonstration of PTerm features using a series of showcase calls. Dependencies include 'flag' for CLI flag handling, 'time' for delays, as well as 'pterm' and 'pterm/putils' for UI components. The main function is the entry point, taking optional speedup and skip-intro flags, and expects no input other than CLI arguments. Demo output is produced interactively as the program runs.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"flag\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\n// Speed the demo up, by setting this flag.\n// Usefull for debugging.\n// Example:\n//\n//\tgo run main.go -speedup\nvar speedup = flag.Bool(\"speedup\", false, \"Speed up the demo\")\nvar skipIntro = flag.Bool(\"skip-intro\", false, \"Skips the intro\")\nvar second = time.Second\n\nvar pseudoProgramList = strings.Split(\"pseudo-excel pseudo-photoshop pseudo-chrome pseudo-outlook pseudo-explorer \"+\n\t\"pseudo-git pseudo-vsc pseudo-intellij pseudo-minecraft pseudo-scoop pseudo-chocolatey\", \" \")\n\nfunc main() {\n\tsetup() // Setup the demo (flags etc.)\n\n\t// Show intro\n\tif !*skipIntro {\n\t\tintroScreen()\n\t\tclear()\n\t}\n\n\tshowcase(\"Structured Logging\", 5, func() {\n\t\tlogger := pterm.DefaultLogger.\n\t\t\tWithLevel(pterm.LogLevelTrace)\n\t\tlogger.Trace(\"Doing not so important stuff\", logger.Args(\"priority\", \"super low\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tinterstingStuff := map[string]any{\n\t\t\t\"when were crayons invented\":  \"1903\",\n\t\t\t\"what is the meaning of life\": 42,\n\t\t\t\"is this interesting\":         true,\n\t\t}\n\t\tlogger.Debug(\"This might be interesting\", logger.ArgsFromMap(interstingStuff))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Info(\"That was actually interesting\", logger.Args(\"such\", \"wow\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Warn(\"Oh no, I see an error coming to us!\", logger.Args(\"speed\", 88, \"measures\", \"mph\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Error(\"Damn, here it is!\", logger.Args(\"error\", \"something went wrong\"))\n\t\ttime.Sleep(time.Second * 3)\n\t\tlogger.Info(\"But what's really cool is, that you can print very long logs, and PTerm will automatically wrap them for you! Say goodbye to text, that has weird line breaks!\", logger.Args(\"very\", \"long\"))\n\t})\n\n\tshowcase(\"Progress bar\", 2, func() {\n\t\tpb, _ := pterm.DefaultProgressbar.WithTotal(len(pseudoProgramList)).WithTitle(\"Installing stuff\").Start()\n\t\tfor i := 0; i < pb.Total; i++ {\n\t\t\tpb.UpdateTitle(\"Installing \" + pseudoProgramList[i])\n\t\t\tif pseudoProgramList[i] == \"pseudo-minecraft\" {\n\t\t\t\tpterm.Warning.Println(\"Could not install pseudo-minecraft\\nThe company policy forbids games.\")\n\t\t\t} else {\n\t\t\t\tpterm.Success.Println(\"Installing \" + pseudoProgramList[i])\n\t\t\t}\n\t\t\tpb.Increment()\n\t\t\ttime.Sleep(second / 2)\n\t\t}\n\t\tpb.Stop()\n\t})\n\n\tshowcase(\"Spinner\", 2, func() {\n\t\tlist := pseudoProgramList[7:]\n\t\tspinner, _ := pterm.DefaultSpinner.Start(\"Installing stuff\")\n\t\tfor i := 0; i < len(list); i++ {\n\t\t\tspinner.UpdateText(\"Installing \" + list[i])\n\t\t\tif list[i] == \"pseudo-minecraft\" {\n\t\t\t\tpterm.Warning.Println(\"Could not install pseudo-minecraft\\nThe company policy forbids games.\")\n\t\t\t} else {\n\t\t\t\tpterm.Success.Println(\"Installing \" + list[i])\n\t\t\t}\n\t\t\ttime.Sleep(second)\n\t\t}\n\t\tspinner.Success()\n\t})\n\n\tshowcase(\"Live Output\", 2, func() {\n\t\tpterm.Info.Println(\"You can use an Area to display changing output:\")\n\t\tpterm.Println()\n\t\tarea, _ := pterm.DefaultArea.WithCenter().Start() // Start the Area printer, with the Center option.\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tstr, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(time.Now().Format(\"15:04:05\"))).Srender() // Save current time in str.\n\t\t\tarea.Update(str)                                                                                              // Update Area contents.\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\t\tarea.Stop()\n\t})\n\n\tshowcase(\"Tables\", 4, func() {\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\ttd := [][]string{\n\t\t\t{\"Library\", \"Description\"},\n\t\t\t{\"PTerm\", \"Make beautiful CLIs\"},\n\t\t\t{\"Testza\", \"Programmer friendly test framework\"},\n\t\t\t{\"Cursor\", \"Move the cursor around the terminal\"},\n\t\t}\n\t\ttable, _ := pterm.DefaultTable.WithHasHeader().WithData(td).Srender()\n\t\tboxedTable, _ := pterm.DefaultTable.WithHasHeader().WithData(td).WithBoxed().Srender()\n\t\tpterm.DefaultCenter.Println(table)\n\t\tpterm.DefaultCenter.Println(boxedTable)\n\t})\n\n\tshowcase(\"TrueColor Support\", 7, func() {\n\t\tfrom := pterm.NewRGB(0, 255, 255) // This RGB value is used as the gradients start point.\n\t\tto := pterm.NewRGB(255, 0, 255)   // This RGB value is used as the gradients first point.\n\n\t\tstr := \"If your terminal has TrueColor support, you can use RGB colors!\\nYou can even fade them :)\\n\\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.\"\n\t\tstrs := strings.Split(str, \"\")\n\t\tvar fadeInfo string // String which will be used to print info.\n\t\t// For loop over the range of the string length.\n\t\tfor i := 0; i < len(str); i++ {\n\t\t\t// Append faded letter to info string.\n\t\t\tfadeInfo += from.Fade(0, float32(len(str)), float32(i), to).Sprint(strs[i])\n\t\t}\n\t\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(fadeInfo)\n\t})\n\n\tshowcase(\"Fully Customizable\", 2, func() {\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\ttext := \"All printers are fully customizable!\"\n\t\tarea := pterm.DefaultArea.WithCenter()\n\t\tarea.Update(pterm.DefaultBox.Sprintln(text))\n\t\ttime.Sleep(second)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopLeft().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopCenter().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleTopRight().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomRight().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomCenter().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithTitle(\"Some title!\").WithTitleBottomLeft().Sprintln(text))\n\t\ttime.Sleep(second / 3)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgCyan)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgRed)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).WithBottomPadding(1).WithLeftPadding(1).WithRightPadding(1).WithBoxStyle(pterm.NewStyle(pterm.FgGreen)).Sprintln(text))\n\t\ttime.Sleep(second / 5)\n\t\tarea.Update(pterm.DefaultBox.WithTopPadding(1).\n\t\t\tWithBottomPadding(1).\n\t\t\tWithLeftPadding(1).\n\t\t\tWithRightPadding(1).\n\t\t\tWithHorizontalString(\"═\").\n\t\t\tWithVerticalString(\"║\").\n\t\t\tWithBottomLeftCornerString(\"╗\").\n\t\t\tWithBottomRightCornerString(\"╔\").\n\t\t\tWithTopLeftCornerString(\"╝\").\n\t\t\tWithTopRightCornerString(\"╚\").\n\t\t\tSprintln(text))\n\t\tarea.Stop()\n\t})\n\n\tshowcase(\"Themes\", 2, func() {\n\t\tpterm.Info.Println(\"You can change the color theme of PTerm easily to fit your needs!\\nThis is the default one:\")\n\t\ttime.Sleep(second / 2)\n\t\t// Print every value of the default theme with its own style.\n\t\tv := reflect.ValueOf(pterm.ThemeDefault)\n\t\ttypeOfS := v.Type()\n\n\t\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\t\tif ok {\n\t\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t\t}\n\t\t}\n\t})\n\n\tshowcase(\"And much more!\", 3, func() {\n\t\tfor i := 0; i < 4; i++ {\n\t\t\tpterm.Println()\n\t\t}\n\t\tbox := pterm.DefaultBox.\n\t\t\tWithBottomPadding(1).\n\t\t\tWithTopPadding(1).\n\t\t\tWithLeftPadding(3).\n\t\t\tWithRightPadding(3).\n\t\t\tSprintf(\"Have fun exploring %s!\", pterm.Cyan(\"PTerm\"))\n\t\tpterm.DefaultCenter.Println(box)\n\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Section Rendering with Styling in Pterm for Go Terminal Applications\nDESCRIPTION: These snippets implement terminal section rendering using Pterm in Go. Sections are stylized blocks of text with titles, subtitles, and customizable style options. It requires handling of terminal dimensions, text wrapping, and color support. Inputs include section title, content text, and style configurations. Outputs are visually distinguished sections printed to the terminal with borders, colors, and spacing. Limitations relate to terminal size and color compatibility.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_16\n\nLANGUAGE: Go\nCODE:\n```\npackage pterm\n\n// SectionPrinter handles rendering sections of terminal UI\nfunc (sp *SectionPrinter) Render(title string, content string) error {\n\t// Draw section title with style\n\t// Wrap content text\n\t// Print with indentation and colors\n\treturn nil\n}\n\n// Helper methods for styling sections\nfunc applySectionStyle(text string, style Style) string {\n\treturn \"\"\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Customized Boxes with Different Title Positions in Go using PTerm\nDESCRIPTION: This snippet demonstrates how to create boxes with customized padding and position titles in different locations around the box. It uses the PTerm library to create seven boxes with the same content but different title positions, and displays them in a panel layout for visual comparison.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/box/title/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Create a default box with specified padding\n\tpaddedBox := pterm.DefaultBox.WithLeftPadding(4).WithRightPadding(4).WithTopPadding(1).WithBottomPadding(1)\n\n\t// Define a title for the box\n\ttitle := pterm.LightRed(\"I'm a box!\")\n\n\t// Create boxes with the title positioned differently and containing different content\n\tbox1 := paddedBox.WithTitle(title).Sprint(\"Hello, World!\\n      1\")                         // Title at default position (top left)\n\tbox2 := paddedBox.WithTitle(title).WithTitleTopCenter().Sprint(\"Hello, World!\\n      2\")    // Title at top center\n\tbox3 := paddedBox.WithTitle(title).WithTitleTopRight().Sprint(\"Hello, World!\\n      3\")     // Title at top right\n\tbox4 := paddedBox.WithTitle(title).WithTitleBottomRight().Sprint(\"Hello, World!\\n      4\")  // Title at bottom right\n\tbox5 := paddedBox.WithTitle(title).WithTitleBottomCenter().Sprint(\"Hello, World!\\n      5\") // Title at bottom center\n\tbox6 := paddedBox.WithTitle(title).WithTitleBottomLeft().Sprint(\"Hello, World!\\n      6\")   // Title at bottom left\n\tbox7 := paddedBox.WithTitle(title).WithTitleTopLeft().Sprint(\"Hello, World!\\n      7\")      // Title at top left\n\n\t// Render the boxes in a panel layout\n\tpterm.DefaultPanel.WithPanels([][]pterm.Panel{\n\t\t{{box1}, {box2}, {box3}},\n\t\t{{box4}, {box5}, {box6}},\n\t\t{{box7}},\n\t}).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Horizontal Bar Chart with Custom Width in Go using PTerm\nDESCRIPTION: Demonstrates how to create a horizontal bar chart with a custom width using PTerm. The example defines nine bars with different values and renders them horizontally with a fixed width of 5 units.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_8\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbarData := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is horizontal and has a width of 5\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(barData).WithHorizontal().WithWidth(5).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering PTerm Horizontal Bar Chart in Go\nDESCRIPTION: This snippet demonstrates how to create and render a horizontal bar chart using the PTerm library. It defines the bar data and uses `pterm.DefaultBarChart.WithBars().WithHorizontal().Render()` to display the chart horizontally.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create a bar chart with the defined data\n\t// The chart is displayed horizontally\n\t// The Render() function is called to display the chart\n\tpterm.DefaultBarChart.WithBars(bars).WithHorizontal().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering PTerm Default Bar Chart in Go\nDESCRIPTION: This snippet shows how to create and render a default vertical bar chart using the PTerm library. It defines the data for the bars as a slice of `pterm.Bar` structs and uses `pterm.DefaultBarChart.WithBars().Render()` to display the chart with standard settings.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_10\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the bar chart. Each bar is represented by a `pterm.Bar` struct.\n\t// The `Label` field represents the label of the bar, and the `Value` field represents the value of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Use the `DefaultBarChart` from the `pterm` package to create a bar chart.\n\t// The `WithBars` method is used to set the bars of the chart.\n\t// The `Render` method is used to display the chart.\n\tpterm.DefaultBarChart.WithBars(bars).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Clearing Terminal Screen in Go\nDESCRIPTION: Provides a simple function to clear the terminal screen using ANSI escape codes. This is a standard cross-platform method supported by most modern terminals. It takes no arguments and has no dependencies beyond the standard 'print' function.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc clear() {\n\tprint(\"\\033[H\\033[2J\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Nil Check Test for PTerm Printers in Go\nDESCRIPTION: A template for testing that a PTerm printer can handle nil values without producing errors. This ensures that printers work correctly even when not explicitly configured.\nSOURCE: https://github.com/pterm/pterm/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc TestTemplatePrinterNilPrint(t *testing.T) { // TODO: Replace \"Template\" with actual printer name.\n\tp := TemplatePrinter{} // TODO: Replace \"Template\" with actual printer name.\n\tp.Println(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Centering Text and Big Letters in Terminal with PTerm in Go\nDESCRIPTION: This example demonstrates use of DefaultCenter to center both a text block and stylized large letters (BigText) on the terminal screen using PTerm. It generates 'PTerm' in big letters and offers an option to center blocks as a whole or each line separately. Key dependencies are PTerm and its putils subpackage. Inputs are strings to center; outputs are centered text or big letter blocks rendered to the terminal. Ideal for banners or titles in terminal applications.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_25\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Print a block of text centered in the terminal\n\tpterm.DefaultCenter.Println(\"This text is centered!\\nIt centers the whole block by default.\\nIn that way you can do stuff like this:\")\n\n\t// Generate BigLetters and store in 's'\n\ts, _ := pterm.DefaultBigText.WithLetters(putils.LettersFromString(\"PTerm\")).Srender()\n\n\t// Print the BigLetters 's' centered in the terminal\n\tpterm.DefaultCenter.Println(s)\n\n\t// Print each line of the text separately centered in the terminal\n\tpterm.DefaultCenter.WithCenterEachLineSeparately().Println(\"This text is centered!\\nBut each line is\\ncentered\\nseparately\")\n}\n\n```\n\n----------------------------------------\n\nTITLE: Prompting Interactive Continue Using PTerm in Go\nDESCRIPTION: This snippet demonstrates usage of PTerm's interactive continue prompt to pause program execution until the user presses Enter. The prompt message is \"Press 'Enter' to continue...\" by default. After user interaction, the program captures the empty input and prints it with informative prefix. It requires the github.com/pterm/pterm module. There are no inputs except the Enter key press, and output is the printed acknowledgment.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_37\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Create an interactive continue prompt with default settings\n\t// This will pause the program execution until the user presses enter\n\t// The message displayed is \"Press 'Enter' to continue...\"\n\tprompt := pterm.DefaultInteractiveContinue\n\n\t// Show the prompt and wait for user input\n\t// The returned result is the user's input (should be empty as it's a continue prompt)\n\t// The second return value is an error which is ignored here\n\tresult, _ := prompt.Show()\n\n\t// Print a blank line for better readability\n\tpterm.Println()\n\n\t// Print the user's input with an info prefix\n\t// As this is a continue prompt, the input should be empty\n\tpterm.Info.Printfln(\"You answered: %s\", result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Manipulating Terminal Colors in PTrem (Go)\nDESCRIPTION: These snippets provide functions and methods for defining, manipulating, and transforming color representations in the PTrem terminal framework. Functions handle construction of color objects, conversion between types, and computations based on color parameters. Dependencies include Go's standard color packages and PTrem internals. Inputs are typically color codes or names, and outputs are colorized terminal representations, with constraints on supported color spaces.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_18\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Function for creating a color from RGB values \nfunc RGB(r uint8, g uint8, b uint8) Color {\n\t// Implementation logic\n}\n\n```\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Method to lighten a color by a specified amount\nfunc (c Color) Lighten(amount float64) Color {\n\t// Implementation logic\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customize Heatmap Legend Label and Display using pterm Go\nDESCRIPTION: This snippet demonstrates customizing the legend displayed with a pterm heatmap. It shows how to set a custom label for the legend and configure it to only display the colored cells corresponding to the data range, rather than the full spectrum.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_39\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the header data for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a custom legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options\n\t// Options are chained in a single line for simplicity\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithEnableRGB().\n\t\tWithLegendLabel(\"custom\").\n\t\tWithLegendOnlyColoredCells().\n\t\tRender() // Render the heatmap\n}\n```\n\n----------------------------------------\n\nTITLE: Showcasing a titled content block with Pterm and timed delay in Go\nDESCRIPTION: This function prints a full-width header with a light blue background using Pterm, followed by an empty line. It then waits half a second, executes a provided content function, waits for a specified number of seconds, and finally clears the terminal screen. The design enables staged presentation of terminal content with visual headers and controlled display durations. It relies on Pterm for styling and time for delays.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/demo/README.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nfunc showcase(title string, seconds int, content func()) {\n\tpterm.DefaultHeader.WithBackgroundStyle(pterm.NewStyle(pterm.BgLightBlue)).WithFullWidth().Println(title)\n\tpterm.Println()\n\ttime.Sleep(second / 2)\n\tcontent()\n\ttime.Sleep(second * time.Duration(seconds))\n\tprint(\"\\033[H\\033[2J\")\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling and Disabling Terminal Output with PTerm in Go\nDESCRIPTION: Shows how to control terminal output by enabling and disabling it at specific points in your program. This example demonstrates how to hide output during certain iterations of a loop using PTerm's output control functions.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Loop from 0 to 14\n\tfor i := 0; i < 15; i++ {\n\t\tswitch i {\n\t\tcase 5:\n\t\t\t// At the 5th iteration, print a message and disable the output\n\t\t\tpterm.Info.Println(\"Disabled Output!\")\n\t\t\tpterm.DisableOutput()\n\t\tcase 10:\n\t\t\t// At the 10th iteration, enable the output and print a message\n\t\t\tpterm.EnableOutput()\n\t\t\tpterm.Info.Println(\"Enabled Output!\")\n\t\t}\n\n\t\t// Print a progress message for each iteration\n\t\tpterm.Printf(\"Printing something... [%d/%d]\\n\", i, 15)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Single Bullet List Item - PTerm PUtils - Go\nDESCRIPTION: Constructs a single PTerm BulletListItem object from a string and padding. This can be used to build more complex nested lists.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc BulletListItemFromString(text string, padding string) pterm.BulletListItem\n```\n\n----------------------------------------\n\nTITLE: Creating Bullet List from Strings Slice - PTerm PUtils - Go\nDESCRIPTION: Generates a PTerm BulletListPrinter from a slice of strings, enabling the printing of multi-item bullet lists. Takes a string slice and padding.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nfunc BulletListFromStrings(s []string, padding string) pterm.BulletListPrinter\n```\n\n----------------------------------------\n\nTITLE: Converting String to PTerm Letters with RGB - PTerm PUtils - Go\nDESCRIPTION: Converts a string into PTerm Letters, applying a specific RGB color to each character. Useful for colorful text effects.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\nfunc LettersFromStringWithRGB(text string, rgb pterm.RGB) pterm.Letters\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Charts with Only Negative Values Using PTerm in Go\nDESCRIPTION: Shows how to create bar charts featuring only negative values using PTerm, in both vertical and horizontal orientations. The snippet uses PTerm and a slice of negative-value bars, with WithShowValue enabled to annotate bars with their values. Inputs must only have negative values for accurate demonstration.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars with negative values.\n\t// Each bar is represented by a struct with a label and a value.\n\tnegativeBars := pterm.Bars{\n\t\t{Label: \"Bar 1\", Value: -5},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Longer Label\", Value: -7},\n\t}\n\n\t// Print an informational message to the console.\n\tpterm.Info.Println(\"Chart example with negative only values (bars use 100% of chart area)\")\n\n\t// Create a vertical bar chart with the defined bars.\n\t// The WithShowValue() option is used to display the value of each bar in the chart.\n\t// The Render() method is called to draw the chart.\n\t_ = pterm.DefaultBarChart.WithBars(negativeBars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The WithHorizontal() option is used to orient the chart horizontally.\n\t// The WithShowValue() option and Render() method are used in the same way as before.\n\t_ = pterm.DefaultBarChart.WithHorizontal().WithBars(negativeBars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying the PTerm Demo Intro Screen in Go\nDESCRIPTION: This snippet prints an ASCII-styled PTerm logo, a header, and informational text as an introduction to the demo using PTerm's text, center, and header printing facilities. It utilizes the pterm.DefaultBigText and putils.LettersFromStringWithStyle to generate colorful text, and shows the last update time. Requires the PTerm package and assumes prior initialization. There are no required inputs or arguments; all context is handled through demo setup.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/demo/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nfunc introScreen() {\n\tptermLogo, _ := pterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.NewStyle(pterm.FgLightCyan)),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.NewStyle(pterm.FgLightMagenta))).\n\t\tSrender()\n\n\tpterm.DefaultCenter.Print(ptermLogo)\n\n\tpterm.DefaultCenter.Print(pterm.DefaultHeader.WithFullWidth().WithBackgroundStyle(pterm.NewStyle(pterm.BgLightBlue)).WithMargin(10).Sprint(\"PTDP - PTerm Demo Program\"))\n\n\tpterm.Info.Println(\"This animation was generated with the latest version of PTerm!\" +\n\t\t\"\\nPTerm works on nearly every terminal and operating system.\" +\n\t\t\"\\nIt's super easy to use!\" +\n\t\t\"\\nIf you want, you can customize everything :)\" +\n\t\t\"\\nYou can see the code of this demo in the \" + pterm.LightMagenta(\"./_examples/demo\") + \" directory.\" +\n\t\t\"\\n\" +\n\t\t\"\\nThis demo was updated at: \" + pterm.Green(time.Now().Format(\"02 Jan 2006 - 15:04:05 MST\")))\n\tpterm.Println()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Negative Value BarCharts (Vertical and Horizontal) in Go Using PTerm\nDESCRIPTION: This snippet demonstrates the use of PTerm for rendering bar charts with only negative values. It initializes an array of pterm.Bars with negative integer values. Both vertical and horizontal charts are produced, with visible numerical bar values via WithShowValue. pterm.Info prints a contextual message prior to the charts. The Render method is used for final output. Requires only the PTerm library; input is a pterm.Bars slice. Output is a terminal graphical chart strictly for negative values, making full use of available chart space. Constraints: The visual may look misleading if zero or positive values are supplied.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_14\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define a set of bars with negative values.\n\t// Each bar is represented by a struct with a label and a value.\n\tnegativeBars := pterm.Bars{\n\t\t{Label: \"Bar 1\", Value: -5},\n\t\t{Label: \"Bar 2\", Value: -3},\n\t\t{Label: \"Longer Label\", Value: -7},\n\t}\n\n\t// Print an informational message to the console.\n\tpterm.Info.Println(\"Chart example with negative only values (bars use 100% of chart area)\")\n\n\t// Create a vertical bar chart with the defined bars.\n\t// The WithShowValue() option is used to display the value of each bar in the chart.\n\t// The Render() method is called to draw the chart.\n\t_ = pterm.DefaultBarChart.WithBars(negativeBars).WithShowValue().Render()\n\n\t// Create a horizontal bar chart with the same bars.\n\t// The WithHorizontal() option is used to orient the chart horizontally.\n\t// The WithShowValue() option and Render() method are used in the same way as before.\n\t_ = pterm.DefaultBarChart.WithHorizontal().WithBars(negativeBars).WithShowValue().Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Colored BigText Headers in Go Using PTerm\nDESCRIPTION: This example demonstrates the rendering of big stylized text with distinct colors for each segment using PTerm and the putils helper functions. 'P' is colored cyan and 'Term' light magenta. It showcases the use of WithLetters and Render to output large colored banners to the terminal, ideal for CLI headers or section names. Input: string parts with color styles. Output: colored big text visual to the monospaced terminal. Depends on PTerm and its putils subpackage.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_18\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Initialize a big text display with the letters \"P\" and \"Term\"\n\t// \"P\" is displayed in cyan and \"Term\" is displayed in light magenta\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle())).\n\t\tRender() // Render the big text to the terminal\n}\n\n```\n\n----------------------------------------\n\nTITLE: Iterating and Displaying Pterm Default Theme Styles in Go\nDESCRIPTION: This Go main function demonstrates iterating through the fields of the `pterm.ThemeDefault` struct using reflection. It first prints an informational message using `pterm.Info.Println`. Then, it iterates over the fields of `pterm.ThemeDefault`, checks if a field is of type `pterm.Style`, and if so, prints the field's name using that specific style's `Println` method. A short delay (`time.Sleep`) is introduced between printing each style name for better visual demonstration. Requires the `pterm`, `reflect`, and `time` packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/theme/demo/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"reflect\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Print an informational message about the default theme styles.\n\tpterm.Info.Println(\"These are the default theme styles.\\nYou can modify them easily to your personal preference,\\nor create new themes from scratch :)\")\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Get the value and type of the default theme.\n\tv := reflect.ValueOf(pterm.ThemeDefault)\n\ttypeOfS := v.Type()\n\n\t// Check if the type of the default theme is 'pterm.Theme'.\n\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t// Iterate over each field in the default theme.\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t// Try to convert the field to 'pterm.Style'.\n\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\tif ok {\n\t\t\t\t// Print the field name using its own style.\n\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t}\n\t\t\t// Pause for a quarter of a second to make the output easier to read.\n\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t}\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Multi-Colored BigText in Go using PTerm\nDESCRIPTION: This snippet demonstrates how to create and render a colorful big text display using PTerm. It initializes a big text with the word 'PTerm' where 'P' is displayed in cyan and 'Term' is displayed in light magenta using PTerm's styling capabilities.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bigtext/colored/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Initialize a big text display with the letters \"P\" and \"Term\"\n\t// \"P\" is displayed in cyan and \"Term\" is displayed in light magenta\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle())).Render() // Render the big text to the terminal\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Theme Styles Demo Using PTerm in Go\nDESCRIPTION: This snippet presents the default theme styles available in PTerm and prints their names in their respective styles. It depends on the \"github.com/pterm/pterm\" package, along with the Go standard library's \"reflect\" and \"time\". No parameters are required; it iterates over all fields in the ThemeDefault struct, printing each name with styling and pausing briefly for readability. Output is a list of styled theme elements printed to the terminal. It is informational, intended to display available theme styles interactively.\nSOURCE: https://github.com/pterm/pterm/blob/master/README.md#_snippet_68\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"reflect\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Print an informational message about the default theme styles.\n\tpterm.Info.Println(\"These are the default theme styles.\\nYou can modify them easily to your personal preference,\\nor create new themes from scratch :)\")\n\n\t// Print a blank line for better readability.\n\tpterm.Println()\n\n\t// Get the value and type of the default theme.\n\tv := reflect.ValueOf(pterm.ThemeDefault)\n\ttypeOfS := v.Type()\n\n\t// Check if the type of the default theme is 'pterm.Theme'.\n\tif typeOfS == reflect.TypeOf(pterm.Theme{}) {\n\t\t// Iterate over each field in the default theme.\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\t// Try to convert the field to 'pterm.Style'.\n\t\t\tfield, ok := v.Field(i).Interface().(pterm.Style)\n\t\t\tif ok {\n\t\t\t\t// Print the field name using its own style.\n\t\t\t\tfield.Println(typeOfS.Field(i).Name)\n\t\t\t}\n\t\t\t// Pause for a quarter of a second to make the output easier to read.\n\t\t\ttime.Sleep(time.Millisecond * 250)\n\t\t}\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Checkmark Symbols in PTerm's Interactive Multiselect\nDESCRIPTION: Shows how to customize the checkmark symbols used in PTerm's interactive multiselect component. This example uses a green plus sign (+) for checked items and a red minus sign (-) for unchecked items, while also disabling the filter feature.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_multiselect/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and define the checkmark symbols\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithCheckmark(&pterm.Checkmark{Checked: pterm.Green(\"+\"), Unchecked: pterm.Red(\"-\")})\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Colored Big Text using PTerm in Go\nDESCRIPTION: This snippet shows how to render big text with specific parts colored differently. It splits the text 'PTerm' into 'P' and 'Term', applies cyan to 'P' and light magenta to 'Term' using `LettersFromStringWithStyle` and renders the combined result. This technique allows fine-grained color control over large text displays.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/bigtext/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n\t\"github.com/pterm/pterm/putils\"\n)\n\nfunc main() {\n\t// Initialize a big text display with the letters \"P\" and \"Term\"\n\t// \"P\" is displayed in cyan and \"Term\" is displayed in light magenta\n\tpterm.DefaultBigText.WithLetters(\n\t\tputils.LettersFromStringWithStyle(\"P\", pterm.FgCyan.ToStyle()),\n\t\tputils.LettersFromStringWithStyle(\"Term\", pterm.FgLightMagenta.ToStyle())).\n\t\tRender() // Render the big text to the terminal\n}\n```\n\n----------------------------------------\n\nTITLE: Render Basic Heatmap with Axis Labels using pterm Go\nDESCRIPTION: This snippet demonstrates how to generate and display a basic heatmap using the pterm library. It requires defining the heatmap data as a 2D slice of float32 and providing axis labels using the HeatmapAxis struct. The example also enables RGB colors for a wider color range, though RGB support depends on the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_37\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap. Each sub-array represents a row in the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the labels for the X and Y axes of the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Create a heatmap with the defined data and axis labels, and enable RGB colors.\n\t// Then render the heatmap.\n\tpterm.DefaultHeatmap.WithAxisData(headerData).WithData(data).WithEnableRGB().Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Bar Chart Height with PTerm in Go\nDESCRIPTION: Shows how to control the height of a vertical bar chart using PTerm's WithHeight method. The snippet requires the PTerm package and defines a set of bars with various heights; it sets the chart's height to five rows in the terminal. Only the height parameter is customized—values will be scaled accordingly.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/barchart/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define a slice of Bar structs. Each struct represents a bar in the chart.\n\t// The Label field is the name of the bar and the Value field is the height of the bar.\n\tbars := []pterm.Bar{\n\t\t{Label: \"A\", Value: 10},\n\t\t{Label: \"B\", Value: 20},\n\t\t{Label: \"C\", Value: 30},\n\t\t{Label: \"D\", Value: 40},\n\t\t{Label: \"E\", Value: 50},\n\t\t{Label: \"F\", Value: 40},\n\t\t{Label: \"G\", Value: 30},\n\t\t{Label: \"H\", Value: 20},\n\t\t{Label: \"I\", Value: 10},\n\t}\n\n\t// Create and render a bar chart with the defined bars and a height of 5.\n\t// The WithBars method is used to set the bars of the chart.\n\t// The WithHeight method is used to set the height of the chart.\n\t// The Render method is used to display the chart in the terminal.\n\tpterm.DefaultBarChart.WithBars(bars).WithHeight(5).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Printing RGB Color Fading in Terminal with Go and pterm\nDESCRIPTION: Defines RGB colors and prints three example strings with gradient foreground and background fading. Uses the pterm library's NewRGB and NewRGBStyle methods to create color styles that transition smoothly across string characters. This snippet showcases terminal output styling only available in terminals supporting TrueColor.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/coloring/fade-colors-rgb-style/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB colors\n\twhite := pterm.NewRGB(255, 255, 255)\n\tgrey := pterm.NewRGB(128, 128, 128)\n\tblack := pterm.NewRGB(0, 0, 0)\n\tred := pterm.NewRGB(255, 0, 0)\n\tpurple := pterm.NewRGB(255, 0, 255)\n\tgreen := pterm.NewRGB(0, 255, 0)\n\n\t// Define strings to be printed\n\tstr1 := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstr2 := \"The background and foreground colors can be customized individually.\"\n\tstr3 := \"Styles can also be applied. For example: Bold or Italic.\"\n\n\t// Print first string with color fading from white to purple\n\tprintFadedString(str1, white, purple, grey, black)\n\n\t// Print second string with color fading from purple to red\n\tprintFadedString(str2, black, purple, red, red)\n\n\t// Print third string with color fading from white to green and style changes\n\tprintStyledString(str3, white, green, red, black)\n}\n\n// printFadedString prints a string with color fading effect\nfunc printFadedString(str string, fgStart, fgEnd, bgStart, bgEnd pterm.RGB) {\n\tstrs := strings.Split(str, \"\")\n\tvar result string\n\tfor i := 0; i < len(str); i++ {\n\t\t// Create a style with color fading effect\n\t\tstyle := pterm.NewRGBStyle(fgStart.Fade(0, float32(len(str)), float32(i), fgEnd), bgStart.Fade(0, float32(len(str)), float32(i), bgEnd))\n\t\t// Append styled letter to result string\n\t\tresult += style.Sprint(strs[i])\n\t}\n\tpterm.Println(result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Displaying Basic Text Using PTerm in Go\nDESCRIPTION: Demonstrates using PTerm's DefaultBasicText printer to print plain text and concatenated colored text using LightMagenta styling. Requires 'github.com/pterm/pterm' package. Outputs simple lines of text to the terminal without special formatting beyond basic color support. Useful for lightweight text display or resolving progress bars and spinners in terminal applications.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_15\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// The DefaultBasicText is a basic text printer provided by PTerm.\n\t// It is used to print text without any special formatting.\n\tpterm.DefaultBasicText.Println(\"Default basic text printer.\")\n\n\t// The DefaultBasicText can be used in any context that requires a TextPrinter.\n\t// Here, we're using it with the LightMagenta function to color a portion of the text.\n\tpterm.DefaultBasicText.Println(\"Can be used in any\" + pterm.LightMagenta(\" TextPrinter \") + \"context.\")\n\n\t// The DefaultBasicText is also useful for resolving progress bars and spinners.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple RGB Color Fade Points for Gradient Text in Go with PTerm\nDESCRIPTION: Prints a string with a color gradient fading through multiple RGB colors and repeatedly prints a 'Hello, World!' message with a multi-point gradient across terminal height. The script uses PTerm's RGB Fade method supporting multiple intermediate colors for complex gradients. It depends on a TrueColor terminal and the PTerm package.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_30\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define RGB values for gradient points.\n\tstartColor := pterm.NewRGB(0, 255, 255)\n\tfirstPoint := pterm.NewRGB(255, 0, 255)\n\tsecondPoint := pterm.NewRGB(255, 0, 0)\n\tthirdPoint := pterm.NewRGB(0, 255, 0)\n\tendColor := pterm.NewRGB(255, 255, 255)\n\n\t// Define the string to be printed.\n\tstr := \"RGB colors only work in Terminals which support TrueColor.\"\n\tstrs := strings.Split(str, \"\")\n\n\t// Initialize an empty string for the faded info.\n\tvar fadeInfo string\n\n\t// Loop over the string length to create a gradient effect.\n\tfor i := 0; i < len(str); i++ {\n\t\t// Append each character of the string with a faded color to the info string.\n\t\tfadeInfo += startColor.Fade(0, float32(len(str)), float32(i), firstPoint).Sprint(strs[i])\n\t}\n\n\t// Print the info string with gradient effect.\n\tpterm.Info.Println(fadeInfo)\n\n\t// Get the terminal height.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the terminal height to print \"Hello, World!\" with a gradient effect.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Print the string with a color that fades from startColor to endColor.\n\t\tstartColor.Fade(0, float32(terminalHeight-2), float32(i), firstPoint, secondPoint, thirdPoint, endColor).Println(\"Hello, World!\")\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Heatmap with Custom Legend and RGB Colors Using pterm in Go\nDESCRIPTION: This snippet shows how to create a heatmap with RGB color support, custom legend label, and option to display only colored cells in the legend. It configures axis labels and disables boxed rendering. Prior to rendering, it prints an informational message to the terminal. The pterm package is required. Inputs are 2D float32 heatmap data and axis labels, and output is a terminal heatmap with customized legend styling.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the header data for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a custom legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options\n\t// Options are chained in a single line for simplicity\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithEnableRGB().\n\t\tWithLegendLabel(\"custom\").\n\t\tWithLegendOnlyColoredCells().\n\t\tRender() // Render the heatmap\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering Heatmap Using Pterm Library in Go\nDESCRIPTION: This snippet demonstrates how to create and render a heatmap visualization in a Go program using the pterm library. Dependencies include the pterm package which supports terminal graphics rendering. The snippet initializes a 2D slice of float32 values representing the heat intensity matrix, and sets corresponding string axis labels for both X and Y axes. It prints an informational message before configuring the heatmap with options to disable the boxed border and legend, then renders it. Input is a fixed data array and axis labels, and output is a terminal rendered heatmap visualization.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/separated/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport \"github.com/pterm/pterm\"\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has no rgb (supported by every terminal), no axis data and no legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the specified data and options, and render it.\n\tpterm.DefaultHeatmap.WithData(data).WithBoxed(false).WithAxisData(headerData).WithLegend(false).Render()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering pterm Heatmap with Custom RGB in Go\nDESCRIPTION: This snippet demonstrates how to initialize data and axis labels for a terminal heatmap using the pterm library in Go. It defines a custom RGB color range and configures the default heatmap renderer to use this data, axis labels, and color range before printing it to the console. Requires the pterm library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/custom_rgb/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\taxisLabels := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Define the color range for the heatmap.\n\trgbRange := []pterm.RGB{\n\t\tpterm.NewRGB(0, 0, 255),\n\t\tpterm.NewRGB(255, 0, 0),\n\t\tpterm.NewRGB(0, 255, 0),\n\t\tpterm.NewRGB(255, 255, 0),\n\t}\n\n\t// Create and render the heatmap.\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(axisLabels).\n\t\tWithEnableRGB().\n\t\tWithRGBRange(rgbRange...).Render()\n}\n```\n\n----------------------------------------\n\nTITLE: Render pterm Heatmap with Custom Legend in Go\nDESCRIPTION: This Go snippet initializes and renders a pterm heatmap. It defines the data and axis labels, enables RGB colors, sets a custom legend label ('custom'), and configures the legend to show only colored cells before rendering the visual output to the terminal.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/custom_legend/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the header data for the heatmap\n\theaderData := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a custom legend.\")\n\tpterm.Println()\n\n\t// Create the heatmap with the defined data and options\n\t// Options are chained in a single line for simplicity\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(headerData).\n\t\tWithEnableRGB().\n\t\tWithLegendLabel(\"custom\").\n\t\tWithLegendOnlyColoredCells().\n\t\tRender() // Render the heatmap\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Interactive Multiselect Keys with PTerm in Go\nDESCRIPTION: This Go snippet demonstrates initializing and displaying an interactive multiselect using the PTerm library. It sets up five selectable options, disables the filter feature, and customizes which keys are used for confirming and selecting (Enter for confirm, Space for select) by leveraging the atomicgo.dev/keyboard/keys package. Inputs consist of user keyboard actions, and outputs are the user-selected options displayed in green; dependencies include fmt, github.com/pterm/pterm, and atomicgo.dev/keyboard/keys. Limitations include command-line-only interaction and no filter functionality enabled.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/interactive_multiselect/custom-keys/README.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"atomicgo.dev/keyboard/keys\"\n\t\"fmt\"\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Initialize an empty slice to hold the options\n\tvar options []string\n\n\t// Populate the options slice with 5 options\n\tfor i := 0; i < 5; i++ {\n\t\toptions = append(options, fmt.Sprintf(\"Option %d\", i))\n\t}\n\n\t// Create a new interactive multiselect printer with the options\n\t// Disable the filter and set the keys for confirming and selecting options\n\tprinter := pterm.DefaultInteractiveMultiselect.\n\t\tWithOptions(options).\n\t\tWithFilter(false).\n\t\tWithKeyConfirm(keys.Enter).\n\t\tWithKeySelect(keys.Space)\n\n\t// Show the interactive multiselect and get the selected options\n\tselectedOptions, _ := printer.Show()\n\n\t// Print the selected options\n\tpterm.Info.Printfln(\"Selected options: %s\", pterm.Green(selectedOptions))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Heatmap with Custom RGB Color Range in pterm Using Go\nDESCRIPTION: This example sets up a heatmap with RGB color support and a user-defined RGB color gradient range using the pterm library. It supplies a color array defining the gradient and disables boxed borders for the heatmap. Axis labels are defined, and an informational message is printed. It expects a 2D float32 data input and outputs a heatmap visualization with a smooth RGB color transition.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/heatmap/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Define the data for the heatmap.\n\tdata := [][]float32{\n\t\t{0.9, 0.2, -0.7, 0.4, -0.5, 0.6, -0.3, 0.8, -0.1, -1.0, 0.1, -0.8, 0.3},\n\t\t{0.2, -0.7, -0.5, -0.3, -0.1, 0.1, 0.3, 0.5, 0.9, -0.9, -0.7, -0.5, -0.3},\n\t\t{0.4, 0.4, -0.3, -1.0, 0.3, -0.2, -0.9, 0.5, -0.3, -1.0, 0.6, -0.2, -0.9},\n\t\t{0.9, -0.5, -0.1, 0.3, 1, -0.7, -0.3, 0.1, 0.7, -0.9, -0.5, 0.2, 0.6},\n\t\t{0.5, 0.6, 0.1, -0.2, -0.7, 0.8, 0.6, 0.1, -0.5, -0.7, 0.7, 0.3, 0.0},\n\t}\n\n\t// Define the axis labels for the heatmap.\n\taxisLabels := pterm.HeatmapAxis{\n\t\tXAxis: []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"},\n\t\tYAxis: []string{\"1\", \"2\", \"3\", \"4\", \"5\"},\n\t}\n\n\t// Print an informational message.\n\tpterm.Info.Println(\"The following table has rgb (not supported by every terminal), axis data and a legend.\")\n\tpterm.Println()\n\n\t// Define the color range for the heatmap.\n\trgbRange := []pterm.RGB{\n\t\tpterm.NewRGB(0, 0, 255),\n\t\tpterm.NewRGB(255, 0, 0),\n\t\tpterm.NewRGB(0, 255, 0),\n\t\tpterm.NewRGB(255, 255, 0),\n\t}\n\n\t// Create and render the heatmap.\n\tpterm.DefaultHeatmap.\n\t\tWithData(data).\n\t\tWithBoxed(false).\n\t\tWithAxisData(axisLabels).\n\t\tWithEnableRGB().\n\t\tWithRGBRange(rgbRange...).\n\t\tRender()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Converting String to PTerm Letters - PTerm PUtils - Go\nDESCRIPTION: Converts a string into the PTerm Letters format, which is used for styling individual characters. Returns the PTerm Letters structure.\nSOURCE: https://github.com/pterm/pterm/blob/master/putils/README.md#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nfunc LettersFromString(text string) pterm.Letters\n```\n\n----------------------------------------\n\nTITLE: Creating Color Fade Effects Using RGB Colors with PTerm in Go\nDESCRIPTION: Prints a vertical gradient of 'Hello, World!' messages in terminal using a fade effect between two RGB colors (cyan to magenta). The program calculates the terminal height to determine gradient steps and applies linear fading for each line's color using PTerm's RGB Fade method. This requires a terminal supporting TrueColor and the PTerm library.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/README.md#_snippet_28\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/pterm/pterm\"\n)\n\nfunc main() {\n\t// Print an informational message.\n\tpterm.Info.Println(\"RGB colors only work in Terminals which support TrueColor.\")\n\n\t// Define the start and end points for the color gradient.\n\tstartColor := pterm.NewRGB(0, 255, 255) // Cyan\n\tendColor := pterm.NewRGB(255, 0, 255)   // Magenta\n\n\t// Get the terminal height to determine the gradient range.\n\tterminalHeight := pterm.GetTerminalHeight()\n\n\t// Loop over the range of the terminal height to create a color gradient.\n\tfor i := 0; i < terminalHeight-2; i++ {\n\t\t// Calculate the fade factor for the current step in the gradient.\n\t\tfadeFactor := float32(i) / float32(terminalHeight-2)\n\n\t\t// Create a color that represents the current step in the gradient.\n\t\tcurrentColor := startColor.Fade(0, 1, fadeFactor, endColor)\n\n\t\t// Print a string with the current color.\n\t\tcurrentColor.Println(\"Hello, World!\")\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Print Module: Text Output Functions in Go\nDESCRIPTION: This snippet provides various functions for printing different types of styled and unstyled text to the terminal. It includes functions for basic text, headers, and complex outputs, handling content concatenation, style application, and buffered output. Critical for displaying user-facing messages or formatted content in terminal applications.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/print.go:12.36,14.2  ... (truncated for brevity)\n```\n\n----------------------------------------\n\nTITLE: Formatting and Printing Prefixed Terminal Output in Go\nDESCRIPTION: This snippet implements prefix printers which format terminal text by adding configurable prefixes and styles to output lines. Dependencies include Go’s formatting packages and possibly terminal styling libraries. Key parameters involve prefix strings, colors, and styles. Inputs are plain text strings and outputs are styled text with prefixes for clearer CLI visual organization. It is designed for enhancing terminal output readability by adding structured labeling or icons.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:101.65,104.2\ngithub.com/pterm/pterm/prefix_printer.go:107.62,110.2\ngithub.com/pterm/pterm/prefix_printer.go:113.70,116.2\ngithub.com/pterm/pterm/prefix_printer.go:122.60,125.2\ngithub.com/pterm/pterm/prefix_printer.go:128.69,131.2\ngithub.com/pterm/pterm/prefix_printer.go:136.63,139.2\ngithub.com/pterm/pterm/prefix_printer.go:144.72,147.2\ngithub.com/pterm/pterm/prefix_printer.go:150.74,153.2\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:157.57,159.39\ngithub.com/pterm/pterm/prefix_printer.go:163.2,163.15\ngithub.com/pterm/pterm/prefix_printer.go:171.2,171.27\ngithub.com/pterm/pterm/prefix_printer.go:174.2,174.26\ngithub.com/pterm/pterm/prefix_printer.go:177.2,177.27\ngithub.com/pterm/pterm/prefix_printer.go:181.2,184.32\ngithub.com/pterm/pterm/prefix_printer.go:189.2,190.33\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:202.2,204.22\ngithub.com/pterm/pterm/prefix_printer.go:209.2,209.13\ngithub.com/pterm/pterm/prefix_printer.go:213.2,213.20\ngithub.com/pterm/pterm/prefix_printer.go:159.39,161.3\ngithub.com/pterm/pterm/prefix_printer.go:163.15,164.26\ngithub.com/pterm/pterm/prefix_printer.go:164.26,166.4\ngithub.com/pterm/pterm/prefix_printer.go:166.9,168.4\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:171.27,173.3\ngithub.com/pterm/pterm/prefix_printer.go:174.26,176.3\ngithub.com/pterm/pterm/prefix_printer.go:177.27,179.3\ngithub.com/pterm/pterm/prefix_printer.go:184.32,187.3\ngithub.com/pterm/pterm/prefix_printer.go:190.33,191.13\ngithub.com/pterm/pterm/prefix_printer.go:191.13,193.26\ngithub.com/pterm/pterm/prefix_printer.go:196.4,196.35\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:193.26,195.5\ngithub.com/pterm/pterm/prefix_printer.go:197.9,199.4\ngithub.com/pterm/pterm/prefix_printer.go:204.22,207.3\ngithub.com/pterm/pterm/prefix_printer.go:209.13,211.3\ngithub.com/pterm/pterm/prefix_printer.go:218.58,219.39\ngithub.com/pterm/pterm/prefix_printer.go:222.2,223.22\ngithub.com/pterm/pterm/prefix_printer.go:219.39,221.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:227.72,228.39\ngithub.com/pterm/pterm/prefix_printer.go:231.2,231.40\ngithub.com/pterm/pterm/prefix_printer.go:228.39,230.3\ngithub.com/pterm/pterm/prefix_printer.go:236.74,237.39\ngithub.com/pterm/pterm/prefix_printer.go:240.2,240.39\ngithub.com/pterm/pterm/prefix_printer.go:237.39,239.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:246.62,248.39\ngithub.com/pterm/pterm/prefix_printer.go:251.2,253.12\ngithub.com/pterm/pterm/prefix_printer.go:248.39,250.3\ngithub.com/pterm/pterm/prefix_printer.go:259.64,261.39\ngithub.com/pterm/pterm/prefix_printer.go:264.2,266.12\ngithub.com/pterm/pterm/prefix_printer.go:261.39,263.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:271.78,273.39\ngithub.com/pterm/pterm/prefix_printer.go:276.2,278.12\ngithub.com/pterm/pterm/prefix_printer.go:273.39,275.3\ngithub.com/pterm/pterm/prefix_printer.go:284.80,286.39\ngithub.com/pterm/pterm/prefix_printer.go:289.2,291.12\ngithub.com/pterm/pterm/prefix_printer.go:286.39,288.3\n```\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/prefix_printer.go:299.69,300.24\ngithub.com/pterm/pterm/prefix_printer.go:308.2,309.12\ngithub.com/pterm/pterm/prefix_printer.go:300.24,301.33\ngithub.com/pterm/pterm/prefix_printer.go:301.33,302.18\ngithub.com/pterm/pterm/prefix_printer.go:302.18,304.5\ngithub.com/pterm/pterm/prefix_printer.go:315.85,316.24\ngithub.com/pterm/pterm/prefix_printer.go:324.2,325.12\ngithub.com/pterm/pterm/prefix_printer.go:316.24,317.33\ngithub.com/pterm/pterm/prefix_printer.go:317.33,318.18\ngithub.com/pterm/pterm/prefix_printer.go:318.18,320.5\ngithub.com/pterm/pterm/prefix_printer.go:329.52,331.2\ngithub.com/pterm/pterm/prefix_printer.go:346.35,347.13\ngithub.com/pterm/pterm/prefix_printer.go:347.13,348.12\n```\n\n----------------------------------------\n\nTITLE: Tree Printer: Visualizing Hierarchical Structures in Go\nDESCRIPTION: This snippet contains functions for visualizing hierarchical tree data structures within the terminal. It includes methods for traversing nodes, indenting content, and managing node expansion or collapse states. Designed to render complex nested trees with proper indentation and lines, it facilitates navigation and comprehension of hierarchical data.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/tree_printer.go:51.63,54.2  ... (truncated for brevity)\n```\n\n----------------------------------------\n\nTITLE: Panel Printer: Rendering and Layout Management in Go\nDESCRIPTION: This snippet involves functions related to rendering panels within the terminal, managing layout dimensions, and handling user interactions. It processes layout calculations and printing routines, depending on parameters such as width, height, and style configurations. Key functionalities include determining panel sizes, handling focus, and rendering content with proper spacing and separators.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/panel_printer.go:78.45,80.33  ... (truncated for brevity)\n```\n\n----------------------------------------\n\nTITLE: Implementing RenderablePrinter Template in Go\nDESCRIPTION: A template for creating a new RenderablePrinter in PTerm that can render content as a string or directly to the terminal. It includes the basic Srender and Render methods that need to be implemented.\nSOURCE: https://github.com/pterm/pterm/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage pterm\n\ntype TemplatePrinter struct{\n\t// TODO: Add printer settings here\n}\n\n// Srender renders the Template as a string.\nfunc (p TemplatePrinter) Srender() (string, error) {\n\tvar ret strings.Builder\n\n    return ret.String(), nil\n}\n\n// Render prints the Template to the terminal.\nfunc (p TemplatePrinter) Render() error {\n\ts, err := p.Srender()\n    if err != nil {\n        return err\n    }\n    Println(s)\n\n    return nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Customizing Themes in PTrem (Go)\nDESCRIPTION: These code snippets define and customize theme structures for terminal output, encapsulating color and style configurations for various UI components. Typical methods include constructors and mutators for theme-related structs, relying on prior color definitions. Parameters allow for flexibility in theme colorization and style adjustments, with output affecting the appearance of rendered printers. Constraints relate to permissible theme properties and color combinations.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_19\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Defining a theme struct and setting attributes\nvar MyTheme = Theme{\n\tPrimaryStyle: Style{...},\n\tSecondaryStyle: Style{...}\n}\n\n```\n\nLANGUAGE: Go\nCODE:\n```\n// Example: Function to set theme globally\nfunc SetTheme(theme Theme) {\n\t// Implementation\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing LivePrinter Template in Go\nDESCRIPTION: A template for creating a new LivePrinter in PTerm that provides real-time updates to the terminal. It includes the necessary Start, Stop, GenericStart, and GenericStop methods for managing the printer's lifecycle.\nSOURCE: https://github.com/pterm/pterm/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Start the TemplatePrinter.\npackage pterm\nimport \"github.com/pterm/pterm\"\n\ntype TemplatePrinter struct{\n\n}\n\n\nfunc (s TemplatePrinter) Start(text...any) (*TemplatePrinter, error) { // TODO: Replace Template with actual printer.\n\t// TODO: start logic\n\treturn &s, nil\n}\n\n// Stop terminates the TemplatePrinter immediately.\n// The TemplatePrinter will not resolve into anything.\nfunc (s *TemplatePrinter) Stop() error {\n\t// TODO: stop logic\n    return nil\n}\n\n// GenericStart runs Start, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Start instead of this in your program.\nfunc (s *TemplatePrinter) GenericStart() (*LivePrinter, error) {\n\t_, err := s.Start()\n\tlp := LivePrinter(s)\n\treturn &lp, err\n}\n\n// GenericStop runs Stop, but returns a LivePrinter.\n// This is used for the interface LivePrinter.\n// You most likely want to use Stop instead of this in your program.\nfunc (s *TemplatePrinter) GenericStop() (*LivePrinter, error) {\n\terr := s.Stop()\n\tlp := LivePrinter(s)\n\treturn &lp, err\n}\n```\n\n----------------------------------------\n\nTITLE: Testing WithXxx() Methods for PTerm Printers in Go\nDESCRIPTION: Example tests for the WithXxx() methods that verify these methods correctly create new printer instances with the specified values while leaving the original printer unchanged.\nSOURCE: https://github.com/pterm/pterm/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc TestSectionPrinter_WithStyle(t *testing.T) {\n\tp := SectionPrinter{}\n\ts := NewStyle(FgRed, BgRed, Bold)\n\tp2 := p.WithStyle(s)\n\n\tassert.Equal(t, s, p2.Style)\n\tassert.Empty(t, p.Style)\n}\n\nfunc TestSectionPrinter_WithTopPadding(t *testing.T) {\n\tp := SectionPrinter{}\n\tp2 := p.WithTopPadding(1337)\n\n\tassert.Equal(t, 1337, p2.TopPadding)\n\tassert.Empty(t, p.TopPadding)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a random integer in Go within a given range\nDESCRIPTION: Defines a function that seeds the random number generator with the current time in nanoseconds and returns a random integer between the given min and max values inclusively. This ensures a different random output on each invocation, suitable for basic randomization needs in console programs. Uses the 'math/rand' and 'time' standard packages.\nSOURCE: https://github.com/pterm/pterm/blob/master/_examples/demo/demo/README.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\nfunc randomInt(min, max int) int {\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(max-min+1) + min\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Text Printer: Outputting Styled Text in Go\nDESCRIPTION: This set of functions handles rendering styled and formatted text in the terminal. It manages text content, styling parameters, and output formatting, supporting features like alignment, coloring, and content buffering. Dependencies include style configuration objects, and it outputs text with applied styles based on input parameters.\nSOURCE: https://github.com/pterm/pterm/blob/master/coverage.txt#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\ngithub.com/pterm/pterm/basic_text_printer.go:21.69,24.2  ... (truncated for brevity)\n```"
  }
]