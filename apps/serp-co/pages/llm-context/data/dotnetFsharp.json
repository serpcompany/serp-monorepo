[
  {
    "owner": "dotnet",
    "repo": "fsharp",
    "content": "TITLE: Visualizing F# Compiler Phases with Mermaid Diagram\nDESCRIPTION: A Mermaid diagram illustrating the different phases of the F# compiler, including lexing, parsing, importing, type checking, code generation, and IL emission. It shows the flow between these phases and their sub-components.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/overview.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nstateDiagram-v2\n    state \"Compilation phases\" as Flow {\n      Lexing: Lexing\n      Parsing: Parsing\n      Import: Import\n      Typechecking: Type checking\n      Codegen: Code generation\n      Emit: IL emit\n      Inputs --> Lexing: Source and signature files\n      Inputs --> Import: References\n      Lexing --> Parsing\n      Parsing --> Typechecking\n      Import --> Typechecking\n      Typechecking --> Codegen\n      Codegen --> Emit\n      state Lexing {\n          BasicLexing: Basic Lexing\n          WhitespaceSensitiveLexing: Whitespace Sensitive Lexing\n          [*] --> BasicLexing\n          BasicLexing --> WhitespaceSensitiveLexing: A token stream from input source text.\n          WhitespaceSensitiveLexing --> [*]: A token stream, augmented per the F# Language Specification.\n      }\n      state Parsing {\n          Parser: Parsing\n          [*] --> Parser\n          Parser --> [*]: AST per the grammar in the F# Language Specification.\n      }\n      state Import {\n          Resolving: Resolving references\n          ImportNET: Importing .NET references\n          ImportFS: Importing F# references\n          [*] --> Resolving\n          Resolving --> ImportNET\n          Resolving --> ImportFS\n          ImportNET --> [*]\n          ImportFS --> [*]\n      }\n      state Typechecking {\n          SequentialTypechecking: Sequentially type checking files\n          PatternMatchCompilation: Pattern match compilation\n          ConstraintSolving: Constraint solving\n          PostInferenceChecks: Post inference checks\n          [*] --> SequentialTypechecking\n          SequentialTypechecking --> PatternMatchCompilation\n          PatternMatchCompilation --> ConstraintSolving\n          ConstraintSolving --> PostInferenceChecks\n          PostInferenceChecks --> [*]\n      }\n      state Codegen {\n          QuotationTranslation: Quotation translation\n          Optimization: Optimization\n          Codegeneration: Code generation\n          AbstractILRewrite: Abstract IL rewriting\n          [*] --> QuotationTranslation\n          QuotationTranslation --> Optimization\n          Optimization --> Codegeneration\n          Codegeneration --> AbstractILRewrite\n          AbstractILRewrite --> [*]\n      }\n      state Emit {\n          Binary: Binary emit\n          Reflection: Reflection emit\n          Output: Output (assembly, references, PDBs, etc.)\n          [*] --> Binary\n          [*] --> Reflection\n          Binary --> Output\n          Reflection --> Output\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Performance Analysis of F# Compiler Phase Timings for SomethingToCompile.fs\nDESCRIPTION: Output from the F# compiler's timing feature showing the duration of each compilation phase for a sample file. This illustrates which phases consume the most time during compilation, with typecheck, imports, and optimizations being the most expensive operations.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/reusing-typechecking-results.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n--------------------------------------------------------------------------------------------------------\n|Phase name                          |Elapsed |Duration| WS(MB)|  GC0  |  GC1  |  GC2  |Handles|Threads|\n|------------------------------------|--------|--------|-------|-------|-------|-------|-------|-------|\n// main1\n|Import mscorlib+FSharp.Core         |  0,2720|  0,2604|     96|      0|      0|      0|    365|     30|     <-- long\n|Parse inputs                        |  0,3378|  0,0560|    108|      0|      0|      0|    372|     30|\n|Import non-system references        |  0,3932|  0,0476|    127|      0|      0|      0|    372|     30|\n|Typecheck                           |  0,9020|  0,5025|    164|      3|      2|      1|    456|     46|     <-- longest\n|Typechecked                         |  0,9087|  0,0002|    164|      0|      0|      0|    456|     46|\n// main2\n|Write Interface File                |  0,9191|  0,0000|    164|      0|      0|      0|    456|     46|\n|Write XML doc signatures            |  0,9280|  0,0000|    164|      0|      0|      0|    456|     46|\n|Write XML docs                      |  0,9342|  0,0002|    164|      0|      0|      0|    456|     46|\n// main3\n|Encode Interface Data               |  0,9778|  0,0345|    164|      0|      0|      0|    456|     46|\n|Optimizations                       |  1,2312|  0,2463|    178|      2|      2|      1|    456|     46|     <-- long\n|Ending Optimizations                |  1,2386|  0,0000|    178|      0|      0|      0|    456|     46|\n|Encoding OptData                    |  1,2549|  0,0093|    178|      0|      0|      0|    456|     46|\n|TailCall Checks                     |  1,2687|  0,0054|    178|      0|      0|      0|    456|     46|\n// main4, main5\n|TAST -> IL                          |  1,3657|  0,0883|    180|      0|      0|      0|    456|     46|\n// main6\n|Write .NET Binary                   |  1,6016|  0,2284|    183|      0|      0|      0|    462|     46|     <-- long\n--------------------------------------------------------------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Collection API Additions in F#\nDESCRIPTION: This image shows new APIs added to F# collections, including chunkBySize, contains, except, findBack, and others. It illustrates the expansion of functionality in Array, List, and Seq modules.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/release-notes.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n![Collection API additions](http://i.imgur.com/SdJ7Doh.png)\n```\n\n----------------------------------------\n\nTITLE: Performance Analysis of F# Compiler Phase Timings for CE100xnest5.fs\nDESCRIPTION: Compiler timing output for a complex F# file with computation expressions. This highlights how certain language features can dramatically impact compilation performance, with typechecking and optimizations taking particularly long for complex code structures.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/reusing-typechecking-results.md#2025-04-22_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n--------------------------------------------------------------------------------------------------------\n|Phase name                          |Elapsed |Duration| WS(MB)|  GC0  |  GC1  |  GC2  |Handles|Threads|\n|------------------------------------|--------|--------|-------|-------|-------|-------|-------|-------|\n// main1\n|Import mscorlib+FSharp.Core         |  0,4092|  0,4084|    101|      0|      0|      0|    365|     30|     <-- long\n|Parse inputs                        |  0,4635|  0,0445|    108|      0|      0|      0|    374|     30|\n|Import non-system references        |  0,5475|  0,0775|    128|      0|      0|      0|    374|     30|\n|Typecheck                           |  3,1157|  2,5612|    198|     18|     15|      3|    712|     45|     <-- long\n|Typechecked                         |  3,1219|  0,0002|    198|      0|      0|      0|    712|     45|\n// main2\n|Write Interface File                |  3,1280|  0,0000|    198|      0|      0|      0|    712|     45|\n|Write XML doc signatures            |  3,1363|  0,0000|    198|      0|      0|      0|    712|     45|\n|Write XML docs                      |  3,1435|  0,0002|    198|      0|      0|      0|    712|     45|\n// main3\n|Encode Interface Data               |  3,1803|  0,0296|    198|      0|      0|      0|    712|     45|\n|Optimizations                       |  8,9949|  5,8049|    216|     43|     42|      2|    457|     45|     <-- longest\n|Ending Optimizations                |  9,0015|  0,0000|    216|      0|      0|      0|    457|     45|\n|Encoding OptData                    |  9,0090|  0,0010|    216|      0|      0|      0|    457|     45|\n|TailCall Checks                     |  9,0190|  0,0013|    216|      0|      0|      0|    457|     45|\n// main4, main5\n|TAST -> IL                          |  9,0463|  0,0210|    217|      0|      0|      0|    458|     46|\n// main6\n|Write .NET Binary                   |  9,2463|  0,1930|    218|      0|      0|      0|    464|     46|     <-- long\n--------------------------------------------------------------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Building F# on Windows Command Line\nDESCRIPTION: Command to build the F# compiler and related tools on Windows. This is the primary build command for Windows developers contributing to the F# project.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbuild.cmd\n```\n\n----------------------------------------\n\nTITLE: Request Update Process Flow\nDESCRIPTION: Mermaid sequence diagram showing the detailed flow of request updates between client and server components, including cancellation and state management.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/lsp.md#2025-04-22_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n\nparticipant Client\nparticipant FsLSP\nparticipant WorkspaceStateManagement\nparticipant FCS\n\nClient->>+FsLSP: textDocument/diagnostic\nFsLSP->>+WorkspaceStateManagement: Get current workspace snapshot\nWorkspaceStateManagement-->>-FsLSP: Current workspace snapshot\nFsLSP->>FCS: ParseAndCheckFileInProject\nactivate FCS\nClient->>FsLSP: textDocument/didChange\nFsLSP->>FCS: Cancel ParseAndCheckFileInProject\ndeactivate FCS\nFsLSP->>WorkspaceStateManagement: Update workspace state\nFsLSP->>+WorkspaceStateManagement: Get current workspace snapshot\nWorkspaceStateManagement-->>-FsLSP: Current workspace snapshot\n\nFsLSP->>+FCS: ParseAndCheckFileInProject\nFCS-->>-FsLSP: FSharpCheckFileResults\nFsLSP-->>-Client: DocumentDiagnosticReport\n```\n\n----------------------------------------\n\nTITLE: Document Change Sequence Flow\nDESCRIPTION: Mermaid sequence diagram illustrating the flow of document changes between the Client, FsLSP, WorkspaceStateManagement, and FCS components.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/lsp.md#2025-04-22_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n\nparticipant Client\nparticipant FsLSP\nparticipant WorkspaceStateManagement\nparticipant FCS\n\nClient->>FsLSP: textDocument/didChange\nFsLSP->>WorkspaceStateManagement: Update workspace state\nClient->>+FsLSP: textDocument/diagnostic\nFsLSP->>+WorkspaceStateManagement: Get current workspace snapshot\nWorkspaceStateManagement-->>-FsLSP: Current workspace snapshot\nFsLSP->>+FCS: ParseAndCheckFileInProject\nFCS-->>-FsLSP: FSharpCheckFileResults\nFsLSP-->>-Client: DocumentDiagnosticReport\n```\n\n----------------------------------------\n\nTITLE: Running F# Compiler Tests in Release Mode\nDESCRIPTION: Commands for running various test suites for the F# compiler in Release mode, including compiler tests, compiler service tests, component tests, Cambridge tests, FSharpQA tests, FSharp.Core tests, scripting tests, Visual Studio integration tests, and AOT tests.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/TESTGUIDE.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbuild -testCompiler -c Release\nbuild -testCompilerService -c Release\nbuild -testCompilerComponentTests -c Release\nbuild -testCambridge -c Release -ci -nobl\nbuild -testFSharpQA -c Release -ci -nobl\nbuild -testFSharpCore -c Release\nbuild -testScripting -c Release\nbuild -testVs -c Release\nbuild -testAOT -c Release\nbuild -testAll -c Release\n```\n\n----------------------------------------\n\nTITLE: Creating FCS Benchmark with BenchmarkDotNet in F#\nDESCRIPTION: A complete example showing how to create a benchmark for the F# Compiler Services using BenchmarkDotNet. This snippet demonstrates setting up a benchmark that measures parsing performance, including global setup, benchmark execution, and cleanup steps.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/README.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nopen System.IO\nopen FSharp.Compiler.CodeAnalysis\nopen FSharp.Compiler.Diagnostics\nopen FSharp.Compiler.Text\nopen BenchmarkDotNet.Attributes\nopen BenchmarkDotNet.Running\n\n[<MemoryDiagnoser>]\ntype CompilerService() =\n    let mutable checkerOpt = None\n    let mutable sourceOpt = None\n\n    let parsingOptions =\n        {\n            SourceFiles = [|\"CheckExpressions.fs\"|]\n            ConditionalDefines = []\n            DiagnosticOptions = FSharpDiagnosticOptions.Default\n            LangVersionText = \"default\"\n            IsInteractive = false\n            LightSyntax = None\n            CompilingFsLib = false\n            IsExe = false\n        }\n\n    [<GlobalSetup>]\n    member _.Setup() =\n        match checkerOpt with\n        | None ->\n            checkerOpt <- Some(FSharpChecker.Create(projectCacheSize = 200))\n        | _ -> ()\n\n        match sourceOpt with\n        | None ->\n            sourceOpt <- Some <| SourceText.ofString(File.ReadAllText(\"\"\"C:\\Users\\vlza\\code\\fsharp\\src\\Compiler\\Checking\\Expressions\\CheckExpressions.fs\"\"\"))\n        | _ -> ()\n\n    [<Benchmark>]\n    member _.ParsingCheckExpressionsFs() =\n        match checkerOpt, sourceOpt with\n        | None, _ -> failwith \"no checker\"\n        | _, None -> failwith \"no source\"\n        | Some(checker), Some(source) ->\n            let results = checker.ParseFile(\"CheckExpressions.fs\",  source, parsingOptions) |> Async.RunSynchronously\n            if results.ParseHadErrors then failwithf \"parse had errors: %A\" results.Diagnostics\n\n    [<IterationCleanup(Target = \"ParsingCheckExpressionsFs\")>]\n    member _.ParsingCheckExpressionsFsSetup() =\n        match checkerOpt with\n        | None -> failwith \"no checker\"\n        | Some(checker) ->\n            checker.InvalidateAll()\n            checker.ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients()\n            checker.ParseFile(\"dummy.fs\", SourceText.ofString \"dummy\", parsingOptions) |> Async.RunSynchronously |> ignore\n\n[<EntryPoint>]\nlet main _ =\n    BenchmarkRunner.Run<CompilerService>() |> ignore\n    0\n```\n\n----------------------------------------\n\nTITLE: Complex Test Execution in F#\nDESCRIPTION: This snippet shows a more complex test case that involves multiple steps: compiling F# and C# code, verifying assemblies, running F# Interactive, and executing the resulting program. It demonstrates the flexibility of the test framework.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharp/readme.md#2025-04-22_snippet_1\n\nLANGUAGE: F#\nCODE:\n```\n    [<Fact>]\n    let events () = \n        let cfg = testConfig \"core/events\"\n        fsc cfg \"%s -a -o:test.dll -g\" cfg.fsc_flags [\"test.fs\"]\n        peverify cfg \"test.dll\"\n        csc cfg \"\"/r:\"%s\" /reference:test.dll /debug+\"\"\" cfg.FSCOREDLLPATH [\"testcs.cs\"]\n        peverify cfg \"testcs.exe\"\n        use testOkFile = fileguard cfg \"test.ok\"\n        fsi cfg \"\" [\"test.fs\"]\n        testOkFile.CheckExists()\n        exec cfg (\".\" ++ \"testcs.exe\") \"\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Parallel Optimization in F# Compiler\nDESCRIPTION: Instructions for enabling the experimental parallel optimization feature in the F# compiler using a command line flag. This feature is implemented in OptimizeInputs.fs.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/Driver/parallel-optimization.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n--test:ParallelOptimization\n```\n\n----------------------------------------\n\nTITLE: Building F# Compiler on Linux or macOS\nDESCRIPTION: Command to build the F# compiler on Linux or macOS using the build script. This is the basic command to compile the project on Unix-like systems.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results for FSharpChecker Performance\nDESCRIPTION: Sample benchmark results showing performance metrics for ParseAndCheckFileInProject method. Includes system specifications, execution environment details, and performance measurements including execution time, memory generation, and allocation.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/FCSSourceFiles/README.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nBenchmarkDotNet=v0.13.1, OS=Windows 10.0.22621\n11th Gen Intel Core i7-1185G7 3.00GHz, 1 CPU, 8 logical and 4 physical cores\n.NET SDK=6.0.320\n  [Host]     : .NET 6.0.25 (6.0.2523.51912), X64 RyuJIT DEBUG\n  DefaultJob : .NET 6.0.25 (6.0.2523.51912), X64 RyuJIT\n\n|                     Method |    Mean |   Error |  StdDev |        Gen 0 |       Gen 1 |     Gen 2 | Allocated |\n|--------------------------- |--------:|--------:|--------:|-------------:|------------:|----------:|----------:|\n| ParseAndCheckFileInProject | 22.14 s | 0.543 s | 1.522 s | 1645000.0000 | 307000.0000 | 6000.0000 |     10 GB |\n```\n\n----------------------------------------\n\nTITLE: Compiler Service Test in F#\nDESCRIPTION: This snippet illustrates a test using the CompilerAssert framework to verify compiler behavior. It checks if a warning is produced when a value is implicitly discarded, demonstrating how to test specific compiler diagnostics.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharp/readme.md#2025-04-22_snippet_2\n\nLANGUAGE: F#\nCODE:\n```\n    [<Fact>]\n    let ``Unused compare with immutable when assignment might be intended``() =\n        CompilerAssert.TypeCheckSingleError\n            \"\"\"\nlet x = 10\nlet y = \"hello\"\n\nlet changeX() =\n    x = 20\n    y = \"test\"\n            \"\"\"\n            FSharpDiagnosticSeverity.Warning\n            20\n            (6, 5, 6, 11)\n            \"The result of this equality expression has type 'bool' and is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to mutate a value, then mark the value 'mutable' and use the '<-' operator e.g. 'x <- expression'.\"\n```\n\n----------------------------------------\n\nTITLE: Running Desktop Tests for F# Compiler on Windows\nDESCRIPTION: Command to run desktop tests for the F# compiler on Windows in Release configuration. This helps ensure the integrity of the compiler after changes.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nbuild.cmd -test -c Release\n```\n\n----------------------------------------\n\nTITLE: Executing Single Test in F#\nDESCRIPTION: This snippet demonstrates how to define and execute a single test case in the F# test suite. It uses the xUnit framework and calls the singleTestBuildAndRun function to build and run a specific test case.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharp/readme.md#2025-04-22_snippet_0\n\nLANGUAGE: F#\nCODE:\n```\n    [<Fact>]\n    let ``array-FSI`` () = singleTestBuildAndRun \"core/array\" FSI\n```\n\n----------------------------------------\n\nTITLE: Building F# Compiler without Visual Studio on Windows\nDESCRIPTION: Command to build the F# compiler on Windows without using Visual Studio. This is useful for environments where Visual Studio is not installed or not preferred.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nbuild.cmd -noVisualStudio\n```\n\n----------------------------------------\n\nTITLE: Using Paket Package Manager in F# Interactive\nDESCRIPTION: Shows how to use Paket package manager to reference dependencies in F# Interactive, demonstrating with FSharp.Data and CSV processing\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/FSharp.DependencyManager.Nuget/README.md#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\n#r \"paket: nuget FSharp.Data\"\n\nopen FSharp.Data\n\ntype MyCsv = CsvProvider<\"\"\"\nX,Y\n2,Hello\n4,World\n\"\"\">\n\nfor r in MyCsv.GetSample().Rows do\n  printfn \"%i = %s\" r.X r.Y\n```\n\n----------------------------------------\n\nTITLE: Running F# FSharp Suite Tests\nDESCRIPTION: Command for running the FSharp Suite tests, which are compiled using the FSharp.Tests.FSharpSuite.fsproj project to a unit test DLL. This suite has broad coverage of compiler and runtime scenarios.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/TESTGUIDE.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n.\\build.cmd net40 test-net40-fsharp\n```\n\n----------------------------------------\n\nTITLE: F# List Indexing Syntax\nDESCRIPTION: Examples of correct and ambiguous list indexing syntax in F#, particularly when used as function arguments.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_11\n\nLANGUAGE: F#\nCODE:\n```\n(expr1).[expr2]           // Correct indexing\nsomeFunction (expr1) [expr2] // Correct function call\n(expr1)[expr2]             // Ambiguous\n[expr1][expr2]             // Ambiguous\nexpr1[expr2]               // Ambiguous\n```\n\n----------------------------------------\n\nTITLE: Using Nuget Package Manager in F# Interactive\nDESCRIPTION: Demonstrates how to reference and use a Nuget package (Newtonsoft.Json) in F# Interactive, including version specification and basic usage\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/FSharp.DependencyManager.Nuget/README.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\n#r \"nuget: Newtonsoft.Json\"\n// Optionally, specify a version explicitly\n// #r \"nuget: Newtonsoft.Json,11.0.1\"\n\nopen Newtonsoft.Json\n\nlet o = {| X = 2; Y = \"Hello\" |}\n\nprintfn \"%s\" (JsonConvert.SerializeObject o)\n```\n\n----------------------------------------\n\nTITLE: Running the F# Documentation Tool with Local F# Repository\nDESCRIPTION: Command to run the documentation tool using your local dotnet/fsharp fork as input, which will watch for changes and regenerate documentation.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/running-documentation-locally.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndotnet fsdocs watch --eval --sourcefolder ../fsharp/ --input ../fsharp/docs/\n```\n\n----------------------------------------\n\nTITLE: Building F# Compiler on Windows\nDESCRIPTION: Command to build the F# compiler on Windows using the build script. This is the basic command to compile the project.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nbuild.cmd\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks on Specific FCS Versions in F#\nDESCRIPTION: Defines a custom list of FCS versions to benchmark, including the local version, a specific Git commit, and multiple NuGet releases spanning different major versions. Shows how to manually create a diverse set of benchmark targets.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/BenchmarkComparison/runner.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: fsharp\nCODE:\n```\nlet versions =\n    [\n        FCSVersion.Local\n        FCSVersion.Git \"4edcbb45365f96d4858f438a556b93d4a32ae219\"\n        FCSVersion.NuGet (NuGet.findVersion \"41.0.5-preview.22329.3\")\n        FCSVersion.NuGet (NuGet.findVersion \"41.0.5\")\n        FCSVersion.NuGet (NuGet.findVersion \"40.0.0\")\n        FCSVersion.NuGet (NuGet.findVersion \"35.0.0\")\n        FCSVersion.NuGet (NuGet.findVersion \"30.0.0\")\n        FCSVersion.NuGet (NuGet.findVersion \"25.0.1\")\n        FCSVersion.NuGet (NuGet.findVersion \"20.0.1\")\n        FCSVersion.NuGet (NuGet.findVersion \"13.0.0\")\n    ]\n    \nRunner.runAll {config with ResultsSuffix = \"sample_versions\"} versions\n```\n\n----------------------------------------\n\nTITLE: Module Level Let Binding Examples in F#\nDESCRIPTION: Demonstrates basic module-level let bindings and their representation decisions made in CheckExpressions.fs and CheckDeclarations.fs\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/representations.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nmodule M = \n    let z = 1                   \n    let f = x + z               \n                                \n\ntype C(w: int, z: int) =        \n                                \n    let f x = x + z             \n    let f x = f 3 + x           \n                                \n\nlet g (z: int) =                \n    let f x = x + 1             \n```\n\n----------------------------------------\n\nTITLE: Main Compiler Pipeline Structure in F#\nDESCRIPTION: Shows the high-level structure of the F# compiler pipeline with the six main phases. This demonstrates how the compiler is organized in a sequential processing pattern where each phase feeds into the next.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/reusing-typechecking-results.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nmain1 (...args...)\n|> main2\n|> main3\n|> main4 (tcImportsCapture, dynamicAssemblyCreator)\n|> main5\n|> main6 dynamicAssemblyCreator\n```\n\n----------------------------------------\n\nTITLE: Building F# on Windows Without Visual Studio\nDESCRIPTION: Command to build the F# compiler on Windows without requiring a Visual Studio installation. This is useful for environments where Visual Studio is not available.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbuild.cmd -noVisualStudio\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Debug Points for Computed Collections in F#\nDESCRIPTION: Shows how debug points are placed in computed list expressions with control flow constructs. Debug points are added to the for-loop and yield expressions inside list comprehensions.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_3\n\nLANGUAGE: F#\nCODE:\n```\nlet x = [ for i in 1 .. 10 do yield 1 ]\n```\n\n----------------------------------------\n\nTITLE: Key Diagnostic Types and Functions in F#\nDESCRIPTION: Core types and functions used for diagnostic handling in the F# compiler, including ErrorLogger, FSharpDiagnosticSeverity, FSharpDiagnostic, and DiagnosticWithText. Functions include warning emission and error handling capabilities.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/diagnostics.md#2025-04-22_snippet_0\n\nLANGUAGE: F#\nCODE:\n```\n* `ErrorLogger`\n* `FSharpDiagnosticSeverity`\n* `FSharpDiagnostic`\n* `DiagnosticWithText`\n\n* `warning` - emit a warning\n* `errorR` - emit an error and continue\n* `error` - emit an error and throw an exception\n* `errorRecovery` - recover from an exception\n```\n\n----------------------------------------\n\nTITLE: Visualizing F# LSP Component Architecture\nDESCRIPTION: Mermaid diagram showing the relationships between different components of the F# LSP implementation, including Visual Studio, VS Code, FCS, and other related services.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/lsp.md#2025-04-22_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n\nVS(VS) -->|VS LSP client| NewVsix(\"NewVsix (Out-of-process)\")\n\nVsCode(VS Code) --> Ionide(Ionide/FSAC)\n\nVim(Vim) --> Ionide(Ionide/FSAC)\n\nFsLSPServer(FsLSP Server)\n\nNewVsix --> ProjectQuery(Project Query API)\nNewVsix --> FsLSP\n\nFsLSPServer --> FsLSP\n\n\nsubgraph FsLSP\nProjectModel(Project Model)\nWorkspaceStateManagement(Workspace State Management)\nLSPLibrary(LSP Library)\nend\n\nFsLSP --> FCS\n\nIonide --> FsLSPServer\nIonide --> ProjInfo(ProjInfo)\n\nstyle VS stroke-dasharray: 2 4\nstyle Vim stroke-dasharray: 2 4\nstyle VsCode stroke-dasharray: 2 4\nstyle Ionide stroke-dasharray: 2 4\nstyle ProjInfo stroke-dasharray: 2 4\nstyle LSPLibrary stroke-dasharray: 2 4\nstyle ProjectQuery stroke-dasharray: 2 4\n```\n\n----------------------------------------\n\nTITLE: Running All BenchmarkDotNet Benchmarks for F# Compiler Service\nDESCRIPTION: Command to execute all benchmarks in the F# Compiler Service benchmark suite using BenchmarkDotNet in Release configuration.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/CompilerServiceBenchmarks/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -c Release --filter *\n```\n\n----------------------------------------\n\nTITLE: Updating F# Test Baselines\nDESCRIPTION: Commands for updating baseline (.bsl) files used for test result validation. These baseline files contain expected test outputs that are compared with actual results. The update-baselines.fsx script can be run normally or in dry-run mode.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/TESTGUIDE.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nfsi tests\\scripts\\update-baselines.fsx\n```\n\n----------------------------------------\n\nTITLE: Extending SynRationalConst Type Definition\nDESCRIPTION: Definition of the SynRationalConst type with a new divRange field added to the Rational union case to store the range of the division symbol.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/changing-the-ast.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\ntype SynRationalConst =\n\n    // ...\n\n    | Rational of\n        numerator: int32 *\n        numeratorRange: range *\n        divRange: range *   // our new field\n        denominator: int32 *\n        denominatorRange: range *\n        range: range\n    \n    // ...\n```\n\n----------------------------------------\n\nTITLE: Running Specific BenchmarkDotNet Benchmark for F# Compiler Service\nDESCRIPTION: Command to execute a specific benchmark (ParsingCheckExpressionsFs) from the F# Compiler Service benchmark suite using BenchmarkDotNet in Release configuration.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/CompilerServiceBenchmarks/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -c Release --filter *ParsingCheckExpressionsFs*\n```\n\n----------------------------------------\n\nTITLE: Running Tests for F# Compiler on Linux or macOS\nDESCRIPTION: Command to run tests for the F# compiler on Linux or macOS. This helps ensure the integrity of the compiler after changes on Unix-like systems.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n./build.sh --test\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom F# Compiler Path in Project File\nDESCRIPTION: XML configuration to specify a custom F# compiler path in a project file. This allows using a locally built version of the compiler for specific projects.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_7\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n    <DotnetFscCompilerPath>D:\\Git\\fsharp\\artifacts\\bin\\fsc\\Debug\\net9.0\\fsc.dll</DotnetFscCompilerPath>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Running Local FCS Benchmark in F#\nDESCRIPTION: Command to run a benchmark for a local FCS in the current codebase using dotnet CLI. It executes the HistoricalBenchmark project in Release configuration with all filters.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/BenchmarkComparison/README.md#2025-04-22_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndotnet run --project HistoricalBenchmark.fsproj -c Release --filter *\n```\n\n----------------------------------------\n\nTITLE: Pinning FSharp.Core Version in Project File (XML)\nDESCRIPTION: XML snippet showing how to explicitly reference a specific version of FSharp.Core in a project file. This approach is recommended for package authors to ensure compatibility with older projects.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/fsharp-core-notes.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<ItemGroup>\n  <PackageReference Update=\"FSharp.Core\" Version=\"4.7.2\" />\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Configuring Historical Benchmark Runner with Dependencies in F#\nDESCRIPTION: Sets up required NuGet packages and configures the historical benchmark runner with specifications for time, directory paths, parallelism level, and build options.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/BenchmarkComparison/runner.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\n#r \"nuget: NuGet.Protocol, 6.2.1\"\n#r \"nuget: Plotly.NET, 3.0.0\"\n#r \"nuget: Plotly.NET.Interactive, 3.0.0\"\n#r \"nuget: LibGit2Sharp, 0.26.2\"\n#r \"nuget: BenchmarkDotnet, 0.13.1\"\n#r \"../../../../artifacts/bin/HistoricalBenchmark.Runner/Release/net9.0/HistoricalBenchmark.Runner.dll\"\n\nopen HistoricalBenchmark.Runner\n\nlet config =\n    {\n        RunConfig.Time = DateTime(2022, 7, 12, 8, 19, 0)\n        // Set to a valid local absolute path\n        BaseDir = \"d:/benchmarks\"\n        Parallelism = 3\n        ResultsSuffix = \"results\"\n        BuildLocalCodebases = false\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining F# Interactive Resource Strings for Visual Studio Integration\nDESCRIPTION: A collection of localized resource strings used by the F# Interactive (VFSI) component in Visual Studio. These strings include error messages for tool window creation failures, file not found errors, session termination notifications, and introductory messages for the interactive environment.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/vsintegration/src/FSharp.VS.FSI/VFSIstrings.txt#2025-04-22_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\ncannotCreateToolWindow,\"Cannot create window F# Interactive ToolWindow\"\nexceptionRaisedWhenCreatingRemotingClient,\"Exception raised when creating remoting client for launched fsi.exe\\n%s\"\nexceptionRaisedWhenRequestingToolWindow,\"Exception raised when requesting FSI ToolWindow.\\n%s\"\ncouldNotObtainFSharpLS,\"Could not load F# language service\"\nsessionTerminationDetected,\"Session termination detected.\"\nfsharpInteractive,\"F# Interactive\"\ncouldNotFindFsiExe,\"Could not find fsi.exe, the F# Interactive executable.\\nThis file does not exist:\\n\\n%s\\n\"\nkillingProcessRaisedException,\"Killing process raised exception:\\n%s\"\nsessionIsNotDebugFriendly,\"The current F# Interactive session is not configured for debugging. For the best experience, enable debugging in F# Interactive settings, then reset the session.\\n\\nAttempt debugging with current settings?\"\ndoNotShowWarningInFuture,\"Don't show this warning again\"\nsessionInitialMessageNetCore,\"Welcome to F# Interactive for .NET Core in Visual Studio. To execute code, either\\n  1. Use 'Send to Interactive' (Alt-Enter or right-click) from an F# script. The F# Interactive process will\\n     use any global.json settings associated with that script.\\n  2. Press 'Enter' to start. The F# Interactive process will use default settings.\"\n```\n\n----------------------------------------\n\nTITLE: Benchmark Results Output\nDESCRIPTION: Sample benchmark results comparing current and preview compiler versions across various array and range operations, showing performance metrics like execution time, memory allocation, and garbage collection statistics.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/CompiledCodeBenchmarks/README.md#2025-04-22_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n| Job     | Categories                                                                             | start | finish | step | Mean           | Error         | StdDev        | Median         | Ratio | RatioSD | Gen0   | Gen1   | Gen2   | Allocated | Alloc Ratio |\n|-------- |--------------------------------------------------------------------------------------- |------ |------- |----- |---------------:|--------------:|--------------:|---------------:|------:|--------:|-------:|-------:|-------:|----------:|------------:|\n| Current | UInt32,[|127u..1u|],ComputedCollections,Arrays,IntegralRanges                          | ?     | ?      | ?    |      24.046 ns |     0.4269 ns |     0.3993 ns |      23.985 ns |  1.00 |    0.00 | 0.0004 |      - |      - |      96 B |        1.00 |\n| Preview | UInt32,[|127u..1u|],ComputedCollections,Arrays,IntegralRanges                          | ?     | ?      | ?    |       1.729 ns |     0.0804 ns |     0.0752 ns |       1.725 ns |  0.07 |    0.00 |      - |      - |      - |         - |        0.00 |\n```\n\n----------------------------------------\n\nTITLE: Running Fantomas Code Formatter\nDESCRIPTION: Command to format all code files in the repository using Fantomas, an automated source code formatter for F#. This ensures consistent code style across the project.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_17\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet fantomas .\n```\n\n----------------------------------------\n\nTITLE: Running F# Compiler Benchmarks\nDESCRIPTION: Command to execute the MicroPerf benchmarks project for compiled code performance testing.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/CompiledCodeBenchmarks/README.md#2025-04-22_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet run --project .\\tests\\benchmarks\\CompiledCodeBenchmarks\\MicroPerf\\MicroPerf.fsproj -c Release\n```\n\n----------------------------------------\n\nTITLE: Running F# Benchmarks on Windows\nDESCRIPTION: Windows command to build F# in Release configuration and run the benchmark tests to evaluate performance.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_21\n\nLANGUAGE: cmd\nCODE:\n```\nbuild.cmd -configuration Release -testBenchmarks\n```\n\n----------------------------------------\n\nTITLE: NuGet Configuration for F# 8.0 Prerelease Packages\nDESCRIPTION: XML configuration snippet for accessing F# 8.0 prerelease packages from the Azure DevOps feed. This is used to reference nightly builds in projects.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<add key=\"fsharp-prerelease\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8/nuget/v3/index.json\" />\n```\n\n----------------------------------------\n\nTITLE: Running F# Test Baselines in Dry-Run Mode\nDESCRIPTION: Command for running the baseline update script in dry-run mode, which shows what changes would be made without actually making them. This is useful for previewing baseline changes before committing.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/TESTGUIDE.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nfsi tests\\scripts\\update-baselines.fsx -n\n```\n\n----------------------------------------\n\nTITLE: Optimizing Inner Functions in F# List Operations\nDESCRIPTION: Shows how inner functions in F# list operations are optimized by rewriting them as separate methods, avoiding FSharpFunc allocation at runtime.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations.md#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\nlet sumBy f xs =\n    let rec loop xs acc =\n        match xs with\n        | [] -> acc\n        | x :: t -> loop t (f x + acc)\n    loop xs 0\n```\n\n----------------------------------------\n\nTITLE: Building F# on Linux or macOS\nDESCRIPTION: Command to build the F# compiler and related tools on Linux or macOS systems. This shell script serves as the primary build command for Unix-based systems.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: Pinning FSharp.Core Version in Paket Configuration\nDESCRIPTION: Demonstrates how to specify a minimum version of FSharp.Core when using Paket as the package manager. This ensures compatibility with older codebases while allowing newer versions.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/fsharp-core-notes.md#2025-04-22_snippet_1\n\nLANGUAGE: paket\nCODE:\n```\nnuget FSharp.Core >= 4.7.2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating File Order in F# Project\nDESCRIPTION: Shows a sample file order in an F# project to illustrate the default sequential type-checking process.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/Driver/GraphChecking/Docs.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nA.fs\nB.fs\nC.fs\nD.fs\n```\n\n----------------------------------------\n\nTITLE: Disabling Implicit FSharp.Core Reference in Project File\nDESCRIPTION: XML configuration to disable the implicit reference to FSharp.Core in a project file. This is necessary when using a custom version of FSharp.Core.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_8\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n    <DisableImplicitFSharpCoreReference>true</DisableImplicitFSharpCoreReference>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Optimizing Tuple Arguments in F#\nDESCRIPTION: Example of how the F# compiler optimizes functions that accept tuples as arguments. The 'max3' function is rewritten to accept individual arguments instead of a tuple, eliminating tuple allocation at the call site.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nlet max3 t =\n    let (x, y, z) = t\n    max x (max y z)\n\nmax3 (1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Updating Fork with Latest F# Repository Changes\nDESCRIPTION: Series of Git commands to update your fork with the latest changes from the upstream F# repository. This includes cleaning the working directory, fetching upstream changes, rebasing, and pushing to your fork.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout main && git clean -xdf && git fetch upstream && git rebase upstream/main && git push\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable for Updating Test Baselines on Windows\nDESCRIPTION: Commands to set an environment variable for updating test baselines on Windows. This is useful when making changes that affect many baseline files.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nset TEST_UPDATE_BSL=1\n```\n\nLANGUAGE: shell\nCODE:\n```\n$env:TEST_UPDATE_BSL=1\n```\n\n----------------------------------------\n\nTITLE: Updating FCS Surface Area Baselines for F# Compiler\nDESCRIPTION: Series of commands to update FCS (F# Compiler Service) surface area baselines. This is necessary when making changes that affect the public API of the compiler service.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n$env:TEST_UPDATE_BSL=1\ndotnet test tests/FSharp.Compiler.Service.Tests/FSharp.Compiler.Service.Tests.fsproj --filter \"SurfaceAreaTest\" /p:BUILDING_USING_DOTNET=true\ndotnet test tests/FSharp.Compiler.Service.Tests/FSharp.Compiler.Service.Tests.fsproj --filter \"SurfaceAreaTest\" /p:BUILDING_USING_DOTNET=true\ndotnet test tests/FSharp.Compiler.Service.Tests/FSharp.Compiler.Service.Tests.fsproj --filter \"SurfaceAreaTest\" -c Release /p:BUILDING_USING_DOTNET=true\ndotnet test tests/FSharp.Compiler.Service.Tests/FSharp.Compiler.Service.Tests.fsproj --filter \"SurfaceAreaTest\" -c Release /p:BUILDING_USING_DOTNET=true\n```\n\n----------------------------------------\n\nTITLE: Invoking F# Compiler with Response File\nDESCRIPTION: Demonstrates how to invoke the F# compiler using a response file for memory profiling. This approach allows for analyzing the compiler's memory usage during compilation.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/memory-usage.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n@name-of-response-file\n```\n\n----------------------------------------\n\nTITLE: Debug Point Code Generation in IlxGen\nDESCRIPTION: Example of how debug points are emitted in the IlxGen module of the F# compiler, showing conditional emission based on the presence of debug point markers.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_6\n\nLANGUAGE: fsharp\nCODE:\n```\n    match spTry with\n    | DebugPointAtTry.Yes m -> CG.EmitDebugPoint cgbuf m ... \n    | DebugPointAtTry.No -> ...\n```\n\n----------------------------------------\n\nTITLE: Running ILVerify Baseline Script in PowerShell\nDESCRIPTION: Instructions for executing the ilverify.ps1 PowerShell script to update ILVerify baseline files. The script generates .actual files that can be used to replace the original baselines if changes are appropriate.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_16\n\nLANGUAGE: powershell\nCODE:\n```\nilverify.ps1\n```\n\n----------------------------------------\n\nTITLE: Checking Fantomas Formatting in CI\nDESCRIPTION: Command used in Continuous Integration to check if all files are properly formatted according to the Fantomas rules. It verifies formatting without making changes.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_18\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet fantomas . --check\n```\n\n----------------------------------------\n\nTITLE: Defining Closure in F# with Captured Variables\nDESCRIPTION: Demonstrates how local variables are captured in a closure. The variables 'x' and 'y' become closure fields in the generated closure class.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_7\n\nLANGUAGE: fsharp\nCODE:\n```\nlet F() =\n    let x = 1\n    let y = 2\n    (fun () -> x + y)\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable to Retain Test Build Artifacts on Windows\nDESCRIPTION: Commands to set an environment variable to retain test build artifacts on Windows. This is helpful when investigating test issues.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nset FSHARP_RETAIN_TESTBUILDS=1\n```\n\nLANGUAGE: shell\nCODE:\n```\n$env:FSHARP_RETAIN_TESTBUILDS=1\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Functions Across FSI Fragments\nDESCRIPTION: Example showing how internal functions defined in one FSI fragment were previously accessible in subsequent fragments, and how this can fail when using multi-assembly emit without proper InternalsVisibleTo configuration.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/fsi-emit.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\n// Fragment 1\n> let internal f() = 1;;\nval internal f: unit -> int\n\n// Fragment 2 - according to existing rules it is allowed to access internal things of the first\nf();; \nSystem.MethodAccessException: Attempt by method '<StartupCode$FSI_0003>.$FSI_0003.main@()' to access method 'FSI_0002.f()' failed.\n   at <StartupCode$FSI_0003>.$FSI_0003.main@()\n```\n\n----------------------------------------\n\nTITLE: Parser Rule Definition in pars.fsy\nDESCRIPTION: Original parser rule for rational constants in the F# parser specification file, showing how rational numbers are parsed and validated.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/changing-the-ast.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nrationalConstant:\n  | INT32 INFIX_STAR_DIV_MOD_OP INT32\n    { if $2 <> \"/\" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure())\n      if fst $3 = 0 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsIllegalDenominatorForMeasureExponent())\n      if (snd $1) || (snd $3) then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState))\n      SynRationalConst.Rational(fst $1, rhs parseState 1, fst $3, rhs parseState 3, lhs parseState) }\n  | // ...\n```\n\n----------------------------------------\n\nTITLE: Known Failures in F# Compiler/Runtime Unit Tests\nDESCRIPTION: Lists known failures in the F# compiler and runtime unit tests, specifying test names and conditions for failure. Includes issues related to specific .NET Framework versions and culture settings.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/KnownFail.txt#2025-04-22_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n!NETFX35\t\t\t\t\tFSharp.Core.UnitTests.Collections.SeqModule2.SystemLinqSelectWithException -- failed\n!NETFX35\t\t\t\t\tFSharp.Core.UnitTests.Collections.SeqModule2.SystemLinqSelectWithSideEffects -- failed\n!CURRENTUICULTURE1033\t\tFSharp.Core.UnitTests.Control.AsyncModule.ContinuationsThreadingDetails.AsyncSansSyncContext -- failed\n!CURRENTUICULTURE1033\t\tFSharp.Core.UnitTests.Control.AsyncModule.ContinuationsThreadingDetails.AsyncWithSyncContext -- failed\n```\n\n----------------------------------------\n\nTITLE: Launching Visual Studio with F# Development Changes\nDESCRIPTION: Command to launch Visual Studio with the RoslynDev suffix, which allows testing F# tooling changes in a separate Visual Studio instance.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\ndevenv.exe /rootsuffix RoslynDev\n```\n\n----------------------------------------\n\nTITLE: Example of Signature Impact on Compiled Names in F#\nDESCRIPTION: Demonstrates how signature files (.fsi) affect the compiled names of parameters in F# implementation files (.fs), showing that signature parameter names are preferred in compiled output.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/names.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nFoo.fsi \n\n  val SomeFunction: x: int -> y: int -> int \n\nFoo.fs\n\n  let SomeFunction a b = a + b // compiled name of parameters is x, y - warning emitted\n```\n\n----------------------------------------\n\nTITLE: Running F# Benchmarks on Linux/Mac\nDESCRIPTION: Shell command for Linux/Mac to build F# in Release configuration and run the benchmark tests to evaluate performance.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\n./build.sh --configuration Release --testBenchmarks\n```\n\n----------------------------------------\n\nTITLE: Updating XLF Files for F# Compiler\nDESCRIPTION: Command to update XLF localization files for the F# compiler. This is necessary when modifying language keywords or other localized strings.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ndotnet build src\\Compiler /t:UpdateXlf\n```\n\n----------------------------------------\n\nTITLE: Complex Tuple Optimization with Inline Functions in F#\nDESCRIPTION: Demonstrates a more complex case of tuple optimization where the 'inline' keyword is necessary to eliminate tuple allocation in nested function calls.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nlet rec runWithTuple t offset times =\n    let offsetValues x y z offset =\n        (x + offset, y + offset, z + offset)\n    if times <= 0 then\n        t\n    else\n        let (x, y, z) = t\n        let r = offsetValues x y z offset\n        runWithTuple r offset (times - 1)\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks Between Two Git Commits in F#\nDESCRIPTION: Identifies all commits between two specific Git revisions, excluding known problematic commits, and runs benchmarks for each version in the range. Uses the Git functionality from the benchmark runner.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/BenchmarkComparison/runner.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\n// let newerVersion = findVersion \"40.0.1-preview.21352.5\"\n// let olderVersion = findVersion \"40.0.0\"\n// let newerRevision = NuGet.resolvePackageRevision newerVersion\n// let olderVersion = NuGet.resolvePackageRevision olderVersion\n\n// Find all commits between the two\nlet newerRevision = \"cb3692bf5d5af46b075c50d4f802f09152fb6b67\"\nlet olderRevision = \"4d330f37ae740adccd2586d568b6d45d2c408fad\"\nlet cNewer, cOlder = Git.findCommit config newerRevision, Git.findCommit config olderRevision\nlet versions =\n    Git.findCommitsBetweenInclusive config cOlder cNewer |> Seq.toList\n    |> Git.excludeBadCommits [\"679e11c533ad6c408723cf9b227a57be23fb51db\"]\n    |> List.map (fun c -> FCSVersion.Git c.Sha)\n// Fetch, build and run benchmarks for all of them\nRunner.runAll {config with ResultsSuffix = \"between_2_nuget_versions\"} versions\n```\n\n----------------------------------------\n\nTITLE: Installing Custom F# VSIX into Visual Studio\nDESCRIPTION: PowerShell commands to uninstall the existing F# Visual Studio extension and install a custom-built version from the artifacts directory to test changes.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nVSIXInstaller.exe /u:\"VisualFSharp\"\nVSIXInstaller.exe artifacts\\VSSetup\\Release\\VisualFSharpDebug.vsix\n```\n\n----------------------------------------\n\nTITLE: Stack Guards Implementation in F# Compiler\nDESCRIPTION: Example showing how Stack Guards are implemented in the F# compiler to prevent stack overflows. The StackGuard type counts synchronous recursive processing and moves to a new thread if a limit is reached, allowing for processing deeply nested expressions safely.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/large-inputs-and-stack-overflows.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nlet TcStackGuardDepth = StackGuard.GetDepthOption \"Tc\"\n\n...\n   stackGuard = StackGuard(TcMaxStackGuardDepth)\n\nlet rec ....\n\nand TcExpr cenv ty (env: TcEnv) tpenv (expr: SynExpr) =\n\n    // Guard the stack for deeply nested expressions\n    cenv.stackGuard.Guard <| fun () ->\n\n    ...\n```\n\n----------------------------------------\n\nTITLE: Illustrating Module Abbreviations in F#\nDESCRIPTION: This code demonstrates how module abbreviations work in F#, showing that they don't require special handling in the dependency tracking algorithm as they create indirect dependencies.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/Driver/GraphChecking/Docs.md#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\n// F1.fs\nmodule A\nmodule B = let x = 1\n\n// F2.fs\nmodule C\nopen A\nmodule D = B\n```\n\n----------------------------------------\n\nTITLE: System Missing Method Exception Message\nDESCRIPTION: Error message indicating that a method could not be found during execution. This is a common runtime exception in .NET when attempting to call a method that doesn't exist or isn't accessible.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/Conformance/TypeForwarding/Class/G_Constraint002_64_ExpErr.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSystem.MissingMethodException: Method not found\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote for F# Repository in Git\nDESCRIPTION: Command to add the upstream remote for the F# repository to your local Git configuration. This allows for easier management of multiple forks and your own work.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit remote add upstream https://github.com/dotnet/fsharp.git\n```\n\n----------------------------------------\n\nTITLE: Referencing Custom FSharp.Core in Project File\nDESCRIPTION: XML configuration to reference a custom FSharp.Core assembly in a project file. This is used in conjunction with disabling the implicit reference to use a locally built version.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_9\n\nLANGUAGE: xml\nCODE:\n```\n<ItemGroup>\n    <Reference Include=\"FSharp.Core\">\n      <HintPath>D:\\Git\\fsharp\\artifacts\\bin\\FSharp.Core\\Debug\\netstandard2.1\\FSharp.Core.dll</HintPath>\n    </Reference>\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: System Type Load Exception Reference\nDESCRIPTION: Basic reference to System.TypeLoadException, which occurs when the common language runtime cannot find the assembly that contains the type definition.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/Conformance/TypeForwarding/Class/G_Basic002_64_ExpErr.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nSystem.TypeLoadException\n```\n\n----------------------------------------\n\nTITLE: Cleaning Git Repository for F# Testing\nDESCRIPTION: This command cleans the git repository, removing temporary files and .NET versions that may cause build errors when switching branches. It preserves Visual Studio settings.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/TESTGUIDE.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit clean -xdf -e .vs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Debug Points for Let Bindings in F#\nDESCRIPTION: Shows how debug points are added to various forms of let bindings in F#. Simple let bindings with leaf expressions get debug points over the entire binding, while function bindings and complex expressions have different debug point behavior.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_0\n\nLANGUAGE: F#\nCODE:\n```\nlet f () =\n    let x = 1 // debug point for whole of `let x = 1`\n    let f x = 1 // no debug point on `let f x =`, debug point on `1`\n    let x = if today then 1 else tomorrow // no debug point on `let x =`, debug point on `if today then` and `1` and `tomorrow`\n    let x = let y = 1 in y + y // no debug point on `let x =`, debug point on `let y = 1` and `y + y`\n    ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Debug Points for Nested Control-Flow with Conditionals in F#\nDESCRIPTION: Shows how debug points are emitted when a control-flow expression (like an if-statement) is nested inside a function application. Debug points are generated for the conditional parts as well as the whole expression.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_2\n\nLANGUAGE: F#\nCODE:\n```\nlet h3 x = f (if today then 1 else 2)\n```\n\n----------------------------------------\n\nTITLE: Disabling Implicit FSharp.Core Reference in Project File\nDESCRIPTION: XML snippet showing how to configure an F# project to disable implicit FSharp.Core references, which is necessary when testing changes to FSharp.Core itself to ensure the project uses the custom version rather than the default one.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/README.md#2025-04-22_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n    <DisableImplicitFSharpCoreReference>true</DisableImplicitFSharpCoreReference>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Linearizing Processing of Linear Expressions in F# Compiler\nDESCRIPTION: Example of how the F# compiler uses continuation passing style to process linear expressions (expressions with a single linear hole) without causing stack overflows. This pattern helps in processing constructs like list expressions, sequential expressions, let bindings, and conditionals efficiently.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/large-inputs-and-stack-overflows.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nand remapLinearExpr g compgen tmenv expr contf =\n    match expr with\n    | Expr.Let (bind, bodyExpr, m, _) ->\n        ...\n        // tailcall for the linear position\n        remapLinearExpr g compgen tmenvinner bodyExpr (contf << (fun bodyExpr' ->\n            ...))\n\n    | Expr.Sequential (expr1, expr2, dir, spSeq, m)  ->\n        ...\n        // tailcall for the linear position\n        remapLinearExpr g compgen tmenv expr2 (contf << (fun expr2' ->\n            ...))\n\n    | LinearMatchExpr (spBind, exprm, dtree, tg1, expr2, sp2, m2, ty) ->\n        ...\n        // tailcall for the linear position\n        remapLinearExpr g compgen tmenv expr2 (contf << (fun expr2' ->  ...))\n\n    | LinearOpExpr (op, tyargs, argsFront, argLast, m) ->\n        ...\n        // tailcall for the linear position\n        remapLinearExpr g compgen tmenv argLast (contf << (fun argLast' -> ...))\n\n    | _ -> contf (remapExpr g compgen tmenv e)\n\nand remapExpr (g: TcGlobals) (compgen:ValCopyFlag) (tmenv:Remap) expr =\n    match expr with\n    ...\n    | LinearOpExpr _\n    | LinearMatchExpr _\n    | Expr.Sequential _\n    | Expr.Let _ -> remapLinearExpr g compgen tmenv expr (fun x -> x)\n```\n\n----------------------------------------\n\nTITLE: Performance Analysis of F# Compiler Phase Timings for decentlySizedStandAloneFile.fs\nDESCRIPTION: Compiler timing output for a moderately sized standalone F# file. This demonstrates the performance characteristics of different compilation phases for a typical source file, highlighting import, typecheck, and binary writing as significant operations.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/reusing-typechecking-results.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n--------------------------------------------------------------------------------------------------------\n|Phase name                          |Elapsed |Duration| WS(MB)|  GC0  |  GC1  |  GC2  |Handles|Threads|\n|------------------------------------|--------|--------|-------|-------|-------|-------|-------|-------|\n// main1\n|Import mscorlib+FSharp.Core         |  0,3285|  0,3120|    101|      0|      0|      0|    365|     30|     <-- longest\n|Parse inputs                        |  0,3673|  0,0292|    108|      0|      0|      0|    374|     30|\n|Import non-system references        |  0,4354|  0,0622|    128|      0|      0|      0|    374|     30|\n|Typecheck                           |  0,6464|  0,2045|    144|      1|      1|      1|    378|     30|     <-- long\n|Typechecked                         |  0,6522|  0,0004|    144|      0|      0|      0|    378|     30|\n// main2\n|Write Interface File                |  0,6597|  0,0000|    144|      0|      0|      0|    378|     30|\n|Write XML doc signatures            |  0,6661|  0,0000|    144|      0|      0|      0|    378|     30|\n|Write XML docs                      |  0,6710|  0,0002|    144|      0|      0|      0|    378|     30|\n// main3\n|Encode Interface Data               |  0,7273|  0,0503|    154|      0|      0|      0|    378|     30|\n|Optimizations                       |  0,8757|  0,1425|    172|      1|      1|      0|    378|     30|     <-- long\n|Ending Optimizations                |  0,8815|  0,0000|    172|      0|      0|      0|    378|     30|\n|Encoding OptData                    |  0,8899|  0,0024|    173|      0|      0|      0|    378|     30|\n|TailCall Checks                     |  0,8990|  0,0025|    173|      0|      0|      0|    378|     30|\n// main4, main5\n|TAST -> IL                          |  0,9487|  0,0447|    176|      0|      0|      0|    378|     30|\n// main6\n|Write .NET Binary                   |  1,1530|  0,1972|    180|      0|      0|      0|    384|     30|     <-- long\n--------------------------------------------------------------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: PowerShell Command for Smoke Testing Benchmarks\nDESCRIPTION: Reference to a PowerShell script used for running quick validation of benchmarks with minimal iterations, useful for verifying that benchmarks still work without spending time on full benchmark runs.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/README.md#2025-04-22_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\nSmokeTestBenchmarks.ps1\n```\n\n----------------------------------------\n\nTITLE: Benchmarking F# Compiler Performance with Various Signature Generation Scenarios\nDESCRIPTION: Benchmark results comparing different F# compiler scenarios: normal compilation, compilation with signature generation, compilation with pre-generated signatures, and partial signature usage. The results show marginal differences between scenarios.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/reusing-typechecking-results.md#2025-04-22_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nNormal compilation:\n1. Typecheck: 23.7531\n2. Typecheck: 27.4234\n3. Typecheck: 24.5202\n\nNormal compilation + generating signatures (added extra `ReportTime` for measuring the latter):\n1. Typecheck: 26.5991, Siggen: 1.9369\n2. Typecheck: 25.0246, Siggen: 1.7517\n3. Typecheck: 27.0057, Siggen: 1.9093\n\nCompilation with given signatures:\n1. Typecheck: 25.7741\n2. Typecheck: 26.2904\n3. Typecheck: 24.3852\n\nCompilation with given 80% signatures + generating 20% signatures:\n1. Typecheck: 24.1338, Siggen: 0.5284\n2. Typecheck: 27.6037, Siggen: 0.7526\n3. Typecheck: 25.6967, Siggen: 0.6244\n```\n\n----------------------------------------\n\nTITLE: Renaming FSharp Compiler Service Types and Modules\nDESCRIPTION: This diff shows the renaming of various types and modules in the FSharp Compiler Service, including changes to namespaces and type names to improve organization and clarity.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/release-notes.md#2025-04-22_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n-type FSharp.Compiler.AbstractIL.Internal.Library.IFileSystem\n+type FSharp.Compiler.SourceCodeServices.IFileSystem\n\n-module FSharp.Compiler.AbstractIL.Internal.Library.Shim\n+FSharp.Compiler.SourceCodeServices.FileSystemAutoOpens\n\n-type FSharp.Compiler.AbstractIL.Layout\n+type FSharp.Compiler.TextLayout.Layout\n\n-type FSharp.Compiler.AbstractIL.Internal.TaggedText\n+type FSharp.Compiler.TextLayout.TaggedText\n\n-type FSharp.Compiler.Layout.layout\n+type FSharp.Compiler.TextLayout.layout\n\n-type FSharp.Compiler.Layout.Layout\n+FSharp.Compiler.TextLayout.Layout\n\n-module FSharp.Compiler.Layout\n+module FSharp.Compiler.TextLayout.LayoutRender\n\n-module FSharp.Compiler.LayoutOps\n+module FSharp.Compiler.TextLayout.Layout\n\n-module FSharp.Compiler.Layout.TaggedText\n+module FSharp.Compiler.TextLayout.TaggedText\n\n-module FSharp.Compiler.Layout.TaggedTextOps\n+FSharp.Compiler.TextLayout.TaggedText\n\n-module FSharp.Compiler.Layout.TaggedTextOps.Literals\n+FSharp.Compiler.TextLayout.TaggedText\n\n-type FSharp.Compiler.Range.range\n+FSharp.Compiler.Text.Range\n\n-type FSharp.Compiler.Range.pos\n+FSharp.Compiler.Text.Pos\n\n-module FSharp.Compiler.Range.Range\n+module FSharp.Compiler.Text.Pos\n+module FSharp.Compiler.Text.Range\n\n-module FSharp.Compiler.QuickParse\n+module FSharp.Compiler.SourceCodeServices.QuickParse\n\n-module FSharp.Compiler.PrettyNaming\n+FSharp.Compiler.SourceCodeServices.PrettyNaming\n\n-val FSharpKeywords.PrettyNaming.KeywordNames\n+FSharp.Compiler.SourceCodeServices.FSharpKeywords.KeywordNames\n\n-val FSharpKeywords.PrettyNaming.QuoteIdentifierIfNeeded\n+FSharp.Compiler.SourceCodeServices.FSharpKeywords.QuoteIdentifierIfNeeded\n\n-val FSharpKeywords.PrettyNaming.FormatAndOtherOverloadsString\n+FSharp.Compiler.SourceCodeServices.FSharpKeywords.FormatAndOtherOverloadsString\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Debug Points for Nested Control-Flow in F#\nDESCRIPTION: Illustrates how debug points are emitted for nested expressions. Simple function applications get a single debug point, while pipeline operators get multiple points. Nested control-flow constructs generate their own debug points.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_1\n\nLANGUAGE: F#\nCODE:\n```\nlet h1 x = g (f x)\nlet h2 x = x |> f |> g\n```\n\n----------------------------------------\n\nTITLE: NuGet Configuration for F# 7.0 Prerelease Packages\nDESCRIPTION: XML configuration snippet for accessing F# 7.0 prerelease packages from the Azure DevOps feed. This is used to reference nightly builds in projects.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<add key=\"fsharp-prerelease\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json\" />\n```\n\n----------------------------------------\n\nTITLE: Renaming FSharp.Compiler.SourceCodeServices Types\nDESCRIPTION: This diff shows the renaming of various types within the FSharp.Compiler.SourceCodeServices namespace, including changes to token names, error types, and symbol representations.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/release-notes.md#2025-04-22_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-Lexer.*\n+FSharp.Compiler.SourceCodeServices.*\n\n-FSharpSyntaxToken*\n+FSharpToken*\n\n-FSharpErrorInfo\n+FSharpDiagnostic\n\n-FSharpErrorSeverity\n+FSharpDiagnosticSeverity\n\n-ExternalSymbol\n+FSharpExternalSymbol\n\n-UnresolvedSymbol\n+FSharpUnresolvedSymbol\n\n-CompletionKind\n+FSharpCompletionKind\n\n-module Keywords \n+module FSharpKeywords\n```\n\n----------------------------------------\n\nTITLE: Class Level Let Binding Representations in F#\nDESCRIPTION: Details how class-level let bindings are represented, including constructor parameters, instance fields, and methods. Decisions are made in CheckIncrementalClasses.fs\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/representations.md#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\ntype C(w: int, z: int) =   // w --> local to object constructor, required by spec\n                           // z --> private instance field, required by spec\n    let f x = x + z        // f --> private instance method, required by spec, compiled name not mandated\n                           // Note: initially uses an ephemeral 'f' Val then creates a member Val with compiled name\n                           \n    let f x = f 3 + x      // f --> private instance method, required by spec, compiled name not mandated\n                           // Note: initially uses an ephemeral 'f' Val then creates a member Val with compiled name\n                           \n    static let g x = x + 1 // g --> private static method, required by spec, compiled name not mandated, initially uses an ephemeral 'g' Val then creates a member Val with compiled name\n    \n    static let g x = g 3   // g --> private static method, required by spec, compiled name not mandated, initially uses an ephemeral 'g' Val then creates a member Val with compiled name\n```\n\n----------------------------------------\n\nTITLE: Internal Fields Access in FSI Fragments\nDESCRIPTION: Example demonstrating how optimization settings affect access to internal fields across FSI fragments, specifically when inlining attempts to access an internal field from a different assembly fragment.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/fsi-emit.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\n// Fragment 1 - not `x` becomes an internal field of the class\n> type C() =\n>    let mutable x = 1\n>    member _.M() = x\n> ;;\n...\n// Fragment 2 - inlining 'M()' gave an access to the internal field `x`\n> C().M();;\n...<bang>...\n```\n\n----------------------------------------\n\nTITLE: Handling Unused Open Statements in F#\nDESCRIPTION: This snippet demonstrates how unused open statements are handled in F#, which is necessary to satisfy the type-checker and maintain correct dependencies.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/Driver/GraphChecking/Docs.md#2025-04-22_snippet_4\n\nLANGUAGE: fsharp\nCODE:\n```\n// X.fs\nnamespace X\n\n// Y.fs\nnamespace Y\n\nopen X // This open statement is unnecessary, however it is valid F# code.\n```\n\n----------------------------------------\n\nTITLE: Expression Level Let Binding Representations in F#\nDESCRIPTION: Shows how expression-level let bindings are represented, with decisions made during optimization phases\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/representations.md#2025-04-22_snippet_3\n\nLANGUAGE: fsharp\nCODE:\n```\nlet g (z: int) =          // z --> local + field in closure for 'f', not mandated\n    let f x = x + 1       // f --> FSharpFunc value, or maybe a static method, not mandated \n                          //    Decided in various optimization phases\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Latest NuGet Versions of FCS in F#\nDESCRIPTION: Retrieves the 10 latest versions of the F# Compiler Services from NuGet (including prereleases), and runs benchmarks for each version. Uses the NuGet functionality to identify and resolve package versions.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/BenchmarkComparison/runner.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\n// Find two latest NuGet versions of FCS (including prereleases), run benchmarks and export results\nNuGet.allVersionsMetadata.Value()\n|> List.take 10\n|> List.map (fun metadata -> FCSVersion.NuGet metadata.Identity.Version)\n|> Runner.runAll {config with ResultsSuffix = \"10_latest_nuget_versions\"}\n```\n\n----------------------------------------\n\nTITLE: Shared Namespace Setup in F#\nDESCRIPTION: This example shows how shared namespaces are set up across multiple files in F#, which is important for optimizing the dependency graph.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/Driver/GraphChecking/Docs.md#2025-04-22_snippet_3\n\nLANGUAGE: fsharp\nCODE:\n```\n// A.fs\nmodule Foo.Bar.A\n\nlet a = 0\n\n// B.fs\nmodule Foo.Bar.B\n\nlet b = 1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Debug Points for Computation Expressions in F#\nDESCRIPTION: Illustrates debug point placement in computation expressions such as 'task'. Debug points are generated for control flow constructs inside the computation expression body.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_4\n\nLANGUAGE: F#\nCODE:\n```\nlet f() = task { for i in 1 .. 10 do printfn \"hello\" }\n```\n\n----------------------------------------\n\nTITLE: Referencing FSharp Namespaces After API Reorganization\nDESCRIPTION: Example of the primary namespaces in the reorganized F# Compiler Service API, showing the new namespace structure after significant API trimmings and renamings.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/release-notes.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nFSharp.Compiler.IO                // FileSystem\nFSharp.Compiler.CodeAnalysis      // FSharpChecker, FSharpCheckFileResults, FSharpCheckProjectResults and friends\nFSharp.Compiler.Diagnostics       // FSharpDiagnostic and friends\nFSharp.Compiler.EditorServices    // Misc functionality for editors, e.g. interface stub generation\nFSharp.Compiler.Interactive.Shell // F# Interactive\nFSharp.Compiler.Symbols           // FSharpEntity etc\nFSharp.Compiler.Syntax            // SyntaxTree, XmlDoc, PrettyNaming\nFSharp.Compiler.Text              // ISourceFile, Range, TaggedText and other things\nFSharp.Compiler.Tokenization      // FSharpLineTokenizer etc.\n```\n\n----------------------------------------\n\nTITLE: Known Failures in F# IDE Unit Tests\nDESCRIPTION: Lists known failures in the F# IDE unit tests, specifying test names and reasons for failure. Includes issues related to dependencies and specific test behaviors.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/KnownFail.txt#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nUnitTests.Tests.LanguageService.General.MSBuild.PublicSurfaceArea.DotNetReflection -- gazillion dependencies on suitebin DLLs\nUnitTests.Tests.LanguageService.General.ProjectSystem.PublicSurfaceArea.DotNetReflection -- gazillion dependencies on suitebin DLLs\nUnitTests.Tests.ProjectSystem.Miscellaneous.ErrorReporting.EmptyModuleReportedAtTheLastLine -- very noisy test\nUnitTests.Tests.ProjectSystem.Miscellaneous.PreBuildEvent -- failed\n```\n\n----------------------------------------\n\nTITLE: Supported Tags for F# Test Configuration\nDESCRIPTION: Lists the currently supported tags for configuring test exclusions, including .NET Framework versions, F# Runtime versions, OS architecture, build types, and specific multi-targeting scenarios.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/KnownFail.txt#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n# Tags currently supported (see fsharpqa\\testenv\\bin\\KnownFailRewriter.fsx for complete logic/tags):\n# NETFX20\t- NetFx2.0 installed\n# NETFX30\t- NetFx3.0 installed\n# NETFX35\t- NetFx3.5 installed\n#\t- NetFx4.0 installed\n# FSHARPRUNTIME20 - F# Runtime 2.0 installed (Dev10)\n# OS32BIT\t- OS is 32bit\n# OS64BIT\t- OS is 64bit\n# CHK           - F# build CHK\n# RET           - F# build RET\n# POWERPACK\t- F# Powerpack is installed\n# MT402040\t- This is a MT run of type 4.0 -> 2.0 -> 4.0\n# MT402020\t- This is a MT run of type 4.0 -> 2.0 -> 2.0\n```\n\n----------------------------------------\n\nTITLE: Structural Equality Example - HashIdentity\nDESCRIPTION: Example showing how HashIdentity.Structural is typed when EQTYPE is known to be byte\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations-equality.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nlet x = HashIdentity.Structural<byte>\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Exclusions with Tags in F# Test Suite\nDESCRIPTION: Demonstrates how to use tags to exclude tests on specific configurations. Tags can be combined, negated with '!', and specify conditions like OS architecture or .NET Framework version.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/KnownFail.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n#MT402040,OS64BIT\ttest\\hoge\\piyo (...) -- failed\n#OS32BIT\t\ttest\\hoge\\piyo (...) -- failed\n\n#!NETFX35\ttest\\hoge\\piyo (...) -- failed\n```\n\n----------------------------------------\n\nTITLE: Restoring the FSharp.Compiler.Service Project\nDESCRIPTION: Commands to navigate to the FSharp.Compiler.Service directory and restore the project dependencies.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/running-documentation-locally.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncd fsharp-compiler-docs/FSharp.Compiler.Service\ndotnet restore\n```\n\n----------------------------------------\n\nTITLE: Module Level Let Binding Representations in F#\nDESCRIPTION: Shows how module-level let bindings are represented in compiled code, with static properties and methods as required by spec\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/representations.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nmodule M = \n    let z = 1              // z --> static property + field, required by spec, compiled name mandated\n    let f x = x + z          // f --> static method, required by spec, compiled name mandated\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable for Updating Baselines in F# QA Tests\nDESCRIPTION: This snippet demonstrates how to set an environment variable to enable updating baselines en-masse for F# QA tests. This is useful when a change affects many baselines, but should be used cautiously and subject to careful code review.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/readme.md#2025-04-22_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\nset TEST_UPDATE_BSL=1\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Error Messages\nDESCRIPTION: Definition file containing error codes and messages used by the F# compiler for reporting various types of errors including lexical analysis, parsing, type checking and general compilation errors.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nlexCharNotAllowedInOperatorNames,\"'%s' is not permitted as a character in operator names and is reserved for future use\"\nlexUnexpectedChar,\"Unexpected character '%s'\"\n1140,lexByteArrayCannotEncode,\"This byte array literal contains %d characters that do not encode as a single byte\"\n1141,lexIdentEndInMarkReserved,\"Identifiers followed by '%s' are reserved for future use\"\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Changelog Entry Format in Markdown\nDESCRIPTION: Shows the standard format for a changelog entry, which includes an informative description and a link to the associated pull request. This format ensures consistency across all release notes.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/release-notes/About.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* <Informative description>. ([PR #16106](https://github.com/dotnet/fsharp/pull/16106))\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Outputs in 1ES Pipeline Template\nDESCRIPTION: Example of using the 1ES pipeline template with multiple outputs to reduce security scan overhead. It demonstrates how to gather and publish artifacts from the Build.ArtifactStagingDirectory.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/eng/common/template-guidance.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# azure-pipelines.yml\nextends:\n  template: azure-pipelines/MicroBuild.1ES.Official.yml@MicroBuildTemplate\n  parameters:\n    stages:\n    - stage: build\n      jobs:\n      - template: /eng/common/templates-official/jobs/jobs.yml@self\n        parameters:\n          # 1ES makes use of outputs to reduce security task injection overhead\n          templateContext:\n            outputs:\n            - output: pipelineArtifact\n              displayName: 'Publish logs from source'\n              continueOnError: true\n              condition: always()\n              targetPath: $(Build.ArtifactStagingDirectory)/artifacts/log\n              artifactName: Logs\n          jobs:\n          - job: Windows\n            steps:\n            - script: echo \"friendly neighborhood\" > artifacts/marvel/spiderman.txt\n          # copy build outputs to artifact staging directory for publishing\n          - task: CopyFiles@2\n              displayName: Gather build output\n              inputs:\n                SourceFolder: '$(Build.SourcesDirectory)/artifacts/marvel'\n                Contents: '**'\n                TargetFolder: '$(Build.ArtifactStagingDirectory)/artifacts/marvel'\n```\n\n----------------------------------------\n\nTITLE: Debug Points Example for Implicit Constructors\nDESCRIPTION: Examples of how debug points are placed in different implicit constructor scenarios, showing placement for let bindings, do statements, and constructor arguments.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_5\n\nLANGUAGE: fsharp\nCODE:\n```\ntype C(args) =        \n    let x = 1+1         // debug point over `let x = 1+1` as the only side effect\n    let f x = x + 1\n    member _.P = x + f 4\n\ntype C(args) =        \n    do printfn \"hello\"         // debug point over `printfn \"hello\"` as side effect\n    static do printfn \"hello\"         // debug point over `printfn \"hello\"` as side effect for static init\n    let f x = x + 1\n    member _.P = x + f 4\n\ntype C(args) =        // debug point over `(args)` since there's no other place to stop on object construction\n    let f x = x + 1\n    member _.P = 4\n```\n\n----------------------------------------\n\nTITLE: Integer Equality Example\nDESCRIPTION: Basic integer equality comparison demonstrating primitive type equality\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations-equality.md#2025-04-22_snippet_4\n\nLANGUAGE: fsharp\nCODE:\n```\nlet f (x: int) (y: int) = (x = y)\n```\n\n----------------------------------------\n\nTITLE: Restoring Local Tools in F# Compiler Documentation Project\nDESCRIPTION: Commands to navigate back to the main directory and restore local tools required for the documentation generation.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/running-documentation-locally.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd ..\ndotnet tool restore\n```\n\n----------------------------------------\n\nTITLE: Script Example with Internal Function Access\nDESCRIPTION: Example script showing how internal functions are typically accessed across script fragments, highlighting why maintaining this behavior is important for compatibility despite the multi-assembly approach.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/fsi-emit.md#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\nlet internal f() = 1;;\nf();; \n```\n\n----------------------------------------\n\nTITLE: Floating Point Equality Example\nDESCRIPTION: Floating point equality comparison following IEEE rules including NaN handling\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations-equality.md#2025-04-22_snippet_5\n\nLANGUAGE: fsharp\nCODE:\n```\nlet f (x: float32) (y: float32) = (x = y)\n```\n\n----------------------------------------\n\nTITLE: Cloning the F# Compiler Documentation Repository\nDESCRIPTION: Command to clone the F# compiler documentation repository at the same level as your local dotnet/fsharp repository.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/running-documentation-locally.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/fsharp/fsharp-compiler-docs.git\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Namespace and Module Structure in F#\nDESCRIPTION: This snippet shows how namespaces and modules are structured in F#, which is relevant to the dependency tracking algorithm. It illustrates nested modules and the potential impact of AutoOpen attributes.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/Driver/GraphChecking/Docs.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nnamespace A\n\n// If the algorithm determines module A.B is 'potentially used' in another file, there is no need to inspect its contents.\nmodule B =\n\n    module C =\n        \n        // In particular there is no need to check this AutoOpen attribute\n        [<AutoOpen>]\n        module D =\n            ()\n```\n\n----------------------------------------\n\nTITLE: Building F# Compiler in Release Mode\nDESCRIPTION: Command to build the F# compiler repository in Release configuration using Build.cmd script.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/CompiledCodeBenchmarks/README.md#2025-04-22_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n./Build.cmd -c Release\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Error Messages for Invalid Options\nDESCRIPTION: This snippet defines constants for error messages related to invalid or unrecognized compiler options, including target types, debug types, warning levels, and platform specifications.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_6\n\nLANGUAGE: F#\nCODE:\n```\n1048,optsUnrecognizedTarget,\"Unrecognized target '%s', expected 'exe', 'winexe', 'library' or 'module'\"\n1049,optsUnrecognizedDebugType,\"Unrecognized debug type '%s', expected 'pdbonly' or 'full'\"\n1050,optsInvalidWarningLevel,\"Invalid warning level '%d'\"\n1051,optsInvalidSubSystemVersion,\"Invalid version '%s' for '--subsystemversion'. The version must be 4.00 or greater.\"\n1052,optsInvalidTargetProfile,\"Invalid value '%s' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'.\"\n1063,optsUnknownArgumentToTheTestSwitch,\"Unknown --test argument: '%s'\"\n1064,optsUnknownPlatform,\"Unrecognized platform '%s', valid values are 'x86', 'x64', 'Arm', 'Arm64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'. The default is anycpu.\"\n1065,optsUnknownChecksumAlgorithm,\"Algorithm '%s' is not supported\"\n```\n\n----------------------------------------\n\nTITLE: Updated Parser Rule with New Field\nDESCRIPTION: Modified parser rule implementation that includes the new divRange field in the Rational constructor call.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/changing-the-ast.md#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\nSynRationalConst.Rational(fst $1, rhs parseState 1, rhs parseState 2, fst $3, rhs parseState 3, lhs parseState)\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable for Updating Test Baselines on Linux/macOS\nDESCRIPTION: Command to set an environment variable for updating test baselines on Linux or macOS. This is useful when making changes that affect many baseline files.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nexport TEST_UPDATE_BSL=1\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Help Banner Constants\nDESCRIPTION: This snippet defines constants for help banner sections in the F# compiler. These constants are used to organize and display help information for different categories of compiler options.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_2\n\nLANGUAGE: F#\nCODE:\n```\noptsHelpBannerOutputFiles,\"- OUTPUT FILES -\"\noptsHelpBannerInputFiles,\"- INPUT FILES -\"\noptsHelpBannerResources,\"- RESOURCES -\"\noptsHelpBannerCodeGen,\"- CODE GENERATION -\"\noptsHelpBannerAdvanced,\"- ADVANCED -\"\noptsHelpBannerMisc,\"- MISCELLANEOUS -\"\noptsHelpBannerLanguage,\"- LANGUAGE -\"\noptsHelpBannerErrsAndWarns,\"- ERRORS AND WARNINGS -\"\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Miscellaneous Option Constants\nDESCRIPTION: This snippet defines constants for various miscellaneous F# compiler options, including console colors, ASLR, subsystem version, target profile, and debug information in quotations.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_4\n\nLANGUAGE: F#\nCODE:\n```\noptsConsoleColors,\"Output warning and error messages in color (%s by default)\"\noptsUseHighEntropyVA,\"Enable high-entropy ASLR (%s by default)\"\noptsSubSystemVersion,\"Specify subsystem version of this assembly\"\noptsTargetProfile,\"Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib\"\noptsEmitDebugInfoInQuotations,\"Emit debug information in quotations (%s by default)\"\noptsPreferredUiLang,\"Specify the preferred output language culture name (e.g. es-ES, ja-JP)\"\noptsNoCopyFsharpCore,\"Don't copy FSharp.Core.dll along the produced binaries\"\n```\n\n----------------------------------------\n\nTITLE: Visualizing Phases 2-5 Implementation Timeline with Mermaid Gantt Chart\nDESCRIPTION: A Gantt chart showing the later phases of development with parallel tracks for implementing remaining LSP endpoints, setting up the build and release process, and figuring out C# LSP server interoperability.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/lsp.md#2025-04-22_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\ngantt\n    axisFormat .\n    section FsLSP\n        Implement Phase 2 endpoints :fs1, 1900-01-01, 1d\n        Implement Phase 3 endpoints :fs2, after fs1, 1d\n        Implement Phase 4 endpoints :fs3, after fs2, 1d\n        Implement Phase 5 endpoints :fs4, after fs3, 1d\n    section Distribution\n        Settle on release process :d1, 1900-01-01, 1d\n        Add / update build pipelines :d2, after d1, 1d\n        Set up VS insertions :d3, after d2, 1d\n\n    section Cs interop\n        Figure out how to talk to CSharp LSP server :c1, 1900-01-01, 4d\n```\n\n----------------------------------------\n\nTITLE: Defining F# Type Information Constants\nDESCRIPTION: This snippet defines constants for type information used in the F# compiler, including full name and commented-out type and inherits fields.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_7\n\nLANGUAGE: F#\nCODE:\n```\ntypeInfoFullName,\"Full name\"\n# typeInfoType,\"type\"\n# typeInfoInherits,\"inherits\"\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable to Retain Test Build Artifacts on Linux/macOS\nDESCRIPTION: Command to set an environment variable to retain test build artifacts on Linux or macOS. This is helpful when investigating test issues.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/DEVGUIDE.md#2025-04-22_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nexport FSHARP_RETAIN_TESTBUILDS=1\n```\n\n----------------------------------------\n\nTITLE: Including Issue Reference in Changelog Entry\nDESCRIPTION: Demonstrates how to reference both an issue and a pull request in a changelog entry. This format is used when the change resolves a specific tracked issue.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/release-notes/About.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n* Correctly handle assembly imports with public key token of 0 length. ([Issue #16359](https://github.com/dotnet/fsharp/issues/16359), [PR #16363](https://github.com/dotnet/fsharp/pull/16363))\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Internal and Deprecated Option Messages\nDESCRIPTION: This snippet defines constants for messages related to internal compiler options and deprecated command-line options. It includes templates for generating appropriate messages for different scenarios.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_3\n\nLANGUAGE: F#\nCODE:\n```\noptsInternalNoDescription,\"The command-line option '%s' is for test purposes only\"\noptsDCLONoDescription,\"The command-line option '%s' has been deprecated\"\noptsDCLODeprecatedSuggestAlternative,\"The command-line option '%s' has been deprecated. Use '%s' instead.\"\noptsDCLOHtmlDoc,\"The command-line option '%s' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.\"\n```\n\n----------------------------------------\n\nTITLE: Function Composition Optimization Limitations in F#\nDESCRIPTION: Illustrates a limitation in F# optimization where intermediate FSharpFunc values are still allocated during function composition, even with inline functions.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations.md#2025-04-22_snippet_3\n\nLANGUAGE: fsharp\nCODE:\n```\nlet inline f k = (fun x -> k (x + 1))\nlet inline g k = (fun x -> k (x + 2))\n\nlet res = (f << g) id 1 // 4\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Signature and Optimization Data Options\nDESCRIPTION: This snippet defines constants for F# compiler options related to signature data and optimization data. It includes descriptions and error messages for invalid values.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_5\n\nLANGUAGE: F#\nCODE:\n```\noptsSignatureData,\"Include F# interface information, the default is file. Essential for distributing libraries.\"\n1046,optsUnknownSignatureData,\"Invalid value '%s' for --interfacedata, valid value are: none, file, compress.\"\noptsOptimizationData,\"Specify included optimization information, the default is file. Important for distributed libraries.\"\n1047,optsUnknownOptimizationData,\"Invalid value '%s' for --optimizationdata, valid value are: none, file, compress.\"\n```\n\n----------------------------------------\n\nTITLE: Service-based Type Provider Documentation\nDESCRIPTION: XML documentation for OData and WSDL web service type providers, including their parameters and configuration options for accessing remote services.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/vsintegration/tests/MockTypeProviders/DummyProviderForLanguageServiceTesting/FSData.txt#2025-04-22_snippet_2\n\nLANGUAGE: F#\nCODE:\n```\nodataServiceTypeHelp,\"<summary>Provides the types to access an OData service</summary><param name=\\\"ServiceUri\\\">The Uri for the OData service</param><param name='LocalSchemaFile'>The local .csdl file for the service schema</param><param name='ForceUpdate'>Require that a direct connection to the service be available at design-time and force the refresh of the local schema file (default: true)</param><param name='ResolutionFolder'>The folder used to resolve relative file paths at compile-time (default: folder containing the project or script)</param><param name='DataServiceCollection'>Generate collections derived from DataServiceCollection (default: false)</param>\"\nwsdlServiceTypeHelp,\"<summary>Provides the types to access a WSDL web service</summary><param name='ServiceUri'>The Uri for the WSDL service</param><param name='LocalSchemaFile'>The .wsdlschema file to store locally cached service schema</param><param name='ForceUpdate'>Require that a direct connection to the service be available at design-time and force the refresh of the local schema file (default: true)</param><param name='ResolutionFolder'>The folder used to resolve relative file paths at compile-time (default: folder containing the project or script)</param><param name='MessageContract'>Generate Message Contract types (default: false)</param><param name='EnableDataBinding'>Implement the System.ComponentModel.INotifyPropertyChanged interface on all DataContract types to enable data binding (default: false)</param><param name='Serializable'>Generate classes marked with the Serializable Attribute (default: false)</param><param name='Async'>Generate both synchronous and asynchronous method signatures (default: false, which means generate only synchronous method signatures)</param><param name='CollectionType'>A fully-qualified or assembly-qualified name of the type to use as a collection data type when code is generated from schemas</param>\"\n```\n\n----------------------------------------\n\nTITLE: Manual Optimization of Function Composition in F#\nDESCRIPTION: Shows a manual rewrite of the previous example to avoid FSharpFunc allocations, but at the cost of losing function composition flexibility.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations.md#2025-04-22_snippet_4\n\nLANGUAGE: fsharp\nCODE:\n```\nlet f x = x + 1\nlet g x = x + 2\n\nlet res = id 1 |> g |> f // 4\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Option Constants\nDESCRIPTION: This snippet defines constants for various F# compiler options, including descriptions and usage instructions. It covers options for static linking, debugging, assembly resolution, and more.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_1\n\nLANGUAGE: F#\nCODE:\n```\noptsStandalone,\"Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated\"\noptsStaticlink,\"Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.\"\noptsResident,\"Use a resident background compilation service to improve compiler startup times.\"\noptsPdb,\"Name the output debug file\"\noptsSimpleresolution,\"Resolve assembly references using directory-based rules rather than MSBuild resolution\"\noptsShortFormOf,\"Short form of '%s'\"\noptsClirootDeprecatedMsg,\"The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.\"\noptsClirootDescription,\"Use to override where the compiler looks for mscorlib.dll and framework components\"\n```\n\n----------------------------------------\n\nTITLE: Empty Tuple Expression in F#\nDESCRIPTION: This represents an empty tuple in F#, which has the type 'unit'. In F#, unit is a type with only one value, written as '()'. It's used when a function or expression doesn't produce a meaningful result but needs to return something.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/InteractiveSession/Misc/dummy.txt#2025-04-22_snippet_0\n\nLANGUAGE: F#\nCODE:\n```\n()\n```\n\n----------------------------------------\n\nTITLE: Defining Class Method with Closure and Captured Variables\nDESCRIPTION: Shows a class method that creates a closure. The local variable 'y' is captured, but 'x' is not directly captured and is instead accessed through the class instance.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_8\n\nLANGUAGE: fsharp\nCODE:\n```\ntype C() =\n    let x = 1\n    member _.M() = \n        let y = 2\n        (fun () -> x + y)\n```\n\n----------------------------------------\n\nTITLE: Configuring Assembly Binding Redirects for FSharp.Core in XML\nDESCRIPTION: This XML configuration sets up binding redirects for the FSharp.Core assembly. It ensures that any code referencing versions from 2.0.0.0 up to a placeholder version {ver} will be redirected to use the version specified by {ver}. The placeholder would typically be replaced with the actual version number during deployment.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/MultiTargeting/consumer.exe.config.txt#2025-04-22_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <runtime>\n    <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n      <dependentAssembly>\n        <assemblyIdentity\n          name=\"FSharp.Core\"\n          publicKeyToken=\"b03f5f7f11d50a3a\"\n          culture=\"neutral\"/>\n        <bindingRedirect\n          oldVersion=\"2.0.0.0-{ver}\"\n          newVersion=\"{ver}\"/>\n      </dependentAssembly>\n    </assemblyBinding>\n  </runtime>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Displaying ASCII Art Warning in Markdown\nDESCRIPTION: This snippet displays an ASCII art representation of a warning sign, followed by a cautionary message about not modifying files in the directory due to automation management.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/eng/common/README.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Don't touch this folder\n\n                uuuuuuuuuuuuuuuuuuuu\n              u\" uuuuuuuuuuuuuuuuuu \"u\n            u\" u$$$$$$$$$$$$$$$$$$$$u \"u\n          u\" u$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n        u\" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n      u\" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n    u\" u$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$u \"u\n    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $\n    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $\n    $ $$$\" ... \"$...  ...$\" ... \"$$$  ... \"$$$ $\n    $ $$$u `\"$$$$$$$  $$$  $$$$$  $$  $$$  $$$ $\n    $ $$$$$$uu \"$$$$  $$$  $$$$$  $$  \"\"\" u$$$ $\n    $ $$$\"\"$$$  $$$$  $$$u \"$$$\" u$$  $$$$$$$$ $\n    $ $$$$....,$$$$$..$$$$$....,$$$$..$$$$$$$$ $\n    $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $\n    \"u \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n      \"u \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n        \"u \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n          \"u \"$$$$$$$$$$$$$$$$$$$$$$$$\" u\"\n            \"u \"$$$$$$$$$$$$$$$$$$$$\" u\"\n              \"u \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" u\"\n                \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n!!! Changes made in this directory are subject to being overwritten by automation !!!\n\nThe files in this directory are shared by all Arcade repos and managed by automation. If you need to make changes to these files, open an issue or submit a pull request to https://github.com/dotnet/arcade first.\n```\n\n----------------------------------------\n\nTITLE: Creating Func Delegate with F# Lambda\nDESCRIPTION: Demonstrates the creation of a Func delegate using an F# lambda function. This generates a closure class with debug points over the entire expression and the lambda body.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/debug-emit.md#2025-04-22_snippet_9\n\nLANGUAGE: fsharp\nCODE:\n```\nopen System\nlet d = Func<int,int,int>(fun x y -> x + y)\n```\n\n----------------------------------------\n\nTITLE: Defining F# Compiler Version String Templates\nDESCRIPTION: Configuration entries that define string templates for F# compiler version information. The templates include placeholders (%s) that are replaced with actual version numbers at runtime.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/Facilities/UtilsStrings.txt#2025-04-22_snippet_0\n\nLANGUAGE: configuration\nCODE:\n```\nbuildProductName,\"Microsoft (R) F# Compiler version %s\"\nfSharpBannerVersion,\"%s for F# %s\"\n```\n\n----------------------------------------\n\nTITLE: Defining Assembly Resolution Message Keys in F#\nDESCRIPTION: Defines key-value pairs for assembly resolution messages used in F# tooling. The keys represent error codes or message identifiers while values are human-readable messages that explain where assemblies were found during resolution.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/LegacyMSBuildResolver/LegacyResolver.txt#2025-04-22_snippet_0\n\nLANGUAGE: plain text\nCODE:\n```\nassemblyResolutionFoundByAssemblyFoldersKey,\"Found by AssemblyFolders registry key\"\nassemblyResolutionFoundByAssemblyFoldersExKey,\"Found by AssemblyFoldersEx registry key\"\nassemblyResolutionNetFramework,\".NET Framework\"\nassemblyResolutionGAC,\"Global Assembly Cache\"\n```\n\n----------------------------------------\n\nTITLE: Non-inlined Generic Equality Context\nDESCRIPTION: Example demonstrating equality in a non-inlined generic context where EQTYPE is 'T and RUNTIME-EQTYPE is byte\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations-equality.md#2025-04-22_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nlet f2<'T> () =\n   ... some long code\n   let x = HashIdentity.Structural<'T>\n   ... some long code\n\nf2<byte>()\n```\n\n----------------------------------------\n\nTITLE: XML Documentation Template Strings for F# Type Providers\nDESCRIPTION: A collection of template strings used to generate XML documentation for F# type providers, including context types, service APIs, procedure execution, and entity access.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/vsintegration/tests/MockTypeProviders/DummyProviderForLanguageServiceTesting/FSData.txt#2025-04-22_snippet_0\n\nLANGUAGE: F#\nCODE:\n```\nxmlDocContainsTheSimplifiedContextTypes,\"Contains the simplified context types for the %s\"\nxmlDocFullServiceTypesAPI,\"<summary><para>The full API to the %s.</para><para>To use the service via the full API, create an instance of one of the types %s.</para><para>You may need to set the Credentials property on the instance.</para></summary>\"\nxmlDocFullServiceTypesAPINoCredentials,\"<summary><para>The full API to the %s.</para><para>To use the service via the full API, create an instance of one of the types %s.</para></summary>\"\nxmlDocSimplifiedDataContext,\"A simplified data context for the %s. The full data context object is available via the DataContext property.\"\nxmlDocExecuteProcedure,\"Execute the '%s' procedure\"\nxmlDocGetEntities,\"Gets the '%s' entities from the %s. This property may be used as the source in a query expression.\"\nxmlDocGetFullContext,\"Gets the full data context object for this %s\"\nxmlDocGetSimplifiedContext,\"Get a simplified data context for this %s. By default, no credentials are set\"\nxmlDocConstructSimplifiedContext,\"Construct a simplified data context for this %s. By default, no credentials are set\"\nxmlDocDisposeSimplifiedContext,\"Disposes the given context\"\n```\n\n----------------------------------------\n\nTITLE: Build Tool Resource String Definitions\nDESCRIPTION: Defines error message string resources for F# build system, including messages for unknown tool paths, duplicate source roots, path validation, and source root configuration requirements.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/FSharp.Build/FSBuild.txt#2025-04-22_snippet_0\n\nLANGUAGE: resource-strings\nCODE:\n```\ntoolpathUnknown,\"ToolPath is unknown; specify the path to the tool.\"\nmapSourceRootsContainsDuplicate,\"SourceRoot contains duplicate items '%s' with conflicting metadata '%s': '%s' and '%s'\"\nmapSourceRootsPathMustEndWithSlashOrBackslash,\"SourceRoot paths are required to end with a slash or backslash: '%s'\"\nmapSourceRootsNoTopLevelSourceRoot,\"SourceRoot items must include at least one top-level (not nested) item when DeterministicSourcePaths is true\"\nmapSourceRootsNoSuchTopLevelSourceRoot,\"The value of SourceRoot.ContainingRoot was not found in SourceRoot items, or the corresponding item is not a top-level source root: '%s'\"\n```\n\n----------------------------------------\n\nTITLE: Inlined Generic Equality Context\nDESCRIPTION: Example showing equality in an inlined generic context where both EQTYPE and RUNTIME-EQTYPE are byte\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations-equality.md#2025-04-22_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\nlet f3<'T> () =\n   ... some long code\n   let x = HashIdentity.Structural<'T>\n   ... some long code\n\nf3<byte>()\n```\n\n----------------------------------------\n\nTITLE: Type Provider Parameter Documentation for Database Access\nDESCRIPTION: XML documentation for the parameters of database-related type providers including DBML file access, SQL data connection, EDMX file access, and entity connection options.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/vsintegration/tests/MockTypeProviders/DummyProviderForLanguageServiceTesting/FSData.txt#2025-04-22_snippet_1\n\nLANGUAGE: F#\nCODE:\n```\ndbmlFileTypeHelp,\"<summary>Provides the types to access a database with the schema in a DBML file, using a LINQ-to-SQL mapping</summary><param name='File'>The DBML file containing the schema description</param><param name='ResolutionFolder'>The folder used to resolve relative file paths at compile-time (default: folder containing the project or script)</param><param name='ContextTypeName'>The name of data context class (default: derived from database name)</param><param name='Serializable'>Generate uni-directional serializable classes (default: false, which means no serialization)</param>\"\nsqlDataConnectionTypeHelp,\"<summary>Provides the types to access a database, using a LINQ-to-SQL mapping</summary><param name='ConnectionString'>The connection string for the database connection. If using Visual Studio, a connection string can be found in database properties in the Server Explorer window.</param><param name='ConnectionStringName'>The name of the connection string for the database connection in the configuration file.</param><param name='LocalSchemaFile'>The local .dbml file for the database schema (default: no local schema file)</param><param name='ForceUpdate'>Require that a direct connection to the database be available at design-time and force the refresh of the local schema file (default: true)</param><param name='Pluralize'>Automatically pluralize or singularize class and member names using English language rules (default: false)</param><param name='Views'>Extract database views (default: true)</param><param name='Functions'>Extract database functions (default: true)</param><param name='ConfigFile'>The name of the configuration file used for connection strings (default: app.config or web.config is used)</param><param name='DataDirectory'>The name of the data directory, used to replace |DataDirectory| in connection strings (default: the project or script directory)</param><param name='ResolutionFolder'>The folder used to resolve relative file paths at compile-time (default: folder containing the project or script)</param><param name='StoredProcedures'>Extract stored procedures (default: true)</param><param name='Timeout'>Timeout value in seconds to use when SqlMetal accesses the database (default: 0, which means infinite)</param><param name='ContextTypeName'>The name of data context class (default: derived from database name)</param><param name='Serializable'>Generate uni-directional serializable classes (default: false, which means no serialization)</param>\"\nedmxFileTypeHelp,\"<summary>Provides the types to access a database with the schema in an EDMX file, using a LINQ-to-Entities mapping</summary><param name='File'>The EDMX file containing the conceptual, storage and mapping schema descriptions</param><param name='ResolutionFolder'>The folder used to resolve relative file paths at compile-time (default: folder containing the project or script)</param>\"\nsqlEntityConnectionTypeHelp,\"<summary>Provides the types to access a database, using a LINQ-to-Entities mapping</summary><param name='ConnectionString'>The connection string for the database connection</param><param name='ConnectionStringName'>The name of the connection string for the database connection in the configuration file.</param><param name='LocalSchemaFile'>The local file for the database schema</param><param name='Provider'>The name of the ADO.NET data provider to be used for ssdl generation (default: System.Data.SqlClient)</param><param name='EntityContainer'>The name to use for the EntityContainer in the conceptual model</param><param name='ConfigFile'>The name of the configuration file used for connection strings (default: app.config or web.config is used)</param><param name='DataDirectory'>The name of the data directory, used to replace |DataDirectory| in connection strings (default: the project or script directory)</param><param name='ResolutionFolder'>The folder used to resolve relative file paths at compile-time (default: folder containing the project or script)</param><param name='ForceUpdate'>Require that a direct connection to the database be available at design-time and force the refresh of the local schema file (default: true)</param><param name='Pluralize'>Automatically pluralize or singularize class and member names using English language rules (default: false)</param><param name='SuppressForeignKeyProperties'>Exclude foreign key properties in entity type definitions (default: false)</param>\"\n```\n\n----------------------------------------\n\nTITLE: F# Test Configuration Tags Reference\nDESCRIPTION: Comprehensive list of supported configuration tags for F# test exclusions. Each tag represents a specific environment condition, installed component, or build configuration that can be used to control test execution.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/KnownFail.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# Tags currently supported:\\n# DEV11\\t\\t- F# DEV11 installed\\n# VS2008\\t- F# VS2008 installed\\n# NETFX20\\t- NetFx2.0 installed\\n# NETFX30\\t- NetFx3.0 installed\\n# NETFX35\\t- NetFx3.5 installed\\n# NETFX40\\t- NetFx4.0 installed\\n# OS32BIT\\t- OS is 32bit\\n# OS64BIT\\t- OS is 64bit\\n# CHK           - F# build CHK\\n# RET           - F# build RET\\n# POWERPACK\\t- F# Powerpack is installed\\n# MT402040\\t- This is a MT run of type 4.0 -> 2.0 -> 4.0\\n# MT402020\\t- This is a MT run of type 4.0 -> 2.0 -> 2.0\\n# OFFICE        - Office 12 or 14 is installed (2007 or 2010)\\n# OPTIMIZEPLUS  - For runs using the --optimize+ option in ISCFLAGS environment variable\\n# STANDALONE    - For runs using the --standalone option in ISCFLAGS environment variable\\n# INDIRECTARRAYCALLMETHODS    - For runs using the --indirectArrayCallMethods option in ISCFLAGS environment variable\n```\n\n----------------------------------------\n\nTITLE: Generic Struct Type Equality\nDESCRIPTION: Example demonstrating equality with generic struct types in a non-inline context\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/optimizations-equality.md#2025-04-22_snippet_3\n\nLANGUAGE: fsharp\nCODE:\n```\nlet f4<'T> () =\n   ... some long code\n   let x = HashIdentity.Structural<SomeStructType<'T>>\n   ... some long code\n\nf4<byte>()\n```\n\n----------------------------------------\n\nTITLE: Defining F# Build System Resource Strings\nDESCRIPTION: Key-value pairs defining resource strings used in the F# build system for error messages, warnings, and notifications. Includes messages for package management, argument validation, directory operations, and timeout handling.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/FSharp.DependencyManager.Nuget/FSDependencyManager.txt#2025-04-22_snippet_0\n\nLANGUAGE: resource strings\nCODE:\n```\ncantReferenceSystemPackage,\"PackageManager cannot reference the System Package '%s'\"\nrequiresAValue,\"%s requires a value\"\nunableToApplyImplicitArgument,\"Unable to apply implicit argument number %d\"\nnotUsed,\"Not used\"\nloadNugetPackage,\"Load Nuget Package\"\nversion,\"version\"\nhighestVersion,\"with the highest version\"\nsourceDirectoryDoesntExist,\"The source directory '%s' not found\"\ntimedoutResolvingPackages,\"Timed out resolving packages, process: '%s' '%s'\"\ninvalidTimeoutValue,\"Invalid value for timeout '%s', valid values: none, -1 and integer milliseconds to wait\"\nmissingTimeoutValue,\"Missing value for timeout\"\ninvalidBooleanValue,\"Invalid value for boolean '%s', valid values: true or false\"\n```\n\n----------------------------------------\n\nTITLE: Visualizing Phase 0 Implementation Timeline with Mermaid Gantt Chart\nDESCRIPTION: A Gantt chart showing the initial phase of the LSP implementation, including selecting an LSP library, creating projects, implementing a dummy server, and connecting it to the Visual Studio extension.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/lsp.md#2025-04-22_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\ngantt\n    axisFormat .\n    section FsLSP\n        Choose LSP library :fs1, 1900-01-01, 1d\n        Add projects for FsLSP and FsLSPServer :fs2, after fs1, 1d\n        Implement dummy LSP server using the library :fs3, after fs2, 1d\n        Connect to NewVsix :after vsix2 fs3, 1d\n    section Vsix\n        Investigate options for NewVsix :vsix1, 1900-01-01, 1d\n        Implement NewVsix prototype with dummy or some existing LSP server :vsix2, after vsix1, 2d\n```\n\n----------------------------------------\n\nTITLE: F# String Interpolation Examples\nDESCRIPTION: Examples of valid and invalid string interpolation syntax in F#, showing proper usage of format specifiers and interpolation expressions.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_9\n\nLANGUAGE: F#\nCODE:\n```\n%%d{{1+1}}        // Valid\n{{expr,3}}         // Valid .NET style\n{{expr:N5}}        // Valid .NET style\n%%d               // Invalid - missing expression\n%%P               // Invalid specifier\n\n```\n\n----------------------------------------\n\nTITLE: Visualizing Phase 1 Implementation Timeline with Mermaid Gantt Chart\nDESCRIPTION: A Gantt chart showing the second phase of development focused on implementing workspace state management and key LSP endpoints, alongside the Visual Studio extension integration work.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/lsp.md#2025-04-22_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\ngantt\n    axisFormat .\n    section FsLSP\n        Implement WorkspaceStateManagement :fs1, 1900-01-01, 3d\n        Implement Phase 1 endpoints :fs2, after fs1, 2d\n    section Vsix\n        Investigate running side-by-side with old Vsix :vsix1, 1900-01-01, 1d\n        Implement configuration of which features are handled by which Vsix :vsix2, after vsix1, 2d\n```\n\n----------------------------------------\n\nTITLE: Error Message Strings for F# Type Providers\nDESCRIPTION: Error message templates used by F# type providers when encountering various configuration and runtime issues related to connections, parameters, and services.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/vsintegration/tests/MockTypeProviders/DummyProviderForLanguageServiceTesting/FSData.txt#2025-04-22_snippet_4\n\nLANGUAGE: F#\nCODE:\n```\nstaticParameterNotFoundForType,\"static parameter '%s' not found for type '%s'\"\nunexpectedMethodBase,\"unexpected MethodBase\"\ninvalidDataContextClassName,\"%s is not valid name for data context class\"\nfixedQueriesNotSupported,\"The provided ServiceUri is for a data service that supports fixed queries. The OData type provider does not support such services.\"\ndqsServicesNotSupported,\"Services that implement the Data Quality Services API are not supported.\"\ninvalidConnectionString,\"The supplied connection string should be either a valid provider-specific connection string or a valid connection string accepted by the EntityClient.\"\nnonEquivalentConnectionString,\"Connection string presented in EntityClient format can differ only in provider-specific part.\"\nnoConfigFileFound1,\"A configuration string name was specified but no configuration file was found. Neither app.config nor web.config found in project or script directory.\"\nnoConfigFileFound2,\"A configuration string name was specified but the configuration file '%s' was not found\"\nnoConnectionStringOrConnectionStringName,\"When using this provider you must specify either a connection string or a connection string name. To specify a connection string, use %s<\\\"...connection string...\\\">.\"  \nnotBothConnectionStringOrConnectionStringName,\"When using this provider you must specify either a connection string or a connection string name, but not both. To specify a connection string, use SqlDataConnection<\\\"...connection string...\\\">.\"  \ninvalidProviderInConfigFile,\"Invalid provider '%s' in connection string entry '%s' in config file '%s'. SqlDataConnection can only be used with provider 'System.Data.SqlClient'.\"\ninvalidConnectionStringInConfigFile,\"Invalid empty connection string '%s' for the connection string name '%s' in config file '%s'\"\n```\n\n----------------------------------------\n\nTITLE: Listing F# Test Assembly Names\nDESCRIPTION: A list of test and benchmark assembly DLLs that are part of the F# language implementation, covering different testing aspects like unit tests, benchmarks, component tests and test utilities.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/buildtools/AssemblyCheck/SkipVerifyEmbeddedPdb.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nFSharp.Build.UnitTests.dll\nFSharp.Benchmarks.Common.dll\nFSharp.Compiler.Benchmarks.dll\nFSharp.Compiler.ComponentTests.dll\nFSharp.Test.Utilities.dll\nFSharp.Compiler.Private.Scripting.UnitTests.dll\nFSharp.Compiler.Service.Tests.dll\nFSharp.Core.UnitTests.dll\nFSharpSuite.Tests.dll\n```\n\n----------------------------------------\n\nTITLE: Connection and Credential Information Strings\nDESCRIPTION: Descriptive strings for connection and credential properties used by SQL, Entity, and OData type providers.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/vsintegration/tests/MockTypeProviders/DummyProviderForLanguageServiceTesting/FSData.txt#2025-04-22_snippet_3\n\nLANGUAGE: F#\nCODE:\n```\nsqlDataConnection,\"SQL connection\"\nsqlDataConnectionInfo,\"Gets the connection used by the framework\"\nsqlEntityConnection,\"SQL Entity connection\"\nconnectionInfo,\"Gets the connection used by the object context\"\nodataServiceCredentialsInfo,\"Gets or sets the authentication information used by each query for this data context object\"\n```\n\n----------------------------------------\n\nTITLE: Referencing Language Suggestion in Changelog Entry\nDESCRIPTION: Shows how to reference a language suggestion in addition to a pull request. This format is used for changes that implement features requested through the language suggestion process.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/release-notes/About.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n* `while!` ([Language suggestion #1038](https://github.com/fsharp/fslang-suggestions/issues/1038), [PR #14238](https://github.com/dotnet/fsharp/pull/14238))\n```\n\n----------------------------------------\n\nTITLE: F# Reference Cell Operations\nDESCRIPTION: Deprecated and recommended syntax for F# reference cell operations including dereferencing, assignment, increment and decrement.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_10\n\nLANGUAGE: F#\nCODE:\n```\n!cell               // Deprecated\ncell.Value         // Recommended\ncell := expr       // Deprecated\ncell.Value <- expr // Recommended\nincr cell          // Deprecated\ncell.Value <- cell.Value + 1 // Recommended\ndecr cell          // Deprecated\ncell.Value <- cell.Value - 1 // Recommended\n```\n\n----------------------------------------\n\nTITLE: Consolidating Multiple Related PRs in Single Entry\nDESCRIPTION: Demonstrates how to list multiple related pull requests in a single changelog entry when they address the same feature or bug category.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/release-notes/About.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n* Miscellaneous fixes to parentheses analysis. ([PR #16262](https://github.com/dotnet/fsharp/pull/16262), [PR #16391](https://github.com/dotnet/fsharp/pull/16391), [PR #16370](https://github.com/dotnet/fsharp/pull/16370))\n```\n\n----------------------------------------\n\nTITLE: Commenting Error Message Handling Instructions in F#\nDESCRIPTION: This code snippet provides instructions for managing error messages in F# projects. It emphasizes using new error numbers and keeping messages within their existing groups.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/Compiler/FSComp.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n# -------------------------------------------------------------------------------\n# use a completely new error number and keep messages in their surrounding groups\n# -------------------------------------------------------------------------------\n```\n\n----------------------------------------\n\nTITLE: Known Failures in F# Redmond Test Suite\nDESCRIPTION: Lists known failures in the F# Redmond test suite (RunAll.pl), specifying test names, file paths, and reasons for failure. Includes various scenarios like platform-specific issues and multi-targeting problems.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/KnownFail.txt#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nfail001\t\tCodeGen\\EmittedIL\\SerializableAttribute\t#  (ToplevelNamespace.fs - Desktop)\nfail002\t\tCodeGen\\EmittedIL\\SerializableAttribute\t#  (ToplevelModule.fs - Portable)\nfail003\t\tCodeGen\\EmittedIL\\SerializableAttribute\t#  (ToplevelNamespace.fs - Portable)\nOS32BIT\t\t\t\t\t\tConformance\\DeclarationElements\\P-invokeDeclarations (CallingConventions01.fs - x64) -- This test is not meant to run on a 32bit OS\nMT402020\t\t\t\t\tConformance\\Expressions\\ApplicationExpressions\\ObjectConstruction (E_ObjectConstruction01.fs) -- DevDiv:90622\t\nMT402040\t\t\t\t\tConformance\\Expressions\\ApplicationExpressions\\ObjectConstruction (E_ObjectConstruction01.fs) -- DevDiv:90622\t\n```\n\n----------------------------------------\n\nTITLE: F# Runtime Method Not Found Exception\nDESCRIPTION: Error message indicating a missing method exception in the F# runtime system. This typically occurs when trying to call a method that doesn't exist or has been removed.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/Conformance/TypeForwarding/Class/NG_TurnToStruct_x86_ExpErr.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSystem.MissingMethodException: Method not found\n```\n\n----------------------------------------\n\nTITLE: System.MissingMethodException Error Message in F#\nDESCRIPTION: An error message indicating that a method could not be found during execution. This typically occurs when trying to call a method that doesn't exist or when there's a version mismatch between assemblies.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/fsharpqa/Source/Conformance/TypeForwarding/Class/NG_TurnToStruct_64_ExpErr.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSystem.MissingMethodException: Method not found\n```\n\n----------------------------------------\n\nTITLE: Directory Structure Reference in Markdown\nDESCRIPTION: Lists the three output files produced by the HistoricalBenchmark.Runner.runAll function for different version selections of the F# compiler.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/benchmarks/FCSBenchmarks/BenchmarkComparison/sample_results/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `sample_versions` - an arbitrary selection featuring all three types of versions supported\n- `between_2_nuget_versions` - all commits between two NuGet versions of FCS\n- `10_latest_nuget_versions` - 10 FCS NuGet versions between `v41.0.2` and ``v41.0.5-preview.22327.2`\n```\n\n----------------------------------------\n\nTITLE: Building VisualFSharp Solution and TestProject with MSBuild\nDESCRIPTION: The commands to build the VisualFSharp solution and the TestProject separately. TestProject is built separately to avoid type provider DLL locking problems.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/tests/service/data/TestProject/netstandard2.0/README.md#2025-04-22_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\nmsbuild VisualFSharp.sln\nmsbuild C:\\GitHub\\dsyme\\fsharp\\tests\\service\\data\\TestProject\n```\n\n----------------------------------------\n\nTITLE: F# Language Service Overview - No code snippets present\nDESCRIPTION: This documentation file contains tables and descriptions of F# Language Service features but no actual code snippets.\nSOURCE: https://github.com/dotnet/fsharp/blob/main/docs/tooling-features.md#2025-04-22_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Basic Dependency Manager Extension Reference in F#\nDESCRIPTION: Shows the basic syntax for referencing a dependency manager extension in F# Interactive\nSOURCE: https://github.com/dotnet/fsharp/blob/main/src/FSharp.DependencyManager.Nuget/README.md#2025-04-22_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\n#r \"myextension: my extension parameters\"\n```"
  }
]