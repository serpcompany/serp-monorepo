[
  {
    "owner": "mantinedev",
    "repo": "mantine",
    "content": "TITLE: Configuring React Testing Library with Mantine Theme for Tests (TSX)\nDESCRIPTION: This snippet provides a custom render function designed for testing Mantine components with React Testing Library. It uses MantineProvider and a merged theme (testTheme) that overrides the default Modal component's defaultProps to set transitionProps.duration to 0. This effectively disables transitions during tests, resolving issues where tests fail due to components not being immediately available in the DOM after state changes triggered by user events. It requires @testing-library/react, @mantine/core, and access to the project's main theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/portals-testing.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { render as testingLibraryRender } from '@testing-library/react';\nimport { createTheme, MantineProvider, mergeThemeOverrides, Modal } from '@mantine/core';\n// Your project theme\nimport { theme } from '../theme';\n\n// Merge your project theme with tests specific overrides\nconst testTheme = mergeThemeOverrides(\n  theme,\n  createTheme({\n    components: {\n      Modal: Modal.extend({\n        defaultProps: {\n          transitionProps: { duration: 0 },\n        },\n      }),\n    },\n  })\n);\n\nexport function render(ui: React.ReactNode) {\n  return testingLibraryRender(<>{ui}</>, {\n    wrapper: ({ children }: { children: React.ReactNode }) => (\n      <MantineProvider theme={testTheme}>{children}</MantineProvider>\n    ),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Option with Mantine Select Using React Testing Library (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates how to write a test that simulates user selection of a single option in a Mantine Select component. It uses Jest or Vitest (as test runner), and depends on React, Mantine's Select component, and React Testing Library (render, userEvent, and screen utilities). Required test setup: import these utilities from your project's test-utils. Inputs include rendering a form with a Select and simulating a user clicking on the input and option; outputs are assertions on the displayed value and the hidden input value submitted with the form. The pattern is applicable whenever a one-of-many select is being tested.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/combobox-testing.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Select } from '@mantine/core';\n\nfunction MyForm() {\n  return (\n    <Select\n      name=\"age\"\n      label=\"Select your age\"\n      data=[\n        { value: 'ok', label: 'I am 18 or older' },\n        { value: 'not-ok', label: 'I am under 18' },\n      ]\n    />\n  );\n}\n\nit('selects option', () => {\n  render(<MyForm />);\n\n  // Click Select to open the options list\n  // Note that the dropdown is closed when one of the options is selected\n  // If you want to select several options one after another,\n  // you need to click the input again to open the dropdown\n  await userEvent.click(screen.getByRole('textbox', { name: 'Select your age' }));\n\n  // Get option by its label and click it\n  await userEvent.click(screen.getByRole('option', { name: 'I am 18 or older' }));\n\n  // Verify that the option is selected\n  // This is what user sees in the input\n  expect(screen.getByRole('textbox')).toHaveValue('I am 18 or older');\n\n  // This is what will be submitted with the form\n  expect(document.querySelector('input[name=\"age\"]')).toHaveValue('ok');\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Inline Style Props with Mantine Components (TypeScript TSX)\nDESCRIPTION: Demonstrates how to use Mantine's Box component with inline style props such as mx (margin-x), maw (maximum width), c (color), and bg (background). The snippet requires the @mantine/core package and is intended for use in a React application written in TypeScript. Props accept both theme-aware and raw values, affecting the root element's style. This approach is suitable for static, non-responsive styles attached directly to Mantine components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style-props.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box mx=\"auto\" maw={400} c=\"blue.6\" bg=\"#fff\">\n      Your component\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Server Side Rendering with useMediaQuery Hook in Mantine\nDESCRIPTION: Shows how to configure useMediaQuery to provide an initial value during server-side rendering, bypassing the absence of window.matchMedia API. Specifies setting getInitialValueInEffect to false to disable initial value computation in effects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-media-query.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMediaQuery } from '@mantine/hooks';\n\nfunction Demo() {\n  // Set initial value in second argument and getInitialValueInEffect option to false\n  const matches = useMediaQuery('(max-width: 40em)', true, {\n    getInitialValueInEffect: false,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Responsive Style Props with Object Syntax in React/TypeScript\nDESCRIPTION: Illustrates how to provide an object to Mantine style props (like `w` for width) to specify different values based on Mantine's predefined breakpoints. The object keys (`base`, `sm`, `lg`) correspond to breakpoints, and the values are the styles applied at or above that breakpoint, enabling inline responsive styling on Mantine components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/responsive.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box w={{ base: 320, sm: 480, lg: 640 }} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Theme Overrides in a Variable in Mantine\nDESCRIPTION: This code snippet shows how to define a custom theme override and store it in a variable outside a component. This approach prevents unnecessary re-renders. The `createTheme` function generates the theme override with properties like `primaryColor` and `defaultRadius`, and the `MantineProvider` component makes the customized theme available to the application's children.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/theme-object.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst myTheme = createTheme({\n  primaryColor: 'orange',\n  defaultRadius: 0,\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={myTheme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Custom Mantine CSS Variables in Application Styles with CSS\nDESCRIPTION: This CSS snippet shows how to use the custom CSS variables defined in MantineProvider, such as --mantine-hero-height and --mantine-color-deep-orange, within your application styles. No additional dependencies are required. The .hero class utilizes these variables for height and background-color, allowing for automatic adaptation based on the active color scheme. The variables must be initialized via the Mantine cssVariablesResolver.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_26\n\nLANGUAGE: CSS\nCODE:\n```\n.hero {\n  height: var(--mantine-hero-height);\n\n  /* background color will automatically change based on color scheme */\n  background-color: var(--mantine-color-deep-orange);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Clearing a Single Field Error with clearFieldError – Mantine\nDESCRIPTION: Illustrates how to clear the error for a specific field using the `form.clearFieldError` handler. This provides granular control over the form's error state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialErrors: { name: 'Too short', email: 'Invalid email' },\n});\nform.clearFieldError('name');\n\nform.errors; // -> { email: 'Invalid email' }\n\n```\n\n----------------------------------------\n\nTITLE: Configuring onSubmitPreventDefault in use-form\nDESCRIPTION: This snippet shows how to customize default form submission behavior in 'useForm' by setting 'onSubmitPreventDefault' option to control whether 'event.preventDefault()' is called during form submission, enabling server integration or default behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  onSubmitPreventDefault: 'never',\n});\n```\n\n----------------------------------------\n\nTITLE: Import Mantine Core Styles - TypeScript/TSX\nDESCRIPTION: This code snippet demonstrates how to import the essential core styles for Mantine. The `@mantine/core/styles.css` import is required for all Mantine packages and should typically be placed at the root of your application, for example, in a `_app.tsx` file in Next.js.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/getting-started.mdx#_snippet_1\n\nLANGUAGE: TypeScript/TSX\nCODE:\n```\n// core styles are required for all packages\nimport '@mantine/core/styles.css';\n\n// other css files are required only if\n// you are using components from the corresponding package\n// import '@mantine/dates/styles.css';\n// import '@mantine/dropzone/styles.css';\n// import '@mantine/code-highlight/styles.css';\n// ...\n```\n\n----------------------------------------\n\nTITLE: Multiple Nodes Implementation with useClickOutside Hook\nDESCRIPTION: Shows how to use useClickOutside with multiple nodes, particularly useful when working with portals. This example tracks clicks outside both a control element and a dropdown that exists in a different part of the DOM tree.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-click-outside.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Will work only with useState, not useRef\nimport { useState } from 'react';\nimport { Portal } from '@mantine/core';\nimport { useClickOutside } from '@mantine/hooks';\n\nfunction Demo() {\n  const [dropdown, setDropdown] = useState<HTMLDivElement | null>(\n    null\n  );\n  const [control, setControl] = useState<HTMLDivElement | null>(null);\n\n  useClickOutside(() => console.log('outside'), null, [\n    control,\n    dropdown,\n  ]);\n\n  return (\n    // We cannot use root element ref as it does not contain dropdown\n    <div>\n      <div ref={setControl}>Control</div>\n      <Portal>\n        <div ref={setDropdown}>Dropdown</div>\n      </Portal>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing useForm Hook with Initial Values - Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates how to initialize the useForm hook from @mantine/form with a comprehensive object containing nested fields and arrays. It does not require additional dependencies except for @mantine/form and works in uncontrolled mode. The initialValues parameter specifies the starting values for each form field. Expected input is the configuration object; output is a form instance with state and methods for further manipulation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    path: '',\n    path2: '',\n    user: {\n      firstName: 'John',\n      lastName: 'Doe',\n    },\n    fruits: [\n      { name: 'Banana', available: true },\n      { name: 'Orange', available: false },\n    ],\n    accepted: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Controlled Slider with useState in React\nDESCRIPTION: Demonstrates a controlled Slider component using React's useState hook to manage the slider's value. The component initializes the value to 40 and updates it whenever the slider is changed. Requires importing useState from 'react' and Slider from '@mantine/core'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/slider.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Slider } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState(40);\n  return <Slider value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Between px, rem, and em with Mantine Utility Functions in React (TypeScript)\nDESCRIPTION: Shows the use of rem, em, and px utility functions from @mantine/core to convert between units in code. rem() converts numbers or px values to rem (with scaling considered), em() converts to em units, and px() converts rem/em values to pixels. These functions expect either numeric values or valid unit strings, with outputs as string expressions or numbers suitable for use in inline styles or logic. Requires @mantine/core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rem.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { em, rem } from '@mantine/core';\n\n// numbers and values in px are converted to rem\nrem(32); // -> calc(2rem * var(--mantine-scale))\nem(32); // -> 2em\nrem('16px'); // -> calc(1rem * var(--mantine-scale))\nem('16px'); // -> 1em\n\nrem('2rem'); // -> calc(2rem * var(--mantine-scale))\nem('2rem'); // -> 2rem\n\nrem('50%'); // -> 50%\nem('50%'); // -> 50%\n\nrem('5vh'); // -> 5vh\nem('5vh'); // -> 5vh\n\n// mixed values are converted to rem\nrem('16px 2rem'); // -> calc(1rem * var(--mantine-scale)) calc(2rem * var(--mantine-scale))\n```\n\nLANGUAGE: tsx\nCODE:\n```\nimport { px } from '@mantine/core';\n\npx('2rem'); // -> 32\npx('10rem'); // -> 160\n```\n\n----------------------------------------\n\nTITLE: Controlled RangeSlider with useState in React\nDESCRIPTION: Shows how to create a controlled RangeSlider component using React's useState hook. The slider's value is initialized to an array [20, 80] and updated on change. This example imports useState from 'react' and RangeSlider from '@mantine/core'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/slider.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { RangeSlider } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<[number, number]>([20, 80]);\n  return <RangeSlider value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Updating State with useSetState in React (TypeScript/TSX)\nDESCRIPTION: This snippet illustrates initializing state with an object and updating it using the useSetState hook from @mantine/hooks in a functional React component. The setState function supports shallow merging of partial state updates as well as updater functions referencing the current state. Dependencies include @mantine/hooks and a React/TypeScript setup. Initial state must be an object; setState accepts objects or updater functions. Inputs are partial state objects or functions; output is the updated state object. Does not support arrays or primitive state values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-set-state.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useSetState } from '@mantine/hooks';\n\nconst [state, setState] = useSetState({\n  name: 'John',\n  age: 35,\n  job: 'Engineer',\n});\n\nstate; // -> { name: 'John', age: 35, job: 'Engineer' }\n\nsetState({ name: 'Jane' }); // -> { name: 'Jane', age: 35, job: 'Engineer' }\nsetState({ age: 25, job: 'Manager' }); // -> { name: 'Jane', age: 25, job: 'Manager' }\nsetState((current) => ({ age: current.age + 7 })); // -> { name: 'Jane', age: 32, job: 'Manager' }\n```\n\n----------------------------------------\n\nTITLE: Validating with Zod using useForm\nDESCRIPTION: This snippet demonstrates basic form validation using Zod with Mantine Form. It defines a schema for validating name, email, and age fields, then uses `zodResolver` to integrate the schema with the form. The `useForm` hook is used to manage form state and validation, demonstrating how to access validation errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { zodResolver } from 'mantine-form-zod-resolver';\nimport { z } from 'zod';\nimport { useForm } from '@mantine/form';\n\nconst schema = z.object({\n  name: z\n    .string()\n    .min(2, { message: 'Name should have at least 2 letters' }),\n  email: z.string().email({ message: 'Invalid email' }),\n  age: z.number().min(18, {\n    message: 'You must be at least 18 to create an account',\n  }),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: zodResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  name: 'Name should have at least 2 letters',\n//  email: 'Invalid email',\n//  age: 'You must be at least 18 to create an account'\n// }\n```\n\n----------------------------------------\n\nTITLE: Wrap App with MantineProvider - TypeScript/TSX\nDESCRIPTION: This snippet shows how to wrap your main application component with the `MantineProvider`. The provider is crucial for supplying theme context, managing color schemes, and applying global styles to all Mantine components used within the application tree.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/getting-started.mdx#_snippet_2\n\nLANGUAGE: TypeScript/TSX\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  /** Put your mantine theme override here */\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling search value in TagsInput with React useState\nDESCRIPTION: This snippet shows how to control the search input inside TagsInput component using React's useState hook. The searchValue state is dedicated to managing the current search input, enhancing external control over the search behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { TagsInput } from '@mantine/core';\n\nfunction Demo() {\n  const [searchValue, setSearchValue] = useState('');\n  return (\n    <TagsInput\n      searchValue={searchValue}\n      onSearchChange={setSearchValue}\n      data={[]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useToggle with Array Values in TSX\nDESCRIPTION: Demonstrates how to initialize the `useToggle` hook with an array of specific values. Calling the returned `toggle` function cycles through the values. Passing a value to `toggle` forces the state to that specific value. Requires installation of `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-toggle.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useToggle } from '@mantine/hooks';\n\nconst [value, toggle] = useToggle(['light', 'dark'] as const);\n\ntoggle(); // -> value == 'light'\ntoggle(); // -> value == 'dark'\n\n// You can force specific value, in this case state will be set to given value\ntoggle('dark'); // -> value == 'dark'\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Fields with Joi and useForm\nDESCRIPTION: This snippet shows the validation of nested fields with Joi and Mantine Form. It defines a Joi schema for a nested object, integrates with the `useForm` hook using `joiResolver`, and demonstrates access to validation error messages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport Joi from 'joi';\nimport { joiResolver } from 'mantine-form-joi-resolver';\nimport { useForm } from '@mantine/form';\n\nconst nestedSchema = Joi.object({\n  nested: Joi.object({\n    field: Joi.string().min(2).messages({\n      'string.min': 'Field should have at least 2 letters',\n      'string.empty': 'Field should have at least 2 letters',\n    }),\n  }),\n});\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    nested: {\n      field: '',\n    },\n  },\n  validate: joiResolver(nestedSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'nested.field': 'Field should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Using MantineProvider to set default color scheme in React (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure the default color scheme ('light', 'dark', or 'auto') for a Mantine application using the MantineProvider component in React. It specifies dependencies and shows how to apply the provider with the default color scheme setting.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider defaultColorScheme=\"dark\">\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Mantine Button.Group in TSX\nDESCRIPTION: Demonstrates an incorrect way to structure components within Mantine's `Button.Group`. Wrapping individual `Button` components within extra elements like `<div>` disrupts the CSS selectors `Button.Group` uses to apply styles (like borders) correctly to its direct children. Buttons should be direct children of `Button.Group` for proper rendering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/button.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button.Group>\n      <div>\n        <Button>This will not work</Button>\n      </div>\n      <Button>Buttons will have incorrect borders</Button>\n    </Button.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling AppShell Transitions with Custom Duration and Timing\nDESCRIPTION: Example showing how to customize the transition effects for AppShell components by setting transitionDuration and transitionTimingFunction props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <AppShell\n      transitionDuration={500}\n      transitionTimingFunction=\"ease\"\n    >\n      {/* AppShell content */}\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Accessible PillsInput with label prop\nDESCRIPTION: This code snippet shows how to set the `label` prop on the `PillsInput` component to improve accessibility. It shows how to make the component accessible by providing a visible label. The output is an accessible `PillsInput` component. It requires the `@mantine/core` library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pills-input.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PillsInput } from '@mantine/core';\n\n// Accessible input – it has associated label element\nfunction Demo() {\n  return (\n    <PillsInput label=\"Enter tags\">\n      <PillsInput.Field />\n    </PillsInput>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Applying CSS Module Styles in React (TSX)\nDESCRIPTION: Shows how to import a CSS module (`Button.module.css`) into a React component (TSX) and apply its scoped class (`classes.button`) to an HTML button element using the `className` prop. This ensures styles are locally scoped to the component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport classes from './Button.module.css';\n\nfunction Demo() {\n  return (\n    <button className={classes.button} type=\"button\">\n      Button\n    </button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Duplicate Mantine Style Imports in TypeScript\nDESCRIPTION: Warns against importing both regular and layered versions of Mantine styles in the same TypeScript project. Importing both versions can cause style conflicts and should be avoided. Only one of the styles.css or styles.layer.css should be imported for each package/component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ❌ Do not import both styles.css and styles.layer.css\nimport '@mantine/core/styles.css';\nimport '@mantine/core/styles.layer.css';\n```\n\n----------------------------------------\n\nTITLE: Setting Generic Node Type for useMergedRef (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a ref with a specific generic type using Mantine's useMergedRef, suitable when you want strong type checking for the ref (e.g., HTMLDivElement). It depends on @mantine/hooks. Useful for ensuring ref is attached to the correct DOM node type in TypeScript React projects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-merged-ref.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useMergedRef } from '@mantine/hooks';\n\nconst ref = useMergedRef<HTMLDivElement>();\n```\n\n----------------------------------------\n\nTITLE: Handling onSubmit and onReset Events - Mantine (TypeScript/TSX)\nDESCRIPTION: This comprehensive example shows how to use form event handlers such as onSubmit and onReset provided by useForm, including handling of validated values and validation errors. It outlines integration with standard React form components and supports both single and dual callback structures for submit handling. Dependencies are @mantine/form and React; input is user event data, and output is typically side effects or log statements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_5\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({ mode: 'uncontrolled' });\n\n  const handleSubmit = (values: typeof form.values) => {\n    console.log(values);\n  };\n\n  return (\n    <>\n      {/* Supply handle submit as a single argument to receive validated values */}\n      <form onSubmit={form.onSubmit(handleSubmit)} />\n\n      {/* Supply second argument to handle errors */}\n      <form\n        onSubmit={form.onSubmit(\n          (values, event) => {\n            console.log(\n              values, // <- form.getValues() at the moment of submit\n              event // <- form element submit event\n            );\n          },\n          (validationErrors, values, event) => {\n            console.log(\n              validationErrors, // <- form.errors at the moment of submit\n              values, // <- form.getValues() at the moment of submit\n              event // <- form element submit event\n            );\n          }\n        )}\n      />\n\n      {/* form.onReset calls form.reset */}\n      <form onReset={form.onReset}></form>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Gatsby Browser API Wrapper with MantineProvider in TypeScript\nDESCRIPTION: Defines the 'wrapPageElement' Gatsby browser API function to wrap the root element with MantineProvider using the custom theme. It also imports Mantine's global styles for proper styling of components. This file named 'gatsby-browser.tsx' ensures Mantine styles and theming are applied during client-side navigation. Dependencies include '@mantine/core' and the local theme definition.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/gatsby.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Import styles of packages that you've installed.\n// All packages except `@mantine/hooks` require styles imports\nimport '@mantine/core/styles.css';\n\nimport { MantineProvider } from '@mantine/core';\nimport { theme } from './src/theme';\n\nexport const wrapPageElement = ({ element }) => {\n  return <MantineProvider theme={theme}>{element}</MantineProvider>;\n};\n```\n\n----------------------------------------\n\nTITLE: Using Mantine useResizeObserver Hook in TSX\nDESCRIPTION: This snippet demonstrates the basic implementation of the `useResizeObserver` hook from `@mantine/hooks`. It shows how to import the hook, call it to obtain a `ref` and the element's `rect` (size and position), and then attach the `ref` to an HTML element (a `div` in this case) to initiate observation. The `rect` variable will automatically update with the element's content rectangle when its size changes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-resize-observer.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useResizeObserver } from '@mantine/hooks';\n\nfunction Demo() {\n  const [ref, rect] = useResizeObserver();\n  return <div ref={ref}>Observed</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating nested array list items with Mantine useForm hook in TypeScript\nDESCRIPTION: Demonstrates validation of list elements within nested array structures using Mantine useForm. The code initializes users as an array of objects with name and age fields, adding validators enforcing minimum name length and adult age requirements. It shows validation of specific fields via validateField and bulk validation with validate(), resulting in a structured errors object keyed by indexed paths like 'users.1.name'. Requires '@mantine/form' and list initialValues input; outputs validation error messages for invalid entries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/nested.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    users: [\n      { name: 'John', age: 12 },\n      { name: '', age: 22 },\n    ],\n  },\n\n  validate: {\n    users: {\n      name: (value) =>\n        value.length < 2\n          ? 'Name should have at least 2 letters'\n          : null,\n      age: (value) =>\n        value < 18 ? 'User must be 18 or older' : null,\n    },\n  },\n});\n\n// Validate list item field\nform.validateField('users.1.name');\n\n// Or with all other fields\nform.validate();\nconsole.log(form.errors);\n// {\n//  'users.0.age': 'User must be 18 or older',\n//  'users.1.name': 'Name should have at least 2 letters'\n// }\n```\n\n----------------------------------------\n\nTITLE: Updating Form Initial Values Dynamically with form.setInitialValues Hook (TypeScript)\nDESCRIPTION: This React TypeScript example demonstrates how to update form initial values dynamically in a Mantine form using the 'setInitialValues' method after an asynchronous data fetch. The pattern is crucial for scenarios where initial field values are loaded remotely and resets or dirty-field comparisons must be accurate. Dependencies are '@mantine/form' and standard React hooks.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-1-0.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    initialValues: {\n      name: '',\n      email: '',\n    },\n  });\n\n  useEffect(() => {\n    fetch('/api/user')\n      .then((res) => res.json())\n      .then((data) => {\n        // Update initial values after form was initialized\n        // These values will be used in form.reset\n        // and to compare values to get dirty state\n        form.setInitialValues(data);\n        form.setValues(data);\n      });\n  }, []);\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Touched and Dirty State in Mantine Form\nDESCRIPTION: This code snippet shows how to use `form.resetTouched` and `form.resetDirty` functions to clear the touched and dirty states of the form. `form.reset` also resets the `touched` and `dirty` state.  Requires `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/status.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { a: 1 },\n  initialTouched: { a: true },\n  initialDirty: { a: true },\n});\n\nform.isDirty('a'); // -> true\nform.isTouched('a'); // -> true\n\nform.resetTouched();\nform.isTouched('a'); // -> false\n\nform.resetDirty();\nform.isDirty('a'); // -> false\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Dates Styles in TypeScript\nDESCRIPTION: Imports the necessary CSS styles for the @mantine/dates package. This import should typically be placed at the root of the application after the package has been installed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/getting-started.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/dates/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Disabled State Example for Fieldset Component\nDESCRIPTION: Demonstrates how to disable all inputs and buttons inside the fieldset component by setting the disabled prop in demo data. This illustrates the component's ability to handle disabled states for accessibility and control purposes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/fieldset.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={FieldsetDemos.disabled} />\n```\n\n----------------------------------------\n\nTITLE: Configuring Storybook preview.tsx with MantineProvider and Dark Mode Support\nDESCRIPTION: This snippet sets up the .storybook/preview.tsx file to include Mantine styles, wraps stories in MantineProvider with a shared theme, and adds support for dark/light mode switching via storybook-dark-mode events. It uses React hooks and Storybook API to synchronize color schemes and ensure consistent theme application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/storybook.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import styles and dependencies\nimport '@mantine/core/styles.css';\nimport { useEffect } from 'react';\nimport { addons } from '@storybook/preview-api';\nimport { DARK_MODE_EVENT_NAME } from 'storybook-dark-mode';\nimport {\n  MantineProvider,\n  useMantineColorScheme\n} from '@mantine/core';\n// Import the shared theme\nimport { theme } from '../src/theme';\n\nconst channel = addons.getChannel();\n\nfunction ColorSchemeWrapper({ children }: { children: React.ReactNode }) {\n  const { setColorScheme } = useMantineColorScheme();\n  const handleColorScheme = (value: boolean) => setColorScheme(value ? 'dark' : 'light');\n\n  useEffect(() => {\n    channel.on(DARK_MODE_EVENT_NAME, handleColorScheme);\n    return () => channel.off(DARK_MODE_EVENT_NAME, handleColorScheme);\n  }, [channel]);\n\n  return <>{children}</>;\n}\n\nexport const decorators = [\n  (renderStory: any) => (\n    <ColorSchemeWrapper>{renderStory()}</ColorSchemeWrapper>\n  ),\n  (renderStory: any) => (\n    <MantineProvider theme={theme}>{renderStory()}</MantineProvider>\n  ),\n];\n```\n\n----------------------------------------\n\nTITLE: Using useDisclosure Hook with Basic Handlers in React (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the useDisclosure hook from @mantine/hooks to manage a boolean state in a React component. The example initializes the state as closed (false) and provides handlers to open, close, or toggle the state for managing UI components like modals or popovers. There are no additional dependencies besides React and Mantine Hooks, and the inputs/outputs are limited to the boolean state and a handler object with open, close, and toggle functions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-disclosure.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const [opened, handlers] = useDisclosure(false);\n\n  // Sets opened to true\n  handlers.open();\n\n  // Sets opened to false\n  handlers.close();\n\n  // Sets opened to true if it was false and vice versa\n  handlers.toggle();\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Table Component with Style API and New Props\nDESCRIPTION: Describes multiple improvements including Style API support, requiring use of compound components, new props for styling and borders, and a dedicated ScrollContainer for scrollable tables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_15\n\n\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useQueue Hook in Mantine\nDESCRIPTION: Provides the TypeScript type signature for the useQueue hook as defined in Mantine. Lists input parameters (configuration object with optional initialValues and required limit) and return structure, including state, queue, and management functions. This definition guides developers integrating the hook into TypeScript-enabled projects and serves as formal API documentation. Dependency: @mantine/hooks. Intended for documentation; not meant for execution.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-queue.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nfunction useQueue<T>(configuration: {\n  initialValues?: T[];\n  limit: number;\n}): {\n  state: T[];\n  queue: T[];\n  add: (...items: T[]) => void;\n  update: (fn: (state: T[]) => T[]) => void;\n  cleanQueue: () => void;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Typed Form with useForm Hook in Mantine (TypeScript/React)\nDESCRIPTION: Shows how to initialize a typed form using the useForm hook from '@mantine/form' in React. The form state is managed for an interface DemoFormValues with 'name' and 'age' fields. Assigns a unique name to allow global actions, sets initial values, and configures the form for subsequent external state modifications.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nexport interface DemoFormValues {\n  name: string;\n  age: number;\n}\n\nfunction Demo() {\n  const form = useForm<DemoFormValues>({\n    name: 'demo-form',\n    initialValues: {\n      name: '',\n      age: 0,\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Mantine Form with Async Data using TanStack Query (TypeScript)\nDESCRIPTION: Illustrates initializing a Mantine form with data fetched asynchronously using TanStack Query (`useQuery`). The `form.initialize` method is called within a `useEffect` hook that depends on the query data. This ensures the form's initial values are set once the data is available, preventing multiple initializations even if the query data changes subsequently.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/get-input-props.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const query = useQuery({\n    queryKey: ['current-user'],\n    queryFn: () => fetch('/api/users/me').then((res) => res.json()),\n  });\n\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      name: '',\n      email: '',\n    },\n  });\n\n  useEffect(() => {\n    if (query.data) {\n      // Even if query.data changes, form will be initialized only once\n      form.initialize(query.data);\n    }\n  }, [query.data]);\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Form Values - Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet collection shows different ways to read and update form values using a useForm instance, supporting both bulk and per-field operations, as well as nested property access. No dependencies are required beyond the initialized useForm instance. Expected inputs are form values or update callbacks, while outputs are updated internal form state objects. These methods are subject to the initial field structure set during initialization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\n// get current form values\nform.getValues();\n\n// Set all form values\nform.setValues(values);\n\n// Set all form values using the previous state\nform.setValues((prev) => ({ ...prev, ...values }));\n\n// Set value of single field\nform.setFieldValue('path', value);\n\n// Set value of nested field\nform.setFieldValue('user.firstName', 'Jane');\n\n// Resets form values to `initialValues`,\n// clears all validation errors,\n// resets touched and dirty state\nform.reset();\n\n// Sets initial values, used when form is reset\nform.setInitialValues({ values: 'object' });\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Custom Theme in Mantine\nDESCRIPTION: This snippet demonstrates creating a custom theme object with additional properties and integrating it into a MantineProvider. The `createTheme` function defines the theme, and the `MantineProvider` component makes the theme available to all child components. The `other` property enables storage and access to application-specific values within the theme. The example includes font weights and other custom properties.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/theme-object.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  other: {\n    charcoal: '#333333',\n    primaryHeadingSize: 45,\n    fontWeights: {\n      bold: 700,\n      extraBold: 900,\n    },\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Extending Component Variant Types in TypeScript\nDESCRIPTION: Demonstrates how to extend Mantine component variant types to add custom variants through TypeScript declaration merging.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ButtonVariant, MantineSize } from '@mantine/core';\n\ntype ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';\n\ndeclare module '@mantine/core' {\n  export interface ButtonProps {\n    variant?: ExtendedButtonVariant;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Zod Resolver Example\nDESCRIPTION: Shows how to use the `zodResolver` from `@mantine-form-zod-resolver` to integrate Zod schema validation with Mantine forms. It outlines the necessary imports, schema definition, and form initialization with validation, including example output for form errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-3-0.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { zodResolver } from 'mantine-form-zod-resolver';\nimport { z } from 'zod';\nimport { useForm } from '@mantine/form';\n\nconst schema = z.object({\n  name: z\n    .string()\n    .min(2, { message: 'Name should have at least 2 letters' }),\n  email: z.string().email({ message: 'Invalid email' }),\n  age: z.number().min(18, {\n    message: 'You must be at least 18 to create an account',\n  }),\n});\n\nconst form = useForm({\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: zodResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  name: 'Name should have at least 2 letters',\n//  email: 'Invalid email',\n//  age: 'You must be at least 18 to create an account'\n// }\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Fields with Superstruct and useForm\nDESCRIPTION: This snippet shows the validation of nested fields using Superstruct with Mantine Form. It defines a Superstruct schema for nested fields and integrates it with the `useForm` hook via `superstructResolver`, demonstrating how to access validation errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { superstructResolver } from 'mantine-form-superstruct-resolver';\nimport * as s from 'superstruct';\nimport { useForm } from '@mantine/form';\n\nconst nestedSchema = s.object({\n  nested: s.object({\n    field: s.size(s.string(), 2, 30),\n  }),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    nested: {\n      field: '',\n    },\n  },\n  validate: superstructResolver(nestedSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'nested.field': 'nested field: Expected a string with a length between `2` and `30` but received one with a length of `0`',\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Render Function with MantineProvider (TSX)\nDESCRIPTION: This snippet defines a custom render function to ensure Mantine components are tested within a MantineProvider context, supplying a theme as required by Mantine components. The function wraps the provided UI element and passes it to Testing Library's render with the proper theming context. Dependencies include @testing-library/react, @mantine/core, and the theme object. Inputs are React nodes to be rendered; output is a rendered component tree with full Mantine support. It must be placed in the test-utils directory for reuse.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vitest.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\n// ./test-utils/render.tsx\nimport { render as testingLibraryRender } from '@testing-library/react';\nimport { MantineProvider } from '@mantine/core';\n// Import your theme object\nimport { theme } from '../src/theme';\n\nexport function render(ui: React.ReactNode) {\n  return testingLibraryRender(<>{ui}</>, {\n    wrapper: ({ children }: { children: React.ReactNode }) => (\n      <MantineProvider theme={theme}>{children}</MantineProvider>\n    ),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using useDisclosure Hook with onOpen and onClose Callbacks in React (TypeScript)\nDESCRIPTION: This example expands on the useDisclosure usage by including the onOpen and onClose callback options, which execute custom logic (such as logging) when the state changes. The hook is initialized with callbacks and demonstrates how open and close handlers invoke these functions on state transitions. Inputs include the initial state and optional callbacks; outputs are the state and handler object. React and Mantine Hooks are required dependencies.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-disclosure.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const [opened, handlers] = useDisclosure(false, {\n    onOpen: () => console.log('Opened'),\n    onClose: () => console.log('Closed'),\n  });\n\n  // Calls onOpen callback and sets opened to true\n  handlers.open();\n\n  // Does nothing, opened is already true\n  handlers.open();\n\n  // Calls onClose callback and sets opened to false\n  handlers.close();\n\n  // Does nothing, opened is already false\n  handlers.close();\n\n  // Calls onOpen or onClose depending on next state\n  handlers.toggle();\n}\n```\n\n----------------------------------------\n\nTITLE: Using isValid to Check Form Validation Status with Mantine useForm in TypeScript\nDESCRIPTION: Demonstrates usage of the isValid method which performs silent validation returning a boolean indicating overall or per-field validity without populating form errors. The form is initialized with initial values and inline validation rules. Depends on '@mantine/form'. Inputs include initialValues and field-specific validation functions; output is boolean validation results.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validation.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: '', age: 0 },\n  validate: {\n    name: (value) => (value.trim().length < 2 ? 'Too short' : null),\n    age: (value) => (value < 18 ? 'Too young' : null),\n  },\n});\n\n// get validation status of all values\nform.isValid(); // -> false\n\n// get validation status of field\nform.isValid('name'); // -> false\n```\n\n----------------------------------------\n\nTITLE: Initializing Mantine Theme Scale in React (TypeScript)\nDESCRIPTION: This TypeScript/React snippet shows how to use the MantineProvider and createTheme from @mantine/core to manually specify a scaling factor for rem units when the root font size differs from the browser default. This ensures Mantine components maintain consistent size ratios even when base font-size changes. Requires @mantine/core as a dependency and expects a number for the scale parameter. The provider wraps the React app and uses the computed theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rem.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  scale: 1.6,\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom CSS Variables in MantineProvider with TypeScript\nDESCRIPTION: This snippet demonstrates extending the Mantine theme and implementing a CSSVariablesResolver function to inject custom CSS variables for both light and dark color schemes. It depends on @mantine/core and expects a MantineProvider setup. The resolver enables you to define variables, such as --mantine-hero-height and --mantine-color-deep-orange, accessible throughout your React application. Inputs include the theme object and the MantineProvider receives both the theme and resolver. Outputs are available CSS variables for styling purposes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  createTheme,\n  CSSVariablesResolver,\n  MantineProvider,\n  rem,\n} from '@mantine/core';\n\nconst themeOverride = createTheme({\n  other: {\n    deepOrangeLight: '#E17900',\n    deepOrangeDark: '#FC8C0C',\n    heroHeight: rem(400),\n  },\n});\n\nconst resolver: CSSVariablesResolver = (theme) => ({\n  variables: {\n    '--mantine-hero-height': theme.other.heroHeight,\n  },\n  light: {\n    '--mantine-color-deep-orange': theme.other.deepOrangeLight,\n  },\n  dark: {\n    '--mantine-color-deep-orange': theme.other.deepOrangeDark,\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider\n      theme={themeOverride}\n      cssVariablesResolver={resolver}\n    >\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Notification Accessibility with aria-label in TypeScript\nDESCRIPTION: This snippet demonstrates how to enhance the accessibility of the Mantine Notification component by setting the `aria-label` attribute for the close button. This allows screen readers to properly announce the purpose of the close button to users with disabilities. The `closeButtonProps` prop is used to pass accessibility attributes to the close button element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/notification.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Notification } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Notification\n      closeButtonProps={{ 'aria-label': 'Hide notification' }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using CSS Variables with AppShell Components for Responsive Layouts\nDESCRIPTION: Example showing how to use AppShell's CSS variables in SCSS to create responsive layouts that adapt to the dimensions of AppShell components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_18\n\nLANGUAGE: scss\nCODE:\n```\n.main {\n  min-height: calc(100vh - var(--app-shell-header-height));\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Select Component with string\nDESCRIPTION: This example demonstrates a controlled Select component in React, where the value is managed by a state variable. The `onChange` function is used to update the state when a new option is selected. Value must be a string.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/select.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState } from 'react';\nimport { Select } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string | null>('');\n  return <Select data={[]} value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring colorSchemeManager for External Storage in MantineProvider (TypeScript)\nDESCRIPTION: Shows how to implement and pass a custom color scheme manager, such as localStorage-based, to MantineProvider to synchronize color scheme state with external storage. Useful for persisting user preferences across sessions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  localStorageColorSchemeManager,\n  MantineProvider,\n} from '@mantine/core';\n\nconst colorSchemeManager = localStorageColorSchemeManager({\n  key: 'my-app-color-scheme',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider colorSchemeManager={colorSchemeManager}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Handling List Items in Form State - Mantine (TypeScript/TSX)\nDESCRIPTION: This code block describes various operations for managing array fields within a form using useForm, including adding, removing, replacing, and reordering list items. All methods operate on field paths that point to arrays in the form state. Valid inputs include item objects and index positions as required by each method; these affect the current form state mutation and should correspond to existing field definitions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\n// Inserts given list item at the specified path\nform.insertListItem('fruits', { name: 'Apple', available: true });\n\n// An optional index may be provided to specify the position in a nested field.\n// If the index is provided, item will be inserted at the given position.\n// If the index is larger than the current list, the element is inserted at the last position.\nform.insertListItem('fruits', { name: 'Orange', available: true }, 1);\n\n// Removes the list item at the specified path and index.\nform.removeListItem('fruits', 1);\n\n// Replaces the list item at the specified path and index with the given item.\nform.replaceListItem('fruits', 1, { name: 'Apple', available: true });\n\n// Swaps two items of the list at the specified path.\n// You should make sure that there are elements at at the `from` and `to` index.\nform.reorderListItem('fruits', { from: 1, to: 0 });\n```\n\n----------------------------------------\n\nTITLE: Get color scheme with useMantineColorScheme in React component (TSX)\nDESCRIPTION: Demonstrates how to get the current color scheme value within a React component using the `useMantineColorScheme` hook from `@mantine/core`. The returned `colorScheme` value can be `'dark'`, `'light'`, or `'auto'`. This hook utilizes localStorage and is not suitable for server-side rendering (SSR).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-get-color-scheme-value-in-js.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMantineColorScheme } from '@mantine/core';\n\nfunction Demo() {\n  // colorScheme is `'dark' | 'light' | 'auto'`\n  const { colorScheme } = useMantineColorScheme();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic AppShell Layout in React (TSX)\nDESCRIPTION: Demonstrates a basic usage of the Mantine `AppShell` component to create a layout with a fixed Header and a collapsible Navbar. It utilizes the `useDisclosure` hook to manage the Navbar's visibility on mobile viewports, toggled by a `Burger` component within the `AppShell.Header`. Dependencies include `@mantine/core` for `AppShell` and `Burger`, and `@mantine/hooks` for `useDisclosure`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell, Burger } from '@mantine/core';\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const [opened, { toggle }] = useDisclosure();\n\n  return (\n    <AppShell\n      header={{ height: 60 }}\n      navbar={{\n        width: 300,\n        breakpoint: 'sm',\n        collapsed: { mobile: !opened },\n      }}\n      padding=\"md\"\n    >\n      <AppShell.Header>\n        <Burger\n          opened={opened}\n          onClick={toggle}\n          hiddenFrom=\"sm\"\n          size=\"sm\"\n        />\n        <div>Logo</div>\n      </AppShell.Header>\n\n      <AppShell.Navbar p=\"md\">Navbar</AppShell.Navbar>\n\n      <AppShell.Main>Main</AppShell.Main>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Proper hook usage in a client component with 'use client' directive\nDESCRIPTION: This code demonstrates correct React hook usage in a Mantine component by adding `'use client'` at the top, which enables the usage of hooks like `useRef` without errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ No error\n'use client';\n\nimport { useRef } from 'react';\n\nfunction Demo() {\n  const ref = useRef();\n}\n```\n\n----------------------------------------\n\nTITLE: Ensuring Accessibility for Mantine Switch Component in TSX\nDESCRIPTION: Provides guidance and examples on making the Mantine `Switch` component accessible, emphasizing the need for proper labeling as it renders a standard `input[type=\"checkbox\"]`. It shows incorrect usage (without any label or `aria-label`) and correct usage (using `aria-label` or the `label` prop) to ensure assistive technologies can interpret the switch's purpose. Requires `react` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/switch.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Switch } from '@mantine/core';\n\n// -> not ok, input is not labeled\nfunction Bad() {\n  return <Switch />;\n}\n\n// -> ok, input has aria-label\nfunction Good() {\n  return <Switch aria-label=\"I agree to everything\" />;\n}\n\n// -> ok, input has associated label\nfunction AlsoGood() {\n  return <Switch label=\"I agree to everything\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Checkbox.Group Example (React)\nDESCRIPTION: This example showcases a controlled Checkbox.Group component using the `useState` hook to manage an array of string values representing the selected checkboxes.  The `onChange` event updates the selected values, enabling external control of the group's state.  It imports `useState` from `react` and `Checkbox` from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/checkbox.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Checkbox } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string[]>([]);\n\n  return (\n    <Checkbox.Group value={value} onChange={setValue}>\n      <Checkbox value=\"react\" label=\"React\" />\n      <Checkbox value=\"svelte\" label=\"Svelte\" />\n    </Checkbox.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating a Custom Input Component with form.getInputProps (TypeScript)\nDESCRIPTION: Shows how to use a custom input component (`CustomInput`) within a Mantine form by spreading the props returned from `form.getInputProps('fieldName')`. This binds the custom component to the form's state management, including value updates, validation errors, and touched status, provided the custom component correctly handles the standard props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/get-input-props.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\nimport { CustomInput } from './CustomInput';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { name: '' },\n  });\n\n  return (\n    <CustomInput\n      {...form.getInputProps('name')}\n      key={form.key('name')}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostCSS for Mantine (JavaScript/CJS)\nDESCRIPTION: Creates a `postcss.config.cjs` file to configure PostCSS. It includes the `postcss-preset-mantine` plugin for essential Mantine styles transformations and `postcss-simple-vars` to define variables for Mantine's default breakpoints.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/react-router.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Non-Empty HTML Content with Mantine isNotEmptyHTML Validator in TypeScript\nDESCRIPTION: This snippet uses the isNotEmptyHTML validator to verify that the form value contains non-empty HTML content. Values considered empty include empty strings, strings containing only HTML tags without content, and strings with only whitespace. The example sets up a form with an empty html field and applies validation using useForm in uncontrolled mode. Error messages are customizable.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isNotEmptyHTML, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    html: '',\n  },\n\n  validate: {\n    html: isNotEmptyHTML('HTML cannot be empty'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Mantine Responsive Utility Classes in React/TypeScript\nDESCRIPTION: Demonstrates the usage of built-in Mantine CSS classes (`mantine-hidden-from-{x}`, `mantine-visible-from-{x}`) to control element visibility based on viewport size and predefined breakpoints within a React component. This provides responsive control directly on custom HTML elements without relying on Mantine component props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/responsive.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nfunction CustomComponent() {\n  return (\n    <>\n      <div className=\"mantine-hidden-from-md\">Hidden from md</div>\n      <div className=\"mantine-visible-from-xl\">Visible from xl</div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Function to List Items with useListState\nDESCRIPTION: The `apply` handler applies a function to each element of the list. The function takes the item and its index as arguments. The example demonstrates multiplying the `a` property of each item by its index.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// apply function to each element of the list\nconst apply = () =>\n  handlers.apply((item, index) => ({ a: item.a * index }));\n// values -> [{ a: 0 }, { a: 5 }, { a: 4 }]\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled FileInput (single file) in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the FileInput component in a controlled manner when only a single file is allowed. It utilizes the useState hook to manage the selected file. The component takes the 'value' and 'onChange' props to manage the selected file state. The `value` prop holds the currently selected file, and `onChange` is called when the selection changes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/file-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useState } from 'react';\nimport { FileInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<File | null>(null);\n  return <FileInput value={value} onChange={setValue} />;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled TextInput Component using Mantine in TypeScript\nDESCRIPTION: This TypeScript React snippet demonstrates a controlled TextInput component from the Mantine library. It uses the React useState hook to maintain the current input value and updates it on each change event. The snippet requires 'react' for state management and '@mantine/core' for the TextInput component. The input's value is explicitly controlled by the component's local state, ensuring synchronization between the UI and internal state. Inputs are user keystrokes, and outputs are reactive value updates passed as props to the TextInput. This pattern allows custom control over the input's behavior and is essential for validation or related side effects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/text-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  return (\n    <TextInput\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring 100% Height Carousel - Mantine Carousel - TSX\nDESCRIPTION: Defines a React component that renders a Carousel with 100% height inside a container of fixed height (400px). The parent div uses display: flex and the Carousel is made to fill available space using flex: 1. The example shows usage of withIndicators and demonstrates correct structure for slides. This approach requires both container and Carousel root to have appropriate flex and height styles set for correct layout, and works only when container height is fixed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/carousel.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Carousel } from '@mantine/carousel';\n\nexport function PercentageHeight() {\n  return (\n    <div style={{ height: 400, display: 'flex' }}>\n      <Carousel withIndicators height=\"100%\" style={{ flex: 1 }}>\n        <Carousel.Slide>1</Carousel.Slide>\n        <Carousel.Slide>2</Carousel.Slide>\n        <Carousel.Slide>3</Carousel.Slide>\n      </Carousel>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled ColorInput Component in React with TypeScript\nDESCRIPTION: This snippet shows how to implement a controlled ColorInput component using React and TypeScript. It demonstrates the use of React's useState hook to manage the color value state and updates the component's value via the onChange callback. The snippet requires @mantine/core library for the ColorInput component and React for state management. The user inputs a color, which updates the local state and the ColorInput's displayed value accordingly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/color-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { ColorInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  return <ColorInput value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Values with useForm in Mantine\nDESCRIPTION: Demonstrates how to set initial values when creating a form with the useForm hook. Initial values define the starting state of the form before user interaction.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    name: '',\n    email: '',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Mantine Breakpoint Variables in PostCSS\nDESCRIPTION: Shows how to configure `postcss-simple-vars` in `postcss.config.cjs` to make static, Mantine-like breakpoint variables available in CSS modules. It defines variables prefixed with `mantine-breakpoint-` that map to specific CSS breakpoint values, allowing consistent breakpoint usage between JavaScript/TypeScript and CSS.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/responsive.mdx#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: TagsInput Component for Multi-Value Entry\nDESCRIPTION: Built atop Combobox, it allows users to enter multiple tags, including custom values, supporting rich input scenarios with greater flexibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_27\n\n\n\n----------------------------------------\n\nTITLE: Using form.getValues to Access Current Form Values in Mantine\nDESCRIPTION: Example demonstrating how to use form.getValues() to access current form values in both controlled and uncontrolled modes, showing why it's preferred over form.values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/uncontrolled.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n});\n\nform.getValues(); // { name: 'John Doe' }\n\nform.setValues({ name: 'John Smith' });\nform.getValues(); // { name: 'John Smith' }\n```\n\n----------------------------------------\n\nTITLE: Using useIntersection hook within a React component\nDESCRIPTION: Demonstrates practical application of the useIntersection hook within a React functional component, showing how to obtain the ref callback for observed elements and render them. It includes examples with a div and a Mantine Paper component, capturing intersection entries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-intersection.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction Demo() {\n  const { ref } = useIntersection();\n\n  return (\n    <>\n      {/* With regular element: */}\n      <div ref={ref} />\n\n      {/* With Mantine component: */}\n      <Paper ref={ref} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Controlled Autocomplete Component in React with Mantine\nDESCRIPTION: This code snippet demonstrates how to implement a controlled Autocomplete component using React's useState hook. It manages the input value and updates it via the onChange handler, ensuring the component's state reflects user input.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/autocomplete.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { Autocomplete } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  return <Autocomplete data={[]} value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Theme Spacing and Colors in Style Props (TypeScript TSX)\nDESCRIPTION: Illustrates using Mantine's Box component with style props that reference theme values for spacing (such as 'mt' for margin-top) and colors (props like 'c', 'bd', 'bg'). This snippet shows how to use both string values (e.g. 'xs', '-md', 'auto', '5rem') and number values for spacing, as well as referencing color tokens from the theme or raw color strings. Requires @mantine/core and Mantine theme context. Inputs include any valid string, token, or color value, and outputs the corresponding CSS on the root element. Some values depend on the current theme's color scheme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style-props.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      {/* margin-top: theme.spacing.xs */}\n      <Box mt=\"xs\" />\n\n      {/* margin-top: theme.spacing.md * -1 */}\n      <Box mt=\"-md\" />\n\n      {/* margin-top: auto */}\n      <Box mt=\"auto\" />\n\n      {/* margin-top: 1rem */}\n      <Box mt={16} />\n\n      {/* margin-top: 5rem */}\n      <Box mt=\"5rem\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using React Router Link with Mantine Button (TSX)\nDESCRIPTION: Shows how to use the `component` prop of a Mantine `Button` to render it as a `Link` component from `react-router-dom`. This integrates Mantine components with React Router's navigation capabilities.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link } from 'react-router-dom';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button component={Link} to=\"/react-router\">\n      React router link\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Core CSS styles in React\nDESCRIPTION: Shows how to import native CSS files from Mantine packages after the migration from Emotion. This is required to apply Mantine styles in your application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Implementing a Controlled Chip Component in React with Mantine\nDESCRIPTION: This snippet demonstrates how to create a controlled Chip component in React using Mantine. It maintains a boolean state variable that controls whether the chip is checked, and toggles this state when the chip is clicked.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/chip.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Chip } from '@mantine/core';\n\nfunction Demo() {\n  const [checked, setChecked] = useState(false);\n\n  return (\n    <Chip checked={checked} onChange={() => setChecked((v) => !v)}>\n      My chip\n    </Chip>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating theme.colorScheme to CSS Modules\nDESCRIPTION: Shows how to migrate from theme.colorScheme in 6.x to light-dark function or mixins in 7.x CSS.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { createStyles } from '@mantine/core';\n\nconst useStyles = createStyles((theme) => ({\n  root: {\n    backgroundColor:\n      theme.colorScheme === 'dark'\n        ? theme.colors.dark[6]\n        : theme.colors.gray[0],\n    color: theme.colorScheme === 'dark' ? theme.white : theme.black,\n  },\n}));\n```\n\nLANGUAGE: scss\nCODE:\n```\n/* 7.0 */\n\n/* With light-dark function */\n.root {\n  background-color: light-dark(\n    var(--mantine-color-gray-0),\n    var(--mantine-color-dark-6)\n  );\n  color: light-dark(\n    var(--mantine-color-black),\n    var(--mantine-color-white)\n  );\n}\n\n/* With light/dark mixins */\n.root {\n  background-color: var(--mantine-color-gray-0);\n  color: var(--mantine-color-black);\n\n  @mixin dark {\n    background-color: var(--mantine-color-dark-6);\n    color: var(--mantine-color-white);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the useDebouncedValue Hook in React with TypeScript\nDESCRIPTION: This snippet defines the TypeScript function signature for the useDebouncedValue hook, which is intended for React applications requiring debounced value updates. It takes a value of any type T, a wait duration in milliseconds, and an optional options object supporting a boolean leading property. The hook returns a readonly tuple with the debounced value and a cancel function. Proper usage requires React, knowledge of hooks, and optionally TypeScript support for strong typing. The leading option enables immediate updates, while the cancel callback allows aborting pending debounced updates.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-debounced-value.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useDebouncedValue<T = any>(\n  value: T,\n  wait: number,\n  options?: {\n    leading: boolean;\n  }\n): readonly [T, () => void];\n```\n\n----------------------------------------\n\nTITLE: Style object with CSS variables in Mantine\nDESCRIPTION: Shows how to use a style object with Mantine CSS variables to style a Mantine Box component. Requires the `@mantine/core` package.  Defines inline styles using CSS variables for color and font size.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Box, rem } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      style={{\n        color: 'var(--mantine-color-red-5)',\n        fontSize: rem(12),\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating accessible Tooltips with keyboard focus support\nDESCRIPTION: Shows how to make tooltips accessible to screen readers and keyboard users by enabling focus events, following WAI-ARIA recommendations for proper semantic structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tooltip.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Tooltip } from '@mantine/core';\n\n// Tooltip will be visible for screen readers\nfunction Demo() {\n  return (\n    <Tooltip\n      label=\"Tooltip\"\n      events={{ hover: true, focus: true, touch: false }}\n    >\n      <Button>Button with tooltip</Button>\n    </Tooltip>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Form Context from a Separate File - Main Form Component\nDESCRIPTION: Example of implementing the main form component that initializes the form with useUserForm and provides the form context to child components with UserFormProvider.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/create-form-context.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// UserForm.tsx\nimport { NumberInput } from '@mantine/core';\nimport { UserFormProvider, useUserForm } from './form-context';\nimport { NameInput } from './NameInput';\n\nfunction UserForm() {\n  const form = useUserForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      age: 0,\n      name: '',\n    },\n  });\n\n  return (\n    <UserFormProvider form={form}>\n      <form onSubmit={form.onSubmit(() => {})}>\n        <NumberInput\n          label=\"Age\"\n          key={form.key('age')}\n          {...form.getInputProps('age')}\n        />\n        <NameInput />\n      </form>\n    </UserFormProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing onSubmit Prevent Default Behavior - Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates configuring the onSubmitPreventDefault parameter of useForm to alter whether form submissions automatically call event.preventDefault(). You can specify 'always' (default), 'never', or 'validation-failed' as the value depending on desired stopping of native form submission. Prerequisite is initialization of useForm with the desired mode and option.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_6\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  onSubmitPreventDefault: 'never',\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Form Submission State with use-form Hook\nDESCRIPTION: This snippet demonstrates tracking and manually controlling the submission state of a form using the 'useForm' hook's 'submitting' field and 'setSubmitting' method. It handles asynchronous submission and updates UI based on submission status.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({ mode: 'uncontrolled' });\nform.submitting; // -> false\n\nform.setSubmitting(true);\nform.submitting; // -> true\n\nform.setSubmitting(false);\nform.submitting; // -> false\n```\n\n----------------------------------------\n\nTITLE: Configure Portal reuseTargetNode in Mantine Theme (TSX)\nDESCRIPTION: This code snippet demonstrates how to configure the `reuseTargetNode` prop globally for the Portal component within a Mantine theme. Setting `reuseTargetNode` to `true` improves performance by reusing the same target node for all Portal instances. This configuration ensures that all Portal components in the application utilize the same target node, optimizing rendering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-17-0.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, Portal } from '@mantine/core';\n\nexport const theme = createTheme({\n  components: {\n    Portal: Portal.extend({\n      defaultProps: {\n        reuseTargetNode: true,\n      },\n    }),\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Validation with use-field Hook in React\nDESCRIPTION: Demonstrates how to use the use-field hook with asynchronous validation, including showing a loading indicator during validation and triggering validation on button click.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.9.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Loader, TextInput } from '@mantine/core';\nimport { useField } from '@mantine/form';\n\nfunction validateAsync(value: string): Promise<string | null> {\n  return new Promise((resolve) => {\n    window.setTimeout(() => {\n      resolve(value === 'mantine' ? null : 'Value must be \"mantine\"');\n    }, 800);\n  });\n}\n\nfunction Demo() {\n  const field = useField({\n    initialValue: '',\n    validate: validateAsync,\n  });\n\n  return (\n    <>\n      <TextInput\n        {...field.getInputProps()}\n        label=\"Enter 'mantine'\"\n        placeholder=\"Enter 'mantine'\"\n        rightSection={field.isValidating ? <Loader size={18} /> : null}\n        mb=\"md\"\n      />\n      <Button onClick={field.validate}>Validate async</Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Virtual Primary Color in Mantine (TSX)\nDESCRIPTION: This snippet demonstrates how to define a virtual color named 'primary' using `virtualColor` from `@mantine/core`. It sets 'pink' as the color for the dark scheme and 'cyan' for the light scheme within the `createTheme` function. The `MantineProvider` applies this theme, and a `Box` component utilizes the 'primary' virtual color for its background, which automatically adapts based on the current light or dark color scheme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/primary-virtual-color.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createTheme,\n  MantineProvider,\n  virtualColor,\n  Box, // Added Box import for completeness\n} from '@mantine/core';\n\nconst theme = createTheme({\n  primaryColor: 'primary',\n\n  colors: {\n    primary: virtualColor({\n      name: 'primary',\n      dark: 'pink',\n      light: 'cyan',\n    }),\n  },\n});\n\nfunction App() {\n  return (\n    <MantineProvider theme={theme}>\n      <Box bg=\"primary\" c=\"white\" p=\"md\" fw={700}>\n        This box has virtual background color, it is pink in dark mode\n        and cyan in light mode\n      </Box>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Props for Mantine Compound Components (tsx)\nDESCRIPTION: This example shows how to set default props for Mantine's compound components (e.g., Menu.Item, Tabs.List) within the createTheme object. It targets the components by their combined name (e.g., MenuItem, TabsList) without the dot notation and applies the theme globally using MantineProvider, causing instances of these components to inherit the defined defaults. Requires react and @mantine/core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/default-props.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createTheme,\n  MantineProvider,\n  Menu,\n  Tabs,\n} from '@mantine/core';\n\nconst theme = createTheme({\n  components: {\n    MenuItem: Menu.Item.extend({\n      defaultProps: { color: 'red' },\n    }),\n\n    TabsList: Tabs.List.extend({\n      defaultProps: {\n        justify: 'center',\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adapting Bar Color to Light and Dark Color Schemes Using CSS Variables in BarChart, JSX/TypeScript\nDESCRIPTION: Illustrates using CSS variables and Mantine dark/light mixins to specify bar colors that change depending on color scheme (e.g., dark orange in light mode, lime in dark mode). Relies on BarChartDemos.colorSchemeColor example.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_18\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.colorSchemeColor} />\n```\n\n----------------------------------------\n\nTITLE: Accessing Stepper Component Refs in React\nDESCRIPTION: Demonstrates how to get references to the stepper root element and individual step buttons using React refs. This allows direct DOM manipulation or access to the underlying elements when needed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/stepper.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useRef } from 'react';\nimport { Stepper } from '@mantine/core';\n\nfunction MyStepper() {\n  const firstStep = useRef<HTMLButtonElement>(null);\n  const stepper = useRef<HTMLDivElement>(null);\n\n  return (\n    <Stepper ref={stepper} active={0}>\n      <Stepper.Step label=\"First step\" ref={firstStep} />\n      <Stepper.Step label=\"Second step\" />\n    </Stepper>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing form.values and form.getValues in Uncontrolled Mantine Form\nDESCRIPTION: Highlights the difference between accessing `form.values` and calling `form.getValues()` when using `useForm` in `uncontrolled` mode, particularly after a value update. It shows that `form.values` becomes stale, while `form.getValues()` correctly reflects the immediate change made by `setFieldValue`, emphasizing its use for current values in uncontrolled scenarios.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-8-0.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n});\n\nconst handleNameChange = () => {\n  form.setFieldValue('name', 'Test Name');\n\n  // ❌ Do not use form.values to get the current form values\n  // form.values has stale name value until next rerender in controlled mode\n  // and is always outdated in uncontrolled mode\n  console.log(form.values); // { name: 'John Doe' }\n\n  // ✅ Use form.getValues to get the current form values\n  // form.getValues always returns the latest form values\n  console.log(form.getValues()); // { name: 'Test Name' }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled Rating Component - React (TypeScript)\nDESCRIPTION: This snippet demonstrates a controlled rating component using the useState hook. It imports the Rating component from '@mantine/core' and allows the user to change the rating. The value and onChange props are utilized to achieve this functionality. The expected input is an integer representing the rating value, and the output is a visual representation of the rating stars.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/rating.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Rating } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState(0);\n  return <Rating value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Non-Empty Values with Mantine Form Validator in TypeScript\nDESCRIPTION: This snippet demonstrates the isNotEmpty validation function from the @mantine/form package. It validates that form values are not empty according to Mantine's definition (empty string, empty array, false, null, or undefined). Validation errors contain custom error messages. The form is created using useForm hook with uncontrolled mode and initial values of different types to illustrate validation rules applied to multiple fields.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isNotEmpty, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    name: '',\n    acceptTermsOfUse: false,\n    country: null,\n    previousJobs: [],\n  },\n\n  validate: {\n    // Empty strings are considered to be invalid\n    name: isNotEmpty('Name cannot be empty'),\n\n    // False value is considered to be invalid\n    acceptTermsOfUse: isNotEmpty('You must accept terms of use'),\n\n    // null is considered to be invalid\n    country: isNotEmpty('Pick your country'),\n\n    // Empty arrays are considered to be invalid\n    previousJobs: isNotEmpty('Enter at least one job'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using sx Prop with Function\nDESCRIPTION: This React component demonstrates how to use the `sx` prop with a function to conditionally style components based on the theme. It provides light and dark mode styling for a `Button` component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Box, Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Box\n        sx={{\n          padding: 40,\n          '&:hover': { padding: 80 },\n        }}\n      >\n        Box with object sx\n      </Box>\n\n      <Button\n        sx={(theme, u) => ({\n          padding: 10,\n\n          [u.light]: {\n            backgroundColor: theme.colors.blue[0],\n            color: theme.colors.blue[9],\n            '&:hover': {\n              backgroundColor: theme.colors.blue[1],\n            },\n          },\n\n          [u.dark]: {\n            backgroundColor: theme.colors.blue[9],\n            color: theme.colors.blue[0],\n            '&:hover': {\n              backgroundColor: theme.colors.blue[8],\n            },\n          },\n        })}\n      >\n        Button with function sx\n      </Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Pagination Example with React and Mantine\nDESCRIPTION: Demonstrates how to create a controlled Pagination component in React using Mantine. It utilizes the `useState` hook to manage the active page and the `onChange` prop to update the state when the user interacts with the pagination controls. The `total` prop specifies the total number of pages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pagination.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Pagination } from '@mantine/core';\n\nfunction Demo() {\n  const [activePage, setPage] = useState(1);\n  return (\n    <Pagination value={activePage} onChange={setPage} total={10} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Theme Colors and Custom Colors in Style Props (TypeScript TSX)\nDESCRIPTION: Demonstrates Mantine Box components using color-related style props ('c' for color, 'bd' for border, 'bg' for background) with both theme tokens and direct color values. The example includes scenarios where the applied color depends on the current color scheme (light/dark), as indicated by special tokens like 'dimmed' or 'bright', as well as hardcoded CSS colors. Requires @mantine/core and Mantine theme setup. Props accept theme color tokens, CSS color strings, or functional tokens that resolve based on the active color scheme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style-props.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      {/* color: theme.colors.blue[theme.primaryShade] */}\n      <Box c=\"blue\" />\n\n      {/* background: theme.colors.orange[1] */}\n      <Box bg=\"orange.1\" />\n\n      {/* border: 1px solid theme.colors.red[6] */}\n      <Box bd=\"1px solid red.6\" />\n\n      {/* color: if colorScheme is dark `var(--mantine-color-dark-2)`,\n      if color scheme is light `var(--mantine-color-gray-6)` */}\n      <Box c=\"dimmed\" />\n\n      {/* color: if colorScheme is dark `var(--mantine-color-white)`,\n      if color scheme is light `var(--mantine-color-black)` */}\n      <Box c=\"bright\" />\n\n      {/* background: #EDFEFF */}\n      <Box bg=\"#EDFEFF\" />\n\n      {/* background: rgba(0, 34, 45, 0.6) */}\n      <Box bg=\"rgba(0, 34, 45, 0.6)\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Email Format with Mantine Form isEmail Validator in TypeScript\nDESCRIPTION: This code snippet uses the isEmail validator function to check if the form value is a valid email address. The validation relies on a regexp pattern defined internally by Mantine. The form is configured with the useForm hook in uncontrolled mode, and an initial value for the email field is set as an empty string. The validator returns an error string if validation fails.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isEmail, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    email: '',\n  },\n\n  validate: {\n    email: isEmail('Invalid email'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Corrected usage of hooks with 'use client' directive in TypeScript\nDESCRIPTION: This code snippet shows how to properly use the `useDisclosure` hook in a Mantine component by adding the `'use client'` directive at the top, allowing hook usage in client components without errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ No error\n'use client';\n\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const { opened, toggle } = useDisclosure();\n  return (\n    <button onClick={toggle}>{opened ? 'Opened' : 'Closed'}</button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reinitializing useScrollSpy Hook\nDESCRIPTION: This code demonstrates how to use the `reinitialize` function of the `useScrollSpy` hook. It uses the `useEffect` hook to reinitialize the hook's data when the `dependency` prop changes. This allows for updating the headings data after the parent component has mounted. It requires the `@mantine/hooks` library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-scroll-spy.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useScrollSpy } from '@mantine/hooks';\n\nfunction Demo({ dependency }) {\n  const { reinitialize } = useScrollSpy();\n\n  useEffect(() => {\n    reinitialize();\n  }, [dependency]);\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing useEffect and useShallowEffect Dependency Comparison in React\nDESCRIPTION: Demonstrates the difference between standard React `useEffect` and Mantine's `useShallowEffect` when using object dependencies. `useEffect` uses referential equality, potentially causing re-renders when the object reference changes, while `useShallowEffect` uses shallow equality, preventing re-renders if the object content is shallowly the same.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-shallow-effect.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useShallowEffect } from '@mantine/hooks';\n\n// Will be called on each render\nuseEffect(() => {}, [{ a: 1 }]);\n\n// Will be called only once\nuseShallowEffect(() => {}, [{ a: 1 }]);\n```\n\n----------------------------------------\n\nTITLE: Add ColorSchemeScript for SSR - TypeScript/TSX\nDESCRIPTION: This snippet illustrates adding the `ColorSchemeScript` component to the `<head />` of your HTML document in server-side rendered (SSR) applications. This script helps prevent initial style flashes by correctly initializing the color scheme on the server before the client-side JavaScript loads.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/getting-started.mdx#_snippet_3\n\nLANGUAGE: TypeScript/TSX\nCODE:\n```\nimport { ColorSchemeScript } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charSet=\"UTF-8\" />\n        <meta\n          name=\"viewport\"\n          content=\"width=device-width, initial-scale=1.0\"\n        />\n        <title>My awesome app</title>\n\n        <ColorSchemeScript />\n      </head>\n      <body>{/* Your app here */}</body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Dropdown Opened State in Mantine Select Using React Testing Library (TypeScript/TSX)\nDESCRIPTION: This example verifies the open/closed visual state of a Mantine Select dropdown by asserting presence and visibility of elements with role 'listbox'. The test consists of checking that the dropdown is initially closed, then opening it via userEvent.click, and finally asserting the dropdown is visible. Prerequisites include Mantine's Select, React Testing Library (with render, userEvent, screen), and a test runner like Jest or Vitest. The item's label is used to get the correct element by role. This pattern ensures that input focus and accessibility behaviors are functioning as intended.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/combobox-testing.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Select } from '@mantine/core';\n\nfunction MyForm() {\n  return (\n    <Select\n      name=\"age\"\n      label=\"Select your age\"\n      data=[\n        { value: 'ok', label: 'I am 18 or older' },\n        { value: 'not-ok', label: 'I am under 18' },\n      ]\n    />\n  );\n}\n\nit('verifies dropdown opened state', () => {\n  render(<MyForm />);\n\n  // Verify that dropdown is closed\n  // Listbox has the same name as the textbox\n  expect(screen.queryByRole('listbox', { name: 'Select your age' })).toBeNull();\n\n  // Click Select to open the options list\n  await userEvent.click(screen.getByRole('textbox', { name: 'Select your age' }));\n\n  // Verify that dropdown is open\n  expect(screen.getByRole('listbox', { name: 'Select your age' })).toBeVisible();\n});\n```\n\n----------------------------------------\n\nTITLE: Reading Storage Values Directly in React\nDESCRIPTION: Shows how to read values from localStorage or sessionStorage without using hooks, using the readLocalStorageValue function, which is useful for scenarios outside of React components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { readLocalStorageValue } from '@mantine/hooks';\n\nconst value = readLocalStorageValue({ key: 'color-scheme' });\n```\n\n----------------------------------------\n\nTITLE: Defining Table Data for Mantine Table in TypeScript/React\nDESCRIPTION: This snippet defines an array of element objects to provide tabular data for examples using Mantine's Table component. Each object contains the properties 'position', 'mass', 'symbol', and 'name'. The array is expected to be typed or used directly in Table demos, serving as standardized example data. No external dependencies are required beyond basic TypeScript support, and it is designed to be used as a constant source for various Table props or renderings. Input is implicit in the data definition and output is consumption by table components; there are no special constraints except TypeScript type compatibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/table.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nconst elements = [\n  { position: 6, mass: 12.011, symbol: 'C', name: 'Carbon' },\n  { position: 7, mass: 14.007, symbol: 'N', name: 'Nitrogen' },\n  { position: 39, mass: 88.906, symbol: 'Y', name: 'Yttrium' },\n  { position: 56, mass: 137.33, symbol: 'Ba', name: 'Barium' },\n  { position: 58, mass: 140.12, symbol: 'Ce', name: 'Cerium' },\n];\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useLocalStorage Hook in React\nDESCRIPTION: Demonstrates the basic usage of the useLocalStorage hook to store and retrieve a color scheme preference. The hook reads the initial value from localStorage or falls back to the provided default value, and automatically syncs state changes with localStorage.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useLocalStorage } from '@mantine/hooks';\n\n// The hook will read value from localStorage.getItem('color-scheme')\n// If localStorage is not available or value at a given key does not exist\n// 'dark' will be assigned to value variable\nconst [value, setValue] = useLocalStorage({\n  key: 'color-scheme',\n  defaultValue: 'dark',\n});\n\n// Value is set both to state and localStorage at 'color-scheme'\nsetValue('light');\n\n// You can also use callback like in useState hook to set value\nsetValue((current) => (current === 'dark' ? 'light' : 'dark'));\n```\n\n----------------------------------------\n\nTITLE: Initializing BarChart component with @mantine/charts in TypeScript\nDESCRIPTION: Provides an example of rendering a vertical stacked BarChart using the @mantine/charts package in a TypeScript React component. The snippet specifies chart height, data source keyed by 'month', orientation, y-axis properties including width, and series detailing categories with colors. This snippet requires client-side support for React and TypeScript and expects the data to have 'month' keys and corresponding numeric values for each series category.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={data}\n      dataKey=\"month\"\n      type=\"stacked\"\n      orientation=\"vertical\"\n      yAxisProps={{ width: 80 }}\n      series=[\n        { name: 'Smartphones', color: 'violet.6' },\n        { name: 'Laptops', color: 'blue.6' },\n        { name: 'Tablets', color: 'teal.6' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Employee List with Mantine use-form in React\nDESCRIPTION: This example demonstrates how to implement a dynamic list of employee objects using Mantine's use-form hook. The component allows adding, removing, and editing employee information with name and active status fields.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/list-of-strings-in-use-form.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IconTrash } from '@tabler/icons-react';\nimport {\n  ActionIcon,\n  Box,\n  Button,\n  Group,\n  Switch,\n  Text,\n  TextInput,\n} from '@mantine/core';\nimport { useForm } from '@mantine/form';\nimport { randomId } from '@mantine/hooks';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      employees: [{ name: '', active: false, key: randomId() }],\n    },\n  });\n\n  const fields = form.getValues().employees.map((item, index) => (\n    <Group key={item.key} mt=\"xs\">\n      <TextInput\n        placeholder=\"John Doe\"\n        withAsterisk\n        style={{ flex: 1 }}\n        key={form.key(`employees.${index}.name`)}\n        {...form.getInputProps(`employees.${index}.name`)}\n      />\n      <Switch\n        label=\"Active\"\n        key={form.key(`employees.${index}.active`)}\n        {...form.getInputProps(`employees.${index}.active`, {\n          type: 'checkbox',\n        })}\n      />\n      <ActionIcon\n        color=\"red\"\n        onClick={() => form.removeListItem('employees', index)}\n      >\n        <IconTrash size=\"1rem\" />\n      </ActionIcon>\n    </Group>\n  ));\n\n  return (\n    <Box maw={500} mx=\"auto\">\n      {fields.length > 0 ? (\n        <Group mb=\"xs\">\n          <Text fw={500} size=\"sm\" style={{ flex: 1 }}>\n            Name\n          </Text>\n          <Text fw={500} size=\"sm\" pr={90}>\n            Status\n          </Text>\n        </Group>\n      ) : (\n        <Text c=\"dimmed\" ta=\"center\">\n          No one here...\n        </Text>\n      )}\n\n      {fields}\n\n      <Group justify=\"center\" mt=\"md\">\n        <Button\n          onClick={() =>\n            form.insertListItem('employees', {\n              name: '',\n              active: false,\n              key: randomId(),\n            })\n          }\n        >\n          Add employee\n        </Button>\n      </Group>\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Clear Button to Inputs with Input.ClearButton in TypeScript React\nDESCRIPTION: Illustrates how to enhance a Mantine Input component with the new Input.ClearButton to provide a clear (reset) button inside the input field. The clear button size automatically inherits from the input size. The example maintains local state for the input value and conditionally renders the clear button only when the value is non-empty. Requires React and @mantine/core package. Provides cleaner UX for clearing inputs easily.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Input } from '@mantine/core';\nimport { useState } from 'react';\n\nfunction Demo() {\n  const [value, setValue] = useState('clearable');\n\n  return (\n    <Input\n      placeholder=\"Clearable input\"\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n      rightSection={value !== '' ? <Input.ClearButton onClick={() => setValue('')} /> : undefined}\n      rightSectionPointerEvents=\"auto\"\n      size=\"sm\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: useId with Input and Input.Wrapper\nDESCRIPTION: Demonstrates how to use the `useId` hook from `@mantine/hooks` to generate unique IDs for the `Input` and `Input.Wrapper` components. This ensures proper accessibility by connecting the label and input elements correctly.  Requires `@mantine/core` and `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/input.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Input } from '@mantine/core';\nimport { useId } from '@mantine/hooks';\n\nfunction Demo() {\n  const id = useId();\n  return (\n    <Input.Wrapper label=\"Your email\" id={id}>\n      <Input id={id} />\n    </Input.Wrapper>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Controlled Mantine NativeSelect (TSX)\nDESCRIPTION: This snippet shows how to control the value of a Mantine NativeSelect component using React's useState hook. It binds the component's value prop to the state variable and updates the state using the onChange handler.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/native-select.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { NativeSelect } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n\n  return (\n    <NativeSelect\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n      data={['React', 'Angular', 'Svelte', 'Vue']}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying classNames and Styles Props to Mantine Components (TypeScript)\nDESCRIPTION: This snippet demonstrates how to customize the visual appearance of Mantine's Button component using the classNames and styles props. It shows how to target inner elements via selectors, passing an object that maps element names to CSS class names or inline style objects. Dependencies: @mantine/core. Expects valid class name strings or style objects for respective selectors; these approaches enable highly specific custom styling for each sub-element of the component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-api.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button, createTheme, MantineProvider } from '@mantine/core';\n\nfunction ClassNamesDemo() {\n  return (\n    <Button\n      classNames={{\n        root: 'my-root-class',\n        label: 'my-label-class',\n        inner: 'my-inner-class',\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n\nfunction StylesDemo() {\n  return (\n    <Button\n      styles={{\n        root: { backgroundColor: 'red' },\n        label: { color: 'blue' },\n        inner: { fontSize: 20 },\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using useMouse Hook with resetOnExit - Mantine React\nDESCRIPTION: This code snippet demonstrates how to use the `useMouse` hook with the `resetOnExit` option. It imports the `useMouse` hook from `@mantine/hooks` and then initializes it with the `resetOnExit` option set to `true`. This will reset the mouse position to `0, 0` when the mouse leaves the element. The `ref`, `x`, and `y` are then destructured for usage. The target element will be whatever element you pass the `ref` to. Dependencies include `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mouse.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMouse } from '@mantine/hooks';\n\nconst { ref, x, y } = useMouse({ resetOnExit: true });\n```\n\n----------------------------------------\n\nTITLE: Rendering Custom Value Formatter Function Demo for DatePickerInput in JSX\nDESCRIPTION: Shows usage of the `valueFormatter` prop, which accepts a custom function to format the displayed date label beyond standard format strings. This snippet demonstrates advanced formatting control especially useful when handling multiple or range types.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_7\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.valueFormatter} />\n```\n\n----------------------------------------\n\nTITLE: Getting Tab Control Ref with Mantine\nDESCRIPTION: Illustrates how to get a reference to a specific Tabs.Tab component using `useRef`. This allows direct manipulation of the tab element, such as focusing it programmatically.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useRef } from 'react';\nimport { Tabs } from '@mantine/core';\n\nfunction Demo() {\n  const secondTabRef = useRef<HTMLButtonElement>(null);\n\n  return (\n    <Tabs defaultValue=\"first\">\n      <Tabs.List>\n        <Tabs.Tab value=\"first\">First tab</Tabs.Tab>\n        <Tabs.Tab value=\"Second\" ref={secondTabRef}>\n          Second tab\n        </Tabs.Tab>\n        <Tabs.Tab value=\"third\">Third tab</Tabs.Tab>\n      </Tabs.List>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled PasswordInput with React state\nDESCRIPTION: This snippet demonstrates how to create a controlled PasswordInput component using React's useState hook. The value of the input is managed by the component's state, allowing for programmatic control and updates.  The `onChange` event updates the state with the new input value. Dependencies: react, @mantine/core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/password-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { PasswordInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  return (\n    <PasswordInput\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Form Context with Mantine\nDESCRIPTION: Example showing how to create a form context using createFormContext, define a context field component, and implement the main form component with FormProvider.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/create-form-context.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\nimport { createFormContext } from '@mantine/form';\n\n// Definition of form values is required\ninterface FormValues {\n  age: number;\n  name: string;\n}\n\n// createFormContext returns a tuple with 3 items:\n// FormProvider is a component that sets form context\n// useFormContext hook return form object that was previously set in FormProvider\n// useForm hook works the same way as useForm exported from the package but has predefined type\nconst [FormProvider, useFormContext, useForm] =\n  createFormContext<FormValues>();\n\nfunction ContextField() {\n  const form = useFormContext();\n  return (\n    <TextInput\n      label=\"Your name\"\n      key={form.key('name')}\n      {...form.getInputProps('name')}\n    />\n  );\n}\n\nexport function Context() {\n  // Create form as described in use-form documentation\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      age: 0,\n      name: '',\n    },\n  });\n\n  // Wrap your form with FormProvider\n  return (\n    <FormProvider form={form}>\n      <form onSubmit={form.onSubmit(() => {})}>\n        <ContextField />\n      </form>\n    </FormProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Basic Fields with Valibot and Mantine Form in TypeScript\nDESCRIPTION: Demonstrates using `valibotResolver` with a simple Valibot schema (`v.object`) containing string (`v.string`, `v.email`, `v.minLength`) and number (`v.number`, `v.minValue`) validation rules for basic form fields within `useForm`. Shows how to define the schema, integrate it into the `validate` option of `useForm`, and access validation errors via `form.errors` after calling `form.validate()`. Requires `mantine-form-valibot-resolver`, `valibot`, and `@mantine/form` packages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { valibotResolver } from 'mantine-form-valibot-resolver';\nimport * as v from 'valibot';\nimport { useForm } from '@mantine/form';\n\nconst schema = v.object({\n  name: v.pipe(\n    v.string(),\n    v.minLength(2, 'Name should have at least 2 letters')\n  ),\n  email: v.pipe(v.string(), v.email('Invalid email')),\n  age: v.pipe(\n    v.number(),\n    v.minValue(18, 'You must be at least 18 to create an account')\n  ),\n});\n\nconst form = useForm({\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: valibotResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  name: 'Name should have at least 2 letters',\n//  email: 'Invalid email',\n//  age: 'You must be at least 18 to create an account'\n// }\n```\n\n----------------------------------------\n\nTITLE: Composing Forms with UseFormReturnType Prop - Mantine (TypeScript/TSX)\nDESCRIPTION: This code sample illustrates passing a strongly-typed useForm instance as a prop to child components, using the UseFormReturnType interface for type safety. This facilitates reusable, isolated input components that participate in a larger form. Required dependencies are @mantine/form, @mantine/core, and React. The input is a form instance, and the output is interconnected, type-safe components reflecting and updating shared form state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_8\n\nLANGUAGE: TSX\nCODE:\n```\nimport { TextInput } from '@mantine/core';\nimport { useForm, UseFormReturnType } from '@mantine/form';\n\ninterface FormValues {\n  name: string;\n  occupation: string;\n}\n\nfunction NameInput({\n  form,\n}: {\n  form: UseFormReturnType<FormValues>;\n}) {\n  return (\n    <TextInput\n      key={form.key('name')}\n      {...form.getInputProps('name')}\n    />\n  );\n}\n\nfunction OccupationInput({\n  form,\n}: {\n  form: UseFormReturnType<FormValues>;\n}) {\n  return (\n    <TextInput\n      key={form.key('occupation')}\n      {...form.getInputProps('occupation')}\n    />\n  );\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    mode: 'uncontrolled',\n    initialValues: { name: '', occupation: '' },\n  });\n  return (\n    <>\n      <NameInput form={form} />\n      <OccupationInput form={form} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Form Errors with useForm – Mantine\nDESCRIPTION: Demonstrates how to access the `form.errors` object after validation. Initially, the errors object is empty. After manual validation, it contains validation error messages for each field.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { firstName: '', lastName: '' },\n  validate: {\n    firstName: (value) =>\n      value.length < 2 ? 'First name is too short' : null,\n    lastName: (value) =>\n      value.length < 2 ? 'Last name is too short' : null,\n  },\n});\n\n// Errors object is empty by default\nform.errors; // -> {}\n\n// Errors will be filled when you call form.validate manually\n// or automatically with form.onSubmit handler\nform.validate();\n\nform.errors; // ->\n// {\n//   firstName: 'First name is too short',\n//   lastName: 'Last name is too short'\n// }\n\n```\n\n----------------------------------------\n\nTITLE: Using ColorSchemeScript and MantineProvider for auto color scheme based on system preferences (TypeScript)\nDESCRIPTION: This snippet demonstrates configuring Mantine to automatically select color schemes based on the user's system preferences by setting `defaultColorScheme` to 'auto' in both `ColorSchemeScript` and `MantineProvider`. This setup integrates system-level color mode detection into SSR applications.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <ColorSchemeScript defaultColorScheme=\"auto\" />\n      <MantineProvider defaultColorScheme=\"auto\">\n        {/* Your app here */}\n      </MantineProvider>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up MantineProvider in React Router Root Layout (TSX)\nDESCRIPTION: Illustrates how to modify the `app/root.tsx` file in a React Router application to integrate Mantine. It involves importing core Mantine styles, adding the `ColorSchemeScript` to the head for theme management, applying `mantineHtmlProps` to the html tag, and wrapping the main application outlet (`children`) with the `MantineProvider`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/react-router.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Import styles of packages that you've installed.\n// All packages except `@mantine/hooks` require styles imports\nimport '@mantine/core/styles.css';\n\nimport {\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from \"react-router\";\nimport { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';\n\nexport function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\" {...mantineHtmlProps}>\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <ColorSchemeScript />\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <MantineProvider>{children}</MantineProvider>\n        <ScrollRestoration />\n        <Scripts />\n      </body>\n    </html>\n  );\n}\n\n// ... other app/root.tsx content\n```\n\n----------------------------------------\n\nTITLE: Overriding Mantine Layered Styles with Local CSS in TypeScript\nDESCRIPTION: Demonstrates the use of local application styles to override Mantine's layered styles by leveraging the CSS Cascade algorithm. Standard module.css imports placed after Mantine layered styles will override their rules. This approach requires having a custom CSS module (e.g., Demo.module.css) in the project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ If your styles are not wrapped in @layer directive,\n// they will be applied after Mantine styles\nimport classes from './Demo.module.css';\n\nimport '@mantine/core/styles.layer.css';\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Dropzone with NPM - Bash\nDESCRIPTION: This snippet demonstrates the installation of the @mantine/dropzone, @mantine/core, and @mantine/hooks packages using the npm package manager.  It's a prerequisite step to use the Mantine Dropzone component within a project.  No specific parameters are needed; it simply installs the listed dependencies. The output is the successful installation of the specified packages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/dropzone/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @mantine/dropzone @mantine/core @mantine/hooks\n```\n\n----------------------------------------\n\nTITLE: Controlled Checkbox Example (React)\nDESCRIPTION: This example demonstrates how to create a controlled Checkbox component in React using the `useState` hook to manage the checked state. The `onChange` event updates the state, allowing for external control of the checkbox's value. The component relies on imports from `@mantine/core` and `react`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/checkbox.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Checkbox } from '@mantine/core';\n\nfunction Demo() {\n  const [checked, setChecked] = useState(false);\n  return (\n    <Checkbox\n      checked={checked}\n      onChange={(event) => setChecked(event.currentTarget.checked)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using the useId Hook in React Components - Mantine - TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the useId hook from @mantine/hooks within a functional React component to ensure that an input and its label share a unique, persistent identifier. As a dependency, @mantine/hooks must be installed. The Input component accepts an optional id prop; if provided, useId will use that value as the ID, otherwise it will generate a random ID that is stable across renders. The outputs are input-label pairs with matching ids, either user-specified or auto-generated. This implementation is useful for improving accessibility by binding labels to inputs, and is compatible with React and TypeScript projects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-id.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useId } from '@mantine/hooks';\n\nfunction Input({ id }: { id?: string }) {\n  const uuid = useId(id);\n\n  return (\n    <>\n      <label htmlFor={uuid}>Input label</label>\n      <input type=\"text\" id={uuid} />\n    </>\n  );\n}\n\n// input and label will have id 'my-id'\nconst withId = <Input id=\"my-id\" />;\n\n// input and label will have random id 'mantine-fZMoF'\nconst withoutId = <Input />;\n\n```\n\n----------------------------------------\n\nTITLE: Implementing One-Time Code Input with PinInput in React\nDESCRIPTION: Demonstrates how to create a PIN input field with one-time code support for SMS verification. The oneTimeCode prop sets autocomplete=\"one-time-code\" to interface with OS-level SMS code suggestions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pin-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PinInput } from '@mantine/core';\n\nfunction OneTimeCodeInput() {\n  return <PinInput oneTimeCode />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Polymorphic Center Component with Custom Elements (MDX/TSX)\nDESCRIPTION: This snippet illustrates polymorphic usage of the Center component, allowing the rendered element to be changed via props. By default, it renders as a 'div', but can be altered to a 'button' or others by passing 'changeToElement'. Dependencies: React, Mantine's polymorphic component system (likely custom). Inputs: defaultElement ('div'), changeToElement ('button'), component ('Center'). Output: Center-styled content as the specified HTML element. Limitation: may require specific Mantine or project configuration to support polymorphism.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/center.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n<Polymorphic\n  defaultElement=\"div\"\n  changeToElement=\"button\"\n  component=\"Center\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Configuring Trend-based Colors for Sparkline\nDESCRIPTION: Demonstrates how to use the trendColors prop to change the Sparkline color based on data trends (positive, negative, or neutral).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/sparkline.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={SparklineDemos.trendColors} />\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Limitations and Correct Patterns for Using Timeline.Item in Mantine with TypeScript\nDESCRIPTION: This code snippet explains that wrapping Timeline.Item components directly in other components is unsupported, as the Timeline component relies on the immediate order of Timeline.Item elements. It shows an invalid example where Timeline.Item is wrapped directly in a component (which prevents rendering), contrasted with a valid pattern where child components are nested inside Timeline.Item to maintain correct rendering order.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/timeline.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Timeline } from '@mantine/core';\n\n// This will not work, step children will not render\nfunction WillNotWork() {\n  return <Timeline.Item title=\"Nope\">It will not work</Timeline.Item>;\n}\n\n// Create a separate component for children\nfunction WillWork() {\n  return <div>This will work as expected!</div>;\n}\n\nfunction Demo() {\n  return (\n    <Timeline active={1}>\n      <Timeline.Item title=\"Regular item\">First item</Timeline.Item>\n      <WillNotWork />\n      <Timeline.Item title=\"Works as expected\">\n        <WillWork />\n      </Timeline.Item>\n      <Timeline.Item title=\"Regular item\">Third item</Timeline.Item>\n    </Timeline>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Managing a Controlled Mantine Switch.Group in TSX\nDESCRIPTION: Illustrates how to manage the state of multiple `Switch` components grouped within a `Switch.Group`. The `useState` hook manages an array of selected string values, which is bound to the `value` prop of `Switch.Group`. The `onChange` prop updates the state array when any switch within the group changes. Requires `react` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/switch.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Switch } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string[]>([]);\n\n  return (\n    <Switch.Group value={value} onChange={setValue}>\n      <Switch value=\"react\" label=\"React\" />\n      <Switch value=\"svelte\" label=\"Svelte\" />\n    </Switch.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Autocomplete with String Array Data in TypeScript\nDESCRIPTION: Demonstrates how to implement the Autocomplete component from Mantine with a simple string array passed to the data prop, allowing users to either select listed options or freely enter any string value. This snippet has no dependencies besides mantine/core. The input is a string array and output is user selection or input as a string.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/autocomplete-value-label.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Autocomplete } from '@mantine/core';\n\nfunction Demo() {\n  return <Autocomplete data={[\"React\", \"Vue\"]} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Year/Month Control Aria-label – Typescript\nDESCRIPTION: This code snippet demonstrates how to customize the `aria-label` attribute for year and month controls within the MonthPicker component using the `getYearControlProps` and `getMonthControlProps` functions. The code imports the `MonthPicker` component from `@mantine/dates` and defines a functional component `Demo`. The `getYearControlProps` function sets the `aria-label` to indicate the selected year. Similarly, `getMonthControlProps` sets the `aria-label` indicating selected year and month to enhance accessibility for screen reader users.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonthPicker } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <MonthPicker\n      getYearControlProps={(date) => ({\n        'aria-label': `Select year ${date.getFullYear()}`,\n      })}\n      getMonthControlProps={(date) => ({\n        'aria-label': `Select month ${date.getFullYear()}/${date.getMonth()}`,\n      })}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using where-* Mixins for Low-Specificity Styling Overrides - SCSS and CSS\nDESCRIPTION: Describes the `where-*` mixins as alternatives to standard `light`, `dark`, `rtl`, and `hover` mixins. These generate less specific CSS selectors using the `:where()` pseudo-class, facilitating easier overrides in extensions or libraries. The snippet demonstrates `where-light` usage and the generated selector.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_8\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  @mixin where-light {\n    color: red;\n  }\n}\n```\n\nLANGUAGE: CSS\nCODE:\n```\n:where([data-mantine-color-scheme='light']) .demo {\n  color: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Checkbox Accessibility Examples (React)\nDESCRIPTION: These examples demonstrate how to properly label a Checkbox component for accessibility.  The `Bad` example shows an unlabeled checkbox, while `GoodAriaLabel` and `GoodLabel` demonstrate labeling using `aria-label` and the `label` prop, respectively. Proper labeling is crucial for users with assistive technologies. Requires import of `Checkbox` from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/checkbox.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Checkbox } from '@mantine/core';\n\n// Not ok, input is not labeled\nfunction Bad() {\n  return <Checkbox />;\n}\n\n// Ok, input is labelled by aria-label\nfunction GoodAriaLabel() {\n  return <Checkbox aria-label=\"My checkbox\" />;\n}\n\n// Ok, input is labelled by label element\nfunction GoodLabel() {\n  return <Checkbox label=\"My checkbox\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using TagsInput with React useState for controlled value\nDESCRIPTION: This snippet demonstrates managing the TagsInput component's value using React's useState hook, making it a controlled component. It initializes an empty array of strings as the state, passing it to TagsInput via the data, value, and onChange props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { TagsInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string[]>([]);\n  return <TagsInput data={[]} value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Color Scheme in MantineProvider\nDESCRIPTION: This snippet demonstrates setting the default color scheme (light, dark, auto) in MantineProvider.  The `defaultColorScheme` prop configures the initial color scheme of the application.  The user can override this value, and the selected color scheme will persist in localStorage.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider defaultColorScheme=\"dark\">\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Help Center Resource Links and Questions\nDESCRIPTION: This section lists links to Mantine's Help Center, providing guidance on templates, color schemes, testing components, and specific implementation questions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Enabling transitions during color scheme change with useMantineColorScheme hook in React (TypeScript)\nDESCRIPTION: This snippet demonstrates how to enable CSS transitions when switching color schemes by passing the keepTransitions: true option to the `useMantineColorScheme` hook. Dependencies include '@mantine/core'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMantineColorScheme } from '@mantine/core';\n\nfunction Demo() {\n  const { colorScheme, setColorScheme } = useMantineColorScheme({\n    keepTransitions: true,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Custom valueFormatter function usage with DatePickerInput in TypeScript\nDESCRIPTION: Shows usage of the 'valueFormatter' prop in '@mantine/dates' DatePickerInput component to provide a custom display format for selected dates. The formatter function handles different selection types, specifically 'multiple' type with an array of dates, formatting them using dayjs with locale and format parameters. A controlled component example demonstrates updating and using state with 'useState'. Requires 'dayjs' as a dependency for date manipulation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport dayjs from 'dayjs';\nimport { useState } from 'react';\nimport { DateFormatter, DatePickerInput } from '@mantine/dates';\n\nconst formatter: DateFormatter = ({ type, date, locale, format }) => {\n  if (type === 'multiple' && Array.isArray(date)) {\n    if (date.length === 1) {\n      return dayjs(date[0]).locale(locale).format(format);\n    }\n\n    if (date.length > 1) {\n      return `${date.length} dates selected`;\n    }\n\n    return '';\n  }\n\n  return '';\n};\n\nfunction Demo() {\n  const [value, setValue] = useState<Date[]>([]);\n\n  return (\n    <DatePickerInput\n      label=\"Pick 2 dates or more\"\n      placeholder=\"Pick 2 dates or more\"\n      value={value}\n      onChange={setValue}\n      type=\"multiple\"\n      valueFormatter={formatter}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Checked State in Mantine Tree Component (TSX)\nDESCRIPTION: Demonstrates how to implement a checked state for nodes within the Mantine `Tree` component using a custom `renderNode` function. The function utilizes `tree.isNodeChecked`, `tree.isNodeIndeterminate`, `tree.checkNode`, and `tree.uncheckNode` methods provided via the `RenderTreeNodePayload` to manage and display the check state using a `Checkbox.Indicator`. It also handles node expansion toggling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.12.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IconChevronDown } from '@tabler/icons-react';\nimport { Checkbox, Group, RenderTreeNodePayload, Tree } from '@mantine/core';\nimport { data } from './data'; // Assumes data is imported correctly\n\nconst renderTreeNode = ({\n  node,\n  expanded,\n  hasChildren,\n  elementProps,\n  tree,\n}: RenderTreeNodePayload) => {\n  const checked = tree.isNodeChecked(node.value);\n  const indeterminate = tree.isNodeIndeterminate(node.value);\n\n  return (\n    <Group gap=\"xs\" {...elementProps}>\n      <Checkbox.Indicator\n        checked={checked}\n        indeterminate={indeterminate}\n        onClick={() => (!checked ? tree.checkNode(node.value) : tree.uncheckNode(node.value))}\n      />\n\n      <Group gap={5} onClick={() => tree.toggleExpanded(node.value)}>\n        <span>{node.label}</span>\n\n        {hasChildren && (\n          <IconChevronDown\n            size={14}\n            style={{ transform: expanded ? 'rotate(180deg)' : 'rotate(0deg)' }}\n          />\n        )}\n      </Group>\n    </Group>\n  );\n};\n\nfunction Demo() {\n  return <Tree data={data} levelOffset={23} expandOnClick={false} renderNode={renderTreeNode} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Shared Labels for Confirm Modals with ModalsProvider in TypeScript\nDESCRIPTION: Sets up the ModalsProvider with custom default labels for confirm and cancel buttons in confirmation modals. This provides consistency across confirmation dialogs by defining shared button text. Dependencies include the @mantine/modals package and React with TypeScript.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/modals.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ModalsProvider } from '@mantine/modals';\n\nfunction Demo() {\n  return (\n    <ModalsProvider labels={{ confirm: 'Submit', cancel: 'Cancel' }}>\n      {/* Your app here */}\n    </ModalsProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Mantine Theme Tokens via the Style Prop in TSX\nDESCRIPTION: Demonstrates two ways to use Mantine theme tokens within the `style` prop: 1) Directly using the Mantine-provided CSS variables (e.g., `var(--mantine-spacing-xl)`). 2) Using the function form of the `style` prop which receives the theme object as an argument, allowing direct access to theme properties (e.g., `theme.spacing.xl`, `theme.colors.orange[5]`). Imports the `Box` component from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Box\n        style={{\n          margin: 'var(--mantine-spacing-xl)',\n          color: 'var(--mantine-color-orange-5)',\n        }}\n      >\n        With CSS variables\n      </Box>\n\n      <Box\n        style={(theme) => ({\n          margin: theme.spacing.xl,\n          color: theme.colors.orange[5],\n        })}\n      >\n        With theme object\n      </Box>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Form Values before Submission\nDESCRIPTION: Demonstrates how to use transformValues to transform form values before they get submitted. This example shows how to get transformed values programmatically using getTransformedValues.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      firstName: 'John',\n      lastName: 'Doe',\n    },\n\n    transformValues: (values) => ({\n      fullName: `${values.firstName} ${values.lastName}`,\n    }),\n  });\n\n  form.getTransformedValues(); // -> { fullName: 'John Doe' }\n  form.getTransformedValues({\n    firstName: 'Jane',\n    lastName: 'Loe',\n  }); // { fullName: 'Jane Loe' }\n}\n```\n\n----------------------------------------\n\nTITLE: Using built-in color scheme manager with useMantineColorScheme hook\nDESCRIPTION: Shows how to change the application color scheme using the useMantineColorScheme hook. Provides buttons to switch between light, dark, auto modes or clear the user preference.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Group, useMantineColorScheme } from '@mantine/core';\n\nfunction Demo() {\n  const { setColorScheme, clearColorScheme } = useMantineColorScheme();\n\n  return (\n    <Group>\n      <Button onClick={() => setColorScheme('light')}>Light</Button>\n      <Button onClick={() => setColorScheme('dark')}>Dark</Button>\n      <Button onClick={() => setColorScheme('auto')}>Auto</Button>\n      <Button onClick={clearColorScheme}>Clear</Button>\n    </Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Combobox Select Input in Mantine (TSX)\nDESCRIPTION: Demonstrates how to use the Mantine `Combobox` component and `useCombobox` hook to create a simple dropdown select. It utilizes `useState` to manage the selected value, maps an array of strings to `Combobox.Option` elements, and uses `InputBase` as the clickable target to toggle the dropdown.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Combobox, Input, InputBase, useCombobox } from '@mantine/core';\n\nconst groceries = ['🍎 Apples', '🍌 Bananas', '🥦 Broccoli', '🥕 Carrots', '🍫 Chocolate'];\n\nfunction Demo() {\n  const combobox = useCombobox({\n    onDropdownClose: () => combobox.resetSelectedOption(),\n  });\n\n  const [value, setValue] = useState<string | null>(null);\n\n  const options = groceries.map((item) => (\n    <Combobox.Option value={item} key={item}>\n      {item}\n    </Combobox.Option>\n  ));\n\n  return (\n    <Combobox\n      store={combobox}\n      onOptionSubmit={(val) => {\n        setValue(val);\n        combobox.closeDropdown();\n      }}\n    >\n      <Combobox.Target>\n        <InputBase\n          component=\"button\"\n          pointer\n          rightSection={<Combobox.Chevron />}\n          onClick={() => combobox.toggleDropdown()}\n        >\n          {value || <Input.Placeholder>Pick value</Input.Placeholder>}\n        </InputBase>\n      </Combobox.Target>\n\n      <Combobox.Dropdown>\n        <Combobox.Options>{options}</Combobox.Options>\n      </Combobox.Dropdown>\n    </Combobox>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useMantineTheme Hook in Mantine\nDESCRIPTION: This snippet demonstrates the use of the `useMantineTheme` hook to access the current theme object within a functional component. The hook returns the theme object from the MantineProvider context. The example styles a `div` element's background color by accessing a color from the theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/theme-object.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMantineTheme } from '@mantine/core';\n\nfunction Demo() {\n  const theme = useMantineTheme();\n  return <div style={{ background: theme.colors.blue[5] }} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Referencing Mantine Heading Variables in SCSS\nDESCRIPTION: Demonstrates how to apply Mantine's predefined CSS variables for heading styles (font-size, line-height, font-weight) directly within an SCSS stylesheet to style a custom class.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_11\n\nLANGUAGE: scss\nCODE:\n```\n.h1 {\n  font-size: var(--mantine-h1-font-size);\n  line-height: var(--mantine-h1-line-height);\n  font-weight: var(--mantine-h1-font-weight);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing SemiCircleProgress Component in Next.js/React\nDESCRIPTION: Shows how the page is structured with imports for SemiCircleProgress demos and layout components, setting up the documentation page using MDX data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/semi-circle-progress.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { SemiCircleProgressDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.SemiCircleProgress);\n```\n\n----------------------------------------\n\nTITLE: Clearable MonthPickerInput\nDESCRIPTION: Demonstrates how to make the MonthPickerInput clearable by adding a clear button in the right section using the clearable prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.clearable} />\n```\n\n----------------------------------------\n\nTITLE: HTML Output of Not Disabled Button\nDESCRIPTION: This HTML snippet shows the output when the button is not disabled.  The `data-disabled` attribute is not present. This represents the default state and allows for separate styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<button class=\"my-button\">Not disabled button</button>\n```\n\n----------------------------------------\n\nTITLE: Using useInputState with Various Input Components in React\nDESCRIPTION: Demonstrates how to use the useInputState hook with different input types including native HTML inputs, Mantine TextInput, and NumberInput components. The example compares implementation with useInputState against traditional useState approach.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-input-state.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { NumberInput, TextInput } from '@mantine/core';\nimport { useInputState } from '@mantine/hooks';\n\nfunction WithUseInputState() {\n  const [stringValue, setStringValue] = useInputState('');\n  const [numberValue, setNumberValue] = useInputState<\n    string | number\n  >(0);\n\n  return (\n    <>\n      <input\n        type=\"text\"\n        value={stringValue}\n        onChange={setStringValue}\n      />\n      <TextInput value={stringValue} onChange={setStringValue} />\n      <NumberInput value={numberValue} onChange={setNumberValue} />\n    </>\n  );\n}\n\nfunction WithUseState() {\n  const [stringValue, setStringValue] = useState('');\n  const [numberValue, setNumberValue] = useState<string | number>(0);\n\n  return (\n    <>\n      <input\n        type=\"text\"\n        value={stringValue}\n        onChange={(event) =>\n          setStringValue(event.currentTarget.value)\n        }\n      />\n      <TextInput\n        value={stringValue}\n        onChange={(event) =>\n          setStringValue(event.currentTarget.value)\n        }\n      />\n      <NumberInput value={numberValue} onChange={setNumberValue} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up MantineProvider in app/layout.tsx\nDESCRIPTION: Sets up MantineProvider at the root of the application with color scheme support and defines metadata for the app in the 'app' directory router.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';\n\nexport const metadata = {\n  title: 'My Mantine app',\n  description: 'I have followed setup instructions carefully',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\" {...mantineHtmlProps}>\n      <head>\n        <ColorSchemeScript />\n      </head>\n      <body>\n        <MantineProvider>{children}</MantineProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Styled Components with @mantine/emotion Package in React\nDESCRIPTION: Demonstrates how to use the createStyles function from the new @mantine/emotion package to create styled components with theme integration, responsive design, and light/dark mode support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.9.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { rem } from '@mantine/core';\nimport { createStyles } from '@mantine/emotion';\n\nconst useStyles = createStyles((theme, _, u) => ({\n  wrapper: {\n    maxWidth: rem(400),\n    width: '100%',\n    height: rem(180),\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginLeft: 'auto',\n    marginRight: 'auto',\n    borderRadius: theme.radius.sm,\n\n    // Use light and dark selectors to change styles based on color scheme\n    [u.light]: {\n      backgroundColor: theme.colors.gray[1],\n    },\n\n    [u.dark]: {\n      backgroundColor: theme.colors.dark[5],\n    },\n\n    // Reference theme.breakpoints in smallerThan and largerThan functions\n    [u.smallerThan('sm')]: {\n      // Child reference in nested selectors via ref\n      [`& .${u.ref('child')}`]: {\n        fontSize: theme.fontSizes.xs,\n      },\n    },\n  },\n\n  child: {\n    // Assign selector to a ref to reference it in other styles\n    ref: u.ref('child'),\n    padding: theme.spacing.md,\n    borderRadius: theme.radius.sm,\n    boxShadow: theme.shadows.md,\n\n    [u.light]: {\n      backgroundColor: theme.white,\n      color: theme.black,\n    },\n\n    [u.dark]: {\n      backgroundColor: theme.colors.dark[8],\n      color: theme.white,\n    },\n  },\n}));\n\nfunction Demo() {\n  const { classes } = useStyles();\n\n  return (\n    <div className={classes.wrapper}>\n      <div className={classes.child}>createStyles demo</div>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Control Ref with Mantine Spoiler (TSX)\nDESCRIPTION: This code snippet demonstrates how to get a reference to the control (toggle button) of the Mantine Spoiler component using the `controlRef` prop. It uses the `useRef` hook to create a ref that can be passed to the `controlRef` prop.  The ref provides direct access to the HTMLButtonElement. Requires `react` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/spoiler.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useRef } from 'react';\nimport { Spoiler } from '@mantine/core';\n\nfunction Demo() {\n  const spoilerControlRef = useRef<HTMLButtonElement>(null);\n  return (\n    <Spoiler\n      controlRef={spoilerControlRef}\n      hideLabel=\"Hide\"\n      showLabel=\"Show\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Page Metadata for Dropzone and use-form Integration in JavaScript\nDESCRIPTION: Defines metadata object containing the page title, description, slug, category, tags, and timestamps. This metadata describes the purpose of the page which is showing how to use Dropzone with @mantine/form for file selection state management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-use-dropzone-with-form.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const meta = {\n  title: 'How to use Dropzone with @mantine/form?',\n  description: 'Learn how to use Dropzone with @mantine/form to handle file selection state',\n  slug: 'how-to-use-dropzone-with-form',\n  category: 'forms',\n  tags: ['form', '@mantine/form', 'dropzone'],\n  created_at: 'December 1, 2023',\n  last_updated_at: 'April 8, 2024',\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Color Scheme for Disabled JS in Next.js with TSX\nDESCRIPTION: Illustrates how to set the initial color scheme for users with disabled JavaScript, specifically within a Next.js App Router `RootLayout`. This involves manually setting the `data-mantine-color-scheme` attribute on the `<html>` element and including the `ColorSchemeScript` in the `<head>`. This ensures the correct scheme is applied before any JavaScript runs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nexport const metadata = {\n  title: 'My Mantine app',\n  description: 'I have followed setup instructions carefully',\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\" data-mantine-color-scheme=\"light\">\n      <head>\n        <ColorSchemeScript />\n      </head>\n      <body>\n        <MantineProvider>{children}</MantineProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Tree Component with Iconography in React and Mantine\nDESCRIPTION: This snippet defines a Tree component with custom icons for files and folders, utilizing Mantine core and tabler icons. The `FileIcon` function determines appropriate icons based on filename extensions and folder state, while the `Leaf` component renders individual nodes with these icons. The `Demo` component displays the Tree with specified data, allowing node selection and expansion behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.10.0.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { IconFolder, IconFolderOpen } from '@tabler/icons-react';\nimport { Group, RenderTreeNodePayload, Tree } from '@mantine/core';\nimport { CssIcon, NpmIcon, TypeScriptCircleIcon } from '@mantinex/dev-icons';\nimport { data, dataCode } from './data';\nimport classes from './Demo.module.css';\n\ninterface FileIconProps {\n  name: string;\n  isFolder: boolean;\n  expanded: boolean;\n}\n\nfunction FileIcon({ name, isFolder, expanded }: FileIconProps) {\n  if (name.endsWith('package.json')) {\n    return <NpmIcon size={14} />;\n  }\n\n  if (name.endsWith('.ts') || name.endsWith('.tsx') || name.endsWith('tsconfig.json')) {\n    return <TypeScriptCircleIcon size={14} />;\n  }\n\n  if (name.endsWith('.css')) {\n    return <CssIcon size={14} />;\n  }\n\n  if (isFolder) {\n    return expanded ? (\n      <IconFolderOpen color=\"var(--mantine-color-yellow-9)\" size={14} stroke={2.5} />\n    ) : (\n      <IconFolder color=\"var(--mantine-color-yellow-9)\" size={14} stroke={2.5} />\n    );\n  }\n\n  return null;\n}\n\nfunction Leaf({ node, expanded, hasChildren, elementProps }: RenderTreeNodePayload) {\n  return (\n    <Group gap={5} {...elementProps}>\n      <FileIcon name={node.value} isFolder={hasChildren} expanded={expanded} />\n      <span>{node.label}</span>\n    </Group>\n  );\n}\n\nfunction Demo() {\n  return (\n    <Tree\n      classNames={classes}\n      selectOnClick\n      clearSelectionOnOutsideClick\n      data={data}\n      renderNode={(payload) => <Leaf {...payload} />}\n    />\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Field Validation - Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates how to define per-field validation logic within useForm, using both field-level and nested object validators as well as invoking different validation methods. Dependencies include @mantine/form; all validation callbacks receive current field values as input and return either an error message or null. Outputs are updated error objects within the form instance. The structure supports both flat and nested validation schemas.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    email: '',\n    user: {\n      firstName: '',\n      lastName: '',\n    },\n  },\n  validate: {\n    email: (value) => (value.length < 2 ? 'Invalid email' : null),\n    user: {\n      firstName: (value) =>\n        value.length < 2\n          ? 'First name must have at least 2 letters'\n          : null,\n    },\n  },\n});\n\n// Validates all fields with specified `validate` function or schema, sets form.errors\nform.validate();\n\n// Validates single field at specified path, sets form.errors\nform.validateField('user.firstName');\n\n// Works the same way as form.validate but does not set form.errors\nform.isValid();\nform.isValid('user.firstName');\n```\n\n----------------------------------------\n\nTITLE: Customizing Shift Middleware Options in Popover\nDESCRIPTION: This code snippet demonstrates how to customize the options for the `shift` middleware in the Mantine Popover component. Specifically, it shows how to change the padding of the `shift` middleware to `20px`. The `middlewares` prop is used to pass an object with the desired configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/popover.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Popover } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover\n      middlewares={{ shift: { padding: 20 } }}\n      position=\"bottom\"\n    >\n      {/* Popover content */}\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled TimeInput in React with Mantine\nDESCRIPTION: Example of creating a controlled TimeInput component using React useState hook. The component's value is stored in state and updated through the onChange event handler, providing full control over the input's value.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/time-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { TimeInput } from '@mantine/dates';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  return (\n    <TimeInput\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Making a Standard Mantine Component Polymorphic (TSX)\nDESCRIPTION: Demonstrates how to add polymorphic type support to a standard Mantine component (like `Group`) that accepts the `component` prop but doesn't have polymorphic types by default. This is achieved using the `createPolymorphicComponent` utility function from `@mantine/core`, improving type safety when changing the root element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createPolymorphicComponent,\n  Group,\n  GroupProps,\n} from '@mantine/core';\n\nconst PolymorphicGroup = createPolymorphicComponent<\n  'button',\n  GroupProps\n>(Group);\n\nfunction Demo() {\n  return (\n    <PolymorphicGroup component=\"a\" href=\"https://mantine.dev\" />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Accessible Mantine Alert with Close Button (TypeScript/JavaScript)\nDESCRIPTION: This snippet defines React components utilizing Mantine's Alert component with accessibility features, including labels for close buttons and ARIA attributes. It highlights best practices for accessible UI components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/alert.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Alert } from '@mantine/core';\n\nfunction Invalid() {\n  // -> not ok\n  return <Alert withCloseButton />;\n}\n\nfunction Valid() {\n  // -> ok\n  return <Alert withCloseButton closeButtonLabel=\"Dismiss\" />;\n}\n\nfunction AlsoValid() {\n  // -> ok, without close button, closeButtonLabel is not needed\n  return <Alert />;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing nested form state with Mantine useForm hook in TypeScript\nDESCRIPTION: Initializes a form state with nested objects and arrays using Mantine's useForm hook operating in 'uncontrolled' mode. Demonstrates how to access, set, and validate nested fields using string-based property paths. Dependencies include '@mantine/form' for useForm. Key inputs are the initialValues object representing nested user, fruits, and deeply nested structures. Outputs include form helpers to get input properties, set values, and validate nested fields with dot-notation paths.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/nested.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    user: {\n      firstName: 'John',\n      lastName: 'Doe',\n    },\n\n    fruits: [\n      { name: 'Banana', available: true },\n      { name: 'Orange', available: false },\n    ],\n\n    deeply: {\n      nested: {\n        object: [{ item: 1 }, { item: 2 }],\n      },\n    },\n  },\n});\n\n// Props for input that is controlled by user object firstName field\nform.getInputProps('user.firstName');\n\n// Set value of `name` field that is contained in object at second position of fruits array:\nform.setFieldValue('fruits.1.name', 'Carrot');\n\n// Validate deeply nested field\nform.validateField('deeply.nested.object.0.item');\n```\n\n----------------------------------------\n\nTITLE: Implementing Collapsible Navbar with Desktop/Mobile States in React\nDESCRIPTION: Example of implementing an AppShell with a navbar that has separate collapsed states for mobile and desktop viewports using useDisclosure hook for state management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell, Button } from '@mantine/core';\nimport { useDisclosure } from '@mantine/hooks';\n\nexport function CollapseDesktop() {\n  const [mobileOpened, { toggle: toggleMobile }] = useDisclosure();\n  const [desktopOpened, { toggle: toggleDesktop }] =\n    useDisclosure(true);\n\n  return (\n    <AppShell\n      padding=\"md\"\n      header={{ height: 60 }}\n      navbar={{\n        width: 300,\n        breakpoint: 'sm',\n        collapsed: { mobile: !mobileOpened, desktop: !desktopOpened },\n      }}\n    >\n      <AppShell.Header>Header</AppShell.Header>\n      <AppShell.Navbar>Navbar</AppShell.Navbar>\n      <AppShell.Main>\n        <Button onClick={toggleDesktop} visibleFrom=\"sm\">\n          Toggle navbar\n        </Button>\n        <Button onClick={toggleMobile} hiddenFrom=\"sm\">\n          Toggle navbar\n        </Button>\n      </AppShell.Main>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled MultiSelect State Management with React Hooks in TypeScript\nDESCRIPTION: Demonstrates controlled usage of the MultiSelect component where the selected values are managed as a state array of strings using React's useState hook. The onChange callback updates the component's value state, enforcing that only arrays of strings are supported as selections. This snippet requires React and @mantine/core dependencies and showcases basic controlled input technique in TypeScript.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/multi-select.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { MultiSelect } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string[]>([]);\n  return <MultiSelect data={[]} value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Animating Button Loading State (Mantine Button, TypeScript)\nDESCRIPTION: Demonstrates handling a loading animation state in Mantine Button components using the loading prop, coupled with a Switch for toggling. Requires '@mantine/core', useDisclosure hook, and a Switch component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Group } from '@mantine/core';\n\nfunction Demo() {\n  const [loading, { toggle }] = useDisclosure();\n  return (\n    <>\n      <Group>\n        <Button loading={loading}>Filled button</Button>\n        <Button variant=\"light\" loading={loading}>\n          Light button\n        </Button>\n        <Button variant=\"outline\" loading={loading}>\n          Outline button\n        </Button>\n      </Group>\n\n      <Switch checked={loading} onChange={toggle} label=\"Loading state\" mt=\"md\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useFetch Hook TypeScript Interface and Function Signature\nDESCRIPTION: This snippet defines the TypeScript interface UseFetchOptions extending standard RequestInit with an optional autoInvoke boolean to control automatic invocation. It also declares the useFetch generic function that takes a URL string and optional options, returning an object containing potentially null typed data, loading boolean, nullable error, and methods to refetch data and abort the request. It relies on React hooks internally (not shown) and the browser fetch API. The parameters indicate the request URL and fetch options with advanced controls. The return provides reactive state and control methods for asynchronous data fetching operations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-fetch.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface UseFetchOptions extends RequestInit {\n  autoInvoke?: boolean;\n}\n\nfunction useFetch<T>(\n  url: string,\n  options?: UseFetchOptions\n): {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<T> | undefined;\n  abort: () => void;\n};\n```\n\n----------------------------------------\n\nTITLE: Extending MantineTheme Colors Type Declaration\nDESCRIPTION: Demonstrates how to extend Mantine theme's colors with custom color names through TypeScript module augmentation in a declaration file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  DefaultMantineColor,\n  MantineColorsTuple,\n} from '@mantine/core';\n\ntype ExtendedCustomColors =\n  | 'primaryColorName'\n  | 'secondaryColorName'\n  | DefaultMantineColor;\n\ndeclare module '@mantine/core' {\n  export interface MantineThemeColorsOverride {\n    colors: Record<ExtendedCustomColors, MantineColorsTuple>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting nested object values with Mantine useForm hook in TypeScript\nDESCRIPTION: Shows how to update nested object fields individually or set the entire nested object at once within a form initialized with useForm. Utilizes the setFieldValue method accepting dot-notated string property paths. The code requires '@mantine/form' and expects an initial form state with a user object containing name and occupation fields. Inputs are new field values either for individual keys or a complete nested object, and outputs are updated form state values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/nested.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    user: {\n      name: '',\n      occupation: '',\n    },\n  },\n});\n\n// You can set values for each field individually\nform.setFieldValue('user.name', 'John');\nform.setFieldValue('user.occupation', 'Engineer');\n\n// Or set the entire object\nform.setFieldValue('user', { name: 'Jane', occupation: 'Architect' });\n```\n\n----------------------------------------\n\nTITLE: Input and Input.Wrapper id example\nDESCRIPTION: Shows the correct usage of the `id` attribute when using `Input` within `Input.Wrapper`. It emphasizes the importance of setting the same `id` on both components to connect the label and input for accessibility. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/input.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Input } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Input.Wrapper label=\"Your email\" id=\"your-email\">\n      <Input id=\"your-email\" />\n    </Input.Wrapper>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Component Styles with extend function\nDESCRIPTION: This code snippet demonstrates the use of the `extend` function, introduced in newer versions of Mantine, to customize the styling of a `TextInput` component.  It imports necessary modules like `createTheme`, `MantineProvider`, and `TextInput`.  The `TextInput.extend` method allows for the definition of custom styles, class names, and default props, enhancing component customization. This feature offers autocomplete for the developer during customization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  createTheme,\n  MantineProvider,\n  TextInput,\n} from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extend({\n      styles: (t, props) => ({\n        input: {\n          fontSize:\n            props.size === 'compact' ? t.fontSizes.sm : undefined,\n        },\n      }),\n      classNames: {\n        root: classes.root,\n        input: classes.input,\n        label: classes.label,\n      },\n\n      defaultProps: {\n        size: 'compact',\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Mantine Button with Next.js Link (>= v13) (TSX)\nDESCRIPTION: Demonstrates the integration of a Mantine `Button` with Next.js `Link` for versions 13 and above. The `Link` component is directly passed to the `component` prop of the `Button`, simplifying the integration compared to older Next.js versions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport Link from 'next/link';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button component={Link} href=\"/hello\">\n      Next link button\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Notifications Component with Position and zIndex in Mantine (TSX)\nDESCRIPTION: Demonstrates how to configure the Notifications component with a custom position and zIndex. The notifications will by default appear in the position specified here unless overridden per notification, enabling global positioning of notifications on the screen.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Notifications } from '@mantine/notifications';\n\nfunction Demo() {\n  return <Notifications position=\"top-right\" zIndex={1000} />;\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface for Mantine Combobox Store Structure\nDESCRIPTION: Defines the ComboboxStore interface describing the internal state and handler methods for managing Combobox dropdown state, option selection, focus management, and aria attributes. It includes methods to open, close, toggle dropdown, select and reset options, update indexes, and refs for input elements, facilitating comprehensive control over Combobox behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/combobox.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ninterface ComboboxStore {\n  /** Current dropdown opened state */\n  dropdownOpened: boolean;\n\n  /** Opens dropdown */\n  openDropdown(eventSource?: 'keyboard' | 'mouse' | 'unknown'): void;\n\n  /** Closes dropdown */\n  closeDropdown(eventSource?: 'keyboard' | 'mouse' | 'unknown'): void;\n\n  /** Toggles dropdown opened state */\n  toggleDropdown(\n    eventSource?: 'keyboard' | 'mouse' | 'unknown'\n  ): void;\n\n  /** Selected option index */\n  selectedOptionIndex: number;\n\n  /** Selects `Combobox.Option` by index */\n  selectOption(index: number): void;\n\n  /** Selects first `Combobox.Option` with `active` prop.\n   *  If there are no such options, the function does nothing.\n   */\n  selectActiveOption(): string | null;\n\n  /** Selects first `Combobox.Option` that is not disabled.\n   *  If there are no such options, the function does nothing.\n   * */\n  selectFirstOption(): string | null;\n\n  /** Selects next `Combobox.Option` that is not disabled.\n   *  If the current option is the last one, the function selects first option, if `loop` is true.\n   */\n  selectNextOption(): string | null;\n\n  /** Selects previous `Combobox.Option` that is not disabled.\n   *  If the current option is the first one, the function selects last option, if `loop` is true.\n   * */\n  selectPreviousOption(): string | null;\n\n  /** Resets selected option index to -1, removes `data-combobox-selected` from selected option */\n  resetSelectedOption(): void;\n\n  /** Triggers `onClick` event of selected option.\n   *  If there is no selected option, the function does nothing.\n   */\n  clickSelectedOption(): void;\n\n  /** Updates selected option index to currently selected or active option.\n   *  The function is required to be used with searchable components to update selected option index\n   *  when options list changes based on search query.\n   */\n  updateSelectedOptionIndex(target?: 'active' | 'selected'): void;\n\n  /** List id, used for `aria-*` attributes */\n  listId: string | null;\n\n  /** Sets list id */\n  setListId(id: string): void;\n\n  /** Ref of `Combobox.Search` input */\n  searchRef: React.MutableRefObject<HTMLInputElement | null>;\n\n  /** Moves focus to `Combobox.Search` input */\n  focusSearchInput(): void;\n\n  /** Ref of the target element */\n  targetRef: React.MutableRefObject<HTMLElement | null>;\n\n  /** Moves focus to the target element */\n  focusTarget(): void;\n}\n```\n\n----------------------------------------\n\nTITLE: SSR considerations for color scheme state in Next.js or React Router applications\nDESCRIPTION: This snippet offers guidance on handling color scheme in server-side rendered applications by avoiding client-only storage dependencies and utilizing CSS mixins from postcss-preset-mantine for styling based on color scheme. It underscores that `colorScheme` value on the server can differ from the client due to storage limitations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nIn server side rendering scenarios (e.g., Next.js, React Router), you should not rely on `colorScheme` value directly in rendering logic to prevent hydration issues. Instead, generate styles conditioned on dark/light modes using postcss-preset-mantine styles. The `colorScheme` state is handled client-side for consistency.\n```\n\n----------------------------------------\n\nTITLE: Validating with Joi using useForm\nDESCRIPTION: This snippet illustrates form validation using Joi with Mantine Form. It defines a Joi schema to validate name, email, and age, and integrates it into the form using `joiResolver`. It shows accessing the resulting validation errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport Joi from 'joi';\nimport { joiResolver } from 'mantine-form-joi-resolver';\nimport { useForm } from '@mantine/form';\n\nconst schema = Joi.object({\n  name: Joi.string().min(2).messages({\n    'string.min': 'Name should have at least 2 letters',\n    'string.empty': 'Name should have at least 2 letters',\n  }),\n  email: Joi.string()\n    .email({ tlds: { allow: false } })\n    .messages({\n      'string.email': 'Invalid email',\n      'string.empty': 'Invalid email',\n    }),\n  age: Joi.number()\n    .min(18)\n    .message('You must be at least 18 to create an account'),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: joiResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  name: 'Name should have at least 2 letters',\n//  email: 'Invalid email',\n//  age: 'You must be at least 18 to create an account'\n// }\n```\n\n----------------------------------------\n\nTITLE: Removing Borders from Specific AppShell Components\nDESCRIPTION: Example showing how to selectively remove borders from specific AppShell components while keeping borders on others by setting withBorder prop on individual components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// AppShell.Header does not have a border\n// AppShell.Navbar and AppShell.Aside have a border\nfunction Demo() {\n  return (\n    <AppShell>\n      <AppShell.Header withBorder={false}>Header</AppShell.Header>\n      <AppShell.Navbar>Navbar</AppShell.Navbar>\n      <AppShell.Aside>Aside</AppShell.Aside>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Transition Component in React (TypeScript/JSX)\nDESCRIPTION: This snippet demonstrates how to use Mantine's Transition component to animate the mounting and unmounting of a DOM element with specified transition parameters such as type, duration, and timing function. It highlights handling the 'mounted' prop and passing style styles via a render prop pattern.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/transition.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction Demo({ opened }: { opened: boolean }) {\n  return (\n    <Transition\n      mounted={opened}\n      transition=\"fade\"\n      duration={400}\n      timingFunction=\"ease\"\n    >\n      {(styles) => <div style={styles}>Your modal</div>}\n    </Transition>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Fieldset to Disable All Inputs in a Form (JavaScript)\nDESCRIPTION: Demonstrates how to disable all input elements within a form by utilizing the Mantine Fieldset component. Setting the 'disabled' prop disables all nested inputs. The example also shows how to use the 'variant' prop to style the Fieldset as unstyled for only the disabled functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/disable-all-inputs-in-form.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { EnhanceDisableInputs } from '@/demos/EnhanceDisableInputs.demo';\nimport { FieldsetInputs } from '@/demos/FieldsetInputs.demo';\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'How can I disable all inputs/inputs group inside form?',\n  description: 'Learn how to disable all inputs/inputs group inside form with unstyled Fieldset component',\n  slug: 'disable-all-inputs-in-form',\n  category: 'forms',\n  tags: ['form', 'inputs', 'Fieldset'],\n  created_at: 'November 30, 2023',\n  last_updated_at: 'July 15, 2023',\n};\n\nexport default Layout(meta);\n\n// Usage of Fieldset:\n// Wrap form inputs with <Fieldset disabled={true}> to disable all nested inputs.\n// Set variant=\"unstyled\" to remove default border and padding styles if only disabling functionality is desired.\n\n// Example component to demonstrate usage:\n// <Demo data={FieldsetInputs} />\n```\n\n----------------------------------------\n\nTITLE: Setting ARIA Labels for Navigation Controls - Mantine DatePicker - tsx\nDESCRIPTION: Demonstrates how to use the `ariaLabels` prop to provide custom ARIA labels for navigation controls within the Mantine DatePicker component. This enhances accessibility by providing descriptive text for screen readers for controls like navigating decades, years, and months, and changing view levels. Requires importing the `DatePicker` component from `@mantine/dates`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { DatePicker } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <DatePicker\n      ariaLabels={{\n        nextDecade: 'Next decade',\n        previousDecade: 'Previous decade',\n        nextYear: 'Next year',\n        previousYear: 'Previous year',\n        nextMonth: 'Next month',\n        previousMonth: 'Previous month',\n        yearLevelControl: 'Change to decade view',\n        monthLevelControl: 'Change to year view',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating sx prop with nested selectors to CSS Modules\nDESCRIPTION: Shows how to migrate from sx prop with nested selectors in 6.x to CSS Modules in 7.x.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box sx={{ '&:hover': { background: 'red' } }} />;\n}\n```\n\nLANGUAGE: scss\nCODE:\n```\n.box {\n  &:hover {\n    background: red;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating styles prop with nested selectors\nDESCRIPTION: Shows how to migrate from styles prop with nested selectors in 6.x to CSS Modules in 7.x for component customization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x – nested selectors\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TextInput\n      styles={{\n        input: {\n          '&:focus': {\n            color: 'red',\n          },\n        },\n      }}\n    />\n  );\n}\n```\n\nLANGUAGE: scss\nCODE:\n```\n/* 7.0 */\n.input {\n  &:focus {\n    color: red;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating UnstyledButton Polymorphic Capabilities\nDESCRIPTION: Renders a Polymorphic component to showcase how UnstyledButton can change between different HTML elements (button to anchor).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/unstyled-button.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n<Polymorphic\n  defaultElement=\"button\"\n  changeToElement=\"a\"\n  component=\"UnstyledButton\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with useFetch Hook\nDESCRIPTION: This TypeScript code provides an example of how to use the `useFetch` hook to fetch data from an API. It demonstrates handling loading states, errors, and displaying the fetched data. Dependencies include `@mantine/core` and `@mantine/hooks`. It uses the `LoadingOverlay` component to indicate loading and the `error` state to display error messages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Box, Button, Code, Group, LoadingOverlay, Text } from '@mantine/core';\nimport { useFetch } from '@mantine/hooks';\n\ninterface Item {\n  userId: number;\n  id: number;\n  title: string;\n  completed: boolean;\n}\n\nfunction Demo() {\n  const { data, loading, error, refetch, abort } = useFetch<Item[]>(\n    'https://jsonplaceholder.typicode.com/todos/'\n  );\n\n  return (\n    <div>\n      {error && <Text c=\"red\">{error.message}</Text>}\n\n      <Group>\n        <Button onClick={refetch} color=\"blue\">\n          Refetch\n        </Button>\n        <Button onClick={abort} color=\"red\">\n          Abort\n        </Button>\n      </Group>\n      <Box pos=\"relative\" mt=\"md\">\n        <Code block>{data ? JSON.stringify(data.slice(0, 3), null, 2) : 'Fetching'}</Code>\n        <LoadingOverlay visible={loading} />\n      </Box>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Center Component Demos and Layout in React (JavaScript/TypeScript)\nDESCRIPTION: This snippet imports demo data and layout helpers required to render examples of the Center component from Mantine. It pulls in demo data from '@docs/demos', a Layout component from the application's layout directory, and MDX data for contextual page content. Dependencies: React, Mantine, project-specific MDX and demo data modules. Expected input: none. Output: available imports for use in child components. Limitation: Assumes project setup with custom path aliases.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/center.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { CenterDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine CSS Layered Styles in React with TypeScript\nDESCRIPTION: Demonstrates how to import Mantine styles wrapped with the @layer mantine CSS directive in a TypeScript React application. This approach is required if the build tool does not guarantee import order. The .layer.css files provide the same styles as standard .css files but are wrapped for CSS layering. Only one form (standard or layered) should be used per component/package to avoid duplication.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.layer.css';\nimport '@mantine/dates/styles.layer.css';\n\n// ... other styles\n```\n\n----------------------------------------\n\nTITLE: CloseButton Accessibility Example\nDESCRIPTION: This code snippet demonstrates how to make the Mantine `CloseButton` accessible to screen readers by providing an `aria-label` or using the `VisuallyHidden` component. The example shows two approaches: directly setting the `aria-label` and wrapping the button content with the `VisuallyHidden` component to provide a text alternative for screen readers. This is important for users who rely on assistive technologies to understand the purpose of the button.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/close-button.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { CloseButton, VisuallyHidden } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <CloseButton aria-label=\"Close modal\" />\n\n      <CloseButton>\n        <VisuallyHidden>Close modal</VisuallyHidden>\n      </CloseButton>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Type Definition for Resize Observer Hook in TypeScript\nDESCRIPTION: Provides the TypeScript type definition relevant to the `useElementSize` hook, specifically showing the signature for the related `useResizeObserver` hook. It defines the `ObserverRect` type (based on `DOMRectReadOnly`) and the function signature, which returns a tuple containing a React ref object and the `ObserverRect`. Optional `ResizeObserverOptions` can be passed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-element-size.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\ntype ObserverRect = Omit<DOMRectReadOnly, 'toJSON'>;\n\nfunction useResizeObserver<T extends HTMLElement = any>(\n  options?: ResizeObserverOptions\n): readonly [React.RefObject<T>, ObserverRect];\n```\n\n----------------------------------------\n\nTITLE: Tracking Touched and Dirty Fields - Mantine (TypeScript/TSX)\nDESCRIPTION: This code segment covers methods for determining and controlling 'touched' and 'dirty' field flags within a useForm instance, which is useful for advanced UI feedback and validation triggers. Functions include status checks, completes sets, and resets for both touched and dirty states. These utilities depend solely on initialized useForm and use object maps or paths as input. Outputs are updated internal flags reflecting user interactions and unsaved changes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_7\n\nLANGUAGE: TSX\nCODE:\n```\n// Returns true if user interacted with any field inside form in any way\nform.isTouched();\n\n// Returns true if user interacted with field at specified path\nform.isTouched('path');\n\n// Set all touched values\nform.setTouched({ 'user.firstName': true, 'user.lastName': false });\n\n// Clears touched status of all fields\nform.resetTouched();\n\n// Returns true if form values are not deep equal to initialValues\nform.isDirty();\n\n// Returns true if field value is not deep equal to initialValues\nform.isDirty('path');\n\n// Sets dirty status of all fields\nform.setDirty({ 'user.firstName': true, 'user.lastName': false });\n\n// Clears dirty status of all fields, saves form.values snapshot\n// After form.resetDirty is called, form.isDirty will compare\n// form.getValues() to snapshot instead of initialValues\nform.resetDirty();\n```\n\n----------------------------------------\n\nTITLE: Rendering Form Demonstrations with React JSX in JavaScript\nDESCRIPTION: This series of JSX snippets render <Demo> components configured with various form demo data. Each snippet demonstrates a unique form functionality: asynchronously setting initial form values, saving form values to local storage, reordering list items via drag-and-drop, and implementing multi-step form navigation. Each <Demo> component receives a 'data' prop specifying the respective demo scenario from 'FormDemos'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/recipes.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n## Set initial values with async request\n\n<Demo data={FormDemos.asyncSetValues} />\n```\n\nLANGUAGE: jsx\nCODE:\n```\n## Save form values to local storage\n\n<Demo data={FormDemos.localStorage} />\n```\n\nLANGUAGE: jsx\nCODE:\n```\n## List items reordering\n\n<Demo data={FormDemos.dnd} />\n```\n\nLANGUAGE: jsx\nCODE:\n```\n## Form with multiple steps\n\n<Demo data={FormDemos.stepper} />\n```\n\n----------------------------------------\n\nTITLE: Incorrect Import Order: Mantine Overriding\nDESCRIPTION: Demonstrates the incorrect order of importing CSS files, which results in Mantine styles overriding custom styles. This happens because Mantine styles are imported after custom styles, giving them higher precedence.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/styles-order.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// ❌ Wrong order – Mantine styles override your styles\nimport './styles.css';\nimport '@mantine/core/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Checking Length Constraints with Mantine Form hasLength Validator in TypeScript\nDESCRIPTION: This snippet uses hasLength validator to validate whether the length of form values (strings, arrays, or any object with a length property) falls within specified minimum and maximum ranges. It trims strings before validation. The form validates four fields with different length constraints including exact, minimum, maximum, and between min-max lengths, all managed by the useForm hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { hasLength, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    exact: '',\n    maxLength: '',\n    minLength: '',\n    minMaxLength: '',\n  },\n\n  validate: {\n    exact: hasLength(5, 'Values must have exactly 5 characters'),\n    maxLength: hasLength(\n      { max: 20 },\n      'Value must have 20 or less characters'\n    ),\n    minLength: hasLength(\n      { min: 10 },\n      'Value must have 10  or more characters'\n    ),\n    minMaxLength: hasLength(\n      { min: 10, max: 20 },\n      'Value must have 10-20 characters'\n    ),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Utility Classes to Mantine TextInput with TSX\nDESCRIPTION: Shows how to use the `classNames` prop on a Mantine `TextInput` component to apply utility CSS classes. It specifically targets the `root` and `input` parts of the component to add margin-top, background color, and text color, illustrating integration with libraries like Tailwind CSS. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/third-party-styles.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TextInput\n      classNames={{\n        root: 'mt-4',\n        input: 'bg-red-500 text-white',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Border Radius - Mantine Theme - TSX\nDESCRIPTION: Demonstrates how to set custom border radius values for different scales (`xs` through `xl`) using the `radius` property and define the global default radius using the `defaultRadius` property within the `createTheme` function. These values define the `--mantine-radius-*` CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_21\n\nLANGUAGE: TSX\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  defaultRadius: 'sm',\n  radius: {\n    xs: '0.25rem',\n    sm: '0.5rem',\n    md: '1rem',\n    lg: '2rem',\n    xl: '3rem',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Custom Fonts in Mantine Theme with CSS Fonts in TypeScript\nDESCRIPTION: This snippet shows how to create and apply a Mantine theme that uses a custom font loaded via CSS in a Next.js application. The theme sets fontFamily properties with the custom font name as a string and falls back to Mantine default fonts. It requires importing both Mantine styles and the custom CSS file containing @font-face declarations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/next-load-fonts.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createTheme,\n  DEFAULT_THEME,\n  MantineProvider,\n} from '@mantine/core';\n\nimport '@mantine/core/styles.css';\nimport './GreycliffCF/GreycliffCF.css';\n\nconst theme = createTheme({\n  fontFamily: 'Greycliff CF, sans-serif',\n  fontFamilyMonospace: 'Monaco, Courier, monospace',\n  headings: {\n    // Use default theme if you want to provide default Mantine fonts as a fallback\n    fontFamily: `Greycliff CF, ${DEFAULT_THEME.fontFamily}`,\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>Your app here</MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Debounced Callback with Mantine and React (TSX)\nDESCRIPTION: Demonstrates how to use the useDebouncedCallback hook from @mantine/hooks to perform a debounced search. It sets up React state to manage the search input, results, and loading state, with asynchronous logic to fetch and display mock search results. Dependencies include @mantine/core, @mantine/hooks, and React, and inputs/outputs are managed through the TextInput and result mapping. The debounce delay is set to 500ms, and an artificial delay is used for async simulation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Loader, Text, TextInput } from '@mantine/core';\nimport { useDebouncedCallback } from '@mantine/hooks';\n\nfunction getSearchResults(query: string): Promise<{ id: number; title: string }[]> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(\n        query.trim() === ''\n          ? []\n          : Array(5)\n              .fill(0)\n              .map((_, index) => ({ id: index, title: `${query} ${index + 1}` }))\n      );\n    }, 1000);\n  });\n}\n\nfunction Demo() {\n  const [search, setSearch] = useState('');\n  const [searchResults, setSearchResults] = useState<{ id: number; title: string }[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const handleSearch = useDebouncedCallback(async (query: string) => {\n    setLoading(true);\n    setSearchResults(await getSearchResults(query));\n    setLoading(false);\n  }, 500);\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setSearch(event.currentTarget.value);\n    handleSearch(event.currentTarget.value);\n  };\n\n  return (\n    <>\n      <TextInput\n        value={search}\n        onChange={handleChange}\n        placeholder=\"Search...\"\n        rightSection={loading && <Loader size={20} />}\n      />\n      {searchResults.map((result) => (\n        <Text key={result.id} size=\"sm\">\n          {result.title}\n        </Text>\n      ))}\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Y axis scale/domain\nDESCRIPTION: Uses 'yAxisProps' to specify the domain of the Y axis, for instance setting min and max values like '[0, 100]'. Ensures that the Y axis accurately reflects the data range for better readability.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.yScale} />\n```\n\n----------------------------------------\n\nTITLE: useStateHistory Interface Definition with TypeScript\nDESCRIPTION: This snippet defines the interfaces `UseStateHistoryHandlers` and `StateHistory` along with the `useStateHistory` function signature. These interfaces are crucial for the functionality of the `useStateHistory` hook, which manages a state variable along with its history. The `UseStateHistoryHandlers` provides functions to modify the state (set), go back and forward through history (back, forward), and reset the state.  The `StateHistory` interface holds the history of the values and the index of the current value. Requires the `@mantine/hooks` package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-state-history.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface UseStateHistoryHandlers<T> {\n  set: (value: T) => void;\n  back: (steps?: number) => void;\n  forward: (steps?: number) => void;\n  reset: () => void;\n}\n\ninterface StateHistory<T> {\n  history: T[];\n  current: number;\n}\n\nfunction useStateHistory<T>(\n  initialValue: T\n): [T, UseStateHistoryHandlers<T>, StateHistory<T>];\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useDisclosure Hook in React\nDESCRIPTION: This snippet provides the TypeScript function signature for the useDisclosure hook, documenting its expected arguments and return types. It takes an initial boolean state and an optional callbacks object, returning a tuple of the current state and handler functions. This definition clarifies usage, required parameter types, and structure for developers intending to use or extend the hook in TypeScript projects with React.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-disclosure.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useDisclosure(\n  initialState: boolean,\n  callbacks?: {\n    onOpen?(): void;\n    onClose?(): void;\n  }\n): [\n  boolean,\n  {\n    open: () => void;\n    close: () => void;\n    toggle: () => void;\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Integrating Form with TanStack Query\nDESCRIPTION: Demonstrates using form.initialize to sync form values with backend API response using TanStack Query (react-query). The form will be initialized only once even if query.data changes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const query = useQuery({\n    queryKey: ['current-user'],\n    queryFn: () => fetch('/api/users/me').then((res) => res.json()),\n  });\n\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      name: '',\n      email: '',\n    },\n  });\n\n  useEffect(() => {\n    if (query.data) {\n      // Even if query.data changes, form will be initialized only once\n      form.initialize(query.data);\n    }\n  }, [query.data]);\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming data series labels using 'label' property\nDESCRIPTION: Overrides default series 'name' labels by setting the 'label' property in each series object. Enhances label readability or localization for better user understanding.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.seriesLabels} />\n```\n\n----------------------------------------\n\nTITLE: Initializing PillsInput Component in Mantine React\nDESCRIPTION: This code snippet demonstrates the basic implementation of the `PillsInput` component. It requires the `@mantine/core` library. The `PillsInput` component is initialized without a label, making it inaccessible for screen readers. The output is a `PillsInput` component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pills-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PillsInput } from '@mantine/core';\n\n// Inaccessible input – screen reader will not announce it properly\nfunction Demo() {\n  return (\n    <PillsInput>\n      <PillsInput.Field />\n    </PillsInput>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Mantine Tabs with Next.js router\nDESCRIPTION: Demonstrates how to integrate Mantine Tabs with the Next.js router. The `useRouter` hook is used to synchronize the active tab with the URL query parameter `activeTab`. Changing the tab updates the URL, and vice versa.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// For file /tabs/[activeTab].tsx\nimport { useRouter } from 'next/router';\nimport { Tabs } from '@mantine/core';\n\nfunction Demo() {\n  const router = useRouter();\n\n  return (\n    <Tabs\n      value={router.query.activeTab as string}\n      onChange={(value) => router.push(`/tabs/${value}`)}\n    >\n      <Tabs.List>\n        <Tabs.Tab value=\"first\">First tab</Tabs.Tab>\n        <Tabs.Tab value=\"second\">Second tab</Tabs.Tab>\n      </Tabs.List>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Scrollable Sections in AppShell Navbar with AppShell.Section\nDESCRIPTION: Example showing how to create a layout with fixed header/footer sections and a scrollable middle section in an AppShell.Navbar using the AppShell.Section component with ScrollArea.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell, ScrollArea } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <AppShell navbar={{ width: 300, breakpoint: 0 }}>\n      <AppShell.Navbar>\n        <AppShell.Section>Navbar header</AppShell.Section>\n        <AppShell.Section grow component={ScrollArea}>\n          Navbar main section, it will\n        </AppShell.Section>\n        <AppShell.Section>\n          Navbar footer – always at the bottom\n        </AppShell.Section>\n      </AppShell.Navbar>\n      <AppShell.Main>Main</AppShell.Main>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Headroom Effect for AppShell Header in React (TSX)\nDESCRIPTION: Demonstrates how to create a header that hides on scroll down and reappears on scroll up (headroom effect) using the `AppShell` component. It utilizes the `useHeadroom` hook from `@mantine/hooks` to control the `collapsed` state of the `AppShell.Header` and sets `header.offset` to `false` to prevent the main content area from reserving space for the header when hidden. Manual padding-top is applied to `AppShell.Main` to account for the header height. Requires `@mantine/core` and `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell, rem } from '@mantine/core';\nimport { useHeadroom } from '@mantine/hooks';\n\nfunction Demo() {\n  const pinned = useHeadroom({ fixedAt: 120 });\n\n  return (\n    <AppShell\n      header={{ height: 60, collapsed: !pinned, offset: false }}\n      padding=\"md\"\n    >\n      <AppShell.Header>Header</AppShell.Header>\n\n      <AppShell.Main\n        pt={`calc(${rem(60)} + var(--mantine-spacing-md))`}\n      >\n        {/* Content */}\n      </AppShell.Main>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Validating with Yup using useForm\nDESCRIPTION: This code snippet showcases how to perform form validation using Yup with Mantine Form. It sets up a Yup schema for validating name, email, and age and integrates it with `useForm` using `yupResolver`. The example demonstrates the retrieval of validation errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { yupResolver } from 'mantine-form-yup-resolver';\nimport * as yup from 'yup';\nimport { useForm } from '@mantine/form';\n\nconst schema = yup.object().shape({\n  name: yup.string().min(2, 'Name should have at least 2 letters'),\n  email: yup\n    .string()\n    .required('Invalid email')\n    .email('Invalid email'),\n  age: yup\n    .number()\n    .min(18, 'You must be at least 18 to create an account'),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: yupResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  name: 'Name should have at least 2 letters',\n//  email: 'Invalid email',\n//  age: 'You must be at least 18 to create an account'\n// }\n```\n\n----------------------------------------\n\nTITLE: Adding a Right Y-Axis to Mantine Charts (TSX)\nDESCRIPTION: Example of adding a secondary Y-axis on the right side of a `LineChart` using the `withRightYAxis` prop. It demonstrates configuring axis labels (`yAxisLabel`, `rightYAxisLabel`) and assigning series to the right axis using `yAxisId: 'right'`. Applicable to `LineChart`, `BarChart`, and `AreaChart`. Dependencies include `@mantine/charts`. Assumes `data` is imported from a local `./data` file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { LineChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <LineChart\n      h={300}\n      data={data}\n      dataKey=\"name\"\n      withRightYAxis\n      yAxisLabel=\"uv\"\n      rightYAxisLabel=\"pv\"\n      series={[\n        { name: 'uv', color: 'pink.6' },\n        { name: 'pv', color: 'cyan.6', yAxisId: 'right' },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Stacked BarChart Rendering in JSX/TypeScript\nDESCRIPTION: Renders a vertically stacked bar chart by setting `type=\"stacked\"`. This example visually stacks data series along the vertical axis, illustrating aggregate amounts and individual contributions. Uses BarChartDemos.stacked demo dataset for sample data input and relies on Recharts stacked bar functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.stacked} />\n```\n\n----------------------------------------\n\nTITLE: Radio Accessibility Implementation Examples in Mantine\nDESCRIPTION: Illustrates proper and improper ways to make Radio components accessible. Demonstrates using aria-label and label props to ensure screen readers can properly identify the radio inputs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/radio.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Radio } from '@mantine/core';\n\n// Not ok, input is not labeled\nfunction Bad() {\n  return <Radio />;\n}\n\n// Ok, input is labelled by aria-label\nfunction GoodAriaLabel() {\n  return <Radio aria-label=\"My radio\" />;\n}\n\n// Ok, input is labelled by label element\nfunction GoodLabel() {\n  return <Radio label=\"My radio\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Extending dayjs with Custom Parse Format Plugin in TypeScript\nDESCRIPTION: Demonstrates how to extend the dayjs library with the 'customParseFormat' plugin. This is necessary for certain Mantine Dates components like DateInput that require custom date string parsing. This extension should ideally be done once in the application's root file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/getting-started.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport dayjs from 'dayjs';\nimport customParseFormat from 'dayjs/plugin/customParseFormat';\n\ndayjs.extend(customParseFormat);\n```\n\n----------------------------------------\n\nTITLE: Using getHotkeyHandler Function for Custom Listeners\nDESCRIPTION: This snippet demonstrates the use of the `getHotkeyHandler` function to add hotkey event listeners to any DOM node. This function is exported from the `@mantine/hooks` package. It enables adding hotkey handlers to any element, not only the document element. This gives you more control over where and how hotkeys are triggered.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hotkeys.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getHotkeyHandler } from '@mantine/hooks';\n\ndocument.body.addEventListener(\n  'keydown',\n  getHotkeyHandler([\n    ['mod+Enter', () => console.log('Submit')],\n    ['mod+S', () => console.log('Save')],\n  ])\n);\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Loader Component Types in React\nDESCRIPTION: Demonstrates the basic usage of the Mantine Loader component, showcasing the default types: 'oval', 'bars', and 'dots'. The loader type can be selected via the 'type' prop. Loaders are animated using CSS for performance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/loader.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Loader } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Loader type=\"oval\" />\n      <Loader type=\"bars\" />\n      <Loader type=\"dots\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Search Value Management in MultiSelect with React Hooks in TypeScript\nDESCRIPTION: Illustrates controlling the searchable state of the MultiSelect component by managing the search input value explicitly via useState and passing searchValue and onSearchChange props. This approach allows customizing and synchronizing the search input externally. Required dependencies include React and @mantine/core, and it is implemented in TypeScript.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/multi-select.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { MultiSelect } from '@mantine/core';\n\nfunction Demo() {\n  const [searchValue, setSearchValue] = useState('');\n  return (\n    <MultiSelect\n      searchable\n      searchValue={searchValue}\n      onSearchChange={setSearchValue}\n      data={[]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Browser APIs for Jest Testing in TSX\nDESCRIPTION: Provides code for a `jest.setup.js` file to mock common browser APIs like `window.matchMedia`, `ResizeObserver`, `window.getComputedStyle`, and `scrollIntoView`. These APIs are required by many Mantine components but are not available in the default `jsdom` environment, preventing test errors. Requires `@testing-library/jest-dom` for extended matchers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/jest.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@testing-library/jest-dom';\n\nconst { getComputedStyle } = window;\nwindow.getComputedStyle = (elt) => getComputedStyle(elt);\nwindow.HTMLElement.prototype.scrollIntoView = () => {};\n\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: jest.fn().mockImplementation((query) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: jest.fn(),\n    removeListener: jest.fn(),\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n    dispatchEvent: jest.fn(),\n  })),\n});\n\nclass ResizeObserver {\n  observe() {}\n  unobserve() {}\n  disconnect() {}\n}\n\nwindow.ResizeObserver = ResizeObserver;\n```\n\n----------------------------------------\n\nTITLE: Validating List Fields with Zod and useForm\nDESCRIPTION: This snippet focuses on validating list fields using Zod with Mantine Form. It defines a schema for a list of objects and uses `zodResolver` to connect with `useForm`. The example shows how the validation errors for the list items are structured.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { zodResolver } from 'mantine-form-zod-resolver';\nimport { z } from 'zod';\nimport { useForm } from '@mantine/form';\n\nconst listSchema = z.object({\n  list: z.array(\n    z.object({\n      name: z\n        .string()\n        .min(2, { message: 'Name should have at least 2 letters' }),\n    })\n  ),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    list: [{ name: '' }],\n  },\n  validate: zodResolver(listSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'list.0.name': 'Name should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Testing Mantine Modal Open State with React Testing Library (TSX)\nDESCRIPTION: This snippet shows a React Testing Library test that successfully verifies the open state of the AuthModal component after disabling transitions in the test setup. It simulates clicking the button to open the modal and then asserts that the modal's heading is present in the document and that the element with data-autofocus (the Username input) receives focus. This confirms the modal is rendered and interaction is possible within it. Requires the custom render function from the previous snippet.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/portals-testing.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ndescribe('AuthModal', () => {\n  it('opens modal when button is clicked', async () => {\n    render(<AuthModal />);\n    await userEvent.click(screen.getByRole('button', { name: 'Open authentication modal' }));\n    expect(screen.getByRole('heading', { name: 'Authenticate' })).toBeInTheDocument();\n    expect(screen.getByRole('textbox', { name: 'Username' })).toHaveFocus();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Validating nested object values with Mantine useForm hook in TypeScript\nDESCRIPTION: Illustrates validation of nested object fields during form interaction using useForm's validate option. The snippet defines validation functions for nested fields user.name and user.occupation enforcing minimum length constraints. It shows how to invoke generic validate() to trigger validations and access resulting errors keyed by dot-separated field paths. Requires '@mantine/form' and expects 'user' object with string fields in initial values input. Outputs validation error messages if constraints fail.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/nested.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    user: {\n      name: '',\n      occupation: '',\n    },\n  },\n\n  validate: {\n    user: {\n      name: (value) =>\n        value.length < 2 ? 'Name is too short' : null,\n      occupation: (value) =>\n        value.length < 2 ? 'Occupation is too short' : null,\n    },\n  },\n});\n\nform.validate();\nform.errors; // -> { 'user.name': 'Name is too short', 'user.occupation': 'Occupation is too short' }\n```\n\n----------------------------------------\n\nTITLE: Initializing useFocusTrap Hook in React with TypeScript\nDESCRIPTION: This snippet shows how to initialize the useFocusTrap hook within a React functional component. The hook returns a ref which should be assigned to the container element that requires focus trapping, such as modals or menus containing focusable elements. It ensures keyboard navigation focus cycles within this node. No parameters are passed, so the trap defaults to inactive.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-trap.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useFocusTrap } from '@mantine/hooks';\n\nfunction Demo() {\n  const focusTrapRef = useFocusTrap();\n\n  return (\n    <div ref={focusTrapRef}>\n      <input />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Initial Focus Element with data-autofocus in React TypeScript\nDESCRIPTION: This example configures the element that receives the initial keyboard focus when using useFocusTrap. By default, the hook focuses the first interactive element inside the container, but adding the 'data-autofocus' attribute shifts initial focus to that specific element. This control is important for usability and accessibility in modal or dialog components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-trap.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useFocusTrap } from '@mantine/hooks';\n\nfunction Demo() {\n  const focusTrapRef = useFocusTrap();\n\n  return (\n    <div ref={focusTrapRef}>\n      <input />\n      {/* Second input in modal will have initial focus */}\n      <input data-autofocus />\n      <input />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a custom theme with createTheme function\nDESCRIPTION: Demonstrates how to create a custom theme using the createTheme function, which provides autocomplete for all theme properties. This example sets custom font family and primary color.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  fontFamily: 'sans-serif',\n  primaryColor: 'orange',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <App />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Mantine Modal Close State with React Testing Library (TSX)\nDESCRIPTION: This snippet shows a React Testing Library test that successfully verifies the closed state of the AuthModal component after submitting the form within it. It simulates opening the modal, typing into the input fields, clicking the submit button, and then asserts that the modal's heading is no longer present in the document using queryByRole and not.toBeInTheDocument(). This confirms the modal closes as expected upon form submission. Requires the custom render function from the snippet that disables transitions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/portals-testing.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\ndescribe('AuthModal', () => {\n  it('closes modal after the form has been submitted', async () => {\n    render(<AuthModal />);\n    await userEvent.click(screen.getByRole('button', { name: 'Open authentication modal' }));\n    await userEvent.type(screen.getByRole('textbox', { name: 'Username' }), 'john.doe');\n    await userEvent.type(screen.getByLabelText('Password'), 'password');\n    await userEvent.click(screen.getByRole('button', { name: 'Log in' }));\n    expect(screen.queryByRole('heading', { name: 'Authenticate' })).not.toBeInTheDocument();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Importing CopyButton Components in React\nDESCRIPTION: This snippet imports necessary components and data for the page. It imports `CopyButtonDemos` from `@docs/demos`, `Layout` from `@/layout`, and `MDX_DATA` from `@/mdx`.  These imports are essential for rendering the `CopyButton` component examples and structuring the page layout based on the data provided in `MDX_DATA.CopyButton`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/copy-button.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { CopyButtonDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Using children Prop for Custom Loader Content in React\nDESCRIPTION: Illustrates using the 'children' prop on the Loader component to render custom content (like text or icons) instead of the default animation. This is particularly useful when customizing the loader appearance within other Mantine components like Button or LoadingOverlay by passing props via 'loaderProps'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/loader.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { LoadingOverlay, Box, MantineProvider, Text } from '@mantine/core';\nimport { IconSettings } from '@tabler/icons-react'; // Example icon\n\nfunction App() {\n  return (\n    <MantineProvider>\n      <Box style={{ position: 'relative', height: 200 }}>\n        <LoadingOverlay\n          visible\n          zIndex={1000}\n          overlayProps={{ radius: 'sm', blur: 2 }}\n          loaderProps={{\n            children: (\n              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n                <IconSettings size={30} style={{ marginBottom: 8 }} />\n                <Text size=\"sm\">Please wait...</Text>\n              </div>\n            ),\n            // Size and color props for Loader itself are ignored when children are provided\n          }}\n        />\n        {/* Content underneath the overlay */}\n        <Text>Content area</Text>\n      </Box>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Colors via Theme Object in React Components\nDESCRIPTION: Demonstrates how to access color values using the useMantineTheme hook in a React component. The example shows accessing specific color shades by index to style component elements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/colors.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMantineTheme } from '@mantine/core';\n\nfunction Demo() {\n  const theme = useMantineTheme();\n\n  return (\n    <div\n      style={{\n        backgroundColor: theme.colors.blue[1],\n        color: theme.colors.blue[9],\n      }}\n    >\n      This is a blue theme\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Storybook via CLI Command\nDESCRIPTION: This snippet provides the command to initialize Storybook in a project using npm. It sets up necessary configuration files and dependencies to start authoring stories with the latest Storybook version.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/storybook.mdx#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpx storybook@latest init\n```\n\n----------------------------------------\n\nTITLE: Importing Demo Components in Next.js Layout\nDESCRIPTION: React/Next.js import statements for organizing and rendering demo components including Notifications, SemiCircleProgress, and Tree components in a layout structure with MDX data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-12-0.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {\n  NotificationsDemos,\n  SemiCircleProgressDemos,\n  TreeDemos,\n} from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Changelog7120);\n```\n\n----------------------------------------\n\nTITLE: Using useDrawersStack Hook for Multiple Drawers\nDESCRIPTION: This snippet illustrates the use of the 'useDrawersStack' hook to manage multiple drawer instances simultaneously. It provides functions to open, close, toggle, and register drawers, enabling complex drawer stack management with focus and z-index control.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/drawer.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Drawer, useDrawersStack } from '@mantine/core';\n\nfunction Demo() {\n  const stack = useDrawersStack(['first', 'second']);\n\n  return (\n    <>\n      <Drawer {...stack.register('first')}>First</Drawer>\n      <Drawer {...stack.register('second')}>Second</Drawer>\n      <button onClick={() => stack.open('first')}>Open first</button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering accessible Mantine Progress components with aria attributes in TSX\nDESCRIPTION: Provides example implementations of the Mantine Progress component emphasizing accessibility using ARIA attributes such as aria-label, role=\"progressbar\", aria-valuemin, aria-valuemax, and aria-valuenow. Demonstrates both a simple Progress component and a compound component approach with Progress.Root and Progress.Section. Requires @mantine/core installed and relevant imports. The value prop indicates the progress percentage, and aria-label provides a textual label for screen readers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/progress.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Progress } from '@mantine/core';\n\nfunction Demo() {\n  return <Progress aria-label=\"Uploading progress\" value={10} />;\n}\n\nfunction DemoCompound() {\n  return (\n    <Progress.Root>\n      <Progress.Section aria-label=\"Uploading progress\" value={10} />\n    </Progress.Root>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using the use-matches Hook for Responsive Styles in React\nDESCRIPTION: Shows how to use the new use-matches hook from @mantine/core to apply responsive styles based on multiple breakpoints, providing an alternative to use-media-query.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.9.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, useMatches } from '@mantine/core';\n\nfunction Demo() {\n  const color = useMatches({\n    base: 'blue.9',\n    sm: 'orange.9',\n    lg: 'red.9',\n  });\n\n  return (\n    <Box bg={color} c=\"white\" p=\"xl\">\n      Box with color that changes based on screen size\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting data-mantine-color-scheme attribute on HTML element when MantineProvider mounts\nDESCRIPTION: This snippet explains how MantineProvider sets the data attribute 'data-mantine-color-scheme' on the <html> element based on user selection or default value. This attribute influences component styling according to the current color scheme. Dependencies include Mantine's theming system.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nWhen the MantineProvider is mounted, it sets a `data-mantine-color-scheme`\nattribute on the `<html />` element to the value that the user has selected previously or to the value of `defaultColorScheme` prop.\nThe `data-mantine-color-scheme` attribute is used in all components' styles to determine which colors the component should use.\n```\n\n----------------------------------------\n\nTITLE: Using rem and em Utility Functions in CSS Files with postcss-preset-mantine\nDESCRIPTION: Demonstrates the usage of rem() and em() as CSS functions directly in style files, enabled by postcss-preset-mantine PostCSS plugin. This setup allows conversion of px to rem/em within regular CSS and supports media queries. Requires installation and configuration of postcss-preset-mantine in the build system. Inputs are standard CSS declarations and expressions using rem()/em(); outputs are CSS with units replaced as per plugin rules.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rem.mdx#_snippet_5\n\nLANGUAGE: css\nCODE:\n```\n.demo {\n  font-size: rem(16px);\n\n  @media (min-width: em(320px)) {\n    font-size: rem(32px);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependent Component Styles in Mantine using TypeScript\nDESCRIPTION: This snippet demonstrates how to import CSS files for Mantine components that have style dependencies. For example, the Button component depends on UnstyledButton styles, so both '@mantine/core/styles/UnstyledButton.css' and '@mantine/core/styles/Button.css' must be imported. No special dependencies other than Mantine are required. Both imports are necessary for Button to render correctly; omitting UnstyledButton may result in incomplete styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-files-list.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles/UnstyledButton.css';\nimport '@mantine/core/styles/Button.css';\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Polymorphic Component Usage with BackgroundImage in JSX\nDESCRIPTION: Shows how the BackgroundImage component can be used polymorphically, changing from its default div element to a button element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/background-image.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Polymorphic\n  defaultElement=\"div\"\n  changeToElement=\"button\"\n  component=\"BackgroundImage\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Enabling Test Environment with MantineProvider in React (TypeScript)\nDESCRIPTION: This snippet demonstrates using the MantineProvider component's env prop to enable a test-specific environment configuration in a React application. Setting env=\"test\" disables transitions and portals that could interfere with unit testing frameworks like Jest or Vitest, making it easier to test Mantine components by avoiding delayed mount/unmount behavior and DOM manipulation outside the main component tree. The snippet uses TypeScript with TSX syntax, showing how to wrap an app's content with MantineProvider configured for test purposes. Usage is restricted to testing environments and is not recommended in production or with end-to-end tools like Cypress or Playwright.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider env=\"test\">\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Segment Stroke Color in DonutChart with Mantine (TypeScript/React)\nDESCRIPTION: This snippet demonstrates how to use the DonutChart component from the @mantine/charts package and customize the stroke color of segments using the strokeColor prop. The data prop receives an array (empty here for demonstration), and strokeColor accepts values from the Mantine theme palette (e.g., \\\"red.5\\\") or any valid CSS color string. To use this, install @mantine/charts and ensure the component is rendered within a React application. The chart renders a donut chart without data and visually highlights the stroke color of segments. No chart segments are drawn in this example as data is empty.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/donut-chart.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { DonutChart } from '@mantine/charts';\n\nfunction Demo() {\n  return <DonutChart data={[]} strokeColor=\"red.5\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Demo for Blockquote Component - React\nDESCRIPTION: This snippet renders a demo of the Blockquote component. It uses the Demo component and passes it the data for the Blockquote component, which provides the necessary implementation to render the Blockquote demo.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/blockquote.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={BlockquoteDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Rendering JsonInput in Disabled State Demo\nDESCRIPTION: This snippet presents a demonstration of the JsonInput component rendered in a disabled state, illustrating how the component appears and behaves when user input is restricted. Useful for documentation of read-only or disabled scenarios.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={JsonInputDemos.disabled} />\n```\n\n----------------------------------------\n\nTITLE: Configuring Mantine Breakpoints in TypeScript/React\nDESCRIPTION: Demonstrates how to define custom breakpoint values within a Mantine theme object using `createTheme`. This custom theme is then applied to the application tree via `MantineProvider`, affecting all components that use theme breakpoints. Breakpoints are defined as key-value pairs where keys are breakpoint names (xs, sm, etc.) and values are CSS units (em).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/responsive.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  breakpoints: {\n    xs: '30em',\n    sm: '48em',\n    md: '64em',\n    lg: '74em',\n    xl: '90em',\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing BarChart Colors with getBarColor - Mantine Charts in TypeScript\nDESCRIPTION: Shows how to use the getBarColor prop on Mantine's BarChart component to assign bar colors dynamically based on the value. Requires @mantine/charts and a data array. The getBarColor function receives the bar value and series and returns a color string reference from the Mantine theme or any CSS color. Example distinguishes bars by value using 'teal.8' and 'red.8'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={data}\n      dataKey=\"month\"\n      getBarColor={(value) => (value > 700 ? 'teal.8' : 'red.8')}\n      series={[{ name: 'Laptops', color: 'gray.6' }]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Styling nested elements with Mantine styles prop\nDESCRIPTION: Shows how to customize deeply nested elements within Mantine components using the styles prop to target specific component parts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dynamic-css-styles.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\ninterface DemoProps {\n  color: string;\n}\n\nfunction Demo({ color }: DemoProps) {\n  return (\n    <Button styles={{ label: { backgroundColor: color } }}>\n      My demo\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronizing multiple LineCharts\nDESCRIPTION: Uses 'lineChartProps' with 'syncId' to link multiple charts, enabling synchronized tooltips and interactions. Facilitates comparative data visualization across multiple charts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_24\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.sync} />\n```\n\n----------------------------------------\n\nTITLE: Defining UseFieldReturnType Interface TypeScript\nDESCRIPTION: This code defines the `UseFieldReturnType` interface, which describes the object returned by the `use-field` hook.  It specifies methods and properties for interacting with the input field.  Methods include `getInputProps`, `getValue`, `setValue`, `reset`, `validate`, `isTouched`, and `isDirty`. Properties include `isValidating`, `error`, and `key`. The type parameter ValueType specifies the type of input value.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-field.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface UseFieldReturnType<ValueType> {\n  /** Returns props to pass to the input element */\n  getInputProps: () => {\n    /* props for input component */\n  };\n\n  /** Returns current input value */\n  getValue: () => ValueType;\n\n  /** Sets input value to the given value */\n  setValue: (value: ValueType) => void;\n\n  /** Resets field value to initial state, sets touched state to false, sets error to null */\n  reset: () => void;\n\n  /** Validates current input value when called */\n  validate: () => Promise<React.ReactNode | void>;\n\n  /** Set to true when async validate function is called, stays true until the returned promise resolves */\n  isValidating: boolean;\n\n  /** Current error message */\n  error: React.ReactNode;\n\n  /** Sets error message to the given react node */\n  setError: (error: React.ReactNode) => void;\n\n  /** Returns true if the input has been focused at least once */\n  isTouched: () => boolean;\n\n  /** Returns true if input value is different from the initial value */\n  isDirty: () => boolean;\n\n  /** Resets touched state to false */\n  resetTouched: () => void;\n\n  /** key that should be added to the input when mode is uncontrolled */\n  key: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Notification Styles (CSS Import)\nDESCRIPTION: This code snippet provides the necessary import statements to include the default CSS styles for the `@mantine/core` and `@mantine/notifications` packages. Importing these styles is crucial for ensuring that Mantine notifications are positioned and styled correctly on the screen, fixing issues like incorrect placement. These imports should typically be added to the application's main entry file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/notifications-missing-styles.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport '@mantine/core/styles.css';\nimport '@mantine/notifications/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Adding Axis Labels to BarChart Axes in JSX/TypeScript\nDESCRIPTION: Demonstrates how to apply text labels to the x-axis and y-axis using `xAxisLabel` and `yAxisLabel` props, enhancing chart readability. Uses BarChartDemos.axisLabels sample data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_11\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.axisLabels} />\n```\n\n----------------------------------------\n\nTITLE: Example of custom component that will not work with Tooltip\nDESCRIPTION: This example shows code that will not work with Tooltip because the custom component doesn't support the ref prop, which is required for the Tooltip to position correctly relative to the target element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tooltip.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Example of code that WILL NOT WORK\nimport { Tooltip } from '@mantine/core';\n\nfunction MyComponent() {\n  return <div>My component</div>;\n}\n\n// This will not work – MyComponent does not support ref\nfunction Demo() {\n  return (\n    <Tooltip label=\"Does not work\">\n      <MyComponent />\n    </Tooltip>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Styles.css for Native CSS\nDESCRIPTION: This snippet demonstrates how to import native CSS files provided by Mantine packages. It's essential for using native CSS instead of CSS-in-JS and is used to improve performance and reduce bundle size. This approach allows for Mantine components to be used in environments where CSS-in-JS is not supported.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Context Modals with ModalsProvider in TypeScript\nDESCRIPTION: Defines a context modal component (TestModal) accepting typed inner props and context for modal management. This component includes closing logic via context.closeModal and renders custom content with a close button. The modals are registered in ModalsProvider's modals prop by key. Enables modular and reusable modals referenced by keys for dynamic opening.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/modals.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Text } from '@mantine/core';\nimport { ContextModalProps, ModalsProvider } from '@mantine/modals';\n\nconst TestModal = ({\n  context,\n  id,\n  innerProps,\n}: ContextModalProps<{ modalBody: string }>) => (\n  <>\n    <Text size=\"sm\">{innerProps.modalBody}</Text>\n    <Button fullWidth mt=\"md\" onClick={() => context.closeModal(id)}>\n      Close modal\n    </Button>\n  </>\n);\n\nfunction Demo() {\n  return (\n    <ModalsProvider\n      modals={{ demonstration: TestModal /* ...other modals */ }}\n    >\n      {/* Your app here */}\n    </ModalsProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing getTreeExpandedState function\nDESCRIPTION: Imports the `getTreeExpandedState` function from '@mantine/core'. This function is used for dynamically generating expanded state objects for the tree, enabling control over the initial expansion of nodes based on the data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getTreeExpandedState } from '@mantine/core';\n```\n\n----------------------------------------\n\nTITLE: Importing Blockquote Components and Layout - React\nDESCRIPTION: This snippet imports the BlockquoteDemos component from '@docs/demos', the Layout component from '@/layout', and the MDX_DATA from '@/mdx'. These components are used for displaying demo content and structuring the layout of the page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/blockquote.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { BlockquoteDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: useThrottledValue Definition\nDESCRIPTION: Defines the signature of the useThrottledValue hook. It accepts a value of type T and a wait time in milliseconds and returns a throttled value of type T.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-throttled-value.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useThrottledValue<T>(value: T, wait: number): T;\n```\n\n----------------------------------------\n\nTITLE: Implementing Gatsby SSR APIs with MantineProvider in TypeScript\nDESCRIPTION: Exports two Gatsby SSR API functions: 'onPreRenderHTML' to inject a ColorSchemeScript into the <head> components for color scheme management, and 'wrapPageElement' to wrap each page element with MantineProvider using the custom theme. This enables consistent Mantine theming across server-side rendered pages. The file is named 'gatsby-ssr.tsx' and depends on '@mantine/core' and the local theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/gatsby.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\nimport { theme } from './src/theme';\n\nexport const onPreRenderHTML = ({\n  getHeadComponents,\n  replaceHeadComponents,\n}) => {\n  const headComponents = getHeadComponents();\n  replaceHeadComponents([\n    ...headComponents,\n    <ColorSchemeScript key=\"color-scheme-script\" />,\n  ]);\n};\n\nexport const wrapPageElement = ({ element }) => {\n  return <MantineProvider theme={theme}>{element}</MantineProvider>;\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Initial Touched and Dirty Values\nDESCRIPTION: This snippet demonstrates setting initial touched and dirty states for form fields using `initialTouched` and `initialDirty`. It shows how to initialize the touched and dirty states for the form with specific values. It uses the same field path format as errors and needs `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/status.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { a: 1, nested: { field: '' } },\n  initialTouched: { a: true, 'nested.field': true },\n  initialDirty: { a: true, 'nested.field': true },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Styles API to JsonInput Component Demo\nDESCRIPTION: This snippet demonstrates integrating the Styles API with JsonInput, enabling customization of the component's styles through style selectors. It helps developers understand how to override or extend default styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n<StylesApiSelectors component=\"JsonInput\" />\n```\n\n----------------------------------------\n\nTITLE: Implementing external storage management for color scheme (TypeScript)\nDESCRIPTION: This snippet provides an interface and example implementation for custom external storage management of color scheme, such as localStorage or other storage mechanisms. The `MantineColorSchemeManager` interface defines methods to get, set, subscribe, unsubscribe, and clear color scheme values. The example shows a localStorage-based manager with event handling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface MantineColorSchemeManager {\n  get: (defaultValue: MantineColorScheme) => MantineColorScheme;\n  set: (value: MantineColorScheme) => void;\n  subscribe: (\n    onUpdate: (colorScheme: MantineColorScheme) => void\n  ) => void;\n  unsubscribe: () => void;\n  clear: () => void;\n}\n\n// Example localStorage-based implementation\nexport function localStorageColorSchemeManager({\n  key = 'mantine-color-scheme',\n}: { key?: string } = {}): MantineColorSchemeManager {\n  let handleStorageEvent: (event: StorageEvent) => void;\n\n  return {\n    get: (defaultValue) => {\n      if (typeof window === 'undefined') {\n        return defaultValue;\n      }\n      try {\n        return (\n          (window.localStorage.getItem(key) as MantineColorScheme) ||\n          defaultValue\n        );\n      } catch {\n        return defaultValue;\n      }\n    },\n    set: (value) => {\n      try {\n        window.localStorage.setItem(key, value);\n      } catch (error) {\n        // handle error\n      }\n    },\n    subscribe: (onUpdate) => {\n      handleStorageEvent = (event) => {\n        if (\n          event.storageArea === window.localStorage &&\n          event.key === key\n        ) {\n          // Validate and update\n          isMantineColorScheme(event.newValue) &&\n            onUpdate(event.newValue);\n        }\n      };\n      window.addEventListener('storage', handleStorageEvent);\n    },\n    unsubscribe: () => {\n      window.removeEventListener('storage', handleStorageEvent);\n    },\n    clear: () => {\n      window.localStorage.removeItem(key);\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: DateTimePicker props documentation and feature overview\nDESCRIPTION: This section describes the supported props of the DateTimePicker component, including features like seconds display, value formatting, disabling, input customization, clear button, mode switching to modal, and accessibility enhancements. It guides developers on customizing the component for different use cases.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Customizing Component Variants with theme.variantColorResolver in Mantine (TSX)\nDESCRIPTION: Implements a custom `variantColorResolver` function to modify the appearance of component variants. It overrides the default `filled` variant for 'lime' color, completely replaces the `light` variant logic, and adds a new `danger` variant. The resolver is then passed to the `MantineProvider` theme, affecting components like `Button`. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  Button,\n  darken,\n  defaultVariantColorsResolver,\n  Group,\n  MantineProvider,\n  parseThemeColor,\n  rem,\n  rgba,\n  VariantColorsResolver,\n} from '@mantine/core';\n\nconst variantColorResolver: VariantColorsResolver = (input) => {\n  const defaultResolvedColors = defaultVariantColorsResolver(input);\n  const parsedColor = parseThemeColor({\n    color: input.color || input.theme.primaryColor,\n    theme: input.theme,\n  });\n\n  // Override some properties for variant\n  if (parsedColor.isThemeColor && parsedColor.color === 'lime' && input.variant === 'filled') {\n    return { ...defaultResolvedColors, color: 'var(--mantine-color-black)' };\n  }\n\n  // Completely override variant\n  if (input.variant === 'light') {\n    return {\n      background: rgba(parsedColor.value, 0.1),\n      hover: rgba(parsedColor.value, 0.15),\n      border: `${rem(1)} solid ${parsedColor.value}`,\n      color: darken(parsedColor.value, 0.1),\n    };\n  }\n\n  // Add new variants support\n  if (input.variant === 'danger') {\n    return {\n      background: 'var(--mantine-color-red-9)',\n      hover: 'var(--mantine-color-red-8)',\n      color: 'var(--mantine-color-white)',\n      border: 'none',\n    };\n  }\n\n  return defaultResolvedColors;\n};\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={{ variantColorResolver }}>\n      <Group>\n        <Button color=\"lime.4\" variant=\"filled\">\n          Lime filled button\n        </Button>\n\n        <Button color=\"orange\" variant=\"light\">\n          Orange light button\n        </Button>\n\n        <Button variant=\"danger\">Danger button</Button>\n      </Group>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Form Touch Behavior with useForm touchTrigger Option in TypeScript React\nDESCRIPTION: Shows how to configure the newly added touchTrigger option in Mantine's useForm hook to customize when form fields become 'touched'. The 'focus' option makes a field considered touched only on focus events, while 'change' (default) triggers on value change or focus. The example demonstrates form state changes and usage of getInputProps for focus handling. Requires React and @mantine/form package. Enables finer control over form validation UX.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { a: 1 },\n  touchTrigger: 'focus',\n});\n\nform.isTouched('a'); // -> false\nform.setFieldValue('a', 2);\nform.isTouched('a'); // -> false\n\n// onFocus is called automatically when the user focuses the field\nform.getInputProps('a').onFocus();\nform.isTouched('a'); // -> true\n```\n\n----------------------------------------\n\nTITLE: FunnelChart Component Example - React\nDESCRIPTION: This code snippet demonstrates the basic usage of the `FunnelChart` component from `@mantine/charts`. It renders an empty FunnelChart with a red stroke color. The `FunnelChart` component depends on the `@mantine/charts` library.  It accepts data in the `data` prop which is an array, in this example it's an empty array. The `strokeColor` prop is used to set the color of the stroke around the chart segments. Expected output is a funnel chart with red stroke.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/funnel-chart.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { FunnelChart } from '@mantine/charts';\n\nfunction Demo() {\n  return <FunnelChart data={[]} strokeColor=\"red.5\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Color Tuples Using Mantine colorsTuple Function in TypeScript\nDESCRIPTION: Demonstrates the usage of Mantine's colorsTuple utility to generate uniform color tuples for use in theme creation. This allows a single color to be expanded into a 10-shade tuple or convert dynamic string arrays into Mantine-compatible color tuples. Dependencies include Mantine Core and React. Inputs include either a color string or array of strings with exactly 10 color values, and output is a theme colors object with customized color tuples suitable for consistent theming across components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.7.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { colorsTuple, createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    custom: colorsTuple('#FFC0CB'),\n    dynamic: colorsTuple(Array.from({ length: 10 }, (_, index) => '#FFC0CB')),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Responsive AppShell Header Height in React (TSX)\nDESCRIPTION: Illustrates setting a responsive height for the `AppShell.Header` by passing an object to the `header.height` prop. The object keys represent Mantine theme breakpoints (`base`, `sm`, `lg`), and the values specify the header height for each corresponding viewport width range. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// Height is an object with breakpoints:\n// - height is 48 when viewport width is < theme.breakpoints.sm\n// - height is 60 when viewport width is >= theme.breakpoints.sm and < theme.breakpoints.lg\n// - height is 76 when viewport width is >= theme.breakpoints.lg\nfunction Demo() {\n  return (\n    <AppShell header={{ height: { base: 48, sm: 60, lg: 76 } }}>\n      <AppShell.Header>Header</AppShell.Header>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Box Component in React/TSX\nDESCRIPTION: Demonstrates using the Mantine 'Box' component to render an element. It utilizes style props ('bg' for background color, 'my' for vertical margin) for styling, the 'component' prop to render it as an anchor tag ('a'), and passes the 'href' attribute. Requires importing 'Box' from '@mantine/core'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/box.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box bg=\"red.5\" my=\"xl\" component=\"a\" href=\"/\">\n      My component\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Emotion SX Prop in Vite\nDESCRIPTION: This snippet demonstrates the usage of the `sx` prop with the `Box` component from `@mantine/core` to apply custom styles using Emotion.  The `sx` prop receives a function that takes `theme` and `u` (for breakpoints) as arguments. This allows for dynamic styling based on the current theme and provides conditional styles. It shows how to use theme variables for styling, along with light/dark mode support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      sx={(theme, u) => ({\n        padding: 40,\n\n        [u.light]: {\n          backgroundColor: theme.colors.blue[0],\n          color: theme.colors.blue[9],\n\n          '&:hover': {\n            backgroundColor: theme.colors.blue[1],\n          },\n        },\n      })}\n    >\n      Box with emotion sx prop\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Box with Style Props and Unit Conversion in React (TypeScript)\nDESCRIPTION: Demonstrates Mantine's automatic conversion of px values to rem in style props such as width (w) and height (h) for a Box component. Numeric prop values are interpreted as pixels then rendered in rem, ensuring scaling with the theme's scale. Requires @mantine/core. Props accept numbers (px) or valid CSS strings. Output is a scaled Box component with calculated CSS values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rem.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  // width: calc(2rem * var(--mantine-scale))\n  // height: calc(1rem * var(--mantine-scale))\n  return <Box w={32} h={16} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Testing Utilities and Custom Render (TSX)\nDESCRIPTION: This snippet is a testing utilities index file that re-exports all relevant functions from @testing-library/react, the custom render helper, and the userEvent simulation utility. This enables test files to import everything needed for component testing from a single location. Dependencies required: @testing-library/react, ./render (custom helper), @testing-library/user-event. There are no input or output parameters, as this is a utility barrel file. Place it at ./testing-utils/index.ts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vitest.mdx#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\nimport userEvent from '@testing-library/user-event';\n\nexport * from '@testing-library/react';\nexport { render } from './render';\nexport { userEvent };\n```\n\n----------------------------------------\n\nTITLE: Setting Static Grid and Text Colors for Mantine AreaChart (TSX)\nDESCRIPTION: Demonstrates setting static `gridColor` and `textColor` props directly on the Mantine `AreaChart` component in TSX. This approach is suitable for applications with a single color scheme, overriding theme-based CSS variables. The example configures a stacked area chart with specific gray colors for grid lines and text.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/area-chart.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AreaChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <AreaChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      type=\"stacked\"\n      gridColor=\"gray.5\"\n      textColor=\"gray.9\"\n      series={[\n        { name: 'Apples', color: 'indigo.6' },\n        { name: 'Oranges', color: 'blue.6' },\n        { name: 'Tomatoes', color: 'teal.6' },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Overlay Gradient Demo in Mantine React - JSX\nDESCRIPTION: This code displays a demonstration of the Overlay component when applying a `gradient` background. The Demo component receives demo configuration via the `OverlayDemos.gradient` data object. Inputs/outputs and dependencies mirror those in the usage demo, focusing specifically on gradient background customization through props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/overlay.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={OverlayDemos.gradient} />\n```\n\n----------------------------------------\n\nTITLE: Defining useValidatedState Mantine Hook TSX\nDESCRIPTION: Provides the TypeScript definition for the `useValidatedState` hook. It specifies the hook's parameters: `initialValue`, a `validation` function, and an optional `initialValidationState`. It details the structure of the returned tuple: an object containing `value`, `lastValidValue`, and `valid`, and a state setter function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-validated-state.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useValidatedState<T>(\n  initialValue: T,\n  validation: (value: T) => boolean,\n  initialValidationState?: boolean\n): [\n  {\n    value: T;\n    lastValidValue: T;\n    valid: boolean;\n  },\n  (val: T) => void,\n];\n```\n\n----------------------------------------\n\nTITLE: Rendering a Data-Driven Table with Table and TableData in Mantine (TypeScript/React)\nDESCRIPTION: Demonstrates populating a Mantine Table component using the new data prop with TableData for declarative row and column generation. Requires '@mantine/core'. The tableData object specifies the caption, header row, and multiple body rows. Output is a fully populated HTML table element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Table, TableData } from '@mantine/core';\n\nconst tableData: TableData = {\n  caption: 'Some elements from periodic table',\n  head: ['Element position', 'Atomic mass', 'Symbol', 'Element name'],\n  body: [\n    [6, 12.011, 'C', 'Carbon'],\n    [7, 14.007, 'N', 'Nitrogen'],\n    [39, 88.906, 'Y', 'Yttrium'],\n    [56, 137.33, 'Ba', 'Barium'],\n    [58, 140.12, 'Ce', 'Cerium'],\n  ],\n};\n\nfunction Demo() {\n  return <Table data={tableData} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Series Labels in BarChart, JSX/TypeScript\nDESCRIPTION: Shows how to override default series labels (which use the series `name` property) via the `label` property within series objects. Allows customization of labels shown in the chart visual or legend. Demonstrated with BarChartDemos.seriesLabels data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_9\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.seriesLabels} />\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Input Component for Mantine Forms (TypeScript)\nDESCRIPTION: Provides an example structure for a custom input component designed to work with `form.getInputProps`. The `CustomInput` component accepts props like `value`, `defaultValue`, `onChange`, `onFocus`, `onBlur`, and `error`, which are standard props returned by `getInputProps`. It demonstrates passing these props to a native `<input>` element and conditionally rendering an error message.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/get-input-props.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ninterface CustomInputProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;\n  onFocus?: (event: React.FocusEvent<HTMLInputElement>) => void;\n  onBlur?: (event: React.FocusEvent<HTMLInputElement>) => void;\n  error?: string;\n}\n\nexport function CustomInput({\n  value,\n  defaultValue,\n  onChange,\n  onFocus,\n  onBlur,\n  error,\n}: CustomInputProps) {\n  return (\n    <div>\n      <input\n        value={value}\n        defaultValue={defaultValue}\n        onChange={onChange}\n        onFocus={onFocus}\n        onBlur={onBlur}\n      />\n      {error && <div>{error}</div>}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Initial Values with form.setInitialValues in Mantine\nDESCRIPTION: Demonstrates using the form.setInitialValues method to programmatically update the form’s initial values after initialization, ensuring the form reset and dirty state calculations are synchronized with fetched data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    initialValues: {\n      name: '',\n      email: '',\n    },\n  });\n\n  useEffect(() => {\n    fetch('/api/user')\n      .then((res) => res.json())\n      .then((data) => {\n        // Update initial values after form was initialized\n        // These values will be used in form.reset\n        // and to compare values to get dirty state\n        form.setInitialValues(data);\n        form.setValues(data);\n      });\n  }, []);\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Tabs with Mantine\nDESCRIPTION: Demonstrates how to create controlled Tabs component with Mantine, managing active tab state using `useState` hook. The `value` and `onChange` props are used to control the active tab and update the state on tab change. This approach is useful when you need to synchronize the Tabs state with other parts of the application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState } from 'react';\nimport { Tabs } from '@mantine/core';\n\nfunction Demo() {\n  const [activeTab, setActiveTab] = useState<string | null>('first');\n\n  return (\n    <Tabs value={activeTab} onChange={setActiveTab}>\n      <Tabs.List>\n        <Tabs.Tab value=\"first\">First tab</Tabs.Tab>\n        <Tabs.Tab value=\"second\">Second tab</Tabs.Tab>\n      </Tabs.List>\n\n      <Tabs.Panel value=\"first\">First panel</Tabs.Panel>\n      <Tabs.Panel value=\"second\">Second panel</Tabs.Panel>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Validating List Fields with Valibot and Mantine Form in TypeScript\nDESCRIPTION: Shows how to validate arrays or lists of objects using `valibotResolver`. Defines a Valibot schema using `v.array` containing a `v.object` schema for list items and integrates it with the `validate` option in `useForm`. Demonstrates the error structure (using dot and index notation for list fields) accessed via `form.errors` after validation. Requires `mantine-form-valibot-resolver`, `valibot`, and `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { valibotResolver } from 'mantine-form-valibot-resolver';\nimport * as v from 'valibot';\nimport { useForm } from '@mantine/form';\n\nconst listSchema = v.object({\n  list: v.array(\n    v.object({\n      name: v.pipe(\n        v.string(),\n        v.minLength(2, 'Name should have at least 2 letters')\n      ),\n    })\n  ),\n});\n\nconst form = useForm({\n  initialValues: {\n    list: [{ name: '' }],\n  },\n  validate: valibotResolver(listSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'list.0.name': 'Name should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Adding Typesafety to Context Modals in TypeScript with Module Declaration\nDESCRIPTION: Enhances typesafety by declaring a module augmentation for '@mantine/modals', overriding MantineModalsOverride interface with a strongly typed modals object. This enables TypeScript to enforce modal keys and innerProps types, improving developer experience and preventing runtime errors when using openContextModal. ModalsProvider receives the typed modals object.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/modals.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst TestModal = ({\n  context,\n  id,\n  innerProps,\n}: ContextModalProps<{ modalBody: string }>) => (\n  <>\n    <Text size=\"sm\">{innerProps.modalBody}</Text>\n    <Button fullWidth mt=\"md\" onClick={() => context.closeModal(id)}>\n      Close modal\n    </Button>\n  </>\n);\nconst modals = {\n  demonstration: TestModal,\n  /* ...other modals */\n};\ndeclare module '@mantine/modals' {\n  export interface MantineModalsOverride {\n    modals: typeof modals;\n  }\n}\nfunction Demo() {\n  return (\n    <ModalsProvider modals={modals}>\n      {/* Your app here */}\n    </ModalsProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Form State Outside Form Components - Mantine (TypeScript)\nDESCRIPTION: Provides an example for updating and resetting a form state from a component that does not own the form instance. It fetches data asynchronously and calls setValues on globally accessible form actions, and includes a button to reset the form. This demonstrates how global form actions facilitate cross-component form state management. Dependencies: React (useEffect), @mantine/core (Button), form actions exported elsewhere.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-2-0.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEffect } from 'react';\nimport { Button } from '@mantine/core';\nimport { demoFormActions } from './demoFormActions';\n\nfunction ExternalComponent() {\n  useEffect(() => {\n    fetch('/api/user')\n      .then((res) => res.json())\n      .then((res) =>\n        demoFormActions.setValues({\n          name: res.name,\n          age: res.age,\n        })\n      );\n  }, []);\n\n  return (\n    <Button onClick={() => demoFormActions.reset()}>\n      Reset demo form\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Popover State with React Hooks\nDESCRIPTION: This code snippet demonstrates how to control the state of a Mantine Popover component using React's `useState` hook. The `opened` state variable determines whether the Popover is visible, and the `setOpened` function is used to toggle its state. A button is used as the `Popover.Target`, and its `onClick` handler updates the `opened` state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/popover.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Popover } from '@mantine/core';\n\nfunction Demo() {\n  const [opened, setOpened] = useState(false);\n  return (\n    <Popover opened={opened} onChange={setOpened}>\n      <Popover.Target>\n        <Button onClick={() => setOpened((o) => !o)}>\n          Toggle popover\n        </Button>\n      </Popover.Target>\n\n      <Popover.Dropdown>Dropdown</Popover.Dropdown>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Dynamic Color Palettes with @mantine/colors-generator\nDESCRIPTION: Shows how to use the generateColors function from @mantine/colors-generator to create a palette of 10 shades from a single color value, ideal for adding custom theme colors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/colors.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { generateColors } from '@mantine/colors-generator';\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider\n      theme={{\n        colors: {\n          'pale-blue': generateColors('#375EAC'),\n        },\n      }}\n    >\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Form Validation with isJSONString and isNotEmptyHTML (TSX)\nDESCRIPTION: This code demonstrates how to use the `isJSONString` and `isNotEmptyHTML` validators from `@mantine/form` to validate form inputs. `isJSONString` ensures that the input is a valid JSON string, while `isNotEmptyHTML` verifies that the HTML input is not empty, considering empty tags and whitespace as empty. The snippet also showcases the `useForm` hook for managing form state and validation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-17-0.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isJSONString, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    json: '',\n    html: '',\n  },\n\n  validate: {\n    json: isJSONString('Invalid JSON string'),\n    html: isNotEmptyHTML('HTML cannot be empty'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering modal content inside Portal with React and TypeScript\nDESCRIPTION: Demonstrates rendering a modal-like component in a Portal using React and TypeScript. Utilizes useState to toggle visibility. The Portal component renders the modal content outside the parent 'main' element, preventing z-index and position style conflicts. Dependencies include React and @mantine/core's Portal component. The snippet shows expected inputs (state toggling) and outputs (a div rendered in Portal).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/portal.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Portal } from '@mantine/core';\n\nfunction Demo() {\n  const [opened, setOpened] = useState(false);\n\n  return (\n    <main style={{ position: 'relative', zIndex: 1 }}>\n      {opened && (\n        <Portal>\n          <div>Your modal content</div>\n        </Portal>\n      )}\n\n      <button onClick={() => setOpened(true)} type=\"button\">\n        Open modal\n      </button>\n    </main>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using renderRoot Prop with React Router NavLink in Mantine Button (TypeScript)\nDESCRIPTION: This React TypeScript snippet demonstrates how to customize the root element of a Mantine Button with a NavLink from react-router-dom using the 'renderRoot' prop. The callback allows integrating complex components requiring dynamic className computation, overcoming conflicts with Mantine's polymorphic component API. Requires 'react-router-dom', '@mantine/core', and 'clsx' as dependencies. Inputs include NavLink props and className merging; outputs are themed buttons acting as router links.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-1-0.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport cx from 'clsx';\nimport { NavLink } from 'react-router-dom';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      renderRoot={({ className, ...others }) => (\n        <NavLink\n          className={({ isActive }) =>\n            cx(className, { 'active-class': isActive })\n          }\n          {...others}\n        />\n      )}\n    >\n      React router NavLink\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Hotkeys on Specific Elements with useHotkeys\nDESCRIPTION: This snippet shows how to prevent hotkeys from triggering when specific HTML elements have focus. The `useHotkeys` hook accepts a second argument - an array of HTML tag names which should be ignored. In this case, hotkeys are ignored when the focus is in input and textarea elements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hotkeys.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useHotkeys } from '@mantine/hooks';\n\nfunction Demo() {\n  // Ignore hotkeys events only when focus is in input and textarea elements\n  useHotkeys(\n    [['ctrl+K', () => console.log('Trigger search')]],\n    ['INPUT', 'TEXTAREA']\n  );\n\n  // Empty array – do not ignore hotkeys events on any element\n  useHotkeys([['ctrl+K', () => console.log('Trigger search')]], []);\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Fixed Footer Layout Using CSS\nDESCRIPTION: Provides a CSS strategy to create a fixed footer on a webpage. It instructs to set the footer's CSS position to fixed with bottom zero, wrap all content except the footer in a container div, and assign min-height 100vh to this container to ensure the footer remains at the bottom. Setting a background color on the content container is necessary to prevent visual overlap. This snippet is conceptual and demonstrates layout best practices for sticky footers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-that-thing-is-done.mdx#_snippet_1\n\nLANGUAGE: CSS\nCODE:\n```\n/* Footer styles */\nfooter {\n  position: fixed;\n  bottom: 0;\n}\n\n/* Content container styles */\n.content-container {\n  min-height: 100vh;\n  background-color: /* your background color */;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Mantine Color Scheme with Hook in TSX\nDESCRIPTION: This snippet demonstrates how to retrieve the current color scheme (`light` or `dark`) within a React component using the `useMantineColorScheme` hook provided by `@mantine/core`. This method is suitable for client-side rendered applications but is not recommended for server-side rendering frameworks like Next.js or Remix due to potential hydration mismatches. The hook returns an object containing the `colorScheme` property.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/light-dark-elements.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMantineColorScheme } from '@mantine/core';\n\nfunction MyComponent() {\n  const { colorScheme } = useMantineColorScheme();\n\n  // ✅ Works in Vite and other client-side bundlers/frameworks\n  // ❌ Hydration mismatch in Next.js, Remix, and other server-side rendering frameworks\n  return <div>Color scheme is {colorScheme}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getTreeExpandedState function\nDESCRIPTION: Demonstrates the usage of the `getTreeExpandedState` function to generate the expanded state object for the tree. The function accepts the tree data and an array of node values to expand.  It provides options to expand specific nodes or expand all nodes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n// Expand two given nodes\ngetTreeExpandedState(data, ['src', 'src/components']);\n\n// Expand all nodes\ngetTreeExpandedState(data, '*');\n```\n\n----------------------------------------\n\nTITLE: Demonstrating supported Tooltip children in React\nDESCRIPTION: Shows valid and invalid ways to use children with the Tooltip component. The component requires a single element or component as a child and will throw errors with strings, fragments, numbers or multiple elements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tooltip.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Badge, Tooltip } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Tooltip label=\"OK\">\n        <button>Native button – ok</button>\n      </Tooltip>\n\n      <Tooltip label=\"OK\">\n        <Badge>Mantine component – ok</Badge>\n      </Tooltip>\n\n      <Tooltip label=\"Throws\">\n        Raw string, NOT OK – will throw error\n      </Tooltip>\n\n      {/* Number, NOT OK – will throw error */}\n      <Tooltip label=\"Throws\">{2}</Tooltip>\n\n      <Tooltip label=\"Throws\">\n        <>Fragment, NOT OK, will throw error</>\n      </Tooltip>\n\n      <Tooltip label=\"Throws\">\n        <div>More that one node</div>\n        <div>NOT OK, will throw error</div>\n      </Tooltip>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useFocusReturn Hook in Mantine (Manual Return)\nDESCRIPTION: This code snippet illustrates how to manually trigger the focus return functionality of the `useFocusReturn` hook. It initializes the hook with `shouldReturnFocus` set to `false`.  This configuration allows you to control when the focus is returned by calling the returned function named `returnFocus()`. The example shows the hook being used in a more flexible context.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-return.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n```tsx\nimport { useFocusReturn } from '@mantine/hooks';\n\nconst returnFocus = useFocusReturn({\n  opened: false,\n  shouldReturnFocus: false,\n});\n\n// ... later\nreturnFocus();\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up MantineProvider in RedwoodJS App.tsx (TypeScript)\nDESCRIPTION: Updates the main application component (`web/src/App.tsx`) to integrate Mantine. This involves importing the core Mantine styles (`@mantine/core/styles.css`), wrapping the RedwoodJS application components (`RedwoodApolloProvider`, `Routes`) with the `MantineProvider`, and including the `ColorSchemeScript` component for handling color scheme preferences.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/redwood.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Import styles of packages that you've installed.\n// All packages except `@mantine/hooks` require styles imports\nimport '@mantine/core/styles.css';\n\nimport { FatalErrorBoundary, RedwoodProvider } from '@redwoodjs/web';\nimport { RedwoodApolloProvider } from '@redwoodjs/web/apollo';\nimport FatalErrorPage from 'src/pages/FatalErrorPage';\nimport Routes from 'src/Routes';\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nconst App = () => (\n  <FatalErrorBoundary page={FatalErrorPage}>\n    <RedwoodProvider titleTemplate=\"%PageTitle | %AppTitle\">\n      <ColorSchemeScript />\n      <MantineProvider>\n        <RedwoodApolloProvider>\n          <Routes />\n        </RedwoodApolloProvider>\n      </MantineProvider>\n    </RedwoodProvider>\n  </FatalErrorBoundary>\n);\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Configuring Responsive AppShell Navbar Width in React (TSX)\nDESCRIPTION: Demonstrates configuring a responsive width for the `AppShell.Navbar` using an object for the `navbar.width` prop. The keys define breakpoints (`sm`, `lg`), and values set the width for viewports larger than or equal to that breakpoint. Below the main `navbar.breakpoint` ('sm' in this case), the width is 100%. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// Width is an object with breakpoints:\n// - width is 100% when viewport width is < theme.breakpoints.sm\n// - width is 200 when viewport width is >= theme.breakpoints.sm and < theme.breakpoints.lg\n// - width is 300 when viewport width is >= theme.breakpoints.lg\nfunction Demo() {\n  return (\n    <AppShell\n      navbar={{ width: { sm: 200, lg: 300 }, breakpoint: 'sm' }}\n    >\n      <AppShell.Navbar>Navbar</AppShell.Navbar>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Basic MonthPickerInput Usage in React\nDESCRIPTION: Demonstrates the basic implementation of the MonthPickerInput component in a React application, showing how to render a simple month picker input field.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Tooltip Content in BarChart Using Recharts Tooltip Component, JSX/TypeScript\nDESCRIPTION: Allows passing a custom tooltip renderer via `tooltipProps.content` to the underlying Recharts Tooltip component. Requires filtering of recharts payload with a helper function to remove styling-only empty values. Demonstrated with BarChartDemos.customTooltip data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_23\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.customTooltip} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Accessibility for Burger Component\nDESCRIPTION: This snippet provides guidance on making the Burger component accessible for screen readers by setting 'aria-label' or including a visually hidden label with the VisuallyHidden component. It includes a sample implementation demonstrating both approaches.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/burger.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Burger, VisuallyHidden } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Burger aria-label=\"Toggle navigation\" />\n\n      <Burger>\n        <VisuallyHidden>Toggle navigation</VisuallyHidden>\n      </Burger>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useWindowEvent to Manage Keyboard Events with Mantine (TypeScript)\nDESCRIPTION: This code snippet demonstrates two approaches to handling window-level keyboard events in React using TypeScript: the conventional useEffect method and the more concise useWindowEvent hook from the @mantine/hooks package. Dependencies include React and @mantine/hooks. The examples show how to add and remove a keydown event listener, log the KeyboardEvent object, and leverage hook-based API for cleaner component lifecycles. Key parameters are the event type and the keyboard event handler function. The inputs are keyboard events; there is no meaningful output beyond side effects (logging).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-window-event.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useWindowEvent } from '@mantine/hooks';\n\nconst handler = (event: KeyboardEvent) => console.log(event);\n\n// regular way\nuseEffect(() => {\n  window.addEventListener('keydown', handler);\n  return () => window.removeEventListener('keydown', handler);\n}, []);\n\n// with use-window-event hook\nuseWindowEvent('keydown', handler);\n```\n\n----------------------------------------\n\nTITLE: Using useMantineColorScheme hook to access and modify color scheme in React (TypeScript)\nDESCRIPTION: This snippet describes the use of the `useMantineColorScheme` hook to get and set the current color scheme state within React components. It includes the hook signature with the available methods and demonstrates import requirements. Dependencies include @mantine/core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useMantineColorScheme(): {\n  /** Current color scheme value */\n  colorScheme: 'dark' | 'light' | 'auto';\n\n  /** Sets colors scheme to given value */\n  setColorScheme: (colorScheme: 'dark' | 'light' | 'auto') => void;\n\n  /** Toggle color scheme to the opposite value, if value is 'auto', color scheme is inferred from the OS settings */\n  toggleColorScheme: () => void;\n\n  /** Clears color scheme value from storage and sets it to `defaultColorScheme` */\n  clearColorScheme: () => void;\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering SegmentedControl with Array Data Formats\nDESCRIPTION: This snippet illustrates two data formats supported by the `SegmentedControl` component. The first uses an array of strings where the `value` and `label` are identical. The second employs an array of objects, allowing for distinct `value` and `label` properties, offering greater flexibility for customization. Dependencies: `@mantine/core` library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/segmented-control.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { SegmentedControl } from '@mantine/core';\n\nfunction ArrayOfStrings() {\n  return (\n    <SegmentedControl data={['React', 'Angular', 'Svelte', 'Vue']} />\n  );\n}\n\nfunction ArrayOfObjects() {\n  return (\n    <SegmentedControl\n      data={[\n        { value: 'React', label: 'React' },\n        { value: 'Angular', label: 'Angular' },\n        { value: 'Svelte', label: 'Svelte' },\n        { value: 'Vue', label: 'Vue' },\n      ]}\n    />\n  );\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Wrapping App with MantineEmotionProvider (Vite)\nDESCRIPTION: This snippet demonstrates how to wrap the application with `MantineEmotionProvider` and include `emotionTransform` in `MantineProvider` for use with Vite. This enables the use of Emotion styling with Mantine components. Requires importing components from `@mantine/core` and `@mantine/emotion`.  It sets up the necessary providers for Emotion to work correctly within the Mantine context.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport { MantineProvider } from '@mantine/core';\nimport {\n  emotionTransform,\n  MantineEmotionProvider,\n} from '@mantine/emotion';\n\nexport default function App() {\n  return (\n    <MantineProvider stylesTransform={emotionTransform}>\n      <MantineEmotionProvider>App</MantineEmotionProvider>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Dates Selection with MonthPickerInput\nDESCRIPTION: Shows how to configure MonthPickerInput to allow users to select multiple months by setting the type prop to 'multiple'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.multiple} />\n```\n\n----------------------------------------\n\nTITLE: Demonstrating DateInput with Custom Format\nDESCRIPTION: This snippet renders a demo illustrating how to apply a custom date format to DateInput, enabling the component to display and parse dates according to user-defined formats using the `valueFormat` prop. It relies on the extended dayjs plugin for custom parsing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.format} />\n```\n\n----------------------------------------\n\nTITLE: Using form actions in external components\nDESCRIPTION: Shows how to use form actions to manipulate form state from components that don't have direct access to the form. Examples include setting values from API responses and resetting the form.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/actions.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { Button } from '@mantine/core';\nimport { demoFormActions } from './demoFormActions';\n\nfunction ExternalComponent() {\n  useEffect(() => {\n    fetch('/api/user')\n      .then((res) => res.json())\n      .then((res) =>\n        demoFormActions.setValues({\n          name: res.name,\n          age: res.age,\n        })\n      );\n  }, []);\n\n  return (\n    <Button onClick={() => demoFormActions.reset()}>\n      Reset demo form\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Single Field Error with setFieldError – Mantine\nDESCRIPTION: Demonstrates using `form.setFieldError` to set an error for a specific field. This is useful for updating error states individually, driven by asynchronous validations or other dynamic conditions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: '', email: '' },\n});\n\nform.setFieldError('email', 'Invalid email');\n\nform.errors; // -> { email: 'Invalid email' }\n\n```\n\n----------------------------------------\n\nTITLE: Defining the useNetwork Hook Return Type in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure of the object returned by the `useNetwork` hook. It includes properties such as `online` (boolean), optional network metrics like `downlink`, `effectiveType`, `rtt`, `saveData`, and the connection `type`. This hook utilizes the experimental `navigator.connection` API.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-network.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useNetwork(): {\n  online: boolean;\n  downlink?: number;\n  downlinkMax?: number;\n  effectiveType?: 'slow-2g' | '2g' | '3g' | '4g';\n  rtt?: number;\n  saveData?: boolean;\n  type?:\n    | 'bluetooth'\n    | 'cellular'\n    | 'ethernet'\n    | 'wifi'\n    | 'wimax'\n    | 'none'\n    | 'other'\n    | 'unknown';\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Fixed AppShell Header Height in React (TSX)\nDESCRIPTION: Example demonstrating how to set a fixed height for the `AppShell.Header` using a numerical value passed to the `header.height` prop on the `AppShell` component. This value will be converted to rem units and applied across all viewport sizes. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// Height is a number, it will be converted to rem\n// and used as height at all viewport sizes\nfunction Demo() {\n  return (\n    <AppShell header={{ height: 48 }}>\n      <AppShell.Header>Header</AppShell.Header>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Charts Styles in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the necessary styles for the `@mantine/charts` package. It must be imported at the root of your application to make sure the styles are applied to the charts components. This ensures that the Mantine Charts components are styled correctly within the application, providing a consistent visual appearance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/getting-started.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/charts/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Showing Mantine Card.Section Usage Restrictions and Fragment Limitations in TypeScript\nDESCRIPTION: This snippet demonstrates the limitations of wrapping Card.Section components within other elements such as divs or React fragments inside a Card component. It imports Card, sets padding=\"xl\", and attempts to wrap Card.Section inside a div and a fragment, both of which are unsupported and won't behave as expected. The code highlights the requirement that Card.Section must be a direct child of Card for correct negative margin calculation and layout styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/card.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Card } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Card padding=\"xl\">\n      <div>\n        <Card.Section>Won't work</Card.Section>\n      </div>\n\n      <>\n        <Card.Section>Won't work either</Card.Section>\n      </>\n\n      <Card.Section>Works fine</Card.Section>\n    </Card>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Search Value Select Component\nDESCRIPTION: This example shows how to control the search value of the Select component using the `searchValue` and `onSearchChange` props. The `searchable` prop must be set to enable search functionality.  This example includes the use of useState for state management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/select.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState } from 'react';\nimport { Select } from '@mantine/core';\n\nfunction Demo() {\n  const [searchValue, setSearchValue] = useState('');\n  return (\n    <Select\n      searchable\n      searchValue={searchValue}\n      onSearchChange={setSearchValue}\n      data={[]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Form Values in Uncontrolled Mode with Mantine useForm\nDESCRIPTION: Demonstrates initializing the `useForm` hook in `uncontrolled` mode and shows how to retrieve the current form values at any time using the `form.getValues()` method. Unlike `form.values` in this mode, `form.getValues()` always returns the latest state, even after updates via methods like `setValues`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-8-0.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n});\n\nform.getValues(); // { name: 'John Doe' }\n\nform.setValues({ name: 'John Smith' });\nform.getValues(); // { name: 'John Smith' }\n```\n\n----------------------------------------\n\nTITLE: Searching Options in Mantine MultiSelect with React Testing Library (TypeScript/TSX)\nDESCRIPTION: This test sample verifies the search/filtering behavior of a Mantine MultiSelect component by simulating user typing and checking visible options. Required dependencies are Mantine's MultiSelect, React Testing Library utilities, and Jest/Vitest as the test runner. The component is rendered with the 'searchable' prop. Input involves typing a query string into the input, after opening the dropdown, and checking for the presence or absence of list options via their labels. This pattern tests the search algorithm and filter visibility in controlled components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/combobox-testing.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nimport { MultiSelect } from '@mantine/core';\n\nfunction MyForm() {\n  return (\n    <MultiSelect\n      name=\"groceries\"\n      searchable\n      label=\"Select groceries\"\n      data=[\n        { value: 'banana', label: 'Banana' },\n        { value: 'apple', label: 'Apple' },\n        { value: 'orange', label: 'Orange' },\n      ]\n    />\n  );\n}\n\nit('searches for options', () => {\n  render(<MyForm />);\n\n  // Click Select to open the options list\n  await userEvent.click(screen.getByRole('textbox', { name: 'Select groceries' }));\n\n  // Type search query\n  await userEvent.type(screen.getByRole('textbox', { name: 'Select groceries' }), 'banana');\n\n  // Verify that only one option is visible\n  expect(screen.getByRole('option', { name: 'Banana' })).toBeVisible();\n  expect(screen.queryByRole('option', { name: 'Apple' })).toBeNull();\n  expect(screen.queryByRole('option', { name: 'Orange' })).toBeNull();\n});\n```\n\n----------------------------------------\n\nTITLE: Spacing with Margin Props in Mantine\nDESCRIPTION: Demonstrates how to use margin props (`mt`) within Mantine components to achieve spacing instead of using the `Space` component.  It imports `Space` and `Text` from `@mantine/core` and creates a component where `mt=\"md\"` is used to add spacing between two Text components.  This approach is preferred when working with Mantine components as they have built in theme spacing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/space.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Space, Text } from '@mantine/core';\n\n// Space is not required as the same can be achieved with `mt` prop\nfunction Demo() {\n  return (\n    <>\n      <Text>First line</Text>\n      <Text mt=\"md\">Second line</Text>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hotkey Types and Options\nDESCRIPTION: This code provides the type definitions for customizing `useHotkeys`. The interfaces `HotkeyItemOptions` and `HotkeyItem` are described here. It shows how to create hotkey items outside the `use-hotkeys` hook using `HotkeyItem` type, and how to use options to customize hotkeys behaviour. For example, the `usePhysicalKeys` option allows mapping to physical key assignments useful for different keyboard layouts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hotkeys.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ninterface HotkeyItemOptions {\n  preventDefault?: boolean;\n  usePhysicalKeys?: boolean;\n}\n\ntype HotkeyItem = [\n  string,\n  (event: KeyboardEvent) => void,\n  HotkeyItemOptions?,\n];\n```\n\n----------------------------------------\n\nTITLE: Importing Individual Mantine Component Styles with CSS Layer in TypeScript\nDESCRIPTION: Shows how to import component-level Mantine styles wrapped with the @layer mantine directive for granular style management in a TypeScript React application. Applies when developers need only certain components layered for specificity. Each import corresponds to a component, and '... other styles' can be appended for additional components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles/UnstyledButton.layer.css';\nimport '@mantine/core/styles/Button.layer.css';\n\n// ... other styles\n```\n\n----------------------------------------\n\nTITLE: Reordering Items in a List with useListState\nDESCRIPTION: The `reorder` handler moves an item from one position to another within the list. It takes an object with `from` and `to` properties, indicating the starting and ending indices of the move. In this example item at index 2 is moved to index 0.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// move item from one position to another\nconst reorder = () => handlers.reorder({ from: 2, to: 0 });\n// values -> [{ a: 4 }, { a: 0 }, { a: 5 }]\n```\n\n----------------------------------------\n\nTITLE: Basic ColorSwatch Component Usage Demo\nDESCRIPTION: Renders a demo component showcasing the basic usage of the ColorSwatch component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/color-swatch.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ColorSwatchDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Setting Up MantineProvider in _app.tsx\nDESCRIPTION: Initializes MantineProvider in the Next.js custom App component, passing a theme object and wrapping the entire application to provide Mantine styling and theming.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport type { AppProps } from 'next/app';\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  /** Put your mantine theme override here */\n});\n\nexport default function App({ Component, pageProps }: AppProps) {\n  return (\n    <MantineProvider theme={theme}>\n      <Component {...pageProps} />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering DonutChart component with Mantine Charts in TypeScript\nDESCRIPTION: Demonstrates the basic usage of the new DonutChart component from '@mantine/charts' within a React functional component using TypeScript. It assumes an imported 'data' object and shows how to render the chart by passing the data as a prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { DonutChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return <DonutChart data={data} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Ensuring Application Styles Override Mantine with Correct Import Order in TypeScript\nDESCRIPTION: Illustrates the correct and incorrect methods for importing custom application styles alongside Mantine styles in a TypeScript React application. Application CSS (e.g., Demo.module.css) must be imported after Mantine styles to ensure overrides. These imports are static and require the presence of a locally defined CSS module file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ Correct order - your styles will override Mantine styles\nimport '@mantine/core/styles.css';\nimport '@mantine/dates/styles.css';\nimport classes from './Demo.module.css';\n\n// ❌ Incorrect order – Mantine styles will override your styles\nimport classes from './Demo.module.css';\nimport '@mantine/core/styles.css';\nimport '@mantine/dates/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Defining the useIdle Hook Signature in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for the `useIdle` hook. It accepts a mandatory `timeout` number (in milliseconds) and an optional `options` object. The `options` object can specify custom `events` (an array of strings) to listen for activity and an `initialState` boolean (defaulting to true/idle). The hook returns a boolean indicating whether the user is currently idle.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-idle.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useIdle(\n  timeout: number,\n  options?: Partial<{ events: string[]; initialState: boolean }>\n): boolean;\n```\n\n----------------------------------------\n\nTITLE: Creating Custom CSS Loaders for Mantine in React\nDESCRIPTION: Shows how to define a custom CSS-only loader and integrate it with Mantine's theme default props for the Loader component. Requires using '--loader-size' and '--loader-color' CSS variables within the custom CSS rules to ensure compatibility with the component's 'size' and 'color' props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/loader.mdx#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n/* MyCustomLoader.module.css */\n.myCustomLoader {\n  width: var(--loader-size);\n  height: var(--loader-size);\n  border: 2px solid var(--loader-color);\n  border-top-color: transparent;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// Theme setup (e.g., main application file)\nimport { MantineProvider, Loader, createTheme } from '@mantine/core';\nimport classes from './MyCustomLoader.module.css';\n\nconst theme = createTheme({\n  components: {\n    Loader: Loader.extend({\n      defaultProps: {\n        loaders: {\n          ...Loader.defaultLoaders, // Preserve default loaders\n          'my-custom': <div className={classes.myCustomLoader} />,\n        },\n        // Optionally set as default type globally\n        // type: 'my-custom',\n      },\n    }),\n  },\n});\n\n// Usage in a component\nfunction App() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Use the custom loader by type */}\n      <Loader type=\"my-custom\" size=\"md\" color=\"blue\" />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple Theme Overrides in Mantine\nDESCRIPTION: The code demonstrates how to merge multiple theme overrides using the `mergeThemeOverrides` function in Mantine. It creates two separate theme override objects (`theme1` and `theme2`) and combines them into a single theme (`myTheme`). This combined theme is then passed to the `MantineProvider` for global application theming. The comment advises storing the theme override outside the component body to prevent unnecessary re-renders.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/theme-object.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createTheme,\n  MantineProvider,\n  mergeThemeOverrides,\n} from '@mantine/core';\n\nconst theme1 = createTheme({\n  primaryColor: 'orange',\n  defaultRadius: 0,\n});\n\nconst theme2 = createTheme({\n  cursorType: 'pointer',\n});\n\n// Note: It is better to to store theme override outside of component body\n// to prevent unnecessary re-renders\nconst myTheme = mergeThemeOverrides(theme1, theme2);\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={myTheme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rendering ScatterChart with Custom Colors in Mantine (TypeScript)\nDESCRIPTION: This snippet shows how to render the ScatterChart component with specified height, data, keys mapping, and custom colors for the grid and text. It imports the ScatterChart component from '@mantine/charts' and a data object from a local module. The component receives props 'h' (height), 'data' (the chart data), 'dataKey' (to map data fields to x and y axes), 'gridColor' (color for grid lines), and 'textColor' (color for chart text). This example demonstrates the use of direct color props rather than CSS variables for styling. The data object must conform to expected structure with x and y values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/scatter-chart.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ScatterChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <ScatterChart\n      h={350}\n      data={data}\n      dataKey={{ x: 'age', y: 'BMI' }}\n      gridColor=\"gray.5\"\n      textColor=\"gray.9\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New React Router Application (Bash)\nDESCRIPTION: Uses the `create-react-router` CLI tool via npx to bootstrap a new React Router project named `my-react-router-app`. This is the first step in setting up the project environment.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/react-router.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-react-router@latest my-react-router-app\n```\n\n----------------------------------------\n\nTITLE: Rendering Layout with MDX Data\nDESCRIPTION: This code exports the default layout, passing in the `useScrollSpy` data from `MDX_DATA`.  It is the main entry point for the component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-scroll-spy.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default Layout(MDX_DATA.useScrollSpy);\n```\n\n----------------------------------------\n\nTITLE: Responsive Layouts with SimpleGrid and Grid\nDESCRIPTION: Both components now utilize object syntax for breakpoints and spacing, aligning with style props for easier and consistent responsive design.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_20\n\n\n\n----------------------------------------\n\nTITLE: Defining useCounter Custom Hook in React TypeScript\nDESCRIPTION: This code defines the TypeScript signature for the useCounter hook, intended for state management of numeric counters in React components. It accepts an optional initialValue and a configuration object specifying the minimum and maximum allowed values. The hook returns an array containing the current value and an object with increment, decrement, set, and reset functions. No external dependencies are required apart from React; inputs and outputs are strongly typed, and the API ensures the counter stays within optional bounds.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-counter.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useCounter(\n  initialValue?: number,\n  options?: Partial<{\n    min: number;\n    max: number;\n  }>\n): [\n  number,\n  {\n    increment: () => void;\n    decrement: () => void;\n    set: (value: number) => void;\n    reset: () => void;\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Using useMouse Hook - Mantine React\nDESCRIPTION: This code snippet demonstrates the basic usage of the `useMouse` hook. It shows how to import the hook and then destructure the `ref`, `x`, and `y` values from it. The `ref` should be passed to the target element to track the mouse position; if not provided, the document element is used. The `x` and `y` values provide the current mouse coordinates. The `resetOnExit` option can be set to reset mouse position to `0, 0` when mouse leaves the element.  Dependencies include `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mouse.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={HooksDemos.useMouseRef} />\n```\n\n----------------------------------------\n\nTITLE: Defining Options for useFileDialog Hook in TypeScript\nDESCRIPTION: Defines the `UseFileDialogOptions` interface in TypeScript, which allows configuring the `use-file-dialog` hook. Options include `multiple`, `accept`, `capture`, `directory`, `resetOnOpen`, `initialFiles`, `onChange`, and `onCancel` to control file selection behavior and handle events.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-file-dialog.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\ninterface UseFileDialogOptions {\n  /** Determines whether multiple files are allowed, `true` by default */\n  multiple?: boolean;\n\n  /** `accept` attribute of the file input, '*' by default */\n  accept?: string;\n\n  /** `capture` attribute of the file input */\n  capture?: string;\n\n  /** Determines whether the user can pick a directory instead of file, `false` by default */\n  directory?: boolean;\n\n  /** Determines whether the file input state should be reset when the file dialog is opened, `false` by default */\n  resetOnOpen?: boolean;\n\n  /** Initial selected files */\n  initialFiles?: FileList | File[];\n\n  /** Called when files are selected */\n  onChange?: (files: FileList | null) => void;\n\n  /** Called when file dialog is canceled */\n  onCancel?: () => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Modal to Allow Pinch Zoom - TypeScript\nDESCRIPTION: This code snippet demonstrates how to configure the Mantine Modal component to allow pinch-to-zoom functionality on mobile devices. It utilizes the `removeScrollProps` prop to customize the behavior of the underlying `react-remove-scroll` library. The `allowPinchZoom` property is set to `true`, which overrides the default behavior of preventing pinch-to-zoom. The component uses the Mantine Modal and its core features like `Modal` to add the functionality. This configuration will apply only when the Modal is open.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/pinch-to-zoom-modal.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Modal } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Modal\n      removeScrollProps={{\n        allowPinchZoom: true, // Allow pinch to zoom on mobile devices\n      }}\n    >\n      {/* Modal content */}\n    </Modal>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adjusting Color Brightness with darken/lighten in Mantine Core (TSX)\nDESCRIPTION: Demonstrates using the `darken` and `lighten` functions from `@mantine/core` to decrease or increase the brightness of a color. Accepts various color formats (hex, rgb, rgba, CSS variables) and a factor (0-1) representing the percentage to adjust brightness. Returns the modified color, typically in rgba format, or uses `color-mix` for CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { darken, lighten } from '@mantine/core';\n\nlighten('#228BE6', 0.1); // lighten by 10%\n// -> rgba(56, 151, 233, 1)\n\ndarken('rgb(245, 159, 0)', 0.5); // darken by 50%\n// -> rgba(123, 80, 0, 1)\n\ndarken('rgba(245, 159, 0, .3)', 0.5); // darken by 50%\n// -> rgba(123, 80, 0, 1, .3)\n\nlighten('var(--mantine-color-gray-4)', 0.74);\n// -> color-mix(in srgb, var(--mantine-color-gray-4), white 74%)\n```\n\n----------------------------------------\n\nTITLE: Conditional Bar Color Assignment Based on Value in JSX/TypeScript\nDESCRIPTION: Uses the `getBarColor` function prop to dynamically assign bar fill colors based on bar value and series information. The function receives the value and series object, returning a CSS color string or theme reference, though legend and tooltip colors remain unaffected by this coloring. Uses BarChartDemos.getBarColor data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_7\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.getBarColor} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Command/Ctrl+K Focus Shortcut with useWindowEvent (TypeScript)\nDESCRIPTION: This snippet defines a Demo component using React and @mantine/hooks to focus an input when ⌘+K (Mac) or Ctrl+K (Windows/Linux) is pressed. It uses useRef for referencing the input and useWindowEvent to add a keydown listener. Dependencies are React and @mantine/hooks. The main parameters are the keydown event and the inputRef. When the shortcut is detected, the input is focused and default browser action is prevented. Limitations: The component assumes inputRef is attached to a single input and only processes keydown events for the K key combined with modifier keys.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-window-event.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useRef } from 'react';\nimport { useWindowEvent } from '@mantine/hooks';\n\nfunction Demo() {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useWindowEvent('keydown', (event) => {\n    if (event.code === 'KeyK' && (event.ctrlKey || event.metaKey)) {\n      event.preventDefault();\n      inputRef.current?.focus();\n    }\n  });\n\n  return <input ref={inputRef} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled NumberInput Component with useState – TypeScript\nDESCRIPTION: This code snippet demonstrates how to create a controlled NumberInput component using the useState hook in React. The component's value is managed by a state variable, and changes to the input update the state. The value can be a string or a number.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/number-input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { NumberInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string | number>('');\n  return <NumberInput value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Form Errors with useForm – Mantine\nDESCRIPTION: Shows how to set initial form errors using the `initialErrors` option within the `useForm` hook.  This allows pre-populating the error state upon form initialization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { firstName: '', lastName: '' },\n  initialErrors: {\n    firstName: 'First name is too short',\n    lastName: 'Last name is too short',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using spotlight Object Actions to Control Spotlight State in React TypeScript\nDESCRIPTION: Uses the spotlight object exported from @mantine/spotlight package to programmatically open, close, or toggle the visibility state of the Spotlight component. These methods can be used anywhere in the app, including outside React components, and can be assigned as event handlers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/spotlight.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { spotlight } from '@mantine/spotlight';\n\nspotlight.open(); // -> opens spotlight\nspotlight.close(); // -> closes spotlight\nspotlight.toggle(); // -> toggles spotlight opened state\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled SegmentedControl with React\nDESCRIPTION: This snippet demonstrates how to implement a controlled `SegmentedControl` component using React's state management. It uses the `useState` hook to manage the selected value. The component renders a segmented control with options for React, Angular, Vue, and Svelte, updating the state based on user interactions.  The `value` prop receives the selected value, and `onChange` updates the state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/segmented-control.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useState } from 'react';\nimport { SegmentedControl } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('react');\n\n  return (\n    <SegmentedControl\n      value={value}\n      onChange={setValue}\n      data={[\n        { label: 'React', value: 'react' },\n        { label: 'Angular', value: 'ng' },\n        { label: 'Vue', value: 'vue' },\n        { label: 'Svelte', value: 'svelte' },\n      ]}\n    />\n  );\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing Primary Colors - Mantine - SCSS\nDESCRIPTION: Demonstrates how to apply Mantine's primary color CSS variables, derived from `theme.primaryColor`, to standard CSS properties within a SCSS stylesheet. It shows how to use `var()` to access specific color shades (0-9) and variant-specific colors like filled.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_19\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  color: var(--mantine-primary-color-0);\n  background-color: var(--mantine-primary-color-filled);\n}\n```\n\n----------------------------------------\n\nTITLE: Using form.key with Uncontrolled Form Inputs\nDESCRIPTION: Example showing how to correctly use form.key() with uncontrolled form inputs to ensure they update when form values change.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/uncontrolled.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { text: '' },\n  });\n\n  return (\n    <input {...form.getInputProps('text')} key={form.key('text')} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Form Submission State with useForm - Mantine Form Hook in React TypeScript\nDESCRIPTION: Example of utilizing form.submitting and form.setSubmitting features of Mantine's useForm hook. Demonstrates auto-tracking of submission state when the onSubmit handler returns a Promise, as well as manual control of submitting state. Requires @mantine/form for useForm, @mantine/core for UI components. Shows disabling and loading states during async submission, and parameters for initialValues and form modes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_6\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Group, Stack, Text, TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\nconst asyncSubmit = (values: any) =>\n  new Promise((resolve) => setTimeout(() => resolve(values), 3000));\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { name: 'John' },\n  });\n\n  const [completed, setCompleted] = useState(false);\n\n  const handleSubmit = async (values: typeof form.values) => {\n    await asyncSubmit(values);\n    setCompleted(true);\n  };\n\n  if (completed) {\n    return (\n      <Stack>\n        <Text>Form submitted!</Text>\n        <Button onClick={() => setCompleted(false)}>Reset to initial state</Button>\n      </Stack>\n    );\n  }\n\n  return (\n    <form onSubmit={form.onSubmit(handleSubmit)}>\n      <TextInput\n        withAsterisk\n        label=\"Name\"\n        placeholder=\"Your name\"\n        key={form.key('name')}\n        disabled={form.submitting}\n        {...form.getInputProps('name')}\n      />\n\n      <Group justify=\"flex-end\" mt=\"md\">\n        <Button type=\"submit\" loading={form.submitting}>\n          Submit\n        </Button>\n      </Group>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Numeric Range with Mantine Form isInRange Validator in TypeScript\nDESCRIPTION: This example uses the isInRange validator to ensure a numeric form field's value lies within specified minimum and/or maximum bounds. If the value is not a number, validation fails. The form manages three fields with different range constraints, validating with customized error messages. useForm hook manages form state and validation in uncontrolled mode.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isInRange, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    maxRange: 0,\n    minRange: 0,\n    minMaxRange: 0,\n  },\n\n  validate: {\n    maxRange: isInRange({ max: 20 }, 'Value must be 20 or less'),\n    minRange: isInRange({ min: 10 }, 'Value must be 10 or more'),\n    minMaxRange: isInRange(\n      { min: 10, max: 20 },\n      'Value must be between 10 and 20'\n    ),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Controlling Expanded State with Mantine Spoiler (TSX)\nDESCRIPTION: This code snippet demonstrates how to control the expanded state of the Mantine Spoiler component using the `expanded` and `onExpandedChange` props. It utilizes the `useState` hook to manage the expanded state.  The `maxHeight` prop influences spoiler visuals. Requires `react` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/spoiler.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Spoiler } from '@mantine/core';\n\nfunction Demo() {\n  const [expanded, setExpanded] = useState(false);\n\n  return (\n    <Spoiler\n      showLabel=\"Show more\"\n      hideLabel=\"Hide details\"\n      expanded={expanded}\n      onExpandedChange={setExpanded}\n    >\n      {/* Spoiler content */}\n    </Spoiler>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing CSS Modules in Gatsby with TypeScript\nDESCRIPTION: Demonstrates the correct syntax for importing CSS modules in Gatsby projects using TypeScript. Unlike standard syntax, Gatsby requires using 'import * as' to properly load CSS module classes as a namespace object. The snippet compares incorrect default import syntax and the correct Gatsby-compatible syntax, ensuring styles can be applied correctly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/gatsby.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Default syntax – will not work in Gatsby\nimport classes from './Demo.module.css';\n\n// Gatsby syntax\nimport * as classes from './Demo.module.css';\n```\n\n----------------------------------------\n\nTITLE: Configuring _document.tsx for Next.js Pages with Emotion\nDESCRIPTION: This snippet shows how to configure the `_document.tsx` file in a Next.js pages router project to enable server-side rendering with Emotion. It imports required modules from Next.js, `@emotion/server`, and `@mantine/core`.  It includes `<ColorSchemeScript />` for theme support and calls `createGetInitialProps` to integrate Emotion's server-side rendering functionality using the `emotionCache`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport NextDocument, {\n  Head,\n  Html,\n  Main,\n  NextScript,\n} from 'next/document';\nimport createEmotionServer from '@emotion/server/create-instance';\nimport { ColorSchemeScript } from '@mantine/core';\nimport { createGetInitialProps } from '@mantine/emotion';\n// Import cache created in the previous step\nimport { emotionCache } from '../emotion/cache';\n\nexport default function Document() {\n  return (\n    <Html lang=\"en\">\n      <Head>\n        <ColorSchemeScript />\n      </Head>\n      <body>\n        <Main />\n        <NextScript />\n      </body>\n    </Html>\n  );\n}\n\nconst stylesServer = createEmotionServer(emotionCache);\n\nDocument.getInitialProps = createGetInitialProps(\n  NextDocument,\n  stylesServer\n);\n```\n\n----------------------------------------\n\nTITLE: Portal Component Example with reuseTargetNode (TSX)\nDESCRIPTION: This snippet showcases the usage of the `reuseTargetNode` prop in the Portal component. By setting `reuseTargetNode` to `true`, all three paragraphs will be rendered in the same target node. The code demonstrates how to render multiple paragraphs within separate Portal components while ensuring they share the same DOM target for improved performance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-17-0.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Portal } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Portal reuseTargetNode>\n        <p>First</p>\n      </Portal>\n\n      <Portal reuseTargetNode>\n        <p>Second</p>\n      </Portal>\n\n      <Portal reuseTargetNode>\n        <p>Third</p>\n      </Portal>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostCSS for Mantine (JavaScript)\nDESCRIPTION: Creates a `postcss.config.js` file in the `web` directory. It configures PostCSS to use `postcss-preset-mantine` for Mantine-specific transformations and `postcss-simple-vars` to define standard Mantine breakpoints (xs, sm, md, lg, xl) as CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/redwood.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering Multiple Divider Demo Sections Using JSX in JavaScript\nDESCRIPTION: This snippet shows JSX elements rendering a Demo component multiple times with different sets of divider demo data such as usage examples, variants, labels, sizes, and orientation. Each section demonstrates a different aspect of the Divider component's capabilities. The Demo component receives data props corresponding to the specific demo category.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/divider.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DividerDemos.usage} />\n\n<Demo data={DividerDemos.variants} />\n\n<Demo data={DividerDemos.labels} />\n\n<Demo data={DividerDemos.sizes} />\n\n<Demo data={DividerDemos.orientation} />\n```\n\n----------------------------------------\n\nTITLE: Slider Marks Configuration Example\nDESCRIPTION: Illustrates how to add marks to a slider track. Marks are defined as an array of objects, where each object specifies the 'value' and optionally a 'label'. The 'value' determines the mark's position on the track, while the 'label' displays text below the track. The example demonstrates adding marks at 20 and 40.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/slider.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst marks = [\n  { value: 20 }, // -> displays mark on slider track\n  { value: 40, label: '40%' }, // -> adds mark label below slider track\n];\n```\n\n----------------------------------------\n\nTITLE: Render the Modal Component\nDESCRIPTION: Renders the Modal component with the data provided by the `MDX_DATA.Modal` object, wrapping the component in a layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/modal.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default Layout(MDX_DATA.Modal);\n```\n\n----------------------------------------\n\nTITLE: Updating Form State Externally Using Form Actions in Mantine (TypeScript/React)\nDESCRIPTION: Illustrates updating a Mantine form's state from an external component via form actions after fetching data asynchronously. Depends on '@mantine/core', '@mantine/form', and React's useEffect. React's Button component allows the user to reset the form by invoking demoFormActions.reset(). The demoFormActions must be imported and corresponds to a form named 'demo-form'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useEffect } from 'react';\nimport { Button } from '@mantine/core';\nimport { demoFormActions } from './demoFormActions';\n\nfunction ExternalComponent() {\n  useEffect(() => {\n    fetch('/api/user')\n      .then((res) => res.json())\n      .then((res) =>\n        demoFormActions.setValues({\n          name: res.name,\n          age: res.age,\n        })\n      );\n  }, []);\n\n  return <Button onClick={() => demoFormActions.reset()}>Reset demo form</Button>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Color Scheme-dependent Sparkline\nDESCRIPTION: Shows how to create a Sparkline that changes color based on the current color scheme using CSS variables with light/dark mixins or light-dark function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/sparkline.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={SparklineDemos.colorSchemeColor} />\n```\n\n----------------------------------------\n\nTITLE: Valid Data Example for Tree\nDESCRIPTION: Defines a valid data structure for the Tree component, demonstrating the required format: an array of objects, where each object has `value` and `label` keys, and optionally a `children` key for nested nodes. This example is crucial for understanding the expected input data format.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// ✅ Valid data, all values are unique\nconst data = [\n  {\n    value: 'src',\n    label: 'src',\n    children: [\n      { value: 'src/components', label: 'components' },\n      { value: 'src/hooks', label: 'hooks' },\n    ],\n  },\n  { value: 'package.json', label: 'package.json' },\n];\n```\n\n----------------------------------------\n\nTITLE: Fixing hydration mismatch by spreading 'mantineHtmlProps' in layout\nDESCRIPTION: Modifies the layout component to include 'mantineHtmlProps' spread onto the '<html>' element, which includes attributes like 'suppressHydrationWarning' and default 'data-mantine-color-scheme', preventing hydration warnings caused by early client-side attribute changes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// app/layout.tsx\nimport { ColorSchemeScript, MantineProvider, mantineHtmlProps } from '@mantine/core';\n\nexport default function RootLayout({ children }: { children: any }) {\n  return (\n    <html lang=\"en\" {...mantineHtmlProps}>\n      <head>\n        <ColorSchemeScript />\n        <link rel=\"shortcut icon\" href=\"/favicon.svg\" />\n        <meta\n          name=\"viewport\"\n          content=\"minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no\"\n        />\n      </head>\n      <body>\n        <MantineProvider>{children}</MantineProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the useIntersection hook with options parameter\nDESCRIPTION: Defines the useIntersection hook function with an optional configuration object matching IntersectionObserver options such as root, rootMargin, and threshold. It returns an object containing a ref callback function and the latest IntersectionObserverEntry, initialized as null if no intersection has occurred.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-intersection.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useIntersection<T extends HTMLElement = any>(\n  options?: ConstructorParameters<typeof IntersectionObserver>[1]\n): {\n  ref: (element: T | null) => void;\n  entry: IntersectionObserverEntry;\n};\n```\n\n----------------------------------------\n\nTITLE: Changing Body Background Color with Mantine CSS Variables\nDESCRIPTION: A more integrated approach using Mantine's CSS variables to change the body background color. This method defines different background colors for light and dark themes, affecting both the body and components that use the same variable.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/body-background.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n:root {\n  @mixin light-root {\n    --mantine-color-body: #f9f9f9;\n  }\n\n  @mixin dark-root {\n    --mantine-color-body: #333;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mantine Tabs with VisuallyHidden\nDESCRIPTION: Shows how to use aria-label and VisuallyHidden component for accessibility purposes when a Tabs.Tab component does not contain text content. If Tabs.Tab only contains an icon, `aria-label` should be set directly or a `VisuallyHidden` component should be used to provide a label for screen readers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { IconCoin } from '@tabler/icons-react';\nimport { Tabs, VisuallyHidden } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Tabs defaultValue=\"chat\">\n      <Tabs.List>\n        {/* aria-label is not required, tab is labelled by children */}\n        <Tabs.Tab value=\"chat\">Chat</Tabs.Tab>\n\n        {/* aria-label is required, tab is not labelled by children */}\n        <Tabs.Tab\n          value=\"money\"\n          aria-label=\"Get money\"\n          leftSection={<IconCoin size={14} />}\n        />\n\n        {/* You can use VisuallyHidden instead of aria-label */}\n        <Tabs.Tab value=\"money\" leftSection={<IconCoin size={14} />}>\n          <VisuallyHidden>Get money</VisuallyHidden>\n        </Tabs.Tab>\n      </Tabs.List>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: UseMove Definition\nDESCRIPTION: Defines the interface and function signature for the useMove hook. It outlines the structure of the UseMovePosition type, useMoveHandlers, and the return object containing the ref and active state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-move.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ninterface UseMovePosition {\n  x: number;\n  y: number;\n}\n\ninterface useMoveHandlers {\n  onScrubStart?: () => void;\n  onScrubEnd?: () => void;\n}\n\nfunction useMove<T extends HTMLElement = HTMLDivElement>(\n  onChange: (value: UseMovePosition) => void,\n  handlers?: useMoveHandlers,\n  dir?: 'ltr' | 'rtl'\n): {\n  ref: React.RefObject<T>;\n  active: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Specifying Item Type with useListState\nDESCRIPTION: When the `useListState` hook is initialized with an empty array, the item type needs to be specified explicitly to avoid the type being inferred as `any`.  This shows correct usages of the hook with and without specifying a type.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useListState } from '@mantine/hooks';\n\nuseListState(['hello']); // ok, item type is string\nuseListState([]); // not ok, item type is any\nuseListState<string>([]); // ok, item type is string\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine Slider with Emotion/styled TSX\nDESCRIPTION: Shows how to wrap a Mantine `Slider` component with `@emotion/styled` to create a styled component. Styles are applied to inner elements like the slider bar and thumb using static selectors within the tagged template literal, demonstrating how CSS-in-JS can be combined with Mantine's internal structure. Requires `@emotion/styled` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/third-party-styles.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport styled from '@emotion/styled';\nimport { Slider } from '@mantine/core';\n\nconst StyledSlider = styled(Slider)`\n  & .mantine-Slider-bar {\n    background-color: var(--mantine-color-pink-5);\n  }\n\n  & .mantine-Slider-thumb {\n    border-color: var(--mantine-color-pink-5);\n    background-color: white;\n    width: 1.5rem;\n    height: 1.5rem;\n  }\n`;\n\nfunction Demo() {\n  return <StyledSlider defaultValue={40} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Modal Component with Customizable Options\nDESCRIPTION: Demonstrates the implementation of the Modal component with varying customizations for different features like removing header, changing size, or customizing the overlay and transitions. The code snippets demonstrate various props like `withCloseButton`, `size`, `overlayProps`, `transitionProps`, etc. which provide flexibility and control over the modal's appearance and behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/modal.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.usage} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.centered} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.header} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.sizes} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.sizeAuto} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.fullScreen} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.fullScreenMobile} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.overlay} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.overflow} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.scrollarea} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.offset} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.transitions} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.transitionEnd} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.initialFocus} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.initialFocusTrap} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.closeIcon} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.composition} />\n```\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ModalDemos.stack} />\n```\n\n----------------------------------------\n\nTITLE: Setting an Item at a Specific Index with useListState\nDESCRIPTION: The `setItem` handler replaces an item at a specific index with a new item. It takes the index and the new item as arguments. This example replaces the item at index 0 with a new object that has `a: 8`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n// set individual item at given position\nconst setItem = () => handlers.setItem(0, { a: 8 });\n// values -> [{ a: 8 }, { a: 7 }]\n```\n\n----------------------------------------\n\nTITLE: Using the Style Prop for Flex Layout in TSX\nDESCRIPTION: Example of using the `style` prop on a `Button` component within a `Flex` container to apply the CSS `flex: 1` property, making the button expand to fill available horizontal space. Imports `Button` and `Flex` components from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Flex } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Flex>\n      <Button style={{ flex: 1 }}>Large button</Button>\n      <Button>Small button</Button>\n    </Flex>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using the 'bd' Style Prop for Borders in Mantine (tsx)\nDESCRIPTION: Demonstrates applying a border to a Mantine `Box` component using the `bd` style prop. This prop simplifies setting the CSS `border` property, automatically converting pixel width values to rem units and supporting theme color references (e.g., `red.5`). Requires importing `Box` from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-10-0.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box bd=\"1px solid red.5\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Redirect component from Mantine components\nDESCRIPTION: This code imports the Redirect component from the project's components directory. It sets up the ability to perform client-side redirects within the application, which is crucial for navigation and routing functionalities.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/code-highlight.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n```\n\n----------------------------------------\n\nTITLE: Applying Light/Dark Mode Styles in Vanilla Extract (TypeScript)\nDESCRIPTION: Illustrates how to apply different styles based on the current color scheme using `vars.lightSelector` and `vars.darkSelector` provided by `@mantine/vanilla-extract`. These selectors are used within the `selectors` property of the `style` function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// Demo.css.ts\nimport { style } from '@vanilla-extract/css';\nimport { vars } from './theme';\n\nexport const demo = style({\n  fontSize: vars.fontSizes.xl,\n\n  selectors: {\n    [vars.lightSelector]: {\n      backgroundColor: vars.colors.red[5],\n      color: vars.colors.white,\n    },\n\n    [vars.darkSelector]: {\n      backgroundColor: vars.colors.blue[5],\n      color: vars.colors.white,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using useQueue Hook with Custom Type Inference in TypeScript/TSX\nDESCRIPTION: This snippet shows how to initialize the useQueue hook with inferred types in TypeScript by supplying initial values with a defined shape. It specifies a limit and provides an initial array of objects, enabling automatic type inference for queue elements. Dependencies: React, @mantine/hooks. Expected input: configuration object with initialValues and limit. Outputs: state and queue arrays typed according to the objects provided. Ensure TypeScript is enabled and @mantine/hooks is installed. No special limitations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-queue.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useQueue } from '@mantine/hooks';\n\nconst q = useQueue({\n  limit: 2,\n  initialValues: [\n    { name: 'Bob', id: 1 },\n    { name: 'Alice', id: 2 },\n  ],\n});\n\ntypeof q.state[number]; // -> { name: string; id: number; }\n```\n\n----------------------------------------\n\nTITLE: Configuring Mantine ColorPicker Accessibility Labels (TSX)\nDESCRIPTION: This snippet demonstrates how to make the Mantine ColorPicker component accessible for screen readers. It shows how to set the `saturationLabel`, `hueLabel`, and `alphaLabel` props, which provide descriptive text for the respective sliders. The component is imported from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/color-picker.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ColorPicker } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <ColorPicker\n      saturationLabel=\"Saturation\"\n      hueLabel=\"Hue\"\n      alphaLabel=\"Alpha\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Mantine Theme with createTheme (TypeScript)\nDESCRIPTION: Demonstrates how to customize the Mantine theme by using the `createTheme` function and `MantineProvider`.  It shows how to override default colors, shadows, and heading styles. The customized theme is then passed to the `MantineProvider` to apply the changes to the application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/theme-object.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider, rem } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    // Add your color\n    deepBlue: [\n      '#eef3ff',\n      '#dce4f5',\n      '#b9c7e2',\n      '#94a8d0',\n      '#748dc1',\n      '#5f7cb8',\n      '#5474b4',\n      '#44639f',\n      '#39588f',\n      '#2d4b81',\n    ],\n    // or replace default theme color\n    blue: [\n      '#eef3ff',\n      '#dee2f2',\n      '#bdc2de',\n      '#98a0ca',\n      '#7a84ba',\n      '#6672b0',\n      '#5c68ac',\n      '#4c5897',\n      '#424e88',\n      '#364379',\n    ],\n  },\n\n  shadows: {\n    md: '1px 1px 3px rgba(0, 0, 0, .25)',\n    xl: '5px 5px 3px rgba(0, 0, 0, .25)',\n  },\n\n  headings: {\n    fontFamily: 'Roboto, sans-serif',\n    sizes: {\n      h1: { fontSize: rem(36) },\n    },\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Dark and Light Color Scheme Styles with Mixins - SCSS\nDESCRIPTION: Illustrates how to use the `light` and `dark` mixins to conditionally apply CSS styles depending on the user's color scheme preference. The SCSS snippet defines styles under the `@mixin light` and `@mixin dark` directives that compile to attribute selectors targeting light or dark color schemes. This enables easy theming of components based on color mode. Root-level `light-root` and `dark-root` mixins are also shown for defining CSS variables depending on scheme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_2\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  @mixin light {\n    color: red;\n  }\n\n  @mixin dark {\n    color: blue;\n  }\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n[data-mantine-color-scheme='light'] .demo {\n  color: red;\n}\n\n[data-mantine-color-scheme='dark'] .demo {\n  color: blue;\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n:root {\n  @mixin light-root {\n    --color: red;\n  }\n\n  @mixin dark-root {\n    --color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Valibot Resolver for Basic Validation\nDESCRIPTION: This snippet shows how to use `valibotResolver` to validate form fields using the Valibot library. It defines a schema with validation rules and applies it to a `@mantine/form` instance. Dependencies include `@mantine/form`, `valibot`, and `mantine-form-valibot-resolver`. The `validate` method is called, and `form.errors` will contain the validation errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { valibotResolver } from 'mantine-form-valibot-resolver';\nimport { email, minLength, minValue, number, object, string } from 'valibot';\nimport { useForm } from '@mantine/form';\n\nconst schema = object({\n  name: string([minLength(2, 'Name should have at least 2 letters')]),\n  email: string([email('Invalid email')]),\n  age: number([minValue(18, 'You must be at least 18 to create an account')]),\n});\n\nconst form = useForm({\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: valibotResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  name: 'Name should have at least 2 letters',\n//  email: 'Invalid email',\n//  age: 'You must be at least 18 to create an account'\n// }\n\n```\n\n----------------------------------------\n\nTITLE: Setting HTML dir Attribute for RTL Support in HTML\nDESCRIPTION: Simple HTML snippet showing how to set the `dir` attribute on the root `html` element to specify right-to-left text direction (`rtl`). This attribute is necessary for DirectionProvider when `detectDirection` is true, as it reads this value on mount to initialize direction. Note that framework-specific approaches to setting this attribute may vary, so users should consult framework documentation for integration details.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rtl.mdx#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<!-- Set direction attribute on html element -->\n<html dir=\"rtl\">\n  <head></head>\n  <body></body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Showing Complex Notification with Props in Mantine Notifications (TSX)\nDESCRIPTION: Shows how to create and display a notification using the notifications.show function. The example includes all commonly used notification properties such as id, position, close button visibility, lifecycle callbacks, auto close timeout, styling, title, message, color, icon component, additional className, inline styles, and loading indicator status.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IconX } from '@tabler/icons-react';\nimport { notifications } from '@mantine/notifications';\n\n// Bare minimum – message is required for all notifications\nnotifications.show({ message: 'Hello' });\n\n// Most used notification props\nnotifications.show({\n  id: 'hello-there',\n  position: 'bottom-center',\n  withCloseButton: true,\n  onClose: () => console.log('unmounted'),\n  onOpen: () => console.log('mounted'),\n  autoClose: 5000,\n  title: \"You've been compromised\",\n  message: 'Leave the building immediately',\n  color: 'red',\n  icon: <IconX />, \n  className: 'my-notification-class',\n  style: { backgroundColor: 'red' },\n  loading: false,\n});\n```\n\n----------------------------------------\n\nTITLE: onChange handler with object format\nDESCRIPTION: This example demonstrates how to use the second argument of the `onChange` handler to get the selected option object. This is useful when you want to store the entire option object in the state, rather than just the value.  The example uses the ComboboxItem interface.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/select.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState } from 'react';\nimport { ComboboxItem, Select } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<ComboboxItem | null>(null);\n  return (\n    <Select\n      data={[{ value: 'react', label: 'React library' }]}\n      value={value ? value.value : null}\n      onChange={(_value, option) => setValue(option)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using the useIsomorphicEffect Hook in React with Mantine\nDESCRIPTION: This example demonstrates how to import and use the useIsomorphicEffect hook from the Mantine hooks library. The hook functions as a replacement for useLayoutEffect, allowing developers to perform layout effects in both browser and server environments by setting the document title.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-isomorphic-effect.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useIsomorphicEffect } from '@mantine/hooks';\n\nfunction Demo() {\n  useIsomorphicEffect(() => {\n    document.title = 'title';\n  });\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Legend to Mantine RadarChart (TSX)\nDESCRIPTION: Shows how to enable the legend in a `RadarChart` from `@mantine/charts` using the `withLegend` prop. Other configuration props like `h`, `data`, `dataKey`, `withPolarRadiusAxis`, and `series` are also demonstrated. Assumes `data` is imported from a local `./data` file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RadarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <RadarChart\n      h={300}\n      data={data}\n      dataKey=\"product\"\n      withPolarRadiusAxis\n      withLegend\n      series={[\n        { name: 'Sales January', color: 'blue.6', opacity: 0.2 },\n        { name: 'Sales February', color: 'orange.6', opacity: 0.2 },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing target node for multiple Portals in React with TypeScript\nDESCRIPTION: Illustrates how to use the `reuseTargetNode` prop of the Mantine Portal component to render multiple Portal instances into the same DOM target node. This is useful for grouping all portal content within a single container to reduce DOM complexity. No external dependencies other than React and @mantine/core. Expected input is multiple Portal children, output is that all children mount under the same DOM node.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/portal.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Portal } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Portal reuseTargetNode>\n        <p>First</p>\n      </Portal>\n\n      <Portal reuseTargetNode>\n        <p>Second</p>\n      </Portal>\n\n      <Portal reuseTargetNode>\n        <p>Third</p>\n      </Portal>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using @mixin hover with postcss-preset-mantine in SCSS\nDESCRIPTION: Illustrates using the `@mixin hover` (requires `postcss-preset-mantine`) within an SCSS module to apply styles (`color: orange;`) to an element (`.demo`). This mixin automatically generates styles for both hover-capable and touch devices.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-add-hover-styles.mdx#_snippet_2\n\nLANGUAGE: scss\nCODE:\n```\n// Import the css file in your component the same way as in &:hover example\n.demo {\n  @mixin hover {\n    color: orange;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Accordion State - Multi Selection\nDESCRIPTION: Demonstrates state management for a multi-select Accordion. The `value` prop binds to an array of strings, representing the opened items. The `onChange` prop updates this array.  It uses the `useState` hook to manage the array of selected values. This enables multiple accordion items to be open simultaneously.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/accordion.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Accordion } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string[]>([]);\n\n  return (\n    <Accordion multiple value={value} onChange={setValue}>\n      <Accordion.Item value=\"item-1\">\n        <Accordion.Control>control-1</Accordion.Control>\n        <Accordion.Panel>panel-1</Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item value=\"item-2\">\n        <Accordion.Control>control-2</Accordion.Control>\n        <Accordion.Panel>panel-2</Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing System Color Scheme Support\nDESCRIPTION: This code demonstrates how to enable system color scheme support. It imports `ColorSchemeScript` and `MantineProvider` from `@mantine/core`. By setting `defaultColorScheme=\"auto\"`, components will automatically adjust to the user's preferred color scheme based on the `prefers-color-scheme` media query. This requires manually setting the `defaultColorScheme` prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <ColorSchemeScript defaultColorScheme=\"auto\" />\n      <MantineProvider defaultColorScheme=\"auto\">\n        {/* Your app here */}\n      </MantineProvider>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Extending MantineTheme.other Type Declaration\nDESCRIPTION: Shows how to extend the Mantine theme's 'other' property types by declaring module augmentation in a .d.ts file for custom theme properties.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// mantine.d.ts\ndeclare module '@mantine/core' {\n  export interface MantineThemeOther {\n    myCustomProperty: string;\n    myCustomFunction: () => void;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Define Mantine Sass Resources\nDESCRIPTION: Defines essential Sass resources for use with Mantine, including variables for standard breakpoints, a `rem` function for calculating responsive sizes, and mixins for applying styles based on color scheme (`light`, `dark`), hover state, responsive breakpoints (`smaller-than`, `larger-than`), and direction (`rtl`, `ltr`). This file should be included globally via bundler config.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/sass.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n@use 'sass:math';\n\n// Define variables for your breakpoints,\n// values must be the same as in your theme\n$mantine-breakpoint-xs: '36em';\n$mantine-breakpoint-sm: '48em';\n$mantine-breakpoint-md: '62em';\n$mantine-breakpoint-lg: '75em';\n$mantine-breakpoint-xl: '88em';\n\n@function rem($value) {\n  @return #{math.div(math.div($value, $value * 0 + 1), 16)}rem;\n}\n\n@mixin light {\n  [data-mantine-color-scheme='light'] & {\n    @content;\n  }\n}\n\n@mixin dark {\n  [data-mantine-color-scheme='dark'] & {\n    @content;\n  }\n}\n\n@mixin hover {\n  @media (hover: hover) {\n    &:hover {\n      @content;\n    }\n  }\n\n  @media (hover: none) {\n    &:active {\n      @content;\n    }\n  }\n}\n\n@mixin smaller-than($breakpoint) {\n  @media (max-width: $breakpoint) {\n    @content;\n  }\n}\n\n@mixin larger-than($breakpoint) {\n  @media (min-width: $breakpoint) {\n    @content;\n  }\n}\n\n// Add direction mixins if you need rtl support\n@mixin rtl {\n  [dir='rtl'] & {\n    @content;\n  }\n}\n\n@mixin ltr {\n  [dir='ltr'] & {\n    @content;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Mantine Timeline Configuration Props in TypeScript\nDESCRIPTION: This snippet provides an interactive demo to control Timeline appearance via props like active step index, color highlighting, line width, bullet size, and alignment. Props control the visual state and layout of timeline items for customized UI presentation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/timeline.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<Demo data={TimelineDemos.configurator} />\n```\n\n----------------------------------------\n\nTITLE: Configuring Localization in Next.js App Router with DatesProvider (TypeScript)\nDESCRIPTION: Shows the specific implementation for localization within a Next.js App Router environment. It requires adding the `'use client';` directive at the top of the file where the dayjs locale is imported, ensuring the locale data is available on both the client and server, before configuring the DatesProvider.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/getting-started.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\n\nimport 'dayjs/locale/ru';\n\nimport { DatesProvider } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <DatesProvider settings={{ locale: 'ru' }}>\n      {/* Your app  */}\n    </DatesProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Mantine Theme Interface (TypeScript)\nDESCRIPTION: Defines the `MantineTheme` interface in TypeScript, outlining the structure of the theme object used to style Mantine components. This interface includes properties for colors, fonts, spacing, breakpoints, shadows, and other design tokens.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/theme-object.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\ninterface MantineTheme {\n  /** Controls focus ring styles. Supports the following options:\n   *  - `auto` – focus ring is displayed only when the user navigates with keyboard (default value)\n   *  - `always` – focus ring is displayed when the user navigates with keyboard and mouse\n   *  - `never` – focus ring is always hidden (not recommended)\n   */\n  focusRing: 'auto' | 'always' | 'never';\n\n  /** rem units scale, change if you customize font-size of `<html />` element\n   *  default value is `1` (for `100%`/`16px` font-size on `<html />`)\n   */\n  scale: number;\n\n  /** Determines whether `font-smoothing` property should be set on the body, `true` by default */\n  fontSmoothing: boolean;\n\n  /** White color */\n  white: string;\n\n  /** Black color */\n  black: string;\n\n  /** Object of colors, key is color name, value is an array of at least 10 strings (colors) */\n  colors: MantineThemeColors;\n\n  /** Index of theme.colors[color].\n   *  Primary shade is used in all components to determine which color from theme.colors[color] should be used.\n   *  Can be either a number (0–9) or an object to specify different color shades for light and dark color schemes.\n   *  Default value `{ light: 6, dark: 8 }`\n   *\n   *  For example,\n   *  { primaryShade: 6 } // shade 6 is used both for dark and light color schemes\n   *  { primaryShade: { light: 6, dark: 7 } } // different shades for dark and light color schemes\n   * */\n  primaryShade: MantineColorShade | MantinePrimaryShade;\n\n  /** Key of `theme.colors`, hex/rgb/hsl values are not supported.\n   *  Determines which color will be used in all components by default.\n   *  Default value – `blue`.\n   * */\n  primaryColor: string;\n\n  /** Function to resolve colors based on variant.\n   *  Can be used to deeply customize how colors are applied to `Button`, `ActionIcon`, `ThemeIcon`\n   *  and other components that use colors from theme.\n   * */\n  variantColorResolver: VariantColorsResolver;\n\n  /** Determines whether text color must be changed based on the given `color` prop in filled variant\n   *  For example, if you pass `color=\"blue.1\"` to Button component, text color will be changed to `var(--mantine-color-black)`\n   *  Default value – `false`\n   * */\n  autoContrast: boolean;\n\n  /** Determines which luminance value is used to determine if text color should be light or dark.\n   *  Used only if `theme.autoContrast` is set to `true`.\n   *  Default value is `0.3`\n   * */\n  luminanceThreshold: number;\n\n  /** font-family used in all components, system fonts by default */\n  fontFamily: string;\n\n  /** Monospace font-family, used in code and other similar components, system fonts by default  */\n  fontFamilyMonospace: string;\n\n  /** Controls various styles of h1-h6 elements, used in TypographyStylesProvider and Title components */\n  headings: {\n    fontFamily: string;\n    fontWeight: string;\n    textWrap: 'wrap' | 'nowrap' | 'balance' | 'pretty' | 'stable';\n    sizes: {\n      h1: HeadingStyle;\n      h2: HeadingStyle;\n      h3: HeadingStyle;\n      h4: HeadingStyle;\n      h5: HeadingStyle;\n      h6: HeadingStyle;\n    };\n  };\n\n  /** Object of values that are used to set `border-radius` in all components that support it */\n  radius: MantineRadiusValues;\n\n  /** Key of `theme.radius` or any valid CSS value. Default `border-radius` used by most components */\n  defaultRadius: MantineRadius;\n\n  /** Object of values that are used to set various CSS properties that control spacing between elements */\n  spacing: MantineSpacingValues;\n\n  /** Object of values that are used to control `font-size` property in all components */\n  fontSizes: MantineFontSizesValues;\n\n  /** Object of values that are used to control `line-height` property in `Text` component */\n  lineHeights: MantineLineHeightValues;\n\n  /** Object of values that are used to control breakpoints in all components,\n   *  values are expected to be defined in em\n   * */\n  breakpoints: MantineBreakpointsValues;\n\n  /** Object of values that are used to add `box-shadow` styles to components that support `shadow` prop */\n  shadows: MantineShadowsValues;\n\n  /** Determines whether user OS settings to reduce motion should be respected, `false` by default */\n  respectReducedMotion: boolean;\n\n  /** Determines which cursor type will be used for interactive elements\n   * - `default` – cursor that is used by native HTML elements, for example, `input[type=\"checkbox\"]` has `cursor: default` styles\n   * - `pointer` – sets `cursor: pointer` on interactive elements that do not have these styles by default\n   */\n  cursorType: 'default' | 'pointer';\n\n  /** Default gradient configuration for components that support `variant=\"gradient\"` */\n  defaultGradient: MantineGradient;\n\n  /** Class added to the elements that have active styles, for example, `Button` and `ActionIcon` */\n  activeClassName: string;\n\n  /** Class added to the elements that have focus styles, for example, `Button` or `ActionIcon`.\n   *  Overrides `theme.focusRing` property.\n   */\n  focusClassName: string;\n\n  /** Allows adding `classNames`, `styles` and `defaultProps` to any component */\n  components: MantineThemeComponents;\n\n  /** Any other properties that you want to access with the theme objects */\n  other: MantineThemeOther;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Header Components Using Yarn - Bash\nDESCRIPTION: This snippet demonstrates how to install the @mantinex/mantine-header library using the yarn package manager. Yarn must be installed on your system prior to running this command. The package is added to your project dependencies, enabling you to import and use Mantine header components in your application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/mantine-header/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @mantinex/mantine-header\n```\n\n----------------------------------------\n\nTITLE: Comparing ColorSchemeScript and MantineProvider defaultColorScheme (TSX)\nDESCRIPTION: This snippet demonstrates the correct and incorrect ways to use the `defaultColorScheme` prop with `ColorSchemeScript` and `MantineProvider` in a Mantine application. A mismatch in `defaultColorScheme` values between these two components is highlighted as the primary cause of color scheme flickering (FART) in SSR/SSG setups, while matching values prevent this issue.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-flickering.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\n// ❌ Incorrect usage – defaultColorScheme values do not match,\n// this will cause color scheme flickering\nfunction IncorrectDemo() {\n  return (\n    <>\n      <ColorSchemeScript defaultColorScheme=\"light\" />\n      <MantineProvider defaultColorScheme=\"auto\">\n        {/* Your app here */}\n      </MantineProvider>\n    </>\n  );\n}\n\n// ✅ Correct usage – defaultColorScheme values match, no FART\nfunction CorrectDemo() {\n  return (\n    <>\n      <ColorSchemeScript defaultColorScheme=\"light\" />\n      <MantineProvider defaultColorScheme=\"light\">\n        {/* Your app here */}\n      </MantineProvider>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring FocusTrap for Initial Focus in Drawer\nDESCRIPTION: This code demonstrates adding 'data-autofocus' attribute for elements to receive initial focus when a Drawer opens. It also shows how to use 'FocusTrap.InitialFocus' for custom focus setup, ensuring accessibility and user experience considerations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/drawer.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Drawer } from '@mantine/core';\n\nfunction Demo() {\n  return <Drawer title=\"Drawer label\" opened onClose={() => {}} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Header/Footer Configuration Interface in TypeScript\nDESCRIPTION: Presents the TypeScript interface defining the configuration options for the `AppShell.Header` and `AppShell.Footer` components via the `header` and `footer` props on the main `AppShell`. Key properties include `height` (which can be a number, string, or responsive object) and optional `collapsed` and `offset` booleans.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\ninterface Configuration {\n  /** Height of the section: number, string or\n   ** object with breakpoints as keys and height as value */\n  height: AppShellSize | AppShellResponsiveSize;\n\n  /** If section is collapsed,\n   ** it is hidden from the viewport and is not offset in AppShell.Main */\n  collapsed?: boolean;\n\n  /** Determines whether the section should be offset by the AppShell.Main.\n   ** For example, it is useful if you want to\n   ** hide header based on the scroll position. */\n  offset?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Using UseInterval Hook with Auto Invocation in Mantine (TSX)\nDESCRIPTION: Demonstrates how to use the `useInterval` hook from `@mantine/hooks` to automatically start an interval upon component mount. It calls a function (`console.log`) every 1000ms and starts immediately due to the `autoInvoke: true` option. Requires `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-interval.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useInterval } from '@mantine/hooks';\n\nconst interval = useInterval(\n  () => console.log('Interval tick'),\n  1000,\n  { autoInvoke: true }\n);\n```\n\n----------------------------------------\n\nTITLE: Clearing All Form Errors with clearErrors – Mantine\nDESCRIPTION: Shows how to clear all existing form errors using the `form.clearErrors` handler. This can be used to reset the error state when the form is submitted or when input values change.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialErrors: { name: 'Too short', email: 'Invalid email' },\n});\n\nform.clearErrors();\n\nform.errors; // -> {}\n\n```\n\n----------------------------------------\n\nTITLE: Defining the useShallowEffect Hook Signature in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for the `useShallowEffect` hook. It specifies the expected callback function (`cb`) that returns void and the optional dependency list (`dependencies`) which is a React.DependencyList.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-shallow-effect.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useShallowEffect(\n  cb: () => void,\n  dependencies?: React.DependencyList\n): void;\n```\n\n----------------------------------------\n\nTITLE: Validating with Superstruct using useForm\nDESCRIPTION: This snippet demonstrates form validation using Superstruct with Mantine Form. It defines a Superstruct schema for validating name, email, and age and then uses `superstructResolver` to integrate with the form.  The example then shows how to access and interpret the errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport isEmail from 'is-email';\nimport { superstructResolver } from 'mantine-form-superstruct-resolver';\nimport * as s from 'superstruct';\n\nconst emailString = s.define('email', isEmail);\n\nconst schema = s.object({\n  name: s.size(s.string(), 2, 30),\n  email: emailString,\n  age: s.min(s.number(), 18),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: superstructResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//   name: 'name: Expected a string with a length between `2` and `30` but received one with a length of `0`',\n//   email: 'email: Expected a value of type `email`, but received: `\"\"`',\n//   age: 'age: Expected a number greater than or equal to 18 but received `16`',\n// }\n```\n\n----------------------------------------\n\nTITLE: Implementing accessibility features in AngleSlider\nDESCRIPTION: Provides an example of making the AngleSlider accessible by supporting keyboard interactions for adjusting the angle, and setting aria-label for screen readers to improve accessibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/angle-slider.mdx#_snippet_5\n\nLANGUAGE: JSX\nCODE:\n```\nimport { AngleSlider } from '@mantine/core';\n\nfunction Demo() {\n  return <AngleSlider aria-label=\"Gradient angle\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Rendering React Components with MantineProvider in TSX\nDESCRIPTION: Provides a custom `render` function using `@testing-library/react` that automatically wraps the tested component (`ui`) with `MantineProvider`. This is necessary because Mantine components require `MantineProvider` in the component tree. Requires `@testing-library/react` and `@mantine/core`, and a theme object.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/jest.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// ./test-utils/render.tsx\nimport { render as testingLibraryRender } from '@testing-library/react';\nimport { MantineProvider } from '@mantine/core';\n// Import your theme object\nimport { theme } from '../src/theme';\n\nexport function render(ui: React.ReactNode) {\n  return testingLibraryRender(<>{ui}</>, {\n    wrapper: ({ children }: { children: React.ReactNode }) => (\n      <MantineProvider theme={theme}>{children}</MantineProvider>\n    ),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Components with Default Props using Mantine withProps (tsx)\nDESCRIPTION: This snippet demonstrates how to use the static withProps function available on Mantine components to create new components with pre-defined default props. It shows examples creating a LinkButton from Button (setting link-specific props) and a PhoneInput from InputBase (integrating IMaskInput and setting input-specific props), illustrating how subsequent props passed to the new component override the defaults set by withProps. Requires react, @mantine/core, and react-imask.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/default-props.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IMaskInput } from 'react-imask';\nimport { Button, InputBase } from '@mantine/core';\n\nconst LinkButton = Button.withProps({\n  component: 'a',\n  target: '_blank',\n  rel: 'noreferrer',\n  variant: 'subtle',\n});\n\nconst PhoneInput = InputBase.withProps({\n  mask: '+7 (000) 000-0000',\n  component: IMaskInput,\n  label: 'Your phone number',\n  placeholder: 'Your phone number',\n});\n\nfunction Demo() {\n  return (\n    <>\n      {/* You can pass additional props to components created with `withProps` */}\n      <LinkButton href=\"https://mantine.dev\">\n        Mantine website\n      </LinkButton>\n\n      {/* Component props override default props defined in `withProps` */}\n      <PhoneInput placeholder=\"Personal phone\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Mantine Theme Tokens in CSS Modules (SCSS)\nDESCRIPTION: Shows how to use Mantine theme values (colors, spacing, fonts) within CSS Modules by referencing the corresponding CSS variables provided by Mantine (e.g., `var(--mantine-color-red-5)`, `var(--mantine-spacing-md)`, `var(--mantine-font-family-headings)`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_6\n\nLANGUAGE: scss\nCODE:\n```\n.root {\n  // references theme.colors.red[5]\n  background: var(--mantine-color-red-5);\n\n  // references theme.spacing.md\n  margin-top: var(--mantine-spacing-md);\n\n  // references theme.headings.fontFamily\n  font-family: var(--mantine-font-family-headings);\n}\n```\n\n----------------------------------------\n\nTITLE: Using useUncontrolled for a Custom Input Component (TSX)\nDESCRIPTION: Demonstrates implementing a custom input component in React using the `useUncontrolled` hook. The hook manages the input's state, accepting `value`, `defaultValue`, `finalValue`, and an `onChange` handler, returning the current value and a change handler function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-uncontrolled.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useUncontrolled } from '@mantine/hooks';\n\ninterface CustomInputProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n}\n\nfunction CustomInput({\n  value,\n  defaultValue,\n  onChange,\n}: CustomInputProps) {\n  const [_value, handleChange] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: 'Final',\n    onChange,\n  });\n\n  return (\n    <input\n      type=\"text\"\n      value={_value}\n      onChange={(event) => handleChange(event.currentTarget.value)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring useCombobox Hook with Event Handlers in Mantine (TypeScript)\nDESCRIPTION: Shows configuring the useCombobox hook with onDropdownOpen and onDropdownClose event handlers that invoke store methods to select the first option when opening and reset selected option when closing the dropdown. This pattern enhances responsive UI behavior for dropdown opening and closing events.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/combobox.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Combobox, useCombobox } from '@mantine/core';\n\nfunction Demo() {\n  const combobox = useCombobox({\n    onDropdownOpen: () => combobox.selectFirstOption(),\n    onDropdownClose: () => combobox.resetSelectedOption(),\n  });\n\n  return (\n    <Combobox store={combobox}>{/* Your implementation */}</Combobox>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Select Options with `renderOption` in Mantine (TSX)\nDESCRIPTION: Demonstrates using the `renderOption` prop on Mantine's `Select` component to customize the rendering of dropdown options. A custom function `renderSelectOption` receives option data and checked status, returning a React node with an icon, label, and a checkmark if selected. This feature is also available for MultiSelect, TagsInput, and Autocomplete components. Dependencies include `@mantine/core` for components and types, and `@tabler/icons-react` for icons.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.6.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  IconAlignCenter,\n  IconAlignJustified,\n  IconAlignLeft,\n  IconAlignRight,\n  IconCheck,\n} from '@tabler/icons-react';\nimport { Group, Select, SelectProps } from '@mantine/core';\n\nconst iconProps = {\n  stroke: 1.5,\n  color: 'currentColor',\n  opacity: 0.6,\n  size: 18,\n};\n\nconst icons: Record<string, React.ReactNode> = {\n  left: <IconAlignLeft {...iconProps} />,\n  center: <IconAlignCenter {...iconProps} />,\n  right: <IconAlignRight {...iconProps} />,\n  justify: <IconAlignJustified {...iconProps} />,\n};\n\nconst renderSelectOption: SelectProps['renderOption'] = ({ option, checked }) => (\n  <Group flex=\"1\" gap=\"xs\">\n    {icons[option.value]}\n    {option.label}\n    {checked && <IconCheck style={{ marginInlineStart: 'auto' }} {...iconProps} />}\n  </Group>\n);\n\nfunction Demo() {\n  return (\n    <Select\n      label=\"Select with renderOption\"\n      placeholder=\"Select text align\"\n      data={[\n        { value: 'left', label: 'Left' },\n        { value: 'center', label: 'Center' },\n        { value: 'right', label: 'Right' },\n        { value: 'justify', label: 'Justify' },\n      ]}\n      renderOption={renderSelectOption}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Primary Shade for Light and Dark Color Schemes\nDESCRIPTION: Demonstrates how to customize the primaryShade separately for light and dark color schemes. This affects which shade of the primary color will be used by components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/colors.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={{ primaryShade: { light: 6, dark: 8 } }}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Drawer Usage with Size Prop in React\nDESCRIPTION: This snippet demonstrates how to implement a Drawer component with a customizable size, set to 'xl', and controlled via the 'opened' and 'onClose' props. It showcases the core React rendering approach for drawers with adjustable dimensions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/drawer.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Drawer } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Drawer position=\"right\" size=\"xl\" opened onClose={() => {}}\n      >{/* Drawer content */}\n    </Drawer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Setting Form Submitting State - useForm Hook in Mantine with TypeScript\nDESCRIPTION: Shows how to manually set and access the form.submitting state using useForm from @mantine/form. The setSubmitting(true|false) method can be invoked at any time to toggle submission state for custom workflows. Useful for advanced scenarios where automatic state tracking is insufficient. No UI rendering involved in this minimal demonstration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_7\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({ mode: 'uncontrolled' });\nform.submitting; // -> false\n\nform.setSubmitting(true);\nform.submitting; // -> true\n\nform.setSubmitting(false);\nform.submitting; // -> false\n```\n\n----------------------------------------\n\nTITLE: Validating List Fields with Yup and useForm\nDESCRIPTION: This snippet demonstrates validating list fields using Yup with Mantine Form. It defines a Yup schema for an array of objects. The example showcases how the validation results are structured for the array items.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { yupResolver } from 'mantine-form-yup-resolver';\nimport * as yup from 'yup';\nimport { useForm } from '@mantine/form';\n\nconst listSchema = yup.object().shape({\n  list: yup.array().of(\n    yup.object().shape({\n      name: yup\n        .string()\n        .min(2, 'Name should have at least 2 letters'),\n    })\n  ),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    list: [{ name: '' }],\n  },\n  validate: yupResolver(listSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'list.0.name': 'Name should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Configuring Valibot Resolver for List Fields Validation\nDESCRIPTION: This example illustrates Valibot validation on list fields within a form.  It uses `array` to define a schema for a list of objects. The schema is applied to the form with `valibotResolver`. Dependencies are `@mantine/form`, `valibot`, and `mantine-form-valibot-resolver`.  Validation errors are found in `form.errors` after calling `form.validate()`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nimport { valibotResolver } from 'mantine-form-valibot-resolver';\nimport { array, minLength, object, string } from 'valibot';\nimport { useForm } from '@mantine/form';\n\nconst listSchema = object({\n  list: array(\n    object({\n      name: string([minLength(2, 'Name should have at least 2 letters')]),\n    })\n  ),\n});\n\nconst form = useForm({\n  initialValues: {\n    list: [{ name: '' }],\n  },\n  validate: valibotResolver(listSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'list.0.name': 'Name should have at least 2 letters',\n// }\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Mantine Modal Component (TSX)\nDESCRIPTION: This snippet defines a basic React component called AuthModal using Mantine components. It demonstrates the use of Modal, Button, TextInput, PasswordInput, and the useDisclosure hook from @mantine/hooks to manage the modal's open/closed state. The component includes a button to open the modal and a simple form inside the modal.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/portals-testing.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Modal, PasswordInput, TextInput } from '@mantine/core';\nimport { useDisclosure } from '@mantine/hooks';\n\nexport function AuthModal() {\n  const [opened, { open, close }] = useDisclosure();\n\n  return (\n    <>\n      <Modal title=\"Authenticate\" opened={opened} onClose={close}>\n        <form\n          onSubmit={(event) => {\n            event.preventDefault();\n            close();\n          }}\n        >\n          <TextInput data-autofocus label=\"Username\" placeholder=\"Enter your username\" />\n          <PasswordInput label=\"Password\" placeholder=\"Enter your password\" />\n          <Button type=\"submit\">Log in</Button>\n        </form>\n      </Modal>\n\n      <Button onClick={open}>Open authentication modal</Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: UseInterval Hook API Usage in Mantine (TSX)\nDESCRIPTION: Illustrates how to capture the return value of the `useInterval` hook, which provides control over the interval. The returned object includes `start`, `stop`, `toggle` functions and an `active` status boolean. Requires `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-interval.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useInterval } from '@mantine/hooks';\n\nconst { start, stop, toggle, active } = useInterval(fn, interval);\n```\n\n----------------------------------------\n\nTITLE: Customizing Heading Styles with Mantine Theme (TypeScript)\nDESCRIPTION: Illustrates how to set specific styles for headings (h1-h6) within the theme object, including fontWeight, fontSize, and lineHeight. This allows individual customization of each heading level to match desired design specifications.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/typography.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineProvider, rem } from '@mantine/core';\n\nconst theme = createTheme({\n  headings: {\n    // properties for all headings\n    fontWeight: '400',\n    fontFamily: 'Roboto',\n\n    // properties for individual headings, all of them are optional\n    sizes: {\n      h1: {\n        fontWeight: '100',\n        fontSize: rem(36),\n        lineHeight: '1.4',\n      },\n      h2: { fontSize: rem(30), lineHeight: '1.5' },\n      // ...up to h6\n      h6: { fontWeight: '900' },\n    },\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing component styles with component.extend function\nDESCRIPTION: Shows how to use the extend function to customize a component's styles, classNames, and defaultProps with full TypeScript support. This example customizes the TextInput component with conditional styling based on props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { TextInput, MantineProvider, createTheme } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extends({\n      styles: (theme, props) => ({\n        input: {\n          fontSize: props.size === 'compact' ? theme.fontSizes.sm : undefined,\n        }\n      })\n      classNames: {\n        root: classes.root,\n        input: classes.input,\n        label: classes.label,\n      },\n\n      defaultProps: {\n        size: 'compact',\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <App />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for React UI\nDESCRIPTION: This snippet imports necessary modules and components to build the React application, specifically pulling in demos from various files and the Layout component used for structuring the application.  It imports data from MDX files as well.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-9-0.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  BarChartDemos,\n  EmotionDemos,\n  FieldDemos,\n  StylesDemos,\n} from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Retrieving Input Element Reference via GetElementRef\nDESCRIPTION: This snippet displays how to obtain a reference to the DateInput's input element using the GetElementRef component, which facilitates direct DOM manipulations or integrations with other libraries, specifying refType as 'input'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n<GetElementRef\n  component=\"DateInput\"\n  refType=\"input\"\n  package=\"@mantine/dates\" />\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Mantine Server Components Issues\nDESCRIPTION: References Help Center article for resolving common issues related to Mantine components, server components, and Next.js app router configurations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Exporting Default Page Component with Layout\nDESCRIPTION: Exports the default React component for the page. It applies the common `Layout` component, passing in specific MDX content related to the List component (`MDX_DATA.List`) as its child or configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/list.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default Layout(MDX_DATA.List);\n```\n\n----------------------------------------\n\nTITLE: Limiting maximum selected tags with maxTags prop\nDESCRIPTION: This snippet demonstrates restricting the number of tags a user can select by using the 'maxTags' prop, which prevents adding more tags once the limit is reached, ensuring controlled selection count.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.maxTags} />\n```\n\n----------------------------------------\n\nTITLE: Applying SVG Pattern Fill to BarChart Component in Mantine Using TypeScript React\nDESCRIPTION: Shows usage of Mantine's BarChart component with customized series colors using SVG pattern fills. It defines SVG patterns within the component children via 'defs' element. Patterns include diagonal stripes and crosshatch with stroke and fill styles defined using CSS color functions. The BarChart visualizes data passed with custom colors referencing pattern IDs. Dependencies include '@mantine/charts' and properly prepared data. Input data drives the chart rendering; output is a visually enhanced bar chart with patterned fills.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={mixedStackData}\n      dataKey=\"month\"\n      series=[\n        { name: 'Smartphones', color: 'url(#crosshatch)', stackId: 'a' },\n        { name: 'Laptops', color: 'blue.6', stackId: 'b' },\n        { name: 'Tablets', color: 'url(#diagonalStripes)', stackId: 'b' },\n      ]\n    >\n      <defs>\n        <pattern\n          id=\"diagonalStripes\"\n          patternUnits=\"userSpaceOnUse\"\n          width={6}\n          height={8}\n          patternTransform=\"rotate(45)\"\n        >\n          <rect\n            width=\"2\"\n            height=\"8\"\n            transform=\"translate(0,0)\"\n            fill=\"color-mix(in lch, var(--mantine-color-teal-6) 70%, rgba(0,0,0,0))\"\n          />\n        </pattern>\n\n        <pattern id=\"crosshatch\" patternUnits=\"userSpaceOnUse\" width={8} height={8}>\n          <path\n            d=\"M 0 0 L 8 0 L 8 8 L 0 8 Z\"\n            fill=\"none\"\n            stroke=\"color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))\"\n            strokeWidth=\"1\"\n          />\n          <path\n            d=\"M 0 0 L 8 8\"\n            stroke=\"color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))\"\n            strokeWidth=\"1\"\n          />\n          <path\n            d=\"M 8 0 L 0 8\"\n            stroke=\"color-mix(in lch, var(--mantine-color-indigo-6) 70%, rgba(0,0,0,0))\"\n            strokeWidth=\"1\"\n          />\n        </pattern>\n      </defs>\n    </BarChart>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using rem/em Utilities in Vanilla Extract Styles (TypeScript)\nDESCRIPTION: Shows how to use the `rem` and `em` utility functions from `@mantine/core` within Vanilla Extract style definitions. This allows converting pixel values to relative units, useful for accessibility and responsive design, including within media queries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// Demo.css.ts\nimport { style } from '@vanilla-extract/css';\nimport { rem } from '@mantine/core';\n\nexport const demo = style({\n  fontSize: rem(16),\n\n  '@media': {\n    [`(min-width: ${em(768)})`]: {\n      fontSize: rem(18),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering List Demo with Custom Icons\nDESCRIPTION: Uses a custom `<Demo>` component to display an example of the Mantine List component featuring custom icons. The `ListDemos.icon` object contains the specific implementation details. The surrounding text explains relevant props like `icon`, `spacing`, `center`, and `size`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/list.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ListDemos.icon} />\n```\n\n----------------------------------------\n\nTITLE: Fixing FileButton issue with keepMounted - Mantine/React\nDESCRIPTION: This snippet references an external demo component (`FileButtonMenuFix.demo`) that illustrates the first solution. It shows how setting the `keepMounted` prop on the `Menu` component prevents the `FileButton` from unmounting when the menu closes, allowing the `onChange` callback to fire.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/file-button-in-menu.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={FileButtonMenuFix} />\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition for useWindowEvent Hook (TypeScript)\nDESCRIPTION: This snippet shows the TypeScript type definition for the useWindowEvent hook, indicating how it mirrors the window.addEventListener signature. It requires TypeScript 4 or later and depends on correct typings for WindowEventMap. Parameters include the event type (type), listener callback, and optional options mirroring those in addEventListener. The function does not return any value (void). The snippet serves as reference for usage and expected argument types.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-window-event.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nfunction useWindowEvent<K extends keyof WindowEventMap>(\n  type: K,\n  listener: (this: Window, ev: WindowEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n): void;\n```\n\n----------------------------------------\n\nTITLE: Using the use-field Hook for Form Validation in React\nDESCRIPTION: Shows how to use the new use-field hook from @mantine/form to manage a single input field state with validation, which serves as a simpler alternative to the use-form hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.9.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\nimport { isEmail, useField } from '@mantine/form';\n\nfunction Demo() {\n  const field = useField({\n    initialValue: '',\n    validateOnChange: true,\n    validate: isEmail('Invalid email'),\n  });\n\n  return <TextInput {...field.getInputProps()} label=\"Email\" placeholder=\"Enter your email\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Mantine Dropzone Accept Types by Mime Array (TSX)\nDESCRIPTION: Shows an alternative way to define accepted file types using an array of specific mime type strings. This method is useful for listing exact allowed types directly in the array. 'onDrop' is a required prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/dropzone.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Dropzone } from '@mantine/dropzone';\n\nfunction Demo() {\n  return (\n    <Dropzone\n      accept={[\n        'image/png',\n        'image/jpeg',\n        'image/svg+xml',\n        'image/gif',\n      ]}\n      onDrop={() => {}}\n    >\n      {/* children */}\n    </Dropzone>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Get computed color scheme with useComputedColorScheme in React component (TSX)\nDESCRIPTION: Demonstrates how to get the computed color scheme value (resolved from 'auto' to either 'dark' or 'light') within a React component using the `useComputedColorScheme` hook from `@mantine/core`. This hook utilizes localStorage and is not suitable for server-side rendering (SSR).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-get-color-scheme-value-in-js.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useComputedColorScheme } from '@mantine/core';\n\nfunction Demo() {\n  // colorScheme is `'dark' | 'light'`\n  const colorScheme = useComputedColorScheme();\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Page Metadata and Layout in JavaScript\nDESCRIPTION: This JavaScript snippet imports a `Layout` component and defines a `meta` object containing metadata (title, description, slug, category, tags, creation/update dates) for a documentation page. It then exports the `Layout` component initialized with this metadata as the default export, likely for use in a framework like Next.js or Gatsby.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/roadmap.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'Where can I find the roadmap?',\n  description:\n    'The roadmap is private and only available to the team.',\n  slug: 'roadmap',\n  category: 'about',\n  tags: ['project', 'roadmap'],\n  created_at: 'February 15, 2024',\n  last_updated_at: 'February 15, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Modals with Modal.Stack and useModalsStack Hook in TypeScript React\nDESCRIPTION: Demonstrates usage of Mantine's Modal.Stack component combined with the useModalsStack hook to manage multiple modal dialogs simultaneously. The hook accepts an array of unique modal IDs and controls modal opening, closing, and stacking with proper z-index management, focus trap, and escape key handling. The example shows three modals with cascading open/close behavior and buttons triggering state changes. Dependencies include '@mantine/core' and internal hook useModalsStack. Inputs are modal IDs and user interactions; outputs are modal visibility states and focus management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Group, Modal, useModalsStack } from '@mantine/core';\n\nfunction Demo() {\n  const stack = useModalsStack(['delete-page', 'confirm-action', 'really-confirm-action']);\n\n  return (\n    <>\n      <Modal.Stack>\n        <Modal {...stack.register('delete-page')} title=\"Delete this page?\">\n          Are you sure you want to delete this page? This action cannot be undone.\n          <Group mt=\"lg\" justify=\"flex-end\">\n            <Button onClick={stack.closeAll} variant=\"default\">\n              Cancel\n            </Button>\n            <Button onClick={() => stack.open('confirm-action')} color=\"red\">\n              Delete\n            </Button>\n          </Group>\n        </Modal>\n\n        <Modal {...stack.register('confirm-action')} title=\"Confirm action\">\n          Are you sure you want to perform this action? This action cannot be undone. If you are\n          sure, press confirm button below.\n          <Group mt=\"lg\" justify=\"flex-end\">\n            <Button onClick={stack.closeAll} variant=\"default\">\n              Cancel\n            </Button>\n            <Button onClick={() => stack.open('really-confirm-action')} color=\"red\">\n              Confirm\n            </Button>\n          </Group>\n        </Modal>\n\n        <Modal {...stack.register('really-confirm-action')} title=\"Really confirm action\">\n          Jokes aside. You have confirmed this action. This is your last chance to cancel it. After\n          you press confirm button below, action will be performed and cannot be undone. For real\n          this time. Are you sure you want to proceed?\n          <Group mt=\"lg\" justify=\"flex-end\">\n            <Button onClick={stack.closeAll} variant=\"default\">\n              Cancel\n            </Button>\n            <Button onClick={stack.closeAll} color=\"red\">\n              Confirm\n            </Button>\n          </Group>\n        </Modal>\n      </Modal.Stack>\n\n      <Button onClick={() => stack.open('delete-page')}>Open modal</Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Text Component with Style Props in TSX\nDESCRIPTION: Demonstrates using Mantine's style props (`c` for color, `fz` for font-size) on the `Text` component to directly apply specific CSS properties for text styling. This example imports the `Text` component from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <div>\n      <Text c=\"blue.8\" fz=\"lg\">\n        Card title\n      </Text>\n      <Text c=\"dimmed\" fz=\"sm\">\n        Card description\n      </Text>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the useFileDialog Hook Signature in TypeScript\nDESCRIPTION: Provides the TypeScript function signature for the `use-file-dialog` hook. It accepts an optional `UseFileDialogOptions` object and returns an object containing the selected `files` (FileList or null), an `open` function to trigger the file dialog, and a `reset` function to clear the selection.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-file-dialog.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useFileDialog(input?: UseFileDialogOptions): {\n    files: FileList | null;\n    open: () => void;\n    reset: () => void;\n}\n```\n\n----------------------------------------\n\nTITLE: CompositeChart with Custom Grid and Text Colors\nDESCRIPTION: Demonstrates how to customize the grid and text colors of a CompositeChart using the `gridColor` and `textColor` props. It uses sample data and configures the chart with line, bar, and area series, each with a specified name and color. The `dataKey` prop is set to 'date' to map the data accordingly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/composite-chart.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { CompositeChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <CompositeChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      gridColor=\"gray.5\"\n      textColor=\"gray.9\"\n      series={[\n        { name: 'Apples', color: 'indigo.6', type: 'line' },\n        { name: 'Oranges', color: 'blue.6', type: 'bar' },\n        { name: 'Tomatoes', color: 'teal.6', type: 'area' },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Modal Accessibility Configuration\nDESCRIPTION: Demonstrates how to set the accessibility props of the Modal component. It shows how to set `title` props for accessibility and to configure the aria-label for the close button, enhancing the accessibility of the modal.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/modal.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Modal } from '@mantine/core';\n\nfunction Demo() {\n  return <Modal title=\"Modal label\" opened onClose={() => {}} />;\n}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Modal } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Modal\n      closeButtonProps={{ 'aria-label': 'Close modal' }}\n      opened\n      onClose={() => {}}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Generated CSS from @mixin hover for Hover and Touch Devices\nDESCRIPTION: Displays the resulting CSS generated by `postcss-preset-mantine` when the `@mixin hover` is used. It includes separate media queries targeting hover-capable devices (`@media (hover: hover)` with `:hover`) and touch-only devices (`@media (hover: none)` with `:active`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-add-hover-styles.mdx#_snippet_3\n\nLANGUAGE: scss\nCODE:\n```\n@media (hover: hover) {\n  .demo:hover {\n    color: orange;\n  }\n}\n\n@media (hover: none) {\n  .demo:active {\n    color: orange;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Numbers with NumberFormatter in Mantine (TypeScript/React)\nDESCRIPTION: Demonstrates usage of the Mantine NumberFormatter component in a React function to display a number with a currency prefix and thousands separator. The snippet depends on '@mantine/core' and renders formatted values for display. Key props include 'prefix', 'value', and 'thousandSeparator'. The output is a formatted string element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { NumberFormatter } from '@mantine/core';\n\nfunction Demo() {\n  return <NumberFormatter prefix=\"$ \" value={1000000} thousandSeparator />;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Options with String Array to Mantine NativeSelect (TSX)\nDESCRIPTION: This example illustrates how to populate the options of a Mantine NativeSelect component by passing a simple array of strings to the data prop. Each string in the array becomes an option with the same label and value.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/native-select.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NativeSelect } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <NativeSelect data={['React', 'Angular', 'Svelte', 'Vue']} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Polymorphic Component Types and Usage\nDESCRIPTION: This snippet discusses the type inference of polymorphic components in Mantine, illustrating how component props are determined based on the 'component' prop or default element, with code examples using the Box component for different root elements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/polymorphic-in-polymorphic.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n## Polymorphic components types\n\nPolymorphic components types are defined by the type of the root element\nwhich is not known until the component is used.\n\nExample:\n\n```tsx\nimport { Box } from '@mantine/core';\n\n// MyBox component props types are now known\n// Types will be assigned only when MyBox is used\nconst MyBox = Box;\n\nfunction Demo() {\n  // MyBox props type can be determined based on\n  // `component` prop or its absence\n  // In this case MyBox props type contain\n  // React.ComponentProps<'div'>\n  return <MyBox>Hello</MyBox>;\n}\n\nfunction Demo2() {\n  // In this case MyBox props type contain\n  // React.ComponentProps<'a'>\n  return <MyBox component=\"a\" href=\"https://mantine.dev/\" />;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Colors with CSS Variables in Mantine\nDESCRIPTION: This snippet demonstrates how to use colors defined in the Mantine theme via CSS variables. Each color has 10 shades (0-9) accessible through the `--mantine-color-{color}-{shade}` CSS variable. This allows for consistent and theme-aware color usage in CSS styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_4\n\nLANGUAGE: css\nCODE:\n```\n.demo {\n  background: var(--mantine-color-blue-9);\n  color: var(--mantine-color-blue-0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Form Context from a Separate File - Child Component\nDESCRIPTION: Example of importing and using the form context in a child component to create a form input field that accesses the shared form state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/create-form-context.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// NameInput.tsx\nimport { TextInput } from '@mantine/core';\nimport { useUserFormContext } from './form-context';\n\nexport function NameInput() {\n  const form = useUserFormContext();\n  return (\n    <TextInput\n      label=\"Name\"\n      key={form.key('name')}\n      {...form.getInputProps('name')}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Mantine Theme - TypeScript\nDESCRIPTION: This snippet defines a custom theme for the Mantine UI library. It uses the `createTheme` function to create a theme object. The `colors` property is used to define a custom color scheme named 'sepia' with a set of color shades. The theme object is then used with the `MantineProvider` to apply the theme to the application. Required dependencies include `@mantine/core`. The output is the rendered app with the sepia theme applied.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/light-dark-is-not-enough.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    sepia: [\n      '#F4ECD8',\n      '#EAD8B7',\n      '#DFC29A',\n      '#D4AC7E',\n      '#C99862',\n      '#BD8447',\n      '#B2702D',\n      '#A55C15',\n      '#924908',\n      '#7A3704',\n    ],\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <App />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rem Units Scaling\nDESCRIPTION: This snippet illustrates how to scale the `rem` units within a Mantine application. It imports `createTheme` and `MantineProvider` from `@mantine/core`. By setting the `scale` property in the `createTheme` function, you can modify the scaling factor for the rem units to control the overall size of the Mantine components and ensure the components maintain their relative sizes, especially when adjusting the `html` or `:root` font size.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  scale: 1.6,\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Tiptap and Dependencies with Package Managers\nDESCRIPTION: Commands to install the required packages for using Mantine Tiptap. The installation requires @mantine/core and @mantine/hooks for the UI components, along with @tiptap/react and @tiptap/extension-link for the editor functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/tiptap/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/core @mantine/hooks @tiptap/react @tiptap/extension-link\n\n# With npm\nnpm install @mantine/core @mantine/hooks @tiptap/react @tiptap/extension-link\n```\n\n----------------------------------------\n\nTITLE: Generating Color Palettes with @mantine/colors-generator\nDESCRIPTION: Imports the generateColors function from '@mantine/colors-generator' and demonstrates usage within a Mantine theme to create dynamic color palettes based on a single base color. Suitable for customizing themes with consistent color schemes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { generateColors } from '@mantine/colors-generator';\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    'pale-blue': generateColors('#375EAC'),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Shift and Flip Middlewares in Popover\nDESCRIPTION: This code snippet shows how to disable the `shift` and `flip` middlewares in the Mantine Popover component. The `middlewares` prop is used to configure the behavior of the Popover's positioning. By setting `flip` and `shift` to `false`, the Popover will not automatically adjust its position to stay within the viewport.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/popover.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Popover } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover\n      middlewares={{ flip: false, shift: false }}\n      position=\"bottom\"\n    >\n      {/* Popover content */}\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using FZ style prop to apply font size in React\nDESCRIPTION: Provides an example of applying a specific font size variable to a Text component via the fz style prop in React.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Text fz=\"xl\">\n      This text uses --mantine-font-size-xl variable\n    </Text>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Redirect component to navigate to a specific URL\nDESCRIPTION: This snippet renders the Redirect component to navigate users automatically to the '/x/code-highlight' path. It relies on the imported Redirect component to handle the routing logic, enhancing user experience by programmatically redirecting after specific actions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/code-highlight.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Redirect to=\"/x/code-highlight\" />\n```\n\n----------------------------------------\n\nTITLE: Setting Form Errors with setErrors – Mantine\nDESCRIPTION: Illustrates how to use the `form.setErrors` handler to set multiple errors at once.  The handler takes an object where keys are field names and values are the error messages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({ mode: 'uncontrolled' });\nform.setErrors({ firstName: 'Too short', email: 'Invalid email' });\n\nform.errors;\n// -> { firstName: 'Too short', email: 'Invalid email' }\n\n```\n\n----------------------------------------\n\nTITLE: Reading local storage value on initial render without hydration mismatch in TypeScript\nDESCRIPTION: This example illustrates how to configure the useLocalStorage hook to retrieve local storage data during the initial render by setting 'getInitialValueInEffect' to false. This is suitable for client-only applications or when output markup does not depend on local storage value. The hook initializes from local storage immediately, with 'dark' as fallback default.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/local-storage-effect.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useLocalStorage } from '@mantine/hooks';\n\nfunction Demo() {\n  const [value, setValue] = useLocalStorage<'light' | 'dark'>({\n    key: 'color-scheme',\n    defaultValue: 'dark',\n    getInitialValueInEffect: false,\n  });\n\n  return <div>{value}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Mantine Form and Using isTouched/isDirty\nDESCRIPTION: This code snippet initializes a Mantine form using `useForm`. It demonstrates how to use `form.isTouched` and `form.isDirty` to check the touched and dirty status of individual fields and the entire form.  Dependencies include the `@mantine/form` library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/status.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { a: 1, nested: { field: '' } },\n});\n\n// Provide path as first argument to get state of single field\nform.isTouched('a'); // -> was field 'a' focused or changed?\nform.isDirty('a'); // -> was field 'a' modified?\nform.isDirty('nested.field'); // -> nested fields are also supported\n\n// If field path is not provided,\n// then functions will return form state instead\nform.isTouched(); // -> was any field in form focused or changed?\nform.isDirty(); // -> was any field in form modified?\n```\n```\n\n----------------------------------------\n\nTITLE: Form Validation with zodResolver (React, TypeScript)\nDESCRIPTION: Implements schema-based form validation using zodResolver in a Mantine form. Requires '@mantine/form', 'zod', and 'mantine-form-zod-resolver' as dependencies. The form has fields for name, email, and age, validates on demand, and exposes errors for each field based on the schema.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { zodResolver } from 'mantine-form-zod-resolver';\nimport { z } from 'zod';\nimport { useForm } from '@mantine/form';\n\nconst schema = z.object({\n  name: z.string().min(2, { message: 'Name should have at least 2 letters' }),\n  email: z.string().email({ message: 'Invalid email' }),\n  age: z.number().min(18, { message: 'You must be at least 18 to create an account' }),\n});\n\nconst form = useForm({\n  initialValues: {\n    name: '',\n    email: '',\n    age: 16,\n  },\n  validate: zodResolver(schema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  name: 'Name should have at least 2 letters',\n//  email: 'Invalid email',\n//  age: 'You must be at least 18 to create an account'\n// }\n```\n\n----------------------------------------\n\nTITLE: Customizing Input Error Styles with `withErrorStyles` in Mantine (TSX)\nDESCRIPTION: Demonstrates the `withErrorStyles` prop on the Mantine `TextInput` component. It compares the default error display (boolean or string error prop) with a custom implementation where default error styles are disabled (`withErrorStyles={false}`) and a custom error indicator (an icon) is added to the `rightSection`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IconExclamationCircle } from '@tabler/icons-react';\nimport { rem, TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <TextInput placeholder=\"Error as boolean\" label=\"Error as boolean\" error />\n      <TextInput\n        mt=\"md\"\n        placeholder=\"Error as react node\"\n        label=\"Error as react node\"\n        error=\"Something went wrong\"\n      />\n\n      <TextInput\n        mt=\"md\"\n        placeholder=\"Without error styles on input\"\n        label=\"Without error styles on input\"\n        error=\"Something went wrong\"\n        withErrorStyles={false}\n        rightSectionPointerEvents=\"none\"\n        rightSection={\n          <IconExclamationCircle\n            style={{ width: rem(20), height: rem(20) }}\n            color=\"var(--mantine-color-error)\"\n          />\n        }\n      />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Form Context in a Separate File\nDESCRIPTION: Example of creating a form context in a separate file to avoid dependency cycles, defining interface for form values and exporting the context variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/create-form-context.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// form-context.ts file\nimport { createFormContext } from '@mantine/form';\n\ninterface UserFormValues {\n  age: number;\n  name: string;\n}\n\n// You can give context variables any name\nexport const [UserFormProvider, useUserFormContext, useUserForm] =\n  createFormContext<UserFormValues>();\n```\n\n----------------------------------------\n\nTITLE: Resolving Theme Colors with getThemeColor in Mantine Core (TSX)\nDESCRIPTION: Illustrates using the `getThemeColor` function from `@mantine/core` to resolve a Mantine color string (e.g., 'blue', 'blue.7') or a standard CSS color into its corresponding CSS variable or the original value if it's not a theme color. Requires the color string and the Mantine theme object as arguments.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getThemeColor, useMantineTheme } from '@mantine/core';\n\nfunction Demo() {\n  const theme = useMantineTheme();\n\n  getThemeColor('blue', theme); // -> var(--mantine-color-blue-filled)\n  getThemeColor('blue.7', theme); // -> var(--mantine-color-blue-7)\n  getThemeColor('white', theme); // -> var(--mantine-color-white)\n  getThemeColor('#DF78E4', theme); // -> #DF78E4\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Pill Documentation Page\nDESCRIPTION: This snippet imports necessary components and data for rendering the Mantine Pill component documentation page. It includes demo data (`PillDemos`), the page layout (`Layout`), and MDX data specific to the Pill component (`MDX_DATA.Pill`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pill.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PillDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Configuring CSS Layer Order with SCSS\nDESCRIPTION: Shows the use of the @layer directive in an SCSS file to configure cascade order for styles from different libraries, including Mantine. SCSS syntax is valid for modern CSS but may require a supporting build system. The order of layers (base, mantine, components) determines the CSS precedence hierarchy.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_8\n\nLANGUAGE: SCSS\nCODE:\n```\n@layer base, mantine, components;\n```\n\n----------------------------------------\n\nTITLE: Create Stylelint Configuration File for Mantine Projects\nDESCRIPTION: Sample JSON content for `.stylelintrc.json` that extends standard SCSS config and sets rules to disable certain checks to work seamlessly with Mantine components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": [\"stylelint-config-standard-scss\"],\n  \"rules\": {\n    \"scss/no-duplicate-mixins\": null,\n    \"scss/at-mixin-pattern\": null,\n    \"scss/at-rule-no-unknown\": null,\n    \"selector-pseudo-class-no-unknown\": [\n      true,\n      {\n        \"ignorePseudoClasses\": [\"global\"]\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Mantine useForm with Nested Rule Validation in TypeScript\nDESCRIPTION: Initializes a form with nested initial values and defines validation rules using an object structure. Each rule function receives the current field value, all form values, and the field path, enabling complex validations such as conditionally returning an error based on the field's path. Dependencies include the @mantine/form package. Input is the initialValues object and validation rules object; output is a form object managing state and validation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validation.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { a: [{ b: 1 }, { b: 2 }] },\n  validate: {\n    a: {\n      b: (value, values, path) => (path === 'a.0.b' ? 'error' : null),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using DateInput with Time Components\nDESCRIPTION: This snippet shows a demo where the DateInput component includes time information via the `valueFormat` prop, allowing users to input hours, minutes, and seconds. This enhances the component's capability for datetime inputs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.time} />\n```\n\n----------------------------------------\n\nTITLE: useDebouncedCallback Definition – TypeScript\nDESCRIPTION: Defines the structure and type signature for the useDebouncedCallback hook. It accepts a callback function and a delay as input, returning a debounced version of the callback. The debounced function will only be executed after the specified delay has passed since the last invocation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-debounced-callback.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useDebouncedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): (...args: Parameters<T>) => void;\n```\n\n----------------------------------------\n\nTITLE: Implementing custom tooltip content\nDESCRIPTION: Provides a custom rendering function via 'tooltipProps.content' to create tailored tooltip displays. It requires filtering chart payloads with 'getFilteredChartTooltipPayload' to exclude non-content elements. Enhances control over tooltip appearance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_20\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.customTooltip} />\n```\n\n----------------------------------------\n\nTITLE: Basic useHash Hook Usage in React with Mantine\nDESCRIPTION: A basic example of using the useHash hook to modify the URL hash in a React component. The component renders a button that changes the URL hash when clicked.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hash.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\nimport { useHash } from '@mantine/hooks';\n\nfunction Demo() {\n  const [hash, setHash] = useHash({ getInitialValueInEffect: false });\n  return (\n    <Button onClick={() => setHash('new-hash')}>Change hash</Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useRadialMove Hook Options Interface in React TypeScript\nDESCRIPTION: This snippet defines the UseRadialMoveOptions interface, specifying configurable properties for the useRadialMove hook. The interface includes step for value increments, onChangeEnd for handling mouse or touch event completion, and callbacks for value change scrubbing. Dependencies include React and TypeScript; this interface is used to type the options parameter when invoking useRadialMove. Parameters allow customization of slider behavior and interaction events. No runtime outputs are expected from the interface definition itself.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-radial-move.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nexport interface UseRadialMoveOptions {\n  /** Number by which value is incremented/decremented with mouse and touch events, `0.01` by default */\n  step?: number;\n\n  /** Called in `onMouseUp` and `onTouchEnd` events with the current value */\n  onChangeEnd?: (value: number) => void;\n\n  /** Called in `onMouseDown` and `onTouchStart` events */\n  onScrubStart?: () => void;\n\n  /** Called in `onMouseUp` and `onTouchEnd` events */\n  onScrubEnd?: () => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering CompositeChart with Multiple Chart Types – TypeScript/React\nDESCRIPTION: This example illustrates the usage of the CompositeChart component from @mantine/charts to render a single chart combining line, area, and bar visualizations. Requires @mantine/charts, a suitable data array, and React. The 'series' parameter defines each chart type with color and visualization form. Inputs include height ('h'), data array, axis key ('dataKey'), display unit, max bar width, and series definition. Outputs a unified chart for comparing multiple data sets. Data must follow the shape expected by the series.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.13.0.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { CompositeChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <CompositeChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      unit=\"$\"\n      maxBarWidth={30}\n      series=[\n        { name: 'Tomatoes', color: 'rgba(18, 120, 255, 0.2)', type: 'bar' },\n        { name: 'Apples', color: 'red.8', type: 'line' },\n        { name: 'Oranges', color: 'yellow.8', type: 'area' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Colors Types to TypeScript\nDESCRIPTION: Demonstrates how to extend Mantine's color type system to include custom colors for better TypeScript autocomplete support when working with the theme object.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/colors.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  DefaultMantineColor,\n  MantineColorsTuple,\n} from '@mantine/core';\n\ntype ExtendedCustomColors =\n  | 'primaryColorName'\n  | 'secondaryColorName'\n  | DefaultMantineColor;\n\ndeclare module '@mantine/core' {\n  export interface MantineThemeColorsOverride {\n    colors: Record<ExtendedCustomColors, MantineColorsTuple>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the useMap Hook\nDESCRIPTION: This TypeScript code demonstrates the usage of the `useMap` hook to manage a map data structure within a Mantine application. It provides functionality to add, and remove key-value pairs using UI elements. It uses `@tabler/icons-react` for icons, along with Mantine components like `Table`, `ActionIcon`, and `Group`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { IconPlus, IconTrash } from '@tabler/icons-react';\nimport { ActionIcon, Group, Table } from '@mantine/core';\nimport { useMap } from '@mantine/hooks';\n\nfunction Demo() {\n  const map = useMap([\n    ['/hooks/use-media-query', 4124],\n    ['/hooks/use-clipboard', 8341],\n    ['/hooks/use-fetch', 9001],\n  ]);\n\n  const rows = Array.from(map.entries()).map(([key, value]) => (\n    <Table.Tr key={key}>\n      <Table.Td>{key}</Table.Td>\n      <Table.Td>{value}</Table.Td>\n      <Table.Td>\n        <Group>\n          <ActionIcon variant=\"default\" onClick={() => map.set(key, value + 1)} fw={500}>\n            <IconPlus stroke={1.5} size={18} />\n          </ActionIcon>\n          <ActionIcon variant=\"default\" onClick={() => map.delete(key)} c=\"red\">\n            <IconTrash stroke={1.5} size={18} />\n          </ActionIcon>\n        </Group>\n      </Table.Td>\n    </Table.Tr>\n  ));\n\n  return (\n    <Table layout=\"fixed\">\n      <Table.Thead>\n        <Table.Tr>\n          <Table.Th>Page</Table.Th>\n          <Table.Th>Views last month</Table.Th>\n          <Table.Th />\n        </Table.Tr>\n      </Table.Thead>\n      <Table.Tbody>{rows}</Table.Tbody>\n    </Table>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing ARIA Labels for Days, Months, Years - Mantine DatePicker - tsx\nDESCRIPTION: Illustrates how to use the `getDayProps`, `getYearControlProps`, and `getMonthControlProps` functions to dynamically set `aria-label` attributes for individual day, year, and month controls. This allows for more specific and context-aware accessibility labels based on the date value, improving screen reader interactions. These functions accept the date object as an argument.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { DatePicker } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <DatePicker\n      getDayProps={(date) => ({\n        'aria-label': `Select date ${\n          date.getMonth() + 1\n        }/${date.getDate()}/${date.getFullYear()}`,\n      })}\n      getYearControlProps={(date) => ({\n        'aria-label': `Select year ${date.getFullYear()}`,\n      })}\n      getMonthControlProps={(date) => ({\n        'aria-label': `Select month ${date.getFullYear()}/${date.getMonth()}`,\n      })}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useDebouncedState Hook\nDESCRIPTION: The type definition of the useDebouncedState hook, which takes a default value, wait time in milliseconds, and optional configuration for leading updates. Returns a tuple with the current debounced value and a setter function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-debounced-state.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useDebouncedState<T = any>(\n  defaultValue: T,\n  wait: number,\n  options?: {\n    leading: boolean;\n  }\n): readonly [T, (newValue: T) => void];\n```\n\n----------------------------------------\n\nTITLE: Uncontrolled Tabs with Mantine\nDESCRIPTION: Shows how to create uncontrolled Tabs component with Mantine, where the Tabs component manages its own state. The `defaultValue` prop is used to set the initially active tab.  This is suitable for cases where you don't need to track or react to tab changes in the parent component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Tabs } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Tabs defaultValue=\"first\">\n      <Tabs.List>\n        <Tabs.Tab value=\"first\">First tab</Tabs.Tab>\n        <Tabs.Tab value=\"second\">Second tab</Tabs.Tab>\n      </Tabs.List>\n\n      <Tabs.Panel value=\"first\">First panel</Tabs.Panel>\n      <Tabs.Panel value=\"second\">Second panel</Tabs.Panel>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Uncontrolled Form Implementation with useForm Hook\nDESCRIPTION: This TypeScript code provides an example of using the `useForm` hook in uncontrolled mode. It demonstrates how to define initial values, validate form fields, and handle form submission. Dependencies include `@mantine/core` for UI components and `@mantine/form` for form management. The component uses `form.getInputProps` and `form.onSubmit`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Code, Text, TextInput } from '@mantine/core';\nimport { hasLength, isEmail, useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { name: '', email: '' },\n    validate: {\n      name: hasLength({ min: 3 }, 'Must be at least 3 characters'),\n      email: isEmail('Invalid email'),\n    },\n  });\n\n  const [submittedValues, setSubmittedValues] = useState<typeof form.values | null>(null);\n\n  return (\n    <form onSubmit={form.onSubmit(setSubmittedValues)}>\n      <TextInput {...form.getInputProps('name')} label=\"Name\" placeholder=\"Name\" />\n      <TextInput {...form.getInputProps('email')} mt=\"md\" label=\"Email\" placeholder=\"Email\" />\n      <Button type=\"submit\" mt=\"md\">\n        Submit\n      </Button>\n\n      <Text mt=\"md\">Form values:</Text>\n      <Code block>{JSON.stringify(form.values, null, 2)}</Code>\n\n      <Text mt=\"md\">Submitted values:</Text>\n      <Code block>{submittedValues ? JSON.stringify(submittedValues, null, 2) : '–'}</Code>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Import Order for Mantine Component Styles in TypeScript\nDESCRIPTION: This example demonstrates the proper sequence for importing dependent Mantine component styles to ensure correct CSS overriding. The UnstyledButton CSS file is imported first, followed by the Button CSS file, allowing the latter to override the former's styles as intended. Importing in this order is a mandatory prerequisite for obtaining the right appearance for components with layered style dependencies.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-files-list.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ Correct order – Button styles will override UnstyledButton styles\nimport '@mantine/core/styles/UnstyledButton.css';\nimport '@mantine/core/styles/Button.css';\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Mantine Theme Colors (tsx)\nDESCRIPTION: Demonstrates how to add a custom color with 10 defined shades (from lightest to darkest) to the `theme.colors` object using `createTheme`. It also shows how to set the `primaryColor` to reference this custom color and define the `primaryShade` with different indices for light and dark modes to control the default shade used in filled variants. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/ten-shades-per-color.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    oceanBlue: [\n      '#7AD1DD', // lightest\n      '#5FCCDB',\n      '#44CADC',\n      '#2AC9DE',\n      '#1AC2D9',\n      '#11B7CD',\n      '#09ADC3', // primaryShade light\n      '#0E99AC',\n      '#128797', // primaryShade dark\n      '#147885', // darkest\n    ],\n  },\n\n  // theme.primaryColor must be key of theme.colors object,\n  // hex/rgb/other values are not supported\n  primaryColor: 'oceanBlue',\n\n  // primaryShade is the index of main color in theme.colors[color] arrays\n  // theme.colors[color][primaryShade] is used in components with filled variant\n  primaryShade: { light: 6, dark: 8 },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Documentation Dependencies - JavaScript\nDESCRIPTION: Imports necessary components and data for rendering the Mantine documentation page for the Affix component. It imports `AffixDemos` for example data, `Layout` for the page structure, and `MDX_DATA` containing documentation content. These imports are prerequisites for rendering the page within the documentation site's framework.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/affix.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { AffixDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Theme Tokens via Style Props in TSX\nDESCRIPTION: Illustrates how Mantine style props like `bg` (background) and `mt` (margin-top) act as shorthands for accessing Mantine theme tokens. The values like `\"red.5\"` and `\"xl\"` are automatically mapped to their corresponding CSS variables (`var(--mantine-color-red-5)`, `var(--mantine-spacing-xl)`). Imports the `Box` component from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  // bg=\"red.5\" references theme.colors.red[5]\n  // \"red.5\" is a shorthand for var(--mantine-color-red-5)\n\n  // mt=\"xl\" references theme.spacing.xl\n  // \"xl\" is a shorthand for var(--mantine-spacing-xl)\n  return (\n    <Box bg=\"red.5\" mt=\"xl\">\n      My box\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Floating Action Button Demo - JSX/React\nDESCRIPTION: Renders a `Demo` component, which is likely a custom component used to display interactive code examples or demonstrations within the documentation. It receives the `FloatingActionButtonDemo` data, which contains the implementation details and code for the FAB example.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/floating-action-button.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={FloatingActionButtonDemo} />\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Dates Styles - JavaScript\nDESCRIPTION: This code snippet provides the necessary import statement to apply the default styles for the `@mantine/dates` package. Including this line, typically in your application's entry file (like `main.tsx` or `App.tsx`), resolves styling issues that cause the date components to appear broken. It is a simple CSS import presented within a markdown code block tagged as `bash`, showing the exact line to add.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dates-missing-styles.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport '@mantine/dates/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Setting CSS Variables via the Style Prop in TSX\nDESCRIPTION: Shows how to set a custom CSS variable (`--my-color`) using the `style` prop on a `Box` component. This makes the variable available to any nested elements within the Box. The color value is passed dynamically via a component prop. Imports the `Box` component from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo({ color }: { color: string }) {\n  // Later you will be able to use var(--my-color) in any nested element\n  return <Box style={{ '--my-color': color }}>My box</Box>;\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Breakpoint-Based Visibility with hiddenFrom and visibleFrom\nDESCRIPTION: Adds support for hiding or showing components based on viewport breakpoints using hiddenFrom and visibleFrom props, improving responsive behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_29\n\n\n\n----------------------------------------\n\nTITLE: Implementing Accessibility for Stepper Components in React\nDESCRIPTION: Shows how to make Stepper.Step components accessible for screen readers by providing proper labels. Includes examples of correct and incorrect usage patterns for accessibility compliance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/stepper.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Stepper } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Stepper active={0}>\n      {/* Not ok, no label for screen reader */}\n      <Stepper.Step />\n\n      {/* Ok, label and description */}\n      <Stepper.Step label=\"Step 1\" description=\"Create an account\" />\n\n      {/* Ok, aria-label */}\n      <Stepper.Step aria-label=\"Create an account\" />\n    </Stepper>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using data-attributes for dynamic styling in React components\nDESCRIPTION: Demonstrates how to implement dynamic styling with data attributes in Mantine. The component uses boolean and enum props that get converted to data attributes which can be targeted in CSS.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dynamic-css-styles.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\nimport classes from './Demo.module.css';\n\ninterface DemoProps {\n  disabled: boolean;\n  orientation: 'horizontal' | 'vertical';\n}\n\nfunction Demo({ disabled, orientation }: DemoProps) {\n  return (\n    <Box\n      data-disabled={disabled || undefined}\n      data-orientation={orientation}\n      className={classes.root}\n    >\n      My demo\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using not-rtl and not-ltr Mixins for Conditional Direction Styling - SCSS and CSS\nDESCRIPTION: Explains how to use `not-rtl` and `not-ltr` mixins to apply styles when direction attributes are opposite or unspecified. The example includes SCSS usage and the resulting CSS selectors that apply styles when `dir` is not set to `rtl` (or respectively `ltr`), useful for applying defaults or fallback layouts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_7\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  @mixin not-rtl {\n    margin-right: 1rem;\n  }\n}\n```\n\nLANGUAGE: CSS\nCODE:\n```\n:root:not([dir='rtl']) .demo {\n  margin-right: 1rem;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding and positioning legend in LineChart\nDESCRIPTION: Displays legend with 'withLegend' prop. When legend items are hovered, their corresponding data series is highlighted. Allows passing further props to the recharts Legend component via 'legendProps' (e.g., positioning). Useful for clarifying chart data series.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.legend} />\n```\n\n----------------------------------------\n\nTITLE: TypeScript Interface for useCombobox Options in Mantine\nDESCRIPTION: Defines the UseComboboxOptions interface representing configuration options passed to the useCombobox hook. It includes properties for controlling dropdown open state (defaultOpened, opened), event handlers for dropdown opening and closing with event source, looping behavior for keyboard navigation, and scroll behavior settings. Importing this interface enables type-safe configuration of the hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/combobox.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\ninterface UseComboboxOptions {\n  /** Default value for `dropdownOpened`, `false` by default */\n  defaultOpened?: boolean;\n\n  /** Controlled `dropdownOpened` state */\n  opened?: boolean;\n\n  /** Called when `dropdownOpened` state changes */\n  onOpenedChange?(opened: boolean): void;\n\n  /** Called when dropdown closes with event source: keyboard, mouse or unknown */\n  onDropdownClose?(eventSource: ComboboxDropdownEventSource): void;\n\n  /** Called when dropdown opens with event source: keyboard, mouse or unknown */\n  onDropdownOpen?(eventSource: ComboboxDropdownEventSource): void;\n\n  /** Determines whether arrow key presses should loop though items (first to last and last to first), `true` by default */\n  loop?: boolean;\n\n  /** `behavior` passed down to `element.scrollIntoView`, `'instant'` by default */\n  scrollBehavior?: ScrollBehavior;\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Stroke Dash Array for Grid and Cursor Lines in BarChart, JSX/TypeScript\nDESCRIPTION: Controls stroke dash pattern for grid and cursor lines by setting `strokeDasharray` with space-delimited lengths for dashes and gaps (e.g., \"10 5\"). Demonstrated with BarChartDemos.strokeDasharray data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_19\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.strokeDasharray} />\n```\n\n----------------------------------------\n\nTITLE: Appending Items to a List with useListState\nDESCRIPTION: The `append` handler adds one or more items to the end of the list. It takes item(s) as parameters, which will be appended. The example shows how to append an item with property `a: 2` to existing list.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// add one or more items to the end of the list\nconst append = () => handlers.append({ a: 2 });\n// values -> [{ a: 1 }, { a: 2 }]\n```\n\n----------------------------------------\n\nTITLE: Resulting CSS from Responsive Style Prop Usage\nDESCRIPTION: Displays the CSS output generated by Mantine based on the responsive style prop configuration in the React component. It shows how the base style is applied directly and then overridden by media queries corresponding to the specified breakpoints (`sm`, `lg`) with the respective style values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/responsive.mdx#_snippet_6\n\nLANGUAGE: css\nCODE:\n```\n/* Base styles added to element and then get overwritten with responsive values */\n.element {\n  width: 20rem;\n}\n\n/* 48em is theme.breakpoints.sm by default */\n@media (min-width: 48em) {\n  .element {\n    width: 30rem;\n  }\n}\n\n/* 75em is theme.breakpoints.lg by default */\n@media (min-width: 75em) {\n  .element {\n    width: 40rem;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using UseMediaQueryOptions Type for Hook Configuration in Mantine\nDESCRIPTION: Illustrates how to import and utilize the UseMediaQueryOptions type to strongly type the options parameter of useMediaQuery, enabling better type safety and configurability.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-media-query.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMediaQuery, UseMediaQueryOptions } from '@mantine/hooks';\n\nconst options: UseMediaQueryOptions = {\n  getInitialValueInEffect: false,\n};\n\nconst matches = useMediaQuery('(max-width: 40em)', true, options);\n```\n\n----------------------------------------\n\nTITLE: Mantine Tabs with aria-label on Tabs.List\nDESCRIPTION: Demonstrates how to add `aria-label` attribute to `Tabs.List`. This attribute is used to label the list of tabs for screen readers to improve accessibility. The label will be announced when the tab list is focused for the first time.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Tabs } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Tabs defaultValue=\"recent\">\n      {/* Tabs.List aria-label will be announced when tab is focused for the first time */}\n      <Tabs.List aria-label=\"Chats\">\n        <Tabs.Tab value=\"recent\">Most recent</Tabs.Tab>\n        <Tabs.Tab value=\"recent\">Unanswered</Tabs.Tab>\n        <Tabs.Tab value=\"archived\">Archived</Tabs.Tab>\n      </Tabs.List>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Modal with react-remove-scroll Integration\nDESCRIPTION: Demonstrates the use of the Modal component in conjunction with the `react-remove-scroll` package for managing scroll behavior, along with the props provided in the Modal component to customize the scroll behavior, such as `allowPinchZoom`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/modal.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Modal } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Modal\n      removeScrollProps={{ allowPinchZoom: true }}\n      opened\n      onClose={() => {}}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Live Validation on Input Change with Mantine useForm in TypeScript\nDESCRIPTION: Configures the form to perform validation on every input change event by setting the validateInputOnChange option to true. This allows immediate feedback while typing. The form is initialized in uncontrolled mode with this live validation behavior. Requires '@mantine/form'. Inputs: form configuration object; Outputs: form instance with live validation enabled.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validation.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  validateInputOnChange: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring clearable feature in TagsInput\nDESCRIPTION: This snippet illustrates enabling the clear button in TagsInput by setting the 'clearable' prop. The clear button allows users to quickly clear all selected tags unless the component is disabled, read-only, or has no value.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Usage example with clearable set to true, rendering clear button in input */\n<Demo data={TagsInputDemos.clearable} />\n```\n\n----------------------------------------\n\nTITLE: Importing Component Props Types in TypeScript\nDESCRIPTION: Shows how to import prop types for Mantine components. Component prop types can be imported by adding 'Props' to the component name.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { ButtonProps } from '@mantine/core';\nimport type { DatePickerProps } from '@mantine/dates';\n```\n\n----------------------------------------\n\nTITLE: Mocking Browser APIs for jsdom with Vitest (TypeScript)\nDESCRIPTION: This snippet creates a vitest.setup.mjs setup file that mocks browser APIs such as matchMedia and ResizeObserver, which are unavailable in jsdom but required for some Mantine components. It also patches scrollIntoView and getComputedStyle to avoid test failures. The only required dependency is '@testing-library/jest-dom/vitest' and vitest itself. The setup ensures components dependent on these APIs will not throw errors during tests. Place this file in the project root as referenced in the Vitest configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vitest.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@testing-library/jest-dom/vitest';\n\nimport { vi } from 'vitest';\n\nconst { getComputedStyle } = window;\nwindow.getComputedStyle = (elt) => getComputedStyle(elt);\nwindow.HTMLElement.prototype.scrollIntoView = () => {};\n\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation((query) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(),\n    removeListener: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n});\n\nclass ResizeObserver {\n  observe() {}\n  unobserve() {}\n  disconnect() {}\n}\n\nwindow.ResizeObserver = ResizeObserver;\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using useTimeout Hook from Mantine Hooks in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the useTimeout hook from @mantine/hooks in a TypeScript environment. It shows how to initialize the hook with a callback function, a delay in milliseconds, and an optional configuration to auto-start the timer upon component mount. The returned start and clear methods control the timer execution. Dependencies include the Mantine Hooks package. The callback function is invoked after the specified delay unless cancelled. The options object currently supports 'autoInvoke' to control automatic timer start.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-timeout.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useTimeout } from '@mantine/hooks';\n\nconst { start, clear } = useTimeout(callback, delay, {\n  autoInvoke: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled Mantine usePagination\nDESCRIPTION: Shows how to use the `usePagination` hook with external state management, specifically using React's `useState`. It demonstrates passing the current page state (`page`) and an update function (`onChange`) to the hook to enable controlled behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-pagination.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { usePagination } from '@mantine/hooks';\n\nconst [page, onChange] = useState(1);\nconst pagination = usePagination({ total: 10, page, onChange });\n\n// Will call onChange with 5\npagination.setPage(5);\npagination.range; // -> [1, 'dots', 4, 5, 6, 'dots', 10];\n\n// ... All other examples work the same\n```\n\n----------------------------------------\n\nTITLE: Adding Options with Object Array to Mantine NativeSelect (TSX)\nDESCRIPTION: This snippet demonstrates adding options to NativeSelect using an array of objects. Each object requires a label and value property, and an optional disabled property can be included to disable a specific option.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/native-select.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NativeSelect } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <NativeSelect\n      data={[\n        { label: 'React', value: 'react' },\n        { label: 'Angular', value: 'angular' },\n        { label: 'Svelte', value: 'svelte', disabled: true },\n        { label: 'Vue', value: 'vue' },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing AreaChart component with @mantine/charts in TypeScript\nDESCRIPTION: Demonstrates the usage of the AreaChart component from the @mantine/charts package to create a stacked area chart. It imports sample data, specifies chart height, the data key used for the x-axis, the chart type, and an array of series with custom colors. It requires @mantine/charts and React environment with TypeScript support. Inputs include data structured with date keys and series names; outputs a rendered stacked area chart visualization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AreaChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <AreaChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      type=\"stacked\"\n      series=[\n        { name: 'Apples', color: 'indigo.6' },\n        { name: 'Oranges', color: 'blue.6' },\n        { name: 'Tomatoes', color: 'teal.6' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine useCombobox Store Handlers to Control Dropdown State in TypeScript\nDESCRIPTION: Illustrates controlling Combobox dropdown state by manually invoking store handlers like openDropdown from useCombobox. The example shows wrapping a button with Combobox.Target and opening the dropdown programmatically on button click, demonstrating interaction between store handlers and UI elements in a React component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/combobox.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Combobox, useCombobox } from '@mantine/core';\n\nfunction Demo() {\n  const combobox = useCombobox();\n\n  return (\n    <Combobox>\n      <Combobox.Target>\n        <Button onClick={() => combobox.openDropdown()}>\n          Open dropdown\n        </Button>\n      </Combobox.Target>\n\n      {/* Your implementation */}\n    </Combobox>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integrate Google Font with Mantine Theme\nDESCRIPTION: This TypeScript snippet creates a Mantine theme and sets the `fontFamily` and `headings.fontFamily` properties to use the 'Roboto' font. It imports necessary Mantine components and styles. The font must be included in the index.html file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/vite-load-fonts.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createTheme,\n  DEFAULT_THEME,\n  MantineProvider,\n} from '@mantine/core';\n\nimport '@mantine/core/styles.css';\n\nconst theme = createTheme({\n  fontFamily: 'Roboto, sans-serif',\n  fontFamilyMonospace: 'Monaco, Courier, monospace',\n  headings: {\n    // Use default theme if you want to provide default Mantine fonts as a fallback\n    fontFamily: `Roboto, ${DEFAULT_THEME.fontFamily}`,\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>Your app here</MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GreycliffCF.css Font Styles\nDESCRIPTION: This CSS snippet defines font styles for the \"Greycliff CF\" font family. It specifies the font family name, source URLs (woff2 format), font weights, and styles.  Dependencies include the font files (.woff2).  The output is a set of CSS rules that can be imported in React.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/remix-load-fonts.mdx#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n@font-face {\n  font-family: 'Greycliff CF';\n  src: url('./GreycliffCF-Bold.woff2') format('woff2');\n  font-weight: 700;\n  font-style: normal;\n}\n\n@font-face {\n  font-family: 'Greycliff CF';\n  src: url('./GreycliffCF-Heavy.woff2') format('woff2');\n  font-weight: 900;\n  font-style: normal;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Modal Dropdown Demo for DatePickerInput in JSX\nDESCRIPTION: Demonstrates changing the default dropdown from a popover to a modal by setting the `dropdownType` prop to \"modal\". This snippet renders modal-based date picking examples to show different UI approaches for the picker.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_5\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.modal} />\n```\n\n----------------------------------------\n\nTITLE: Prepending Items to a List with useListState\nDESCRIPTION: The `prepend` handler adds one or more items to the beginning of the list. The provided item(s) are inserted at the start of the list. This snippet shows how to prepend items with `a: 3` and `a: 4` to the list.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// add one or more items to the start of the list\nconst prepend = () => handlers.prepend({ a: 3 }, { a: 4 });\n// values -> [{ a: 3 }, { a: 4 }, { a: 1 }, { a: 2 }]\n```\n\n----------------------------------------\n\nTITLE: Converting First Character to Uppercase with Mantine Hooks (TSX)\nDESCRIPTION: Illustrates the usage of the `upperFirst` function from `@mantine/hooks`. This function transforms the first character of a string to its uppercase form, leaving subsequent characters untouched. Requires importing `upperFirst` from the hooks package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/functions-reference.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { upperFirst } from '@mantine/hooks';\n\nupperFirst('Mantine'); // Mantine\nupperFirst('mantine'); // Mantine\n```\n\n----------------------------------------\n\nTITLE: Rendering Get Element Reference for DatePickerInput Button in JSX\nDESCRIPTION: Shows usage of a helper component to get the ref of the button element inside DatePickerInput, useful for advanced usages like focus management or animations. It specifies the component, ref type, and package source.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_12\n\nLANGUAGE: JSX\nCODE:\n```\n<GetElementRef\n  component=\"DatePickerInput\"\n  refType=\"button\"\n  package=\"@mantine/dates\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Selecting Multiple Options with Mantine MultiSelect Using React Testing Library (TypeScript/TSX)\nDESCRIPTION: This snippet showcases how to test selection of multiple options in Mantine's MultiSelect component using React Testing Library and userEvent. The test sample covers rendering a MultiSelect, opening the dropdown, selecting several options, and validating the value sent with a form submit. Dependencies include Mantine's MultiSelect, React Testing Library (render, screen, userEvent), and a testing framework such as Jest or Vitest. Data passed to 'data' prop should be an array of objects with 'value' and 'label'. The hidden input's value is asserted to ensure all selected items are correctly serialized.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/combobox-testing.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { MultiSelect } from '@mantine/core';\n\nfunction MyForm() {\n  return (\n    <MultiSelect\n      name=\"groceries\"\n      label=\"Select groceries\"\n      data=[\n        { value: 'banana', label: 'Banana' },\n        { value: 'apple', label: 'Apple' },\n        { value: 'orange', label: 'Orange' },\n      ]\n    />\n  );\n}\n\nit('selects multiple options', () => {\n  render(<MyForm />);\n\n  // Click Select to open the options list\n  // Note that unlike Select, MultiSelect does not close the dropdown when one of the options is selected\n  // You can select several options one after another without clicking the input again\n  await userEvent.click(screen.getByRole('textbox', { name: 'Select groceries' }));\n\n  // Click several options to select them\n  await userEvent.click(screen.getByRole('option', { name: 'Banana' }));\n  await userEvent.click(screen.getByRole('option', { name: 'Apple' }));\n\n  // The best way to verify that options are selected is to check the hidden input value\n  expect(document.querySelector('input[name=\"groceries\"]')).toHaveValue('banana,apple');\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Store with npm\nDESCRIPTION: This command installs the @mantine/store package using npm. It adds the package as a dependency to your project, enabling the use of its global state management features.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/store/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @mantine/store\n```\n\n----------------------------------------\n\nTITLE: Creating a Controlled TipTap Editor Component in React\nDESCRIPTION: Example of how to create a controlled rich text editor component using @mantine/tiptap and @tiptap/react. This component takes a value prop and provides an onChange callback to enable controlled behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEditor } from '@tiptap/react';\nimport StarterKit from '@tiptap/starter-kit';\nimport { RichTextEditor as MantineRichTextEditor } from '@mantine/tiptap';\n\ninterface RichTextEditorProps {\n  value: string;\n  onChange: (value: string) => void;\n}\n\nexport function RichTextEditor({\n  value,\n  onChange,\n}: RichTextEditorProps) {\n  const editor = useEditor({\n    extensions: [StarterKit],\n    content: value,\n    onUpdate: ({ editor }) => {\n      onChange(editor.getHTML());\n    },\n  });\n\n  return (\n    <MantineRichTextEditor editor={editor}>\n      <MantineRichTextEditor.Toolbar>\n        <MantineRichTextEditor.ControlsGroup>\n          <MantineRichTextEditor.Bold />\n          <MantineRichTextEditor.Italic />\n        </MantineRichTextEditor.ControlsGroup>\n      </MantineRichTextEditor.Toolbar>\n\n      <MantineRichTextEditor.Content />\n    </MantineRichTextEditor>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Emotion Dependencies in Next.js Pages\nDESCRIPTION: This snippet shows the command to install the necessary packages for using Emotion with Mantine in a Next.js pages router project. It includes core Emotion and Mantine Emotion packages and packages necessary for server side rendering with Next.js. Dependencies include: `@mantine/emotion`, `@emotion/react`, `@emotion/cache`, `@emotion/serialize`, `@emotion/utils`, and `@emotion/server`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nInstallScript packages=\"@mantine/emotion @emotion/react @emotion/cache @emotion/serialize @emotion/utils @emotion/server\"\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine Components Without postcss-preset-mantine in Create React App - SCSS\nDESCRIPTION: This SCSS snippet shows how to adapt Mantine styling for Create React App by replacing Mantine-specific functions and nesting with standard CSS features. It provides side-by-side examples of syntax that does not work in CRA (using rem/em functions and nesting) and the equivalent that does (using calc(), var(), and flat selectors). No dependencies are required aside from Create React App's default setup. The expected input is SCSS/CSS for Mantine components, and the output is compatible, compiled CSS. Limitations include the inability to use custom PostCSS features or Mantine SCSS functions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/can-i-use-mantine-with-cra.mdx#_snippet_0\n\nLANGUAGE: scss\nCODE:\n```\n// ❌ Does not work with Create React App\n.demo {\n  font-size: rem(16px);\n\n  @media (min-width: em(320px)) {\n    font-size: rem(32px);\n  }\n}\n\n// ✅ Works with Create React App\n.demo {\n  font-size: calc(1rem * var(--mantine-scale));\n}\n\n@media (min-width: 20em) {\n  .demo {\n    font-size: calc(2rem * var(--mantine-scale));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Swapping Items in a List with useListState\nDESCRIPTION: The `swap` handler swaps the positions of two items in the list. It takes an object with `from` and `to` properties, specifying the indices of the items to swap. This example swaps the items at index 0 and 2.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// swap items positions\nconst swap = () => handlers.swap({ from: 0, to: 2 });\n// values -> [{ a: 5 }, { a: 0 }, { a: 4 }]\n```\n\n----------------------------------------\n\nTITLE: Resultant Responsive CSS from Mantine Style Props (CSS)\nDESCRIPTION: Displays the resultant CSS output generated by Mantine's responsive style prop handling. This snippet illustrates how base and breakpoint-specific width styles are applied using media queries, according to the 'w' prop values in the previous TypeScript example. No dependencies are needed to view the CSS, but its values are dictated by Mantine's theme.breakpoints settings. Inputs correspond to the object values for each breakpoint; output are generated CSS rules with appropriate media queries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style-props.mdx#_snippet_4\n\nLANGUAGE: CSS\nCODE:\n```\n/* Base styles added to element and then get overwritten with responsive values */\n.element {\n  width: 20rem;\n}\n\n/* 48em is theme.breakpoints.sm by default */\n@media (min-width: 48em) {\n  .element {\n    width: 30rem;\n  }\n}\n\n/* 75em is theme.breakpoints.lg by default */\n@media (min-width: 75em) {\n  .element {\n    width: 40rem;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Required and withAsterisk Example\nDESCRIPTION: Shows how to use the `required` and `withAsterisk` props on `TextInput` to display a required indicator on the label. `required` also sets the HTML attribute on the input element. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/input.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\n\n// Will display required asterisk and add `required` attribute to the input element\nfunction RequiredDemo() {\n  return <TextInput label=\"test-label\" required />;\n}\n\n// Will only display the asterisk, `required` attribute is not added to the input element\nfunction AsteriskDemo() {\n  return <TextInput label=\"test-label\" withAsterisk />;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying labels on data points in LineChart\nDESCRIPTION: Activates point labels by setting 'withPointLabels' prop. Shows individual data values on points for better data readability directly on the chart.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.pointLabels} />\n```\n\n----------------------------------------\n\nTITLE: Correcting compound components by adding 'use client' directive\nDESCRIPTION: This snippet shows how to enable the use of Mantine's compound components in a client environment by adding `'use client'` at the top of the file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ No error\n'use client';\n\nimport { Popover } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover>\n      <Popover.Target>\n        <button>Toggle popover</button>\n      </Popover.Target>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: ColorSwatch Polymorphic Component Demo\nDESCRIPTION: Shows how to use ColorSwatch as a polymorphic component, changing it from the default div element to a button element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/color-swatch.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n<Polymorphic\n  defaultElement=\"div\"\n  changeToElement=\"button\"\n  component=\"ColorSwatch\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Using mod prop to add data attributes on Mantine components in TypeScript\nDESCRIPTION: Provides examples of the new universal 'mod' prop that attaches data-* attributes to the root element of Mantine components. This feature supports string, object, and array formats to define multiple or conditional attributes. This approach facilitates adding semantic data attributes for styling or automation without modifying DOM directly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\n<Box mod=\"data-button\" />;\n// -> <div data-button />\n\n<Box mod={{ opened: true }} />;\n// -> <div data-opened />\n\n<Box mod={{ opened: false }} />;\n// -> <div />\n\n<Box mod={[\"button\", { opened: true }]} />;\n// -> <div data-button data-opened />\n\n<Box mod={{ orientation: 'horizontal' }} />;\n// -> <div data-orientation=\"horizontal\" />\n```\n\n----------------------------------------\n\nTITLE: Using renderRoot Prop for Polymorphic Mantine Components with react-router-dom NavLink\nDESCRIPTION: Shows using the renderRoot prop to customize the root element of Mantine components, here replacing the root with react-router-dom's NavLink, enabling style and behavior customization when default component props are incompatible.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport cx from 'clsx';\nimport { Button } from '@mantine/core';\nimport { NavLink } from 'react-router-dom';\n\nfunction Demo() {\n  return (\n    <Button\n      renderRoot={({ className, ...others }) => (\n        <NavLink\n          className={({ isActive }) => cx(className, { 'active-class': isActive })}\n          {...others}\n        />\n      )}\n    >\n      React router NavLink\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: UseClipboard Hook Definition in TypeScript\nDESCRIPTION: TypeScript definition of the useClipboard hook showing its parameters and return type. The hook accepts an options object with a timeout property and returns functions for copying and resetting, along with state indicators.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-clipboard.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useClipboard(\n  options: { timeout: number } = { timeout: 2000 }\n): {\n  copy: (valueToCopy: any) => void;\n  reset: () => void;\n  error: Error;\n  copied: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Type Definition of useTimeout Hook in TypeScript\nDESCRIPTION: This snippet provides the TypeScript function signature for the useTimeout hook, describing the expected input parameters and returned object. The hook takes a callback function with any arguments, a delay number (in milliseconds), and an optional configuration object specifying the autoInvoke boolean flag. It returns an object with two methods: start, which accepts the callback parameters to invoke the timer, and clear, which cancels the timer before execution. This definition clarifies the hook's interface for TypeScript users.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-timeout.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useTimeout(\n  callback: (...callbackParams: any[]) => void,\n  delay: number,\n  options?: {\n    autoInvoke: boolean;\n  }\n): {\n  start: (...callbackParams: any[]) => void;\n  clear: () => void;\n};\n```\n\n----------------------------------------\n\nTITLE: Using Mantine's useDidUpdate Hook in React Functional Component\nDESCRIPTION: This code snippet demonstrates how to import and utilize the useDidUpdate hook from Mantine within a React functional component. The hook is called with a callback that logs a message and an array of dependencies, but it does not run on component mount, only on updates of dependencies.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-did-update.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useDidUpdate } from '@mantine/hooks';\n\nfunction Demo() {\n  useDidUpdate(\n    () => console.log(\"Won't be called when mounted\"),\n    [dependency1, dependency2]\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Notifications Programmatically with notifications.show and notifications.hide (TSX)\nDESCRIPTION: Illustrates adding a notification and removing it programmatically using the returned id from show function passed to hide function. This code enables managing individual notification lifecycle via code in any component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { notifications } from '@mantine/notifications';\n\nconst id = notifications.show({ message: 'Hello!' });\nnotifications.hide(id);\n```\n\n----------------------------------------\n\nTITLE: Displaying Bars' Value Labels Above Each Bar in BarChart, JSX/TypeScript\nDESCRIPTION: Enables showing numeric labels above each bar by setting `withBarValueLabel`. This enhances data readability by directly indicating values on the chart. Illustrated with BarChartDemos.barValueLabel usage.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_28\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.barValueLabel} />\n```\n\n----------------------------------------\n\nTITLE: Using Inline Styles and Styles Prop with Mantine Button Component in TypeScript/TSX\nDESCRIPTION: Shows a Mantine Button component with attempts to apply nested inline styles through `style` and `styles` props. Demonstrates that simple inline styles like `backgroundColor` work but nested styles such as `&:hover` or attribute selectors do not function due to Mantine's styling implementation. Inputs are React components with style objects, outputs are visual styles applied partially. Requires @mantine/core installed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/nested-inline-styles.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      style={{\n        // ✅ This works\n        backgroundColor: 'hotpink',\n\n        // ❌ This does not work\n        '&:hover': { color: 'lightgreen' },\n      }}\n      styles={{\n        root: {\n          // ✅ This works\n          backgroundColor: 'hotpink',\n\n          // ❌ This does not work\n          '&[data-disabled]': { color: 'lightgreen' },\n          '&:hover': { color: 'lightgreen' },\n          '&:focus': { color: 'lightgreen' },\n          '& span': { color: 'lightgreen' },\n        },\n      }}\n    >\n      This has a hotpink background.\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest in Vite Configuration File (TypeScript)\nDESCRIPTION: This snippet adds Vitest to the Vite configuration by exporting a defineConfig call with test setup. Configuration options include enabling globals, specifying the jsdom environment, and referencing a setup file for mocking browser APIs. Dependencies required include vite and vitest. Inputs include additional Vite config fields, and outputs are a consistent test environment across all runs. Place this snippet in the vite.config.ts or equivalent file. Limitations: only applies to Vite-based projects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vitest.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  // ... rest of your config\n  test: {\n    globals: true,\n    environment: 'jsdom',\n    setupFiles: './vitest.setup.mjs',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling and Positioning Chart Legend in BarChart, JSX/TypeScript\nDESCRIPTION: Controls the display of the chart legend using `withLegend` prop and passes additional positioning props through `legendProps` to the underlying Recharts Legend component. Provides interactivity by highlighting the corresponding series on item hover. Examples use BarChartDemos.legend and BarChartDemos.legendPosition data for demonstrations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_8\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.legend} />\n<Demo data={BarChartDemos.legendPosition} />\n```\n\n----------------------------------------\n\nTITLE: Define CSS variables in Mantine style prop\nDESCRIPTION: Demonstrates how to define CSS variables directly within the style prop of a Mantine Box component.  Requires the `@mantine/core` package. The defined CSS variable `--radius` is then used for the `borderRadius` property.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      style={{ '--radius': '0.5rem', borderRadius: 'var(--radius)' }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: CSS styling with data attributes\nDESCRIPTION: Shows the corresponding CSS module that targets the data attributes defined in the component. Includes styling for the disabled state and different orientation values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dynamic-css-styles.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n.root {\n  background: orange;\n  display: flex;\n\n  &[data-disabled] {\n    background: silver;\n  }\n\n  &[data-orientation='horizontal'] {\n    flex-direction: row;\n  }\n\n  &[data-orientation='vertical'] {\n    flex-direction: column;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Notifications Component as Sibling in React\nDESCRIPTION: This snippet demonstrates the proper way to include the Notifications component in a Mantine React application. Instead of wrapping the entire app, Notifications is rendered as a sibling element to the main application component, ensuring it functions correctly without blocking rendering. This approach aligns with the component's design constraints.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/notifications-empty-screen.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\nimport { Notifications } from '@mantine/notifications';\n\nfunction Demo() {\n  return (\n    <MantineProvider>\n      <Notifications />\n      <App />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Heading Styles with Mantine Style Props in TSX\nDESCRIPTION: Illustrates using Mantine's `fz` (font-size) and `lh` (line-height) style props on a `Box` component. By referencing heading levels ('h1') as values, the corresponding Mantine CSS variables (`--mantine-h1-font-size`, `--mantine-h1-line-height`) are applied. Requires the `@mantine/core` package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box fz=\"h1\" lh=\"h1\">\n      This text uses --mantine-h1-* variables\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Overlay Component as Polymorphic Element in Mantine React - JSX\nDESCRIPTION: This snippet demonstrates how to render the Overlay as a different HTML element by using the Polymorphic utility/component. By specifying `defaultElement` as `div`, switching to an `a` tag, and targeting the Overlay component, developers can control polymorphic props and composition for accessibility or semantics. Inputs include the component name and desired element tags; the result is the flexible Overlay render method. Requires Mantine’s Polymorphic support and the Overlay component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/overlay.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Polymorphic\n  defaultElement=\"div\"\n  changeToElement=\"a\"\n  component=\"Overlay\"\n  withNext\n/>\n```\n\n----------------------------------------\n\nTITLE: Configuring PostCSS with mantine-preset\nDESCRIPTION: Creates a 'postcss.config.cjs' file with plugins for Mantine preset and simple variables, defining custom breakpoints for responsiveness.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using inline styles for dynamic properties in Mantine\nDESCRIPTION: Demonstrates how to use inline styles and style props for dynamic styling when the values aren't known in advance, such as arbitrary colors or font families.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dynamic-css-styles.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\ninterface DemoProps {\n  fontFamily: string;\n  color: string;\n}\n\nfunction Demo({ fontFamily, color }: DemoProps) {\n  return (\n    <Box style={{ backgroundColor: color }} ff={fontFamily}>\n      My demo\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting null data points in LineChart\nDESCRIPTION: Uses 'connectNulls' prop to connect data points across null values within the series. Defaults to true, enabling continuous lines even when data contains gaps. Useful for visual continuity in incomplete datasets.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.connectNulls} />\n```\n\n----------------------------------------\n\nTITLE: Setting Default Color Scheme in MantineProvider (TypeScript)\nDESCRIPTION: Illustrates how to set an initial default color scheme ('dark') for the application when the external storage (like localStorage) does not have a stored value. This ensures a consistent initial appearance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider defaultColorScheme=\"dark\">\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Root Font Size for Mantine REM Scaling (CSS)\nDESCRIPTION: Sets the base `font-size` for the `:root` (or `html`) element to `10px`. This is done to demonstrate Mantine's `rem` unit scaling feature, where Mantine components can be scaled relative to this base size.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_13\n\nLANGUAGE: css\nCODE:\n```\n:root {\n  font-size: 10px;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useFocusReturn Hook in Mantine (Usage)\nDESCRIPTION: This code snippet demonstrates how to use the `useFocusReturn` hook.  It shows how to initialize the hook with the `opened` and `shouldReturnFocus` options. The `opened` option, which is a boolean, determines when the hook saves the active element. The `shouldReturnFocus` option determines if the focus should be returned automatically, or if a returned function needs to be called. The hook restores the focus to the last focused element based on the provided options.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-return.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n```tsx\nimport { useFocusReturn } from '@mantine/hooks';\n\nuseFocusReturn({\n  // Is region with focus trap active?\n  // When it activates hook saves document.activeElement to the internal state\n  // and focuses this element once focus trap is deactivated\n  opened: false,\n\n  // Determines whether focus should be returned automatically, true by default\n  shouldReturnFocus: true,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing legend position in LineChart\nDESCRIPTION: Uses 'legendProps' to adjust legend placement and size by passing props such as 'verticalAlign' and 'height' to the recharts Legend component. Facilitates layout customization for better integration within UI.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.legendPosition} />\n```\n\n----------------------------------------\n\nTITLE: Applying Line Height with Fh style prop in React\nDESCRIPTION: Provides an example of setting line height in a Text component via the lh style prop using CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Text lh=\"xl\">\n      This text uses --mantine-line-height-xl variable\n    </Text>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Page Redirection in React for TipTap Component\nDESCRIPTION: This snippet imports and uses a Redirect component to automatically redirect users from the current page to the '/x/tiptap' path. This is likely part of a documentation site restructuring where the TipTap component documentation was moved to a new location.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/tiptap.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n\n<Redirect to=\"/x/tiptap\" />\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Focus in Popover Dropdown\nDESCRIPTION: This code snippet showcases how to set the initial focus to a specific element within the `Popover.Dropdown` using the `data-autofocus` attribute. The Popover component utilizes FocusTrap to manage focus within the dropdown. The element with the `data-autofocus` attribute will receive focus when the dropdown opens.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/popover.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Popover } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover>\n      <Popover.Target>\n        <button type=\"button\">Target</button>\n      </Popover.Target>\n      <Popover.Dropdown>\n        <input />\n        <input data-autofocus />\n        <input />\n      </Popover.Dropdown>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up a named form with useForm\nDESCRIPTION: Shows how to create a form with the useForm hook and assign it a name that can be referenced by form actions. The name property is essential for connecting form actions to a specific form.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/actions.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nexport interface DemoFormValues {\n  name: string;\n  age: number;\n}\n\nfunction Demo() {\n  const form = useForm<DemoFormValues>({\n    mode: 'uncontrolled',\n    name: 'demo-form',\n    initialValues: {\n      name: '',\n      age: 0,\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Setting Up ColorSwatch Component Page\nDESCRIPTION: Imports necessary components and data for the ColorSwatch documentation page and sets up the layout using MDX data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/color-swatch.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ColorSwatchDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.ColorSwatch);\n```\n\n----------------------------------------\n\nTITLE: Using getColorScheme utility (TSX)\nDESCRIPTION: Demonstrates how to use the `getColorScheme` utility function to get the current color scheme value outside of a component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-get-color-scheme-value-in-js.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getColorScheme } from './getColorScheme';\n\nconst colorScheme = getColorScheme();\n```\n\n----------------------------------------\n\nTITLE: Declaring useMap React Hook Type Signature in TypeScript\nDESCRIPTION: Defines the type signature for the useMap hook, which initializes and returns a Map object tied to React state. It accepts an optional initial state parameter as an array of key-value tuples and outputs a Map instance with keys of type T and values of type V. This signature ensures type safety and proper initialization when using useMap in TypeScript React projects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-map.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useMap<T, V>(initialState?: [T, V][]): Map<T, V>;\n```\n\n----------------------------------------\n\nTITLE: Accessible Clear Button Setup in MultiSelect Component with React and TypeScript\nDESCRIPTION: Shows how to add an accessible clear button to the MultiSelect component by setting the clearable prop to true and specifying aria-label for the clear button via clearButtonProps. This ensures proper screen reader accessibility. It uses React and Typescript and requires the @mantine/core library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/multi-select.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MultiSelect } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MultiSelect\n      data={[]}\n      clearable\n      clearButtonProps={{\n        'aria-label': 'Clear input',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Button with Icon and Link\nDESCRIPTION: This snippet demonstrates how to create a styled button component using Mantine's Button with an integrated icon and hyperlink behavior. The button includes a red heart icon on the right, expands to a minimum width, and navigates to the sponsorship page when clicked.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Button\n  rightSection={<IconHeartFilled size={22} color=\"var(--mantine-color-red-7)\" />}\n  size=\"lg\"\n  miw={300}\n  justify=\"space-between\"\n  children=\"Sponsor Mantine\"\n  variant=\"default\"\n  radius=\"md\"\n  component=\"a\"\n  href=\"https://opencollective.com/mantinedev\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Configuring Pointer Cursor for Radio Components in Mantine Theme\nDESCRIPTION: Shows how to configure the cursor type for Radio components by modifying the Mantine theme. This snippet sets the cursor to 'pointer' instead of the default 'default' cursor for all Radio inputs and labels.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/radio.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider, Radio } from '@mantine/core';\n\nconst theme = createTheme({\n  cursorType: 'pointer',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Radio label=\"Pointer cursor\" />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Clearable Input in DateInput\nDESCRIPTION: This snippet shows how to allow users to clear the date input by setting the `clearable` prop. When activated, the input can be emptied or reset by selecting the same date again, providing a user-friendly way to reset the field.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.clearable} />\n```\n\n----------------------------------------\n\nTITLE: PasswordInput with aria-label for Visibility Toggle\nDESCRIPTION: This snippet shows how to set the `aria-label` attribute on the visibility toggle button of the PasswordInput component using the `visibilityToggleButtonProps` prop. This is important for accessibility, as it provides a descriptive label for screen readers. Dependencies: @mantine/core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/password-input.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PasswordInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <PasswordInput\n      label=\"Password\"\n      visibilityToggleButtonProps={{\n        'aria-label': 'Toggle password visibility',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Spacing with Space Component for HTML elements\nDESCRIPTION: Demonstrates how to use the `Space` component to add spacing between regular HTML elements. It imports `Space` from `@mantine/core` and creates a component where a vertical space (`h=\"md\"`) is inserted between two `div` elements.  Since regular HTML elements do not have access to Mantine's theme spacing via props, the `Space` component is recommended.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/space.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Space } from '@mantine/core';\n\n// Margin props are not available on div,\n// use Space to add spacing from theme\nfunction Demo() {\n  return (\n    <>\n      <div>First line</div>\n      <Space h=\"md\" />\n      <div>Second line</div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Textarea in React\nDESCRIPTION: This example demonstrates how to create a controlled Textarea component in React using the useState hook to manage the textarea's value.  The onChange event handler updates the state with the current value of the textarea.  The component uses the Textarea component from the '@mantine/core' library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/textarea.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useState } from 'react';\nimport { Textarea } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  return (\n    <Textarea\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Button Sections in CSS\nDESCRIPTION: This CSS snippet provides an example of styling the left and right sections of the button using the `data-position` attributes. Styles are applied to both sections initially, with specific styles for the left and right sections based on the respective `data-position` attributes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_6\n\nLANGUAGE: css\nCODE:\n```\n.section {\n  /* Styles applied to both sections */\n  width: 2rem;\n\n  /* Styles applied only to left section */\n  &[data-position='left'] {\n    background-color: red;\n  }\n\n  /* Styles applied only to right section */\n  &[data-position='right'] {\n    background-color: blue;\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Mantine Theme in TypeScript\nDESCRIPTION: Defines a custom Mantine theme using the `createTheme` function from `@mantine/core`. This theme object specifies properties like `fontFamily` and `primaryColor` and needs to be passed to the `MantineProvider`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// theme.ts\nimport { createTheme } from '@mantine/core';\n\n// Do not forget to pass theme to MantineProvider\nexport const theme = createTheme({\n  fontFamily: 'serif',\n  primaryColor: 'cyan',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring _app.tsx for Next.js Pages with Emotion\nDESCRIPTION: This snippet demonstrates how to configure the `_app.tsx` file in a Next.js pages router project to use Emotion with Mantine. It imports necessary modules from Next.js, `@mantine/core`, and `@mantine/emotion`. It then wraps the application with `MantineEmotionProvider` (using the Emotion cache), and also includes `MantineProvider` and `emotionTransform` to set up Emotion correctly within the Mantine context.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport Head from 'next/head';\nimport { MantineProvider } from '@mantine/core';\nimport {\n  emotionTransform,\n  MantineEmotionProvider,\n} from '@mantine/emotion';\nimport { emotionCache } from '../emotion/cache';\n\nexport default function App({ Component, pageProps }: any) {\n  return (\n    <MantineEmotionProvider cache={emotionCache}>\n      <MantineProvider stylesTransform={emotionTransform}>\n        <Head>\n          <title>Mantine Template</title>\n          <meta\n            name=\"viewport\"\n            content=\"minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no\"\n          />\n          <link rel=\"shortcut icon\" href=\"/favicon.svg\" />\n        </Head>\n        <Component {...pageProps} />\n      </MantineProvider>\n    </MantineEmotionProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Popover Component with onDismiss Prop (TSX)\nDESCRIPTION: This example illustrates the usage of the `onDismiss` prop in the Popover component to handle outside clicks and escape key presses for closing the popover. The snippet manages the popover's open state using the `useState` hook.  The `onDismiss` function sets the opened state to `false`, which allows for closing the popover when clicking outside the popover or pressing the escape key.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-17-0.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Popover } from '@mantine/core';\n\nfunction Demo() {\n  const [opened, setOpened] = useState(false);\n  return (\n    <Popover\n      opened={opened}\n      onDismiss={() => setOpened(false)}\n    >\n      <Popover.Target>\n        <Button onClick={() => setOpened((o) => !o)}>\n          Toggle popover\n        </Button>\n      </Popover.Target>\n\n      <Popover.Dropdown>Dropdown</Popover.Dropdown>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Borders from All AppShell Components\nDESCRIPTION: Example showing how to remove the default border from all AppShell components by setting the withBorder prop to false on the parent AppShell component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// None of the components will have a border\nfunction Demo() {\n  return (\n    <AppShell withBorder={false}>{/* AppShell content */}</AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FloatingIndicator Component with React and Mantine in TypeScript\nDESCRIPTION: Illustrates the use of Mantine's FloatingIndicator component combined with React state and refs to create an interactive indicator that follows button controls arranged in a grid. The component reacts to user clicks by updating the active button state and floating the indicator accordingly. It depends on @mantine/core for UI components and @tabler/icons-react for icons, and requires CSS module styling. Inputs are button clicks which update internal active state, and output is a visual floating indicator positioned relative to the active control.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.7.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport {\n  IconArrowDown,\n  IconArrowDownLeft,\n  IconArrowDownRight,\n  IconArrowLeft,\n  IconArrowRight,\n  IconArrowUp,\n  IconArrowUpLeft,\n  IconArrowUpRight,\n  IconCircle,\n} from '@tabler/icons-react';\nimport { FloatingIndicator, UnstyledButton } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const [rootRef, setRootRef] = useState<HTMLDivElement | null>(null);\n  const [controlsRefs, setControlsRefs] = useState<Record<string, HTMLButtonElement | null>>({});\n  const [active, setActive] = useState('center');\n\n  const setControlRef = (name: string) => (node: HTMLButtonElement) => {\n    controlsRefs[name] = node;\n    setControlsRefs(controlsRefs);\n  };\n\n  return (\n    <div className={classes.root} dir=\"ltr\" ref={setRootRef}>\n      <FloatingIndicator\n        target={controlsRefs[active]}\n        parent={rootRef}\n        className={classes.indicator}\n      />\n\n      <div className={classes.controlsGroup}>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('up-left')}\n          ref={setControlRef('up-left')}\n          mod={{ active: active === 'up-left' }}\n        >\n          <IconArrowUpLeft size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('up')}\n          ref={setControlRef('up')}\n          mod={{ active: active === 'up' }}\n        >\n          <IconArrowUp size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('up-right')}\n          ref={setControlRef('up-right')}\n          mod={{ active: active === 'up-right' }}\n        >\n          <IconArrowUpRight size={26} stroke={1.5} />\n        </UnstyledButton>\n      </div>\n      <div className={classes.controlsGroup}>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('left')}\n          ref={setControlRef('left')}\n          mod={{ active: active === 'left' }}\n        >\n          <IconArrowLeft size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('center')}\n          ref={setControlRef('center')}\n          mod={{ active: active === 'center' }}\n        >\n          <IconCircle size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('right')}\n          ref={setControlRef('right')}\n          mod={{ active: active === 'right' }}\n        >\n          <IconArrowRight size={26} stroke={1.5} />\n        </UnstyledButton>\n      </div>\n      <div className={classes.controlsGroup}>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('down-left')}\n          ref={setControlRef('down-left')}\n          mod={{ active: active === 'down-left' }}\n        >\n          <IconArrowDownLeft size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('down')}\n          ref={setControlRef('down')}\n          mod={{ active: active === 'down' }}\n        >\n          <IconArrowDown size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('down-right')}\n          ref={setControlRef('down-right')}\n          mod={{ active: active === 'down-right' }}\n        >\n          <IconArrowDownRight size={26} stroke={1.5} />\n        </UnstyledButton>\n      </div>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Data Attributes with mod Prop on Mantine Box Component in TypeScript/React\nDESCRIPTION: This snippet illustrates the use of the newly introduced mod prop on Mantine Box components to dynamically add data attributes to the root DOM element. It supports string, object, or array types to specify data attribute keys and values, enabling enhanced markup customization without manual attribute management. The examples demonstrate adding boolean data attributes and attributes with specific values. Requires importing Box from @mantine/core and React environment.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-5-0.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\n<Box mod=\"data-button\" />;\n// -> <div data-button />\n\n<Box mod={{ opened: true }} />;\n// -> <div data-opened />\n\n<Box mod={{ opened: false }} />;\n// -> <div />\n\n<Box mod={[\"button\", { opened: true }]} />;\n// -> <div data-button data-opened />\n\n<Box mod={{ orientation: 'horizontal' }} />;\n// -> <div data-orientation=\"horizontal\" />\n```\n\n----------------------------------------\n\nTITLE: Refactored Button Component with Left and Right Sections\nDESCRIPTION: Demonstrates the updated API where Button components now use 'leftSection' and 'rightSection' props instead of 'icon' props. This improves clarity and flexibility in adding icons or sections to buttons.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button leftSection=\"left\" rightSection=\"right\">\n      Label\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Tooltip Animation Duration in BarChart, JSX/TypeScript\nDESCRIPTION: By default, tooltips do not animate transitions. Setting `tooltipAnimationDuration` to a number in milliseconds enables smooth animation of tooltip movements, enhancing visual fluidity. Demonstrated with BarChartDemos.tooltipAnimation demo data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_21\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.tooltipAnimation} />\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useClickOutside Hook in React\nDESCRIPTION: Demonstrates the basic implementation of the useClickOutside hook. The hook returns a ref that should be attached to the target element, and the provided handler function is called when a click occurs outside this element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-click-outside.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useClickOutside } from '@mantine/hooks';\n\nfunction Example() {\n  const handleClickOutside = () =>\n    console.log('Clicked outside of div');\n  const ref = useClickOutside(handleClickOutside);\n  return <div ref={ref} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Popover Middlewares\nDESCRIPTION: This TypeScript code illustrates how to customize the `middlewares` options in the `Popover` component. It shows an example of modifying the shift middleware padding.  Dependencies include `@mantine/core` for UI components and Floating UI for positioning configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Popover } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover middlewares={{ shift: { padding: 20 } }} position=\"bottom\">\n      {/* Popover content */}\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Selective Live Validation for Specific Fields with Mantine useForm in TypeScript\nDESCRIPTION: Sets up the form to validate only specified fields on input changes by providing an array of field paths to the validateInputOnChange option. Demonstrates usage of a dynamic index constant FORM_INDEX for nested arrays. This approach improves performance by limiting validation scope. Depends on '@mantine/form' and a constant FORM_INDEX. Inputs are the form configuration and specific field paths; output is a form object with scoped live validation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validation.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { FORM_INDEX, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  validateInputOnChange: [\n    'name',\n    'email',\n    `jobs.${FORM_INDEX}.title`,\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering Mantine Notifications Component Inside MantineProvider in TypeScript (TSX)\nDESCRIPTION: Sets up the Notifications component within a MantineProvider context, which is required to use the notifications system. It demonstrates wrapping the application or part of it with MantineProvider and rendering the Notifications component to enable notification rendering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\nimport { Notifications } from '@mantine/notifications';\n\nfunction Demo() {\n  return (\n    <MantineProvider>\n      <Notifications />\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling AppShell Components Except Main Content\nDESCRIPTION: Example demonstrating how to disable all AppShell sections except the Main component by using the disabled prop, useful for hiding shell components on specific pages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\nfunction Demo() {\n  return <AppShell disabled>{/* AppShell content */}</AppShell>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using HeadlessMantineProvider in a React Application\nDESCRIPTION: Demonstrates how to import and use `HeadlessMantineProvider` to enable headless UI features in a React app, replacing the default `MantineProvider`. Wrapping the application within `HeadlessMantineProvider` disables all styling features, allowing for custom styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/unstyled.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HeadlessMantineProvider } from '@mantine/core';\n\nfunction App() {\n  return (\n    <HeadlessMantineProvider>\n      {/* Your application */}\n    </HeadlessMantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: React Controlled JsonInput Component Example in TypeScript\nDESCRIPTION: This code demonstrates a controlled React component utilizing the JsonInput component, managing its input value via useState. It highlights how to create a controlled form input, capturing user input, and updating the component state accordingly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { JsonInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  return <JsonInput value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessibility Labels for RangeSlider and Slider\nDESCRIPTION: Demonstrates how to add accessibility labels to Slider and RangeSlider components for screen readers. The thumbLabel prop for Slider and thumbFromLabel and thumbToLabel props for RangeSlider are used to provide labels for the thumbs, which are read by screen readers to improve accessibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/slider.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RangeSlider, Slider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Slider thumbLabel=\"Thumb aria-label\" />\n      <RangeSlider\n        thumbFromLabel=\"First thumb aria-label\"\n        thumbToLabel=\"Second thumb aria-label\"\n      />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering Items in a List with useListState\nDESCRIPTION: The `filter` handler filters the list based on a provided condition. It accepts a function that determines which items should be kept in the list. This example filters the list to keep only those items whose 'a' property equals 'new-prop'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n// filter objects that have a = 'new-prop'\nconst filter = () => handlers.filter((item) => item.a === 'new-prop');\n// values -> [{ a: 'new-prop' }]\n```\n\n----------------------------------------\n\nTITLE: Defining Color Scheme Specific Root Styles - PostCSS/Mantine (SCSS)\nDESCRIPTION: Illustrates creating :root-level CSS variables for light and dark color schemes using Mantine postcss-preset-mantine mixins. The light-root and dark-root mixins allow developers to set CSS variable values conditionally depending on the active color scheme. Requires postcss-preset-mantine version 1.9.0 or higher, and SCSS/PostCSS processing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-2-0.mdx#_snippet_3\n\nLANGUAGE: scss\nCODE:\n```\n:root {\n  @mixin light-root {\n    --color: red;\n  }\n\n  @mixin dark-root {\n    --color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Opening and Closing Typesafe Context Modals Programmatically in TypeScript\nDESCRIPTION: Demonstrates usage of openContextModal and closeModal functions from @mantine/modals to open and close a typesafe context modal identified by modal key 'demonstration'. openContextModal accepts a configuration object including modal key, title, and typed innerProps to pass data securely. This pattern supports programmatic modal lifecycle management with type-checked props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/modals.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { closeModal, openContextModal } from '@mantine/modals';\n\nopenContextModal({\n  modal: 'demonstration',\n  title: 'Test modal from context',\n  innerProps: {\n    modalBody:\n      'This modal was defined in ModalsProvider, you can open it anywhere in you app with useModals hook',\n  },\n});\ncloseModal('demonstration');\n```\n\n----------------------------------------\n\nTITLE: Customizing axes properties in LineChart\nDESCRIPTION: Passes axis-specific properties via 'xAxisProps' and 'yAxisProps' to tailor axes orientation, scale, and style. Includes examples such as changing axis orientation through props. Enhances axis display customization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.axisProps} />\n```\n\n----------------------------------------\n\nTITLE: Example of incorrect usage of hooks in server component\nDESCRIPTION: This snippet illustrates a TypeScript component that attempts to use a React hook (`useDisclosure`) without the 'use client' directive, resulting in an error because hooks are not allowed in server components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ❌ This will throw an error\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const { opened, toggle } = useDisclosure();\n  return (\n    <button onClick={toggle}>{opened ? 'Opened' : 'Closed'}</button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine VisuallyHidden with ActionIcon (TSX)\nDESCRIPTION: Demonstrates integrating the Mantine VisuallyHidden component with an ActionIcon in a React functional component. VisuallyHidden hides the provided text 'Like post' from the visual display, ensuring it's still available to screen readers for improved accessibility when the icon is focused.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/visually-hidden.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IconHeart } from '@tabler/icons-react';\nimport { ActionIcon, VisuallyHidden } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <ActionIcon>\n      <IconHeart />\n      <VisuallyHidden>Like post</VisuallyHidden>\n    </ActionIcon>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Augmenting Custom Variant Types for Mantine Button in TypeScript\nDESCRIPTION: Provides a guide for augmenting Mantine's ButtonProps to allow custom variant types using TypeScript declaration merging. Depends on @mantine/core and use of type augmentation via declaration merging. The key parameter is the variant property, which can be set to extended string values. No runtime input/output; affects type safety during development. Limitation: the module augmentation must match the library's module structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ButtonVariant, MantineSize } from '@mantine/core';\n\ntype ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';\n\ndeclare module '@mantine/core' {\n  export interface ButtonProps {\n    variant?: ExtendedButtonVariant;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Non-Memoized Handler Refs with assignRef Utility (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use Mantine's assignRef utility to assign function handler refs that are not memoized via useCallback. The example defines a NumberInputHandlers interface, a DemoProps interface for an optional forwarded ref, and a Demo component that assigns a custom handler object to the provided ref. Dependencies: react, @mantine/hooks. Inputs are handler refs; output is a handlers object with increment and decrement functions. This is usually used for exposing imperative handlers instead of element refs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-merged-ref.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useState } from 'react';\nimport { assignRef } from '@mantine/hooks';\n\ninterface NumberInputHandlers {\n  increment: () => void;\n  decrement: () => void;\n}\n\ninterface DemoProps {\n  handlersRef?: React.ForwardedRef<NumberInputHandlers | undefined>;\n}\n\nfunction Demo({ handlersRef }: DemoProps) {\n  const [value, setValue] = useState(0);\n\n  const increment = () => setValue((v) => v + 1);\n  const decrement = () => setValue((v) => v - 1);\n\n  assignRef(handlersRef, { increment, decrement });\n\n  return (\n    <>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: MonthPicker Aria Labels Configuration – Typescript\nDESCRIPTION: This code snippet demonstrates how to configure aria labels for the next/previous controls in the MonthPicker component using the `ariaLabels` prop. It imports the `MonthPicker` component from `@mantine/dates` and defines a functional component `Demo` that renders the `MonthPicker` with custom aria labels for decade and year navigation. This enhances accessibility by providing descriptive labels for screen readers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MonthPicker } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <MonthPicker\n      ariaLabels={{\n        nextDecade: 'Next decade',\n        previousDecade: 'Previous decade',\n        nextYear: 'Next year',\n        previousYear: 'Previous year',\n        yearLevelControl: 'Change to decade view',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Tooltip and Interactions in BarChart, JSX/TypeScript\nDESCRIPTION: Disables the tooltip display and related cursor line interactions by setting `withTooltip={false}` prop. Useful when interaction or tooltip clutter is unwanted. Illustrated by BarChartDemos.noTooltip example.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_24\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.noTooltip} />\n```\n\n----------------------------------------\n\nTITLE: Drawing Reference Lines Behind BarChart in JSX/TypeScript\nDESCRIPTION: Uses the `referenceLines` prop to render lines behind the chart bars. Useful for marking thresholds or highlighting key values on the chart’s coordinate plane. Demonstrated with BarChartDemos.referenceLines data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_27\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.referenceLines} />\n```\n\n----------------------------------------\n\nTITLE: Initializing and Managing State Queue with useQueue Hook in React - TypeScript/TSX\nDESCRIPTION: Demonstrates setting up the useQueue hook from @mantine/hooks to manage a state with a fixed capacity and an overflow queue. The snippet showcases adding, updating, and clearing items in state and queue, with descriptive comments highlighting how the hook responds to these operations. Dependencies: React, @mantine/hooks. Expected input: an options object with initialValues (optional) and limit (required). Returns state, queue, and several management functions. Outputs: arrays representing visible state and queue. Limitations: Items are split between state and queue based on the limit, and the order of items is preserved.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-queue.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useQueue } from '@mantine/hooks';\n\nconst { state, queue, add, update, cleanQueue } = useQueue({\n  initialValues: [1],\n  limit: 2,\n});\n\n// state -> [1], queue -> []\n\n// When state.length is less that limit, new items are added to state\nadd(2);\n// state -> [1,2], queue -> []\n\n// When state.length is equal to limit, new items are added to queue\nadd(3, 4, 5, 6);\n// state -> [1,2], queue -> [3,4,5,6]\n\n// Use update function to modify items\nupdate((values) => values.map((item) => item * 3));\n// state -> [3,6], queue -> [9,12,15,18]\n\n// If you add or remove items in update function,\n// they will be divided between queue and state according to limit\n// order is always preserved\nupdate((values) => values.filter((item) => item % 2));\n// state -> [3,9], queue -> [15]\n\n// Remove all items from queue\ncleanQueue();\n// state -> [3,9], queue -> []\n\n// Remove all items from queue and state\nupdate(() => []);\n// state -> [], queue -> []\n```\n\n----------------------------------------\n\nTITLE: Using Custom Render and Utilities in Jest Test in TSX\nDESCRIPTION: Demonstrates a typical Jest test file structure using the custom `render` function and other utilities imported from the central `../test-utils` module. Shows how to render a component and use `screen` along with `@testing-library/jest-dom` matchers for making assertions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/jest.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { render, screen } from '../test-utils';\nimport { Welcome } from './Welcome';\n\ndescribe('Welcome component', () => {\n  it('has correct Next.js theming section link', () => {\n    render(<Welcome />);\n    expect(screen.getByText('this guide')).toHaveAttribute(\n      'href',\n      'https://mantine.dev/guides/next/'\n    );\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering various input sections in TagsInput\nDESCRIPTION: This snippet showcases how to organize input sections such as header, body, and footer within the TagsInput for enhanced layout control, managed via the 'sections' prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.sections} />\n```\n\n----------------------------------------\n\nTITLE: Avatar Component Accessibility Examples in Mantine\nDESCRIPTION: This code snippet illustrates how to use the `Avatar` component with correct and incorrect `alt` attributes for accessibility. The `alt` prop is crucial for screen readers and when the image fails to load. The examples show a component without the `alt` attribute (NotOk), a component with a correct `alt` (Ok), and a placeholder example using text content with `alt` attribute (OkPlaceholder).  Using `alt` is necessary for accessibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/avatar.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Avatar } from '@mantine/core';\n\nfunction NotOk() {\n  // Not ok, no alt for image\n  return <Avatar src=\"./image.png\" />;\n}\n\nfunction Ok() {\n  // Ok, alt is set on <img /> tag\n  return <Avatar src=\"./image.png\" alt=\"Rob Johnson\" />;\n}\n\nfunction Ehh() {\n  // Ehh, title is not required, but still recommended\n  return <Avatar>RJ</Avatar>;\n}\n\nfunction OkPlaceholder() {\n  // Ok, title is set on placeholder\n  return <Avatar alt=\"Rob Johnson\">RJ</Avatar>;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Input Usage Example\nDESCRIPTION: Demonstrates incorrect usage of the `Input` component directly.  It highlights that `Input` is a base component and is generally not meant to be used directly in applications. The code is not accessible. Requires `@mantine/core` for Input and TextInput.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/input.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Input, TextInput } from '@mantine/core';\n\n// Incorrect usage, input is not accessible\nfunction Incorrect() {\n  return (\n    <Input.Wrapper label=\"Input label\">\n      <Input />\n    </Input.Wrapper>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Providing component and renderRoot Props to a Non-polymorphic Component (Mantine Group, TypeScript)\nDESCRIPTION: Illustrates that non-polymorphic Mantine components now accept 'component' and 'renderRoot' props. The Group component is rendered as a 'nav' element, with children links inside. Requires Mantine v7.3.0 or newer.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Group } from '@mantine/core';\n\n// Group is not polymorphic component,\n// but it still supports component and renderRoot props\nfunction Demo() {\n  return (\n    <Group component=\"nav\">\n      <a>Item 1</a>\n      <a>Item 2</a>\n      <a>Item 3</a>\n    </Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Items into a List with useListState\nDESCRIPTION: The `insert` handler inserts one or more items at a specific index within the list. It takes the index and the item(s) to insert as parameters. In this example, an item with `a: 5` is inserted at index 1.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// insert one or more items at given position\nconst insert = () => handlers.insert(1, { a: 5 });\n// values -> [{ a: 4 }, { a: 5 }, { a: 2 }]\n```\n\n----------------------------------------\n\nTITLE: Changing Chart Grid and Text Colors Using CSS Variables and Props in BarChart, JSX/TypeScript\nDESCRIPTION: Explains how to theme grid lines and text colors using CSS variables --chart-grid-color and --chart-text-color or alternatively with `gridColor` and `textColor` props if only a single color scheme is in use. Examples derive from BarChartDemos.gridColor and the embedded usage code snippet.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_20\n\nLANGUAGE: TSX\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      type=\"stacked\"\n      gridColor=\"gray.5\"\n      textColor=\"gray.9\"\n      series={[\n        { name: 'Smartphones', color: 'violet.6' },\n        { name: 'Laptops', color: 'blue.6' },\n        { name: 'Tablets', color: 'teal.6' },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demo: Opening DateTimePicker in modal mode\nDESCRIPTION: This example illustrates switching the DateTimePicker display mode from default popover to modal by setting the \"dropdownType\" prop to \"modal,\" facilitating full-screen or large modal interactions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_8\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DateTimePickerDemos.modal} />\n```\n\n----------------------------------------\n\nTITLE: Defining Mantine useTextSelection Hook (TSX)\nDESCRIPTION: This snippet provides the TypeScript definition for the `useTextSelection` React hook from the Mantine library. It indicates that the hook returns a `Selection` object representing the current text selection or `null` if no text is currently selected. This definition clarifies the hook's output type.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-text-selection.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useTextSelection(): Selection | null;\n```\n\n----------------------------------------\n\nTITLE: Rendering Vertical Oriented BarChart in JSX/TypeScript\nDESCRIPTION: Alters the bar chart orientation to vertical by setting `orientation=\"vertical\"`. Demonstrates flipped axes and bars, useful for different visualization needs. Based on BarChartDemos.vertical example.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_26\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.vertical} />\n```\n\n----------------------------------------\n\nTITLE: Using ColorSchemeScript component to set color scheme before hydration in SSR apps (TypeScript)\nDESCRIPTION: This snippet shows how to include the `ColorSchemeScript` component to set the `data-mantine-color-scheme` attribute on the `<html>` element prior to hydration, preventing flash of incorrect color schemes during SSR rendering. Additional props like nonce can be added to the script tag.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ColorSchemeScript } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <ColorSchemeScript\n      nonce=\"8IBTHwOdqNKAWeKl7plt8g==\"\n      defaultColorScheme=\"dark\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying conditional classNames based on component props\nDESCRIPTION: Demonstrates how to conditionally apply styles to components based on their props using the extend function and cx utility. This example applies different styles to TextInput when it's required or has an error.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport cx from 'clsx';\nimport { createTheme, MantineProvider, TextInput } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extend({\n      classNames: (_theme, props) => ({\n        label: cx({ [classes.labelRequired]: props.required }),\n        input: cx({ [classes.inputError]: props.error }),\n      }),\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <TextInput required label=\"Required input\" placeholder=\"Required input\" />\n      <TextInput error label=\"Input with error\" placeholder=\"Input with error\" mt=\"md\" />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Line Heights Using Mantine Theme (TypeScript)\nDESCRIPTION: Demonstrates setting custom line-height values for text components with the theme object using createTheme. The shared lineHeights object assigns values like '1.4' to '1.65' for different sizes, controlling line spacing across components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/typography.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  lineHeights: {\n    xs: '1.4',\n    sm: '1.45',\n    md: '1.55',\n    lg: '1.6',\n    xl: '1.65',\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing TreeNodeData Type\nDESCRIPTION: Imports the `TreeNodeData` type from the '@mantine/core' library. This enables type-checking for the data structure used with the Tree component, enhancing code maintainability and preventing errors by enforcing the correct data format.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TreeNodeData } from '@mantine/core';\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Component Example\nDESCRIPTION: Illustrates how to use the `Polymorphic` component to change the underlying HTML element of the `Paper` component.  The `defaultElement` is 'div' which can be changed to 'button'. `withNext` is likely a prop used by the `Polymorphic` component or its children.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/paper.mdx#_snippet_5\n\nLANGUAGE: mdx\nCODE:\n```\n<Polymorphic\n  defaultElement=\"div\"\n  changeToElement=\"button\"\n  component=\"Paper\"\n  withNext\n/>\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Multiple BarChart Tooltips Using syncId Prop in TypeScript/JSX\nDESCRIPTION: Passes props to the underlying Recharts BarChart component via `barChartProps`. Setting `syncId` synchronizes tooltip visibility and coordinates across multiple BarChart instances sharing the same ID. Demonstrated with BarChartDemos.sync data example.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_25\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.sync} />\n```\n\n----------------------------------------\n\nTITLE: Explaining PostCSS functions in Mantine styles with example usage\nDESCRIPTION: Provides an example of using the 'light-dark' PostCSS function in SCSS files, demonstrating how it simplifies theme-based styling by automatically adjusting styles based on color scheme. Highlights that PostCSS transformations are only applicable within stylesheet files.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/postcss-fns-inline.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n// What you write\n.demo {\n  background: light-dark(white, black);\n}\n\n// What you get after PostCSS processing\n[data-mantine-color-scheme='light'] .demo {\n  background: black;\n}\n\n[data-mantine-color-scheme='dark'] .demo {\n  background: black;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Values Against RegExp Using Mantine Form Validator in TypeScript\nDESCRIPTION: The snippet demonstrates the matches validator that checks whether the form value matches a given regular expression pattern. It only passes validation if the value is a string and matches the regexp. The example validates a color string field against a hex color regexp. The form is initialized and validated using useForm in uncontrolled mode.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { matches, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    color: '',\n  },\n\n  validate: {\n    color: matches(/^#([0-9a-f]{3}){1,2}$/, 'Invalid color'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up system color scheme support with MantineProvider and ColorSchemeScript\nDESCRIPTION: Demonstrates how to configure Mantine to use system color scheme preferences with the 'auto' value. Requires setting the defaultColorScheme on both ColorSchemeScript and MantineProvider components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <ColorSchemeScript defaultColorScheme=\"auto\" />\n      <MantineProvider defaultColorScheme=\"auto\">\n        <App />\n      </MantineProvider>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Partially Overriding Heading Styles in Mantine Theme (TSX)\nDESCRIPTION: Demonstrates modifying only specific properties of a heading style (e.g., `fontSize` for `h1`) within the Mantine theme using `createTheme` from `@mantine/core`. Unspecified properties will retain their default values from `DEFAULT_THEME` due to deep merging.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\n// Changes only font-size of h1,\n// other values will be taken from the DEFAULT_THEME\nconst theme = createTheme({\n  headings: {\n    sizes: {\n      h1: {\n        fontSize: '2rem',\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering Basic HoverCard Usage Demo (JSX)\nDESCRIPTION: Renders a `Demo` component to display the basic usage example of the HoverCard. The actual demonstration logic and content are sourced from the `HoverCardDemos.usage` object.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/hover-card.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={HoverCardDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Configuring the DateInput Demo Interface\nDESCRIPTION: This snippet showcases a demo that allows users to interactively configure DateInput properties, such as min/max dates, format, or disabled states, providing an interactive playground for exploring component capabilities.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.configurator} />\n```\n\n----------------------------------------\n\nTITLE: Comparing Form Field Values with Mantine matchesField Validator in TypeScript\nDESCRIPTION: This example demonstrates the matchesField validator that checks if a form field value matches the value of another specified field. It only works with primitive values and does not support array or object comparison. The snippet shows validation for confirming password equality using useForm in uncontrolled mode, returning a custom error if values differ.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { matchesField, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    password: '',\n    confirmPassword: '',\n  },\n\n  validate: {\n    confirmPassword: matchesField(\n      'password',\n      'Passwords are not the same'\n    ),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Disabled Button in TypeScript\nDESCRIPTION: This code snippet demonstrates the creation of a disabled button using the Mantine UI library. The `disabled` prop is set to `true`, which adds the `data-disabled` attribute to the HTML button element. This attribute can be used to apply specific styles for the disabled state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button disabled className=\"my-button\">\n      Disabled button\n    </Button>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring DateInput with Custom Value Format and Day.js Plugin\nDESCRIPTION: This snippet explains how to customize the display format of DateInput using the `valueFormat` prop, and shows how to enable the `customParseFormat` plugin in dayjs for custom date parsing. These configurations allow flexible date handling and display formatting in the component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Do this once in your application root file\nimport dayjs from 'dayjs';\nimport customParseFormat from 'dayjs/plugin/customParseFormat';\n\ndayjs.extend(customParseFormat);\n```\n\n----------------------------------------\n\nTITLE: Limitations: Using PostCSS functions in inline styles with React and Mantine\nDESCRIPTION: Explains that PostCSS functions are not supported in inline styles within React components. Demonstrates an incorrect usage example where a PostCSS function is directly used in a React inline style, emphasizing that such code will not be processed by PostCSS, and thus, the styling will not work as intended.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/postcss-fns-inline.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      style={{\n        // ❌ This does not get processed by PostCSS\n        backgroundColor: 'light-dark(white, black)',\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Conditionally Hiding Components per Color Scheme in Mantine (TypeScript/React)\nDESCRIPTION: Shows usage of 'lightHidden' and 'darkHidden' props to display or hide buttons depending on the current color scheme. Depends on '@mantine/core'. One button is only visible in dark mode, and another in light mode. Output: two Button components conditionally hidden by user's theme settings.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Button color=\"cyan\" lightHidden>\n        Visible in dark color scheme only\n      </Button>\n\n      <Button color=\"pink\" darkHidden>\n        Visible in light color scheme only\n      </Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Spacing - Mantine Theme - TSX\nDESCRIPTION: Illustrates how to override the default spacing scale (`xs` through `xl`) in the Mantine theme by providing custom pixel or rem values within the `spacing` property of the `createTheme` function. This customization allows control over the `--mantine-spacing-*` CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_20\n\nLANGUAGE: TSX\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  spacing: {\n    xs: '0.5rem',\n    sm: '0.75rem',\n    md: '1rem',\n    lg: '1.5rem',\n    xl: '2rem',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: MonthPickerInput with Icon\nDESCRIPTION: Shows how to add an icon to the MonthPickerInput component for better visual indication of its purpose.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.icon} />\n```\n\n----------------------------------------\n\nTITLE: Setting Y Axis Domain Scale in BarChart, JSX/TypeScript\nDESCRIPTION: Allows explicit domain setting on the y-axis via `yAxisProps`, useful when data range is known in advance to ensure consistent axis scaling. Illustrated with BarChartDemos.yScale example.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_13\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.yScale} />\n```\n\n----------------------------------------\n\nTITLE: Updating Opened Modal Content via Modals Manager - Mantine with React TypeScript\nDESCRIPTION: Shows use of the modals.updateModal function from @mantine/modals to modify modal properties after opening it. Depends on @mantine/core and @mantine/modals. The example opens a modal, then updates its title and content after a timeout. Requires handling modal IDs returned by modals.open for referencing updates.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_5\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Button } from '@mantine/core';\nimport { modals } from '@mantine/modals';\n\nfunction Demo() {\n  return (\n    <Button\n      onClick={() => {\n        const modalId = modals.open({\n          title: 'Initial Modal Title',\n          children: <Text>This text will update in 2 seconds.</Text>,\n        });\n\n        setTimeout(() => {\n          modals.updateModal({\n            modalId,\n            title: 'Updated Modal Title',\n            children: (\n              <Text size=\"sm\" c=\"dimmed\">\n                This is the updated content of the modal.\n              </Text>\n            ),\n          });\n        }, 2000);\n      }}\n    >\n      Open updating modal\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Date Parser with dateParser Prop\nDESCRIPTION: This snippet demonstrates how to replace the default date parsing logic in DateInput with a custom parser function via the `dateParser` prop. The parser accepts a string and returns a Date object, enabling flexible input handling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.parser} />\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine and PostCSS Packages\nDESCRIPTION: Uses a custom <PackagesInstallation> component to install necessary packages for Mantine UI and PostCSS setup.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_3\n\nLANGUAGE: HTML\nCODE:\n```\n<PackagesInstallation />\n```\n\n----------------------------------------\n\nTITLE: Initializing DirectionProvider and MantineProvider in React with TypeScript\nDESCRIPTION: Example React functional component demonstrating the setup of Mantine's DirectionProvider and MantineProvider components to enable right-to-left or left-to-right direction control across the application. The DirectionProvider wraps MantineProvider, providing direction context to all nested Mantine components. This is crucial when implementing RTL support or dynamic direction changes in Mantine-based React applications.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rtl.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { DirectionProvider, MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <DirectionProvider>\n      <MantineProvider>{/* Your app here */}</MantineProvider>\n    </DirectionProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useMouse Hook - Mantine React\nDESCRIPTION: This code defines the `useMouse` hook's type signature. It takes an optional options object with a `resetOnExit` boolean as a parameter. It returns an object with `x`, `y`, and `ref` properties. `x` and `y` represent the mouse coordinates and are numbers. `ref` is a `React.MutableRefObject` which can be passed to the target element. Dependencies include React.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mouse.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useMouse<T extends HTMLElement = any>(options?: {\n  resetOnExit?: boolean;\n}): {\n  x: number;\n  y: number;\n  ref: React.MutableRefObject<T>;\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating createStyles and Global imports to @mantine/emotion\nDESCRIPTION: Shows how to update imports for createStyles and Global components from @mantine/core to @mantine/emotion in Mantine 7.x.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { createStyles, Global } from '@mantine/core';\n\n// 7.x\nimport { createStyles, Global } from '@mantine/emotion';\n```\n\n----------------------------------------\n\nTITLE: Adding Grouped String Options to Mantine NativeSelect (TSX)\nDESCRIPTION: This example shows how to create option groups within NativeSelect using the data prop. The data array contains objects, each with a group key for the group label and an items key containing an array of strings for the options within that group.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/native-select.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NativeSelect } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <NativeSelect\n      data={[\n        {\n          group: 'Frontend libraries',\n          items: ['React', 'Angular', 'Svelte', 'Vue'],\n        },\n        {\n          group: 'Backend libraries',\n          items: ['Express', 'Koa', 'Django'],\n        },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Get color scheme outside of React component (TSX)\nDESCRIPTION: Shows how to retrieve the color scheme value outside of a React component by parsing the `data-mantine-color-scheme` attribute from the `documentElement`. The return type is `MantineColorScheme`.  This method is not compatible with server-side rendering (SSR).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-get-color-scheme-value-in-js.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineColorScheme } from '@mantine/core';\n\nexport function getColorScheme() {\n  return document.documentElement.getAttribute(\n    'data-mantine-color-scheme'\n  ) as MantineColorScheme;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Responsive Style Props with Object Syntax (TypeScript TSX)\nDESCRIPTION: Shows how to use Mantine style props with an object format to enable responsive breakpoints directly in component props. In this example, the 'w' prop (for width) is supplied as an object with values for 'base', 'sm', and 'lg' breakpoints. Requires @mantine/core and assumes theme.breakpoints configuration. Each breakpoint value overrides the previous as the viewport grows. This method is more computationally expensive and is not recommended for large lists.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style-props.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box w={{ base: 320, sm: 480, lg: 640 }} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using transitionProps in Mantine Modal component with React\nDESCRIPTION: This code demonstrates how to pass transitionProps to Mantine's Modal component to handle events after the open or close animations complete. It utilizes useDisclosure hook for state management and sets onEntered and onExited callbacks to log messages upon animation completion.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-call-function-when-modal-closes.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Modal } from '@mantine/core';\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const [opened, handlers] = useDisclosure();\n\n  return (\n    <Modal\n      title=\"Modal title\"\n      opened={opened}\n      onClose={handlers.close}\n      transitionProps={{\n        onEntered: () => console.log('Modal opened, animation done'),\n        onExited: () => console.log('Modal closed, animation done'),\n      }}\n    >\n      Modal content\n    </Modal>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using RemoveScroll class names to Offset Fixed Elements in React TypeScript\nDESCRIPTION: Shows how to use class names from the RemoveScroll component of @mantine/core to correctly position fixed elements when the Spotlight is open and scroll is locked. Includes example divs using RemoveScroll.classNames.fullWidth and RemoveScroll.classNames.zeroRight to apply width: 100% and right: 0 respectively.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/spotlight.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RemoveScroll } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <div className={RemoveScroll.classNames.fullWidth}>\n        width: 100%\n      </div>\n      <div className={RemoveScroll.classNames.zeroRight}>\n        right: 0\n      </div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useModalsStack with Modal Component TypeScript\nDESCRIPTION: Illustrates how to use the `useModalsStack` hook with the `Modal` component from `@mantine/core`. It demonstrates how to register modals using `stack.register` and control them with `stack.open`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-14-0.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Modal, useModalsStack } from '@mantine/core';\n\nfunction Demo() {\n  const stack = useModalsStack(['first', 'second']);\n\n  return (\n    <>\n      <Modal {...stack.register('first')}>First</Modal>\n      <Modal {...stack.register('second')}>Second</Modal>\n      <Button onClick={() => stack.open('first')}>Open first</Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Component Variants with `withProps` in Mantine (TSX)\nDESCRIPTION: Demonstrates using the `withProps` static function on Mantine components like `Button` and `InputBase` to define new components (`LinkButton`, `PhoneInput`) with pre-configured default props. It also shows overriding these defaults and integrating external components like `IMaskInput`. Dependencies include `@mantine/core` and `react-imask`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IMaskInput } from 'react-imask';\nimport { Button, InputBase } from '@mantine/core';\n\nconst LinkButton = Button.withProps({\n  component: 'a',\n  target: '_blank',\n  rel: 'noreferrer',\n  variant: 'subtle',\n});\n\nconst PhoneInput = InputBase.withProps({\n  mask: '+7 (000) 000-0000',\n  component: IMaskInput,\n  label: 'Your phone number',\n  placeholder: 'Your phone number',\n});\n\nfunction Demo() {\n  return (\n    <>\n      {/* You can pass additional props to components created with `withProps` */}\n      <LinkButton href=\"https://mantine.dev\">Mantine website</LinkButton>\n\n      {/* Component props override default props defined in `withProps` */}\n      <PhoneInput placeholder=\"Personal phone\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Modal from Closing using opened prop - JavaScript\nDESCRIPTION: This snippet explains the use of the `opened` prop of the Mantine Modal and Drawer components to prevent the modal from closing when the user clicks outside of it or presses the Escape key. It is useful when an async operation is in progress inside the modal. This involves setting the `opened` prop to `true` to keep the modal open.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-prevent-modal-from-closing.mdx#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Initializing Sparkline component with @mantine/charts in TypeScript\nDESCRIPTION: Shows how to create a simplified sparkline chart to display trends over a small dataset using the Sparkline component from @mantine/charts. The snippet defines width and height, provides an array of numeric data, sets the curve type, color, fill opacity, and stroke width properties. Designed for quick inline trend visualization in React environment with TypeScript support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Sparkline } from '@mantine/charts';\n\nfunction Demo() {\n  return (\n    <Sparkline\n      w={200}\n      h={60}\n      data={[10, 20, 40, 20, 40, 10, 50]}\n      curveType=\"linear\"\n      color=\"blue\"\n      fillOpacity={0.6}\n      strokeWidth={2}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Usage Demo for Center Component (MDX/TSX)\nDESCRIPTION: This snippet displays a live usage example of the Center component by passing demo data to a Demo wrapper. It ensures interactive documentation and previews for users learning how to utilize the Center component. Dependencies: React, Mantine Demo system, pre-defined CenterDemos.usage data. Input: CenterDemos.usage. Output: rendered demo container showcasing Center usage. Limitations: relies on the Demo and CenterDemos structure present.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/center.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n<Demo data={CenterDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Resetting Dirty State with New Values\nDESCRIPTION: This snippet demonstrates how to call `form.resetDirty` with new values to reset values used for dirty checks. It uses `@mantine/form` library and provides an example to illustrate how this works.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/status.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { a: 1 },\n});\n\nform.setValues({ a: 2 });\nform.isDirty(); // -> true\n\nform.resetDirty({ a: 2 });\nform.isDirty(); // -> false\n\nform.setValues({ a: 3 });\nform.isDirty(); // -> true\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the useForceUpdate Hook Signature in TypeScript\nDESCRIPTION: This TypeScript definition specifies the signature for the `useForceUpdate` hook. It indicates that the hook takes no arguments and returns a function that also takes no arguments and returns `void`. This returned function, when invoked, forces a re-render of the component where the hook is utilized.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-force-update.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useForceUpdate(): () => void;\n```\n\n----------------------------------------\n\nTITLE: Importing All Mantine Core Styles in React with TypeScript\nDESCRIPTION: Demonstrates how to include the entire set of Mantine component styles in a TypeScript React application. Requires the @mantine/core package to be installed in the project. Importing this CSS file ensures all core component styles are available without granular control over individual component styles. No parameters are needed; this is a top-level import statement.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Defining FileInputProps Type (single/multiple) in TypeScript\nDESCRIPTION: This snippet demonstrates how to define different types for FileInputProps. It imports the `FileInputProps` from '@mantine/core'. The code defines  `SingleInputProps` and `MultipleInputProps` by specializing the `FileInputProps` generic interface with `false` and `true`, respectively,  to specify single and multiple file selection configurations. This is useful for type safety and code organization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/file-input.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport type { FileInputProps } from '@mantine/core';\n\ntype SingleInputProps = FileInputProps<false>;\ntype MultipleInputProps = FileInputProps<true>;\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Classes in a CSS Module (CSS)\nDESCRIPTION: Illustrates a CSS module file (`Button.module.css`) containing multiple class definitions (`.button`, `.text`). Each class defined in this file will receive a unique, generated class name upon import, preventing naming collisions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n/* Button.module.css */\n.button {\n  color: red;\n}\n\n.text {\n  color: blue;\n}\n```\n\n----------------------------------------\n\nTITLE: Monitoring Form Field Changes with form.watch\nDESCRIPTION: This TypeScript code demonstrates using `form.watch` to subscribe to changes of a specific form field. It displays how to trigger a callback function whenever the value of the 'name' field changes. The callback receives the previous value, current value, and the touched and dirty states of the field.  Dependencies include `@mantine/core` and `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      name: '',\n      email: '',\n    },\n  });\n\n  form.watch('name', ({ previousValue, value, touched, dirty }) => {\n    console.log({ previousValue, value, touched, dirty });\n  });\n\n  return (\n    <div>\n      <TextInput label=\"Name\" placeholder=\"Name\" {...form.getInputProps('name')} />\n      <TextInput mt=\"md\" label=\"Email\" placeholder=\"Email\" {...form.getInputProps('email')} />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Responsive AppShell Main Padding in React (TSX)\nDESCRIPTION: Illustrates applying responsive padding to the `AppShell.Main` area via the `padding` prop on the root `AppShell` component. An object maps breakpoints (`base`, `sm`, `lg`) to padding values (numbers, strings, or theme spacing tokens), similar to Mantine style props. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// Padding is:\n// - 10 when viewport width is < theme.breakpoints.sm\n// - 15 when viewport width is >= theme.breakpoints.sm and < theme.breakpoints.lg\n// - theme.spacing.xl when viewport width is >= theme.breakpoints.lg\nfunction Demo() {\n  return (\n    <AppShell padding={{ base: 10, sm: 15, lg: 'xl' }}>\n      {/* AppShell content */}\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UseFieldInput Interface TypeScript\nDESCRIPTION: This code defines the `UseFieldInput` interface, which outlines the options accepted by the `use-field` hook. It specifies the types for various configuration parameters such as `mode`, `initialValue`, `initialTouched`, `initialError`, `onValueChange`, `validateOnChange`, `validateOnBlur`, `clearErrorOnChange`, `validate`, and `type`. These options allow for customization of field behavior like validation, state management, and event handling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-field.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UseFieldInput<T> {\n  /** Field mode, controlled by default */\n  mode?: 'controlled' | 'uncontrolled';\n\n  /** Initial field value */\n  initialValue: T;\n\n  /** Initial touched value */\n  initialTouched?: boolean;\n\n  /** Initial field error message */\n  initialError?: React.ReactNode;\n\n  /** Called with updated value when the field value changes */\n  onValueChange?: (value: T) => void;\n\n  /** Determines whether the field should be validated when value changes, false by default */\n  validateOnChange?: boolean;\n\n  /** Determines whether the field should be validated when it loses focus, false by default */\n  validateOnBlur?: boolean;\n\n  /** Determines whether the field should clear error message when value changes, true by default */\n  clearErrorOnChange?: boolean;\n\n  /** A function to validate field value, can be sync or async */\n  validate?: (value: T) => React.ReactNode | Promise<React.ReactNode>;\n\n  /** Field type, input by default */\n  type?: 'input' | 'checkbox';\n\n  /** A function to resolve validation error from the result returned from validate function, should return react node */\n  resolveValidationError?: (error: unknown) => React.ReactNode;\n}\n```\n\n----------------------------------------\n\nTITLE: Styling with CSS Modules in SCSS and TSX\nDESCRIPTION: Demonstrates the recommended approach of using CSS Modules for styling components. Includes an SCSS file (`Demo.module.css`) defining styles with nesting, data attributes (`data-collapsed`), media queries, mixins, and Mantine CSS variables. A corresponding TSX component (`Demo.tsx`) imports these styles as an object (`classes`) and applies them using the `className` prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_5\n\nLANGUAGE: scss\nCODE:\n```\n// Demo.module.css\n\n.root {\n  padding-right: rem(100px);\n\n  &[data-collapsed] {\n    padding-right: rem(40px);\n\n    & .control {\n      max-width: rem(200px);\n    }\n  }\n}\n\n.control {\n  background-color: var(--mantine-color-blue-1);\n  color: var(--mantine-color-blue-filled);\n  padding: var(--mantine-spacing-xl);\n  margin-left: rem(40px);\n\n  @media (max-width: $mantine-breakpoint-sm) {\n    margin-left: 0;\n    margin-top: var(--mantine-spacing-md);\n  }\n\n  @mixin hover {\n    background-color: light-dark(\n      var(--mantine-color-blue-1),\n      var(--mantine-color-blue-9)\n    );\n  }\n}\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// Demo.tsx\nimport classes from './Demo.module.css';\n\nfunction Demo({ collapsed }: { collapsed: boolean }) {\n  return (\n    <div\n      className={classes.root}\n      data-collapsed={collapsed || undefined}\n    >\n      <button type=\"button\" className={classes.control}>\n        Control\n      </button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Serialization with useLocalStorage Hook in React\nDESCRIPTION: Demonstrates how to provide custom serialization and deserialization functions to the useLocalStorage hook for handling data types that cannot be serialized with JSON.stringify by default.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useLocalStorage } from '@mantine/hooks';\n\nconst [value, setValue] = useLocalStorage({\n  key: 'color-scheme',\n  serialize: (value) => {\n    /* return value serialized to string */\n  },\n  deserialize: (localStorageValue) => {\n    /* parse localStorage string value and return value */\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Custom PostCSS Mixins in SCSS\nDESCRIPTION: This SCSS snippet demonstrates the usage of the custom PostCSS mixins defined earlier (`clearfix` and `circle`). It applies the `clearfix` mixin to the `.demo` class and calls the `circle` mixin with a size of `100px`.  Requires PostCSS processing to be applied to the SCSS code.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-9-0.mdx#_snippet_3\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  @mixin clearfix;\n  @mixin circle 100px;\n}\n```\n\n----------------------------------------\n\nTITLE: Explaining Polymorphic Components in Mantine\nDESCRIPTION: This snippet provides a conceptual explanation of polymorphic components, describing their ability to change the root element via the 'component' prop, with examples showcasing default behavior and customizations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/polymorphic-in-polymorphic.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n## What is polymorphic component?\n\nA polymorphic component is a component which root element can be changed with component prop.\nAll polymorphic components have a default element which is used when component prop is not provided.\nFor example, the `Button` component default element is `button` and it can be changed to\n`a` or any other element or component:\n\n```tsx\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button component=\"a\" href=\"https://mantine.dev/\" target=\"_blank\">\n      Mantine website\n    </Button>\n  );\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Validating List Fields with Joi and useForm\nDESCRIPTION: This snippet demonstrates validating list fields using Joi with Mantine Form. It defines a Joi schema for a list of objects, uses `joiResolver`, and accesses the validation results.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport Joi from 'joi';\nimport { joiResolver } from 'mantine-form-joi-resolver';\nimport { useForm } from '@mantine/form';\n\nconst listSchema = Joi.object({\n  list: Joi.array().items(\n    Joi.object({\n      name: Joi.string().min(2).messages({\n        'string.min': 'Name should have at least 2 letters',\n        'string.empty': 'Name should have at least 2 letters',\n      }),\n    })\n  ),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    list: [{ name: '' }],\n  },\n  validate: joiResolver(listSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'list.0.name': 'Name should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Creating a Mantine Theme Override in TypeScript\nDESCRIPTION: Defines a Mantine custom theme by importing and invoking the 'createTheme' function from '@mantine/core'. This theme sets 'serif' as the global font family and enables further theme customization. The file should be saved as 'src/theme.ts'. Dependencies include '@mantine/core'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/gatsby.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// src/theme.ts\nimport { createTheme } from '@mantine/core';\n\nexport const theme = createTheme({\n  fontFamily: 'serif',\n  // ... other theme override properties\n});\n```\n\n----------------------------------------\n\nTITLE: Converting Space-separated px Values to rem (Mantine rem Function, TypeScript)\nDESCRIPTION: Demonstrates the use of Mantine's rem utility function to convert space-separated px values to rem units, supporting responsive and scalable sizing. Requires '@mantine/core' v1.11.0+ for rem function enhancements. Input: px strings, Output: CSS calc() strings.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { rem } from '@mantine/core';\n\nrem('16px 32px');\n// -> calc(1rem * var(--mantine-scale)) calc(2rem * var(--mantine-scale))\n```\n\n----------------------------------------\n\nTITLE: Example SCSS Before Auto REM Conversion\nDESCRIPTION: Shows a simple SCSS snippet using pixel units for font size in a standard rule and a media query. This serves as an example of the input CSS that the `autoRem` PostCSS option will process and transform.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-8-0.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  font-size: 16px;\n\n  @media (min-width: 320px) {\n    font-size: 32px;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demo: Changing the displayed value format\nDESCRIPTION: This snippet shows how to utilize the \"valueFormat\" prop to alter the display format of the selected date/time using dayjs formatting, allowing for customized date/time representation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DateTimePickerDemos.format} />\n```\n\n----------------------------------------\n\nTITLE: Demo Usage\nDESCRIPTION: Renders a demo of the Paper component using the `PaperDemos.usage` data. The `Demo` component is likely responsible for displaying the demonstration visually.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/paper.mdx#_snippet_4\n\nLANGUAGE: mdx\nCODE:\n```\n<Demo data={PaperDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Using UseListStateHandlers in Child Components\nDESCRIPTION: This demonstrates how to use the `UseListStateHandlers` type to type the handlers passed to child components as props. This ensures type safety when working with the handlers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { UseListStateHandlers } from '@mantine/hooks';\n\ninterface Props {\n  handlers: UseListStateHandlers<string>;\n}\n\nfunction Demo({ handlers }: Props) {\n  return (\n    <button type=\"button\" onClick={() => handlers.append('hello')}>\n      Append hello\n    </button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Spacing Props for SimpleGrid in TypeScript\nDESCRIPTION: This example shows how to use the `spacing` and `verticalSpacing` props of the SimpleGrid component from Mantine to control the horizontal and vertical gaps between grid columns and rows. If `verticalSpacing` is not specified, `spacing` is used for both directions. The snippet includes two variants: one using a single spacing value for both directions and another specifying different values for vertical and horizontal spacing. It requires React and @mantine/core as dependencies, and expects valid spacing scale values like \"xl\" or \"lg\" as props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/simple-grid.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { SimpleGrid } from '@mantine/core';\n\n// `spacing` is used for both horizontal and vertical spacing\nconst Spacing = () => <SimpleGrid spacing=\"xl\" />;\n\n// `spacing` is used for horizontal spacing, `verticalSpacing` for vertical\nconst VerticalSpacing = () => (\n  <SimpleGrid spacing=\"xl\" verticalSpacing=\"lg\" />\n);\n```\n\n----------------------------------------\n\nTITLE: Applying style modifications through stylesApi\nDESCRIPTION: This snippet employs 'Demos' to showcase how to use styles API to customize the appearance of the TagsInput component, such as colors, borders, or spacing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.stylesApi} />\n```\n\n----------------------------------------\n\nTITLE: Initializing Mantine AngleSlider Component in TypeScript React\nDESCRIPTION: Demonstrates the usage of Mantine's AngleSlider component to render angle selectors with labeled marks. It includes two example sliders with custom label formatting and restrictions on selectable marks. Dependencies include '@mantine/core' for UI components. Key parameters include 'formatLabel' to format slider labels, 'size' to define the slider size, and 'marks' to specify selectable angle values. The input is user interaction with the slider, outputting angle values constrained by marks with proper accessibility labels.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AngleSlider, Group } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Group p=\"lg\" gap={50}>\n      <AngleSlider\n        aria-label=\"Angle slider\"\n        formatLabel={(value) => `${value}\\u00B0`}\n        size={100}\n        restrictToMarks\n        marks=[\n          { value: 0 },\n          { value: 45 },\n          { value: 90 },\n          { value: 135 },\n          { value: 180 },\n          { value: 225 },\n          { value: 270 },\n          { value: 315 },\n        ]\n      />\n\n      <AngleSlider\n        aria-label=\"Angle slider\"\n        formatLabel={(value) => `${value}\\u00B0`}\n        size={100}\n        marks=[\n          { value: 0, label: '0\\u00B0' },\n          { value: 45, label: '45\\u00B0' },\n          { value: 90, label: '90\\u00B0' },\n          { value: 135, label: '135\\u00B0' },\n          { value: 180, label: '180\\u00B0' },\n          { value: 225, label: '225\\u00B0' },\n          { value: 270, label: '270\\u00B0' },\n          { value: 315, label: '315\\u00B0' },\n        ]\n      />\n    </Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring global autoContrast and luminanceThreshold in theme with @mantine/core in TypeScript\nDESCRIPTION: Shows how to enable the global 'autoContrast' setting and adjust the 'luminanceThreshold' in Mantine's theme via createTheme. It programmatically generates buttons with variable color shades to demonstrate dynamic text color switching based on background luminance. Requires @mantine/core and React with TypeScript. Applies theme through MantineProvider and renders a stack of buttons to visualize contrast adjustments.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, createTheme, MantineProvider, Stack } from '@mantine/core';\n\nconst theme = createTheme({\n  autoContrast: true,\n  luminanceThreshold: 0.3,\n});\n\nfunction Wrapper(props: any) {\n  const buttons = Array(10)\n    .fill(0)\n    .map((_, index) => (\n      <Button key={index} color={`blue.${index}`}>\n        Button\n      </Button>\n    ));\n\n  return (\n    <MantineProvider theme={theme}>\n      <Stack>{buttons}</Stack>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating FunnelChart Component with Mantine in TypeScript React\nDESCRIPTION: Shows an example of rendering a FunnelChart component using Mantine charts with an array of country-based data objects including name, value, and color. The component is imported from '@mantine/charts' and rendered with a single 'data' prop. The purpose is to visualize funnel-shaped data trends or distributions. Inputs consist of categorical and numeric data with color coding, and the output is the funnel chart UI.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { FunnelChart } from '@mantine/charts';\n\nconst data = [\n  { name: 'USA', value: 400, color: 'indigo.6' },\n  { name: 'India', value: 300, color: 'yellow.6' },\n  { name: 'Japan', value: 100, color: 'teal.6' },\n  { name: 'Other', value: 200, color: 'gray.6' },\n];\n\nfunction Demo() {\n  return <FunnelChart data={data} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding reference lines behind the chart\nDESCRIPTION: Uses 'referenceLines' prop to add static reference lines at specific positions. These lines are rendered behind all chart elements and help highlight thresholds or targets.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_27\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.referenceLines} />\n```\n\n----------------------------------------\n\nTITLE: Combining useFocusTrap with Other Ref Hooks in React TypeScript\nDESCRIPTION: This snippet shows how to merge the ref returned by useFocusTrap with other ref hooks such as useClickOutside and useMergedRef. The useMergedRef hook combines multiple refs into a single ref callback, enabling multiple behaviors to be attached to the same DOM node. This is essential for integrating focus trapping with outside click detection or other ref based logic.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-trap.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useRef } from 'react';\nimport {\n  useClickOutside,\n  useFocusTrap,\n  useMergedRef,\n} from '@mantine/hooks';\n\nfunction Demo() {\n  const myRef = useRef();\n  const useClickOutsideRef = useClickOutside(() => {});\n  const focusTrapRef = useFocusTrap();\n  const mergedRef = useMergedRef(\n    myRef,\n    useClickOutsideRef,\n    focusTrapRef\n  );\n\n  return <div ref={mergedRef} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Form Validation Errors - Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet details the use of error manipulation methods within a useForm instance, such as reading, setting, and clearing error messages for entire forms or individual fields. No additional dependencies are required. Inputs include error objects or messages and target field paths; output is an updated form.errors state. These utilities are typically used alongside custom validation or UI error feedback handling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\n// get current errors state\nform.errors;\n\n// Set all errors\nform.setErrors({ path: 'Error message', path2: 'Another error' });\n\n// Set error message at specified path\nform.setFieldError('user.lastName', 'No special characters allowed');\n\n// Clears all errors\nform.clearErrors();\n\n// Clears error of field at specified path\nform.clearFieldError('path');\n```\n\n----------------------------------------\n\nTITLE: Mixed Stacked BarChart with Custom stackId in JSX/TypeScript\nDESCRIPTION: Shows how to create a bar chart where individual data series are grouped into different stacks using the `stackId` property within series objects. This allows for multiple stacked groups within a single chart. Depends on BarChartDemos.mixedStack demo data illustrating grouping behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.mixedStack} />\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition for useMergedRef Hook\nDESCRIPTION: This snippet provides the TypeScript type definition for the useMergedRef hook, specifying the generic signature and accepted argument types. The hook takes any number of forwarded refs and returns a function that assigns them to a given node. Key input: variable argument list of React.ForwardedRef<T>. Output: callback function for ref assignment.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-merged-ref.mdx#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\nfunction useMergedRef<T = any>(\n  ...refs: React.ForwardedRef<T>[]\n): (node: T) => void;\n```\n\n----------------------------------------\n\nTITLE: Getting reference to input element with GetElementRef\nDESCRIPTION: This code provides mechanism to access the DOM input element through React refs via 'GetElementRef', facilitating advanced manipulations or focus management within TagsInput.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\n<GetElementRef component=\"TagsInput\" refType=\"input\" />\n```\n\n----------------------------------------\n\nTITLE: Controlling Mantine Loader Size in React\nDESCRIPTION: Illustrates how to set the size of the Mantine Loader component using the 'size' prop. Accepts numbers (treated as pixels converted to rem, e.g., 32 becomes 2rem via the '--loader-size' CSS variable) or valid CSS size values (e.g., '2.5rem', 'xl').\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/loader.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Loader, Group } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Group>\n      <Loader size={32} />       {/* Becomes --loader-size: 2rem */}\n      <Loader size=\"2.5rem\" />\n      <Loader size=\"xl\" />      {/* Uses theme size */}\n    </Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Custom Root Element for Color Scheme Data Attribute (TypeScript)\nDESCRIPTION: Defines a function to return a specific DOM element (like document.body) to attach 'data-mantine-color-scheme', controlling where the color scheme data attribute is set, supporting hydration and SSR scenarios.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nconst getRootElement = () =>\n  typeof window === 'undefined' ? undefined : document.body;\n\nfunction Demo() {\n  return (\n    <MantineProvider getRootElement={getRootElement}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying theme-based colors to lines\nDESCRIPTION: References theme colors or CSS color values for line colors, supporting design consistency and flexibility. Examples include using theme colors like 'blue', 'red.5', or any valid CSS color value.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.color} />\n```\n\n----------------------------------------\n\nTITLE: Correct usage with 'use client' directive for callback functions\nDESCRIPTION: This code shows the proper way to use callback functions as children in Mantine components by including the `'use client'` directive at the top of the file, ensuring client-only execution.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ No error\n'use client';\n\nimport { CopyButton } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <CopyButton value=\"https://mantine.dev\">\n      {({ copied, copy }) => (\n        <button color={copied ? 'teal' : 'blue'} onClick={copy}>\n          {copied ? 'Copied url' : 'Copy url'}\n        </button>\n      )}\n    </CopyButton>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Named Form with useForm - Mantine (TypeScript)\nDESCRIPTION: Demonstrates creating a form using Mantine's useForm hook with a specified name property, which is required for using form actions. The form is typed for strict type safety, and initial values are provided for each field. The 'name' property enables global access and manipulation of form state elsewhere in the application. Dependencies: @mantine/form package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-2-0.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nexport interface DemoFormValues {\n  name: string;\n  age: number;\n}\n\nfunction Demo() {\n  const form = useForm<DemoFormValues>({\n    name: 'demo-form',\n    initialValues: {\n      name: '',\n      age: 0,\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Welcome Component with Custom Utilities (TSX)\nDESCRIPTION: This example test imports the custom render function and other test utilities, then tests that the Welcome component links to the correct Next.js guide. It demonstrates the use of screen.getByText and assertion helpers from Testing Library. Dependencies: Welcome component, MantineProvider setup, custom test-utils. Inputs are UI components, outputs are test assertions. Consistent use of custom utilities ensures all Mantine context is initialized during tests.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vitest.mdx#_snippet_5\n\nLANGUAGE: TSX\nCODE:\n```\nimport { render, screen } from '../test-utils';\nimport { Welcome } from './Welcome';\n\ndescribe('Welcome component', () => {\n  it('has correct Next.js theming section link', () => {\n    render(<Welcome />);\n    expect(screen.getByText('this guide')).toHaveAttribute(\n      'href',\n      'https://mantine.dev/guides/next/'\n    );\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Styling Inputs Based on HTML Element Type\nDESCRIPTION: This informational snippet explains that Mantine inputs derived from `<input />` elements should use the `&:placeholder` CSS selector to modify placeholder colors, whereas inputs based on `<button />` elements should utilize the Styles API for customization. It guides developers on applying correct styling techniques depending on input types.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/inputs-placeholder-color.mdx#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: UseTreeReturnType Interface\nDESCRIPTION: Defines the `UseTreeReturnType` interface. This interface describes the object returned by the `useTree` hook, including methods for managing the tree's state, such as expansion, selection, and checking, as well as derived state properties.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface UseTreeReturnType {\n  /** Determines whether multiple node can be selected at a time */\n  multiple: boolean;\n\n  /** A record of `node.value` and boolean values that represent nodes expanded state */\n  expandedState: TreeExpandedState;\n\n  /** An array of selected nodes values */\n  selectedState: string[];\n\n  /** An array of checked nodes values */\n  checkedState: string[];\n\n  /** A value of the node that was last clicked\n   * Anchor node is used to determine range of selected nodes for multiple selection\n   */\n  anchorNode: string | null;\n\n  /** Initializes tree state based on provided data, called automatically by the Tree component */\n  initialize: (data: TreeNodeData[]) => void;\n\n  /** Toggles expanded state of the node with provided value */\n  toggleExpanded: (value: string) => void;\n\n  /** Collapses node with provided value */\n  collapse: (value: string) => void;\n\n  /** Expands node with provided value */\n  expand: (value: string) => void;\n\n  /** Expands all nodes */\n  expandAllNodes: () => void;\n\n  /** Collapses all nodes */\n  collapseAllNodes: () => void;\n\n  /** Sets expanded state */\n  setExpandedState: React.Dispatch<\n    React.SetStateAction<TreeExpandedState>\n  >;\n\n  /** Toggles selected state of the node with provided value */\n  toggleSelected: (value: string) => void;\n\n  /** Selects node with provided value */\n  select: (value: string) => void;\n\n  /** Deselects node with provided value */\n  deselect: (value: string) => void;\n\n  /** Clears selected state */\n  clearSelected: () => void;\n\n  /** Sets selected state */\n  setSelectedState: React.Dispatch<React.SetStateAction<string[]>>;\n\n  /** A value of the node that is currently hovered */\n  hoveredNode: string | null;\n\n  /** Sets hovered node */\n  setHoveredNode: React.Dispatch<React.SetStateAction<string | null>>;\n\n  /** Checks node with provided value */\n  checkNode: (value: string) => void;\n\n  /** Unchecks node with provided value */\n  uncheckNode: (value: string) => void;\n\n  /** Checks all nodes */\n  checkAllNodes: () => void;\n\n  /** Unchecks all nodes */\n  uncheckAllNodes: () => void;\n\n  /** Sets checked state */\n  setCheckedState: React.Dispatch<React.SetStateAction<string[]>>;\n\n  /** Returns all checked nodes with status */\n  getCheckedNodes: () => CheckedNodeStatus[];\n\n  /** Returns `true` if node with provided value is checked */\n  isNodeChecked: (value: string) => boolean;\n\n  /** Returns `true` if node with provided value is indeterminate */\n  isNodeIndeterminate: (value: string) => boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up ModalsProvider with MantineProvider in TypeScript\nDESCRIPTION: Initializes modal context by wrapping the application with MantineProvider and ModalsProvider components. This setup is required to enable modal functionalities from the @mantine/modals package in a React TypeScript application. No props are passed here, demonstrating basic usage.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/modals.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\nimport { ModalsProvider } from '@mantine/modals';\n\nfunction Demo() {\n  return (\n    <MantineProvider>\n      <ModalsProvider>{/* Your app here */}</ModalsProvider>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Positioning the Mantine Dialog Component using the 'position' prop (TSX)\nDESCRIPTION: This TSX snippet demonstrates how to control the fixed position of a Mantine Dialog component. It utilizes the 'position' prop, which accepts an object with 'top', 'bottom', 'left', or 'right' properties to specify the offset in pixels from the corresponding viewport edge. The example shows two Dialog components: one positioned near the top-left corner (20px from top, 20px from left) and another near the bottom-left corner (20px from bottom, 20px from left). The 'opened' prop is required to make the dialogs visible.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/dialog.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Dialog } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Dialog position={{ top: 20, left: 20 }} opened>\n        Dialog in top left corner\n      </Dialog>\n      <Dialog position={{ bottom: 20, left: 20 }} opened>\n        Dialog in bottom left corner\n      </Dialog>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Vertical Variant and Tabular Numbers in Table Component\nDESCRIPTION: This snippet illustrates how to enable the vertical layout variant and 'tabularNums' prop of the Table component. 'variant=\"vertical\"' offers alternative styling, while 'tabularNums' aligns numeric columns with monospaced digits for better readability.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TableDemos.vertical} />\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TableDemos.tabularNums} />\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mantine Card and Card.Section Layout Margin Behavior in TypeScript\nDESCRIPTION: This snippet shows how to use the Card and Card.Section components from the Mantine core library to layout sections with specific margin rules around the first, middle, and last Card.Section children. It imports Card and Text, uses padding=\"xl\" on Card, and demonstrates the negative margin application on Card.Section depending on its position to create visual spacing effects. This example highlights that non-Card.Section content receives normal padding. Expected inputs are JSX children components; output is visually styled card sections. No fragments or wrappers should be used around Card.Section for correct behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/card.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Card, Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Card padding=\"xl\">\n      {/* top, right, left margins are negative – -1 * theme.spacing.xl */}\n      <Card.Section>First section</Card.Section>\n\n      {/* Content that is not inside Card.Section will have theme.spacing.xl spacing on all sides relative to Card */}\n      <Text>Some other content</Text>\n\n      {/* right, left margins are negative – -1 * theme.spacing.xl */}\n      <Card.Section>Middle section</Card.Section>\n\n      {/* bottom, right, left margins are negative – -1 * theme.spacing.xl */}\n      <Card.Section>Last section</Card.Section>\n    </Card>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Header Components Using npm - Bash\nDESCRIPTION: This snippet provides the npm command to install the @mantinex/mantine-header package. npm should already be set up in your project environment. Running this command downloads and registers the header components in your package.json, making them accessible for use within your codebase.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/mantine-header/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @mantinex/mantine-header\n```\n\n----------------------------------------\n\nTITLE: Configuring Mantine SimpleGrid with Responsive Props (TSX)\nDESCRIPTION: Shows how to use the updated object format for responsive props (`cols`, `spacing`, `verticalSpacing`) in the Mantine SimpleGrid component. This allows defining different grid layouts and spacing based on screen size breakpoints (base, sm, lg). Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\nimport { SimpleGrid } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <SimpleGrid\n      cols={{ base: 1, sm: 2, lg: 5 }}\n      spacing={{ base: 10, sm: 'xl' }}\n      verticalSpacing={{ base: 'md', sm: 'xl' }}\n    >\n      <div>1</div>\n      <div>2</div>\n      <div>3</div>\n      <div>4</div>\n      <div>5</div>\n    </SimpleGrid>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Modal Transitions with Mantine in TypeScript\nDESCRIPTION: Demonstrates the use of Mantine's Modal component with the new onExitTransitionEnd and onClose props to manage and clear modal data after transitions. Dependencies include @mantine/core, @mantine/hooks, and React. Parameters like opened, onClose, and onExitTransitionEnd handle modal visibility and post-transition logic. Input is user interactions via buttons; output is the displayed modal and cleared state. Limitations: expects correct usage of Mantine hooks and clear prop assignment.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_10\n\nLANGUAGE: TypeScript JSX\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Group, Modal } from '@mantine/core';\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const [firstOpened, firstHandlers] = useDisclosure(false);\n  const [secondOpened, secondHandlers] = useDisclosure(false);\n  const [modalData, setModalData] = useState({\n    title: '',\n    message: '',\n  });\n\n  return (\n    <>\n      <Modal\n        opened={firstOpened}\n        onClose={() => {\n          firstHandlers.close();\n          setModalData({ title: '', message: '' });\n        }}\n        title={modalData.title}\n      >\n        {modalData.message}\n      </Modal>\n      <Modal\n        opened={secondOpened}\n        onClose={secondHandlers.close}\n        onExitTransitionEnd={() => setModalData({ title: '', message: '' })}\n        title={modalData.title}\n      >\n        {modalData.message}\n      </Modal>\n\n      <Group>\n        <Button\n          onClick={() => {\n            firstHandlers.open();\n            setModalData({ title: 'Edit your profile', message: 'Imagine a form here' });\n          }}\n        >\n          Clear data in onClose\n        </Button>\n\n        <Button\n          onClick={() => {\n            secondHandlers.open();\n            setModalData({ title: 'Edit your profile', message: 'Imagine a form here' });\n          }}\n        >\n          Clear data in onExitTransitionEnd\n        </Button>\n      </Group>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Documentation Components and Data in React (JavaScript)\nDESCRIPTION: This snippet imports demonstration components, a shared layout, and MDX documentation data required for rendering useInViewport documentation and its demo. Dependencies include the '@docs/demos' package for demo examples, '@/layout' for layout composition, and '@/mdx' for markdown-driven documentation content. The imports must resolve to available modules for successful compilation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-in-viewport.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { HooksDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Demo: DateTimePicker with seconds display\nDESCRIPTION: This example demonstrates configuring the DateTimePicker to include seconds in the displayed time, illustrating customization options for detailed time selection.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DateTimePickerDemos.withSeconds} />\n```\n\n----------------------------------------\n\nTITLE: Disabled MonthPickerInput\nDESCRIPTION: Shows how to render the MonthPickerInput in a disabled state, preventing user interaction with the component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.disabled} />\n```\n\n----------------------------------------\n\nTITLE: Configure Next.js for Sass with Mantine\nDESCRIPTION: Configures Next.js to automatically include the `_mantine.scss` file's content at the beginning of every Sass file using `sassOptions.additionalData`. This provides access to global Sass variables, functions, and mixins defined for Mantine within a Next.js project. Requires `sass`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/sass.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport path from 'node:path';\n\nexport default {\n  // ...other config\n  sassOptions: {\n    implementation: 'sass-embedded',\n    additionalData: `@use \"${path.join(process.cwd(), '_mantine').replace(/\\\\/g, '/')}\" as mantine;`,\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Getting Form Values Type with TypeScript\nDESCRIPTION: Shows how to get the inferred form values type in TypeScript. This is useful for type checking in handleSubmit function or anywhere else in the code.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({ initialValues: { name: '', age: 0 } });\n\n  // Get inferred form values type, will be `{ name: string; age: number }`\n  type FormValues = typeof form.values;\n\n  // Use values type in handleSubmit function or anywhere else\n  const handleSubmit = (values: FormValues) => console.log(values);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying CSS Module Styles in React\nDESCRIPTION: This example demonstrates how to import and apply CSS module styles in a React component.  The CSS module is imported, and its classes are applied to the component using the `className` prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport classes from './Button.module.css';\n\nfunction Demo() {\n  return (\n    <button className={classes.button} type=\"button\">\n      Button\n    </button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the RichTextEditorLabels Interface in TypeScript\nDESCRIPTION: Defines the `RichTextEditorLabels` TypeScript interface, which specifies the structure for the `labels` prop object. It lists all configurable labels for the various controls within the `RichTextEditor`, including formatting buttons, link editor elements, and color picker components. Most labels expect a string, but some, like `colorControlLabel`, require a function that returns a string.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// RichTextEditorLabels type can be imported from @mantine/tiptap package\nexport interface RichTextEditorLabels {\n  /** RichTextEditor.Bold control aria-label */\n  boldControlLabel: string;\n\n  /** RichTextEditor.Hr control aria-label */\n  hrControlLabel: string;\n\n  /** RichTextEditor.Italic control aria-label */\n  italicControlLabel: string;\n\n  /** RichTextEditor.Underline control aria-label */\n  underlineControlLabel: string;\n\n  /** RichTextEditor.Strike control aria-label */\n  strikeControlLabel: string;\n\n  /** RichTextEditor.ClearFormatting control aria-label */\n  clearFormattingControlLabel: string;\n\n  /** RichTextEditor.Link control aria-label */\n  linkControlLabel: string;\n\n  /** RichTextEditor.Unlink control aria-label */\n  unlinkControlLabel: string;\n\n  /** RichTextEditor.BulletList control aria-label */\n  bulletListControlLabel: string;\n\n  /** RichTextEditor.OrderedList control aria-label */\n  orderedListControlLabel: string;\n\n  /** RichTextEditor.H1 control aria-label */\n  h1ControlLabel: string;\n\n  /** RichTextEditor.H2 control aria-label */\n  h2ControlLabel: string;\n\n  /** RichTextEditor.H3 control aria-label */\n  h3ControlLabel: string;\n\n  /** RichTextEditor.H4 control aria-label */\n  h4ControlLabel: string;\n\n  /** RichTextEditor.H5 control aria-label */\n  h5ControlLabel: string;\n\n  /** RichTextEditor.H6 control aria-label */\n  h6ControlLabel: string;\n\n  /** RichTextEditor.Blockquote control aria-label */\n  blockquoteControlLabel: string;\n\n  /** RichTextEditor.AlignLeft control aria-label */\n  alignLeftControlLabel: string;\n\n  /** RichTextEditor.AlignCenter control aria-label */\n  alignCenterControlLabel: string;\n\n  /** RichTextEditor.AlignRight control aria-label */\n  alignRightControlLabel: string;\n\n  /** RichTextEditor.AlignJustify control aria-label */\n  alignJustifyControlLabel: string;\n\n  /** RichTextEditor.Code control aria-label */\n  codeControlLabel: string;\n\n  /** RichTextEditor.CodeBlock control aria-label */\n  codeBlockControlLabel: string;\n\n  /** RichTextEditor.Subscript control aria-label */\n  subscriptControlLabel: string;\n\n  /** RichTextEditor.Superscript control aria-label */\n  superscriptControlLabel: string;\n\n  /** RichTextEditor.ColorPicker control aria-label */\n  colorPickerControlLabel: string;\n\n  /** RichTextEditor.UnsetColor control aria-label */\n  unsetColorControlLabel: string;\n\n  /** RichTextEditor.Highlight control aria-label */\n  highlightControlLabel: string;\n\n  /** RichTextEditor.Undo control aria-label */\n  undoControlLabel: string;\n\n  /** RichTextEditor.Redo control aria-label */\n  redoControlLabel: string;\n\n  /** A function go get RichTextEditor.Color control aria-label based on color that control applies */\n  colorControlLabel: (color: string) => string;\n\n  /** aria-label for link editor url input */\n  linkEditorInputLabel: string;\n\n  /** placeholder for link editor url input */\n  linkEditorInputPlaceholder: string;\n\n  /** Content of external button tooltip in link editor when the link was chosen to open in a new tab */\n  linkEditorExternalLink: string;\n\n  /** Content of external button tooltip in link editor when the link was chosen to open in the same tab */\n  linkEditorInternalLink: string;\n\n  /** Save button content in link editor */\n  linkEditorSave: string;\n\n  /** Cancel button title text in color picker control */\n  colorPickerCancel: string;\n\n  /** Clear button title text in color picker control */\n  colorPickerClear: string;\n\n  /** Color picker button title text in color picker control */\n  colorPickerColorPicker: string;\n\n  /** Palette button title text in color picker control */\n  colorPickerPalette: string;\n\n  /** Save button title text in color picker control */\n  colorPickerSave: string;\n\n  /** aria-label for color palette colors */\n  colorPickerColorLabel: (color: string) => string;\n}\n```\n\n----------------------------------------\n\nTITLE: Making PinInput Accessible with ARIA Labels in React\nDESCRIPTION: Shows how to implement accessibility for PinInput components by adding the aria-label attribute. This ensures screen readers can properly identify the purpose of the input field.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pin-input.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PinInput } from '@mantine/core';\n\nfunction Accessibility() {\n  return <PinInput aria-label=\"One time code\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting the Imported CSS Module Object (TSX)\nDESCRIPTION: Shows how importing a CSS module (`Button.module.css`) in a TypeScript/JavaScript file results in an object (`classes`). This object maps the original class names (keys) to the uniquely generated, scoped class names (values) created by the build tool. The example logs this object to the console.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport classes from './Button.module.css';\n\nconsole.log(classes);\n// -> Object of scoped class names: key is a class name, value is a generated unique class name\n// { button: 'button-Xh3s7ER', text: 'text-js65s3Se' }\n// Note that generated class names may vary depending on your build tool\n```\n\n----------------------------------------\n\nTITLE: Displaying Usage Demo of JsonInput\nDESCRIPTION: This snippet illustrates embedding a demo component showcasing JsonInput's usage, which includes json validation and formatting options triggered on blur. It helps users visualize how to incorporate JsonInput into their interfaces with predefined demos.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={JsonInputDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Changing line style to dashed using series configuration\nDESCRIPTION: Sets 'strokeDasharray' in a specific series to create dashed lines, allowing line style differentiation within the same chart.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_26\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.lineDasharray} />\n```\n\n----------------------------------------\n\nTITLE: Rendering DatePickerInput with Icon Demo in JSX\nDESCRIPTION: Shows how to include an icon inside the DatePickerInput component, enhancing UI clarity and aesthetics by passing the demo data to the generic demo renderer.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_11\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.icon} />\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useToggle Hook in TSX\nDESCRIPTION: Provides the TypeScript function signature for the `useToggle` hook. It shows the generic type parameter `T` (defaulting to `boolean`), the optional `options` argument (a readonly array of `T`), and the returned readonly tuple containing the state value (`T`) and the toggle function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-toggle.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useToggle<T = boolean>(\n  options?: readonly T[]\n): readonly [T, (value?: React.SetStateAction<T>) => void];\n```\n\n----------------------------------------\n\nTITLE: Disabling Font Smoothing in Mantine Theme (TSX)\nDESCRIPTION: Shows how to disable Mantine's default font smoothing behavior (`-webkit-font-smoothing: antialiased` and `-moz-osx-font-smoothing: grayscale`). This is done by setting the `fontSmoothing` property to `false` within the `createTheme` configuration from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\n// Disable font smoothing in your theme\nconst theme = createTheme({\n  fontSmoothing: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Utilizing Container Queries in Mantine Grid – TypeScript/React\nDESCRIPTION: This snippet demonstrates how to apply container queries in the Mantine Grid component, allowing responsive adjustments based on a container's width rather than the viewport. Dependencies include @mantine/core and a React environment. Key parameters include the 'type' prop set to 'container', the 'breakpoints' object for responsive sizing, and usage of 'Grid.Col' for defining grid columns. The wrapper div in the example enables resizable demonstration, though it is not required in production use. Input is a set of layout breakpoints; output is a responsive grid arrangement. Some CSS properties in the wrapper (e.g., resize) are needed only for the demo context.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.13.0.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Grid } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    // Wrapper div is added for demonstration purposes only,\n    // it is not required in real projects\n    <div style={{ resize: 'horizontal', overflow: 'hidden', maxWidth: '100%' }}>\n      <Grid\n        type=\"container\"\n        breakpoints={{ xs: '100px', sm: '200px', md: '300px', lg: '400px', xl: '500px' }}\n      >\n        <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>1</Grid.Col>\n        <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>2</Grid.Col>\n        <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>3</Grid.Col>\n        <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>4</Grid.Col>\n      </Grid>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Percent Normalized BarChart Usage in JSX/TypeScript\nDESCRIPTION: Illustrates a bar chart type `percent` where y-axis values are normalized to 100%, allowing comparison of series proportions rather than absolute values. Utilizes BarChartDemos.percent dataset. Useful for percentage contribution visualizations in comparative data scenarios.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.percent} />\n```\n\n----------------------------------------\n\nTITLE: Adding Grouped Object Options to Mantine NativeSelect (TSX)\nDESCRIPTION: This snippet illustrates how to define grouped options using the data prop with a more complex object structure. Each item in the main array represents a group with a group label and an items array containing option objects (with label, value, and optional disabled).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/native-select.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NativeSelect } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <NativeSelect\n      data={[\n        {\n          group: 'Frontend libraries',\n          items: [\n            { label: 'React', value: 'react' },\n            { label: 'Angular', value: 'angular' },\n            { label: 'Vue', value: 'vue', disabled: true },\n          ],\n        },\n        {\n          group: 'Backend libraries',\n          items: [\n            { label: 'Express', value: 'express' },\n            { label: 'Koa', value: 'koa' },\n            { label: 'Django', value: 'django' },\n          ],\n        },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying error state styles\nDESCRIPTION: This snippet illustrates setting the 'error' prop to true or a message to visually indicate validation errors or issues with the input, usually changing border color or displaying messages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.error} />\n```\n\n----------------------------------------\n\nTITLE: Converting First Character to Lowercase with Mantine Hooks (TSX)\nDESCRIPTION: Shows how to use the `lowerFirst` function from `@mantine/hooks`. It converts the first character of a string to its lowercase equivalent while leaving the rest of the string unchanged. Requires importing `lowerFirst` from the hooks package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/functions-reference.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { lowerFirst } from '@mantine/hooks';\n\nlowerFirst('Mantine'); // mantine\nlowerFirst('mantine'); // mantine\n```\n\n----------------------------------------\n\nTITLE: Displaying Mantine Image with Fallback Source (TSX)\nDESCRIPTION: Illustrates the updated Mantine Image component usage, specifically showing the `fallbackSrc` prop. This prop provides a placeholder image URL to display if the primary `src` is null or fails to load. Note the use of the `h` style prop instead of the removed `height` prop. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Image } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Image\n      radius=\"md\"\n      src={null}\n      h={200}\n      fallbackSrc=\"https://placehold.co/600x400?text=Placeholder\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UseListStateHandlers Type\nDESCRIPTION: This code defines the `UseListStateHandlers` type from the `@mantine/hooks` package. This type is a generic that contains all the handlers provided by the `useListState` hook, allowing for type-safe handling of list state in components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface UseListStateHandlers<T> {\n  setState: React.Dispatch<React.SetStateAction<T[]>>;\n  append: (...items: T[]) => void;\n  prepend: (...items: T[]) => void;\n  insert: (index: number, ...items: T[]) => void;\n  pop: () => void;\n  shift: () => void;\n  apply: (fn: (item: T, index?: number) => T) => void;\n  applyWhere: (\n    condition: (item: T, index: number) => boolean,\n    fn: (item: T, index?: number) => T\n  ) => void;\n  remove: (...indices: number[]) => void;\n  reorder: ({ from, to }: { from: number; to: number }) => void;\n  swap: ({ from, to }: { from: number; to: number }) => void;\n  setItem: (index: number, item: T) => void;\n  setItemProp: <K extends keyof T, U extends T[K]>(index: number, prop: K, value: U) => void;\n  filter: (fn: (item: T, i: number) => boolean) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: clampUseMovePosition Function Usage\nDESCRIPTION: Illustrates how to use the clampUseMovePosition function to ensure that x and y values stay within the 0-1 range. This is useful when external events influence the value, and you need to keep it constrained.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-move.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { clampUseMovePosition } from '@mantine/hooks';\n\nclampUseMovePosition({ x: 0.5, y: 0.5 }); // -> { x: 0.5, y: 0.5 }\nclampUseMovePosition({ x: 1.5, y: 0.5 }); // -> { x: 1, y: 0.5 }\nclampUseMovePosition({ x: -0.5, y: 0.5 }); // -> { x: 0, y: 0.5 }\n```\n\n----------------------------------------\n\nTITLE: Using CSS Layers in Mantine with TypeScript\nDESCRIPTION: Demonstrates importing Mantine styles with CSS layers using TypeScript. Ensures styles are grouped and applied with proper layering, allowing style overrides without import order concerns.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// If your styles are not wrapped in @layer directive,\n// they will be applied after Mantine styles.\n// Import order does not affect styles in this case\nimport classes from './Demo.module.css';\nimport '@mantine/core/styles.layer.css';\n```\n\n----------------------------------------\n\nTITLE: Setting textWrap CSS Property on Mantine Title Component in TypeScript/React\nDESCRIPTION: This snippet demonstrates how to apply the CSS text-wrap property via the new textWrap prop on the Mantine Title component, both locally and through theme configuration. It shows the creation of a custom theme with createTheme and application of the updated theme with MantineProvider. The textWrap prop controls text wrapping behaviors for titles and headings using either string values like 'wrap' or other valid CSS text-wrap options. Requires @mantine/core and React.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-5-0.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider, Title } from '@mantine/core';\n\nconst theme = createTheme({\n  headings: {\n    textWrap: 'wrap',\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Title>Some very long title that should wrap</Title>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: ActionIcon Accessibility Demo\nDESCRIPTION: This example illustrates how to make `ActionIcon` accessible using either the `aria-label` attribute or the `VisuallyHidden` component.  It showcases two ways to provide descriptive labels for screen readers, enhancing accessibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/action-icon.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { IconHeart } from '@tabler/icons-react';\nimport { ActionIcon, VisuallyHidden } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <ActionIcon aria-label=\"Like post\">\n        <IconHeart />\n      </ActionIcon>\n\n      <ActionIcon>\n        <VisuallyHidden>Like post</VisuallyHidden>\n        <IconHeart />\n      </ActionIcon>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using SVG Patterns as Bar Fill in BarChart, JSX/TypeScript\nDESCRIPTION: Shows how to apply SVG pattern fills (e.g., diagonal stripes, crosshatch) to bars by setting the `fill` property in the series objects to SVG pattern URLs defined in the chart's `defs` children. Dependent on BarChartDemos.stripes for pattern demonstration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_6\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.stripes} />\n```\n\n----------------------------------------\n\nTITLE: Rendering Disabled State Demo for DatePickerInput in JSX\nDESCRIPTION: Renders examples showing how the DatePickerInput behaves when disabled. This is crucial for accessibility and UI interaction handling in form contexts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_9\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.disabled} />\n```\n\n----------------------------------------\n\nTITLE: Using useComputedColorScheme hook for consistent color scheme toggling in React (TypeScript)\nDESCRIPTION: This snippet illustrates how to utilize the `useComputedColorScheme` hook along with `useMantineColorScheme` to implement toggle logic that is reliable even when the color scheme is set to 'auto'. It highlights the importance of computed color scheme for correct toggling. Dependencies include '@mantine/core'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// -> colorScheme is 'auto' | 'light' | 'dark'\n  const { colorScheme, setColorScheme } = useMantineColorScheme();\n\n// -> computedColorScheme is 'light' | 'dark', argument is the default value\n  const computedColorScheme = useComputedColorScheme('light');\n\n// Incorrect toggle when colorScheme is 'auto'\n  const toggleColorScheme = () => {\n    setColorScheme(colorScheme === 'dark' ? 'light' : 'dark');\n  };\n\n// Correct toggle using computedColorScheme\n  const toggleColorScheme = () => {\n    setColorScheme(computedColorScheme === 'dark' ? 'light' : 'dark');\n  };\n```\n\n----------------------------------------\n\nTITLE: Splitting input values into multiple tags with splitChars\nDESCRIPTION: This code demonstrates custom splitting of input string into multiple tags using specified characters such as comma, pipe, and space via the 'splitChars' prop. It also handles splitting pasted text accordingly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.splitChars} />\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Styles with CSS Layers in React TypeScript\nDESCRIPTION: This snippet demonstrates how to import Mantine component styles bundled as CSS layers in a React TypeScript project. The '@mantine/core/styles.layer.css' file groups Mantine CSS rules inside the 'mantine' CSS layer to allow style precedence control. Users must not import both the normal 'styles.css' and 'styles.layer.css' files as they are mutually exclusive. No special configuration is required other than updating the import statements. The 'classes' import references local CSS module styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-1-0.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// If your styles are not wrapped in @layer directive,\n// they will be applied after Mantine styles.\n// Import order does not affect styles in this case\nimport classes from './Demo.module.css';\n\nimport '@mantine/core/styles.layer.css';\n```\n\n----------------------------------------\n\nTITLE: Enabling Tree Shaking with Next.js App Router\nDESCRIPTION: Configures experimental Next.js feature 'optimizePackageImports' in next.config.mjs to optimize imports and support tree shaking for Mantine components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default {\n  // ...other configuration\n  experimental: {\n    optimizePackageImports: ['@mantine/core', '@mantine/hooks'],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Example of passing callback function as children without 'use client' directive\nDESCRIPTION: This snippet demonstrates an error scenario where a callback function is passed as children to a Mantine `CopyButton` component in a server component, which is invalid. It highlights the need to add `'use client'` for such cases.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ❌ This will throw an error\nimport { CopyButton } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <CopyButton value=\"https://mantine.dev\">\n      {({ copied, copy }) => (\n        <button color={copied ? 'teal' : 'blue'} onClick={copy}>\n          {copied ? 'Copied url' : 'Copy url'}\n        </button>\n      )}\n    </CopyButton>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Emotion SX Prop in Next.js Pages\nDESCRIPTION: This snippet shows how to use the `sx` prop with the `Box` component from `@mantine/core` in a Next.js pages router project to apply custom styles using Emotion. The `sx` prop takes a function to receive the theme and breakpoint utilities, allowing for dynamic styling based on the theme and conditions. It shows using the theme colors and light/dark mode support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      sx={(theme, u) => ({\n        padding: 40,\n\n        [u.light]: {\n          backgroundColor: theme.colors.blue[0],\n          color: theme.colors.blue[9],\n\n          '&:hover': {\n            backgroundColor: theme.colors.blue[1],\n          },\n        },\n      })}\n    >\n      Box with emotion sx prop\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Default Export Rendering Layout with MDX Content (JavaScript)\nDESCRIPTION: Defines the default export by wrapping MDX data representing the fieldset within a layout component. This renders the MDX content appropriately within the layout, facilitating visual demonstration of the component's usage and features.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/fieldset.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.Fieldset);\n```\n\n----------------------------------------\n\nTITLE: Updating Modals Dynamically with modals.updateModal\nDESCRIPTION: This code showcases the 'updateModal' and 'updateContextModal' functions from the modals manager API, enabling dynamic updates to modal content or configurations after the modal has been rendered and opened.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={ModalsDemos.updateModal} />\n```\n\n----------------------------------------\n\nTITLE: Creating a Shared Theme Object in src/theme.ts for Mantine and Storybook\nDESCRIPTION: The snippet demonstrates defining a theme object using Mantine's createTheme function. This shared theme allows consistent styling across the application and Storybook environment by importing and using the same theme in MantineProvider components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/storybook.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/theme.ts\nimport { createTheme } from '@mantine/core';\n\nexport const theme = createTheme({\n  fontFamily: 'serif',\n  // ... other theme override properties\n});\n```\n\n----------------------------------------\n\nTITLE: Merging Custom Font Sizes with Default Theme\nDESCRIPTION: Illustrates how to change a single font size while inheriting other sizes from the default Mantine theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  fontSizes: {\n    xs: '0.5rem',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Restricting Slider Value Selection to Marks in Mantine Slider Component Using TypeScript React\nDESCRIPTION: Demonstrates the Slider component with the 'restrictToMarks' prop to confine slider values strictly to predefined marks, ignoring the step increment. The example creates marks at intervals generated dynamically. It imports Slider from '@mantine/core'. Inputs are the marks array and a default value; output is a slider UI that only allows values at mark positions, enhancing precise user input.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Slider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Slider\n      restrictToMarks\n      defaultValue={25}\n      marks={Array.from({ length: 5 }).map((_, index) => ({ value: index * 25 }))}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useShallowEffect with Various Dependency Types in React\nDESCRIPTION: Shows how `useShallowEffect` handles different types of dependencies including primitives, arrays of primitives, objects of primitives, and arrays of objects. It illustrates which dependency changes will trigger the effect based on shallow equality rules.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-shallow-effect.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useShallowEffect } from '@mantine/hooks';\n\n// Primitive values are handled like in useEffect\nuseShallowEffect(() => {}, [1, 2, 3]);\n\n// Arrays with primitive values will not trigger callback\nuseShallowEffect(() => {}, [[1], [2], [3]]);\n\n// Objects with primitive values will not trigger callback\nuseShallowEffect(() => {}, [{ a: 1 }, { b: 2 }]);\n\n// Arrays with objects will trigger callback since values are not shallow equal\nuseShallowEffect(() => {}, [[{ a: 1 }], [{ b: 2 }]]);\n```\n\n----------------------------------------\n\nTITLE: Using DEFAULT_THEME for system fonts fallback in theme\nDESCRIPTION: Shows how to reference the DEFAULT_THEME to set font family with system font fallback, ensuring consistent styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, DEFAULT_THEME } from '@mantine/core';\n\nconst theme = createTheme({\n  fontFamily: `Roboto, ${DEFAULT_THEME.fontFamily}`,\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Input Size with data-size Attribute in Mantine (TSX)\nDESCRIPTION: Shows how to extend the Mantine `Input` component within a custom theme to apply CSS classes based on the `size` prop. It then demonstrates using these custom sizes (`xxl`, `xxs`) on `Input` components within a `MantineProvider`. Requires `@mantine/core` and corresponding CSS/SCSS definitions in `./Demo.module.css`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, Input, MantineProvider } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    Input: Input.extend({ classNames: classes }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Input placeholder=\"Size XXL\" size=\"xxl\" />\n      <Input placeholder=\"Size XXS\" size=\"xxs\" mt=\"md\" />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: ActionIcon Example with Incorrect Elements\nDESCRIPTION: This code demonstrates how to structure `ActionIcon.Group` component and indicates a common mistake, by wrapping `ActionIcon` components with additional `div` elements.  It serves to highlight correct and incorrect usage within the `ActionIcon.Group`, showing how such mistakes can affect the component's rendering and behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/action-icon.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ActionIcon } from '@mantine/core';\n\n// Will not work correctly\nfunction Demo() {\n  return (\n    <ActionIcon.Group>\n      <div>\n        <ActionIcon>This will not work</ActionIcon>\n      </div>\n      <ActionIcon>ActionIcons will have incorrect borders</ActionIcon>\n    </ActionIcon.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Package with NPM (Bash)\nDESCRIPTION: This shell command shows how to install the package (represented by the `{{package}}` placeholder) using the Node Package Manager (NPM). It adds the package as a dependency to the project's `package.json` file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/scripts/plop/templates/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# With npm\nnpm install {{package}}\n```\n\n----------------------------------------\n\nTITLE: Generating Random ID with Mantine Hooks (TSX)\nDESCRIPTION: Demonstrates the `randomId` function from `@mantine/hooks`. This utility generates a random string, typically prefixed with `mantine-`, useful for creating unique identifiers in applications. Requires importing `randomId` from the hooks package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/functions-reference.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { randomId } from '@mantine/hooks';\n\nrandomId(); // mantine-d7h137oav\nrandomId(); // mantine-1q2j3j4j5\n```\n\n----------------------------------------\n\nTITLE: Conditional Portal rendering using OptionalPortal in React with TypeScript\nDESCRIPTION: Demonstrates using the OptionalPortal component to conditionally render children inside a Portal based on the `withinPortal` boolean prop. This component accepts the same props as Portal and allows flexible conditional rendering patterns. Dependencies are React and @mantine/core. Inputs are children and withinPortal boolean, output is children rendered inside or outside of Portal accordingly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/portal.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { OptionalPortal } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <OptionalPortal withinPortal>\n        This text is rendered in Portal\n      </OptionalPortal>\n      <OptionalPortal withinPortal={false}>\n        This text is rendered as regular child\n      </OptionalPortal>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting Mantine Template Metadata and Layout - JavaScript\nDESCRIPTION: This snippet defines a metadata object containing details such as title, description, slug, category, tags, and timestamps for the documentation page. It then exports the Layout component with the provided metadata as the default export. The snippet depends on the '@/layout' module for the Layout function/component. The 'meta' object fields are static and should be updated manually as needed; there are no runtime parameters. The Layout component expects the metadata object as its input and outputs the rendered documentation layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/templates-usage.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'How to use Mantine template on GitHub?',\n  description: 'Learn how to create a new repository based on Mantine template',\n  slug: 'templates-usage',\n  category: 'about',\n  tags: ['templates', 'getting started', 'github'],\n  created_at: 'November 15, 2024',\n  last_updated_at: 'November 15, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Setting Submitting State Manually\nDESCRIPTION: This snippet shows how to manually set and check the `form.submitting` state.  `form.submitting` can be set to `true` or `false` using `form.setSubmitting()`. The code depends on `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/status.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({ mode: 'uncontrolled' });\nform.submitting; // -> false\n\nform.setSubmitting(true);\nform.submitting; // -> true\n\nform.setSubmitting(false);\nform.submitting; // -> false\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing Z-Index - Mantine - CSS\nDESCRIPTION: Shows how to use the predefined `--mantine-z-index-*` CSS variables in plain CSS stylesheets to manage element stacking context. This example demonstrates calculating a z-index value relative to `--mantine-z-index-modal` to ensure content appears above it.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_23\n\nLANGUAGE: CSS\nCODE:\n```\n/* Display content above the modal */\n.my-content {\n  z-index: calc(var(--mantine-z-index-modal) + 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Using autoContrast property for text color adjustments in Buttons with @mantine/core in TypeScript\nDESCRIPTION: Illustrates how to toggle the 'autoContrast' prop on Button components to automatically adjust text color based on the button background color for better readability in a Mantine React app. Displays groups of buttons with autoContrast enabled and disabled, showing visual differences. No explicit dependencies beyond @mantine/core and React with TypeScript. This property works with 'filled' variant buttons and is intended to improve accessibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Code, Group } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Code>autoContrast: true</Code>\n      <Group mt=\"xs\" mb=\"lg\">\n        <Button color=\"lime.4\" autoContrast>\n          Lime.4 button\n        </Button>\n        <Button color=\"blue.2\" autoContrast>\n          Blue.2 button\n        </Button>\n        <Button color=\"orange.3\" autoContrast>\n          Orange.3 button\n        </Button>\n      </Group>\n\n      <Code>autoContrast: false</Code>\n      <Group mt=\"xs\">\n        <Button color=\"lime.4\">Lime.4 button</Button>\n        <Button color=\"blue.2\">Blue.2 button</Button>\n        <Button color=\"orange.3\">Orange.3 button</Button>\n      </Group>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: useScrollSpy Hook Type Definitions\nDESCRIPTION: This code defines the interfaces and types used by the `useScrollSpy` hook.  It defines `UseScrollSpyHeadingData`, `UseScrollSpyOptions`, and `UseScrollSpyReturnType`. These are exported from the `@mantine/hooks` package.  The parameters of `useScrollSpy` are  `selector`, `getDepth`, and `getValue` and returns the index, data, initialized status, and a function to reinitialize the hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-scroll-spy.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ninterface UseScrollSpyHeadingData {\n  /** Heading depth, 1-6 */\n  depth: number;\n\n  /** Heading text content value */\n  value: string;\n\n  /** Heading id */\n  id: string;\n\n  /** Function to get heading node */\n  getNode: () => HTMLElement;\n}\n\ninterface UseScrollSpyOptions {\n  /** Selector to get headings, `'h1, h2, h3, h4, h5, h6'` by default */\n  selector?: string;\n\n  /** A function to retrieve depth of heading, by default depth is calculated based on tag name */\n  getDepth?: (element: HTMLElement) => number;\n\n  /** A function to retrieve heading value, by default `element.textContent` is used */\n  getValue?: (element: HTMLElement) => string;\n}\n\ninterface UseScrollSpyReturnType {\n  /** Index of the active heading in the `data` array */\n  active: number;\n\n  /** Headings data. If not initialize, data is represented by an empty array. */\n  data: UseScrollSpyHeadingData[];\n\n  /** True if headings value have been retrieved from the DOM. */\n  initialized: boolean;\n\n  /** Function to update headings values after the parent component has mounted. */\n  reinitialize: () => void;\n}\n\nfunction useScrollSpy({ selector, getDepth, getValue, }?: UseScrollSpyOptions): UseScrollSpyReturnType\n```\n\n----------------------------------------\n\nTITLE: Controlled AngleSlider with React's useState hook\nDESCRIPTION: Shows how to implement a controlled AngleSlider component using React's useState hook, enabling manual control over the slider's value and handling changes via the onChange prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/angle-slider.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { AngleSlider } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState(180);\n  return <AngleSlider value={value} onChange={setValue} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using renderRoot Prop for Polymorphic Button (TSX)\nDESCRIPTION: Demonstrates using the `renderRoot` prop on a Mantine `Button` component to render it as an anchor (`<a>`) tag. This prop accepts a function returning a React element, requiring the spread of `props` onto the returned element for styles and accessibility. It serves as an alternative to the `component` prop, especially useful for generic components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      renderRoot={(props) => (\n        <a href=\"https://mantine.dev/\" target=\"_blank\" {...props} />\n      )}\n    >\n      Mantine website\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Minimal Next.js layout component using MantineProvider and ColorSchemeScript\nDESCRIPTION: Provides a basic layout component for Next.js applications with Mantine, integrating 'ColorSchemeScript' and 'MantineProvider' to manage color schemes and theme context for client-side hydration. Essential for ensuring consistent theme rendering across server and client.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// app/layout.tsx\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nexport default function RootLayout({ children }: { children: any }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <ColorSchemeScript />\n        <link rel=\"shortcut icon\" href=\"/favicon.svg\" />\n        <meta\n          name=\"viewport\"\n          content=\"minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no\"\n        />\n      </head>\n      <body>\n        <MantineProvider>{children}</MantineProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Meta Configuration and Layout Import for Mantine Documentation - JavaScript\nDESCRIPTION: This snippet imports the Layout component and exports a meta object containing metadata information such as title, description, slug, category, tags, and timestamps for a Mantine documentation page. It then exports the default Layout component initialized with the meta info, which likely integrates page metadata for rendering the documentation layout. This snippet has no external dependencies beyond the Layout import and serves as configuration and layout setup for the documentation page content.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/native-required.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'Native browser validation does not work in some components, what should I do?',\n  description: 'Learn why native browser validation does not work in some components',\n  slug: 'native-required',\n  category: 'components',\n  tags: ['select', 'multi-select', 'autocomplete', 'tags-input', 'datepicker', 'required'],\n  created_at: 'December 7, 2024',\n  last_updated_at: 'December 7, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering JsonInput with Layout and MDX Data\nDESCRIPTION: This snippet shows how to import necessary components and render the JsonInput component within a layout, passing MDX data as content. It establishes the basic usage context of the JsonInput component within a Mantine project, utilizing layout and documentation data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { JsonInputDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.JsonInput);\n```\n\n----------------------------------------\n\nTITLE: Applying a Function Conditionally to List Items with useListState\nDESCRIPTION: The `applyWhere` handler applies a function to elements of the list that satisfy a given condition. It accepts a condition function and an update function.  The condition is met if a is greater than 0, then a is incremented by 2.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// apply function to each element that matches condition\nconst applyWhere = () =>\n  handlers.applyWhere(\n    (item) => item.a > 0,\n    (item) => ({ a: item.a + 2 })\n  );\n// values -> [{ a: 7 }, { a: 0 }, { a: 6 }]\n```\n\n----------------------------------------\n\nTITLE: Enhancing BarChart with Dynamic Color Based on Data Values\nDESCRIPTION: This snippet showcases the use of the 'getBarColor' prop in BarChart component, which enables assigning colors to bars dynamically based on their value and series information. The function enhances visual differentiation in charts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={BarChartDemos.getBarColor} />\n```\n\n----------------------------------------\n\nTITLE: Exporting HoverCard Page Layout (TypeScript)\nDESCRIPTION: Exports the default page component, applying the standard `Layout` wrapper to the specific HoverCard content defined in `MDX_DATA.HoverCard`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/hover-card.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default Layout(MDX_DATA.HoverCard);\n```\n\n----------------------------------------\n\nTITLE: Enabling REM Unit Scaling in Mantine Theme (TSX)\nDESCRIPTION: Creates a Mantine theme with the `scale` property set to `1.6`. This value compensates for a base `font-size` of `10px` (default is `16px`, 16/10 = 1.6), ensuring Mantine components using `rem` units maintain their intended visual size relative to the new base. Requires `@mantine/core` and a corresponding CSS rule setting the root font-size.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  scale: 1.6,\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <App />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Props to Inner Recharts Bar Component in Mantine (TSX)\nDESCRIPTION: Illustrates how to pass props down to the underlying Recharts `Bar` component within a Mantine `BarChart` using the `barProps` prop. In this example, `barProps` is used to set the `radius` of the bars. Similar props (`areaProps`, `lineProps`) exist for `AreaChart` and `LineChart` respectively, allowing customization of the inner chart elements. Requires the `@mantine/charts` package. The prop accepts either an object or a function receiving series data and returning an object.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.6.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={200}\n      data={data}\n      dataKey=\"month\"\n      orientation=\"vertical\"\n      yAxisProps={{ width: 80 }}\n      barProps={{ radius: 10 }}\n      series={[{ name: 'Smartphones', color: 'blue.6' }]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Theme Components for Global Styles (TypeScript)\nDESCRIPTION: This snippet showcases how to globally control the style and classes of Mantine components by extending their configuration within the createTheme function. Required dependencies: @mantine/core. It demonstrates the inclusion of classNames and styles in the theme, which are subsequently applied project-wide via MantineProvider; expected input includes valid selectors and corresponding class/style values for the component override configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-api.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst theme = createTheme({\n  components: {\n    Button: Button.extend({\n      classNames: {\n        root: 'my-root-class',\n        label: 'my-label-class',\n        inner: 'my-inner-class',\n      },\n      styles: {\n        root: { backgroundColor: 'red' },\n        label: { color: 'blue' },\n        inner: { fontSize: 20 },\n      },\n    }),\n  },\n});\n\nfunction ProviderDemo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Button>Button</Button>\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using MantineTheme Type for Theme Access\nDESCRIPTION: Shows how to use the MantineTheme type for functions that need access to the theme object, using the useMantineTheme hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineTheme, useMantineTheme } from '@mantine/core';\n\nfunction getPrimaryColor(theme: MantineTheme) {\n  return theme.colors.blue[5];\n}\n\nfunction Demo() {\n  const theme = useMantineTheme();\n  return <div style={{ color: getPrimaryColor(theme) }} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Meta Data Definition for Documenting Stylelint Setup\nDESCRIPTION: Defines metadata for the documentation page, including title, description, category, tags, and timestamps used for organizing or referencing the guide.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\"title\": \"string\", \"description\": \"string\", \"slug\": \"string\", \"category\": \"string\", \"tags\": [\"string\"], \"created_at\": \"string\", \"last_updated_at\": \"string\"}\n```\n\n----------------------------------------\n\nTITLE: Setting the State of a List with useListState\nDESCRIPTION: The `setState` handler sets the entire state of the list to a new array. It replaces the existing list with the provided array. The example sets the state to a new array containing two objects with `a` properties.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n// set entirely new state\nconst setState = () => handlers.setState([{ a: 6 }, { a: 7 }]);\n// values -> [{ a: 6 }, { a: 7 }]\n```\n\n----------------------------------------\n\nTITLE: Implementing RTL Styles in Vanilla Extract (TypeScript)\nDESCRIPTION: Demonstrates how to apply styles specifically for right-to-left (RTL) layouts using the `vars.rtlSelector`. This selector is used within the `selectors` property of the `style` function to override or add styles when the application's direction is RTL.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// Demo.css.ts\nimport { style } from '@vanilla-extract/css';\nimport { vars } from './theme';\n\nexport const demo = style({\n  paddingRight: vars.spacing.md,\n\n  selectors: {\n    [vars.rtlSelector]: {\n      paddingLeft: vars.spacing.md,\n      paddingRight: 0,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Color Manipulation Using alpha, lighten, and darken Functions - SCSS\nDESCRIPTION: Demonstrates advanced CSS color manipulation with `alpha`, `lighten`, and `darken` functions that leverage the CSS `color-mix` feature. The `alpha` function adds transparency to colors, while `lighten` and `darken` mix in white or black colors respectively. The example shows input using these functions and their output transforming to compatible `color-mix` syntax with proper color percentages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_4\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  color: alpha(var(--mantine-color-red-4), 0.5);\n  border: 1px solid alpha(#ffc, 0.2);\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  color: color-mix(\n    in srgb,\n    var(--mantine-color-red-4),\n    transparent 50%\n  );\n  border: 1px solid color-mix(in srgb, #ffc, transparent 80%);\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  color: lighten(var(--mantine-color-red-4), 0.5);\n  border: 1px solid darken(#ffc, 0.2);\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  color: color-mix(in srgb, var(--mantine-color-red-4), white 50%);\n  border: 1px solid color-mix(in srgb, #ffc, black 20%);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Week Numbers in Mantine DatePicker with TypeScript\nDESCRIPTION: Shows how to enable week numbers in the DatePicker component by using the withWeekNumbers prop. Requires @mantine/dates package. No input parameters are required; outputs a DatePicker UI with week numbers shown. Works as a plug-and-play enhancement with no significant constraints except requiring Mantine v6+.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_11\n\nLANGUAGE: TypeScript JSX\nCODE:\n```\nimport { DatePicker } from '@mantine/dates';\n\nfunction Demo() {\n  return <DatePicker withWeekNumbers />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the AngleSlider component in React\nDESCRIPTION: Demonstrates the basic usage of the AngleSlider component to select an angle between 0 and 360 degrees, incorporating the component within a demo layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/angle-slider.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={AngleSliderDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Style array to merge Mantine styles\nDESCRIPTION: Explains how to use an array of style objects and/or functions to merge multiple styles into a single style object for a Mantine Box component. Requires the `@mantine/core` package. This approach is useful for creating wrappers around Mantine components while preserving the ability to override styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Box, MantineStyleProp } from '@mantine/core';\n\ninterface DemoProps {\n  style?: MantineStyleProp;\n}\n\nfunction Demo({ style }: DemoProps) {\n  return <Box style={[{ color: 'red' }, style]} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Mantine Notifications at Various Positions (TSX)\nDESCRIPTION: Demonstrates how to use the `@mantine/notifications` package to display notifications at different positions on the screen ('top-left', 'top-right', 'bottom-left', 'bottom-right', 'top-center', 'bottom-center'). It maps through an array of positions, creating a Button for each that triggers a notification at the specified position using `notifications.show`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.12.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Group } from '@mantine/core';\nimport { notifications } from '@mantine/notifications';\n\nconst positions = [\n  'top-left',\n  'top-right',\n  'bottom-left',\n  'bottom-right',\n  'top-center',\n  'bottom-center',\n] as const;\n\nfunction Demo() {\n  const buttons = positions.map((position) => (\n    <Button\n      key={position}\n      onClick={() =>\n        notifications.show({\n          title: `Notification at ${position}`,\n          message: `Notification at ${position} message`,\n          position,\n        })\n      }\n    >\n      {position}\n    </Button>\n  ));\n\n  return <Group>{buttons}</Group>;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Point Labels in LineChart – TypeScript/React\nDESCRIPTION: This snippet shows how to enable point labels in a LineChart from @mantine/charts using the 'withPointLabels' prop. Requires @mantine/charts, configuration of a data array, and React environment. Key properties are 'series' (to define individual line series and their colors), 'h' (height), and 'withLegend' (to enable chart legend). Expects a data structure with at least the axis and series values. The result is a line chart with visible labels on each data point.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.13.0.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { LineChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <LineChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      withLegend\n      withPointLabels\n      series=[\n        { name: 'Apples', color: 'indigo.6' },\n        { name: 'Oranges', color: 'blue.6' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Menu Item with Mantine Core in React\nDESCRIPTION: This code snippet demonstrates how to use a custom component as a Menu.Item in Mantine Core. It highlights the importance of using forwardRef to ensure that props are correctly passed to the underlying element and that the component works correctly with the Menu.Item.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/menu.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Menu } from '@mantine/core';\n\n// ❌ Will not work with Menu.Item\nfunction IncorrectItem() {\n  return <button type=\"button\">My custom Menu item</button>;\n}\n\n// ✅ Will work correctly with Menu.Item\nconst CorrectItem = forwardRef<\n  HTMLButtonElement,\n  React.ComponentPropsWithoutRef<'button'>\n>((props, ref) => (\n  <button type=\"button\" {...props} ref={ref}>\n    My custom Menu item\n  </button>\n));\n\nfunction Demo() {\n  // ❌ Will not work\n  const incorrect = <Menu.Item component={IncorrectItem} />;\n\n  // ✅ Will work\n  const correct = <Menu.Item component={CorrectItem} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ActionIcon Group Sections - Mantine Core with React TypeScript\nDESCRIPTION: Illustrates the use of ActionIcon.GroupSection component inside ActionIcon.Group to create grouped button sections in Mantine. Uses the useCounter hook from @mantine/hooks and icons from @tabler/icons-react. The GroupSection component allows adding non-ActionIcon content, such as numeric displays, enhancing button grouping flexibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nimport { IconChevronDown, IconChevronUp } from '@tabler/icons-react';\nimport { ActionIcon } from '@mantine/core';\nimport { useCounter } from '@mantine/hooks';\n\nfunction Demo() {\n  const [value, { increment, decrement }] = useCounter(135, { min: 0 });\n\n  return (\n    <ActionIcon.Group>\n      <ActionIcon variant=\"default\" size=\"lg\" radius=\"md\" onClick={decrement}>\n        <IconChevronDown color=\"var(--mantine-color-red-text)\" />\n      </ActionIcon>\n      <ActionIcon.GroupSection variant=\"default\" size=\"lg\" bg=\"var(--mantine-color-body)\" miw={60}>\n        {value}\n      </ActionIcon.GroupSection>\n      <ActionIcon variant=\"default\" size=\"lg\" radius=\"md\" onClick={increment}>\n        <IconChevronUp color=\"var(--mantine-color-teal-text)\" />\n      </ActionIcon>\n    </ActionIcon.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Throttled Callback Handlers with Mantine and useThrottledCallback (TSX)\nDESCRIPTION: Illustrates using useThrottledCallback from @mantine/hooks to throttle callback invocations in an input handler. The demonstration sets up a TextInput and displays the latest throttled value, ensuring the setter is called at most once per 1000ms regardless of user typing speed. Necessary dependencies are @mantine/core, @mantine/hooks, and React. No asynchronous work or side effects beyond state mutation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Text, TextInput } from '@mantine/core';\nimport { useThrottledCallback } from '@mantine/hooks';\n\nfunction Demo() {\n  const [throttledValue, setValue] = useState('');\n  const throttledSetValue = useThrottledCallback((value) => setValue(value), 1000);\n\n  return (\n    <>\n      <TextInput\n        placeholder=\"Search\"\n        onChange={(event) => throttledSetValue(event.currentTarget.value)}\n      />\n      <Text>Throttled value: {throttledValue || '–'}</Text>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useMutationObserver Hook in React with Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates how to utilize the useMutationObserver hook from @mantine/hooks within a functional React component to monitor changes in the 'dir' attribute of the document’s root element. It requires React, Mantine core, and Mantine hooks libraries to be installed. The callback observes attribute changes and updates local state, while the component UI presents directions for users and displays the current direction detected. Expected input is DOM mutations, and the output is an updated state reflecting the 'dir' attribute value. Limitations include dependence on browser MutationObserver support and assumes the container is a browser environment with proper DOM element access.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.7.0.md#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useState } from 'react';\nimport { Kbd, Text } from '@mantine/core';\nimport { useMutationObserver } from '@mantine/hooks';\n\nfunction Demo() {\n  const [lastMutation, setLastMutation] = useState('');\n\n  useMutationObserver(\n    (mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'dir') {\n          mutation.target instanceof HTMLElement &&\n            setLastMutation(mutation.target.getAttribute('dir') || '');\n        }\n      });\n    },\n    {\n      attributes: true,\n      attributeFilter: ['dir'],\n    },\n    () => document.documentElement\n  );\n\n  return (\n    <>\n      <Text>\n        Press <Kbd>Ctrl</Kbd> + <Kbd>Shift</Kbd> + <Kbd>L</Kbd> to change direction\n      </Text>\n\n      <Text mt={10}>Direction was changed to: {lastMutation || 'Not changed yet'}</Text>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Button and Input Components with Mantine withProps Static Function in TypeScript\nDESCRIPTION: Demonstrates how to use Mantine's withProps static function to create prefixed component wrappers with default props set for Button and InputBase components in a React and TypeScript project. This snippet shows setting additional static props such as HTML attributes and external input mask integration for input formatting. It includes a functional React component illustrating default props usage and overriding behavior. Dependencies include '@mantine/core' and 'react-imask'. Inputs are JSX props for components, outputs are rendered button and masked input elements with defined defaults.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-11-0.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IMaskInput } from 'react-imask';\nimport { Button, InputBase } from '@mantine/core';\n\nconst LinkButton = Button.withProps({\n  component: 'a',\n  target: '_blank',\n  rel: 'noreferrer',\n  variant: 'subtle',\n});\n\nconst PhoneInput = InputBase.withProps({\n  mask: '+7 (000) 000-0000',\n  component: IMaskInput,\n  label: 'Your phone number',\n  placeholder: 'Your phone number',\n});\n\nfunction Demo() {\n  return (\n    <>\n      {/* You can pass additional props to components created with `withProps` */}\n      <LinkButton href=\"https://mantine.dev\">\n        Mantine website\n      </LinkButton>\n\n      {/* Component props override default props defined in `withProps` */}\n      <PhoneInput placeholder=\"Personal phone\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Scroll Position with use-scroll-spy Hook in TypeScript React\nDESCRIPTION: Demonstrates how to use the use-scroll-spy hook from Mantine to track the scroll position of heading elements in the DOM and return the index of the element currently visible in the viewport. Useful for creating interactive table of contents or navigation menus. Requires React and @mantine/hooks package. The hook accepts a CSS selector to identify headings, and outputs data with heading details and the active index. The example dynamically renders a scrollable list highlighting the active heading, with clickable buttons that scroll the corresponding element into view.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Text, UnstyledButton } from '@mantine/core';\nimport { useScrollSpy } from '@mantine/hooks';\n\nfunction Demo() {\n  const spy = useScrollSpy({\n    selector: '#mdx :is(h1, h2, h3, h4, h5, h6)',\n  });\n\n  const headings = spy.data.map((heading, index) => (\n    <li\n      key={heading.id}\n      style={{\n        listStylePosition: 'inside',\n        paddingInlineStart: heading.depth * 20,\n        background: index === spy.active ? 'var(--mantine-color-blue-light)' : undefined,\n      }}\n    >\n      <UnstyledButton onClick={() => heading.getNode().scrollIntoView()}>\n        {heading.value}\n      </UnstyledButton>\n    </li>\n  ));\n\n  return (\n    <div>\n      <Text>Scroll to heading:</Text>\n      <ul style={{ margin: 0, padding: 0 }}>{headings}</ul>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing layout with MDX data for DateTimePicker\nDESCRIPTION: This snippet imports layout and MDX data, then renders the layout component passing the DateTimePicker documentation data for display on the page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { DateTimePickerDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.DateTimePicker);\n```\n\n----------------------------------------\n\nTITLE: Style function to access Mantine theme\nDESCRIPTION: Illustrates how to use a style function to access and use theme properties within the style prop of a Mantine Box component. Requires the `@mantine/core` package.  The style function receives the theme object as an argument, allowing access to colors, font sizes, and other theme-related properties.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/style.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      style={(theme) => ({\n        color: theme.colors.red[5],\n        fontSize: theme.fontSizes.xs,\n      })}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting aria-label on clear button with clearButtonProps\nDESCRIPTION: This example illustrates adding accessible attributes to the clear button, such as 'aria-label', ensuring screen readers can communicate the button's purpose properly. Note that 'clearButtonProps' is required if 'clearable' is true.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { TagsInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TagsInput\n      data={[]}\n      clearable\n      clearButtonProps={{\n        'aria-label': 'Clear input',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering MDX Content within Layout in React (JavaScript/JSX)\nDESCRIPTION: This snippet exports a default React component that renders the MDX content ('Mark') inside a 'Layout' wrapper, utilizing imported data. This pattern enables dynamic content rendering within a consistent layout framework, dependent on React and MDX integration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/mark.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.Mark);\n```\n\n----------------------------------------\n\nTITLE: Setting default color scheme for initial rendering in Mantine (TypeScript)\nDESCRIPTION: This snippet illustrates how to specify the default color scheme for initial render both on `ColorSchemeScript` and `MantineProvider`. It ensures the application starts with a specified color mode ('dark' in this case) when user has not chosen any scheme. Dependencies include Mantine's theming components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <ColorSchemeScript defaultColorScheme=\"dark\" />\n      <MantineProvider defaultColorScheme=\"dark\">\n        {/* Your app here */}\n      </MantineProvider>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Value Formatter for MonthPickerInput\nDESCRIPTION: Shows how to implement a custom valueFormatter function for more advanced formatting control, especially useful for different component types.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.valueFormatter} />\n```\n\n----------------------------------------\n\nTITLE: Displaying Usage Demo of DateInput Component\nDESCRIPTION: This snippet renders a demo section by passing the usage example data to a Demo component. It helps users visualize how to implement and utilize the DateInput component in applications, illustrating practical use cases.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Components with the useIsFirstRender Hook\nDESCRIPTION: This React component imports predefined 'HooksDemos', a layout component, and MDX data, then utilizes the 'useIsFirstRender' hook within the layout to determine initial render state. It also renders a demo component showcasing the hook's usage. The snippet integrates the hook into React's component tree and displays usage instructions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-is-first-render.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { HooksDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.useIsFirstRender);\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Colors with CSS Variables\nDESCRIPTION: Shows how to access Mantine colors using CSS variables in SCSS. This approach allows styling elements with Mantine's color system directly in stylesheets.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/colors.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  color: var(--mantine-color-red-5);\n  background: var(--mantine-color-grape-9);\n  border: rem(1px) solid var(--mantine-color-blue-1);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Import Order: Custom Styles Overriding\nDESCRIPTION: Demonstrates the correct order of importing CSS files, ensuring that custom styles override Mantine styles. This is achieved by importing Mantine styles before custom styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/styles-order.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// ✅ Correct order – your styles override Mantine styles\nimport '@mantine/core/styles.css';\nimport './styles.css';\n```\n\n----------------------------------------\n\nTITLE: Rendering Custom Value Format Demo for DatePickerInput in JSX\nDESCRIPTION: Shows how to customize the displayed date format by providing a `valueFormat` string compliant with the dayjs formatting syntax. This demo helps illustrate formatting flexibility for the date label.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_6\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.valueFormat} />\n```\n\n----------------------------------------\n\nTITLE: Customizing Heading Styles in Mantine Theme (TSX)\nDESCRIPTION: Shows how to override default heading styles in a Mantine application. This is achieved by defining custom `fontSize`, `lineHeight`, and `fontWeight` within the `headings.sizes` object when creating the theme using `createTheme` from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  headings: {\n    sizes: {\n      h1: {\n        fontSize: '2rem',\n        lineHeight: '1.5',\n        fontWeight: '500',\n      },\n      h2: {\n        fontSize: '1.5rem',\n        lineHeight: '1.6',\n        fontWeight: '500',\n      },\n    },\n    // ...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Grouping Sections within ActionIcon and Button Groups\nDESCRIPTION: This code demonstrates new components 'ActionIcon.GroupSection' and 'Button.GroupSection' to logically segment groups within ActionIcon and Button components, respectively. These allow for organized grouping beyond simple arrays.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={ActionIconDemos.groupSection} />\n```\n\n----------------------------------------\n\nTITLE: Defining useHover Hook in TypeScript\nDESCRIPTION: This TypeScript snippet defines the `useHover` hook.  It takes a generic type `T` extending `HTMLElement` (defaults to `HTMLDivElement`) and returns an object containing a `ref` (React ref object) and a `hovered` boolean.  This hook is intended to track whether a particular HTML element is being hovered over by the mouse cursor.  The `ref` is for attaching the hook to a DOM element, while the `hovered` variable indicates its current state. No external dependencies are explicitly shown here.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hover.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useHover<T extends HTMLElement = HTMLDivElement>(): {\n  ref: React.RefObject<T>;\n  hovered: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Loading Mantine Styles from Unpkg CDN in HTML\nDESCRIPTION: Provides HTML link elements to load both regular and @layered Mantine core stylesheets directly from unpkg CDN. This method is ideal for static sites or when you cannot use npm/yarn to install packages. Each link element must specify the desired package version to ensure consistency with local usage.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_9\n\nLANGUAGE: HTML\nCODE:\n```\n<!-- Regular styles -->\n<link\n  rel=\"stylesheet\"\n  href=\"https://unpkg.com/@mantine/core@7.4.2/styles.css\"\n/>\n\n<!-- Styles with @layer directive -->\n<link\n  rel=\"stylesheet\"\n  href=\"https://unpkg.com/@mantine/core@7.4.2/styles.layer.css\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Overhaul of AppShell Component\nDESCRIPTION: The AppShell now uses compound components rather than exported subcomponents, supports animations, collapsible sections, and removes the 'fixed' prop for a simplified fixed positioning model.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_19\n\n\n\n----------------------------------------\n\nTITLE: Enabling Sticky Table Headers with Mantine Table (TypeScript/React)\nDESCRIPTION: Shows how to enable sticky table headers using the stickyHeader and stickyHeaderOffset props in Mantine Table. The elements array serves as data, and the table header will remain visible while scrolling if the page is long enough. Output is a Table with a sticky Thead section and custom rows built from data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Table } from '@mantine/core';\n\nconst elements = [\n  { position: 6, mass: 12.011, symbol: 'C', name: 'Carbon' },\n  { position: 7, mass: 14.007, symbol: 'N', name: 'Nitrogen' },\n  { position: 39, mass: 88.906, symbol: 'Y', name: 'Yttrium' },\n  { position: 56, mass: 137.33, symbol: 'Ba', name: 'Barium' },\n  { position: 58, mass: 140.12, symbol: 'Ce', name: 'Cerium' },\n];\n\nfunction Demo() {\n  const rows = elements.map((element) => (\n    <Table.Tr key={element.name}>\n      <Table.Td>{element.position}</Table.Td>\n      <Table.Td>{element.name}</Table.Td>\n      <Table.Td>{element.symbol}</Table.Td>\n      <Table.Td>{element.mass}</Table.Td>\n    </Table.Tr>\n  ));\n\n  return (\n    <Table stickyHeader stickyHeaderOffset={60}>\n      <Table.Thead>\n        <Table.Tr>\n          <Table.Th>Element position</Table.Th>\n          <Table.Th>Element name</Table.Th>\n          <Table.Th>Symbol</Table.Th>\n          <Table.Th>Atomic mass</Table.Th>\n        </Table.Tr>\n      </Table.Thead>\n      <Table.Tbody>{rows}</Table.Tbody>\n      <Table.Caption>Scroll page to see sticky thead</Table.Caption>\n    </Table>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: UseMovePosition Type Usage\nDESCRIPTION: Demonstrates how to use the UseMovePosition type with the useState hook to manage the x and y coordinates. This allows you to define the type of the state variable, enhancing type safety and code clarity.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-move.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { UseMovePosition } from '@mantine/hooks';\n\nconst [value, setValue] = useState<UseMovePosition>({\n  x: 0.5,\n  y: 0.5,\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Directional Styling with rtl and ltr Mixins - SCSS and CSS\nDESCRIPTION: Shows the use of `rtl` and `ltr` mixins to conditionally apply CSS rules depending on text direction, typically set via the `dir` attribute in HTML. These mixins generate selectors targeting the appropriate direction attribute on parent elements for styling right-to-left or left-to-right layouts, enabling flexible internationalization support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_6\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  margin-left: 1rem;\n\n  @mixin rtl {\n    margin-left: 0;\n    margin-right: 1rem;\n  }\n}\n```\n\nLANGUAGE: CSS\nCODE:\n```\n.demo {\n  margin-left: 1rem;\n}\n\n[dir='rtl'] .demo {\n  margin-left: 0;\n  margin-right: 1rem;\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  margin-left: 1rem;\n\n  @mixin ltr {\n    margin-left: 0;\n    margin-right: 1rem;\n  }\n}\n```\n\nLANGUAGE: CSS\nCODE:\n```\n.demo {\n  margin-left: 1rem;\n}\n\n[dir='ltr'] .demo {\n  margin-left: 0;\n  margin-right: 1rem;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Line Heights in Theme\nDESCRIPTION: Demonstrates how to set custom line height values in the theme for consistent spacing and override defaults.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  lineHeights: {\n    xs: '1.2',\n    sm: '1.3',\n    md: '1.4',\n    lg: '1.5',\n    xl: '1.6',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Default Opened Items - Array Value\nDESCRIPTION: Shows how to set default opened items when the `multiple` prop is true. The `defaultValue` prop accepts an array of strings, each representing a value of an Accordion.Item to be opened by default. This allows multiple items to be pre-opened upon initial render.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/accordion.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Accordion } from '@mantine/core';\n\nfunction Demo() {\n  // Both items will be opened by default\n  return (\n    <Accordion multiple defaultValue={['item-1', 'item-2']}>\n      <Accordion.Item value=\"item-1\">\n        <Accordion.Control>control-1</Accordion.Control>\n        <Accordion.Panel>panel-1</Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item value=\"item-2\">\n        <Accordion.Control>control-2</Accordion.Control>\n        <Accordion.Panel>panel-2</Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js Layout for Mantine and Emotion\nDESCRIPTION: This snippet sets up the root layout for a Next.js application using Mantine and Emotion. It imports the necessary components and providers, including `RootStyleRegistry`, `MantineEmotionProvider`, and `MantineProvider`, to enable the use of Emotion-based styling within Mantine components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\nimport {\n  emotionTransform,\n  MantineEmotionProvider,\n} from '@mantine/emotion';\nimport { RootStyleRegistry } from './EmotionRootStyleRegistry';\n\nexport const metadata = {\n  title: 'Mantine Next.js template',\n  description: 'I am using Mantine with Next.js!',\n};\n\nexport default function RootLayout({ children }: { children: any }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <ColorSchemeScript />\n        <link rel=\"shortcut icon\" href=\"/favicon.svg\" />\n        <meta\n          name=\"viewport\"\n          content=\"minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no\"\n        />\n      </head>\n      <body>\n        <RootStyleRegistry>\n          <MantineEmotionProvider>\n            <MantineProvider stylesTransform={emotionTransform}>\n              {children}\n            </MantineProvider>\n          </MantineEmotionProvider>\n        </RootStyleRegistry>\n      </body>\n    </html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine Components with Static CSS Classes (CSS)\nDESCRIPTION: This CSS snippet demonstrates the use of Mantine's static class naming convention to apply persistent styles to a component without relying on props or theme overrides. It targets the root element of the Button component by class name, allowing integration with global CSS or alternative styling solutions. No dependencies required beyond Mantine's generated static classes; changes here affect all Buttons using the .mantine-Button-root class.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-api.mdx#_snippet_3\n\nLANGUAGE: CSS\nCODE:\n```\n.mantine-Button-root {\n  background-color: red;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Bar Size in Pixels in BarChart, JSX/TypeScript\nDESCRIPTION: Configures the minimal pixel height or width for bars using the `minBarSize` prop, ensuring bars are visible even with small values. Uses BarChartDemos.minBarSize sample for demonstration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_17\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.minBarSize} />\n```\n\n----------------------------------------\n\nTITLE: Importing InputMask Demo and Layout Components in React\nDESCRIPTION: Imports the `InputMask` demo component from a local project path and the `Layout` component, likely used for page structure, within a React application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/input-mask.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { InputMask } from '@/demos/InputMask.demo';\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Using sx and styles props with @mantine/emotion\nDESCRIPTION: Demonstrates how sx and styles props usage remains the same in both 6.x and 7.x when using @mantine/emotion.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x and 7.x, no changes\nimport { Box, Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Box\n        sx={(theme) => ({ backgroundColor: theme.colors.red[5] })}\n      />\n      <Button styles={{ root: { height: 50 } }} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Progress Compound Components (TSX)\nDESCRIPTION: Demonstrates the new compound component pattern for the Mantine Progress component. It shows how to create a multi-section progress bar using `Progress.Root`, `Progress.Section`, and `Progress.Label` to display different segments with labels and colors. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Progress } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Progress.Root size=\"xl\">\n      <Progress.Section value={35} color=\"cyan\">\n        <Progress.Label>Documents</Progress.Label>\n      </Progress.Section>\n      <Progress.Section value={28} color=\"pink\">\n        <Progress.Label>Photos</Progress.Label>\n      </Progress.Section>\n      <Progress.Section value={15} color=\"orange\">\n        <Progress.Label>Other</Progress.Label>\n      </Progress.Section>\n    </Progress.Root>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring postcss-preset-mantine Plugin in PostCSS - JavaScript\nDESCRIPTION: Shows how to set up `postcss-preset-mantine` in the PostCSS configuration file `postcss.config.cjs`, enabling the preset's plugins with default options or custom features such as `autoRem` and custom mixins. Dependencies include PostCSS and the preset package. The input is a module export for plugins, and the output is the activated preset modifying CSS processing behavior according to configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n  },\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {\n      autoRem: true,\n    },\n  },\n};\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {\n      autoRem: true,\n      mixins: {\n        clearfix: {\n          '&::after': {\n            content: '\"\"',\n            display: 'table',\n            clear: 'both',\n          },\n        },\n        circle: (_mixin, size) => ({\n          borderRadius: '50%',\n          width: size,\n          height: size,\n        }),\n      },\n    },\n    // ... Other plugins\n  },\n};\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nmodule.exports = {\n  'postcss-preset-mantine': {\n    features: {\n      lightDarkFunction: false,\n      nested: false,\n      colorMixAlpha: false,\n      remEmFunctions: false,\n      mixins: false,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: JsonInput Properties and Configuration Demo\nDESCRIPTION: This demo showcases the configurable properties of the JsonInput component through the InputFeatures component, allowing users to explore various property options such as formatting, validation, and appearance. It serves as an API reference for customizing JsonInput behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n<InputFeatures component=\"JsonInput\" element=\"textarea\" />\n```\n\n----------------------------------------\n\nTITLE: Setting Color Transparency with alpha in Mantine Core (TSX)\nDESCRIPTION: Shows how to use the `alpha` function from `@mantine/core` to apply transparency to a color. It takes a color string and an alpha value (0-1) as arguments. Returns the color in rgba format if possible, otherwise uses `color-mix` with `transparent` for CSS variables, noting potential browser compatibility issues.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { alpha } from '@mantine/core';\n\nalpha('#4578FC', 0.45); // -> rgba(69, 120, 252, 0.45)\nalpha('var(--mantine-color-gray-4)', 0.74);\n// -> color-mix(in srgb, var(--mantine-color-gray-4), transparent 26%)\n```\n\n----------------------------------------\n\nTITLE: Creating a Gradient LineChart in Mantine (TSX)\nDESCRIPTION: Illustrates using the `gradient` type in the `LineChart` component from `@mantine/charts` to render a line with a gradient fill. It showcases configuration props like `h`, `data`, `series`, `dataKey`, `type`, `gradientStops`, `strokeWidth`, `curveType`, `yAxisProps`, and `valueFormatter`. Assumes `data` is imported from a local `./data` file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { LineChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <LineChart\n      h={300}\n      data={data}\n      series={[{ name: 'temperature', label: 'Avg. Temperature' }]}\n      dataKey=\"date\"\n      type=\"gradient\"\n      gradientStops={[\n        { offset: 0, color: 'red.6' },\n        { offset: 20, color: 'orange.6' },\n        { offset: 40, color: 'yellow.5' },\n        { offset: 70, color: 'lime.5' },\n        { offset: 80, color: 'cyan.5' },\n        { offset: 100, color: 'blue.5' },\n      ]}\n      strokeWidth={5}\n      curveType=\"natural\"\n      yAxisProps={{ domain: [-25, 40] }}\n      valueFormatter={(value) => `${value}°C`}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Valibot Schema Types with Mantine Form using TypeScript\nDESCRIPTION: Explains how to derive the form data type (`FormData`) from a Valibot schema using `v.InferInput`. This inferred type is then used as a generic type parameter for the `useForm` hook (`useForm<FormData>`), providing strong type safety for `initialValues` and form handling. Requires `mantine-form-valibot-resolver`, `valibot`, and `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { valibotResolver } from 'mantine-form-valibot-resolver';\nimport * as v from 'valibot';\nimport { useForm } from '@mantine/form';\n\nexport const userSchema = v.object({\n  email: v.pipe(v.string(), v.email()),\n});\n\ntype FormData = v.InferInput<typeof userSchema>;\n\nconst form = useForm<FormData>({\n  initialValues: {\n    email: '',\n  },\n  validate: valibotResolver(userSchema),\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering PieChart component with Mantine Charts in TypeScript\nDESCRIPTION: Illustrates the basic setup for the new PieChart component from '@mantine/charts'. Similar to DonutChart, it imports data and renders the pie chart by passing the data array to the component's data prop within a functional React component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PieChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return <PieChart data={data} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting First Render with Mantine's useIsFirstRender Hook (TSX)\nDESCRIPTION: Shows how to use the useIsFirstRender hook from @mantine/hooks to determine if the current render is the first mount. The component tracks a counter with useState and signals the first render status using colored text. Dependencies are React, @mantine/core, and Mantine hooks, and the display updates in response to rerender events. Suitable for conditional initialization or one-time logic.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Text } from '@mantine/core';\nimport { useIsFirstRender } from '@mantine/hooks';\n\nfunction Demo() {\n  const [counter, setCounter] = useState(0);\n  const firstRender = useIsFirstRender();\n  return (\n    <div>\n      <Text>\n        Is first render:{' '}\n        <Text span c={firstRender ? 'teal' : 'red'}>\n          {firstRender ? 'Yes' : 'No!'}\n        </Text>\n      </Text>\n      <Button onClick={() => setCounter((c) => c + 1)} mt=\"sm\">\n        Rerendered {counter} times, click to rerender\n      </Button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies and Rendering Layout in TypeScript\nDESCRIPTION: This snippet imports necessary modules from `@docs/demos`, `@/layout`, and `@/mdx`. It then exports the default layout, which is rendered with the MDX data. The `Layout` function is likely a component that structures the overall page content.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-os.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { HooksDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.useOs);\n```\n\n----------------------------------------\n\nTITLE: Creating and Applying a Custom Theme\nDESCRIPTION: This code snippet shows how to create a custom theme and apply it to a Mantine application. It imports `createTheme` and `MantineProvider` from `@mantine/core`. The `createTheme` function is used to override the default theme settings, such as `fontFamily` and `primaryColor`. The customized theme is passed as a prop to the `MantineProvider`, making the theme available to all Mantine components within the application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  fontFamily: 'sans-serif',\n  primaryColor: 'orange',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Regular Component Props in TypeScript\nDESCRIPTION: Demonstrates how to extend props of regular Mantine components that include React.ComponentPropsWithoutRef<'X'> in their type definition.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Group, GroupProps } from '@mantine/core';\n\n// Interface includes `React.ComponentPropsWithoutRef<'div'>`\ninterface MyGroupProps extends GroupProps {\n  spacing: number;\n}\n\nfunction MyGroup({ spacing, ...others }: MyGroupProps) {\n  return <Group my={spacing} {...others} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using PostCSS Breakpoint Variables in CSS Media Queries\nDESCRIPTION: Illustrates how to use the variables defined in the PostCSS config (like `$mantine-breakpoint-xs`) directly within CSS media queries in `.css` files. PostCSS will replace these variables with their defined static values during processing, enabling consistent breakpoint usage.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/responsive.mdx#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n.demo {\n  @media (max-width: $mantine-breakpoint-xs) {\n    background-color: red;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Container Component Documentation in React\nDESCRIPTION: Code showing how the Container component documentation page is set up with imports and default export. It imports demos, layout components, and MDX data to structure the documentation page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/container.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ContainerDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Container);\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Dropzone with Yarn - Bash\nDESCRIPTION: This snippet demonstrates the installation of the @mantine/dropzone, @mantine/core, and @mantine/hooks packages using the yarn package manager.  It's a prerequisite step to use the Mantine Dropzone component within a project.  No specific parameters are needed; it simply installs the listed dependencies. The output is the successful installation of the specified packages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/dropzone/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @mantine/dropzone @mantine/core @mantine/hooks\n```\n\n----------------------------------------\n\nTITLE: Importing and applying Mantine Theme and Fonts\nDESCRIPTION: This TypeScript/React snippet configures the Mantine theme to use a custom font. It imports necessary modules from `@mantine/core` and `@remix-run/react`.  Dependencies include Mantine Core, Remix React, and the previously defined `GreycliffCF.css` file.  The output is the Mantine Provider wrapped around the app children, applying the configured theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/remix-load-fonts.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\nimport './GreycliffCF/styles.css';\n\nimport {\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\nimport {\n  ColorSchemeScript,\n  createTheme,\n  DEFAULT_THEME,\n  MantineProvider,\n} from '@mantine/core';\n\nconst theme = createTheme({\n  fontFamily: 'Greycliff CF, sans-serif',\n  fontFamilyMonospace: 'Monaco, Courier, monospace',\n  headings: {\n    // Use default theme if you want to provide default Mantine fonts as a fallback\n    fontFamily: `Greycliff CF, ${DEFAULT_THEME.fontFamily}`,\n  },\n});\n\nexport function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta\n          name=\"viewport\"\n          content=\"width=device-width, initial-scale=1\"\n        />\n        <Meta />\n        <Links />\n        <ColorSchemeScript />\n      </head>\n      <body>\n        <MantineProvider theme={theme}>{children}</MantineProvider>\n        <ScrollRestoration />\n        <Scripts />\n      </body>\n    </html>\n  );\n}\n\nexport default function App() {\n  return <Outlet />;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic px-to-rem Conversion in postcss-preset-mantine (JavaScript)\nDESCRIPTION: Illustrates how to enable automatic conversion of px units to rem in CSS files by setting the autoRem option to true in the postcss-preset-mantine plugin configuration. Requires a Node.js project and proper installation of postcss and postcss-preset-mantine. Expects a CommonJS module exporting plugins object. The plugin will process CSS files, converting px values as specified.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rem.mdx#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {\n      autoRem: true\n    }\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Ref Handling for Burger Component\nDESCRIPTION: This snippet shows how to obtain a reference to the Burger component, specifying the component's DOM element type ('button') via refType. This enables direct DOM manipulation or focus management in advanced use cases.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/burger.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n<GetElementRef component=\"Burger\" refType=\"button\" />\n```\n\n----------------------------------------\n\nTITLE: Applying Styles to Mantine Components with SCSS\nDESCRIPTION: This SCSS snippet demonstrates how to use an attribute selector to apply a style to all Mantine components. It targets all elements whose `class` attribute starts with \"mantine-\".  The key functionality is setting the text color to red. This is dependent on the `mantine-` class prefix, which is the default for Mantine components.  There are no specific parameters or inputs in this snippet, it is a selector that targets all components and modifies their appearance. Output is all Mantine components with red text color.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/apply-styles-to-all.mdx#_snippet_0\n\nLANGUAGE: scss\nCODE:\n```\n[class^=mantine] {\n  color: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Making TagsInput read-only\nDESCRIPTION: This snippet sets the 'readOnly' prop to prevent user input while still displaying selected tags and disabling editing features. The component does not show suggestions or trigger onChange.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.readOnly} />\n```\n\n----------------------------------------\n\nTITLE: Using classNames in Theme Components for TextInput (TypeScript)\nDESCRIPTION: This snippet provides an example of applying global classNames to the TextInput component via the theme.components configuration in Mantine. It requires valid CSS modules imported as classes, and uses createTheme and MantineProvider from @mantine/core. This approach allows all instances of TextInput to share the same root, input, and label class definitions project-wide.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-api.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport {\n  createTheme,\n  MantineProvider,\n  TextInput,\n} from '@mantine/core';\n// Styles are the same as in previous example\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extend({\n      classNames: {\n        root: classes.root,\n        input: classes.input,\n        label: classes.label,\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating emotion.d.ts for SX & Styles in Vite\nDESCRIPTION: This snippet demonstrates the creation of a `emotion.d.ts` file, which extends Mantine's types to support the `sx` and `styles` props when using Emotion.  This file is necessary for TypeScript support within the project. It depends on `@mantine/core` and `@mantine/emotion` to define the types.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core';\n\nimport type { EmotionStyles, EmotionSx } from '@mantine/emotion';\n\ndeclare module '@mantine/core' {\n  export interface BoxProps {\n    sx?: EmotionSx;\n    styles?: EmotionStyles;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing FileButton issue with closeOnItemClick - Mantine/React\nDESCRIPTION: This snippet references an external demo component (`FileButtonMenuFix2.demo`) that illustrates the second solution. It shows how setting the `closeOnItemClick={false}` prop on the specific `Menu.Item` containing the `FileButton` prevents the menu from closing when that item is clicked, resolving the issue.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/file-button-in-menu.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={FileButtonMenuFix2} />\n```\n\n----------------------------------------\n\nTITLE: Showing UnstyledButton Element Reference Access\nDESCRIPTION: Demonstrates how to access the underlying element reference of the UnstyledButton component through the GetElementRef component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/unstyled-button.mdx#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\n<GetElementRef component=\"UnstyledButton\" refType=\"button\" />\n```\n\n----------------------------------------\n\nTITLE: Using leftSection and rightSection Props in Mantine Button (TSX)\nDESCRIPTION: Demonstrates the usage of the `leftSection` and `rightSection` props in the Mantine `Button` component, which replace the previous `icon` prop for consistency. These props allow adding elements or icons before and after the button's label. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button leftSection=\"left\" rightSection=\"right\">\n      Label\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Input DOM Node with useForm in TSX\nDESCRIPTION: This snippet demonstrates how to obtain the HTML DOM node for a specific form input field using the `form.getInputNode` function provided by the Mantine `useForm` hook. It shows how to get nodes for simple paths like 'order_id' and nested paths like 'user.email'. This function is useful for direct DOM manipulation, such as focusing an element, and requires the `@mantine/form` dependency.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/focus-first-input-with-error.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    order_id: null,\n    user: { email: '' },\n  },\n});\n\n// Returns input DOM node for order_id input\nform.getInputNode('order_id');\n\n// Returns input DOM node for user.email input\nform.getInputNode('user.email');\n```\n\n----------------------------------------\n\nTITLE: Accessing Theme Values in JavaScript\nDESCRIPTION: This code shows how to access theme values in JavaScript using `useMantineTheme` hook.  It also demonstrates how to modify theme values, such as lightening a color, before applying them as inline styles.  This approach offers dynamic styling options based on the current theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lighten, useMantineTheme } from '@mantine/core';\n\nfunction Demo() {\n  const theme = useMantineTheme();\n\n  const style = {\n    // You can use CSS variables in inline styles\n    background: 'var(--mantine-color-red-9)',\n\n    // Or use values from theme object if you need to modify them\n    color: lighten(theme.colors.red[9], 0.2),\n  };\n\n  return <div style={style} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Individual Spotlight Control Actions and Using Them in React TypeScript\nDESCRIPTION: Shows an alternative import syntax where openSpotlight, closeSpotlight, and toggleSpotlight are imported directly from @mantine/spotlight. It illustrates calling these action functions independently, serving the same purpose as the methods on the spotlight object, to control the Spotlight component’s open state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/spotlight.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  closeSpotlight,\n  openSpotlight,\n  toggleSpotlight,\n} from '@mantine/spotlight';\n\nopenSpotlight(); // same as spotlight.open()\ncloseSpotlight(); // same as spotlight.close()\ntoggleSpotlight(); // same as spotlight.toggle()\n```\n\n----------------------------------------\n\nTITLE: CSS module with variable references\nDESCRIPTION: Shows the CSS module that uses the custom CSS variable defined in the component for pseudo-class styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dynamic-css-styles.mdx#_snippet_5\n\nLANGUAGE: scss\nCODE:\n```\n.root {\n  background: orange;\n\n  &:hover {\n    background: var(--demo-hover);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useLogger Hook in TypeScript\nDESCRIPTION: This snippet defines a TypeScript function signature for the `useLogger` hook. It specifies that the hook accepts a `componentName` (string) and an array of `props` (any[]) as input, and returns a value of type `any`. This signature is used to describe how the hook should be used.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-logger.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useLogger(componentName: string, props: any[]): any;\n```\n\n----------------------------------------\n\nTITLE: Using MantineSize Type for Component Size Props\nDESCRIPTION: Demonstrates using MantineSize type for component props that accept standard Mantine size values, including props that can accept size union types.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineSize, Paper } from '@mantine/core';\n\ninterface DemoProps {\n  size: MantineSize;\n  radius: MantineSize | (string & {}) | number;\n  shadow: MantineSize | string;\n}\n\nfunction Demo({ size, radius, shadow }: DemoProps) {\n  return <Paper radius={radius} shadow={shadow} p={size} m={size} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering HoverCard with Interactive Elements Demo (JSX)\nDESCRIPTION: Renders a `Demo` component demonstrating the integration of interactive elements (like anchors or buttons) within the HoverCard dropdown. The demo content comes from `HoverCardDemos.profile`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/hover-card.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={HoverCardDemos.profile} />\n```\n\n----------------------------------------\n\nTITLE: Using Subtle Variant in RichTextEditor\nDESCRIPTION: This code demonstrates enabling the 'subtle' styling variant for the RichTextEditor component, which adjusts its appearance for a more minimal or unobtrusive editing interface.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TipTapDemos.subtleVariant} />\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Theme with Mantine\nDESCRIPTION: This snippet shows how to create a custom theme using `createTheme` and apply it to the `MantineProvider`.  The custom theme can override default theme values such as `fontFamily` and `defaultRadius`.  This ensures that all Mantine components use the defined theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\n// Your theme configuration is merged with default theme\nconst theme = createTheme({\n  fontFamily: 'Montserrat, sans-serif',\n  defaultRadius: 'md',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing grid and text colors with CSS variables or props\nDESCRIPTION: Changes grid lines and text colors using CSS variables '--chart-grid-color' and '--chart-text-color', or fallback props 'gridColor' and 'textColor'. Supports theming and visual consistency across different color schemes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.gridColor} />\n```\n\n----------------------------------------\n\nTITLE: Rendering Notifications Component with Limit of Concurrent Notifications (TSX)\nDESCRIPTION: Shows how to limit the maximum number of notifications displayed simultaneously by specifying the limit prop on the Notifications component. Additional notifications beyond the limit are queued and displayed after current ones are closed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Notifications } from '@mantine/notifications';\n\nfunction Demo() {\n  return <Notifications limit={5} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Destructuring useMouse Hook - Mantine React\nDESCRIPTION: This code snippet shows how to destructure the return values from the `useMouse` hook. It imports the hook and then destructures `ref`, `x`, and `y`. The `ref` is used to pass a ref to a target element. `x` and `y` give you the mouse coordinates. Dependencies include `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mouse.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useMouse } from '@mantine/hooks';\n\nconst {\n  ref, // -> pass ref to target element, if not used document element will be used as target element\n  x, // -> mouse x position\n  y, // -> mouse y position\n} = useMouse();\n```\n\n----------------------------------------\n\nTITLE: Using useStateHistory Hook in React with Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet illustrates how to utilize the useStateHistory hook from @mantine/hooks to maintain and navigate through a state value’s history in a React functional component. The implementation requires Mantine core and hooks libraries. Buttons are provided to set a new random value, go back, and go forward in history, while the current history stack is displayed as JSON. Key parameters are the initial value and handler methods. The output is interactive demonstration of state history manipulation; limitations assume a proper browser environment and valid state transitions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.7.0.md#_snippet_5\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Button, Code, Group, Text } from '@mantine/core';\nimport { useStateHistory } from '@mantine/hooks';\n\nfunction Demo() {\n  const [value, handlers, history] = useStateHistory(1);\n  return (\n    <>\n      <Text>Current value: {value}</Text>\n      <Group my=\"md\">\n        <Button onClick={() => handlers.set(Math.ceil(Math.random() * 100) + 1)}>Set value</Button>\n        <Button onClick={() => handlers.back()}>Back</Button>\n        <Button onClick={() => handlers.forward()}>Forward</Button>\n      </Group>\n      <Code block>{JSON.stringify(history, null, 2)}</Code>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing use-radial-move Hook for Custom Radial Sliders\nDESCRIPTION: This snippet references the 'use-radial-move' custom hook, which facilitates the creation of radial sliders by handling user interactions and movement calculations. It is used within a demo component to showcase radial movement behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={HooksDemos.useRadialMoveUsage} />\n```\n\n----------------------------------------\n\nTITLE: Applying Responsive Styles with smaller-than and larger-than Mixins - SCSS\nDESCRIPTION: Shows usage of `smaller-than` and `larger-than` mixins to apply CSS styles based on screen size breakpoints. The mixins generate media queries with max-width or min-width in em units, carefully adjusting breakpoints to avoid overlap. The example covers both fixed pixel breakpoints and usage with Mantine breakpoint variables. This simplifies writing responsive CSS rules tied to viewport widths.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_3\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  @mixin smaller-than 320px {\n    color: red;\n  }\n\n  @mixin larger-than 320px {\n    color: blue;\n  }\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n@media (max-width: 19.99375em) {\n  .demo {\n    color: red;\n  }\n}\n\n@media (min-width: 20em) {\n  .demo {\n    color: blue;\n  }\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  @mixin smaller-than $mantine-breakpoint-sm {\n    color: red;\n  }\n\n  @mixin larger-than $mantine-breakpoint-sm {\n    color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Date Range Selection with MonthPickerInput\nDESCRIPTION: Demonstrates how to set up MonthPickerInput for selecting a range of months by setting the type prop to 'range'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.range} />\n```\n\n----------------------------------------\n\nTITLE: Transforming TypeScript Demo Code to JavaScript\nDESCRIPTION: This snippet demonstrates how to convert a TypeScript example using Mantine components into JavaScript by removing type annotations and imports. The transformation allows developers to reuse Mantine demos in JavaScript projects without TypeScript-specific syntax.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/javascript.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// TypeScript code\nimport { Button, ButtonProps } from '@mantine/core';\n\ninterface MyButtonProps extends ButtonProps {\n  myProp: string;\n}\n\nfunction MyButton({ myProp, ...others }: MyButtonProps) {\n  return <Button {...others} />;\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// JavaScript code\nimport { Button } from '@mantine/core';\n\nfunction MyButton({ myProp, ...others }) {\n  return <Button {...others} />;\n}\n```\n\n----------------------------------------\n\nTITLE: useHash Hook TypeScript Definition\nDESCRIPTION: The TypeScript type definition for the useHash hook, showing its parameter options and return type. The hook returns a readonly tuple with the current hash string and a function to update it.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hash.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useHash(options: {\n  getInitialValueInEffect?: boolean;\n}): readonly [string, (value: string) => void];\n```\n\n----------------------------------------\n\nTITLE: Implementing virtualColor function for theme-aware colors in Mantine\nDESCRIPTION: Example of using the virtualColor function to define colors that adapt to light and dark color schemes. The function takes an object with name, light, and dark properties to specify which colors to use in different schemes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-7-0.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={ThemingDemos.virtualColors} />\n```\n\n----------------------------------------\n\nTITLE: Displaying Initials in Mantine Avatar Component (TSX)\nDESCRIPTION: Demonstrates using the `name` prop on the `Avatar` component to display initials derived from the provided name (e.g., \"John Doe\" becomes \"JD\"). Setting `color=\"initials\"` automatically generates a background color based on the name. Dependencies include `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Avatar, Group } from '@mantine/core';\n\nconst names = [\n  'John Doe',\n  'Jane Mol',\n  'Alex Lump',\n  'Sarah Condor',\n  'Mike Johnson',\n  'Kate Kok',\n  'Tom Smith',\n];\n\nfunction Demo() {\n  const avatars = names.map((name) => <Avatar key={name} name={name} color=\"initials\" />);\n  return <Group>{avatars}</Group>;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Global Classes for Style Components in MantineProvider (TypeScript)\nDESCRIPTION: Demonstrates how to turn off global CSS classes with 'withGlobalClasses' to prevent rendering of global styles, which may be used for custom styling or CSS management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider withGlobalClasses={false}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping suggestion options in dropdown\nDESCRIPTION: This snippet demonstrates organizing suggestion options into groups by passing grouped data to the component, enhancing dropdown navigation and selection clarity.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.groups} />\n```\n\n----------------------------------------\n\nTITLE: Adding axis labels to charts in Mantine\nDESCRIPTION: Demonstrates how to use the xAxisLabel and yAxisLabel props with Mantine chart components like AreaChart, BarChart, and LineChart to provide clear axis descriptions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-7-0.mdx#_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={AreaChartDemos.axisLabels} />\n```\n\n----------------------------------------\n\nTITLE: Using the useMounted Hook from Mantine Hooks in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the useMounted hook from the @mantine/hooks library within a React functional component written in TypeScript. The hook returns a boolean indicating if the component is currently mounted, which enables conditional rendering. The demonstration includes a component that displays 'Component is mounted' when mounted and 'Component is not mounted' otherwise. Prerequisites include React and the Mantine hooks package installed and available.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mounted.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMounted } from '@mantine/hooks';\n\nfunction Demo() {\n  const mounted = useMounted();\n  return (\n    <div>\n      {mounted ? 'Component is mounted' : 'Component is not mounted'}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating theme.colorScheme with @mantine/emotion\nDESCRIPTION: Shows how to transition from using theme.colorScheme in 6.x to using light/dark utilities in @mantine/emotion in 7.x.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { createStyles } from '@mantine/core';\n\nconst useStyles = createStyles((theme) => ({\n  root: {\n    backgroundColor:\n      theme.colorScheme === 'dark'\n        ? theme.colors.dark[6]\n        : theme.colors.gray[0],\n    color: theme.colorScheme === 'dark' ? theme.white : theme.black,\n  },\n}));\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// 7.x\nimport { createStyles } from '@mantine/emotion';\n\nconst useStyles = createStyles((theme, _, u) => ({\n  root: {\n    [u.dark] {\n      backgroundColor: theme.colors.dark[6];\n      color: theme.white;\n    },\n\n    [u.light]: {\n      backgroundColor: theme.colors.gray[0];\n      color: theme.black;\n    },\n  },\n}));\n```\n\n----------------------------------------\n\nTITLE: Usage demonstration of LineChart component with data\nDESCRIPTION: Shows how to include the LineChart component with sample usage data. Dependencies include the LineChartDemos object containing predefined demo data. This snippet demonstrates rendering the chart with default or specific datasets.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Importing and Using SCSS Module Styles in a React Component (TSX)\nDESCRIPTION: Shows how to import an SCSS module (`Element.module.css`) into a React component (TSX) and apply the defined class (`styles.element`) to a Mantine `Box` component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-add-hover-styles.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\nimport styles from './Element.module.css';\n\nexport const Element = () => {\n  return <Box className={styles.element}>Element</Box>;\n};\n```\n\n----------------------------------------\n\nTITLE: Importing FormErrors Type – Mantine\nDESCRIPTION: Shows how to import the `FormErrors` type from `@mantine/form` for type checking. Also shows how to get the type directly from the `form` instance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { FormErrors } from '@mantine/form';\n\n```\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({ mode: 'uncontrolled' });\n\nconst handleErrors = (errors: typeof form.errors) => {};\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useInputState Hook\nDESCRIPTION: Shows the TypeScript type definition for the useInputState hook. The hook accepts an initial state of generic type T and returns a tuple with the current state value and a setter function that can handle both direct values and React change events.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-input-state.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useInputState<T>(\n  initialState: T\n): [\n  T,\n  (value: null | undefined | T | React.ChangeEvent<any>) => void,\n];\n```\n\n----------------------------------------\n\nTITLE: Importing BarChart Demo Data and Layout in TypeScript\nDESCRIPTION: Imports the BarChartDemos object containing predefined demo datasets from the documentation demos path, a Layout component for page rendering, and static MDX data representing the BarChart documentation content. This snippet sets up necessary dependencies for rendering the BarChart documentation page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { BarChartDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.BarChart);\n```\n\n----------------------------------------\n\nTITLE: Configure VS Code CSS Variables Lookup - JSON\nDESCRIPTION: This JSON snippet provides settings for the `.vscode/settings.json` file. It configures the 'CSS Variable Autocomplete extension' to scan specified file patterns, including Mantine's core styles, to enable intelligent autocomplete suggestions for Mantine's CSS variables within your project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/getting-started.mdx#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"cssVariables.lookupFiles\": [\n    \"**/*.css\",\n    \"**/*.scss\",\n    \"**/*.sass\",\n    \"**/*.less\",\n    \"node_modules/@mantine/core/styles.css\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying target DOM node for Portal in React with TypeScript\nDESCRIPTION: Shows how to specify a custom DOM node as the portal target by creating a container div programmatically and passing it as the `target` prop to the Portal component. Also includes an example of using a CSS selector string to target an existing DOM element. Requires React, @mantine/core, and browser environment DOM APIs. Inputs are Portal children and custom target container; output is rendering children inside that target node.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/portal.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Portal } from '@mantine/core';\n\nconst container = document.createElement('div');\ndocument.body.appendChild(container);\n\nfunction Demo() {\n  return <Portal target={container}>My portal</Portal>;\n}\n```\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Portal } from '@mantine/core';\n\nfunction Demo() {\n  return <Portal target=\"#portal-container\">My portal</Portal>;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Font Smoothing Globally with SCSS\nDESCRIPTION: Provides an SCSS example for setting custom global font smoothing styles on the `body` element. This approach is typically used after disabling Mantine's default font smoothing via the theme configuration (`fontSmoothing: false`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_16\n\nLANGUAGE: scss\nCODE:\n```\n// Add global styles to your project with desired font smoothing values\nbody {\n  -webkit-font-smoothing: subpixel-antialiased;\n  -moz-osx-font-smoothing: auto;\n}\n```\n\n----------------------------------------\n\nTITLE: Using CSS variables for dynamic pseudo-class styling\nDESCRIPTION: Demonstrates how to use CSS variables to apply dynamic styling to pseudo-classes like :hover, which can't be directly targeted with inline styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dynamic-css-styles.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\nimport classes from './Demo.module.css';\n\ninterface DemoProps {\n  color: string;\n}\n\nfunction Demo({ color }: DemoProps) {\n  return (\n    <Box style={{ '--demo-hover': color }} className={classes.root}>\n      My demo\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Tooltip events in React\nDESCRIPTION: Shows how to customize the events that trigger the tooltip. The events prop accepts an object with hover, focus, and touch properties to control behavior across different interaction methods.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tooltip.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Tooltip } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Tooltip\n      label=\"Tooltip\"\n      events={{ hover: true, focus: true, touch: false }}\n    >\n      <button>target</button>\n    </Tooltip>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useSessionStorage Hook in React\nDESCRIPTION: Shows how to use the useSessionStorage hook, which works similarly to useLocalStorage but stores data in sessionStorage instead of localStorage, meaning data persists only for the current session.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useSessionStorage } from '@mantine/hooks';\n\nconst [value, setValue] = useSessionStorage({\n  key: 'session-key',\n  defaultValue: 'mantine',\n});\n```\n\n----------------------------------------\n\nTITLE: Passing Props to Recharts Bar Component Dynamically in BarChart, JSX/TypeScript\nDESCRIPTION: Passes additional properties to the internal Recharts Bar component using the `barProps` prop, which accepts either an object or a function receiving series data to compute props dynamically. This allows fine control over individual bar configuration. Demonstrated by BarChartDemos.barProps.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_16\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.barProps} />\n```\n\n----------------------------------------\n\nTITLE: Demonstration of Burger Component Usage\nDESCRIPTION: This snippet presents a demo of the Burger component rendering an open/close menu button, controlled via 'opened' and 'onClick' props. It illustrates how to display different visual states of the button based on props, along with a demo component showcasing usage examples.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/burger.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n`Burger` component renders open/close menu button.\nSet `opened` and `onClick` props to control component state.\nIf `opened` prop is set, cross will be rendered, otherwise – burger.\n\n<Demo data={BurgerDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: rem function usage\nDESCRIPTION: Illustrates how to use the `rem` function from `@mantine/core` to convert pixel values to `rem` units. It demonstrates how to use it with space-separated values and within component props like the `radius` prop of the `Modal` component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-3-0.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { rem } from '@mantine/core';\n\nrem('16px 32px');\n// -> calc(1rem * var(--mantine-scale)) calc(2rem * var(--mantine-scale))\n```\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Modal } from '@mantine/core';\n\nfunction Demo() {\n  return <Modal radius=\"10px 10px 0 0\" opened onClose={() => {}} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents with TableOfContents Component in TypeScript React\nDESCRIPTION: Shows usage of the TableOfContents component in Mantine, which is built on the use-scroll-spy hook to automatically create a table of contents UI based on heading elements. It supports properties such as variant, color, size, and radius for styling, as well as scrollSpyOptions to define which elements to spy on. The getControlProps function handles scroll behavior when clicking TOC items. Requires React and @mantine/core package. Outputs a styled, interactive table of contents that scrolls to relevant sections.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TableOfContents } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TableOfContents\n      variant=\"filled\"\n      color=\"blue\"\n      size=\"sm\"\n      radius=\"sm\"\n      scrollSpyOptions={{\n        selector: '#mdx :is(h1, h2, h3, h4, h5, h6)',\n      }}\n      getControlProps={({ data }) => ({\n        onClick: () => data.getNode().scrollIntoView(),\n        children: data.value,\n      })}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demo: Disabling the DateTimePicker\nDESCRIPTION: This demo showcases setting the disabled state on the DateTimePicker component, which prevents user interaction and signals a non-editable state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_5\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DateTimePickerDemos.disabled} />\n```\n\n----------------------------------------\n\nTITLE: Adding OKLCH colors to custom Mantine theme in TypeScript\nDESCRIPTION: Demonstrates how to extend Mantine's default theme colors by adding an 'oklch-blue' palette using OKLCH color values within a TypeScript React app. It shows the theme creation with createTheme, usage of MantineProvider to apply the theme globally, and rendering buttons styled with the custom OKLCH-based colors. Requires Mantine core components and React with TypeScript. The color array supports 10 shades defined by OKLCH CSS color strings.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, createTheme, Group, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    'oklch-blue': [\n      'oklch(96.27% 0.0217 238.66)',\n      'oklch(92.66% 0.0429 240.01)',\n      'oklch(86.02% 0.0827 241.66)',\n      'oklch(78.2% 0.13 243.83)',\n      'oklch(71.8% 0.1686 246.06)',\n      'oklch(66.89% 0.1986 248.32)',\n      'oklch(62.59% 0.2247 250.29)',\n      'oklch(58.56% 0.2209 251.26)',\n      'oklch(54.26% 0.2067 251.67)',\n      'oklch(49.72% 0.1888 251.59)',\n    ],\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Group>\n        <Button color=\"oklch-blue\">Filled</Button>\n        <Button color=\"oklch-blue\" variant=\"outline\">\n          Outline\n        </Button>\n        <Button color=\"oklch-blue\" variant=\"light\">\n          Light\n        </Button>\n      </Group>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Failing React Testing Library Test for Mantine Modal (TSX)\nDESCRIPTION: This snippet shows a React Testing Library test for the AuthModal component that fails when transitions are enabled. It attempts to click the button to open the modal and then assert that the modal's heading is present in the document. The test fails because the transition component uses setTimeout, which @testing-library/react doesn't wait for by default, causing the modal content to not be in the DOM immediately after the click event is processed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/portals-testing.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { render, screen, userEvent } from '@/test-utils';\nimport { AuthModal } from './AuthModal';\n\ndescribe('AuthModal', () => {\n  it('opens modal when button is clicked', async () => {\n    render(<AuthModal />);\n    await userEvent.click(screen.getByRole('button', { name: 'Open authentication modal' }));\n    // ⛔ Test fails, modal heading is not in the document yet\n    // Error message: TestingLibraryElementError: Unable to find an accessible element\n    // with the role \"heading\" and name \"Authenticate\"\n    expect(screen.getByRole('heading', { name: 'Authenticate' })).toBeInTheDocument();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine Component Inputs in SCSS\nDESCRIPTION: Demonstrates the incorrect method of using private Mantine CSS variables (`--_`) and the correct method using standard SCSS selectors (`&:focus`, `&::placeholder`) to style input elements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/private-css-variables.mdx#_snippet_0\n\nLANGUAGE: scss\nCODE:\n```\n.input {\n  // ❌ do not use private CSS variables\n  --_input-bd-focus: red;\n  --_input-placeholder-color: red;\n}\n\n.input {\n  // ✅ use regular styles\n  &:focus,\n  &:focus-within {\n    border-color: red;\n  }\n\n  &::placeholder {\n    color: red;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Aria Labels for Year Controls (TSX)\nDESCRIPTION: This snippet demonstrates using the `getYearControlProps` function in the Mantine `YearPicker` to dynamically assign a custom `aria-label` to each individual year control. The function receives the date object for the year and returns an object containing the desired props, enhancing accessibility by providing specific labels for each selectable year.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/year-picker.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { YearPicker } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <YearPicker\n      getYearControlProps={(date) => ({\n        'aria-label': `Select year ${date.getFullYear()}`,\n      })}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Input Aria-label Example\nDESCRIPTION: Demonstrates the use of `aria-label` for accessibility when using the `Input` component. If an associated label isn't present, `aria-label` is necessary to provide a text alternative. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/input.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Input } from '@mantine/core';\n\n// ok – the input is labelled by the aria-label\nfunction WithAriaLabel() {\n  return <Input aria-label=\"Your email\" />;\n}\n\n// ok – the input is labelled by the label element\nfunction WithLabel() {\n  return (\n    <>\n      <label htmlFor=\"my-email\">Your email</label>\n      <Input id=\"my-email\" />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using form.getInputNode to Focus Input DOM Elements in React Mantine Form\nDESCRIPTION: This code demonstrates the `form.getInputNode(path)` method, allowing programmatic access to input DOM nodes based on form field paths. It is utilized within an uncontrolled form with email and name fields, enabling focus management when form submission results in errors by focusing the first erroneous input. Dependencies include Mantine core components and the `useForm` hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.10.0.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button, Group, TextInput } from '@mantine/core';\nimport { isEmail, isNotEmpty, useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      name: '',\n      email: '',\n    },\n\n    validate: {\n      name: isNotEmpty('Name is required'),\n      email: isEmail('Invalid email'),\n    },\n  });\n\n  return (\n    <form\n      onSubmit={form.onSubmit(\n        (values) => console.log(values),\n        (errors) => {\n          const firstErrorPath = Object.keys(errors)[0];\n          form.getInputNode(firstErrorPath)?.focus();\n        }\n      )}\n    >\n      <TextInput\n        withAsterisk\n        label=\"Your name\"\n        placeholder=\"Your name\"\n        key={form.key('name')}\n        {...form.getInputProps('name')}\n      />\n\n      <TextInput\n        withAsterisk\n        label=\"Your email\"\n        placeholder=\"your@email.com\"\n        key={form.key('email')}\n        {...form.getInputProps('email')}\n      />\n\n      <Group justify=\"flex-end\" mt=\"md\">\n        <Button type=\"submit\">Submit</Button>\n      </Group>\n    </form>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generated CSS from smaller-than and larger-than Mixins (SCSS to CSS Transformation)\nDESCRIPTION: Presents the CSS output after SCSS mixins are processed. Establishes media queries using em units, subtracting 0.1px for max-width in smaller-than for breakpoint intersection avoidance. No dependencies apart from the appropriate build tools.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n// Breakpoint values are converted to em units\n// In smaller-than mixin 0.1px is subtracted from breakpoint value\n// to avoid intersection with larger-than mixin\n@media (max-width: 19.99375em) {\n  .demo {\n    color: red;\n  }\n}\n\n@media (min-width: 20em) {\n  .demo {\n    color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Roboto font in Mantine Theme\nDESCRIPTION: This TypeScript/React snippet configures the Mantine theme to use the Roboto font family. It imports necessary modules from `@mantine/core` and `@remix-run/react`.  Dependencies include Mantine Core and Remix React.  This is similar to the earlier snippet using local fonts, but it now uses the Roboto font and its fallback.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/remix-load-fonts.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\nimport './GreycliffCF/styles.css';\n\nimport {\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from '@remix-run/react';\nimport {\n  ColorSchemeScript,\n  createTheme,\n  DEFAULT_THEME,\n  MantineProvider,\n} from '@mantine/core';\n\nconst theme = createTheme({\n  fontFamily: 'Roboto, sans-serif',\n  fontFamilyMonospace: 'Monaco, Courier, monospace',\n  headings: {\n    // Use default theme if you want to provide default Mantine fonts as a fallback\n    fontFamily: `Roboto, ${DEFAULT_THEME.fontFamily}`,\n  },\n});\n\nexport function Layout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta\n          name=\"viewport\"\n          content=\"width=device-width, initial-scale=1\"\n        />\n        <Meta />\n        <Links />\n        <ColorSchemeScript />\n        <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n        <link\n          rel=\"preconnect\"\n          href=\"https://fonts.gstatic.com\"\n          crossOrigin=\"\"\n        />\n        <link\n          href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap\"\n          rel=\"stylesheet\"\n        />\n      </head>\n      <body>\n        <MantineProvider theme={theme}>{children}</MantineProvider>\n        <ScrollRestoration />\n        <Scripts />\n      </body>\n    </html>\n  );\n}\n\nexport default function App() {\n  return <Outlet />;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing MantineProvider with React\nDESCRIPTION: This code snippet demonstrates how to initialize MantineProvider at the root of a React application.  MantineProvider is essential for providing the theme context, managing CSS variables, and handling color schemes.  It wraps the entire application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return <MantineProvider>{/* Your app here */}</MantineProvider>;\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Default RichTextEditor Labels in TypeScript\nDESCRIPTION: Shows the default implementation of the `RichTextEditorLabels` interface, available as the `DEFAULT_LABELS` constant exported from `@mantine/tiptap`. This object provides the standard English labels used by the `RichTextEditor` controls when no custom `labels` prop is supplied. It serves as a reference for understanding the default text and for selectively overriding specific labels.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RichTextEditorLabels } from '@mantine/tiptap';\n\nexport const DEFAULT_LABELS: RichTextEditorLabels = {\n  // Controls labels\n  linkControlLabel: 'Link',\n  colorPickerControlLabel: 'Text color',\n  highlightControlLabel: 'Highlight text',\n  colorControlLabel: (color) => `Set text color ${color}`,\n  boldControlLabel: 'Bold',\n  italicControlLabel: 'Italic',\n  underlineControlLabel: 'Underline',\n  strikeControlLabel: 'Strikethrough',\n  clearFormattingControlLabel: 'Clear formatting',\n  unlinkControlLabel: 'Remove link',\n  bulletListControlLabel: 'Bullet list',\n  orderedListControlLabel: 'Ordered list',\n  h1ControlLabel: 'Heading 1',\n  h2ControlLabel: 'Heading 2',\n  h3ControlLabel: 'Heading 3',\n  h4ControlLabel: 'Heading 4',\n  h5ControlLabel: 'Heading 5',\n  h6ControlLabel: 'Heading 6',\n  blockquoteControlLabel: 'Blockquote',\n  alignLeftControlLabel: 'Align text: left',\n  alignCenterControlLabel: 'Align text: center',\n  alignRightControlLabel: 'Align text: right',\n  alignJustifyControlLabel: 'Align text: justify',\n  codeControlLabel: 'Code',\n  codeBlockControlLabel: 'Code block',\n  subscriptControlLabel: 'Subscript',\n  superscriptControlLabel: 'Superscript',\n  unsetColorControlLabel: 'Unset color',\n  hrControlLabel: 'Horizontal line',\n  undoControlLabel: 'Undo',\n  redoControlLabel: 'Redo',\n\n  // Task list\n  tasksControlLabel: 'Task list',\n  tasksSinkLabel: 'Decrease task level',\n  tasksLiftLabel: 'Increase task level',\n\n  // Link editor\n  linkEditorInputLabel: 'Enter URL',\n  linkEditorInputPlaceholder: 'https://example.com/',\n  linkEditorExternalLink: 'Open link in a new tab',\n  linkEditorInternalLink: 'Open link in the same tab',\n  linkEditorSave: 'Save',\n\n  // Color picker control\n  colorPickerCancel: 'Cancel',\n  colorPickerClear: 'Clear color',\n  colorPickerColorPicker: 'Color picker',\n  colorPickerPalette: 'Color palette',\n  colorPickerSave: 'Save',\n  colorPickerColorLabel: (color) => `Set text color ${color}`,\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Border Style with `bd` Prop in Mantine Box (tsx)\nDESCRIPTION: Demonstrates using the `bd` style prop on a Mantine `Box` component to set a 1-pixel solid red border. It utilizes Mantine's theme color system (`red.5`) for the border color and benefits from automatic rem conversion for the border width.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.10.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box bd=\"1px solid red.5\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Import Modal and Dependencies\nDESCRIPTION: Imports the necessary components and modules for using the Modal component within the application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/modal.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ModalDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Rendering AspectRatio Demo Components in JSX\nDESCRIPTION: Renders multiple <Demo> components passing AspectRatioDemos data sets as props to demonstrate different use cases: images, maps, videos, and flex container layouts. Each demo visually illustrates usage of the AspectRatio component maintaining width/height ratios for media embedding. Commentary explains sizing behavior and required style properties within flex containers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/aspect-ratio.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={AspectRatioDemos.image} />\n\n<Demo data={AspectRatioDemos.map} />\n\n<Demo data={AspectRatioDemos.video} />\n\n<Demo data={AspectRatioDemos.flex} />\n```\n\n----------------------------------------\n\nTITLE: Configuring Different z-index Values for Specific AppShell Sections\nDESCRIPTION: Example showing how to set different z-index values for specific sections of the AppShell by applying the zIndex prop to individual components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// AppShell.Header has z-index of 100\n// AppShell.Navbar and AppShell.Aside have z-index of 300\nfunction Demo() {\n  return (\n    <AppShell>\n      <AppShell.Header zIndex={100}>Header</AppShell.Header>\n      <AppShell.Navbar zIndex={300}>Navbar</AppShell.Navbar>\n      <AppShell.Aside zIndex={300}>Aside</AppShell.Aside>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Jest Setup File in JS\nDESCRIPTION: Shows how to add the path to the `jest.setup.js` file in the Jest configuration (`jest.config.js`) using the `setupFilesAfterEnv` array. This ensures the setup file, containing browser API mocks and other setup logic, is executed after the test environment is initialized and before test files are run.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/jest.mdx#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst config = {\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  // ... rest of your config\n};\n```\n\n----------------------------------------\n\nTITLE: Enhancing Accessibility with InputAccessibility\nDESCRIPTION: This snippet highlights the use of the InputAccessibility component to improve the accessibility features, such as ARIA labels and roles, ensuring the DateInput component adheres to accessibility standards for users with disabilities.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\n<InputAccessibility\n  component=\"DateInput\"\n  packageName=\"@mantine/dates\" />\n```\n\n----------------------------------------\n\nTITLE: Using form.initialize to Sync Form with API\nDESCRIPTION: This code demonstrates the use of `form.initialize` to sync form values with the response from an API call. It fetches data using `apiRequest()` and then initializes the form with the fetched data.  Dependencies include `@mantine/core` and `@mantine/form`.  The `form.initialize` method is called within the `onClick` handler of a button.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, NumberInput, TextInput } from '@mantine/core';\nimport { isInRange, isNotEmpty, useForm } from '@mantine/form';\n\ninterface FormValues {\n  name: string;\n  age: number | string;\n}\n\nfunction apiRequest(): Promise<FormValues> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve({ name: 'John Doe', age: 25 });\n    }, 1000);\n  });\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    initialValues: { name: '', age: 0 },\n    validate: {\n      name: isNotEmpty('Name is required'),\n      age: isInRange({ min: 18 }, 'You must be at least 18 to register'),\n    },\n  });\n\n  return (\n    <>\n      <TextInput {...form.getInputProps('name')} label=\"Name\" placeholder=\"Name\" />\n      <NumberInput {...form.getInputProps('age')} label=\"Age\" placeholder=\"Age\" mt=\"md\" />\n      <Button onClick={() => apiRequest().then((values) => form.initialize(values))} mt=\"md\">\n        Initialize form\n      </Button>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Importing RadialBarChart, Layout, and MDX Data (JavaScript)\nDESCRIPTION: This snippet imports necessary modules for rendering the radial bar chart and managing the layout. It imports the `RadialBarChartDemos` for demo data, `Layout` for structuring the page, and `MDX_DATA` which contains the Markdown data related to the RadialBarChart. These imports are fundamental to the React component structure and data handling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/radial-bar-chart.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { RadialBarChartDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Configuring Axis Labels in AreaChart Component with Mantine (TypeScript/TSX)\nDESCRIPTION: This snippet shows how to add 'xAxisLabel' and 'yAxisLabel' properties to the AreaChart component imported from @mantine/charts, allowing developers to label chart axes. The usage presumes the existence of a valid 'data' array and Mantine chart library. Key parameters include chart height (h), dataKey, type, axis labels, and series. The result is an AreaChart with labeled axes and stacked series. Limitations: data must match expected format and component must be rendered in a React/TypeScript project with relevant data and styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.7.0.md#_snippet_6\n\nLANGUAGE: TSX\nCODE:\n```\nimport { AreaChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <AreaChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      type=\"stacked\"\n      xAxisLabel=\"Date\"\n      yAxisLabel=\"Amount\"\n      series=[\n        { name: 'Apples', color: 'indigo.6' },\n        { name: 'Oranges', color: 'blue.6' },\n        { name: 'Tomatoes', color: 'teal.6' },\n      ]\n    />\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring PostCSS with Mantine Preset in JavaScript\nDESCRIPTION: Exports a PostCSS configuration object defining plugins for the project, including 'postcss-preset-mantine' for Mantine compatibility and 'postcss-simple-vars' for CSS variable definitions. It sets breakpoint variables that aid in responsive design. This file should be named 'postcss.config.cjs' and placed at the project root. Dependencies include PostCSS and the specified plugins.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/gatsby.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Assigning Colors from Theme or CSS to BarChart Series in JSX/TypeScript\nDESCRIPTION: Shows assignment of series colors referencing Mantine theme color tokens or any valid CSS color strings via the `color` property inside series objects. Examples include named themes like `blue`, `red.5`, etc. Based on BarChartDemos.color dataset.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_15\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.color} />\n```\n\n----------------------------------------\n\nTITLE: Rendering RadialBarChart Component Using Mantine in TypeScript React\nDESCRIPTION: Illustrates creating a RadialBarChart component from Mantine charts with data consisting of categories and associated values and colors. It imports 'RadialBarChart' from '@mantine/charts' and supplies the chart with 'data' and configuration properties such as 'dataKey', height, and label visibility. The chart visualizes data as radial bars representing distinct data values per category. The input is structured data with names, values, and colors, and the output is a rendered chart component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RadialBarChart } from '@mantine/charts';\n\nconst data = [\n  { name: '18-24', value: 31.47, color: 'blue.7' },\n  { name: '25-29', value: 26.69, color: 'orange.6' },\n  { name: '30-34', value: 15.69, color: 'yellow.7' },\n  { name: '35-39', value: 8.22, color: 'cyan.6' },\n  { name: '40-49', value: 8.63, color: 'green' },\n  { name: '50+', value: 2.63, color: 'pink' },\n  { name: 'unknown', value: 6.67, color: 'gray' },\n];\n\nfunction Demo() {\n  return <RadialBarChart data={data} dataKey=\"value\" h={280} withLabels />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Dropzone MIME_TYPES Constants (TSX)\nDESCRIPTION: Illustrates how to use the predefined MIME_TYPES constants exported from '@mantine/dropzone' to specify accepted file types. This approach improves code readability and avoids hardcoding mime type strings. 'onDrop' is a required prop. Requires importing 'MIME_TYPES'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/dropzone.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Dropzone, MIME_TYPES } from '@mantine/dropzone';\n\nfunction Demo() {\n  return (\n    <Dropzone\n      accept={[\n        MIME_TYPES.png,\n        MIME_TYPES.jpeg,\n        MIME_TYPES.svg,\n        MIME_TYPES.gif,\n      ]}\n      onDrop={() => {}}\n    >\n      {/* children */}\n    </Dropzone>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Disabling TagsInput interaction with disabled\nDESCRIPTION: This code disables user interaction entirely by setting the 'disabled' prop, preventing input and suggestion display, useful in read-only or restricted modes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.disabled} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Container Queries in Carousel Component in TypeScript React\nDESCRIPTION: Shows usage of container queries with Mantine's Carousel component by setting its type to 'container', enabling responsive slide sizes and gaps based on container width instead of viewport. The example wraps Carousel in a resizable div to demonstrate layout changes as container resizes, with customizable slideSize and slideGap properties targeting various width breakpoints. Requires React and @mantine/carousel package. Enhances responsive design flexibility by using container queries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Carousel } from '@mantine/carousel';\n\nfunction Demo() {\n  return (\n    // Wrapper div is added for demonstration purposes only,\n    // It is not required in real projects\n    <div\n      style={{\n        resize: 'horizontal',\n        overflow: 'hidden',\n        maxWidth: '100%',\n        minWidth: 250,\n        padding: 10,\n      }}\n    >\n      <Carousel\n        withIndicators\n        height={200}\n        type=\"container\"\n        slideSize={{ base: '100%', '300px': '50%', '500px': '33.333333%' }}\n        slideGap={{ base: 0, '300px': 'md', '500px': 'lg' }}\n        loop\n        align=\"start\"\n      >\n        <Carousel.Slide>1</Carousel.Slide>\n        <Carousel.Slide>2</Carousel.Slide>\n        <Carousel.Slide>3</Carousel.Slide>\n        {/* ...other slides */}\n      </Carousel>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Global component to CSS files\nDESCRIPTION: Shows how to migrate from Global component in 6.x to a regular CSS file in 7.x for applying global styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { Global } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Global\n      styles={(theme) => ({\n        '*, *::before, *::after': {\n          boxSizing: 'border-box',\n        },\n\n        body: {\n          backgroundColor:\n            theme.colorScheme === 'dark'\n              ? theme.colors.dark[7]\n              : theme.white,\n          color:\n            theme.colorScheme === 'dark'\n              ? theme.colors.dark[0]\n              : theme.black,\n          lineHeight: theme.lineHeight,\n        },\n\n        '.your-class': {\n          backgroundColor: 'red',\n        },\n\n        '#your-id > [data-active]': {\n          backgroundColor: 'pink',\n        },\n      })}\n    />\n  );\n}\n```\n\nLANGUAGE: scss\nCODE:\n```\n/* 7.0 */\n/* src/index.css */\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\nbody {\n  background-color: light-dark(\n    var(--mantine-color-white),\n    var(--mantine-color-dark-7)\n  );\n  color: light-dark(\n    var(--mantine-color-black),\n    var(--mantine-color-white)\n  );\n  line-height: var(--mantine-line-height);\n}\n\n.your-class {\n  background-color: red;\n}\n\n#your-id > [data-active] {\n  background-color: pink;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mantine Table with Compound Components (TSX)\nDESCRIPTION: Illustrates the required use of compound components (`Table.Tr`, `Table.Td`, `Table.Thead`, `Table.Tbody`, `Table.Th`) for the Mantine Table component. This example renders a basic table structure by mapping over an assumed `elements` array. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Table } from '@mantine/core';\n\nfunction Demo() {\n  const rows = elements.map((element) => (\n    <Table.Tr key={element.name}>\n      <Table.Td>{element.position}</Table.Td>\n      <Table.Td>{element.name}</Table.Td>\n      <Table.Td>{element.symbol}</Table.Td>\n      <Table.Td>{element.mass}</Table.Td>\n    </Table.Tr>\n  ));\n\n  return (\n    <Table>\n      <Table.Thead>\n        <Table.Tr>\n          <Table.Th>Element position</Table.Th>\n          <Table.Th>Element name</Table.Th>\n          <Table.Th>Symbol</Table.Th>\n          <Table.Th>Atomic mass</Table.Th>\n        </Table.Tr>\n      </Table.Thead>\n      <Table.Tbody>{rows}</Table.Tbody>\n    </Table>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostCSS Preset Mantine for Auto REM Conversion\nDESCRIPTION: Demonstrates how to enable the `autoRem` option in `postcss-preset-mantine` via the PostCSS configuration file (e.g., `postcss.config.js`). Setting `autoRem: true` instructs the plugin to automatically convert pixel values in CSS properties to `rem` units based on the configured scale, starting from version 1.14.4.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-8-0.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {\n      autoRem: true,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Specifying Value Type with useUncontrolled (TSX)\nDESCRIPTION: Shows how to explicitly define the data type (e.g., `number`) for the state managed by `useUncontrolled` using TypeScript generics. This example sets up the hook with numeric `value`, `defaultValue`, and `finalValue`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-uncontrolled.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useUncontrolled } from '@mantine/hooks';\n\nfunction Demo() {\n  const [_value, handleChange] = useUncontrolled<number>({\n    value: 10,\n    defaultValue: 5,\n    finalValue: 20,\n    onChange: (val) => console.log(val > 10),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Fonts to Mantine Theme with next/font in TypeScript\nDESCRIPTION: This snippet illustrates how to integrate the previously defined local font into a Mantine theme in a Next.js app. It creates a Mantine theme with fontFamily properties set based on the custom font's style data, providing fallbacks to Mantine's default fonts. It requires Mantine core imports and the local font object. The example includes a React component setup with MantineProvider wrapping the app to apply the theme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/next-load-fonts.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport {\n  createTheme,\n  DEFAULT_THEME,\n  MantineProvider,\n} from '@mantine/core';\nimport { greycliffCF } from './GreycliffCF';\n\nconst theme = createTheme({\n  fontFamily: greycliffCF.style.fontFamily,\n  fontFamilyMonospace: 'Monaco, Courier, monospace',\n  headings: {\n    // Use default theme if you want to provide default Mantine fonts as a fallback\n    fontFamily: `${greycliffCF.style.fontFamily}, ${DEFAULT_THEME.fontFamily}`,\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>Your app here</MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: CSS Z-Index Variable Example\nDESCRIPTION: Shows how to use Mantine's z-index CSS variables to control the stacking order of elements. It provides an example of how to display content above a modal using the `--mantine-z-index-modal` variable.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-3-0.mdx#_snippet_4\n\nLANGUAGE: css\nCODE:\n```\n/* Display content above the modal */\n.my-content {\n  z-index: calc(var(--mantine-z-index-modal) + 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Text Component with Span Shorthand in React\nDESCRIPTION: Demonstrates how to use the 'span' prop as a shorthand for 'component=\"span\"' in the Text component, which renders the text as an inline span element instead of the default paragraph element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/text.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Text span>Same as below</Text>\n      <Text component=\"span\">Same as above</Text>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Usage Explanation for useIsFirstRender Hook\nDESCRIPTION: This snippet offers a usage explanation for the 'useIsFirstRender' hook, indicating that the hook returns true on the first render and false thereafter. It references a demo component to illustrate practical application, aiding developers in understanding how to implement and utilize the hook effectively.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-is-first-render.mdx#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n`useIsFirstRender` returns true if the component is being rendered for the first time,\notherwise it returns false.\n\n<Demo data={HooksDemos.useIsFirstRenderUsage} />\n```\n\n----------------------------------------\n\nTITLE: Accessing Theme Outside of Components in Mantine\nDESCRIPTION: This demonstrates how to access the theme outside of components in Mantine. It uses `createTheme`, `DEFAULT_THEME` and `mergeMantineTheme` to create a full theme object. First a theme override is created, and merged with the default theme to construct a complete theme object. The exported theme can be imported anywhere in the application. This enables application-wide theming access.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/theme-object.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// theme.ts\nimport {\n  createTheme,\n  DEFAULT_THEME,\n  mergeMantineTheme,\n} from '@mantine/core';\n\nconst themeOverride = createTheme({\n  primaryColor: 'orange',\n  defaultRadius: 0,\n});\n\nexport const theme = mergeMantineTheme(DEFAULT_THEME, themeOverride);\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Mantine Theme and Title in React\nDESCRIPTION: This snippet configures the Mantine theme to set the text wrap style and then renders a Title component within the theme. It imports the necessary Mantine components for theme creation and Title rendering. The `textWrap` property is set in the theme to wrap the title's text. The Demo component encapsulates this functionality.  It takes no inputs and renders a title with text that should wrap, according to the theme's configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/title.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider, Title } from '@mantine/core';\n\nconst theme = createTheme({\n  headings: {\n    textWrap: 'wrap',\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Title>Some very long title that should wrap</Title>\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Restricting Slider Values to Marks with RangeSlider in TypeScript React\nDESCRIPTION: Demonstrates the restrictToMarks prop in Mantine Slider and RangeSlider components that restricts user selection to predefined marks only. The example shows sliders with marks at set values and default values, limiting slider thumb movement to those marks. Requires React and @mantine/core package. Useful for enforcing discrete selection intervals in sliders.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Slider, RangeSlider, Stack } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Stack>\n      <Slider\n        restrictToMarks\n        defaultValue={25}\n        marks={Array.from({ length: 5 }).map((_, index) => ({ value: index * 25 }))}\n      />\n\n      <RangeSlider\n        restrictToMarks\n        defaultValue={[5, 15]}\n        marks=[\n          { value: 5 },\n          { value: 15 },\n          { value: 25 },\n          { value: 35 },\n          { value: 70 },\n          { value: 80 },\n          { value: 90 },\n        ]\n      />\n    </Stack>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Theme Colors in SCSS\nDESCRIPTION: This code snippet demonstrates how to use the custom colors defined in the theme within SCSS files. It references the custom color scheme \"sepia\" using CSS variables (`--mantine-color-sepia-0` and `--mantine-color-sepia-9`) to set the background and text color for the body.  This allows for applying the defined sepia theme colors to the application's body. There are no direct dependencies in this snippet, as it refers to variables set by the previous TypeScript snippet. The expected output is that the body will have a sepia background and a sepia text color.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/light-dark-is-not-enough.mdx#_snippet_1\n\nLANGUAGE: SCSS\nCODE:\n```\nbody {\n  background-color: var(--mantine-color-sepia-0);\n  color: var(--mantine-color-sepia-9);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Single-Value Color Tuples with colorsTuple\nDESCRIPTION: Demonstrates how to use the colorsTuple utility to create a color palette from a single color value or transform dynamic string arrays into Mantine color tuples.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/colors.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { colorsTuple, createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    custom: colorsTuple('#FFC0CB'),\n    dynamic: colorsTuple(\n      Array.from({ length: 10 }, (_, index) => '#FFC0CB')\n    ),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using HotkeyItem with useHotkeys for Advanced configuration\nDESCRIPTION: This snippet demonstrates how to use the `HotkeyItem` type to predefine hotkeys and pass them to the `useHotkeys` hook.  The example creates an array of `HotkeyItem` objects, including options like `preventDefault` and `usePhysicalKeys`.  This allows for more complex configurations, like using physical key assignments for international keyboard layouts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hotkeys.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { HotkeyItem, useHotkeys } from '@mantine/hooks';\n\nconst hotkeys: HotkeyItem[] = [\n  [\n    'mod+J',\n    () => console.log('Toggle color scheme'),\n    { preventDefault: false },\n  ],\n  ['ctrl+K', () => console.log('Trigger search')],\n  ['alt+mod+shift+X', () => console.log('Rick roll')],\n  [\n    'D',\n    () => console.log('Triggers when pressing \\\"E\\\" on Dvorak keyboards!'),\n    { usePhysicalKeys: true }\n  ],\n];\n\nuseHotkeys(hotkeys);\n```\n\n----------------------------------------\n\nTITLE: Configure PostCSS with Mantine Preset - JavaScript\nDESCRIPTION: This snippet shows the configuration for a `postcss.config.cjs` file, necessary when using Mantine without a framework or in a custom setup. It includes the `postcss-preset-mantine` plugin for Mantine's styling features and `postcss-simple-vars` configured with Mantine's default breakpoints.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/getting-started.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using Primary Color CSS Variables\nDESCRIPTION: This code snippet provides a list of CSS variables for primary colors that are available in the Mantine UI library.  These variables can be used in CSS or SCSS files to customize the primary color scheme of the application.  It does not require a direct code implementation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_19\n\nLANGUAGE: scss\nCODE:\n```\n--mantine-primary-color-0\n--mantine-primary-color-1\n--mantine-primary-color-2\n--mantine-primary-color-3\n--mantine-primary-color-4\n--mantine-primary-color-5\n--mantine-primary-color-6\n--mantine-primary-color-7\n--mantine-primary-color-8\n--mantine-primary-color-9\n--mantine-primary-color-contrast\n--mantine-primary-color-filled\n--mantine-primary-color-filled-hover\n--mantine-primary-color-light\n--mantine-primary-color-light-hover\n--mantine-primary-color-light-color\n```\n\n----------------------------------------\n\nTITLE: Usage with Next.js GetTemplates Component\nDESCRIPTION: Uses a custom <GetTemplates> component with type 'next' to configure or display templates specific to Next.js integration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<GetTemplates type=\"next\" />\n```\n\n----------------------------------------\n\nTITLE: Using colorsTuple function for consistent color palettes in Mantine themes\nDESCRIPTION: Demonstrates how to use the colorsTuple function to either use a single color for all shades or transform dynamic string arrays into Mantine color tuples. The function ensures the array has 10 values for a complete color palette.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-7-0.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { colorsTuple, createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    custom: colorsTuple('#FFC0CB'),\n    dynamic: colorsTuple(\n      Array.from({ length: 10 }, (_, index) => '#FFC0CB')\n    ),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing input props via InputFeatures\nDESCRIPTION: This code demonstrates how to pass additional input-related properties such as styles, placeholder, or event handlers through 'InputFeatures', enabling detailed customization of the input element within TagsInput.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.configurator} />\n```\n\n----------------------------------------\n\nTITLE: Transformed SCSS After Auto REM Conversion\nDESCRIPTION: Illustrates the resulting CSS output after applying the `autoRem` option via `postcss-preset-mantine`. Pixel values in properties like `font-size` are converted into `calc()` expressions using `rem` units and the `--mantine-scale` variable. Note that values within `@media` queries are not automatically converted.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-8-0.mdx#_snippet_2\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  font-size: calc(1rem * var(--mantine-scale));\n\n  @media (min-width: 320px) {\n    font-size: calc(2rem * var(--mantine-scale));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Definition of useSet Hook in TypeScript\nDESCRIPTION: The TypeScript type definition for the useSet hook, which takes an optional array of values of type T and returns a Set<T>. The hook allows using a Set as a React state, where operations like add, clear, and delete trigger state updates.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-set.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useSet<T>(values?: T[]): Set<T>;\n```\n\n----------------------------------------\n\nTITLE: JsonInput Accessibility Features Documentation\nDESCRIPTION: This snippet outlines the inclusion of accessibility features for JsonInput, likely including ARIA attributes and keyboard navigation support to ensure the component is usable by all users. It points out the accessibility considerations and enhancements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n<InputAccessibility component=\"JsonInput\" />\n```\n\n----------------------------------------\n\nTITLE: Declaring Custom Fonts with CSS @font-face\nDESCRIPTION: This CSS snippet declares two custom font variations using the @font-face rule, referencing local .woff2 font files with specified font-weight and font-style attributes. It allows manual font loading without next/font optimizations. The CSS file should be imported into the application root to apply the fonts globally.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/next-load-fonts.mdx#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n@font-face {\n  font-family: 'Greycliff CF';\n  src: url('./GreycliffCF-Bold.woff2') format('woff2');\n  font-weight: 700;\n  font-style: normal;\n}\n\n@font-face {\n  font-family: 'Greycliff CF';\n  src: url('./GreycliffCF-Heavy.woff2') format('woff2');\n  font-weight: 900;\n  font-style: normal;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Popover with Overlay and Customization in TypeScript React\nDESCRIPTION: Demonstrates the new withOverlay prop in Mantine's Popover component which adds a customizable overlay behind the popover dropdown. The example shows a user avatar with a popover containing profile information, using styling properties such as shadow, arrow, zIndex layering, blur overlay effect, and positioning. Requires React and @mantine/core package. Improves UI focus and accessibility by visually separating popover from background.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Anchor, Avatar, Group, Popover, Stack, Text, UnstyledButton } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover\n      width={320}\n      shadow=\"md\"\n      withArrow\n      withOverlay\n      overlayProps={{ zIndex: 10000, blur: '8px' }}\n      zIndex={10001}\n    >\n      <Popover.Target>\n        <UnstyledButton style={{ zIndex: 10001, position: 'relative' }}>\n          <Avatar src=\"https://avatars.githubusercontent.com/u/79146003?s=200&v=4\" radius=\"xl\" />\n        </UnstyledButton>\n      </Popover.Target>\n      <Popover.Dropdown>\n        <Group>\n          <Avatar src=\"https://avatars.githubusercontent.com/u/79146003?s=200&v=4\" radius=\"xl\" />\n          <Stack gap={5}>\n            <Text size=\"sm\" fw={700} style={{ lineHeight: 1 }}>\n              Mantine\n            </Text>\n            <Anchor href=\"https://x.com/mantinedev\" c=\"dimmed\" size=\"xs\" style={{ lineHeight: 1 }}>\n              @mantinedev\n            </Anchor>\n          </Stack>\n        </Group>\n\n        <Text size=\"sm\" mt=\"md\">\n          Customizable React components and hooks library with focus on usability, accessibility and\n          developer experience\n        </Text>\n\n        <Group mt=\"md\" gap=\"xl\">\n          <Text size=\"sm\">\n            <b>0</b> Following\n          </Text>\n          <Text size=\"sm\">\n            <b>1,174</b> Followers\n          </Text>\n        </Group>\n      </Popover.Dropdown>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Options Filtering in Mantine Select with TypeScript\nDESCRIPTION: This TypeScript/React snippet shows how to define a custom filter function for the Mantine Select component using the filter prop. The filter logic splits both the search query and each option into words, returning only options that contain all search words as substrings in their labels. Requires @mantine/core for Select, ComboboxItem, and OptionsFilter types and components. The component expects a data array of option strings and supports case-insensitive, word-based partial matching.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/select-fuzzy.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Select, ComboboxItem, OptionsFilter } from '@mantine/core';\n\nconst optionsFilter: OptionsFilter = ({ options, search }) => {\n  const splittedSearch = search.toLowerCase().trim().split(' ');\n  return (options as ComboboxItem[]).filter((option) => {\n    const words = option.label.toLowerCase().trim().split(' ');\n    return splittedSearch.every((searchWord) => words.some((word) => word.includes(searchWord)));\n  });\n};\n\nfunction Demo() {\n  return (\n    <Select\n      label=\"Your country\"\n      placeholder=\"Pick value\"\n      data={[\"Great Britain\", \"Russian Federation\", \"United States\"]}\n      filter={optionsFilter}\n      searchable\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Mantine Stylelint Configuration\nDESCRIPTION: Provides an alternative `.stylelintrc.json` configuration adjusting numerous rules to match Mantine's styling conventions, allowing extensive customization of linting behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": [\"stylelint-config-standard-scss\"],\n  \"rules\": {\n    \"custom-property-pattern\": null,\n    \"selector-class-pattern\": null,\n    \"scss/no-duplicate-mixins\": null,\n    \"declaration-empty-line-before\": null,\n    \"declaration-block-no-redundant-longhand-properties\": null,\n    \"alpha-value-notation\": null,\n    \"custom-property-empty-line-before\": null,\n    \"property-no-vendor-prefix\": null,\n    \"color-function-notation\": null,\n    \"length-zero-no-unit\": null,\n    \"selector-not-notation\": null,\n    \"no-descending-specificity\": null,\n    \"comment-empty-line-before\": null,\n    \"scss/at-mixin-pattern\": null,\n    \"scss/at-rule-no-unknown\": null,\n    \"value-keyword-case\": null,\n    \"media-feature-range-notation\": null,\n    \"selector-pseudo-class-no-unknown\": [\n      true,\n      {\n        \"ignorePseudoClasses\": [\"global\"]\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Modal.Stack and useModalsStack Hook\nDESCRIPTION: Demonstrates the use of `Modal.Stack` component to render multiple modals at the same time, the code also utilizes the `useModalsStack` hook to manage and control the state and behavior of the modals.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/modal.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Modal, useModalsStack } from '@mantine/core';\n\nfunction Demo() {\n  const stack = useModalsStack(['first', 'second']);\n\n  return (\n    <>\n      <Modal {...stack.register('first')}>First</Modal>\n      <Modal {...stack.register('second')}>Second</Modal>\n      <Button onClick={() => stack.open('first')}>Open first</Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demo: Configuring input props for DateTimePicker\nDESCRIPTION: This example employs the InputFeatures component to customize input-specific properties of the DateTimePicker, such as the input element type and accessibility features.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_6\n\nLANGUAGE: JSX\nCODE:\n```\n<InputFeatures component=\"DateTimePicker\" element=\"button\" />\n```\n\n----------------------------------------\n\nTITLE: Importing Layout and Applying Metadata in JavaScript\nDESCRIPTION: Imports a Layout component and applies it by passing the previously defined meta object as a parameter. This establishes the page layout configuration based on the metadata, facilitating a consistent page structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/vue-svelte-angular.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Changing Body Background Color with CSS\nDESCRIPTION: A simple CSS approach to change the body background color by directly targeting the body element. This method sets a light gray background (#f9f9f9) for the entire page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/body-background.mdx#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\nbody {\n  background-color: #f9f9f9;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Demo of Nested Lists\nDESCRIPTION: Uses a custom `<Demo>` component to showcase nested lists using the Mantine List component, with implementation details sourced from `ListDemos.nested`. The text highlights the `withPadding` and `listStyleType` props for controlling nesting appearance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/list.mdx#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ListDemos.nested} />\n```\n\n----------------------------------------\n\nTITLE: Defining usePrevious Hook in TypeScript\nDESCRIPTION: The TypeScript definition of the usePrevious hook. This hook takes a generic value parameter and returns either that type or undefined. It stores the previous value of a state variable and returns undefined on initial render.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-previous.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction usePrevious<T>(value: T): T | undefined;\n```\n\n----------------------------------------\n\nTITLE: Rendering Unit Labels on Y-Axis and Tooltips in BarChart, JSX/TypeScript\nDESCRIPTION: The `unit` prop renders a label next to y-axis ticks and within tooltips to specify measurement units, improving chart interpretability. Demonstrated with BarChartDemos.unit data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_22\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.unit} />\n```\n\n----------------------------------------\n\nTITLE: CSS reset included in Mantine\nDESCRIPTION: Minimal CSS reset included in @mantine/core that provides basic styles for modern browsers. Additional resets like normalize.css can be included for older browser support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/global-styles.mdx#_snippet_1\n\nLANGUAGE: css\nCODE:\n```\nbody {\n  margin: 0;\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\ninput,\nbutton,\ntextarea,\nselect {\n  font: inherit;\n}\n\nbutton,\nselect {\n  text-transform: none;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostCSS for Mantine with Vite\nDESCRIPTION: Configuration for PostCSS in a Vite project to support Mantine. Sets up postcss-preset-mantine and defines responsive breakpoint variables that Mantine requires for proper styling and responsive behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vite.mdx#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating cache.ts for Emotion in Next.js Pages\nDESCRIPTION: This snippet shows creating a `cache.ts` file that exports a Emotion cache instance for use in Next.js pages router projects.  The cache is created using `createCache` from `@emotion/cache`, and the key is set to 'css'. This is essential for server-side rendering support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport createCache from '@emotion/cache';\n\nexport const emotionCache = createCache({ key: 'css' });\n```\n\n----------------------------------------\n\nTITLE: Using Mantine ColorSwatch with Automatic px-to-rem Conversion in React (TypeScript)\nDESCRIPTION: This React/TypeScript snippet demonstrates how Mantine automatically converts numeric size props (interpreted as px) to rem for components like ColorSwatch. Passing a number to the size prop results in a size scaled from px to rem, while a string value like \"2rem\" can be used directly. Requires @mantine/core. The size prop expects either a number (treated as px) or a string (explicit unit). Outputs a ColorSwatch of equivalent size either way.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rem.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ColorSwatch } from '@mantine/core';\n\nfunction DemoPx() {\n  // Specify ColorSwatch size in px, it will be automatically converted to rem\n  // Width and height of ColorSwatch in this case will be 32px / 16 = 2rem\n  return <ColorSwatch color=\"#000\" size={32} />;\n}\n\nfunction DemoRem() {\n  // This demo will have the same size as previous one\n  return <ColorSwatch color=\"#000\" size=\"2rem\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the useSet Hook\nDESCRIPTION: This TypeScript code example demonstrates the use of the `useSet` hook to manage a set of string values.  It provides an input to add new scopes, preventing duplicates, and displays the scopes. Dependencies include `@mantine/core` and `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { Code, Stack, TextInput } from '@mantine/core';\nimport { useSet } from '@mantine/hooks';\n\nfunction Demo() {\n  const [input, setInput] = useState('');\n  const scopes = useSet<string>(['@mantine', '@mantine-tests', '@mantinex']);\n\n  const isDuplicate = scopes.has(input.trim().toLowerCase());\n\n  const items = Array.from(scopes).map((scope) => <Code key={scope}>{scope}</Code>);\n\n  return (\n    <>\n      <TextInput\n        label=\"Add new scope\"\n        placeholder=\"Enter scope\"\n        description=\"Duplicate scopes are not allowed\"\n        value={input}\n        onChange={(event) => setInput(event.currentTarget.value)}\n        error={isDuplicate && 'Scope already exists'}\n        onKeyDown={(event) => {\n          if (event.nativeEvent.code === 'Enter' && !isDuplicate) {\n            scopes.add(input.trim().toLowerCase());\n            setInput('');\n          }\n        }}\n      />\n\n      <Stack gap={5} align=\"flex-start\" mt=\"md\">\n        {items}\n      </Stack>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CSS Layer Order with @layer Directive in SCSS\nDESCRIPTION: This SCSS snippet illustrates usage of the '@layer' directive to explicitly order CSS layers in projects combining Mantine and other component libraries. The order declared ('base, mantine, components') ensures Mantine styles override 'base' but can themselves be overridden by 'components'. This requires a build pipeline that supports CSS layers and SCSS preprocessing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-1-0.mdx#_snippet_2\n\nLANGUAGE: SCSS\nCODE:\n```\n@layer base, mantine, components;\n```\n\n----------------------------------------\n\nTITLE: Avatar.Group Usage with incorrect wrapping in Mantine\nDESCRIPTION: This code shows an example of how the `Avatar.Group` component should not be used. It's demonstrating incorrect usage where extra HTML elements (`div` tags) are used to wrap the `Avatar` components. This will lead to the avatars not rendering correctly within the group. It's important to avoid wrapping `Avatar` components with additional elements inside `Avatar.Group`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/avatar.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Will not work correctly\nfunction Demo() {\n  return (\n    <Avatar.Group spacing=\"sm\">\n      <div>\n        <Avatar src=\"image.png\" radius=\"xl\" />\n      </div>\n      <Avatar src=\"image.png\" radius=\"xl\" />\n      <Avatar src=\"image.png\" radius=\"xl\" />\n      <Avatar radius=\"xl\">+5</Avatar>\n    </Avatar.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Input with Controlled and Uncontrolled Modes using Mantine and React - TypeScript\nDESCRIPTION: This snippet defines a React functional component, CustomInput, which supports both controlled and uncontrolled usage by leveraging the useUncontrolled hook from @mantine/hooks. It accepts value, defaultValue, and onChange props, allowing integration with form libraries like @mantine/form. Dependencies include @mantine/hooks and React. The component expects string values and calls onChange when the input value changes. It outputs a standard input[type=text] element. Limitations: this component does not directly support error states or additional props required by form libraries unless further extended.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/custom-input-use-form.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useUncontrolled } from '@mantine/hooks';\n\ninterface CustomInputProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n}\n\nfunction CustomInput({\n  value,\n  defaultValue,\n  onChange,\n}: CustomInputProps) {\n  const [_value, handleChange] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: 'Final',\n    onChange,\n  });\n\n  return (\n    <input\n      type=\"text\"\n      value={_value}\n      onChange={(event) => handleChange(event.currentTarget.value)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using TagsInput within a Popover component\nDESCRIPTION: This snippet shows how to embed TagsInput inside a Popover by setting 'withinPortal' to false, enabling the dropdown to render within the existing DOM hierarchy for correct positioning.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.withinPopover} />\n```\n\n----------------------------------------\n\nTITLE: CSS for ActionIcon Component Sizes\nDESCRIPTION: This CSS snippet shows how ActionIcon component's sizes are defined using CSS variables. It sets different sizes for xs, sm, md, lg, and xl. You can override or add new sizes using the Styles API. The components have CSS variables for size, such as --ai-size-xs, --ai-size-sm, --ai-size-md, --ai-size-lg, and --ai-size-xl.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/variants-sizes.mdx#_snippet_1\n\nLANGUAGE: css\nCODE:\n```\n.root {\n  --ai-size-xs: rem(18px);\n  --ai-size-sm: rem(22px);\n  --ai-size-md: rem(28px);\n  --ai-size-lg: rem(34px);\n  --ai-size-xl: rem(44px);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Fixed AppShell Navbar Width in React (TSX)\nDESCRIPTION: Example showing how to set a fixed width for the `AppShell.Navbar` using a number in the `navbar.width` prop, effective only when the viewport is wider than the specified `navbar.breakpoint`. Below the breakpoint, the navbar width defaults to 100%. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// Width is a number, it will be converted to rem\n// and used as width when viewport is larger than theme.breakpoints.sm\nfunction Demo() {\n  return (\n    <AppShell navbar={{ width: 48, breakpoint: 'sm' }}>\n      <AppShell.Navbar>Navbar</AppShell.Navbar>\n    </AppShell>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Mantine Dependencies with npm-check-updates\nDESCRIPTION: Uses npx to run npm-check-updates to automatically update Mantine-related dependencies in package.json. This command targets @mantine/*, @mantinex/*, and postcss-preset-mantine packages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-update-dependencies.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpx npm-check-updates @mantine/* @mantinex/* postcss-preset-mantine -u\n```\n\n----------------------------------------\n\nTITLE: Setting data-mantine-color-scheme Attribute for Disabled JavaScript Support in HTML\nDESCRIPTION: This HTML snippet illustrates how to manually set the data-mantine-color-scheme attribute on the root <html> element to ensure Mantine styles are properly applied when JavaScript is disabled. Since Mantine's automatic addition of this attribute via JavaScript components is unavailable when JS is disabled, defining it manually with either 'light' or 'dark' value is required to avoid broken styles. The snippet emphasizes that the 'auto' scheme is unsupported without JavaScript.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/disabled-js.mdx#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<html data-mantine-color-scheme=\"light\">\n<!-- ... rest of your application -->\n```\n\n----------------------------------------\n\nTITLE: Creating form actions with createFormActions\nDESCRIPTION: Demonstrates how to create a form actions object using the createFormActions function. This requires importing the form values type and specifying the same form name used in useForm.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/actions.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Import type of form values from the file where you defined useForm\nimport { createFormActions } from '@mantine/form';\nimport type { DemoFormValues } from './DemoForm';\n\nexport const demoFormActions =\n  createFormActions<DemoFormValues>('demo-form');\n```\n\n----------------------------------------\n\nTITLE: Rendering Tabular Numbers in Table - Mantine Core with React TypeScript\nDESCRIPTION: Provides an example of using the tabularNums prop on the Table component to render numerical data with equal-width digits via the CSS font-variant-numeric: tabular-nums property. Requires @mantine/core and uses the NumberFormatter component for pretty numeric display. The table aligns columns of product units sold for easy reading.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\nimport { NumberFormatter, Table } from '@mantine/core';\n\nconst data = [\n  { product: 'Apples', unitsSold: 2214411234 },\n  { product: 'Oranges', unitsSold: 9983812411 },\n  { product: 'Bananas', unitsSold: 1234567890 },\n  { product: 'Pineapples', unitsSold: 9948810000 },\n  { product: 'Pears', unitsSold: 9933771111 },\n];\n\nfunction Demo() {\n  const rows = data.map((item) => (\n    <Table.Tr key={item.product}>\n      <Table.Td>{item.product}</Table.Td>\n      <Table.Td>\n        <NumberFormatter value={item.unitsSold} thousandSeparator />\n      </Table.Td>\n    </Table.Tr>\n  ));\n\n  return (\n    <Table tabularNums>\n      <Table.Thead>\n        <Table.Tr>\n          <Table.Th>Product</Table.Th>\n          <Table.Th>Units sold</Table.Th>\n        </Table.Tr>\n      </Table.Thead>\n      <Table.Tbody>{rows}</Table.Tbody>\n    </Table>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useModalsStack Hook Type Interface in TypeScript\nDESCRIPTION: Defines the TypeScript interface for the useModalsStack hook return type, which manages multiple modal states by their unique string IDs. It provides methods to open, close, toggle modals, close all modals, and retrieve props for modal binding. The 'state' property tracks open states of each modal. This interface is essential for typing the hook's returned object in TypeScript, enabling strict type safety and clear API contract.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\ninterface ModalStackReturnType<T extends string> {\n  // Current opened state of each modal\n  state: Record<T, boolean>;\n\n  // Opens modal with the given id\n  open: (id: T) => void;\n\n  // Closes modal with the given id\n  close: (id: T) => void;\n\n  // Toggles modal with the given id\n  toggle: (id: T) => void;\n\n  // Closes all modals within the stack\n  closeAll: () => void;\n\n  // Returns props for modal with the given id\n  register: (id: T) => {\n    opened: boolean;\n    onClose: () => void;\n    stackId: T;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Popover Middlewares in Mantine\nDESCRIPTION: Shows how to pass a configuration object to the `middlewares` prop of the `Popover` component. This allows customizing options for the underlying Floating UI positioning middlewares, such as setting the `padding` for the `shift` middleware to `20`, affecting the component's behavior near viewport boundaries. This approach is applicable to other components based on Popover.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-8-0.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Popover } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover\n      middlewares={{ shift: { padding: 20 } }}\n      position=\"bottom\"\n    >\n      {/* Popover content */}\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Basic BarChart Usage in JSX/TypeScript\nDESCRIPTION: Demonstrates rendering a basic bar chart without specifying the `type` prop, resulting in standard bar chart behavior where each data series is rendered independently. Depends on BarChartDemos.usage data which contains sample data arrays. Utilizes Demo component to instantiate the chart in the documentation UI.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Accessibility enhancements for DateTimePicker\nDESCRIPTION: This snippet provides accessibility features such as ARIA labels or roles for the DateTimePicker to improve usability for assistive technologies, by specifying the component and package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n<InputAccessibility\n  component=\"DateTimePicker\"\n  packageName=\"@mantine/dates\"\n/>\n```\n\n----------------------------------------\n\nTITLE: HTML Output of Button with Sections\nDESCRIPTION: This HTML snippet shows the output of the button with left and right sections.  The `data-position` attributes are applied to the section elements, differentiating the left and right sections. The `data-position` attributes are crucial for targeted styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_5\n\nLANGUAGE: html\nCODE:\n```\n<button>\n  <span class=\"section\" data-position=\"left\">L</span>\n  Label\n  <span class=\"section\" data-position=\"right\">R</span>\n</button>\n```\n\n----------------------------------------\n\nTITLE: Configuring enhanceGetInputProps with Input Options\nDESCRIPTION: This code snippet demonstrates the use of `enhanceGetInputProps` to modify input props based on options passed to `form.getInputProps`.  It uses `@mantine/core` and `@mantine/form`.  When the `fieldType` option is 'name', it sets the `label`, `placeholder`, `withAsterisk`, and `description` properties.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NumberInput, TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\ninterface FormValues {\n  name: string;\n  age: number | string;\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    initialValues: { name: '', age: '' },\n    enhanceGetInputProps: (payload) => {\n      if (payload.options.fieldType === 'name') {\n        return {\n          label: 'Your name',\n          placeholder: 'Your name',\n          withAsterisk: true,\n          description: 'Your personal information is stored securely. (Just kidding!)',\n        };\n      }\n\n      return {};\n    },\n  });\n\n  return (\n    <>\n      <TextInput {...form.getInputProps('name', { fieldType: 'name' })} />\n      <NumberInput {...form.getInputProps('age')} label=\"Age\" placeholder=\"Age\" mt=\"md\" />\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: ColorSwatch Shadow Customization Demo\nDESCRIPTION: Demonstrates how to disable the default inner box-shadow of the ColorSwatch component using the withShadow prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/color-swatch.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ColorSwatchDemos.shadow} />\n```\n\n----------------------------------------\n\nTITLE: Theme Color Customization\nDESCRIPTION: Demonstrates how to customize the default dark color scheme in Mantine by overriding the `theme.colors.dark` values in the `MantineProvider`. It provides the old color values and the code to apply them.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-3-0.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    dark: [\n      '#C1C2C5',\n      '#A6A7AB',\n      '#909296',\n      '#5c5f66',\n      '#373A40',\n      '#2C2E33',\n      '#25262b',\n      '#1A1B1E',\n      '#141517',\n      '#101113',\n    ],\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\nLANGUAGE: scss\nCODE:\n```\n--mantine-color-dark-0: #c9c9c9;\n--mantine-color-dark-1: #b8b8b8;\n--mantine-color-dark-2: #828282;\n--mantine-color-dark-3: #696969;\n--mantine-color-dark-4: #424242;\n--mantine-color-dark-5: #3b3b3b;\n--mantine-color-dark-6: #2e2e2e;\n--mantine-color-dark-7: #242424;\n--mantine-color-dark-8: #1f1f1f;\n--mantine-color-dark-9: #141414;\n```\n\n----------------------------------------\n\nTITLE: Using useStateHistory hook for state management in Mantine\nDESCRIPTION: Shows how to implement the new useStateHistory hook which allows tracking and restoring previous states in React components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-7-0.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={HooksDemos.useStateHistoryUsage} />\n```\n\n----------------------------------------\n\nTITLE: TypeScript Function Signature for useDidUpdate Hook\nDESCRIPTION: This snippet shows the function definition for useDidUpdate, describing its parameters and return type. It accepts a callback effect function and an optional array of dependencies, executing the callback only when dependencies update, excluding component mount.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-did-update.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useDidUpdate(fn: EffectCallback, dependencies?: any[]): void;\n```\n\n----------------------------------------\n\nTITLE: Controlling Value Acceptance on Blur in Mantine TagsInput (TSX)\nDESCRIPTION: Compares the behavior of the `TagsInput` component with `acceptValueOnBlur` set to `true` (default behavior, adds tag on blur) and `false` (only adds tag on Enter key press or suggestion click). Key props shown are `label`, `placeholder`, `data`, and `acceptValueOnBlur`. Dependencies include `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TagsInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <TagsInput\n        label=\"Value IS accepted on blur\"\n        placeholder=\"Enter text, then blur the field\"\n        data={['React', 'Angular', 'Svelte']}\n        acceptValueOnBlur\n      />\n      <TagsInput\n        label=\"Value IS NOT accepted on blur\"\n        placeholder=\"Enter text, then blur the field\"\n        data={['React', 'Angular', 'Svelte']}\n        acceptValueOnBlur={false}\n        mt=\"md\"\n      />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Vertical Variant of Table Component - Mantine Core in React TypeScript\nDESCRIPTION: Demonstrates using the vertical variant of the Table component in Mantine. The variant=\"vertical\" prop enables a vertical orientation with labeled rows, and withTableBorder/layout=\"fixed\" apply visual and structural table style. All required dependencies are provided by @mantine/core. Example displays an epic summary with headings and corresponding values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Table } from '@mantine/core';\n\nexport function Demo() {\n  return (\n    <Table variant=\"vertical\" layout=\"fixed\" withTableBorder>\n      <Table.Tbody>\n        <Table.Tr>\n          <Table.Th w={160}>Epic name</Table.Th>\n          <Table.Td>7.x migration</Table.Td>\n        </Table.Tr>\n\n        <Table.Tr>\n          <Table.Th>Status</Table.Th>\n          <Table.Td>Open</Table.Td>\n        </Table.Tr>\n\n        <Table.Tr>\n          <Table.Th>Total issues</Table.Th>\n          <Table.Td>135</Table.Td>\n        </Table.Tr>\n\n        <Table.Tr>\n          <Table.Th>Total story points</Table.Th>\n          <Table.Td>874</Table.Td>\n        </Table.Tr>\n\n        <Table.Tr>\n          <Table.Th>Last updated at</Table.Th>\n          <Table.Td>September 26, 2024 17:41:26</Table.Td>\n        </Table.Tr>\n      </Table.Tbody>\n    </Table>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @mantinex/shiki with Yarn or NPM\nDESCRIPTION: Commands to install the @mantinex/shiki package using either the Yarn or NPM package managers. This package is necessary for utilizing Shiki-based code highlighting features within Mantine applications. Requires Node.js and either Yarn or NPM to be installed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/shiki/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n# With yarn\nyarn add @mantinex/shiki\n```\n\nLANGUAGE: Bash\nCODE:\n```\n# With npm\nnpm install @mantinex/shiki\n```\n\n----------------------------------------\n\nTITLE: Adding Padding to Paper Component with Style Props in TSX\nDESCRIPTION: Illustrates applying padding using the `p` style prop on the `Paper` component to create inner spacing. This example imports the `Paper` component from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Paper } from '@mantine/core';\n\nfunction Demo() {\n  return <Paper p=\"xl\">My custom card</Paper>;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Bar Size in BarChart – TypeScript/React\nDESCRIPTION: This code demonstrates assigning a minimum bar size in pixels via the 'minBarSize' prop in the Mantine BarChart component. Dependencies are @mantine/charts and React, with the data array structured according to the chart's expectations. Key inputs are chart height, data, data key, and the 'series' prop for each bar. The example enables the legend by setting 'withLegend'. Limitations: bar width may still be affected by available chart space and maxBarWidth, if set.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.13.0.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={data}\n      dataKey=\"month\"\n      withLegend\n      series=[\n        { name: 'Smartphones', color: 'violet.6' },\n        { name: 'Laptops', color: 'blue.6' },\n        { name: 'Tablets', color: 'teal.6' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Button API Improvements and Style API Changes\nDESCRIPTION: Explains removal and renaming of props like 'compact', 'uppercase', 'loaderPosition', and updates to style API selectors for better customization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_18\n\n\n\n----------------------------------------\n\nTITLE: Form name validation examples\nDESCRIPTION: Illustrates valid and invalid form name formats. Form names must contain only letters, numbers, and dashes to work properly with form actions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/actions.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\n// ✅ Valid form name\nconst valid = useForm({\n  name: 'valid-FORM-name-10',\n  mode: 'uncontrolled',\n});\n\n// ❌ Invalid form name: must not contain spaces and special characters\nconst invalid = useForm({\n  name: 'invalid_form name',\n  mode: 'uncontrolled',\n});\n```\n\n----------------------------------------\n\nTITLE: Client-side code causing hydration mismatch by setting data-mantine-color-scheme\nDESCRIPTION: JavaScript snippet that executes before hydration, reading user's system preferences and local storage to set the 'data-mantine-color-scheme' attribute on the document element, leading to mismatch warnings if not coordinated properly with server-rendered HTML.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ntry {\n  var _colorScheme = window.localStorage.getItem(\"mantine-color-scheme-value\");\n  var colorScheme = _colorScheme === \"light\" || _colorScheme === \"dark\" || _colorScheme === \"auto\" ? _colorScheme : \"light\";\n  var computedColorScheme = colorScheme !== \"auto\" ? colorScheme : window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n  document.documentElement.setAttribute(\"data-mantine-color-scheme\", computedColorScheme);\n} catch (e) {}\n```\n\n----------------------------------------\n\nTITLE: Rendering Mantine Affix Usage Demo - MDX\nDESCRIPTION: This MDX snippet renders a demonstration component (`Demo`) specifically for showcasing the usage of the Mantine Affix component. It passes the predefined usage example data (`AffixDemos.usage`) to the `Demo` component, which is responsible for displaying the interactive demo and its corresponding code.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/affix.mdx#_snippet_2\n\nLANGUAGE: MDX\nCODE:\n```\n<Demo data={AffixDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Notifications Component Wrapping Application in React\nDESCRIPTION: This snippet illustrates the common mistake of wrapping the entire application with the Notifications component, which is unsupported because Notifications does not accept children. It demonstrates the incorrect implementation where Notifications is used as a parent wrapper, leading to a blank screen issue.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/notifications-empty-screen.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\nimport { Notifications } from '@mantine/notifications';\n\nfunction Demo() {\n  return (\n    <MantineProvider>\n      <Notifications>\n        <App />\n      </Notifications>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Mantine Theme Size Types\nDESCRIPTION: Shows how to extend Mantine theme sizing properties like spacing and radius through type declaration file customization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  DefaultMantineSize,\n  MantineThemeSizesOverride,\n} from '@mantine/core';\n\ntype ExtendedCustomSpacing =\n  | 'myCustomSpacing'\n  | 'anotherCustomSpacing'\n  | DefaultMantineSize;\n\ntype ExtendedCustomRadius =\n  | 'myCustomRadius'\n  | DefaultMantineSize;\n\ndeclare module '@mantine/core' {\n  export interface MantineThemeSizesOverride {\n    spacing: Record<ExtendedCustomSpacing, string>;\n    radius: Record<ExtendedCustomRadius, string>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hover Styles with hover Mixin - CSS\nDESCRIPTION: Illustrates how to create hover styles using the `hover` mixin, which handles hover and active states across different devices and interaction modes. The mixin generates media queries for devices that support hover and those that do not, applying appropriate pseudo-classes for each scenario to ensure consistent user experience.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_5\n\nLANGUAGE: CSS\nCODE:\n```\n.demo {\n  @mixin hover {\n    color: orange;\n  }\n}\n```\n\nLANGUAGE: CSS\nCODE:\n```\n@media (hover: hover) {\n  .demo:hover {\n    color: orange;\n  }\n}\n\n@media (hover: none) {\n  .demo:active {\n    color: orange;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Attempting Autocomplete with Value/Label Object Data in TypeScript\nDESCRIPTION: Illustrates an improper usage example where Autocomplete is given data as an array of objects containing value and label properties, which is unsupported. The snippet highlights the ambiguity that arises when users input free text or select predefined labels, making the logging or value interpretation unclear. Dependencies include mantine/core and basic React setup. The input is an array of objects with value/label keys, and the onChange logs the selection string. This example serves as a conceptual reference rather than recommended code.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/autocomplete-value-label.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Autocomplete } from '@mantine/core';\n\nconst data = [\n  { value: '18361', label: 'React' },\n  { value: '09411', label: 'Vue' },\n];\n\nfunction Demo() {\n  return (\n    <Autocomplete data={data} onChange={(val) => console.log(val)} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting z-index for All AppShell Sections\nDESCRIPTION: Example demonstrating how to set the z-index for all AppShell sections simultaneously by configuring the zIndex prop on the parent AppShell component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// All sections will have z-index of 200\nfunction Demo() {\n  return <AppShell zIndex={200}>{/* AppShell content */}</AppShell>;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Grid and Text Colors using Props in Mantine BubbleChart (TSX)\nDESCRIPTION: This snippet demonstrates how to set the grid line and text colors of the BubbleChart component directly using the `gridColor` and `textColor` props. This method is suitable when CSS variables or color scheme dependent styling is not required. The example also shows common props like data, range, label, and dataKey.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bubble-chart.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { BubbleChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BubbleChart\n      gridColor=\"gray.5\"\n      textColor=\"gray.9\"\n      h={60}\n      data={data}\n      range={[16, 225]}\n      label=\"Sales/hour\"\n      color=\"lime.6\"\n      dataKey={{ x: 'hour', y: 'index', z: 'value' }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Changing Line Width in Burger Component\nDESCRIPTION: This snippet demonstrates how to customize the line width of the Burger component through a demo. It showcases how to modify visual styling parameters for the component to suit design requirements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/burger.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={BurgerDemos.lineWidth} />\n```\n\n----------------------------------------\n\nTITLE: Adding Value Labels to BarChart in Mantine Charts\nDESCRIPTION: Demonstrates how to use the new withBarValueLabel prop on the BarChart component to display formatted value labels on top of each bar in the chart.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.9.0.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={data}\n      dataKey=\"month\"\n      valueFormatter={(value) => new Intl.NumberFormat('en-US').format(value)}\n      withBarValueLabel\n      series={[\n        { name: 'Smartphones', color: 'violet.6' },\n        { name: 'Laptops', color: 'blue.6' },\n        { name: 'Tablets', color: 'teal.6' },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using a custom color scheme manager in MantineProvider (TypeScript)\nDESCRIPTION: This snippet shows how to use a custom color scheme manager, such as the localStorage manager, with MantineProvider to control color scheme persistence and synchronization across tabs or components. It highlights dependency on the `MantineColorSchemeManager` interface.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\nimport { localStorageColorSchemeManager } from './localStorageColorSchemeManager';\n\nconst colorSchemeManager = localStorageColorSchemeManager({\n  key: 'my-color-scheme',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider colorSchemeManager={colorSchemeManager}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Carousel (Bash)\nDESCRIPTION: This snippet provides the necessary commands to install the `@mantine/carousel` package along with its peer dependencies (`@mantine/core`, `@mantine/hooks`) using either `yarn` or `npm`. These packages are essential prerequisites for using the Mantine carousel component in a project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/carousel/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/core @mantine/hooks @mantine/carousel\n\n# With npm\nnpm install @mantine/core @mantine/hooks @mantine/carousel\n```\n\n----------------------------------------\n\nTITLE: Using Redirect Component in JSX\nDESCRIPTION: Utilizes the imported `Redirect` component to perform a client-side redirect to the specified URL. The target URL is passed via the `to` prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/modals.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Redirect to=\"/x/modals\" />\n```\n\n----------------------------------------\n\nTITLE: Using renderRoot with React Router NavLink (TSX)\nDESCRIPTION: Shows how to integrate a Mantine `Button` with `react-router-dom`'s `NavLink`, which uses a function for its `className` prop to handle active states. The `renderRoot` prop is necessary to correctly pass props and apply conditional classes using `cx` based on `isActive`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport cx from 'clsx';\nimport { NavLink } from 'react-router-dom';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      renderRoot={({ className, ...others }) => (\n        <NavLink\n          className={({ isActive }) =>\n            cx(className, { 'active-class': isActive })\n          }\n          {...others}\n        />\n      )}\n    >\n      React router NavLink\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useUncontrolled Hook\nDESCRIPTION: Provides the TypeScript interface `UseUncontrolledInput<T>` which defines the accepted parameters (`value`, `defaultValue`, `finalValue`, `onChange`) for the hook, and the function signature showing the returned tuple: the current value (`T`), the change handler function `(value: T) => void`, and a boolean indicating if the component is controlled.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-uncontrolled.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ninterface UseUncontrolledInput<T> {\n  /** Value for controlled state */\n  value?: T;\n\n  /** Initial value for uncontrolled state */\n  defaultValue?: T;\n\n  /** Final value for uncontrolled state when value and defaultValue are not provided */\n  finalValue?: T;\n\n  /** Controlled state onChange handler */\n  onChange?: (value: T) => void;\n}\n\nfunction useUncontrolled<T>(input: UseUncontrolledInput<T>): [\n  T, // current value\n  (value: T) => void, // onChange function\n  boolean, // value that indicates if input is controlled or not\n];\n```\n\n----------------------------------------\n\nTITLE: Exporting Layout-Wrapped Divider MDX Content Using React JSX in JavaScript\nDESCRIPTION: This snippet exports the default component by wrapping the Divider MDX content inside the Layout higher-order component. It organizes the page layout and content structure for rendering within a React application, effectively combining static MDX documentation with a dynamic layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/divider.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.Divider);\n```\n\n----------------------------------------\n\nTITLE: Rendering custom suggestion options with renderOption\nDESCRIPTION: This snippet demonstrates how to provide a custom rendering function for suggestion options via 'renderOption', which receives each option object and returns a React node for display, allowing highly customized dropdown options.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.renderOption} />\n```\n\n----------------------------------------\n\nTITLE: Customizing dot appearance and behavior\nDESCRIPTION: Uses 'dotProps' to style all dots in their default state and 'activeDotProps' for active state styling when hovered. Allows precise control over data point indicators.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_22\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.dotProps} />\n```\n\n----------------------------------------\n\nTITLE: Handling Transition End Events in Modal and Drawer\nDESCRIPTION: This snippet illustrates using 'onExitTransitionEnd' and 'onEnterTransitionEnd' callbacks in Modal and Drawer components to execute code after transition animations finish, such as cleanup or data fetching.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={ModalDemos.transitionEnd} />\n```\n\n----------------------------------------\n\nTITLE: Typed Data Example with TreeNodeData\nDESCRIPTION: Demonstrates the use of the `TreeNodeData` type to define and type-check the data structure for the Tree component.  The `data` constant is explicitly typed as `TreeNodeData[]`, enforcing the required structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst data: TreeNodeData[] = [\n  {\n    value: 'src',\n    label: 'src',\n    children: [\n      { value: 'src/components', label: 'components' },\n      { value: 'src/hooks', label: 'hooks' },\n    ],\n  },\n  { value: 'package.json', label: 'package.json' },\n];\n```\n\n----------------------------------------\n\nTITLE: Importing Flex Component Documentation Resources in React\nDESCRIPTION: This code snippet shows the imports needed for the Flex component documentation page, including style props data, demos, and layout components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/flex.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { FLEX_STYLE_PROPS_DATA } from '@mantine/core';\nimport { FlexDemos } from '@docs/demos';\nimport { StylePropsTable } from '@/components/StylePropsTable';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Flex);\n```\n\n----------------------------------------\n\nTITLE: Embedding a Mantine CSS Variables Display Component with MDX and React - JavaScript/JSX\nDESCRIPTION: This JSX snippet demonstrates how to include a descriptive section header and embed the CssVariablesList React component within a documentation page. It requires the CssVariablesList component to be previously imported and available in scope. The component renders a comprehensive list of Mantine theme variables, and the surrounding Markdown/MDX header provides context for users. Inputs and outputs are static with a focus on visual presentation; customizable content or dynamic interaction is not supported in this usage.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables-list.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n# Default CSS variables list\n\nThis page contains a list of all Mantine CSS variables that are generated from default theme.\n\n<CssVariablesList />\n```\n\n----------------------------------------\n\nTITLE: Generating a New RedwoodJS Application (Bash)\nDESCRIPTION: Creates a new RedwoodJS project named 'my-redwood-project' with TypeScript support using the `yarn create redwood-app` command. This is the initial step before installing Mantine.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/redwood.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create redwood-app my-redwood-project --typescript\n```\n\n----------------------------------------\n\nTITLE: Locking Scroll with RemoveScroll Component (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `RemoveScroll` component from the `@mantine/core` library to lock scrolling within a specific area of your application.  It wraps the content that should have its scroll locked. The component supports all props from `react-remove-scroll`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-lock-scroll.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { RemoveScroll } from '@mantine/core';\n\nfunction App() {\n  return (\n    <RemoveScroll>\n      <div>Content</div>\n    </RemoveScroll>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining useMutationObserver Hook Signature in TypeScript\nDESCRIPTION: This snippet provides the TypeScript signature for the `useMutationObserver` React hook. It shows the expected types for the `callback` (a `MutationCallback`), `options` (a `MutationObserverInit` object), and an optional `target` element, which can be an `HTMLElement`, a function returning an `HTMLElement`, or `null`. The hook returns a `RefObject` pointing to the element being observed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mutation-observer.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useMutationObserver<Element extends HTMLElement>(\n  callback: MutationCallback,\n  options: MutationObserverInit,\n  target?: HTMLElement | (() => HTMLElement) | null\n): RefObject<Element>;\n```\n\n----------------------------------------\n\nTITLE: Exporting Layout with Metadata in Mantine Documentation\nDESCRIPTION: Wraps the documentation content in a layout component, passing the meta object for standardized page rendering with relevant metadata, contributing to consistent UI/UX across documentation pages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/multiselect-value-placeholder.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Formatting values with 'valueFormat' function\nDESCRIPTION: Provides a function via 'valueFormat' prop to format Y-axis and tooltip values, enabling custom display formats like currency, percentages, etc. improves data presentation clarity.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.valueFormatter} />\n```\n\n----------------------------------------\n\nTITLE: Install Mantine Code Highlight with NPM\nDESCRIPTION: Installs the @mantine/hooks, @mantine/core and @mantine/code-highlight packages using npm package manager. These packages are required for using the Mantine code highlight component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/code-highlight/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @mantine/hooks @mantine/core @mantine/code-highlight\n```\n\n----------------------------------------\n\nTITLE: React 18+ Compatibility Enforcement in Mantine\nDESCRIPTION: Mentions that starting from version 7.0, Mantine now requires React 18 or higher due to hooks like useId and useSyncExternalStore, ensuring compatibility and leveraging React's latest features.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Passing Custom Props to XAxis and YAxis in BarChart, JSX/TypeScript\nDESCRIPTION: Illustrates customizing X and Y axis components from Recharts by passing `xAxisProps` and `yAxisProps`. Enables changes like axis orientation or domain adjustments. Relies on BarChartDemos.axisProps dataset.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_10\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.axisProps} />\n```\n\n----------------------------------------\n\nTITLE: Using form.getInputProps with Mantine Inputs (TypeScript)\nDESCRIPTION: Demonstrates how to use the `form.getInputProps` handler from the `@mantine/form` hook to bind standard Mantine components like `TextInput` and `Checkbox` to the form state. It shows passing the field name ('name', 'accepted') and options like `{ type: 'checkbox' }` to correctly handle different input types. The returned props (value, onChange, onFocus, onBlur, error) are spread onto the respective input components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/get-input-props.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Checkbox, TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { name: '', accepted: false },\n    validate: {\n      name: (value) => value.trim().length > 2,\n    },\n  });\n\n  return (\n    <>\n      <TextInput\n        key={form.key('name')}\n        {...form.getInputProps('name')}\n      />\n      <Checkbox\n        key={form.key('accepted')}\n        {...form.getInputProps('accepted', { type: 'checkbox' })}\n      />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the useEventListener Hook in React (TypeScript)\nDESCRIPTION: Defines a generic TypeScript hook named useEventListener that attaches an event listener to a DOM element associated with a provided ref. The hook takes the event type (as a key of HTMLElementEventMap), a listener function receiving the event, and optional event listener options (either boolean or AddEventListenerOptions). On component unmount, the event listener is automatically removed to avoid memory leaks or duplicated listeners. Required dependencies are React and appropriate type definitions. Expected input parameters are the event type string, a callback function, and optional settings; the hook returns a mutable ref to the target element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-event-listener.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nfunction useEventListener<\n  K extends keyof HTMLElementEventMap,\n  T extends HTMLElement = any,\n>(\n  type: K,\n  listener: (this: HTMLDivElement, ev: HTMLElementEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n): MutableRefObject<T>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Container Queries in Mantine's SimpleGrid for Responsive Layouts\nDESCRIPTION: This snippet illustrates the use of container queries with Mantine's SimpleGrid, allowing grid columns and spacing to adapt based on the container's width rather than the viewport. The example wraps the grid in a resizable div to demonstrate dynamic adjustments, with configuration objects specifying breakpoints and spacing values for different container widths. Dependencies include SimpleGrid from Mantine core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.10.0.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { SimpleGrid } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    // Wrapper div is added for demonstration purposes only,\n    // it is not required in real projects\n    <div style={{ resize: 'horizontal', overflow: 'hidden', maxWidth: '100%' }}>\n      <SimpleGrid\n        type=\"container\"\n        cols={{ base: 1, '300px': 2, '500px': 5 }}\n        spacing={{ base: 10, '300px': 'xl' }}\n      >\n        <div>1</div>\n        <div>2</div>\n        <div>3</div>\n        <div>4</div>\n        <div>5</div>\n      </SimpleGrid>\n    </div>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using color manipulation functions alpha and lighten with CSS variables and OKLCH in TypeScript\nDESCRIPTION: Demonstrates the usage of improved color functions 'alpha' and 'lighten' from @mantine/core which now support CSS variables and OKLCH colors. The snippet shows how to import the functions and apply them to hex colors and CSS variables, returning valid CSS color expressions (standard RGBA or CSS color-mix). Requires @mantine/core and TypeScript environment. These functions replace older implementations to provide wider color model compatibility.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { alpha, lighten } from '@mantine/core';\n\nalpha('#4578FC', 0.45); // -> rgba(69, 120, 252, 0.45)\nalpha('var(--mantine-color-gray-4)', 0.74);\n// -> color-mix(in srgb, var(--mantine-color-gray-4), transparent 26%)\n\nlighten('#4578FC', 0.45); // -> #a3c1ff\nlighten('var(--mantine-color-gray-4)', 0.74);\n// -> color-mix(in srgb, var(--mantine-color-gray-4), white 74%)\n```\n\n----------------------------------------\n\nTITLE: Importing UnstyledButton Documentation Components\nDESCRIPTION: Imports the necessary components for displaying UnstyledButton documentation, including demos, layout components, and MDX data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/unstyled-button.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { UnstyledButtonDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Importing Layout and MDX Data in TypeScript\nDESCRIPTION: This snippet imports the `Layout` component and `MDX_DATA` from their respective modules. The `Layout` component is likely a wrapper for the content, and `MDX_DATA` contains data needed for rendering the documentation, specifically for the 'GettingStartedCharts' section.  This sets up the page structure and loads relevant content for the Mantine Charts getting started guide.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/getting-started.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.GettingStartedCharts);\n```\n\n----------------------------------------\n\nTITLE: Starting the React Router Development Server (Bash)\nDESCRIPTION: Shows the command to start the development server for the React Router application after completing the Mantine setup. This command typically compiles the application and makes it available for development and testing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/react-router.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Defining Meta Information for Documentation Page\nDESCRIPTION: Creates a metadata object containing the page title, description, URL slug, category, tags, and timestamps for creation and last update. This metadata structures and describes the documentation content for rendering and search purposes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/multiselect-value-placeholder.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const meta = {\n  title: 'Can I remove MultiSelect placeholder when the component has selected values?',\n  description: 'Learn why MultiSelect placeholder is not removed when values are selected and how to remove it with CSS',\n  slug: 'multiselect-value-placeholder',\n  category: 'components',\n  tags: ['multi-select', 'placeholder'],\n  created_at: 'July 23, 2024',\n  last_updated_at: 'July 23, 2024'\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Mantine Switch Input Element with useRef in TSX\nDESCRIPTION: Demonstrates how to obtain a direct reference to the underlying `HTMLInputElement` of a Mantine `Switch` component using the `useRef` hook in React. The `ref` is passed directly to the `Switch` component's `ref` prop. Requires `react` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/switch.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useRef } from 'react';\nimport { Switch } from '@mantine/core';\n\nfunction Demo() {\n  const ref = useRef<HTMLInputElement>(null);\n  return <Switch ref={ref} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Mantine Dropzone Component Ref (TSX)\nDESCRIPTION: Demonstrates how to obtain a React ref for the Dropzone component using the 'ref' prop and the 'useRef' hook. This allows direct access to the underlying DOM element for actions like focusing or imperative control. Requires importing 'useEffect' and 'useRef'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/dropzone.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect, useRef } from 'react';\nimport { Dropzone } from '@mantine/dropzone';\n\nfunction Demo() {\n  const dropzoneRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    dropzoneRef.current?.focus();\n  }, []);\n\n  return (\n    <Dropzone ref={dropzoneRef} onDrop={() => {}}>\n      {/* children */}\n    </Dropzone>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Mantine z-index CSS Variables (CSS)\nDESCRIPTION: Demonstrates how to use Mantine's new z-index CSS custom properties to control layering. This snippet places .my-content above a modal by calculating z-index based on the --mantine-z-index-modal variable. Requires Mantine's CSS variables present in the document.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_13\n\nLANGUAGE: css\nCODE:\n```\n/* Display content above the modal */\n.my-content {\n  z-index: calc(var(--mantine-z-index-modal) + 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding units to axis and tooltip values\nDESCRIPTION: Displays measurement units next to Y-axis ticks and tooltip values using the 'unit' prop, improving clarity with context such as 'USD', '%', or 'kg'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_19\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.unit} />\n```\n\n----------------------------------------\n\nTITLE: Using useLocalStorage with SuperJSON for Advanced Types in React\nDESCRIPTION: Shows how to integrate the SuperJSON library with useLocalStorage hook to handle complex JavaScript types like Date, Map, Set, and BigInt that are not supported by standard JSON serialization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport superjson from 'superjson';\nimport { useLocalStorage } from '@mantine/hooks';\n\nconst defaultValue = { name: 'John', age: 25 };\n\nconst [value, setValue] = useLocalStorage({\n  key: 'data',\n  defaultValue,\n  serialize: superjson.stringify,\n  deserialize: (str) =>\n    str === undefined ? defaultValue : superjson.parse(str),\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Stepper.Step Component Wrapping in React\nDESCRIPTION: Explains the limitations of wrapping Stepper.Step components and provides the correct approach for rendering custom content within steps. The Stepper relies on direct Stepper.Step children order.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/stepper.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Stepper } from '@mantine/core';\n\n// This will not work, step children will not render\nfunction WillNotWork() {\n  return (\n    <Stepper.Step label=\"Nope\" description=\"It will not work\">\n      This part will not render\n    </Stepper.Step>\n  );\n}\n\n// Create a separate component for children\nfunction WillWork() {\n  return <div>This will work as expected!</div>;\n}\n\nfunction Demo() {\n  return (\n    <Stepper active={1}>\n      <Stepper.Step label=\"Regular step\">First step</Stepper.Step>\n      {/* Wrapped Stepper.Step will not render children, do not do that */}\n      <WillNotWork />\n      <Stepper.Step label=\"Step with custom content\">\n        <WillWork />\n      </Stepper.Step>\n      <Stepper.Step label=\"Regular step\">Third step</Stepper.Step>\n    </Stepper>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Offset to Drawer Component (Mantine, TypeScript)\nDESCRIPTION: Shows new 'offset' prop for the Mantine Drawer component, which controls the distance from the viewport edge. Requires '@mantine/core', '@mantine/hooks', and useDisclosure for visibility management. Demonstrates opening and closing the drawer and passing custom radius.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Drawer } from '@mantine/core';\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const [opened, { open, close }] = useDisclosure(false);\n\n  return (\n    <>\n      <Drawer offset={8} radius=\"md\" opened={opened} onClose={close} title=\"Authentication\">\n        {/* Drawer content */}\n      </Drawer>\n\n      <Button onClick={open}>Open Drawer</Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Tooltip and Axis Values in BarChart, JSX/TypeScript\nDESCRIPTION: Utilizes the `valueFormat` prop that accepts a callback function to format numeric values displayed in tooltips and axis ticks, allowing customized numeric or string representation. Demonstrated with BarChartDemos.valueFormatter data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_14\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.valueFormatter} />\n```\n\n----------------------------------------\n\nTITLE: PieChart Stroke Color Configuration – TypeScript\nDESCRIPTION: This snippet demonstrates how to customize the stroke color of segments in a Mantine PieChart component using the `strokeColor` prop. It imports the `PieChart` component from `@mantine/charts` and sets the stroke color to `red.5` from the theme. The `data` prop is passed with an empty array, implying the chart will be rendered with no actual data points until provided.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/pie-chart.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PieChart } from '@mantine/charts';\n\nfunction Demo() {\n  return <PieChart data={[]} strokeColor=\"red.5\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Axis Label Display in ScatterChart – TypeScript/React\nDESCRIPTION: This example demonstrates the ScatterChart component's support for displaying labels on point axes via the 'pointLabels' prop. Requires @mantine/charts, a data array, and React. Important parameters include 'dataKey' for mapping data fields to x and y axes, 'xAxisLabel' and 'yAxisLabel' for labeling, and 'pointLabels' for specifying which axis to label (e.g., 'x'). The chart renders points with axis labels as configured. The data prop must match the fields referenced in 'dataKey'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.13.0.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ScatterChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <ScatterChart\n      h={350}\n      data={data}\n      dataKey={{ x: 'age', y: 'BMI' }}\n      xAxisLabel=\"Age\"\n      yAxisLabel=\"BMI\"\n      pointLabels=\"x\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Component Classes\nDESCRIPTION: This demonstrates how to access the CSS classes of Mantine components.  By importing `Button` from '@mantine/core', the `Button.classes` object can be used to retrieve the names of CSS classes associated with the various parts of the button component.  This allows for creating custom components and applying existing Mantine styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return <button type=\"button\" className={Button.classes.root} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Transformed Values Type with TypeScript\nDESCRIPTION: Demonstrates how to get the type of transformed values using TransformedValues type. Useful when creating a custom submit function that needs to handle the transformed data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TransformedValues, useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      name: '',\n      locationId: '2',\n    },\n\n    transformValues: (values) => ({\n      ...values,\n      locationId: Number(values.locationId),\n    }),\n  });\n\n  type Transformed = TransformedValues<typeof form>;\n  // -> { name: string, locationId: number }\n\n  const handleSubmit = (values: TransformedValues<typeof form>) => {};\n\n  return <form onSubmit={form.onSubmit(handleSubmit)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting MDX Remix Page with Layout in React - TypeScript/JavaScript\nDESCRIPTION: This snippet demonstrates how to export a default React component by invoking a higher-order Layout function with Remix-specific MDX documentation content. It imports the Layout component and MDX data object, then calls Layout with the Remix property from MDX_DATA as an argument. Expected inputs include valid React components and structured MDX documentation data; the output is a page-level React component ready for use in a Next.js or similar React application. The snippet assumes that @/layout and @/mdx are available module paths and that MDX_DATA.Remix contains the relevant content to be displayed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/remix.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Remix);\n```\n\n----------------------------------------\n\nTITLE: Simulating Mantine's light-dark Function for Color Schemes in CRA - SCSS\nDESCRIPTION: This SCSS snippet replaces Mantine's light-dark() helper with manual attribute selectors compatible with CRA. It shows both an example that does not work (using the light-dark function) and the supported alternative with explicit styles for light and dark color schemes. No external dependencies required. Input is a component style definition; output is color adaptation based on color scheme. Limitation: cannot use Mantine's light-dark SCSS helper.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/can-i-use-mantine-with-cra.mdx#_snippet_2\n\nLANGUAGE: scss\nCODE:\n```\n// ❌ Does not work with Create React App\n.demo {\n  color: light-dark(red, blue);\n}\n\n// ✅ Works with Create React App\n[data-mantine-color-scheme='light'] .demo {\n  color: red;\n}\n\n[data-mantine-color-scheme='dark'] .demo {\n  color: blue;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Combining Refs Dynamically with mergeRefs Utility (TypeScript)\nDESCRIPTION: This example uses Mantine's mergeRefs utility function to combine refs without memoization, suitable for dynamic component lists or conditional refs in React. It avoids hook memoization to prevent inconsistent hook calls across renders. Dependencies include react and @mantine/hooks. You can pass any number of refs, with mergedRef passed to a DOM node as the ref prop. Note: mergeRefs should not be used with useFocusTrap, as stated in the documentation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-merged-ref.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useRef } from 'react';\nimport { mergeRefs, useClickOutside } from '@mantine/hooks';\n\nfunction Demo() {\n  const myRef = useRef();\n  const useClickOutsideRef = useClickOutside(() => {});\n  const mergedRef = mergeRefs(myRef, useClickOutsideRef);\n  return <div ref={mergedRef} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering the Main LineChart with Layout and MDX data\nDESCRIPTION: Exports the default component that renders the line chart within the layout, passing the MDX data for display. Dependencies include layout components and MDX data. Sets up the overall chart page structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { LineChartDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.LineChart);\n```\n\n----------------------------------------\n\nTITLE: Configuring postcss-preset-mantine Features in JavaScript\nDESCRIPTION: Configuration options for disabling specific features in postcss-preset-mantine v1.17.0+. Options include disabling the light-dark function, nested CSS, color manipulation functions, rem/em functions, and mixins.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-12-0.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nmodule.exports = {\n  'postcss-preset-mantine': {\n    features: {\n      // Turn off `light-dark` function\n      lightDarkFunction: false,\n\n      // Turn off `postcss-nested` plugin\n      nested: false,\n\n      // Turn off `lighten`, `darken` and `alpha` functions\n      colorMixAlpha: false,\n\n      // Turn off `rem` and `em` functions\n      remEmFunctions: false,\n\n      // Turn off `postcss-mixins` plugin\n      mixins: false,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Example of Mantine Components in Server Components\nDESCRIPTION: Highlights that Mantine components use context and cannot be used directly in server components unless using 'use client' or component syntax like 'ComponentXXX'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Popover } from '@mantine/core';\n\n// This will throw an error\nexport default function Page() {\n  return (\n    <Popover>\n      <Popover.Target>Target</Popover.Target>\n      <Popover.Dropdown>Dropdown</Popover.Dropdown>\n    </Popover>\n  );\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n'use client';\n\nimport { Popover } from '@mantine/core';\n\n// No error\nexport default function Page() {\n  return (\n    <Popover>\n      <Popover.Target>Target</Popover.Target>\n      <Popover.Dropdown>Dropdown</Popover.Dropdown>\n    </Popover>\n  );\n}\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {\n  Popover,\n  PopoverDropdown,\n  PopoverTarget,\n} from '@mantine/core';\n\n// No error\nexport default function Page() {\n  return (\n    <Popover>\n      <PopoverTarget>Trigger</PopoverTarget>\n      <PopoverDropdown>Dropdown</PopoverDropdown>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Redirect Component in JSX\nDESCRIPTION: Imports the Redirect component and uses it to redirect users to the new NProgress component location at '/x/nprogress'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/nprogress.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n\n<Redirect to=\"/x/nprogress\" />\n```\n\n----------------------------------------\n\nTITLE: Using ElementProps Utility Type in TypeScript\nDESCRIPTION: Demonstrates the ElementProps utility type for handling native element props with Mantine-specific features like style prop override and property omission.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ButtonProps, ElementProps } from '@mantine/core';\n\n// Equivalent of `React.ComponentPropsWithoutRef<'button'>`\ntype ButtonElementProps = ElementProps<'button'>;\n\n// Equivalent of `Omit<React.ComponentPropsWithoutRef<'button'>, 'color' | 'onClick'>`\ntype OmitColor = ElementProps<'button', 'color' | 'onClick'>;\n\n// Removes all Mantine component props from React component props\n// to avoid props types conflicts\n// Equivalent of `Omit<React.ComponentPropsWithoutRef<'button'>, keyof ButtonProps>`\ntype OmitButtonProps = ElementProps<'button', keyof ButtonProps>;\n```\n\n----------------------------------------\n\nTITLE: Using Pagination with Only Previous and Next Buttons (withPages=false) in TypeScript React\nDESCRIPTION: Illustrates usage of the withPages prop in Mantine's Pagination component to hide numbered page controls, showing only previous and next buttons. The example includes state for current page, calculates total pages from total items and page limit, and displays a message about the current range being shown. Requires React and @mantine/core package. Suitable for simpler pagination UIs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.16.0.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Group, Pagination, Text } from '@mantine/core';\n\nconst limit = 10;\nconst total = 145;\nconst totalPages = Math.ceil(total / limit);\n\nfunction Demo() {\n  const [page, setPage] = useState(1);\n  const message = `Showing ${limit * (page - 1) + 1} – ${Math.min(total, limit * page)} of ${total}`;\n\n  return (\n    <Group justify=\"flex-end\">\n      <Text size=\"sm\">{message}</Text>\n      <Pagination total={totalPages} value={page} onChange={setPage} withPages={false} />\n    </Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Spotlight Instances and Stores in React TypeScript\nDESCRIPTION: Illustrates how to create multiple Spotlight stores and control instances independently using createSpotlight and Spotlight components. Each store-spotlight pair can be used across the app for isolated Spotlight UIs. The example shows opening each Spotlight with separate buttons and rendering Spotlight instances with their respective stores and empty actions arrays.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/spotlight.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\nimport { createSpotlight, Spotlight } from '@mantine/spotlight';\n\n// You can import `firstSpotlight` and `secondSpotlight` anywhere\n// in your application and use `open`, `close` and `toggle` actions\n// to control spotlight the same way as with default `spotlight` object\nexport const [firstStore, firstSpotlight] = createSpotlight();\nexport const [secondStore, secondSpotlight] = createSpotlight();\n\nfunction Demo() {\n  return (\n    <>\n      <Button onClick={firstSpotlight.open}>\n        Open first spotlight\n      </Button>\n      <Button onClick={secondSpotlight.open}>\n        Open second spotlight\n      </Button>\n\n      <Spotlight store={firstStore} actions={[]} />\n      <Spotlight store={secondStore} actions={[]} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom series labels in AreaChart using Mantine Charts in TypeScript\nDESCRIPTION: Demonstrates how to specify custom labels for chart series within the AreaChart component from '@mantine/charts' by using the 'label' property inside the 'series' array objects. This feature supports multi-series charts and controls the label text shown in legends. The example covers a stacked AreaChart with color assignments and legend positioning. Requires a data source matching the dataKey.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AreaChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <AreaChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      type=\"stacked\"\n      withLegend\n      legendProps={{ verticalAlign: 'bottom' }}\n      series=[\n        { name: 'Apples', label: 'Apples sales', color: 'indigo.6' },\n        { name: 'Oranges', label: 'Oranges sales', color: 'blue.6' },\n        { name: 'Tomatoes', label: 'Tomatoes sales', color: 'teal.6' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Button Size with Data Attribute\nDESCRIPTION: This code example shows how to customize a Button's size using the `data-size` attribute. This approach provides a way to define different size variations for components by assigning various values (e.g., 'small', 'medium', 'large') to this attribute. The use of a `data-` attribute allows for styling components based on their attributes in conjunction with CSS.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: TypeScript AccordionProps Example\nDESCRIPTION: Shows TypeScript usage with the Accordion component, specifically demonstrating how to use the `AccordionProps` generic type to specify the `multiple` state.  It defines `MultipleAccordionProps` (multiple=true) and `DefaultAccordionProps` (multiple=false) for type safety.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/accordion.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AccordionProps } from '@mantine/core';\n\ntype MultipleAccordionProps = AccordionProps<true>;\ntype DefaultAccordionProps = AccordionProps<false>;\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Components and Demos\nDESCRIPTION: This snippet imports necessary components and demo modules from the Mantine library. It includes components for rendering UI elements and various demo components for documentation purposes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button } from '@mantine/core';\nimport {\n  CarouselDemos,\n  CodeHighlightDemos,\n  ComboboxDemos,\n  FieldsetDemos,\n  GridDemos,\n  GroupDemos,\n  ImageDemos,\n  InputDemos,\n  LoaderDemos,\n  NumberInputDemos,\n  ProgressDemos,\n  SimpleGridDemos,\n  SpotlightDemos,\n  StylesDemos,\n  TableDemos,\n  TagsInputDemos,\n  ThemingDemos,\n} from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Importing Demo and Layout Components\nDESCRIPTION: This snippet imports the InputPlaceholderColorDemo component for demonstrating placeholder color changes and the Layout component for page structure. It sets up necessary dependencies for rendering the demo within a consistent layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/inputs-placeholder-color.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { InputPlaceholderColorDemo } from '@/demos/InputPlaceholderColor.demo';\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Image Component Updates with Style Props and Fallbacks\nDESCRIPTION: Removes figure wrapper and caption, replaces width/height props with 'w' and 'h' style props, and introduces fallback images for improved robustness.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_21\n\n\n\n----------------------------------------\n\nTITLE: Define Font Face in CSS\nDESCRIPTION: This CSS snippet defines the font face for the 'Greycliff CF' font family, specifying the source URL for different font weights using the @font-face rule. It uses woff2 format for the font and sets the font-weight and font-style properties. This css file then is imported into the main tsx file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/vite-load-fonts.mdx#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n@font-face {\n  font-family: 'Greycliff CF';\n  src: url('./GreycliffCF-Bold.woff2') format('woff2');\n  font-weight: 700;\n  font-style: normal;\n}\n\n@font-face {\n  font-family: 'Greycliff CF';\n  src: url('./GreycliffCF-Heavy.woff2') format('woff2');\n  font-weight: 900;\n  font-style: normal;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Color Luminance with luminance in Mantine Core (TSX)\nDESCRIPTION: Demonstrates the `luminance` function from `@mantine/core` which calculates the relative luminance of a provided color string. The function returns a numerical value between 0 (representing black) and 1 (representing white), useful for accessibility checks and contrast calculations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { luminance } from '@mantine/core';\n\nluminance('#fff'); // -> 1\nluminance('#000'); // -> 0\nluminance('#4578FC'); // -> 0.21726425554966\n```\n\n----------------------------------------\n\nTITLE: Importing Components and Data for Changelogs Page in React\nDESCRIPTION: Imports necessary components and data for rendering the changelog page. It imports the VersionsList component to display versions, a Layout component for page structure, and MDX_DATA which contains changelog content.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/previous-versions.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { VersionsList } from '@/components/VersionsList';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Defining the useFavicon Hook API in React (TypeScript)\nDESCRIPTION: This snippet declares the function signature for the useFavicon custom React hook in TypeScript. The hook accepts a single parameter, url, which is a string representing the favicon's URL (supported formats include .ico, .png, .svg, and .gif), and returns void. The favicon is updated whenever the url changes and is non-empty or non-null, with trailing whitespace trimmed. This hook must be invoked only in client-side React components (useLayoutEffect is not called on the server) and requires the Mantine core library to function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-favicon.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useFavicon(url: string): void;\n```\n\n----------------------------------------\n\nTITLE: Using MantineThemeOverride Type for Theme Customization\nDESCRIPTION: Demonstrates using MantineThemeOverride type for functions that accept partial theme overrides, such as when merging multiple theme configurations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createTheme,\n  MantineThemeOverride,\n  mergeThemeOverrides,\n} from '@mantine/core';\n\nconst baseTheme = createTheme({\n  fontFamily: 'Helvetica, sans-serif',\n});\n\nfunction mergeThemes(themes: MantineThemeOverride[]) {\n  return mergeThemeOverrides(baseTheme, ...themes);\n}\n\nconst overrideTheme = createTheme({\n  primaryColor: 'blue',\n});\n\nconst overrideTheme2 = createTheme({\n  cursorType: 'pointer',\n});\n\nconst mergedTheme = mergeThemes([overrideTheme, overrideTheme2]);\n```\n\n----------------------------------------\n\nTITLE: Unmounting Inactive Tabs with Mantine\nDESCRIPTION: Demonstrates how to unmount inactive Tabs.Panel components using the `keepMounted` prop. Setting `keepMounted={false}` will unmount inactive panels, potentially improving performance for tabs containing resource-intensive components. Components inside the Tab.Panel will reset their state on each tab change.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Tabs } from '@mantine/core';\n\n// Second tab panel will be mounted only when user activates second tab\nfunction Demo() {\n  return (\n    <Tabs keepMounted={false} defaultValue=\"first\">\n      <Tabs.List>\n        <Tabs.Tab value=\"first\">First tab</Tabs.Tab>\n        <Tabs.Tab value=\"second\">Second tab</Tabs.Tab>\n      </Tabs.List>\n\n      <Tabs.Panel value=\"first\">First panel</Tabs.Panel>\n      <Tabs.Panel value=\"second\">Second panel</Tabs.Panel>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Overflow for Mantine Grid in React (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates how to set the 'overflow' property to 'hidden' on the Mantine Grid component using TypeScript/TSX within a functional React component. It prevents negative margins in Grid from causing overflow, which is necessary when the Grid is not wrapped in a parent container with padding. No additional dependencies are required beyond the '@mantine/core' library. The component renders two columns with a specified 'span' prop, each occupying 50% of the grid width. The function expects no props and outputs a JSX element rendering the grid.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/grid.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Grid } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Grid overflow=\"hidden\">\n      <Grid.Col span={6}>1</Grid.Col>\n      <Grid.Col span={6}>2</Grid.Col>\n    </Grid>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Replacing SCSS Mixins for Color Scheme in Mantine Components - SCSS\nDESCRIPTION: This SCSS snippet demonstrates how to implement color scheme-based styling for Mantine components in CRA without relying on SCSS mixins. The example shows both the unsupported mixin syntax and a supported approach using attribute selectors to directly target data-mantine-color-scheme values. No additional dependencies are needed beyond basic SCSS/CSS. The input is a component class, and the output is targeted color overrides for light/dark modes. Limitation: SCSS mixins are not available; direct selectors must be used.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/can-i-use-mantine-with-cra.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n// ❌ Does not work with Create React App\n.demo {\n  @mixin light {\n    color: red;\n  }\n\n  @mixin dark {\n    color: blue;\n  }\n}\n\n// ✅ Works with Create React App\n[data-mantine-color-scheme='light'] .demo {\n  color: red;\n}\n\n[data-mantine-color-scheme='dark'] .demo {\n  color: blue;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining the useSetState Hook Type Signature (TypeScript)\nDESCRIPTION: This snippet provides the TypeScript definition for the useSetState hook, specifying generics, input parameter expectations, and return types. It enforces that the initial state is an object (T extends Record<string, any>), and the setter accepts either a partial state object or an updater function. This definition outlines required generics and the callable shape of useSetState. Intended for TypeScript codebases using Mantine Hooks.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-set-state.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useSetState<T extends Record<string, any>>(\n  initialState: T\n): readonly [\n  T,\n  (\n    statePartial: Partial<T> | ((currentState: T) => Partial<T>)\n  ) => void,\n];\n```\n\n----------------------------------------\n\nTITLE: Parsing Theme Colors with parseThemeColor in Mantine Core (TSX)\nDESCRIPTION: Example demonstrating the use of the `parseThemeColor` function within a React component to retrieve detailed information about a Mantine color string. It requires the color string and the Mantine theme object (obtained via `useMantineTheme` hook). The returned object (`ParseThemeColorResult`) is used here to conditionally apply either a CSS variable or the direct color value as a background.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  MantineColor,\n  parseThemeColor,\n  useMantineTheme,\n} from '@mantine/core';\n\ninterface DemoProps {\n  color: MantineColor;\n}\n\nfunction Demo({ color }: DemoProps) {\n  const theme = useMantineTheme();\n  const parsedColor = parseThemeColor({ color, theme });\n\n  return (\n    <div\n      style={{\n        backgroundColor: parsedColor.isThemeColor\n          ? `var(${parsedColor.variable})`\n          : parsedColor.value,\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Controlled Chip Groups in Mantine with Single and Multiple Selection\nDESCRIPTION: This example shows how to implement both single selection (radio button behavior) and multiple selection (checkbox behavior) with Chip.Group. It demonstrates state management for both scenarios, including the different value types needed for each selection mode.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/chip.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Chip } from '@mantine/core';\n\nfunction Single() {\n  // string value when multiple is false (default)\n  const [value, setValue] = useState('react');\n\n  return (\n    <Chip.Group multiple={false} value={value} onChange={setValue}>\n      <Chip value=\"react\">React</Chip>\n      <Chip value=\"ng\">Angular</Chip>\n      <Chip value=\"svelte\">Svelte</Chip>\n      <Chip value=\"vue\">Vue</Chip>\n    </Chip.Group>\n  );\n}\n\nfunction Multiple() {\n  // array of strings value when multiple is true\n  const [value, setValue] = useState(['react']);\n\n  return (\n    <Chip.Group multiple value={value} onChange={setValue}>\n      <Chip value=\"react\">React</Chip>\n      <Chip value=\"ng\">Angular</Chip>\n      <Chip value=\"svelte\">Svelte</Chip>\n      <Chip value=\"vue\">Vue</Chip>\n    </Chip.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using use-radial-move Hook in Mantine with React TypeScript\nDESCRIPTION: Demonstrates how to use the new useRadialMove hook from @mantine/hooks to implement a custom radial slider component with React and Mantine. Requires @mantine/core, @mantine/hooks, and a local CSS module for styling. The hook provides a ref to attach to the root element, and updates the angle value based on user interaction, displaying the current angle using state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useState } from 'react';\nimport { Box } from '@mantine/core';\nimport { useRadialMove } from '@mantine/hooks';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const [value, setValue] = useState(115);\n  const { ref } = useRadialMove(setValue);\n\n  return (\n    <Box className={classes.root} ref={ref} style={{ '--angle': `${value}deg` }}>\n      <div className={classes.value}>{value}°</div>\n      <div className={classes.thumb} />\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: index.html example\nDESCRIPTION: An example of `index.html` with the google fonts preconnect and link tags. Sets the basic configurations and imports the main tsx script.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/vite-load-fonts.mdx#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/src/favicon.svg\" />\n    <meta\n      name=\"viewport\"\n      content=\"minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no\"\n    />\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n    <link\n      rel=\"preconnect\"\n      href=\"https://fonts.gstatic.com\"\n      crossorigin\n    />\n    <link\n      href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap\"\n      rel=\"stylesheet\"\n    />\n    <title>Vite + Mantine App</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Defining useRadialMove Hook Signature in React TypeScript\nDESCRIPTION: This code defines the function signature for the useRadialMove hook, parameterized by an optional HTMLElement type, defaulting to HTMLDivElement. It requires an onChange callback for value updates and accepts an optional UseRadialMoveOptions object for configuration. The hook returns an object containing a typed ref for DOM access and an active boolean indicating interaction state. Required dependencies include React and TypeScript; the function expects a numeric change handler and may accept customized event callbacks in the options. The output is a React ref object and an interaction state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-radial-move.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nfunction useRadialMove<T extends HTMLElement = HTMLDivElement>(\n  onChange: (value: number) => void,\n  options?: UseRadialMoveOptions\n): {\n  ref: React.RefObject<T>;\n  active: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Utilizing Enhanced Color Prop Values in Mantine Components (TSX)\nDESCRIPTION: Demonstrates the improved `color` prop flexibility in Mantine components. It shows passing both theme color names (e.g., 'cyan') and direct CSS hex color values (e.g., '#1D72FE') to the `Button` component for `filled`, `light`, and `outline` variants. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Group, Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <Text size=\"sm\" mb={5} fw={500}>\n        Filled variant\n      </Text>\n      <Group>\n        <Button color=\"cyan\">Theme color</Button>\n        <Button color=\"#1D72FE\">Hex color</Button>\n      </Group>\n\n      <Text size=\"sm\" mb={5} mt=\"md\" fw={500}>\n        Light variant\n      </Text>\n      <Group>\n        <Button variant=\"light\" color=\"cyan\">\n          Theme color\n        </Button>\n        <Button variant=\"light\" color=\"#1D72FE\">\n          Hex color\n        </Button>\n      </Group>\n\n      <Text size=\"sm\" mb={5} mt=\"md\" fw={500}>\n        Outline variant\n      </Text>\n      <Group>\n        <Button variant=\"outline\" color=\"cyan\">\n          Theme color\n        </Button>\n        <Button variant=\"outline\" color=\"#1D72FE\">\n          Hex color\n        </Button>\n      </Group>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Install Mantine Hooks with NPM\nDESCRIPTION: This command installs the @mantine/hooks package using NPM. It adds the package to your project's dependencies, allowing you to use the hooks in your React components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/hooks/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @mantine/hooks\n```\n\n----------------------------------------\n\nTITLE: Modal Display for MonthPickerInput\nDESCRIPTION: Shows how to render the MonthPicker in a Modal instead of the default Popover by setting the dropdownType prop to 'modal'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.modal} />\n```\n\n----------------------------------------\n\nTITLE: Install Mantine Form package - Bash\nDESCRIPTION: Provides commands to install the Mantine Form library as a project dependency using either yarn or npm package managers. This is a required prerequisite to use the library in a project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/form/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @mantine/form\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @mantine/form\n```\n\n----------------------------------------\n\nTITLE: Example package.json Before Mantine Update\nDESCRIPTION: Shows a sample package.json file with Mantine dependencies before the update, demonstrating the current structure and versions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-update-dependencies.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"your-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {},\n  \"dependencies\": {\n    \"@mantine/core\": \"^7.2.2\",\n    \"@mantine/hooks\": \"^7.2.2\",\n    \"next\": \"14.0.2\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"postcss\": \"^8.4.31\",\n    \"postcss-preset-mantine\": \"^1.10.0\",\n    \"prettier\": \"^3.1.0\",\n    \"typescript\": \"5.2.2\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying marks and restricting selection to marks\nDESCRIPTION: Demonstrates how to add marks to the slider with the marks prop, where each mark has a value and optional label, and how to restrict selection to only marked points using restrictToMarks.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/angle-slider.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={AngleSliderDemos.marks} />\n```\n\n----------------------------------------\n\nTITLE: Example ScatterChart Component Using Mantine Core in TypeScript\nDESCRIPTION: Provides an example of a ScatterChart component implementation that reuses the FloatingIndicator and button control pattern for interactivity. This snippet depends on Mantine Core UI components, Tabler icons for directional arrows, and React hooks for managing component state and refs. It demonstrates the floating indicator following the active button control in a scatter chart-like control grid. Inputs are user interaction events updating the 'active' state, output is a floating highlight positioned relative to the active control element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.7.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport {\n  IconArrowDown,\n  IconArrowDownLeft,\n  IconArrowDownRight,\n  IconArrowLeft,\n  IconArrowRight,\n  IconArrowUp,\n  IconArrowUpLeft,\n  IconArrowUpRight,\n  IconCircle,\n} from '@tabler/icons-react';\nimport { FloatingIndicator, UnstyledButton } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const [rootRef, setRootRef] = useState<HTMLDivElement | null>(null);\n  const [controlsRefs, setControlsRefs] = useState<Record<string, HTMLButtonElement | null>>({});\n  const [active, setActive] = useState('center');\n\n  const setControlRef = (name: string) => (node: HTMLButtonElement) => {\n    controlsRefs[name] = node;\n    setControlsRefs(controlsRefs);\n  };\n\n  return (\n    <div className={classes.root} dir=\"ltr\" ref={setRootRef}>\n      <FloatingIndicator\n        target={controlsRefs[active]}\n        parent={rootRef}\n        className={classes.indicator}\n      />\n\n      <div className={classes.controlsGroup}>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('up-left')}\n          ref={setControlRef('up-left')}\n          mod={{ active: active === 'up-left' }}\n        >\n          <IconArrowUpLeft size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('up')}\n          ref={setControlRef('up')}\n          mod={{ active: active === 'up' }}\n        >\n          <IconArrowUp size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('up-right')}\n          ref={setControlRef('up-right')}\n          mod={{ active: active === 'up-right' }}\n        >\n          <IconArrowUpRight size={26} stroke={1.5} />\n        </UnstyledButton>\n      </div>\n      <div className={classes.controlsGroup}>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('left')}\n          ref={setControlRef('left')}\n          mod={{ active: active === 'left' }}\n        >\n          <IconArrowLeft size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('center')}\n          ref={setControlRef('center')}\n          mod={{ active: active === 'center' }}\n        >\n          <IconCircle size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('right')}\n          ref={setControlRef('right')}\n          mod={{ active: active === 'right' }}\n        >\n          <IconArrowRight size={26} stroke={1.5} />\n        </UnstyledButton>\n      </div>\n      <div className={classes.controlsGroup}>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('down-left')}\n          ref={setControlRef('down-left')}\n          mod={{ active: active === 'down-left' }}\n        >\n          <IconArrowDownLeft size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('down')}\n          ref={setControlRef('down')}\n          mod={{ active: active === 'down' }}\n        >\n          <IconArrowDown size={26} stroke={1.5} />\n        </UnstyledButton>\n        <UnstyledButton\n          className={classes.control}\n          onClick={() => setActive('down-right')}\n          ref={setControlRef('down-right')}\n          mod={{ active: active === 'down-right' }}\n        >\n          <IconArrowDownRight size={26} stroke={1.5} />\n        </UnstyledButton>\n      </div>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Polymorphic Component Props\nDESCRIPTION: Explains the use of `component` and `renderRoot` props with non-polymorphic Mantine components.  It provides an example using the `Group` component to illustrate how to render it as a `nav` element, emphasizing the difference in prop inheritance between polymorphic and non-polymorphic components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-3-0.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Group } from '@mantine/core';\n\n// Group is not polymorphic component,\n// but it still supports component and renderRoot props\nfunction Demo() {\n  return (\n    <Group component=\"nav\">\n      <a>Item 1</a>\n      <a>Item 2</a>\n      <a>Item 3</a>\n    </Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Google Fonts in HTML Head\nDESCRIPTION: This HTML snippet is intended to be placed in the `<head>` section of your React application. It includes `<link>` tags to preconnect to `fonts.googleapis.com` and `fonts.gstatic.com` and a `<link>` tag to load the Roboto font family, specifying its weights and display settings. This imports the font from Google Fonts for use within the application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/remix-load-fonts.mdx#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n<link\n  rel=\"preconnect\"\n  href=\"https://fonts.gstatic.com\"\n  crossorigin=\"\"\n/>\n<link\n  href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap\"\n  rel=\"stylesheet\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Creating Form Actions for External State Manipulation - Mantine (TypeScript)\nDESCRIPTION: Shows how to create exported form actions using createFormActions from @mantine/form, enabling external control over form state. The form actions must match the form name defined with useForm and should be typed with the same values interface. These exported actions can be imported into other files/components to programmatically update or reset form data. Dependencies: @mantine/form and the local type definition for form values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-2-0.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Import type of form values from the file where you defined useForm\nimport { createFormActions } from '@mantine/form';\nimport type { DemoFormValues } from './DemoForm';\n\nexport const demoFormActions =\n  createFormActions<DemoFormValues>('demo-form');\n```\n\n----------------------------------------\n\nTITLE: Using Mantine Button with Color and Variant Props (TSX)\nDESCRIPTION: Demonstrates how to use a Mantine `Button` component, specifying its `color` ('pink') and `variant` ('filled'). The component's appearance (background, text, border) is determined by the corresponding CSS variables generated based on the theme's color definitions (e.g., `--mantine-color-pink-filled`, `--mantine-color-pink-filled-hover`). Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button color=\"pink\" variant=\"filled\">\n      Filled pink button\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Shallow Object Equality Check with Mantine Hooks (TSX)\nDESCRIPTION: Illustrates the `shallowEqual` function from `@mantine/hooks`. This function performs a shallow comparison between two objects or arrays to determine if they are equal at the first level of properties/elements. Requires importing `shallowEqual` from the hooks package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/functions-reference.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { shallowEqual } from '@mantine/hooks';\n\nshallowEqual({ a: 1 }, { a: 1 }); // true\nshallowEqual({ a: 1 }, { a: 2 }); // false\n```\n\n----------------------------------------\n\nTITLE: Exporting default layout with intersection data\nDESCRIPTION: Exports a default React component integrated with Mantine's Layout component, passing the MDX_DATA's useIntersection hook invocation as a higher-order component for intersection tracking in documentation or demo pages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-intersection.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.useIntersection);\n```\n\n----------------------------------------\n\nTITLE: Importing the Color Scheme Demo Component\nDESCRIPTION: Imports the `ColorSchemeColor` demo component from the '@/demos/ColorSchemeColor.demo' path. This component is likely used later to demonstrate dynamic color changes based on the color scheme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-color.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ColorSchemeColor } from '@/demos/ColorSchemeColor.demo';\n```\n\n----------------------------------------\n\nTITLE: Configuring Touch Trigger Option in Mantine Form\nDESCRIPTION: This snippet shows how to use the `touchTrigger` option to customize when a field is considered touched.  The `touchTrigger` option can be set to `'change'` (default) or `'focus'`. When set to `'focus'`, a field is considered touched only when focused. Requires `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/status.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { a: 1 },\n  touchTrigger: 'focus',\n});\n\nform.isTouched('a'); // -> false\nform.setFieldValue('a', 2);\nform.isTouched('a'); // -> false\n\n// onFocus is called automatically when the user focuses the field\nform.getInputProps('a').onFocus();\nform.isTouched('a'); // -> true\n```\n```\n\n----------------------------------------\n\nTITLE: UseTreeInput Interface\nDESCRIPTION: Defines the `UseTreeInput` interface, outlining the configuration options for the `useTree` hook. It specifies the properties used to initialize the tree's state such as `initialExpandedState`, `initialSelectedState`, `initialCheckedState`, and event handlers for expand/collapse.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface UseTreeInput {\n  /** Initial expanded state of all nodes */\n  initialExpandedState?: Record<string, boolean>;\n\n  /** Initial selected state of nodes */\n  initialSelectedState?: string[];\n\n  /** Initial checked state of nodes */\n  initialCheckedState?: string[];\n\n  /** Determines whether multiple node can be selected at a time */\n  multiple?: boolean;\n\n  /** Called with the node value when it is expanded */\n  onNodeExpand?: (value: string) => void;\n\n  /** Called with the node value when it is collapsed */\n  onNodeCollapse?: (value: string) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Title with lineClamp Prop\nDESCRIPTION: This example shows how to use the `lineClamp` prop on the `Title` component to truncate text after a specified number of lines.  It depends on `@mantine/core`. The `lineClamp` prop limits the number of lines displayed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, Title } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box maw={400}>\n      <Title order={2} lineClamp={2}>\n        Lorem ipsum dolor sit amet consectetur adipisicing elit. Iure doloremque quas dolorum. Quo\n        amet earum alias consequuntur quam accusamus a quae beatae, odio, quod provident consectetur\n        non repudiandae enim adipisci?\n      </Title>\n    </Box>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring styles API for customization\nDESCRIPTION: This demonstrates the use of 'StylesApiSelectors' to connect with Mantine's styles API, enabling theme-based style overrides for the TagsInput component for consistent design.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\n<StylesApiSelectors component=\"TagsInput\" />\n```\n\n----------------------------------------\n\nTITLE: Defining useFocusReturn Hook in Mantine\nDESCRIPTION: This code snippet provides the type definition for the `useFocusReturn` hook. It defines the input `options` object, which includes `opened` (boolean) and `shouldReturnFocus` (boolean, optional). It specifies the hook's return type as a function `() => void`, which is used for manually returning focus.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-return.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n```tsx\nfunction useFocusReturn(options: {\n  opened: boolean;\n  shouldReturnFocus?: boolean;\n}): () => void;\n```\n```\n\n----------------------------------------\n\nTITLE: AlphaSlider Component Demo (Mantine, React, TypeScript)\nDESCRIPTION: Illustrates the AlphaSlider component, controlling and displaying the alpha value. Requires Mantine and React dependencies. Sets the slider color and updates value on interaction.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { AlphaSlider, Text } from '@mantine/core';\n\nfunction Demo() {\n  const [value, onChange] = useState(0.55);\n\n  return (\n    <>\n      <Text>Alpha value: {value}</Text>\n      <AlphaSlider color=\"#1c7ed6\" value={value} onChange={onChange} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a BarChart Overlay with Mantine Charts in TypeScript\nDESCRIPTION: Illustrates usage of the Mantine BarChart component with custom bar sizing logic to create an overlay effect. Dependencies: @mantine/charts, React, and a CSS module. Key inputs are data, bar sizing formulas, and custom series styling; output is a styled chart with variable bar widths and color themes. Constraint: requires proper setup of bar data and relevant CSS classes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_12\n\nLANGUAGE: TypeScript JSX\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const bigBarWidth = useMediaQuery('(min-width: 48em)') ? 42 : 26;\n  const ratio = 0.5;\n  const smallBarWidth = bigBarWidth * ratio;\n  const barGap = (bigBarWidth + smallBarWidth) / -2;\n\n  return (\n    <BarChart\n      h={300}\n      data={overlayData}\n      dataKey=\"index\"\n      barChartProps={{ barGap }}\n      barProps={(data) => ({ barSize: data.name === 'you' ? bigBarWidth : smallBarWidth })}\n      classNames={classes}\n      series=[\n        { name: 'you', color: 'var(--you-bar-color)' },\n        { name: 'average', color: 'var(--average-bar-color)' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using useModalsStack Hook with Modal Component in TypeScript React\nDESCRIPTION: Shows the practical application of the useModalsStack hook integrating with Mantine's Modal component to manage multiple modals. The hook receives an array of modal IDs and provides handlers to control modal visibility and properties. The example renders two modals with buttons for user-triggered opening. Dependencies include '@mantine/core'. Inputs include modal ID list; outputs are modals rendered with appropriate open states and event handlers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.14.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Modal, useModalsStack } from '@mantine/core';\n\nfunction Demo() {\n  const stack = useModalsStack(['first', 'second']);\n\n  return (\n    <>\n      <Modal {...stack.register('first')}>First</Modal>\n      <Modal {...stack.register('second')}>Second</Modal>\n      <Button onClick={() => stack.open('first')}>Open first</Button>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing postcss-loader Configuration in Ejected CRA for Mantine - JavaScript (Webpack)\nDESCRIPTION: This code snippet is inserted into config/webpack.config.js after ejecting CRA. It updates postcss-loader settings to reference PostCSS options and control source map generation based on environment variables. Dependencies: ejected CRA, webpack, postcss-loader. Key parameters include sourceMap, isEnvProduction, shouldUseSourceMap, isEnvDevelopment. Outputs: enables full Mantine styling post-processing with custom PostCSS plugins.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/can-i-use-mantine-with-cra.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n{\n  loader: require.resolve(\"postcss-loader\"),\n  options: {\n    postcssOptions: {\n      ident: \"postcss\",\n    },\n    sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment,\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Aria Labels for YearPicker Navigation (TSX)\nDESCRIPTION: This example shows how to customize the `aria-label` attributes for the next and previous decade navigation controls within the Mantine `YearPicker` component using the `ariaLabels` prop. This improves accessibility by providing descriptive labels for screen reader users.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/year-picker.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { YearPicker } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <YearPicker\n      ariaLabels={{\n        nextDecade: 'Next decade',\n        previousDecade: 'Previous decade',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Mantine Notifications State with useNotifications Hook (TSX)\nDESCRIPTION: Illustrates how to subscribe to and display the state of notifications using the `useNotifications` hook from `@mantine/notifications`. The component uses `useCounter` to generate unique notification titles, triggers notifications with `notifications.show`, and displays the current `notificationsStore.notifications` and `notificationsStore.queue` states within Code blocks.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.12.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Text, Code } from '@mantine/core';\nimport { notifications, useNotifications } from '@mantine/notifications';\nimport { useCounter } from '@mantine/hooks'; // Assuming useCounter is imported\n\nfunction Demo() {\n  const [counter, { increment }] = useCounter();\n  const notificationsStore = useNotifications();\n\n  const showNotification = () => {\n    notifications.show({\n      title: `Notification ${counter}`,\n      message: 'Most notifications are added to queue',\n    });\n\n    increment();\n  };\n\n  return (\n    <>\n      <Button onClick={showNotification} mb=\"md\">\n        Show notification\n      </Button>\n\n      <Text>Notifications state</Text>\n      <Code block>{JSON.stringify(notificationsStore.notifications, null, 2)}</Code>\n\n      <Text mt=\"md\">Notifications queue</Text>\n      <Code block>{JSON.stringify(notificationsStore.queue, null, 2)}</Code>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Mantine Image with Next.js Image (TSX)\nDESCRIPTION: This snippet demonstrates how to use Mantine's `Image` component as a wrapper for Next.js's `Image` component. By setting the `component` prop to `NextImage`, you can utilize Mantine's styling props and features while still benefiting from Next.js image optimizations. Requires `@mantine/core` and `next`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/image.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport NextImage from 'next/image';\nimport { Image } from '@mantine/core';\nimport myImage from './my-image.jpg';\n\nfunction Demo() {\n  return <Image component={NextImage} src={myImage} alt=\"My image\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Fields Before form.initialize\nDESCRIPTION: This code uses `enhanceGetInputProps` to disable form fields before `form.initialize` is called, preventing data loss.  It relies on `@mantine/core` and `@mantine/form`. The input field is disabled if the form is not initialized.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NumberInput, TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\ninterface FormValues {\n  name: string;\n  age: number | string;\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    initialValues: { name: '', age: '' },\n    enhanceGetInputProps: (payload) => {\n      if (!payload.form.initialized) {\n        return { disabled: true };\n      }\n\n      return {};\n    },\n  });\n\n  return (\n    <>\n      <TextInput {...form.getInputProps('name')} label=\"Your name\" placeholder=\"Your name\" />\n      <NumberInput {...form.getInputProps('age')} label=\"Age\" placeholder=\"Age\" mt=\"md\" />\n      <Button onClick={() => form.initialize({ name: 'John', age: 20 })} mt=\"md\">\n        Initialize form\n      </Button>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing LineChart component with @mantine/charts in TypeScript\nDESCRIPTION: Illustrates creating a LineChart component using the @mantine/charts package with TypeScript. It shows how to set the chart height, assign data source, specify x-axis data key, enable legend display, and define multiple data series with colors. Requires React and TypeScript setups alongside @mantine/charts. Input data should contain 'date' keys with corresponding numeric values by series for visualization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { LineChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <LineChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      withLegend\n      series=[\n        { name: 'Apples', color: 'indigo.6' },\n        { name: 'Oranges', color: 'blue.6' },\n        { name: 'Tomatoes', color: 'teal.6' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Multiple Dates Selection Demo for DatePickerInput in JSX\nDESCRIPTION: Renders a demo component illustrating how to enable multiple date selection by setting the `type` prop to \"multiple\". This helps users understand and visualize the multi-date picking functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.multiple} />\n```\n\n----------------------------------------\n\nTITLE: Defining page metadata and structure - TypeScript/JSX\nDESCRIPTION: This snippet defines the metadata for the documentation page, including title, description, slug, and tags. It also imports necessary demo components and sets up the page layout using a `Layout` component provided elsewhere.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/file-button-in-menu.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FileButtonMenuBroken } from '@/demos/FileButtonMenuBroken.demo';\nimport { FileButtonMenuFix } from '@/demos/FileButtonMenuFix.demo';\nimport { FileButtonMenuFix2 } from '@/demos/FileButtonMenuFix2.demo';\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'Why FileButton does not work in Menu?',\n  description: 'Learn how to use FileButton in Menu component',\n  slug: 'file-button-in-menu',\n  category: 'components',\n  tags: ['menu', 'file button', 'dropdown', 'file upload'],\n  created_at: 'July 15, 2024',\n  last_updated_at: 'July 15, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Expanded State Changes (TSX)\nDESCRIPTION: This code snippet shows how to subscribe to expanded state changes of the Mantine Spoiler component using the `onExpandedChange` prop. The callback function receives a boolean indicating the new expanded state, which is logged to the console. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/spoiler.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Spoiler } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Spoiler\n      showLabel=\"Show more\"\n      hideLabel=\"Hide details\"\n      onExpandedChange={(expanded) => console.log(expanded)}\n    >\n      {/* Spoiler content */}\n    </Spoiler>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demo MantineProvider with Custom Class Name Prefix\nDESCRIPTION: This TypeScript snippet demonstrates the use of the `MantineProvider` component with a custom `classNamesPrefix` set to \"app\". It renders a `Text` component. Dependencies include `@mantine/core`. It showcases how to change class names to apply custom css classes. Input is the text to display, the output is text component with the custom class names.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/apply-styles-to-all.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider, Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider classNamesPrefix=\"app\">\n      <Text>Just some text</Text>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: PasswordInput without Visibility Toggle\nDESCRIPTION: This snippet demonstrates how to use the Mantine TextInput component with the `type` prop set to `password` instead of PasswordInput, effectively creating a password input field without the visibility toggle button. Dependencies: @mantine/core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/password-input.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return <TextInput type=\"password\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Falsey Errors – Mantine\nDESCRIPTION: Shows that `false`, `null` or `undefined` errors will be automatically removed from the `form.errors` object. This helps manage and clean up error states.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialErrors: { name: 'name-error', email: null },\n});\n\nform.errors; // -> { name: 'name-error' }, email error is not included in errors object\n\n```\n\n----------------------------------------\n\nTITLE: Custom sorting of suggestion options using filter function\nDESCRIPTION: This code allows customization of the order in which suggestion options are displayed by passing a 'filter' function to sort or filter options according to custom logic.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.sort} />\n```\n\n----------------------------------------\n\nTITLE: Configuring Anchor Default Props - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to configure the `underline` prop for all `Anchor` components globally using the Mantine theme.  It creates a custom theme and extends the `Anchor` component's default props to set `underline` to `always`.  This means all Anchor components within the `MantineProvider` will have the underline style applied.  It uses `createTheme` to define the new theme and `MantineProvider` to apply the theme to the application. It requires the `@mantine/core` dependency.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/anchor.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Anchor, createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  components: {\n    Anchor: Anchor.extend({\n      defaultProps: {\n        underline: 'always',\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Loading Overlay with Inline Children in Mantine (TypeScript/React)\nDESCRIPTION: Demonstrates overriding the default loader in a LoadingOverlay with a custom React node using the loaderProps.children property. Utilizes useDisclosure to toggle visibility, and depends on '@mantine/core' and '@mantine/hooks'. The LoadingOverlay and Button components are displayed, and the overlay content is set to a string instead of the default spinner.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Box, Button, Group, LoadingOverlay } from '@mantine/core';\nimport { useDisclosure } from '@mantine/hooks';\n\nfunction Demo() {\n  const [visible, { toggle }] = useDisclosure(false);\n\n  return (\n    <>\n      <Box pos=\"relative\">\n        <LoadingOverlay visible={visible} loaderProps={{ children: 'Loading...' }} />\n        {/* ...other content */}\n      </Box>\n\n      <Group position=\"center\">\n        <Button onClick={toggle}>Toggle overlay</Button>\n      </Group>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Responsive Styling with Mantine Breakpoints in Vanilla Extract (TypeScript)\nDESCRIPTION: Shows how to create responsive styles using Mantine's breakpoint helpers (`largerThan`, `smallerThan`) available on the `vars` object. These helpers simplify writing media queries by allowing the use of pixel values or predefined breakpoint keys (like 'sm') which are automatically converted to appropriate media query conditions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// Demo.css.ts\nimport { style } from '@vanilla-extract/css';\nimport { vars } from './theme';\n\nexport const demo = style({\n  fontSize: vars.fontSizes.sm,\n\n  '@media': {\n    // equivalent to `(min-width: 640px)` converted to em\n    // -> `(min-width: 40em)`\n    [vars.largerThan(640)]: {\n      fontSize: vars.fontSizes.md,\n    },\n\n    // equivalent to `(max-width: 640px)` converted to em\n    // -> `(max-width: 40em)`\n    [vars.smallerThan(640)]: {\n      fontSize: vars.fontSizes.xs,\n    },\n\n    // You can reference `theme.breakpoints` values\n    [vars.largerThan('sm')]: {\n      fontSize: vars.fontSizes.md,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Virtual Colors with Mantine Core in TypeScript\nDESCRIPTION: Demonstrates how to create a theme in Mantine with virtual colors that adapt based on light or dark color schemes using the virtualColor function. This snippet requires Mantine Core and React. It defines a 'primary' color key with distinct light and dark color values, then applies the theme to the application via MantineProvider. Inputs are the color scheme definitions, and output is a theme supporting dynamic color appearance depending on user preference.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.7.0.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider, virtualColor } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    primary: virtualColor({\n      name: 'primary',\n      dark: 'pink',\n      light: 'cyan',\n    }),\n  },\n});\n\nfunction App() {\n  return <MantineProvider theme={theme}>{/* Your app here */}</MantineProvider>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Page Metadata for Mantine Documentation\nDESCRIPTION: Defines metadata for a documentation page about nested popovers in Mantine, including title, description, tags, and timestamps.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/nested-popover-closes.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nexport const meta = {\n  title:\n    'My Popover dropdown closes when I click on the dropdown of nested Popover',\n  description:\n    'Popover dropdown is closed when it detects click outside events',\n  slug: 'nested-popover-closes',\n  category: 'components',\n  tags: ['popover', 'menu', 'DatePicker', 'Select'],\n  created_at: 'September 8, 2024',\n  last_updated_at: 'September 8, 2024',\n};\n```\n\n----------------------------------------\n\nTITLE: Importing and Setting Up Sparkline Component Layout\nDESCRIPTION: Imports the necessary modules and sets up the default export for the Sparkline component documentation page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/sparkline.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { SparklineDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Sparkline);\n```\n\n----------------------------------------\n\nTITLE: Example SCSS with px and conversion to rem\nDESCRIPTION: This SCSS code demonstrates how the `autoRem` feature will convert px values to rem. It defines a `.demo` class with a `font-size` of 16px and then uses a media query. The expected output will have the font-size converted to `calc(1rem * var(--mantine-scale))`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_1\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  font-size: 16px;\n\n  @media (min-width: 320px) {\n    font-size: 32px;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting dropdown width with comboboxProps\nDESCRIPTION: This snippet customizes dropdown width, typically making it equal to the input's width by setting the 'width' property in 'comboboxProps', allowing for flexible sizing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.dropdownWidth} />\n```\n\n----------------------------------------\n\nTITLE: Using Subtle Variant in RichTextEditor - Mantine X Tiptap Extension in React TypeScript\nDESCRIPTION: Demonstrates using the subtle variant prop in Mantine's RichTextEditor component. Depends on @mantine/tiptap, @tiptap/react, and Tiptap extensions like StarterKit, Underline, and Highlight. The editor initializes with sample HTML content and displays a toolbar with formatting controls. Designed for rich text editing interfaces needing a non-intrusive style.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_9\n\nLANGUAGE: TSX\nCODE:\n```\nimport Highlight from '@tiptap/extension-highlight';\nimport Underline from '@tiptap/extension-underline';\nimport { useEditor } from '@tiptap/react';\nimport StarterKit from '@tiptap/starter-kit';\nimport { RichTextEditor } from '@mantine/tiptap';\n\nconst content = '<p>Subtle rich text editor variant</p>';\n\nfunction Demo() {\n  const editor = useEditor({\n    extensions: [StarterKit, Underline, Highlight],\n    content,\n  });\n\n  return (\n    <RichTextEditor editor={editor} variant=\"subtle\">\n      <RichTextEditor.Toolbar sticky stickyOffset={60}>\n        <RichTextEditor.ControlsGroup>\n          <RichTextEditor.Bold />\n          <RichTextEditor.Italic />\n          <RichTextEditor.Underline />\n          <RichTextEditor.Strikethrough />\n          <RichTextEditor.ClearFormatting />\n          <RichTextEditor.Highlight />\n          <RichTextEditor.Code />\n        </RichTextEditor.ControlsGroup>\n      </RichTextEditor.Toolbar>\n\n      <RichTextEditor.Content />\n    </RichTextEditor>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Sparkline Component Usage Demo\nDESCRIPTION: Demonstrates the basic usage of the Sparkline component, showing how to display a single series of data in a small space.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/sparkline.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={SparklineDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Fields with Valibot and Mantine Form in TypeScript\nDESCRIPTION: Illustrates validating nested object structures using `valibotResolver`. Defines a Valibot schema with a nested `v.object` and integrates it with the `validate` option in `useForm`. Shows the resulting error structure (using dot notation for nested fields) accessed via `form.errors` after validation. Requires `mantine-form-valibot-resolver`, `valibot`, and `@mantine/form`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { valibotResolver } from 'mantine-form-valibot-resolver';\nimport * as v from 'valibot';\nimport { useForm } from '@mantine/form';\n\nconst nestedSchema = v.object({\n  nested: v.object({\n    field: v.pipe(\n      v.string(),\n      v.minLength(2, 'Field should have at least 2 letters')\n    ),\n  }),\n});\n\nconst form = useForm({\n  initialValues: {\n    nested: {\n      field: '',\n    },\n  },\n  validate: valibotResolver(nestedSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'nested.field': 'Field should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Rendering CSS Variables List with Mantine and React - JavaScript\nDESCRIPTION: This snippet imports and composes React components to create a documentation page that displays all CSS variables defined in the Mantine default theme. Dependencies include React, and Mantine documentation-specific components (CssVariablesList, Layout, and MDX_DATA). Major parameters are the MDX_DATA.CSSVariablesList object providing MDX content, and Layout for consistent documentation style. The snippet exports a page that renders a static list component with minimal configuration; no external input is processed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables-list.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { CssVariablesList } from '@/components/CssVariablesList';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.CSSVariablesList);\n```\n\n----------------------------------------\n\nTITLE: Defining Data for Accordion Examples\nDESCRIPTION: This snippet defines an array of objects, `groceries`, used as data for Accordion examples. Each object represents a grocery item with properties like emoji, value (title), and description. The data is used to populate the content within the Accordion panels in the UI.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/accordion.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst groceries = [\n  {\n    emoji: '🍎',\n    value: 'Apples',\n    description:\n      'Crisp and refreshing fruit. Apples are known for their versatility and nutritional benefits. They come in a variety of flavors and are great for snacking, baking, or adding to salads.',\n  },\n  {\n    emoji: '🍌',\n    value: 'Bananas',\n    description:\n      'Naturally sweet and potassium-rich fruit. Bananas are a popular choice for their energy-boosting properties and can be enjoyed as a quick snack, added to smoothies, or used in baking.',\n  },\n  {\n    emoji: '🥦',\n    value: 'Broccoli',\n    description:\n      'Nutrient-packed green vegetable. Broccoli is packed with vitamins, minerals, and fiber. It has a distinct flavor and can be enjoyed steamed, roasted, or added to stir-fries.',\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Spotlight Component Refactor with Compound Patterns\nDESCRIPTION: The Spotlight context logic is replaced with a component-based approach, renamed SpotlightProvider to Spotlight, and allows multiple independent spotlights within an app.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_22\n\n\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Yarn After Update\nDESCRIPTION: Installs the updated dependencies using Yarn package manager after the package.json has been modified.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-update-dependencies.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Wrap with Layout\nDESCRIPTION: Wraps the `MDX_DATA.Paper` content with the `Layout` component. This applies a standard layout to the Paper component's documentation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/paper.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport default Layout(MDX_DATA.Paper);\n```\n\n----------------------------------------\n\nTITLE: Install Mantine Code Highlight with Yarn\nDESCRIPTION: Installs the @mantine/hooks, @mantine/core and @mantine/code-highlight packages using yarn package manager. These packages are required for using the Mantine code highlight component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/code-highlight/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @mantine/hooks @mantine/core @mantine/code-highlight\n```\n\n----------------------------------------\n\nTITLE: Installing PostCSS Dependencies (Bash)\nDESCRIPTION: Installs necessary PostCSS development dependencies (`postcss`, `postcss-preset-mantine`, `postcss-simple-vars`) using the `<InstallScript>` component, which conceptually represents running a package manager command like `yarn add --dev`. These are required for Mantine's styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/redwood.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n<InstallScript\n  packages=\"postcss postcss-preset-mantine postcss-simple-vars\"\n  dev\n/>\n```\n\n----------------------------------------\n\nTITLE: Waterfall BarChart with Custom Bar Coloring and Decoupling in JSX/TypeScript\nDESCRIPTION: Demonstrates a waterfall bar chart where successive bars build upon the previous ones, showing incremental positive or negative impacts. Supports setting individual bar colors through the `color` property on data points and decoupling bars using `standalone` prop. Based on BarChartDemos.waterfall data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_5\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.waterfall} />\n```\n\n----------------------------------------\n\nTITLE: Using useFocusTrap Hook with Active State Parameter in TypeScript\nDESCRIPTION: This snippet demonstrates the API usage of the useFocusTrap hook by passing a boolean parameter to toggle the active state of the focus trap. Calling useFocusTrap(true) activates the trap, while false deactivates it. Without arguments, the trap defaults to inactive. This allows dynamic control of focus confinement based on component state or lifecycle.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-trap.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useFocusTrap } from '@mantine/hooks';\n\nuseFocusTrap(); // -> focus trap inactive\nuseFocusTrap(true); // -> focus trap active\n\nuseFocusTrap(false); // -> focus trap disabled\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Correct and Incorrect Mantine Styles Import Order in TypeScript\nDESCRIPTION: Provides examples of correct and incorrect styles import order for Mantine packages in a TypeScript project. Ensures that @mantine/core styles load before other Mantine packages to maintain style integrity. Import order is vital to avoid style conflicts; no parameters or dynamic logic are present—these are static import sequences.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ Correct order\nimport '@mantine/core/styles.css';\nimport '@mantine/dates/styles.css';\n// ❌ Incorrect order\nimport '@mantine/dates/styles.css';\nimport '@mantine/core/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Type Definition of the useMounted Hook in TypeScript\nDESCRIPTION: This snippet provides a TypeScript function signature for the useMounted hook, defining that it returns a boolean value. It indicates the hook's role in signaling whether a component is mounted or not and serves as a reference for type checking in TypeScript projects using this hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mounted.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useMounted(): boolean;\n```\n\n----------------------------------------\n\nTITLE: Importing and Exporting Custom Layout in React - JavaScript\nDESCRIPTION: This snippet imports a custom Layout component from the '@/layout' path and exports it using file metadata as a parameter. It configures the page's meta-information, such as title, description, slug, category, tags, and timestamps. This is intended for React-based documentation sites and may require Next.js or custom project structure for the '@/layout' alias to resolve.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/mantine-provider-missing.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title:\n    'MantineProvider was not found in component tree. What should I do?',\n  description: 'Learn how to resolve MantineProvider issues',\n  slug: 'mantine-provider-missing',\n  category: 'common',\n  tags: ['provider', 'error'],\n  created_at: 'December 28, 2023',\n  last_updated_at: 'December 28, 2023',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Installing react-imask Package using npm/yarn/pnpm\nDESCRIPTION: Represents the command needed to install the 'react-imask' library using a package manager (like npm, yarn, or pnpm). This library is required to add input masking functionality to Mantine components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/input-mask.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n<InstallScript packages=\"react-imask\" />\n```\n\n----------------------------------------\n\nTITLE: Declaring useQueue Hook with Explicit Type Parameter in TypeScript/TSX\nDESCRIPTION: Illustrates how to declare the useQueue hook with a specific item type using TypeScript generics when no initial values are present. The example shows adding objects with defined structure directly, ensuring proper type safety. Dependencies: React, @mantine/hooks. Inputs: explicit generic type parameter and configuration object. The output is a typed queue structure able to enforce object shapes for queue operations. Works only in environments with TypeScript support and the Mantine hooks package installed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-queue.mdx#_snippet_2\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useQueue } from '@mantine/hooks';\n\nconst q = useQueue<{ name: string; id: number }>({\n  limit: 2,\n  initialValues: [],\n});\n\nq.add({ name: 'Bob', id: 1 });\n```\n\n----------------------------------------\n\nTITLE: Customizing Mantine Switch Cursor to Pointer via Theme in TSX\nDESCRIPTION: Shows how to change the default cursor style (`cursor: default`) of a Mantine `Switch` to `pointer`. This is achieved by wrapping the `Switch` component within a `MantineProvider` and applying a custom theme created with `createTheme`, setting the `cursorType` property to 'pointer'. Requires `react`, `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/switch.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider, Switch } from '@mantine/core';\n\nconst theme = createTheme({\n  cursorType: 'pointer',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Switch label=\"Pointer cursor\" />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demo: Enabling clearable feature in DateTimePicker\nDESCRIPTION: This snippet demonstrates the use of the \"clearable\" prop to show a clear button, enabling users to easily reset the selected date/time, with the note that rightSection customization disables the clear button.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_7\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DateTimePickerDemos.clearable} />\n```\n\n----------------------------------------\n\nTITLE: Rendering Clearable DatePickerInput Demo in JSX\nDESCRIPTION: Illustrates use of the `clearable` prop that adds a clear button allowing users to easily reset the selected date(s). The demo explains behavior when a `rightSection` prop is provided and the clear button is omitted.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_8\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.clearable} />\n```\n\n----------------------------------------\n\nTITLE: CSS usage of alpha, lighten, and darken functions with CSS variables in SCSS\nDESCRIPTION: Provides examples of CSS styling using 'alpha', 'lighten', and 'darken' functions in SCSS files with CSS variables from Mantine. It shows how these functions transform to CSS 'color-mix' expressions on older CSS preprocessor stages, allowing dynamic color manipulation at the stylesheet level. Requires postcss-preset-mantine version 1.12.0 or higher for automatic transformations. Enables use of advanced color models in CSS rather than fixed values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_8\n\nLANGUAGE: scss\nCODE:\n```\n.demo-alpha {\n  color: alpha(var(--mantine-color-red-4), 0.5);\n  border: 1px solid alpha(#ffc, 0.2);\n}\n\n.demo-lighten-darken {\n  color: lighten(var(--mantine-color-red-4), 0.5);\n  border: 1px solid darken(#ffc, 0.2);\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling tooltip animation\nDESCRIPTION: Activates animated tooltip transitions by setting 'tooltipAnimationDuration' to desired duration in milliseconds, resulting in smoother tooltip movement. Enhances user experience during interaction.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_18\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.tooltipAnimation} />\n```\n\n----------------------------------------\n\nTITLE: Using MantineColorScheme Type in TypeScript\nDESCRIPTION: Shows how to use MantineColorScheme type for typing functions that handle color scheme values, compatible with the useMantineColorScheme hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  MantineColorScheme,\n  useMantineColorScheme,\n} from '@mantine/core';\n\nfunction getComputedColorScheme(colorScheme: MantineColorScheme) {\n  return colorScheme === 'auto' ? 'light' : colorScheme;\n}\n\nfunction Demo() {\n  const { colorScheme } = useMantineColorScheme();\n  const computed = getComputedColorScheme(colorScheme);\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing RichTextEditor Labels in React (TSX)\nDESCRIPTION: Demonstrates how to use the `labels` prop on the `RichTextEditor` component to override default control labels. It initializes an editor instance using `useEditor` from `@tiptap/react` and then passes a custom labels object to the `RichTextEditor` from `@mantine/tiptap`. This allows changing accessibility attributes like `aria-label` and `title` for controls.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEditor } from '@tiptap/react';\nimport { RichTextEditor } from '@mantine/tiptap';\n\nfunction Demo() {\n  const editor = useEditor({\n    extensions: [\n      // ... your extensions\n    ],\n  });\n\n  return (\n    <RichTextEditor\n      editor={editor}\n      labels={{\n        boldControlLabel: 'Make text bold',\n        italicControlLabel: 'Make text bold',\n        // ...other labels\n      }}\n    >\n      <RichTextEditor.Content />\n    </RichTextEditor>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Refs with useMergedRef in Mantine (TypeScript)\nDESCRIPTION: This snippet shows how to use Mantine's useMergedRef hook to combine multiple refs and attach them to a single DOM node in a React function component. It demonstrates integration with useClickOutside and useFocusTrap hooks from @mantine/hooks. Dependencies include react and @mantine/hooks. Inputs are refs from useRef and Mantine hooks; output is a merged ref function to assign to a DOM element's ref prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-merged-ref.mdx#_snippet_0\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useRef } from 'react';\nimport {\n  useClickOutside,\n  useFocusTrap,\n  useMergedRef,\n} from '@mantine/hooks';\n\nfunction Demo() {\n  const myRef = useRef();\n  const useClickOutsideRef = useClickOutside(() => {});\n  const focusTrapRef = useFocusTrap();\n  const mergedRef = useMergedRef(\n    myRef,\n    useClickOutsideRef,\n    focusTrapRef\n  );\n\n  return <div ref={mergedRef} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Props with MantineThemeProvider (tsx)\nDESCRIPTION: This snippet demonstrates how to define and apply default props for Mantine components using MantineThemeProvider. It uses createTheme to specify default props for the Button component (setting color to 'cyan' and variant to 'outline') and then wraps a part of the application with MantineThemeProvider to apply this theme, ensuring buttons within this scope inherit these defaults. Requires react and @mantine/core.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/default-props.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  Button,\n  createTheme,\n  MantineThemeProvider,\n} from '@mantine/core';\n\nconst theme = createTheme({\n  components: {\n    Button: Button.extend({\n      defaultProps: {\n        color: 'cyan',\n        variant: 'outline',\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <>\n      <MantineThemeProvider theme={theme}>\n        {/* Part of the app with theme */}\n      </MantineThemeProvider>\n\n      {/* Another part without theme */}\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying valueFormatter prop for AreaChart value display in Mantine Charts with TypeScript\nDESCRIPTION: Shows usage of 'valueFormatter' prop on Mantine's AreaChart component to format y-axis and tooltip values. The example uses JavaScript's Intl.NumberFormat to format numbers as US locale strings. This enhances readability of chart data for end users. Data is passed along with series configuration to the chart component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AreaChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <AreaChart\n      h={300}\n      data={data}\n      dataKey=\"date\"\n      type=\"stacked\"\n      valueFormatter={(value) => new Intl.NumberFormat('en-US').format(value)}\n      series=[\n        { name: 'Apples', color: 'indigo.6' },\n        { name: 'Oranges', color: 'blue.6' },\n        { name: 'Tomatoes', color: 'teal.6' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Page Metadata Definition\nDESCRIPTION: This snippet defines a metadata object containing information about the page, including title, description, URL slug, category, tags, and timestamps for creation and last update. It provides context for the demo page and aids in documentation and SEO.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/inputs-placeholder-color.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const meta = {\n  title: 'How to change inputs placeholder color?',\n  description: 'Learn how to change placeholder color with Styles API',\n  slug: 'inputs-placeholder-color',\n  category: 'styles',\n  tags: ['inputs', 'dates', 'placeholder'],\n  created_at: 'January 17, 2024',\n  last_updated_at: 'January 17, 2024',\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Page Metadata and Layout in Mantine/Next.js\nDESCRIPTION: This JavaScript snippet imports a `Layout` component and defines a `meta` object containing metadata (title, description, slug, category, tags, creation/update dates) for a documentation page. It then exports the `Layout` component instantiated with this `meta` object, a common pattern in frameworks like Next.js for setting page-specific information and applying a consistent layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/submit-template.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title:\n    'How can I submit a template to Mantine documentation?',\n  description:\n    'Learn how to create and submit a template to Mantine documentation',\n  slug: 'submit-template',\n  category: 'about',\n  tags: ['template', 'community', 'contribution'],\n  created_at: 'November 15, 2024',\n  last_updated_at: 'November 15, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Using renderRoot Prop with Typed Next.js Link in Mantine Button (TypeScript)\nDESCRIPTION: This TypeScript snippet shows usage of the 'renderRoot' prop on a Mantine Button to use a statically typed Next.js Link component as the root. The callback enables passing all required props and works with Next.js 13+ Link API. Dependencies include 'next/link' and '@mantine/core'. It is suitable for integrating routing-aware links with Mantine styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-1-0.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Link from 'next/link';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button renderRoot={(props) => <Link href=\"/hello\" {...props} />}>\n      Typed Next link button\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Features in postcss-preset-mantine (JavaScript/Config)\nDESCRIPTION: Provides a configuration example showing how to disable specific features within the `postcss-preset-mantine` plugin (version 1.17.0+). This is achieved by setting feature keys (like `lightDarkFunction`, `nested`, `colorMixAlpha`, etc.) to `false` within the `features` object in the PostCSS configuration file (e.g., `postcss.config.js`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.12.0.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = {\n  plugins: { // Assuming standard PostCSS config structure\n    'postcss-preset-mantine': {\n      features: {\n        // Turn off `light-dark` function\n        lightDarkFunction: false,\n\n        // Turn off `postcss-nested` plugin\n        nested: false,\n\n        // Turn off `lighten`, `darken` and `alpha` functions\n        colorMixAlpha: false,\n\n        // Turn off `rem` and `em` functions\n        remEmFunctions: false,\n\n        // Turn off `postcss-mixins` plugin\n        mixins: false,\n      },\n    },\n    // Other PostCSS plugins...\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: useThrottledCallback Definition – TypeScript\nDESCRIPTION: Defines the `useThrottledCallback` hook in TypeScript.  It takes a callback function `callback` of type `T` and a `wait` time in milliseconds as input. It returns a throttled version of the function, ensuring it's called at most once every `wait` milliseconds. The return type matches the parameter types of the input callback.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-throttled-callback.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useThrottledCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  wait: number\n): (...args: Parameters<T>) => void;\n```\n\n----------------------------------------\n\nTITLE: Adding custom global styles in a Mantine application\nDESCRIPTION: Example of adding custom global styles to a Mantine application by creating a global CSS file (without the .module part) and using Mantine CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/global-styles.mdx#_snippet_3\n\nLANGUAGE: css\nCODE:\n```\nbody {\n  background-color: var(--mantine-color-red-filled);\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Documentation Layout for Overlay - JavaScript\nDESCRIPTION: This code snippet exports the Overlay documentation page as a layout-enhanced component by invoking the Layout HOC (Higher Order Component) with the specific MDX_DATA for Overlay. This provides contextual page structure and hands-off MDX-rendering logic. The only parameter is the Overlay doc data structure; output is the composed React component for consumption by the documentation site.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/overlay.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default Layout(MDX_DATA.Overlay);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Import Order for Mantine Component Styles in TypeScript\nDESCRIPTION: This code sample shows the wrong order for importing Mantine component styles. Importing Button styles before UnstyledButton causes the generic UnstyledButton styles to override Button styles, leading to incorrect presentation. This snippet highlights a common mistake and serves as a warning for developers on style import ordering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-files-list.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ❌ Incorrect order – UnstyledButton styles will override Button styles\nimport '@mantine/core/styles/Button.css';\nimport '@mantine/core/styles/UnstyledButton.css';\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Input Size Styles with data-size in SCSS\nDESCRIPTION: Defines SCSS rules targeting the `.wrapper` class of the Mantine `Input`. It uses `data-size` attribute selectors (`[data-size='xxl']`, `[data-size='xxs']`) to apply specific padding, height, and font-size styles to the inner `.input` element for the custom `xxl` and `xxs` sizes. Uses the `rem()` function, likely provided by Mantine's tooling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_11\n\nLANGUAGE: scss\nCODE:\n```\n.wrapper {\n  &[data-size='xxl'] {\n    & .input {\n      padding-left: rem(28px);\n      padding-right: rem(28px);\n      height: rem(68px);\n      font-size: rem(28px);\n    }\n  }\n\n  &[data-size='xxs'] {\n    & .input {\n      padding-left: rem(10px);\n      padding-right: rem(10px);\n      height: rem(28px);\n      font-size: rem(10px);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using useMouse Hook Example - Mantine React\nDESCRIPTION: This snippet showcases a basic usage scenario of the `useMouse` hook. The demonstration uses a `<Demo />` component and expects the `HooksDemos.useMouseUsage` prop to provide relevant data such as code or UI elements. Dependencies include the Mantine `HooksDemos` object and a layout component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-mouse.mdx#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={HooksDemos.useMouseUsage} />\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple Mantine Packages with CSS Layers in React TypeScript\nDESCRIPTION: This snippet shows the import pattern for including CSS layers for multiple Mantine packages in a React TypeScript setup. By referencing each package's 'styles.layer.css', each set of CSS rules is wrapped in a consistent layer, simplifying global style order management when using several Mantine packages. No additional configuration or dependencies are required.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-1-0.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.layer.css';\nimport '@mantine/dates/styles.layer.css';\n\n// ... other styles\n```\n\n----------------------------------------\n\nTITLE: Applying Google Fonts in Mantine Theme in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to create and apply a Mantine theme that uses the Google-hosted Roboto font within a Next.js app. It imports Mantine core styles and creates a theme overriding the fontFamily properties. The React component wraps the app with MantineProvider to enforce the theme globally.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/next-load-fonts.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\n\nimport {\n  createTheme,\n  DEFAULT_THEME,\n  MantineProvider,\n} from '@mantine/core';\n\nconst theme = createTheme({\n  fontFamily: 'Roboto, sans-serif',\n  fontFamilyMonospace: 'Monaco, Courier, monospace',\n  headings: {\n    // Use default theme if you want to provide default Mantine fonts as a fallback\n    fontFamily: `Roboto, ${DEFAULT_THEME.fontFamily}`,\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>Your app here</MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Throttling Input Value Updates with Mantine's useThrottledValue (TSX)\nDESCRIPTION: Uses the useThrottledValue hook from @mantine/hooks to throttle updates to a value derived from a controlled TextInput. The throttled value is displayed in real time, and updates occur at most once every 1000ms. This requires importing React useState, Mantine UI components, and Mantine hooks. It is suitable for performance-sensitive state propagation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Text, TextInput } from '@mantine/core';\nimport { useThrottledValue } from '@mantine/hooks';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  const throttledValue = useThrottledValue(value, 1000);\n\n  return (\n    <>\n      <TextInput placeholder=\"Search\" onChange={(event) => setValue(event.currentTarget.value)} />\n      <Text>Throttled value: {throttledValue || '–'}</Text>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine Components with Styled-Components (`@emotion/styled`) (TSX)\nDESCRIPTION: Illustrates creating a styled version of a Mantine `Slider` component using `@emotion/styled`. It applies styles to the root element via the styled-component wrapper and styles inner elements (`.mantine-Slider-bar`, `.mantine-Slider-thumb`) using nested static selectors targeting Mantine's internal class names. Uses Mantine CSS variables for theming.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport styled from '@emotion/styled';\nimport { Slider } from '@mantine/core';\n\nconst StyledSlider = styled(Slider)`\n  & .mantine-Slider-bar {\n    background-color: var(--mantine-color-pink-5);\n  }\n\n  & .mantine-Slider-thumb {\n    border-color: var(--mantine-color-pink-5);\n    background-color: white;\n    width: 1.5rem;\n    height: 1.5rem;\n  }\n`;\n\nfunction Demo() {\n  return <StyledSlider defaultValue={40} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Google Fonts via HTML Link Tags\nDESCRIPTION: This HTML snippet provides the standard Google Fonts embed code to load the Roboto font family with multiple font weights. It uses preconnect to improve loading performance and a stylesheet link referencing Google Fonts API. The snippet is intended to be placed inside the head section of a Next.js app. Later, the font is incorporated into a Mantine theme by specifying the font family string.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/next-load-fonts.mdx#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin />\n<link\n  href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap\"\n  rel=\"stylesheet\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Defining Vitest Scripts in package.json (JSON)\nDESCRIPTION: This snippet provides an example scripts block in package.json for running Vitest tests from the CLI or with watch mode. The vitest script runs the entire suite, while vitest:watch runs Vitest in watch mode. It's essential for facilitating test runs and should be added to the project's package.json file. Requires Vitest as a dev dependency. No configuration parameters are required beyond what is shown.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vitest.mdx#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"scripts\": {\n    \"vitest\": \"vitest run\",\n    \"vitest:watch\": \"vitest\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: RenderTreeNodePayload Interface\nDESCRIPTION: Defines the `RenderTreeNodePayload` interface, which specifies the properties passed to the `renderNode` function for customizing node rendering. It outlines the data available for rendering custom nodes, including level, expansion state, node data, and properties for the root node element.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface RenderTreeNodePayload {\n  /** Node level in the tree */\n  level: number;\n\n  /** `true` if the node is expanded, applicable only for nodes with `children` */\n  expanded: boolean;\n\n  /** `true` if the node has non-empty `children` array */\n  hasChildren: boolean;\n\n  /** `true` if the node is selected */\n  selected: boolean;\n\n  /** Node data from the `data` prop of `Tree` */\n  node: TreeNodeData;\n\n  /** Tree controller instance, return value of `useTree` hook */\n  tree: TreeController;\n\n  /** Props to spread into the root node element */\n  elementProps: {\n    className: string;\n    style: React.CSSProperties;\n    onClick: (event: React.MouseEvent) => void;\n    'data-selected': boolean | undefined;\n    'data-value': string;\n    'data-hovered': boolean | undefined;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Font Size Variables in CSS\nDESCRIPTION: Demonstrates referencing user-defined font size variables in stylesheets for consistent appearance on elements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_7\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  font-size: var(--mantine-font-size-xxs);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Redirect Component (JavaScript)\nDESCRIPTION: This snippet imports the 'Redirect' component from a specific path within the project's component library. This component encapsulates the logic required to perform a client-side navigation, acting as a prerequisite for triggering a redirect.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/notifications.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n```\n\n----------------------------------------\n\nTITLE: Navigating to the Web Directory (Bash)\nDESCRIPTION: Changes the current directory to the `web` subdirectory within the RedwoodJS project. This is necessary before installing web-specific dependencies like Mantine. It's recommended to use `yarn` for installations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/redwood.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd web\n```\n\n----------------------------------------\n\nTITLE: Migrating theme referencing to CSS variables\nDESCRIPTION: Shows how to migrate from referencing theme object in 6.x to using CSS variables in 7.x for styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      sx={(theme) => ({\n        backgroundColor: theme.colors.red[6],\n        color: theme.white,\n        padding: `calc(${theme.spacing.xl} * 2)`,\n      })}\n    />\n  );\n}\n```\n\nLANGUAGE: scss\nCODE:\n```\n/* 7.0 */\n.box {\n  background-color: var(--mantine-color-red-6);\n  color: var(--mantine-color-white);\n  padding: calc(var(--mantine-spacing-xl) * 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing createStyles with CSS Modules\nDESCRIPTION: Shows how to migrate from createStyles in 6.x to CSS Modules in 7.x for styling components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { createStyles } from '@mantine/core';\n\nconst useStyles = createStyles((theme) => ({\n  root: {\n    backgroundColor: theme.colors.red[5],\n  },\n}));\n```\n\nLANGUAGE: scss\nCODE:\n```\n/* 7.0 */\n.root {\n  background-color: var(--mantine-color-red-5);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling onChangeEnd event for user interaction\nDESCRIPTION: Shows usage of the onChangeEnd callback to respond when the user stops dragging or changes the value with the keyboard, suitable for debounced updates or final value processing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/angle-slider.mdx#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={AngleSliderDemos.onChangeEnd} />\n```\n\n----------------------------------------\n\nTITLE: Using consistentWeeks setting in Mantine DatesProvider in TypeScript\nDESCRIPTION: Illustrates how to enforce consistent 6-week calendar layouts for each month inside Mantine's DatePicker by wrapping the component with DatesProvider and setting 'consistentWeeks: true' in its settings property. This prevents layout shifts during month changes and improves UI stability. Requires '@mantine/dates' package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { DatePicker, DatesProvider } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <DatesProvider settings={{ consistentWeeks: true }}>\n      <DatePicker />\n    </DatesProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple Mantine Style Layers\nDESCRIPTION: Shows importing multiple Mantine style layer files to include styles across different packages, replacing traditional styles imports. This ensures styles are loaded with layering support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.layer.css';\nimport '@mantine/dates/styles.layer.css';\n// ... other styles\n```\n\n----------------------------------------\n\nTITLE: Using the New Mantine BubbleChart Component (TSX)\nDESCRIPTION: Example usage of the new `BubbleChart` component from `@mantine/charts`. It shows how to configure the chart's height (`h`), data source (`data`), bubble size range (`range`), label (`label`), color (`color`), and data keys (`dataKey`). Assumes `data` is imported from a local `./data` file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { BubbleChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BubbleChart\n      h={60}\n      data={data}\n      range={[16, 225]}\n      label=\"Sales/hour\"\n      color=\"lime.6\"\n      dataKey={{ x: 'hour', y: 'index', z: 'value' }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Font Family Variables in CSS\nDESCRIPTION: Demonstrates how to access Mantine font family CSS variables within stylesheets for consistent, theme-based styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_2\n\nLANGUAGE: SCSS\nCODE:\n```\n.text {\n  font-family: var(--mantine-font-family);\n}\n\n.code {\n  font-family: var(--mantine-font-family-monospace);\n}\n\n.heading {\n  font-family: var(--mantine-font-family-headings);\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Disabled State of DateInput\nDESCRIPTION: This snippet presents the DateInput component in a disabled state using a demo data set. It illustrates how to render the component as non-interactive for scenarios requiring display-only mode.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.disabled} />\n```\n\n----------------------------------------\n\nTITLE: Using Mantine CodeHighlightTabs for Syntax Highlighting (TSX)\nDESCRIPTION: Illustrates the usage of the `CodeHighlightTabs` component from the `@mantine/code-highlight` package, which replaces the deprecated `@mantine/prism`. This example shows how to display multiple code snippets (TSX, CSS/SCSS) in tabs with syntax highlighting and custom file icons based on filename. Requires `@mantine/code-highlight` and potentially icon packages like `@mantinex/dev-icons`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\nimport { CodeHighlightTabs } from '@mantine/code-highlight';\nimport { CssIcon, TypeScriptIcon } from '@mantinex/dev-icons';\n\nconst tsxCode = `\nfunction Button() {\n  return <button>Click me</button>;\n}\n`;\n\nconst cssCode = `\n.button {\n  background-color: transparent;\n  color: var(--mantine-color-blue-9);\n}\n`;\n\nfunction getFileIcon(fileName: string) {\n  if (fileName.endsWith('.ts') || fileName.endsWith('.tsx')) {\n    return <TypeScriptIcon size={18} />;\n  }\n\n  if (fileName.endsWith('.css')) {\n    return <CssIcon size={18} />;\n  }\n\n  return null;\n}\n\nfunction Demo() {\n  return (\n    <CodeHighlightTabs\n      getFileIcon={getFileIcon}\n      code={[\n        {\n          fileName: 'Button.tsx',\n          code: tsxCode,\n          language: 'tsx',\n        },\n        {\n          fileName: 'Button.module.css',\n          code: cssCode,\n          language: 'scss',\n        },\n      ]}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Device Orientation with Mantine's useOrientation Hook (TSX)\nDESCRIPTION: Demonstrates using the useOrientation hook from @mantine/hooks to access and display the device's orientation data (angle and type). Relies on Mantine Code and Text components for UI. No dependencies beyond Mantine and React are required. Useful for responsive UIs reacting to device orientation changes; outputs browser/device orientation angle and type.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Code, Text } from '@mantine/core';\nimport { useOrientation } from '@mantine/hooks';\n\nfunction Demo() {\n  const { angle, type } = useOrientation();\n  return (\n    <>\n      <Text>\n        Angle: <Code>{angle}</Code>\n      </Text>\n      <Text>\n        Type: <Code>{type}</Code>\n      </Text>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Badge Component Usage with Next.js Integration (JSX/React)\nDESCRIPTION: This snippet demonstrates the polymorphic rendering of the Badge component by switching the base element from a 'div' to an 'a' tag using the <Polymorphic> utility. This feature, enabled via the 'withNext' prop, increases flexibility when integrating the Badge component in navigation or link-rich contexts such as Next.js routing. The snippet assumes Polymorphic utility is available and properly configured within the Mantine project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/badge.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Polymorphic\n  defaultElement=\"div\"\n  changeToElement=\"a\"\n  component=\"Badge\"\n  withNext\n/>\n```\n\n----------------------------------------\n\nTITLE: Applying Conditional Display Styles with PostCSS Mixins in SCSS\nDESCRIPTION: This SCSS snippet illustrates how to use the `light` and `dark` PostCSS mixins from `postcss-presets-mantine` to conditionally hide elements based on the active Mantine color scheme. Classes applying these mixins (e.g., `.lightHidden` or `.darkHidden`) can be used on elements to control their `display` property based on the color scheme, providing a server-side rendering compatible method for conditional styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/light-dark-elements.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n.lightHidden {\n  @mixin light {\n    display: none;\n  }\n}\n\n.darkHidden {\n  @mixin dark {\n    display: none;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Error when calling extend() from server component\nDESCRIPTION: This snippet shows an error caused by trying to call `Button.extend()` in a server component without the `'use client'` directive. The fix involves adding `'use client'` at the top.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ❌ This will throw an error\nimport { Button, createTheme } from '@mantine/core';\n\nexport const theme = createTheme({\n  components: {\n    Button: Button.extend({}),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Waterfall BarChart in Mantine (TSX)\nDESCRIPTION: Shows how to configure a `BarChart` from `@mantine/charts` to use the `waterfall` type for visualizing value changes over time. Key props demonstrated include `h`, `data`, `dataKey`, `type`, `series`, and `withLegend`. Assumes `data` is imported from a local `./data` file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={data}\n      dataKey=\"item\"\n      type=\"waterfall\"\n      series={[{ name: 'Effective tax rate in %', color: 'blue' }]}\n      withLegend\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Mantine Affix Documentation Page - JavaScript\nDESCRIPTION: Exports the default component for the Affix documentation page. It wraps the specific MDX data content for the Affix component (`MDX_DATA.Affix`) within the general documentation site's `Layout` component. This is the main entry point for rendering this specific documentation page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/affix.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.Affix);\n```\n\n----------------------------------------\n\nTITLE: Setting Default Opened Items - String Value\nDESCRIPTION: Demonstrates how to set a default opened item when `multiple` prop is false. The `defaultValue` prop is used to specify the value (string) of the item to be opened by default. This sets the initial state of the Accordion. The Accordion.Item's value corresponds to the string passed to defaultValue.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/accordion.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Accordion } from '@mantine/core';\n\nfunction Demo() {\n  // Second item will be opened by default\n  return (\n    <Accordion defaultValue=\"item-2\">\n      <Accordion.Item value=\"item-1\">\n        <Accordion.Control>control-1</Accordion.Control>\n        <Accordion.Panel>panel-1</Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item value=\"item-2\">\n        <Accordion.Control>control-2</Accordion.Control>\n        <Accordion.Panel>panel-2</Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Prefix in SCSS for MantineProvider\nDESCRIPTION: This SCSS snippet shows how to adapt the attribute selector when using a custom `classNamesPrefix` within the `MantineProvider`. It changes the selector from `mantine-` to whatever the custom prefix is. This example sets the text color to red for all components with the prefix 'app'. It demonstrates adapting to different prefix configurations set in the MantineProvider.  Input is dependent on the prefix configured for the MantineProvider, output will be the new prefix taking effect.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/apply-styles-to-all.mdx#_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n[class^=app] {\n  color: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Local Fonts with next/font in TypeScript\nDESCRIPTION: This snippet demonstrates how to load custom local fonts in a Next.js project using the next/font/local package. It shows a TypeScript module that imports font files (.woff2) with specific font-weight and style attributes. The output is a font object with styling information to be used in theming. Dependencies include Next.js and next/font package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/next-load-fonts.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport localFont from 'next/font/local';\n\nexport const greycliffCF = localFont({\n  src: [\n    {\n      path: './GreycliffCF-Bold.woff2',\n      weight: '700',\n      style: 'normal',\n    },\n    {\n      path: './GreycliffCF-Heavy.woff2',\n      weight: '900',\n      style: 'normal',\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Visual Indicators for Checkboxes and Radios in Mantine\nDESCRIPTION: This code demonstrates the `Checkbox.Indicator` and `Radio.Indicator` components, which provide purely visual states for checkboxes and radios without semantic meaning. These indicators can be styled individually to reflect checked, indeterminate, or disabled states, facilitating custom UI designs without affecting accessibility. Dependencies include core components from Mantine.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.10.0.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Checkbox, Group } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Group>\n      <Checkbox.Indicator />\n      <Checkbox.Indicator checked />\n      <Checkbox.Indicator indeterminate />\n      <Checkbox.Indicator disabled />\n      <Checkbox.Indicator disabled checked />\n      <Checkbox.Indicator disabled indeterminate />\n    </Group>\n  );\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Group, Radio } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Group>\n      <Radio.Indicator />\n      <Radio.Indicator checked />\n      <Radio.Indicator disabled />\n      <Radio.Indicator disabled checked />\n    </Group>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Mantine usePagination Hook\nDESCRIPTION: Demonstrates basic initialization and usage of the `usePagination` hook in an uncontrolled state. It shows how to access the calculated `range` property and call various methods like `setPage`, `next`, `previous`, `last`, and `first` to navigate pages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-pagination.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { usePagination } from '@mantine/hooks';\n\nconst pagination = usePagination({ total: 10, initialPage: 1 });\n\npagination.range; // -> [1, 2, 3, 4, 5, 'dots', 10];\n\npagination.setPage(5);\npagination.range; // -> [1, 'dots', 4, 5, 6, 'dots', 10];\n\npagination.next();\npagination.range; // -> [1, 'dots', 5, 6, 7, 'dots', 10];\n\npagination.previous();\npagination.range; // -> [1, 'dots', 4, 5, 6, 'dots', 10];\n\npagination.last();\npagination.range; // -> [1, 'dots', 6, 7, 8, 9, 10];\n\npagination.first();\npagination.range; // -> [1, 2, 3, 4, 5, 'dots', 10];\n```\n\n----------------------------------------\n\nTITLE: Generating CSS Gradients with getGradient in Mantine Core (TSX)\nDESCRIPTION: Shows how to use the `getGradient` function to create a CSS `linear-gradient` string from a `MantineGradient` object, which specifies the gradient angle (`deg`), starting color (`from`), and ending color (`to`). Requires the gradient configuration object and the Mantine theme object to resolve any theme colors used.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getGradient, useMantineTheme } from '@mantine/core';\n\nfunction Demo() {\n  const theme = useMantineTheme();\n\n  getGradient({ deg: 180, from: 'blue', to: 'cyan.7' }, theme);\n  // -> `linear-gradient(180deg, var(--mantine-color-blue-filled) 0%, var(--mantine-color-cyan-7) 100%)`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Mantine Carousel with Responsive Slide Props (TSX)\nDESCRIPTION: Demonstrates using the object format for responsive props (`slideSize`, `slideGap`) in the Mantine Carousel component, replacing the previous `breakpoints` prop. This allows defining different slide sizes and gaps based on screen breakpoints (base, sm, md). Requires `@mantine/carousel`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Carousel } from '@mantine/carousel';\n\nfunction Demo() {\n  return (\n    <Carousel\n      withIndicators\n      height={200}\n      slideSize={{ base: '100%', sm: '50%', md: '33.333333%' }}\n      slideGap={{ base: 0, sm: 'md' }}\n      loop\n      align=\"start\"\n    >\n      <Carousel.Slide>1</Carousel.Slide>\n      <Carousel.Slide>2</Carousel.Slide>\n      <Carousel.Slide>3</Carousel.Slide>\n      {/* ...other slides */}\n    </Carousel>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reading local storage value with default hook behavior in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of Mantine's useLocalStorage hook in a React component, fetching a color scheme value ('light' or 'dark') that initializes from local storage after component mounts to prevent hydration issues. Dependencies include '@mantine/hooks'. The hook returns a state variable 'value' and a setter 'setValue', with default value 'dark'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/local-storage-effect.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useLocalStorage } from '@mantine/hooks';\n\nfunction Demo() {\n  const [value, setValue] = useLocalStorage<'light' | 'dark'>({\n    key: 'color-scheme',\n    defaultValue: 'dark',\n  });\n\n  return <div>{value}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Extending ButtonVariant Type\nDESCRIPTION: This code snippet demonstrates how to extend the `ButtonVariant` type from the `@mantine/core` library. It allows adding custom variants like 'contrast' and 'radial-gradient' to the `ButtonProps` interface. This is achieved by creating a `mantine.d.ts` file in your project and extending the `ButtonProps` interface to include the new variant type. This ensures type safety when using custom variants.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/variants-sizes.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ButtonVariant, MantineSize } from '@mantine/core';\n\ntype ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';\n\ndeclare module '@mantine/core' {\n  export interface ButtonProps {\n    variant?: ExtendedButtonVariant;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Accordion State - Single Selection\nDESCRIPTION: Demonstrates state management for a single-select Accordion using React's `useState` hook.  The `value` prop is used to bind the Accordion's state to a string representing the currently selected item.  The `onChange` prop is used to update the state, allowing the user's selection to be reflected in the component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/accordion.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Accordion } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<string | null>(null);\n\n  return (\n    <Accordion value={value} onChange={setValue}>\n      <Accordion.Item value=\"item-1\">\n        <Accordion.Control>control-1</Accordion.Control>\n        <Accordion.Panel>panel-1</Accordion.Panel>\n      </Accordion.Item>\n\n      <Accordion.Item value=\"item-2\">\n        <Accordion.Control>control-2</Accordion.Control>\n        <Accordion.Panel>panel-2</Accordion.Panel>\n      </Accordion.Item>\n    </Accordion>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Redirect Component in React (JavaScript)\nDESCRIPTION: This snippet demonstrates importing a custom Redirect component and rendering it to navigate users to the '/x/dropzone' route. It requires React and the Redirect component from the project's components directory; it outputs a redirection effect when rendered.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/dropzone.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n\n<Redirect to=\"/x/dropzone\" />\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine global styles in TSX\nDESCRIPTION: Shows how to import the global CSS styles required for Mantine components to work properly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/global-styles.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Accessing and Using Mantine Component Static Classes in Custom Elements (TypeScript)\nDESCRIPTION: This code snippet shows how to use Mantine's Button.classes object to access static CSS class names, applying consistent styles to custom button elements outside the main Mantine components. Requires importing the Button component from @mantine/core. The output button mimics the root styling of Mantine's Button by applying the .mantine-Button-root class provided via Button.classes.root.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-api.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return <button type=\"button\" className={Button.classes.root} />;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Controlled Radio Component in React with Mantine\nDESCRIPTION: Demonstrates how to implement a controlled Radio component using React state hooks. The component's checked state is managed by the useState hook and updated through the onChange event handler.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/radio.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Radio } from '@mantine/core';\n\nfunction Demo() {\n  const [checked, setChecked] = useState(false);\n  return (\n    <Radio\n      checked={checked}\n      onChange={(event) => setChecked(event.currentTarget.checked)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing sx prop with className or style\nDESCRIPTION: Shows how to migrate from sx prop in 6.x to className or style prop in 7.x for applying styles to components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// 6.x\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box sx={(theme) => ({ backgroundColor: theme.colors.red[5] })} />\n  );\n}\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// 7.0\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box style={{ backgroundColor: 'var(--mantine-color-red-5)' }} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Add NPM Script for CSS Linting\nDESCRIPTION: Specifies a JSON snippet to add a script in `package.json` that runs Stylelint across all CSS files in the project, using cache for improved performance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"stylelint\": \"stylelint '**/*.css' --cache\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Week Numbers in DatePicker Component\nDESCRIPTION: This code demonstrates enabling the 'withWeekNumbers' prop in DatePicker and related components, which displays week numbers alongside dates for improved calendar context.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={DatePickerDemos.withWeekNumbers} />\n```\n\n----------------------------------------\n\nTITLE: Allowing duplicates in TagsInput with allowDuplicates\nDESCRIPTION: This snippet enables duplicate entry detection by setting 'allowDuplicates' to true, permitting users to add the same value multiple times regardless of case or whitespace. Default behavior disallows duplicates.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.allowDuplicates} />\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Core and Hooks Packages\nDESCRIPTION: Commands to install the required Mantine packages using either yarn or npm package managers. Both @mantine/core and @mantine/hooks packages are necessary dependencies.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/core/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/core @mantine/hooks\n\n# With npm\nnpm install @mantine/core @mantine/hooks\n```\n\n----------------------------------------\n\nTITLE: Using Outline Variant in Checkbox and Radio Components (Mantine, TypeScript)\nDESCRIPTION: Demonstrates the usage of 'outline' variant for Mantine Checkbox and Radio components. All require '@mantine/core' with outline variant support. Renders a Stack layout with checked and indeterminate states.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Checkbox, Radio, Stack } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Stack gap={7}>\n      <Checkbox variant=\"outline\" label=\"Outline Checkbox\" defaultChecked />\n      <Checkbox variant=\"outline\" label=\"Outline indeterminate Checkbox\" indeterminate />\n      <Radio variant=\"outline\" label=\"Outline Radio\" defaultChecked />\n    </Stack>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: MantineProvider with env Prop for Testing (TSX)\nDESCRIPTION: This code snippet demonstrates how to use the `env` prop of the MantineProvider component to configure the environment for testing. Setting `env` to `test` disables features like transitions and portals that might interfere with testing. It sets up the MantineProvider in a test environment, ensuring that components behave predictably during testing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-17-0.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider env=\"test\">\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Clamping Number with Mantine Hooks (TSX)\nDESCRIPTION: Demonstrates how to use the `clamp` function from `@mantine/hooks`. This function limits a number within specified inclusive lower and upper bounds. Examples show usage with both min/max, only min, and only max boundaries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/functions-reference.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { clamp } from '@mantine/hooks';\n\n// With both min and max boundaries\nclamp(10, 0, 5); // 5\nclamp(100, 0, 5); // 5\nclamp(-100, 0, 5); // 0\n\n// With only min boundary\nclamp(10, 0, undefined); // 10\nclamp(-100, 0, undefined); // 0\n\n// With only max boundary\nclamp(0, undefined, 5); // 0\nclamp(10, undefined, 5); // 5\n```\n\n----------------------------------------\n\nTITLE: Introducing the Combobox Component for Advanced Inputs\nDESCRIPTION: A flexible new component supporting custom selects, autocompletes, tags, and multiselects, serving as the base for updated Autocomplete, Select, TagsInput, and MultiSelect components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_26\n\n\n\n----------------------------------------\n\nTITLE: Using ScrollArea with scrollbars Prop\nDESCRIPTION: This code shows how to use the `scrollbars` prop on the `ScrollArea` component. It allows controlling the scrollbar directions.  Dependencies include `@mantine/core`. Setting `scrollbars=\"y\"` only renders the vertical scrollbar.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, ScrollArea } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <ScrollArea w={300} h={200} scrollbars=\"y\">\n      <Box w={600}>{/* ... content */}</Box>\n    </ScrollArea>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Mantine Button with Next.js Link (<= v12) (TSX)\nDESCRIPTION: Illustrates how to use a Mantine `Button` as a child of the Next.js `Link` component for versions 12 and below. The `passHref` prop is required on the `Link`, and the `Button` uses `component=\"a\"` to render the necessary anchor tag.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport Link from 'next/link';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Link href=\"/hello\" passHref>\n      <Button component=\"a\">Next link button</Button>\n    </Link>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing custom components with Tooltip using ref forwarding\nDESCRIPTION: Demonstrates two approaches for creating custom components that work with Tooltip: using forwardRef and using a custom refProp. Both methods allow the Tooltip to access the DOM node for positioning.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tooltip.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { forwardRef } from 'react';\nimport { Tooltip } from '@mantine/core';\n\n// forwardRef function will allow to get root element ref\nconst MyBadge = forwardRef<HTMLDivElement, { color: string }>(\n  ({ color }, ref) => (\n    <div ref={ref} color={color}>\n      Badge\n    </div>\n  )\n);\n\n// other props can also be used\nfunction MyOtherBadge({\n  color,\n  innerRef,\n}: {\n  color: string;\n  innerRef?: React.ForwardedRef<HTMLDivElement>;\n}) {\n  return (\n    <div ref={innerRef} color={color}>\n      Badge\n    </div>\n  );\n}\n\nfunction Demo() {\n  return (\n    <>\n      <Tooltip label=\"Can be used as is\">\n        <MyBadge color=\"red\" />\n      </Tooltip>\n\n      <Tooltip label=\"refProp is required\" refProp=\"innerRef\">\n        <MyOtherBadge color=\"orange\" />\n      </Tooltip>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Responsive Visibility with `hiddenFrom` and `visibleFrom` Props in Mantine (TSX)\nDESCRIPTION: Shows how to use the `hiddenFrom` and `visibleFrom` props, available on all Mantine components, to control element visibility based on viewport breakpoints. This example uses these props on `Button` components within a `Group` to hide or show them at specific screen sizes ('sm', 'md').\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_31\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Group } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Group justify=\"center\">\n      <Button hiddenFrom=\"sm\" color=\"orange\">\n        Hidden from sm\n      </Button>\n      <Button visibleFrom=\"sm\" color=\"cyan\">\n        Visible from sm\n      </Button>\n      <Button visibleFrom=\"md\" color=\"pink\">\n        Visible from md\n      </Button>\n    </Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Fields with Zod and useForm\nDESCRIPTION: This snippet illustrates how to validate nested fields using Zod with Mantine Form. It defines a schema for a nested object and uses `zodResolver` to integrate it with the form. The `useForm` hook is used, and the example demonstrates accessing validation errors for nested fields.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { zodResolver } from 'mantine-form-zod-resolver';\nimport { z } from 'zod';\nimport { useForm } from '@mantine/form';\n\nconst nestedSchema = z.object({\n  nested: z.object({\n    field: z\n      .string()\n      .min(2, { message: 'Field should have at least 2 letters' }),\n  }),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    nested: {\n      field: '',\n    },\n  },\n  validate: zodResolver(nestedSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'nested.field': 'Field should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Using styles Prop for Nested Element Styling\nDESCRIPTION: This React component uses the `styles` prop to customize the appearance of a Mantine `Button`. The `styles` prop allows for targeting nested elements within a component and allows for conditional styling. It accesses the theme and component properties and also uses the light/dark utilities.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      color=\"red\"\n      styles={(theme, { color }, u) => ({\n        root: {\n          padding: 10,\n          backgroundColor: theme.colors[color || 'blue'][7],\n          color: theme.white,\n\n          '&:hover': {\n            backgroundColor: theme.colors[color || 'blue'][8],\n          },\n        },\n\n        label: {\n          [u.light]: {\n            border: `1px solid ${theme.black}`,\n          },\n          [u.dark]: {\n            border: `1px solid ${theme.white}`,\n          },\n        },\n      })}\n    >\n      Button with styles prop\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Custom Redirect Component in Next.js with TypeScript\nDESCRIPTION: Imports the Redirect component from the local '@/components/Redirect' path, then immediately renders it to programmatically redirect users to the '/x/spotlight' route. Assumes the existence of a properly implemented Redirect component with a 'to' prop string for the destination path. Requires a Next.js or React environment with TypeScript support and the '@/components/Redirect' file present. When the file renders, users are instantly navigated to '/x/spotlight' with no additional inputs or outputs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/spotlight.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n\n<Redirect to=\"/x/spotlight\" />\n```\n\n----------------------------------------\n\nTITLE: Integrating Custom Font in Mantine Theme (Local)\nDESCRIPTION: This TypeScript snippet creates a Mantine theme and sets the `fontFamily` and `headings.fontFamily` properties to use the 'Greycliff CF' font. It also imports necessary Mantine components and styles. The GreycliffCF.css file must be imported for this to work.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/vite-load-fonts.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createTheme,\n  DEFAULT_THEME,\n  MantineProvider,\n} from '@mantine/core';\n\nimport '@mantine/core/styles.css';\nimport './GreycliffCF/GreycliffCF.css';\n\nconst theme = createTheme({\n  fontFamily: 'Greycliff CF, sans-serif',\n  fontFamilyMonospace: 'Monaco, Courier, monospace',\n  headings: {\n    // Use default theme if you want to provide default Mantine fonts as a fallback\n    fontFamily: `Greycliff CF, ${DEFAULT_THEME.fontFamily}`,\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>Your app here</MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Responsive Props in Mantine Grid Columns (TSX)\nDESCRIPTION: Demonstrates the use of the object format for the `span` prop within `Grid.Col` components in Mantine Grid. This enables defining responsive column spans across different breakpoints (base, md, lg), similar to style props. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Grid } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Grid>\n      <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>1</Grid.Col>\n      <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>2</Grid.Col>\n      <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>3</Grid.Col>\n      <Grid.Col span={{ base: 12, md: 6, lg: 3 }}>4</Grid.Col>\n    </Grid>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Font Sizes with createTheme in Mantine (TypeScript)\nDESCRIPTION: Shows how to set custom font size values for Mantine components by defining a theme object with fontSizes property using createTheme and applying it with MantineProvider. The snippet illustrates configuring font sizes like xs, sm, md, lg, xl with rem units, affecting the overall typography scale.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/typography.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineProvider, rem } from '@mantine/core';\n\nconst theme = createTheme({\n  fontSizes: {\n    xs: rem(10),\n    sm: rem(11),\n    md: rem(14),\n    lg: rem(16),\n    xl: rem(20),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Nested Inline Styles Using Emotion in TypeScript/TSX\nDESCRIPTION: Demonstrates the syntax for using nested inline styles with the Emotion CSS-in-JS library in a React component. It illustrates how to apply a hotpink background and a lightgreen hover effect in an inline style object passed through the `css` prop. Requires Emotion setup and React environment. Input is JSX with CSS-in-JS syntax, output is styled React elements in the DOM.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/nested-inline-styles.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nrender(\n  <div\n    css={{\n      backgroundColor: 'hotpink',\n      '&:hover': {\n        color: 'lightgreen',\n      },\n    }}\n  >\n    This has a hotpink background.\n  </div>\n);\n```\n\n----------------------------------------\n\nTITLE: Using CSS Variables in style Prop with Mantine Box Component (TypeScript)\nDESCRIPTION: This snippet demonstrates defining and consuming custom CSS variables directly in the 'style' prop of a Mantine Box component in React TypeScript. The example assigns '--radius' and references it via 'borderRadius', enabling advanced theming and dynamic styling beyond the limitations of 'React.CSSProperties'. No special dependencies are needed apart from '@mantine/core'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-1-0.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      style={{ '--radius': '0.5rem', borderRadius: 'var(--radius)' }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Dynamic Component Prop Types (TSX)\nDESCRIPTION: Illustrates two approaches for using a dynamic value (e.g., based on a condition) in the `component` prop of a polymorphic Mantine `Box` component. Type checking can be maintained by providing explicit types (`<'input'>`) and casting the dynamic value to `any`, or disabled entirely by passing `any` as the type argument (`<any>`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction KeepTypes() {\n  return (\n    <Box<'input'>\n      component={(Math.random() > 0.5 ? 'input' : 'div') as any}\n    />\n  );\n}\n\nfunction NukeTypes() {\n  return (\n    <Box<any> component={Math.random() > 0.5 ? 'input' : 'div'} />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Tooltip transition animation\nDESCRIPTION: Demonstrates how to change the animation when the tooltip appears and disappears using the transitionProps property to specify transition type and duration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tooltip.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, Tooltip } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Tooltip\n      label=\"Tooltip with custom transition\"\n      transitionProps={{ transition: 'skew-up', duration: 300 }}\n    >\n      <Button>Button with tooltip</Button>\n    </Tooltip>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring enhanceGetInputProps for Input Disabling\nDESCRIPTION: This code demonstrates using `enhanceGetInputProps` within a `@mantine/form` hook. It disables a `TextInput` component based on the field path.  Dependencies include `@mantine/core` and `@mantine/form`. The input is disabled when the field path matches 'name'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NumberInput, TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\ninterface FormValues {\n  name: string;\n  age: number | string;\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    initialValues: { name: '', age: '' },\n    enhanceGetInputProps: (payload) => ({\n      disabled: payload.field === 'name',\n    }),\n  });\n\n  return (\n    <>\n      <TextInput {...form.getInputProps('name')} label=\"Name\" placeholder=\"Name\" />\n      <NumberInput {...form.getInputProps('age')} label=\"Age\" placeholder=\"Age\" mt=\"md\" />\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example package.json After Mantine Update\nDESCRIPTION: Shows the same package.json file after manually updating Mantine dependencies to specific versions. All @mantine/* packages are updated to 7.3.0 and postcss-preset-mantine to 1.11.0.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-update-dependencies.mdx#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"your-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {},\n  \"dependencies\": {\n    \"@mantine/core\": \"^7.3.0\",\n    \"@mantine/hooks\": \"^7.3.0\",\n    \"next\": \"14.0.2\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"postcss\": \"^8.4.31\",\n    \"postcss-preset-mantine\": \"^1.11.0\",\n    \"prettier\": \"^3.1.0\",\n    \"typescript\": \"5.2.2\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Controlled Radio Group in Mantine\nDESCRIPTION: Demonstrates how to create a controlled Radio.Group component with multiple Radio options. The group's value is managed with React state and includes a label, description, and required indicator.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/radio.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Radio } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState('react');\n\n  return (\n    <Radio.Group\n      value={value}\n      onChange={setValue}\n      name=\"favoriteFramework\"\n      label=\"Select your favorite framework/library\"\n      description=\"This is anonymous\"\n      withAsterisk\n    >\n      <Radio value=\"react\" label=\"React\" />\n      <Radio value=\"svelte\" label=\"Svelte\" />\n      <Radio value=\"ng\" label=\"Angular\" />\n      <Radio value=\"vue\" label=\"Vue\" />\n    </Radio.Group>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating emotion.d.ts for SX & Styles in Next.js Pages\nDESCRIPTION: This snippet shows creating a `emotion.d.ts` file for extending Mantine's types to include the `sx` and `styles` props when using Emotion in Next.js. This is necessary for proper type-checking with TypeScript. It imports from `@mantine/core` and `@mantine/emotion`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core';\n\nimport type { EmotionStyles, EmotionSx } from '@mantine/emotion';\n\ndeclare module '@mantine/core' {\n  export interface BoxProps {\n    sx?: EmotionSx;\n    styles?: EmotionStyles;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Overlay Demos and Layout in React - JavaScript\nDESCRIPTION: This snippet imports demonstration modules (`OverlayDemos`), a custom page layout (`Layout`), and documentation data (`MDX_DATA`) required for the Overlay documentation page. It uses ES module syntax and serves as the foundational setup for rendering interactive demos and structured layouts. No direct input or output, but these imports are prerequisites for all usage and demo examples.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/overlay.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { OverlayDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: useOrientation Hook Definition\nDESCRIPTION: Defines the options interface, return type interface, and the function signature for the useOrientation hook in TypeScript.  It specifies the structure of the returned object, available options to customize the hook's behavior, including default values and SSR safety.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-orientation.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface UseOrientationOptions {\n  /** Default angle value, used until the real can be retrieved\n   * (during server side rendering and before js executes on the page)\n   * If not provided, the default value is `0`\n   * */\n  defaultAngle?: number;\n\n  /** Default angle value, used until the real can be retrieved\n   * (during server side rendering and before js executes on the page)\n   * If not provided, the default value is `'landscape-primary'`\n   * */\n  defaultType?: OrientationType;\n\n  /** If true, the initial value will be resolved in useEffect (ssr safe)\n   *  If false, the initial value will be resolved in useLayoutEffect (ssr unsafe)\n   *  True by default.\n   */\n  getInitialValueInEffect?: boolean;\n}\n\ninterface UseOrientationReturnType {\n  angle: number;\n  type: OrientationType;\n}\n\nfunction useOrientation(options?: UseOrientationOptions): UseOrientationReturnType\n```\n\n----------------------------------------\n\nTITLE: Accessing Form Values with getValues\nDESCRIPTION: This TypeScript code illustrates how to retrieve the current form values using `form.getValues()` in uncontrolled mode. It highlights that `form.values` is not reactive in uncontrolled mode, and `form.getValues()` must be used instead to get the latest form state.  It assumes `useForm` hook is initialized with the mode set to 'uncontrolled'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n});\n\nform.getValues(); // { name: 'John Doe' }\n\nform.setValues({ name: 'John Smith' });\nform.getValues(); // { name: 'John Smith' }\n```\n\n----------------------------------------\n\nTITLE: Import Layout Component\nDESCRIPTION: Imports a Layout component from a specified path. This is typically used to wrap the page content within a consistent layout framework.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Example of using hooks in a server component\nDESCRIPTION: This snippet shows an incorrect usage of React hooks (`useRef`) in a server component without the 'use client' directive, leading to an error when hooks are used outside client components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ❌ This will throw an error\nimport { useRef } from 'react';\n\nfunction Demo() {\n  const ref = useRef();\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Integrating Badge Demo Data in Mantine (JavaScript/React)\nDESCRIPTION: This snippet imports Badge demo data from the '@docs/demos' package and supporting layout/MDX modules to create a documentation page for the Mantine Badge component. No external dependencies beyond the referenced packages are required. The code initializes the page with relevant layout and data, enabling the dynamic rendering of demo content for users.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/badge.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { BadgeDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Badge);\n```\n\n----------------------------------------\n\nTITLE: Button with Left and Right Sections in TypeScript\nDESCRIPTION: This code demonstrates how to create a button with left and right sections using the Mantine library. The `leftSection` and `rightSection` props define the content of these sections, which generates `data-position` attributes, allowing for individual styling of each section.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button leftSection=\"L\" rightSection=\"R\">\n      Label\n    </Button>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Applying useFocusTrap Ref to DOM and Mantine Components in TypeScript\nDESCRIPTION: This example illustrates how to apply the ref returned by useFocusTrap to both a standard HTML div element and a Mantine UI Paper component. It highlights the flexibility of the hook to be used with native DOM nodes or third-party components that support forwarding refs. The ref is essential for managing focus containment within the assigned node.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-trap.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Paper } from '@mantine/core';\nimport { useFocusTrap } from '@mantine/hooks';\n\nfunction Demo() {\n  const focusTrapRef = useFocusTrap();\n\n  return (\n    <>\n      {/* With regular element: */}\n      <div ref={focusTrapRef} />\n\n      {/* With Mantine component: */}\n      <Paper ref={focusTrapRef} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Mixed Stacks in BarChart – TypeScript/React\nDESCRIPTION: This snippet illustrates how to create stacked bar charts with mixed stacking groups in BarChart by setting the 'stackId' property for each series. Requires @mantine/charts, a data array, and React. Each series object includes 'stackId' to determine which series are visually stacked together. The bar chart visualizes grouped and independently stacked series per the 'stackId' values. Inputs are categorical data; output is a compositely stacked bar chart.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.13.0.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { BarChart } from '@mantine/charts';\nimport { data } from './data';\n\nfunction Demo() {\n  return (\n    <BarChart\n      h={300}\n      data={data}\n      dataKey=\"month\"\n      series=[\n        { name: 'Smartphones', color: 'violet.6', stackId: 'a' },\n        { name: 'Laptops', color: 'blue.6', stackId: 'b' },\n        { name: 'Tablets', color: 'teal.6', stackId: 'b' },\n      ]\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @mantinex/mantine-meta npm Package Using Bash\nDESCRIPTION: This snippet shows the commands required to install the @mantinex/mantine-meta package via yarn and npm package managers. It is intended for users to add the package as a dependency in their JavaScript or TypeScript projects that use the Mantine framework. The commands should be run in a terminal or command prompt within the project directory. No additional dependencies are required beyond yarn or npm itself.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/mantine-meta/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantinex/mantine-meta\n\n# With npm\nnpm install @mantinex/mantine-meta\n```\n\n----------------------------------------\n\nTITLE: Using Nested Selectors in SCSS for Mantine Styling\nDESCRIPTION: Provides an example of a working nested CSS selector using SCSS syntax to style a button with a hotpink background and a lightgreen hover color. This method is supported by Mantine because styles are applied via CSS files or CSS modules instead of inline nested styles. Input is SCSS code, output is compiled CSS affecting components. Requires SCSS processing setup.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/nested-inline-styles.mdx#_snippet_2\n\nLANGUAGE: scss\nCODE:\n```\n.button {\n  background-color: hotpink;\n\n  &:hover {\n    color: lightgreen;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating custom component sizes with CSS variables\nDESCRIPTION: Shows how to define custom component sizes by setting CSS variables in the theme. This example adds 'xxl' and 'xxs' sizes to the Button component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, createTheme, Group, MantineProvider, rem } from '@mantine/core';\n\nconst theme = createTheme({\n  components: {\n    Button: Button.extend({\n      vars: (theme, props) => {\n        if (props.size === 'xxl') {\n          return {\n            root: {\n              '--button-height': rem(60),\n              '--button-padding-x': rem(30),\n              '--button-fz': rem(24),\n            },\n          };\n        }\n\n        if (props.size === 'xxs') {\n          return {\n            root: {\n              '--button-height': rem(24),\n              '--button-padding-x': rem(10),\n              '--button-fz': rem(10),\n            },\n          };\n        }\n\n        return { root: {} };\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Group>\n        <Button size=\"xxl\">XXL Button</Button>\n        <Button size=\"xxs\">XXS Button</Button>\n      </Group>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting textWrap property for Title component in Mantine Core with TypeScript\nDESCRIPTION: Illustrates usage of the new 'textWrap' prop on the Mantine Title component to control how text wraps inside the heading element via CSS 'text-wrap' property. The example sets 'textWrap=\"wrap\"' for multiline wrap. This improves control over heading appearance for long titles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Title } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Title order={3} textWrap=\"wrap\">\n      Lorem, ipsum dolor sit amet consectetur adipisicing elit. Quasi voluptatibus inventore iusto\n      cum dolore molestiae perspiciatis! Totam repudiandae impedit maxime!\n    </Title>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Single-Shade Mantine Theme Color (tsx)\nDESCRIPTION: Illustrates using the `colorsTuple` helper function from `@mantine/core` to quickly generate a 10-shade array from a single color value for use in the `theme.colors` object. This is suitable if you do not require distinct shade variations for different component variants, hover effects, or specific light/dark mode behaviors. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/ten-shades-per-color.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { colorsTuple, createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    custom: colorsTuple('#FFC0CB'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Correct usage of extend() with 'use client' directive\nDESCRIPTION: This snippet demonstrates proper usage of the `extend()` function in Mantine with the addition of `'use client'` at the top to enable client-side component extension.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ No error\n `'use client';`\n\nimport { Button, createTheme } from '@mantine/core';\n\nexport const theme = createTheme({\n  components: {\n    Button: Button.extend({}),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Validating List Fields with Superstruct and useForm\nDESCRIPTION: This snippet demonstrates validating list fields using Superstruct with Mantine Form. It defines a Superstruct schema that validates the properties within each item in the list. The example demonstrates how to access the error messages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { superstructResolver } from 'mantine-form-superstruct-resolver';\nimport * as s from 'superstruct';\nimport { useForm } from '@mantine/form';\n\nconst listSchema = s.object({\n  list: s.array(\n    s.object({\n      name: s.size(s.string(), 2, 30),\n    })\n  ),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    list: [{ name: '' }],\n  },\n  validate: superstructResolver(listSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'list 0 name: Expected a string with a length between `2` and `30` but received one with a length of `0`',\n// }\n```\n\n----------------------------------------\n\nTITLE: Initializing Global Form Actions with createFormActions in Mantine (TypeScript)\nDESCRIPTION: Defines a global form actions object using createFormActions for synchronizing or modifying form states outside the rendering tree in Mantine. Uses the DemoFormValues type for type safety. Form name must match the string assigned when initializing the form with useForm.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import type of form values from the file where you defined useForm\nimport { createFormActions } from '@mantine/form';\nimport type { DemoFormValues } from './DemoForm';\n\nexport const demoFormActions = createFormActions<DemoFormValues>('demo-form');\n```\n\n----------------------------------------\n\nTITLE: Improved Dark Theme Color Variables (SCSS)\nDESCRIPTION: Lists the updated CSS custom properties (variables) for Mantine's dark theme, providing enhanced contrast and readability. Should be injected in a CSS or SCSS file where theme variables are defined.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_14\n\nLANGUAGE: scss\nCODE:\n```\n--mantine-color-dark-0: #c9c9c9;\n--mantine-color-dark-1: #b8b8b8;\n--mantine-color-dark-2: #828282;\n--mantine-color-dark-3: #696969;\n--mantine-color-dark-4: #424242;\n--mantine-color-dark-5: #3b3b3b;\n--mantine-color-dark-6: #2e2e2e;\n--mantine-color-dark-7: #242424;\n--mantine-color-dark-8: #1f1f1f;\n--mantine-color-dark-9: #141414;\n```\n\n----------------------------------------\n\nTITLE: SCSS Media Query Mixins\nDESCRIPTION: Demonstrates how to use the `smaller-than` and `larger-than` mixins in SCSS to apply styles based on screen size.  It explains the usage with pixel values and Mantine breakpoints, highlighting the automatic conversion to `em` units and the slight subtraction to avoid intersections.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-3-0.mdx#_snippet_0\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  @mixin smaller-than 320px {\n    color: red;\n  }\n\n  @mixin larger-than 320px {\n    color: blue;\n  }\n}\n```\n\nLANGUAGE: scss\nCODE:\n```\n// Breakpoint values are converted to em units\n// In smaller-than mixin 0.1px is subtracted from breakpoint value\n// to avoid intersection with larger-than mixin\n@media (max-width: 19.99375em) {\n  .demo {\n    color: red;\n  }\n}\n\n@media (min-width: 20em) {\n  .demo {\n    color: blue;\n  }\n}\n```\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  @mixin smaller-than $mantine-breakpoint-sm {\n    color: red;\n  }\n\n  @mixin larger-than $mantine-breakpoint-sm {\n    color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Color Scheme Toggle with useLocalStorage in React\nDESCRIPTION: Example of creating a color scheme toggle button component that uses the useLocalStorage hook to persist the user's color scheme preference across page reloads. The component toggles between light and dark themes and displays the appropriate icon.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { IconMoonStars, IconSun } from '@tabler/icons-react';\nimport { ActionIcon } from '@mantine/core';\nimport { useLocalStorage } from '@mantine/hooks';\n\nfunction ColorSchemeToggle() {\n  const [colorScheme, setColorScheme] = useLocalStorage<\n    'light' | 'dark'\n  >({\n    key: 'color-scheme',\n    defaultValue: 'light',\n  });\n\n  const toggleColorScheme = () =>\n    setColorScheme((current) =>\n      current === 'dark' ? 'light' : 'dark'\n    );\n\n  return (\n    <ActionIcon onClick={toggleColorScheme}>\n      {colorScheme === 'dark' ? <IconSun /> : <IconMoonStars />}\n    </ActionIcon>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Generating and Using Custom Color Palettes in Mantine Theme (TSX)\nDESCRIPTION: Utilizes the `generateColors` function from `@mantine/colors-generator` to create a color palette based on the hex code '#375EAC'. This generated palette is then added to the `theme.colors` object under the key 'pale-blue' within the `MantineProvider`. Requires `@mantine/core` and `@mantine/colors-generator`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nimport { generateColors } from '@mantine/colors-generator';\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider\n      theme={{\n        colors: {\n          'pale-blue': generateColors('#375EAC'),\n        },\n      }}\n    >\n      <App />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Clearing of Field Errors on Input Change with Mantine useForm in TypeScript\nDESCRIPTION: Changes default behavior where input errors clear upon value change by setting clearInputErrorOnChange to false. This keeps error messages visible until explicitly cleared, aiding in certain user experiences. Requires '@mantine/form'. Input is the form config object; output is the form instance with persistent error display on change.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validation.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  clearInputErrorOnChange: false,\n});\n```\n\n----------------------------------------\n\nTITLE: UseInterval Hook Definition and Options in Mantine (TSX)\nDESCRIPTION: Defines the TypeScript interface `UseIntervalOptions` and the function signature for the `useInterval` hook. It details the types for the callback function (`fn`), interval duration (`interval`), and the optional `options` object, including the `autoInvoke` property. Shows the expected return type structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-interval.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ninterface UseIntervalOptions {\n  /** If set, the interval will start automatically when the component is mounted, `false` by default */\n  autoInvoke?: boolean;\n}\n\nfunction useInterval(\n  fn: () => void,\n  interval: number,\n  options?: UseIntervalOptions\n): {\n  start: () => void;\n  stop: () => void;\n  toggle: () => void;\n  active: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining the `useFocusWithin` Hook Signature (TypeScript)\nDESCRIPTION: This TypeScript code defines the function signature for the `useFocusWithin` hook. It accepts an optional object with `onFocus` and `onBlur` callback functions. The hook returns an object containing a React `ref` to attach to the parent element and a boolean `focused` state indicating if any descendant element currently has focus.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-within.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useFocusWithin<T extends HTMLElement = any>(handlers?: {\n  onFocus?(event: FocusEvent): void;\n  onBlur?(event: FocusEvent): void;\n}): {\n  ref: React.MutableRefObject<T>;\n  focused: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Customizing Spotlight Keyboard Shortcuts Using shortcut Prop in React TypeScript\nDESCRIPTION: Demonstrates controlling the keyboard shortcuts that open the Spotlight component using the shortcut prop, accepting either a string, an array of strings, or null to disable shortcuts. It uses the Spotlight component from @mantine/spotlight and exemplifies single shortcut, multiple shortcuts, and shortcut disabling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/spotlight.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Spotlight } from '@mantine/spotlight';\n\nfunction SingleShortcut() {\n  return <Spotlight shortcut=\"mod + J\" actions={[]} />;\n}\n\n// Same as on mantine.dev\nfunction MultipleShortcuts() {\n  return (\n    <Spotlight shortcut={['mod + K', 'mod + P', '/']} actions={[]} />\n  );\n}\n\n// Disable shortcut\nfunction NoShortcut() {\n  return <Spotlight shortcut={null} actions={[]} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring usePagination Siblings Option\nDESCRIPTION: Illustrates how to customize the number of visible page items around the currently active page using the `siblings` option when initializing the `usePagination` hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-pagination.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { usePagination } from '@mantine/hooks';\n\nconst pagination = usePagination({ total: 20, siblings: 3 });\n```\n\n----------------------------------------\n\nTITLE: Rendering Breadcrumbs Usage Demo with Mantine in JSX\nDESCRIPTION: This snippet demonstrates how to display a live usage example of the Breadcrumbs component using Mantine. It utilizes the Demo component and passes the BreadcrumbsDemos.usage property as data, enabling dynamic visualization within the documentation layout. The code requires the Mantine library, access to BreadcrumbsDemos and the Demo component, and expects the demo data to conform to the expected format for rendering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/breadcrumbs.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={BreadcrumbsDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: TypeScript typings for ScrollIntoView animation options and return type\nDESCRIPTION: Defines TypeScript interfaces for configuring scroll animation parameters and the return object of the useScrollIntoView hook, detailing optional properties such as alignment, duration, axis, easing, offset, cancelability, and list-specific behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-scroll-into-view.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface ScrollIntoViewAnimation {\n  /** target element alignment relatively to parent based on current axis */\n  alignment?: 'start' | 'end' | 'center';\n}\n\ninterface ScrollIntoViewParams {\n  /** callback fired after scroll */\n  onScrollFinish?: () => void;\n\n  /** duration of scroll in milliseconds */\n  duration?: number;\n\n  /** axis of scroll */\n  axis?: 'x' | 'y';\n\n  /** custom mathematical easing function */\n  easing?: (t: number) => number;\n\n  /** additional distance between nearest edge and element */\n  offset?: number;\n\n  /** indicator if animation may be interrupted by user scrolling */\n  cancelable?: boolean;\n\n  /** prevents content jumping in scrolling lists with multiple targets */\n  isList?: boolean;\n}\n\ninterface ScrollIntoViewReturnType<\n  Target extends HTMLElement,\n  Parent extends HTMLElement | null = null\n> {\n  scrollableRef: React.MutableRefObject<Parent>;\n  targetRef: React.MutableRefObject<Target>;\n  scrollIntoView: (params?: ScrollIntoViewAnimation) => void;\n  cancel: () => void;\n}\n\nfunction useScrollIntoView<\n  Target extends HTMLElement,\n  Parent extends HTMLElement | null = null\n>({\n  duration,\n  axis,\n  onScrollFinish,\n  easing,\n  offset,\n  cancelable,\n  isList,\n}?: ScrollIntoViewParams): ScrollIntoViewReturnType<Target, Parent>;\n```\n\n----------------------------------------\n\nTITLE: Closing Popover with onDismiss Prop\nDESCRIPTION: This code demonstrates how to use the `onDismiss` prop to close the Popover when clicking outside or pressing Escape, while still maintaining control over the `opened` state.  The `onDismiss` function sets the `opened` state to `false`, effectively closing the Popover.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/popover.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Popover } from '@mantine/core';\n\nfunction Demo() {\n  const [opened, setOpened] = useState(false);\n  return (\n    <Popover\n      opened={opened}\n      onDismiss={() => setOpened(false)}\n    >\n      <Popover.Target>\n        <Button onClick={() => setOpened((o) => !o)}>\n          Toggle popover\n        </Button>\n      </Popover.Target>\n\n      <Popover.Dropdown>Dropdown</Popover.Dropdown>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Mantine useResizeObserver Hook Signature in TSX\nDESCRIPTION: This snippet shows the TypeScript definition for the `useResizeObserver` hook. It defines the `ObserverRect` type as a `DOMRectReadOnly` without the `toJSON` method and specifies the hook's signature, including a generic type `T` for the observed element, an optional `ResizeObserverOptions` parameter, and the returned tuple type: a `React.RefObject` for attaching to the element and an `ObserverRect` containing the element's content rectangle data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-resize-observer.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\ntype ObserverRect = Omit<DOMRectReadOnly, 'toJSON'>;\n\nfunction useResizeObserver<T extends HTMLElement = any>(\n  options?: ResizeObserverOptions\n): readonly [React.RefObject<T>, ObserverRect];\n```\n\n----------------------------------------\n\nTITLE: Importing NProgress Styles – TSX\nDESCRIPTION: Imports the required CSS styles for the @mantine/nprogress package. These styles are essential for the visual representation of the navigation progress bar. This import should be done at the root of the application to ensure styles are applied globally.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/nprogress.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/nprogress/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Exporting Page Layout with Metadata - JavaScript\nDESCRIPTION: Exports the default React component by applying the Layout function with the defined metadata. This connects the metadata and content structure with the page rendering logic to display the documentation content appropriately.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/select-autocomplete-difference.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Manually Setting Form Values Type in TypeScript\nDESCRIPTION: Shows how to manually set form values type when inference is not sufficient. This is useful for union types, nullable fields, and empty arrays that can't be correctly inferred in strict mode.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\ninterface FormValues {\n  name: string; // regular field, same as inferred type\n  role: 'user' | 'admin'; // union, more specific than inferred string type\n\n  // values that may be undefined or null\n  // cannot be correctly inferred in strict mode\n  age: number | undefined;\n  registeredAt: Date | null;\n\n  // Arrays that are empty cannot be inferred correctly\n  jobs: string[];\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    mode: 'uncontrolled',\n    initialValues: {\n      name: '',\n      role: 'user',\n      age: undefined,\n      registeredAt: null,\n      jobs: [],\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Navbar/Aside Configuration Interface in TypeScript\nDESCRIPTION: Shows the TypeScript interface for configuring the `AppShell.Navbar` and `AppShell.Aside` components through the `navbar` and `aside` props on `AppShell`. It defines properties like `width` (number, string, or responsive object), the mandatory `breakpoint` for mobile switching, and an optional `collapsed` object with `desktop` and `mobile` states.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\ninterface Configuration {\n  /** Width of the section: number, string or\n   ** object with breakpoints as keys and width as value */\n  width: AppShellSize | AppShellResponsiveSize;\n\n  /** Breakpoint at which section should switch to mobile mode\n   ** In mobile mode the section always has 100% width and its\n   ** collapsed state is controlled by the `collapsed.mobile`\n   ** instead of `collapsed.desktop` */\n  breakpoint: MantineBreakpoint | (string & {}) | number;\n\n  /** Determines whether the section should be collapsed */\n  collapsed?: { desktop?: boolean; mobile?: boolean };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useColorScheme Hook - TypeScript\nDESCRIPTION: This TypeScript snippet defines the `useColorScheme` hook's function signature. It specifies the input parameters and the return type. The hook can take an optional `initialValue` parameter, which can be either 'dark' or 'light'.  It also accepts an `options` object to configure its behavior and returns either 'dark' or 'light' representing the current color scheme.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-color-scheme.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useColorScheme(\n  initialValue?: 'dark' | 'light',\n  options?: {\n    getInitialValueInEffect: boolean;\n  }\n): 'dark' | 'light';\n```\n\n----------------------------------------\n\nTITLE: Rendering Accessibility Features for DatePickerInput in JSX\nDESCRIPTION: Renders a component explaining or testing accessibility properties for the DatePickerInput component within the @mantine/dates package. This ensures the component complies with accessibility standards.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_13\n\nLANGUAGE: JSX\nCODE:\n```\n<InputAccessibility\n  component=\"DatePickerInput\"\n  packageName=\"@mantine/dates\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Color Palettes in Mantine Theme (TSX)\nDESCRIPTION: Explains how to add new color palettes to the Mantine theme. A new key (e.g., 'demo') is added to the `colors` object within `createTheme`, containing an array of 10 color shades. Mantine automatically generates corresponding CSS variables (`--mantine-color-demo-0` to `--mantine-color-demo-9`). Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    demo: [\n      '#FF0000',\n      '#FF3333',\n      '#FF6666',\n      '#FF9999',\n      '#FFCCCC',\n      '#FFEEEE',\n      '#FFFAFA',\n      '#FFF5F5',\n      '#FFF0F0',\n      '#FFEBEB',\n    ],\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining the useThrottledState Hook in React with TypeScript\nDESCRIPTION: Defines a generic TypeScript function useThrottledState for React, which provides a throttled alternative to useState. It takes a defaultValue of any type T and a wait parameter in milliseconds, returning a tuple containing the current state and a setter function that throttles state updates to at most once per wait interval. Dependencies include React and knowledge of React.SetStateAction; expects the consumer to handle state values and update logic accordingly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-throttled-state.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useThrottledState<T = any>(\n  defaultValue: T,\n  wait: number\n): readonly [T, (newValue: React.SetStateAction<T>) => void];\n```\n\n----------------------------------------\n\nTITLE: Using Custom PostCSS Mixins in SCSS\nDESCRIPTION: Demonstrates how to use custom defined PostCSS mixins in stylesheet files after they have been configured in the PostCSS configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.9.0.md#_snippet_4\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  @mixin clearfix;\n  @mixin circle 100px;\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling specific options in dropdown\nDESCRIPTION: This code illustrates how to disable certain options so they cannot be selected while still allowing user input of disabled options, with recommended filtering in onChange handler for strict control.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.disabledOptions} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Controlled FileInput (multiple files) in TypeScript\nDESCRIPTION: This snippet shows how to manage multiple file selection using the FileInput component. It utilizes the useState hook and the `multiple` prop. The `value` prop will be an array of `File` objects.  The `onChange` prop updates the selected file array whenever a change occurs in the selection.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/file-input.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { useState } from 'react';\nimport { FileInput } from '@mantine/core';\n\nfunction Demo() {\n  const [value, setValue] = useState<File[]>([]);\n  return <FileInput multiple value={value} onChange={setValue} />;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Form Components with Uncontrolled Mode Support\nDESCRIPTION: Implementation of a custom form input component that supports both controlled and uncontrolled modes using the use-uncontrolled hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/uncontrolled.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useUncontrolled } from '@mantine/hooks';\n\ninterface CustomInputProps {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n}\n\n// ✅ CustomInput supports both controlled and uncontrolled modes\nfunction CustomInput({\n  value,\n  defaultValue,\n  onChange,\n}: CustomInputProps) {\n  const [_value, handleChange] = useUncontrolled({\n    value,\n    defaultValue,\n    finalValue: 'Final',\n    onChange,\n  });\n\n  return (\n    <input\n      type=\"text\"\n      value={_value}\n      onChange={(event) => handleChange(event.currentTarget.value)}\n    />\n  );\n}\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: { text: 'Initial' },\n  });\n\n  // ✅ CustomInput supports `defaultValue` prop,\n  // it can be used in uncontrolled mode\n  return (\n    <CustomInput\n      {...form.getInputProps('text')}\n      key={form.key('text')}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting fixed dropdown position with position and middlewares\nDESCRIPTION: This snippet customizes dropdown placement by specifying positioning behavior and middlewares, such as always displaying above the input regardless of available space, overriding default adaptive positioning.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.dropdownPosition} />\n```\n\n----------------------------------------\n\nTITLE: Using sx Prop for Mantine Component Styling\nDESCRIPTION: This React component demonstrates how to apply styles to a Mantine `Box` component using the `sx` prop. The `sx` prop can receive a styles object or a function.  The example includes a hover effect and uses the theme object to access colors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n'use client';\n\nimport { Box } from '@mantine/core';\n\nexport default function HomePage() {\n  return (\n    <Box\n      sx={(theme, u) => ({\n        padding: 40,\n\n        [u.light]: {\n          backgroundColor: theme.colors.blue[0],\n          color: theme.colors.blue[9],\n\n          '&:hover': {\n            backgroundColor: theme.colors.blue[1],\n          },\n        },\n      })}\n    >\n      Box with emotion sx prop\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting useInViewport Documentation with Layout in React (JavaScript)\nDESCRIPTION: This snippet wraps the useInViewport documentation content in a shared layout and exports it as the default component. It relies on MDX_DATA.useInViewport, which likely contains markdown or JSX content specific to the useInViewport hook, and applies the Layout higher-order component for consistent presentation. The expected input is a content-specific data structure (MDX_DATA.useInViewport); output is a React component for documentation consumption.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-in-viewport.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default Layout(MDX_DATA.useInViewport);\n```\n\n----------------------------------------\n\nTITLE: Disabling Inputs Using Mantine use-form enhanceGetInputProps Hook (JavaScript)\nDESCRIPTION: Shows how to disable all inputs in a form that utilizes Mantine's use-form hook by leveraging the enhanceGetInputProps function. This approach allows dynamic control over input states based on form logic, simplifying the process without wrapping inputs in a Fieldset.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/disable-all-inputs-in-form.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { EnhanceDisableInputs } from '@/demos/EnhanceDisableInputs.demo';\nimport { Layout } from '@/layout';\n\n// Usage of enhanceGetInputProps:\n// Pass or set options in use-form to generate enhanced input properties.\n// These can include a disabled state, which when applied to inputs, disables them.\n\n// Example component:\n// <Demo data={EnhanceDisableInputs} />\n```\n\n----------------------------------------\n\nTITLE: Handling Types with useToggle and TypeScript in TSX\nDESCRIPTION: Illustrates different ways TypeScript infers or can be guided to specific types when using `useToggle`. Shows how `as const` or explicit type parameters can narrow down the type of the state variable from a general string to a union of literal strings. Requires TypeScript.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-toggle.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useToggle } from '@mantine/hooks';\n\nuseToggle(['light', 'dark']); // value is string\nuseToggle(['light', 'dark'] as const); // value is 'dark' | 'light'\nuseToggle<'dark' | 'light'>(['light', 'dark']); // same as above\n```\n\n----------------------------------------\n\nTITLE: Using rem and em Conversion Functions with postcss-preset-mantine - SCSS\nDESCRIPTION: Demonstrates usage of `rem` and `em` functions in SCSS to convert pixel values to rem and em units respectively. The functions help maintain scalable and responsive CSS sizing by transforming pixel-based lengths into relative units multiplied by a scaling factor variable `--mantine-scale`. Input styling with pixel values is converted to CSS with calc expressions and correct unit values for normal declarations and media queries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/postcss-preset.mdx#_snippet_1\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  font-size: rem(16px);\n\n  @media (min-width: em(320px)) {\n    font-size: rem(32px);\n  }\n}\n```\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  font-size: calc(1rem * var(--mantine-scale));\n\n  @media (min-width: 20em) {\n    font-size: calc(2rem * var(--mantine-scale));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing dependencies for useIntersection hook implementation\nDESCRIPTION: Imports necessary modules, including HooksDemos, Layout, MDX_DATA, and useIntersection hook from Mantine hooks package, to set up the environment required for demonstration and usage of the intersection observation functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-intersection.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { HooksDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\nimport { useIntersection } from '@mantine/hooks';\n```\n\n----------------------------------------\n\nTITLE: Implementing useElementSize Hook in React/TypeScript\nDESCRIPTION: Demonstrates the basic usage of the `useElementSize` hook. It shows how to import the hook from `@mantine/hooks` and destructure the returned `ref`, `width`, and `height`. The `ref` should be attached to the target DOM element whose dimensions are needed. Initially, or when no element is observed, width and height will be 0.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-element-size.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useElementSize } from '@mantine/hooks';\n\nconst { ref, width, height } = useElementSize();\n```\n\n----------------------------------------\n\nTITLE: Defining smaller-than and larger-than Mixins with SCSS\nDESCRIPTION: Demonstrates SCSS mixin usage for responsive styles using 'smaller-than' and 'larger-than' within a .demo selector. Requires postcss-preset-mantine v1.11.0 or higher for correct transformation. Applies color styles conditionally based on the screen size compared to the specified breakpoint.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_0\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  @mixin smaller-than 320px {\n    color: red;\n  }\n\n  @mixin larger-than 320px {\n    color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Definition for useLocalStorage Hook\nDESCRIPTION: Provides the TypeScript interface definition for the useLocalStorage hook, including all available options and the return type signature with value, setValue, and removeValue functions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\ninterface UseLocalStorage<T> {\n  /** Local storage key */\n  key: string;\n\n  /** Default value that will be set if value is not found in local storage */\n  defaultValue?: T;\n\n  /** If set to true, value will be updated in useEffect after mount. Default value is true. */\n  getInitialValueInEffect?: boolean;\n\n  /** Determines whether the value must be synced between browser tabs, `true` by default */\n  sync?: boolean;\n\n  /** Function to serialize value into a string to be saved in local storage */\n  serialize?: (value: T) => string;\n\n  /** Function to deserialize string value from local storage to value */\n  deserialize?: (value: string) => T;\n}\n\nfunction useLocalStorage<T = string>(options: UseLocalStorage<T>): readonly [\n  T, // current value\n  (val: T | ((prevState: T) => T)) => void, // callback to set value in storage\n  () => void, // callback to remove value from storage\n];\n```\n\n----------------------------------------\n\nTITLE: Defining the useId Hook Signature - Mantine - TypeScript\nDESCRIPTION: This snippet provides the TypeScript function signature for the useId hook from Mantine. It accepts an optional id parameter of type string and returns a string value representing the generated or provided ID. This function is designed as a React hook and should be used within functional React components. It is required that the environment supports React hooks, and the @mantine/hooks package is available.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-id.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useId(id: string): string;\n```\n\n----------------------------------------\n\nTITLE: Simplified Light/Dark Mode Styling in Vanilla Extract (TypeScript)\nDESCRIPTION: Demonstrates a common pattern for handling light/dark mode styles in Vanilla Extract. Base styles (usually for light mode) are defined first, and then specific overrides for dark mode are applied using the `vars.darkSelector` within the `selectors` block.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// Demo.css.ts\nimport { style } from '@vanilla-extract/css';\nimport { vars } from './theme';\n\nexport const demo = style({\n  fontSize: vars.fontSizes.xl,\n  backgroundColor: vars.colors.red[5],\n  color: vars.colors.white,\n\n  selectors: {\n    [vars.darkSelector]: {\n      backgroundColor: vars.colors.blue[5],\n      color: vars.colors.white,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Page Metadata in JavaScript/TypeScript\nDESCRIPTION: This snippet defines a constant 'meta' object containing metadata for the page, such as title, description, slug, category, tags, and creation/update timestamps. This data is often consumed by a layout component or build process.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/other-libs.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport const meta = {\n  title: 'Is there a comparison with other libraries?',\n  description:\n    'Comparison with other libraries is not provided, you are trusted to make your own decision based on documentation examples',\n  slug: 'other-libs',\n  category: 'about',\n  tags: ['mui', 'chakra-ui', 'antd', 'material-ui'],\n  created_at: 'March 15, 2024',\n  last_updated_at: 'March 15, 2024',\n};\n```\n\n----------------------------------------\n\nTITLE: Forcing Color Scheme in Mantine with TSX\nDESCRIPTION: Demonstrates how to force the color scheme to a specific value ('light' or 'dark') using the `forceColorScheme` prop. This prop must be set on both `ColorSchemeScript` and `MantineProvider` and overrides `defaultColorScheme` and `colorSchemeManager`. When forced, the scheme cannot be changed dynamically with `setColorScheme`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/color-schemes.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ColorSchemeScript, MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <ColorSchemeScript forceColorScheme=\"light\" />\n      <MantineProvider forceColorScheme=\"light\">\n        {/* Your app here */}\n      </MantineProvider>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using MantineProvider with Custom Theme in React (TypeScript)\nDESCRIPTION: Demonstrates how to wrap your application with MantineProvider while passing a custom theme object. It covers importing modules, creating a theme with customized font and primary color, and embedding the provider at the app root to apply the theme across all components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  fontFamily: 'Open Sans, sans-serif',\n  primaryColor: 'cyan',\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using renderRoot with Generic Next.js Link (TSX)\nDESCRIPTION: Explains how to handle generic components, like a typed Next.js `Link`, with Mantine polymorphic components. Since the `component` prop cannot infer generic types correctly, `renderRoot` is used instead to render the `Link` component while spreading the necessary props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/polymorphic.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport Link from 'next/link';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button renderRoot={(props) => <Link href=\"/hello\" {...props} />}>\n      Typed Next link button\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Carousel Responsive Value Changes\nDESCRIPTION: Carousel's slideSize and slideGap now accept object syntax for breakpoints instead of the previous breakpoints array, enabling intuitive responsive configurations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_23\n\n\n\n----------------------------------------\n\nTITLE: Using Mantine Dropzone Grouped Mime Types Constant (TSX)\nDESCRIPTION: Shows how to accept common groups of mime types using predefined constants like 'IMAGE_MIME_TYPE' exported from '@mantine/dropzone'. This simplifies accepting broad categories of files with a single constant. 'onDrop' is a required prop. Requires importing the specific group constant.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/dropzone.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Dropzone, IMAGE_MIME_TYPE } from '@mantine/dropzone';\n\nfunction Demo() {\n  return (\n    <Dropzone accept={IMAGE_MIME_TYPE} onDrop={() => {}}>\n      {/* children */}\n    </Dropzone>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Global Styles in TypeScript\nDESCRIPTION: This snippet imports the global CSS file required by all Mantine components. It must be imported before any other component styles to establish baseline resets and variables. The import is essential for proper appearance and functionality across the library; omitting it can cause unexpected rendering issues or missing base styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-files-list.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles/global.css';\n```\n\n----------------------------------------\n\nTITLE: New Fieldset Component for Grouping Inputs\nDESCRIPTION: Provides a new Fieldset component to semantically group related form controls, aiding in accessibility and structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_25\n\n\n\n----------------------------------------\n\nTITLE: ModalStackReturnType Interface Definition TypeScript\nDESCRIPTION: Defines the interface for the return type of the `useModalsStack` hook. It includes properties for managing the state of multiple modals, opening, closing, and toggling modals, closing all modals, and registering modals to get props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-14-0.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\ninterface ModalStackReturnType<T extends string> {\n  // Current opened state of each modal\n  state: Record<T, boolean>;\n\n  // Opens modal with the given id\n  open: (id: T) => void;\n\n  // Closes modal with the given id\n  close: (id: T) => void;\n\n  // Toggles modal with the given id\n  toggle: (id: T) => void;\n\n  // Closes all modals within the stack\n  closeAll: () => void;\n\n  // Returns props for modal with the given id\n  register: (id: T) => {\n    opened: boolean;\n    onClose: () => void;\n    stackId: T;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Primary Color in MantineProvider\nDESCRIPTION: Shows the incorrect way to set primaryColor in MantineProvider that will throw an error. The primaryColor must be a key of theme.colors object, not a CSS color value.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/colors.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider\n      theme={{\n        primaryColor: '#CEFEDC', // This will throw an error\n      }}\n    >\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Carousel Styles - Mantine Carousel - TypeScript\nDESCRIPTION: Imports the required CSS styles for the @mantine/carousel component, enabling its visual design and layout. This import should be placed at the root of your application to ensure styles are available throughout. Requires installation of the @mantine/carousel package and assumes a standard project setup with CSS import capability; no parameters are used.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/carousel.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/carousel/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Passing Custom Props to Recharts LabelList Component for Bar Value Labels in JSX/TypeScript\nDESCRIPTION: Allows customization of bar value labels by passing `valueLabelProps` prop, which accepts either an object or a function receiving series data to return props for Recharts LabelList component. Enables styling or positioning adjustments. Examples rely on BarChartDemos.valueLabelProps data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_29\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.valueLabelProps} />\n```\n\n----------------------------------------\n\nTITLE: Validating JSON String Format with Mantine isJSONString Validator in TypeScript\nDESCRIPTION: This snippet uses isJSONString validation function to ensure the form value is a valid JSON string. The validation returns an error message on invalid JSON format. The snippet is implemented with useForm in uncontrolled mode and provides an example of initial value and validation for a single json field.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validators.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { isJSONString, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    json: '',\n  },\n\n  validate: {\n    json: isJSONString('Invalid JSON string'),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Applying textWrap setting globally via Mantine theme in TypeScript\nDESCRIPTION: Shows how to globally configure the 'textWrap' property for all heading components by setting it on the theme via createTheme and MantineProvider. This enforces consistent text wrapping behavior application-wide without setting the prop on individual components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.5.0.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  headings: {\n    textWrap: 'wrap'\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Title>Some very long title that should wrap</Title>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @mantine/dates with Yarn and NPM\nDESCRIPTION: Provides shell commands to install the `@mantine/dates` package along with its required peer dependencies (`@mantine/core`, `@mantine/hooks`, `dayjs`) using either the Yarn or NPM package managers. These dependencies are necessary for the date components to function correctly within a Mantine project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/dates/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/core @mantine/hooks @mantine/dates dayjs\n\n# With npm\nnpm install @mantine/core @mantine/hooks @mantine/dates dayjs\n```\n\n----------------------------------------\n\nTITLE: Setting Color Scheme Specific CSS Variables Using light-root and dark-root Mixins (SCSS/PostCSS)\nDESCRIPTION: Demonstrates use of the new light-root and dark-root mixins for theming in Mantine with postcss-preset-mantine v1.9.0+. These mixins, placed within :root, conditionally define variables such as --color to reflect light or dark color schemes. Requires SCSS/PostCSS environment and updated dependency versions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.2.0.md#_snippet_8\n\nLANGUAGE: SCSS\nCODE:\n```\n:root {\n  @mixin light-root {\n    --color: red;\n  }\n\n  @mixin dark-root {\n    --color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using TypographyStylesProvider in React\nDESCRIPTION: This code snippet demonstrates how to wrap HTML content within the `TypographyStylesProvider` component to apply predefined typography styles. It leverages `dangerouslySetInnerHTML` to render the HTML content, which should be used with caution to prevent potential security vulnerabilities.  The component is imported from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/typography-styles-provider.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TypographyStylesProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TypographyStylesProvider>\n      <div\n        dangerouslySetInnerHTML={{ __html: '<p>Your html here</p>' }}\n      />\n    </TypographyStylesProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Guidance on Importing Mantine Carousel Styles in TypeScript\nDESCRIPTION: This snippet explains that missing style imports for '@mantine/core' and '@mantine/carousel' can cause the Carousel component to render vertically or display incorrect controls. It provides the exact import statements to include in the root of the application to fix styling issues, improving component rendering and control placement.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/carousel-missing-styles.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles.css';\nimport '@mantine/carousel/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Enabling Validation on Input Blur with Mantine useForm in TypeScript\nDESCRIPTION: Configures the form to validate all fields when inputs lose focus by setting the validateInputOnBlur option to true. This defers validation feedback until user finishes editing a field. Requires '@mantine/form'. Input: form configuration; output: form instance with blur-triggered validation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validation.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  validateInputOnBlur: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Number Array with Mantine Hooks (TSX)\nDESCRIPTION: Shows how to use the `range` function from `@mantine/hooks`. It creates an array of numbers starting from the `start` value and ending at the `end` value (inclusive), in ascending or descending order based on input. Requires importing `range` from the hooks package.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/functions-reference.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { range } from '@mantine/hooks';\n\nrange(0, 5); // [0, 1, 2, 3, 4, 5]\nrange(5, 0); // [5, 4, 3, 2, 1, 0]\n```\n\n----------------------------------------\n\nTITLE: Initializing Emotion Styles for Mantine in Next.js\nDESCRIPTION: This snippet imports and uses necessary dependencies to configure Emotion for use within a Next.js application using Mantine. The code creates a custom Emotion cache and a component to inject styles into the server-rendered HTML to prevent hydration mismatches.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core';\n\nimport type { EmotionStyles, EmotionSx } from '@mantine/emotion';\n\ndeclare module '@mantine/core' {\n  export interface BoxProps {\n    sx?: EmotionSx;\n    styles?: EmotionStyles;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using useValidatedState Mantine Hook TSX\nDESCRIPTION: Demonstrates the basic usage of the `useValidatedState` hook. It initializes the state with a value and a validation rule, then shows how updating the state affects the returned object's `value`, `lastValidValue`, and `valid` properties. Requires `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-validated-state.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useValidatedState } from '@mantine/hooks';\n\nconst [{ lastValidValue, value, valid }, setValue] =\n  useValidatedState('valid', (state) => state === 'valid');\n\nlastValidValue; // -> valid\nvalue; // -> valid\nvalid; // -> true\n\nsetValue('invalid');\n\nlastValidValue; // -> valid\nvalue; // -> invalid\nvalid; // -> false\n```\n\n----------------------------------------\n\nTITLE: Default Layout import and page meta configuration in Mantine with Next.js\nDESCRIPTION: Defines the page metadata and wraps the application layout using a imported 'Layout' component, assisting in setting page information and maintaining consistent layout structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'I get hydration warning about data-mantine-color-scheme attribute, what does it mean?',\n  description: 'Learn how hydration works and how to fix warnings',\n  slug: 'color-scheme-hydration-warning',\n  category: 'common',\n  tags: ['color-scheme', 'defaultColorScheme', 'forceColorScheme', 'Next.js', 'Remix'],\n  created_at: 'January 11, 2025',\n  last_updated_at: 'January 11, 2025',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Mantine Tabs with react-router\nDESCRIPTION: Shows how to integrate Mantine Tabs with react-router.  The `useNavigate` and `useParams` hooks are used to synchronize the active tab with the URL.  Changing the tab updates the URL, and vice versa. Requires react-router-dom.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tabs.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useNavigate, useParams } from 'react-router-dom';\nimport { Tabs } from '@mantine/core';\n\nfunction Demo() {\n  const navigate = useNavigate();\n  const { tabValue } = useParams();\n\n  return (\n    <Tabs\n      value={tabValue}\n      onChange={(value) => navigate(`/tabs/${value}`)}\n    >\n      <Tabs.List>\n        <Tabs.Tab value=\"first\">First tab</Tabs.Tab>\n        <Tabs.Tab value=\"second\">Second tab</Tabs.Tab>\n      </Tabs.List>\n    </Tabs>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Mantine SemiCircleProgress Component (TSX)\nDESCRIPTION: Shows a basic implementation of the new `SemiCircleProgress` component from `@mantine/core`. It demonstrates configuring the component's appearance and behavior using props like `fillDirection`, `orientation`, `filledSegmentColor`, `size`, `thickness`, `value`, and `label`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.12.0.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { SemiCircleProgress } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <SemiCircleProgress\n      fillDirection=\"left-to-right\"\n      orientation=\"up\"\n      filledSegmentColor=\"blue\"\n      size={200}\n      thickness={12}\n      value={40}\n      label=\"Label\"\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Mantine usePagination TypeScript Definition\nDESCRIPTION: Provides the TypeScript signature for the `usePagination` hook, including the `PaginationParams` interface detailing all available configuration options (`total`, `initialPage`, `page`, `onChange`, `siblings`, `boundaries`) and the structure of the object returned by the hook, listing its properties and methods (`range`, `active`, `setPage`, `next`, `previous`, `first`, `last`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-pagination.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\ninterface PaginationParams {\n  /** Page selected on initial render, defaults to 1 */\n  initialPage?: number;\n\n  /** Controlled active page number */\n  page?: number;\n\n  /** Total amount of pages */\n  total: number;\n\n  /** Siblings amount on left/right side of selected page, defaults to 1 */\n  siblings?: number;\n\n  /** Amount of elements visible on left/right edges, defaults to 1  */\n  boundaries?: number;\n\n  /** Callback fired after change of each page */\n  onChange?: (page: number) => void;\n}\n\nfunction usePagination(settings: PaginationParams): {\n  range: (number | 'dots')[];\n  active: number;\n  setPage: (pageNumber: number) => void;\n  next: () => void;\n  previous: () => void;\n  first: () => void;\n  last: () => void;\n};\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine Components with Global CSS Selectors (CSS)\nDESCRIPTION: Demonstrates applying styles globally to all instances of a Mantine `TextInput` component by targeting its static, predictable CSS class names (e.g., `.mantine-TextInput-root`, `.mantine-TextInput-input`). This approach uses standard CSS and Mantine CSS variables for theme consistency, but styles are not scoped and affect all matching components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_7\n\nLANGUAGE: css\nCODE:\n```\n/* styles.css */\n\n/* Note that these styles are not scoped and\n   will be applied to all TextInput components */\n.mantine-TextInput-root {\n  margin-top: 0.8rem;\n}\n\n.mantine-TextInput-input {\n  background-color: var(--mantine-color-red-filled);\n  color: var(--mantine-color-white);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Mantine Component Styles using Static Classes (TSX)\nDESCRIPTION: Shows how to apply the base styles of a Mantine component, like `Button`, to a standard HTML element (`<button>`). This is achieved by accessing the component's static `classes` property (e.g., `Button.classes.root`) and assigning it to the `className` prop. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return <button type=\"button\" className={Button.classes.root} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostCSS Mixins\nDESCRIPTION: This code configures the `postcss-preset-mantine` plugin to add custom mixins.  It defines `clearfix` and `circle` mixins and specifies options such as `autoRem`.  Dependencies include `postcss-preset-mantine` and `postcss-mixins`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-9-0.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {\n      autoRem: true,\n      mixins: {\n        clearfix: {\n          '&::after': {\n            content: '\"\"',\n            display: 'table',\n            clear: 'both',\n          },\n        },\n        circle: (_mixin, size) => ({\n          borderRadius: '50%',\n          width: size,\n          height: size,\n        }),\n      },\n    },\n    // ... Other plugins\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Localization with DatesProvider in TypeScript\nDESCRIPTION: Illustrates setting up localization for @mantine/dates components. It involves importing the desired locale from dayjs (e.g., 'ru') and then wrapping the application or relevant parts with a DatesProvider, passing the locale name in the settings prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/getting-started.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport 'dayjs/locale/ru';\n\nimport { DatesProvider } from '@mantine/dates';\n\nfunction Demo() {\n  return (\n    <DatesProvider settings={{ locale: 'ru' }}>\n      {/* Your app  */}\n    </DatesProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Fields with Yup and useForm\nDESCRIPTION: This snippet demonstrates how to validate nested fields using Yup with Mantine Form. It defines a Yup schema for a nested object and uses `yupResolver` to integrate it with `useForm`. The example includes how to access the corresponding validation errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/schema-validation.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { yupResolver } from 'mantine-form-yup-resolver';\nimport * as yup from 'yup';\nimport { useForm } from '@mantine/form';\n\nconst nestedSchema = yup.object().shape({\n  nested: yup.object().shape({\n    field: yup\n      .string()\n      .min(2, 'Field should have at least 2 letters'),\n  }),\n});\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    nested: {\n      field: '',\n    },\n  },\n  validate: yupResolver(nestedSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'nested.field': 'Field should have at least 2 letters',\n// }\n```\n\n----------------------------------------\n\nTITLE: Installing @mantinex/dev-icons with yarn\nDESCRIPTION: This snippet shows the command to install the @mantinex/dev-icons package using the yarn package manager.  The command `yarn add @mantinex/dev-icons` downloads and installs the package along with its dependencies into the project.  It does not take any parameters and the output is usually a success message and any warnings regarding peer dependencies.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/dev-icons/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @mantinex/dev-icons\n```\n\n----------------------------------------\n\nTITLE: Augmenting Variants Types for Custom Components\nDESCRIPTION: This example explains how to extend the variant type definitions in Mantine's component styling system, allowing developers to add custom variant options like 'contrast' or 'radial-gradient' for the Button component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ButtonVariant, MantineSize } from '@mantine/core';\n\ntype ExtendedButtonVariant = ButtonVariant | 'contrast' | 'radial-gradient';\n\ndeclare module '@mantine/core' {\n  export interface ButtonProps {\n    variant?: ExtendedButtonVariant;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine DatePickerInput Demo Components in JavaScript\nDESCRIPTION: This snippet imports the DatePickerInput demos, layout component, and MDX data required to render the documentation page. It sets up the basic dependencies and data used throughout the file, serving as the foundation for rendering example demos and documentation content.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { DatePickerInputDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Importing @mantine/spotlight Styles in React TypeScript\nDESCRIPTION: Imports the default styles for the @mantine/spotlight component from its CSS file. This should be done at the root level of the application after installing the package to ensure proper styling. The import statement should be placed in a TypeScript React (TSX) file.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/spotlight.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/spotlight/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Defining the useHeadroom Hook Interface and Function Signature (TypeScript)\nDESCRIPTION: Defines the `UseHeadroomInput` interface with optional parameters `fixedAt` (scroll distance in pixels for fixing), `onPin` (callback when pinned), `onFix` (callback when fixed), and `onRelease` (callback when unpinned) to configure the hook's behavior. It also shows the function signature for `useHeadroom`, which accepts this optional input object and returns a boolean indicating whether the element should be pinned (true) or hidden/released (false).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-headroom.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface UseHeadroomInput {\n  /** Number in px at which element should be fixed */\n  fixedAt?: number;\n\n  /** Called when element is pinned */\n  onPin?: () => void;\n\n  /** Called when element is at fixed position */\n  onFix?: () => void;\n\n  /** Called when element is unpinned */\n  onRelease?: () => void;\n}\n\nfunction useHeadroom(input?: UseHeadroomInput): boolean;\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Layout with MDX Data in React (JavaScript/TypeScript)\nDESCRIPTION: This snippet imports layout and styling configurations and renders the MDX data for Alert demos within the layout. It demonstrates component composition and data-driven rendering patterns in React.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/alert.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { AlertDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Alert);\n```\n\n----------------------------------------\n\nTITLE: Resulting CSS After PostCSS Variable Transformation\nDESCRIPTION: Displays the CSS output after `postcss-simple-vars` has processed the input containing variable references. The variables like `$mantine-breakpoint-xs` are replaced with their configured static values (e.g., `36em`). This demonstrates how the variables facilitate consistent breakpoint usage in CSS modules.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/responsive.mdx#_snippet_3\n\nLANGUAGE: css\nCODE:\n```\n@media (max-width: 36em) {\n  .demo {\n    background-color: red;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the TagsInput Component in Mantine (TSX)\nDESCRIPTION: Illustrates the basic usage of the `TagsInput` component in Mantine. It shows how to render the component with a label, placeholder text, and pre-defined data suggestions, allowing users to input custom tags or select from the provided list.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_29\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TagsInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TagsInput\n      label=\"Press Enter to submit a tag\"\n      placeholder=\"Pick tag from list\"\n      data={['React', 'Angular', 'Svelte']}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring px to rem Conversion in PostCSS\nDESCRIPTION: This code snippet configures the `postcss-preset-mantine` plugin to automatically convert pixel (px) values to rem units in CSS files. It sets the `autoRem` option to `true`. Dependencies include `postcss-preset-mantine` and a PostCSS configuration setup in `postcss.config.js` or equivalent.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {\n      autoRem: true,\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using renderRoot Prop for Typed Next.js Link with Mantine Button\nDESCRIPTION: Demonstrates leveraging the renderRoot prop to embed Next.js's Link component as the root element of a Mantine Button, enabling navigation capabilities within button components, especially when default behavior is insufficient.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Link from 'next/link';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button renderRoot={(props) => <Link href=\"/hello\" {...props} />}>\n      Typed Next link button\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Mantine Theme to Vanilla Extract Variables (TypeScript)\nDESCRIPTION: Imports a previously defined Mantine theme and uses the `themeToVars` function from `@mantine/vanilla-extract` to convert it into a CSS variables object. This `vars` object makes Mantine theme tokens accessible within Vanilla Extract's `.css.ts` files.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// theme.css.ts\nimport { theme } from './theme';\nimport { themeToVars } from '@mantine/vanilla-extract';\n\n// CSS variables object, can be access in *.css.ts files\nexport const vars = themeToVars(theme);\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine Components with Utility CSS via `classNames` (TSX)\nDESCRIPTION: Example of applying utility CSS classes (like Tailwind CSS) to specific inner elements of a Mantine `TextInput` component using the `classNames` prop. This allows targeted styling of component parts (`root`, `input`) without relying solely on CSS Modules.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TextInput\n      classNames={{\n        root: 'mt-4',\n        input: 'bg-red-500 text-white',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: HueSlider Component Demo (Mantine, React, TypeScript)\nDESCRIPTION: Provides an example of the HueSlider component with a controlled hue value state. Requires Mantine v7.3.0+ and React with useState. Shows current value as text and updates as slider is changed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { HueSlider, Text } from '@mantine/core';\n\nfunction Demo() {\n  const [value, onChange] = useState(250);\n\n  return (\n    <>\n      <Text>Hue value: {value}</Text>\n      <HueSlider value={value} onChange={onChange} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Space-separated rem Values in Modal Radius (React, TypeScript)\nDESCRIPTION: Shows how to pass space-separated radius values as a prop to the Modal component for setting different border radii. Requires Mantine Modal and rem utility with support for space-separated values. Accepts CSS-compatible border-radius strings.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Modal } from '@mantine/core';\n\nfunction Demo() {\n  return <Modal radius=\"10px 10px 0 0\" opened onClose={() => {}} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Accessible PillsInput with aria-label\nDESCRIPTION: This code snippet showcases how to make the `PillsInput` component accessible using the `aria-label` attribute on the `PillsInput.Field` component. The component is accessible because it has `aria-label` which makes it screen reader friendly. The component requires `@mantine/core` library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pills-input.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { PillsInput } from '@mantine/core';\n\n// Accessible input – it has aria-label\nfunction Demo() {\n  return (\n    <PillsInput>\n      <PillsInput.Field aria-label=\"Enter tags\" />\n    </PillsInput>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying MantineProvider Error Message - JSX\nDESCRIPTION: This snippet demonstrates usage of an <ErrorMessage> component to display a MantineProvider context error message in a React component tree. The 'error' prop supplies a descriptive string for the error. This approach is suitable for user-facing documentation or developer dashboards that relay errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/mantine-provider-missing.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<ErrorMessage error=\"@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app.\" />\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine CSS Layer\nDESCRIPTION: Shows how to import the Mantine CSS layer file, which wraps all Mantine styles in a `@layer mantine {}` at-rule. This reduces the specificity of Mantine styles, making it easier to override them with custom styles, particularly useful when import order cannot be controlled.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/styles-order.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/core/styles.layer.css';\n```\n\n----------------------------------------\n\nTITLE: Applying Layout Component with Metadata in JavaScript/TypeScript\nDESCRIPTION: This snippet imports a 'Layout' component and exports the result of calling it with the 'meta' object defined in the same file. This pattern is commonly used in frameworks like Next.js to wrap page content with a shared layout, passing page-specific data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/other-libs.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Importing TipTap Styles in React\nDESCRIPTION: Shows how to import the required styles for the @mantine/tiptap package at the root of your application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/tiptap/styles.css';\n```\n\n----------------------------------------\n\nTITLE: usePageLeave Hook Definition\nDESCRIPTION: Defines the `usePageLeave` hook, which takes a function as input and calls it when the mouse cursor leaves the document. The hook returns void.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-page-leave.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction usePageLeave(onPageLeave: () => void): void;\n```\n\n----------------------------------------\n\nTITLE: Defining Mantine useDocumentVisibility Hook Signature - TSX\nDESCRIPTION: This snippet provides the TypeScript signature for the `useDocumentVisibility` hook. It indicates that the hook is a function that returns a string literal type which can be either 'visible' or 'hidden', directly reflecting the possible values of `document.visibilityState`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-document-visibility.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useDocumentVisibility(): 'visible' | 'hidden';\n```\n\n----------------------------------------\n\nTITLE: Applying Margins to TextInput using Style Props in TSX\nDESCRIPTION: Shows how to use the `mt` (margin-top) style prop on `TextInput` components within a form to add vertical spacing between form elements. This example imports the `TextInput` component from `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/styles-overview.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <form>\n      <TextInput label=\"First name\" />\n      <TextInput label=\"Last name\" mt=\"md\" />\n      <TextInput label=\"Email\" mt=\"md\" />\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Multiple Mantine Component Styles in TypeScript\nDESCRIPTION: This code block shows how to import CSS files for a set of Mantine components that may be reused across other core components, ensuring all required styles are loaded when dependencies are unclear. It includes imports for ScrollArea, UnstyledButton, VisuallyHidden, Paper, Popover, CloseButton, Group, Loader, Overlay, ModalBase, Input, InlineInput, Flex, FloatingIndicator, and ActionIcon. Each CSS import loads styles necessary for the associated component, and using this approach guarantees that all potential base styles are available in projects with deeply nested or complex dependencies.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-files-list.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles/ScrollArea.css';\nimport '@mantine/core/styles/UnstyledButton.css';\nimport '@mantine/core/styles/VisuallyHidden.css';\nimport '@mantine/core/styles/Paper.css';\nimport '@mantine/core/styles/Popover.css';\nimport '@mantine/core/styles/CloseButton.css';\nimport '@mantine/core/styles/Group.css';\nimport '@mantine/core/styles/Loader.css';\nimport '@mantine/core/styles/Overlay.css';\nimport '@mantine/core/styles/ModalBase.css';\nimport '@mantine/core/styles/Input.css';\nimport '@mantine/core/styles/InlineInput.css';\nimport '@mantine/core/styles/Flex.css';\nimport '@mantine/core/styles/FloatingIndicator.css';\nimport '@mantine/core/styles/ActionIcon.css';\n```\n\n----------------------------------------\n\nTITLE: Defining DirectionProvider Props Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the expected properties for the DirectionProvider component used to control text direction in Mantine applications. It requires `children` as React nodes, an optional `initialDirection` to specify default text direction with values 'rtl' or 'ltr', and an optional `detectDirection` boolean that determines if direction should be detected based on the root element's dir attribute on mount. This interface ensures proper typing and configuration of the DirectionProvider component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rtl.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nexport interface DirectionProviderProps {\n  /** Your application */\n  children: React.ReactNode;\n\n  /** Direction set as a default value, `ltr` by default */\n  initialDirection?: 'rtl' | 'ltr';\n\n  /** Determines whether direction should be updated on mount based on `dir` attribute set on root element (usually html element), `true` by default  */\n  detectDirection?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Navigation Progress with Yarn and npm in Bash\nDESCRIPTION: This snippet shows the installation commands for adding the @mantine/nprogress package along with its peer dependencies @mantine/core and @mantine/hooks using yarn and npm. It ensures that the essential packages for the navigation progress bar are installed for use in a React project. The commands expect a JavaScript environment with access to the respective package managers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/nprogress/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/nprogress @mantine/core @mantine/hooks\n\n# With npm\nnpm install @mantine/nprogress @mantine/core @mantine/hooks\n```\n\n----------------------------------------\n\nTITLE: Importing Styles for @mantinex/mantine-logo (TSX)\nDESCRIPTION: Shows how to import the necessary CSS styles for the `@mantinex/mantine-logo` component into a TypeScript/React (TSX) file. This step is required for the component to render correctly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/mantine-logo/README.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantinex/mantine-logo/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Demonstrating FileButton issue in Menu - Mantine/React\nDESCRIPTION: This snippet references an external demo component (`FileButtonMenuBroken.demo`) that visually demonstrates the issue where a `FileButton` inside a `Menu` component does not trigger its `onChange` callback when the menu closes automatically upon item click.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/file-button-in-menu.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={FileButtonMenuBroken} />\n```\n\n----------------------------------------\n\nTITLE: Disabling Typography Styles in TipTap Editor\nDESCRIPTION: Demonstrates how to disable the default typography styles in RichTextEditor by setting withTypographyStyles prop to false, allowing for custom styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEditor } from '@tiptap/react';\nimport { RichTextEditor } from '@mantine/tiptap';\n\nfunction Demo() {\n  const editor = useEditor({\n    extensions: [\n      // ... your extensions\n    ],\n  });\n\n  return (\n    <RichTextEditor editor={editor} withTypographyStyles={false}>\n      <RichTextEditor.Content />\n    </RichTextEditor>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Mantine Dropzone Accept Types with Object (TSX)\nDESCRIPTION: Demonstrates how to specify accepted file types for the Dropzone using an object mapping mime types to arrays of file extensions. The keys are mime types, and values are arrays of accepted file extensions. 'onDrop' is a required prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/dropzone.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Dropzone } from '@mantine/dropzone';\n\nfunction Demo() {\n  return (\n    <Dropzone\n      accept={{\n        'image/*': [], // All images\n        'text/html': ['.html', '.htm'],\n      }}\n      onDrop={() => {}}\n    >\n      {/* children */}\n    </Dropzone>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Controlling acceptance of new values on blur with acceptValueOnBlur\nDESCRIPTION: This code shows how to modify the default behavior where new typed values are added when the input loses focus by setting 'acceptValueOnBlur' to false. When disabled, values are added only on Enter key press or suggestion click.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.acceptValueOnBlur} />\n```\n\n----------------------------------------\n\nTITLE: Creating custom variants with data-variant attribute\nDESCRIPTION: Demonstrates how to create custom component variants using the data-variant attribute. This example defines an 'underline' variant for the Input component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme, Input, MantineProvider } from '@mantine/core';\nimport classes from './Demo.module.css';\n\n// It is better to add new variants in theme.components\n// This way you will be able to use them in anywhere in the app\nconst theme = createTheme({\n  components: {\n    Input: Input.extend({ classNames: classes }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Input variant=\"underline\" placeholder=\"Underline input\" />\n      <Input variant=\"filled\" placeholder=\"Filled input\" mt=\"md\" />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing compound components with regular components to avoid errors\nDESCRIPTION: This code demonstrates an alternative approach by importing and using non-compound versions of Mantine components (e.g., `PopoverTarget`) which can be used in server components without `'use client'`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ✅ No error, no 'use client' needed\nimport { Popover, PopoverTarget } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover>\n      <PopoverTarget>\n        <button>Toggle popover</button>\n      </PopoverTarget>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Explanation of React hydration process in server-side rendering contexts\nDESCRIPTION: Describes how React handles hydration in server-side rendered applications, illustrating the sequence from server rendering to client hydration, and how mismatches between server and client HTML can trigger warnings, especially when client code modifies the DOM before hydration completes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Referencing Global CSS Classes within CSS Modules (SCSS)\nDESCRIPTION: Demonstrates using the `:global()` selector within a CSS module (using SCSS syntax) to apply styles to an element with a global class name (`.global-class-name`) when it appears inside an element styled by a local module class (`.test`). This allows interaction with unscoped, global styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_4\n\nLANGUAGE: scss\nCODE:\n```\n.test {\n  & :global(.global-class-name) {\n    color: red;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Redirecting to Carousel Route with Redirect Component (JSX)\nDESCRIPTION: This snippet utilizes the `Redirect` component from a hypothetical '@/components/Redirect' module to redirect the user to the `/x/carousel` route. This likely uses React Router or a similar routing library. The `to` prop specifies the target URL for redirection.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/carousel.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n\n<Redirect to=\"/x/carousel\" />\n```\n\n----------------------------------------\n\nTITLE: Using Line Height Variables in CSS\nDESCRIPTION: Shows how to access Mantine line height CSS variables in custom styles for consistent vertical spacing.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_8\n\nLANGUAGE: SCSS\nCODE:\n```\n.demo {\n  line-height: var(--mantine-line-height-md);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Theme Values in CSS\nDESCRIPTION: This snippet illustrates how to access theme values within CSS using CSS variables.  Mantine exposes theme values as CSS variables prefixed with `--mantine-`.  This approach allows consistent styling across the application by referencing theme-defined values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n.demo {\n  background: var(--mantine-color-red-1);\n  color: var(--mantine-color-red-9);\n  font-family: var(--mantine-font-family);\n  border-radius: var(--mantine-radius-md);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies TypeScript\nDESCRIPTION: This snippet imports necessary modules and components for defining and rendering the `use-field` hook's documentation and associated demos. It imports FieldDemos for the demo data, the Layout component for structuring the page, and MDX_DATA containing the data associated with the useField hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-field.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FieldDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Importing Divider Demo Data and Layout Component in JavaScript\nDESCRIPTION: This snippet performs ES6 imports for Divider demo data from '@docs/demos', the Layout component from a local layout directory, and MDX data from a local MDX module. These imports establish dependencies required to render divider demos within an application using React.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/divider.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { DividerDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Initializing useListState Hook\nDESCRIPTION: This snippet demonstrates how to initialize the `useListState` hook, which is a custom hook for managing list state in React. It takes an initial array as an argument and returns an array containing the current list values and a set of handlers for manipulating the list.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useListState } from '@mantine/hooks';\n\nconst [values, handlers] = useListState([{ a: 1 }]);\n```\n\n----------------------------------------\n\nTITLE: Implementing forwardRef for proper Tooltip compatibility\nDESCRIPTION: This example demonstrates the correct way to create a custom component that works with Tooltip by using forwardRef to pass the ref to the root element, enabling proper positioning.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tooltip.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Example of code that will work\nimport { forwardRef } from 'react';\nimport { Tooltip } from '@mantine/core';\n\nconst MyComponent = forwardRef<HTMLDivElement>((props, ref) => (\n  <div ref={ref} {...props}>\n    My component\n  </div>\n));\n\n// Works correctly – ref is forwarded\nfunction Demo() {\n  return (\n    <Tooltip label=\"Works fine\">\n      <MyComponent />\n    </Tooltip>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring X Axis Offset Using Padding Props in BarChart, JSX/TypeScript\nDESCRIPTION: Shows how to add padding around the x-axis to control spacing between chart edges and axis extremes with `xAxisProps` adjustments. Example relies on BarChartDemos.xAxisOffset data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_12\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.xAxisOffset} />\n```\n\n----------------------------------------\n\nTITLE: Passing removeScrollProps to react-remove-scroll in Drawer\nDESCRIPTION: This snippet exemplifies passing 'removeScrollProps' to the Drawer to customize scroll locking behavior, such as enabling pinch zoom. It leverages 'react-remove-scroll' to control scroll behavior when drawers are open.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/drawer.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Drawer } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Drawer\n      removeScrollProps={{ allowPinchZoom: true }}\n      opened\n      onClose={() => {}}\n    >\n      {/* Drawer content */}\n    </Drawer>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Mantine Provider in a Vite React Application\nDESCRIPTION: Example of how to import necessary Mantine styles and wrap your application with MantineProvider in a Vite React project. This setup is essential for Mantine components to work properly with their default styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vite.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Import styles of packages that you've installed.\n// All packages except `@mantine/hooks` require styles imports\nimport '@mantine/core/styles.css';\n\nimport { MantineProvider } from '@mantine/core';\n\nexport default function App() {\n  return <MantineProvider>{/* Your app here */}</MantineProvider>;\n}\n```\n\n----------------------------------------\n\nTITLE: useMove Usage Example (Basic)\nDESCRIPTION: Demonstrates basic usage of the useMove hook. It showcases how to access the ref for the target element and the active state, as well as how to log x and y coordinates on move events. The x and y values range from 0 to 1.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-move.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMove } from '@mantine/hooks';\n\nconst {\n  ref, // -> pass ref to target element\n  active, // -> is user changing something right now?\n} = useMove(({ x, y }) => console.log({ x, y }));\n```\n\n----------------------------------------\n\nTITLE: Basic Styling with Mantine Variables in Vanilla Extract (TypeScript)\nDESCRIPTION: Demonstrates basic component styling using Vanilla Extract's `style` function. It accesses Mantine theme properties (like font sizes and colors) via the imported `vars` object generated by `themeToVars`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/vanilla-extract.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Demo.css.ts\nimport { style } from '@vanilla-extract/css';\nimport { vars } from './theme';\n\nexport const demo = style({\n  fontSize: vars.fontSizes.xl,\n  backgroundColor: vars.colors.red[5],\n  color: vars.colors.white,\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Theme CSS Variables with withCssVariables Prop (TypeScript)\nDESCRIPTION: Demonstrates how to disable automatic addition of theme CSS variables to the document by setting 'withCssVariables' to false. Useful when managing styles via external CSS files.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider withCssVariables={false}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using Mixins with Mantine Breakpoints (SCSS)\nDESCRIPTION: Shows how to integrate 'smaller-than' and 'larger-than' mixins with Mantine-provided SCSS breakpoint variables for cleaner responsive styling. Requires Mantine breakpoint variables in the scope and postcss-preset-mantine v1.11.0+.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_2\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  @mixin smaller-than $mantine-breakpoint-sm {\n    color: red;\n  }\n\n  @mixin larger-than $mantine-breakpoint-sm {\n    color: blue;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Controlled Menu with Mantine Core in React\nDESCRIPTION: This code snippet demonstrates how to create a controlled Menu component using Mantine Core and React. It uses the useState hook to manage the opened state of the menu and the onChange prop to update the state when the menu is opened or closed.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/menu.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Menu } from '@mantine/core';\n\nfunction Demo() {\n  const [opened, setOpened] = useState(false);\n  return (\n    <Menu opened={opened} onChange={setOpened}>\n      {/* Menu content */}\n    </Menu>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Behavior of 'suppressHydrationWarning' attribute in React\nDESCRIPTION: Details how the 'suppressHydrationWarning' attribute taken from 'mantineHtmlProps' suppresses hydration warnings on specific elements—in this case, the '<html />' element—helping maintain consistent server and client DOMs without warnings, especially when client-side scripts modify the DOM before hydration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Implementing useReducedMotion Hook Definition\nDESCRIPTION: This TypeScript snippet defines the `useReducedMotion` hook. The hook accepts an optional `initialValue` boolean, which allows for specifying an initial value, especially relevant during server-side rendering where `window.matchMedia` might not be available. The `options` parameter is an object that can contain `getInitialValueInEffect` which is a boolean. The hook returns a boolean indicating whether the user prefers reduced motion. This hook leverages the `window.matchMedia()` API under the hood to detect the user's motion preferences based on the `prefers-reduced-motion` media query.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-reduced-motion.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useReducedMotion(\n  initialValue?: boolean,\n  options?: {\n    getInitialValueInEffect: boolean;\n  }\n): boolean;\n```\n\n----------------------------------------\n\nTITLE: Applying Styles to Disabled Button in CSS\nDESCRIPTION: This CSS snippet shows how to style the disabled button using the `data-disabled` attribute. It sets the text color to gray when the button is disabled.  The `&[data-disabled]` selector is used to specifically target the disabled state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n.my-button {\n  color: var(--mantine-color-black);\n\n  &[data-disabled] {\n    color: var(--mantine-color-gray-5);\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Close Button via closeButtonProps\nDESCRIPTION: This code highlights how to modify the close button's accessibility label using 'closeButtonProps', ensuring better accessibility compliance and allowing localization or descriptive labeling of the close button.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/drawer.mdx#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Drawer } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Drawer\n      closeButtonProps={{ 'aria-label': 'Close drawer' }}\n      opened\n      onClose={() => {}}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Nonce Attribute for Style Tags in MantineProvider (TypeScript)\nDESCRIPTION: Shows how to supply a function to generate a nonce value for `<style>` tags for security purposes, supporting Content Security Policy (CSP) compliance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\n// Example function implementation for nonce\nconst getStyleNonce = () => {\n  return 'random-generated-nonce';\n};\n\nfunction Demo() {\n  return (\n    <MantineProvider getStyleNonce={getStyleNonce}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Emotion Dependencies in Vite\nDESCRIPTION: This snippet shows the command to install the necessary packages for using Emotion with Mantine in a Vite project.  It includes core Emotion and Mantine Emotion packages.  Dependencies include: @mantine/emotion, @emotion/react, @emotion/cache, @emotion/serialize, and @emotion/utils.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nInstallScript packages=\"@mantine/emotion @emotion/react @emotion/cache @emotion/serialize @emotion/utils\"\n```\n\n----------------------------------------\n\nTITLE: Defining the useIsFirstRender Hook in TypeScript\nDESCRIPTION: This snippet defines the 'useIsFirstRender' hook in TypeScript, which returns a boolean indicating whether the component is rendering for the first time. It declares the function and its return type, serving as the core for first-render detection logic.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-is-first-render.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useIsFirstRender(): boolean;\n```\n\n----------------------------------------\n\nTITLE: Adding a right Y axis with 'withRightYAxis'\nDESCRIPTION: Enables an additional Y axis on the right side by setting 'withRightYAxis'. Passes down props via 'rightYAxisProps' and assigns a label with 'rightYAxisLabel'. Data series can be linked by setting 'yAxisId' in series configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.rightYAxis} />\n```\n\n----------------------------------------\n\nTITLE: CSS Styling to Remove MultiSelect Placeholder When Values Are Selected\nDESCRIPTION: Provides guidance on applying CSS styles to the MultiSelect component to hide the placeholder once the user has selected values, allowing for customized visual behavior. This involves styling the component with CSS rules to override default placeholder display.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/multiselect-value-placeholder.mdx#_snippet_4\n\nLANGUAGE: CSS\nCODE:\n```\n<Demo data={MultiSelectPlaceholderDemo} />\n```\n\n----------------------------------------\n\nTITLE: Controlling dropdown scroll behavior with withScrollArea\nDESCRIPTION: This code shows how to toggle between native scrollbar and custom scroll area in the dropdown menu by setting 'withScrollArea' to false. When disabled, customization of styles via Styles API is required.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.scrollArea} />\n```\n\n----------------------------------------\n\nTITLE: Adding ColorSchemeScript in _document.tsx\nDESCRIPTION: Defines a custom Document component that includes Mantine's ColorSchemeScript to support theme color schemes across server and client.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Head, Html, Main, NextScript } from 'next/document';\nimport { ColorSchemeScript, mantineHtmlProps } from '@mantine/core';\n\nexport default function Document() {\n  return (\n    <Html lang=\"en\" {...mantineHtmlProps}>\n      <Head>\n        <ColorSchemeScript defaultColorScheme=\"auto\" />\n      </Head>\n      <body>\n        <Main />\n        <NextScript />\n      </body>\n    </Html>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Mantine Layout with MDX Data in JavaScript\nDESCRIPTION: This code imports the Layout component and MDX data, then exports a default component rendering the layout with MDX contribute content. It demonstrates how to integrate Markdown/MDX content within a React component for documentation or contribution pages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/contribute.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Contribute);\n```\n\n----------------------------------------\n\nTITLE: Rendering Date Range Selection Demo for DatePickerInput in JSX\nDESCRIPTION: Shows a demo of setting the `type` prop to \"range\" enabling users to pick a range of dates. This demonstrates the component's ability to handle date-range selections visually and interactively.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.range} />\n```\n\n----------------------------------------\n\nTITLE: Definition of 'mantineHtmlProps' object for hydration management\nDESCRIPTION: Explains that 'mantineHtmlProps' is an object containing 'suppressHydrationWarning' set to true and default 'data-mantine-color-scheme' attribute, used to prevent hydration warnings and set initial color scheme before hydration occurs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const mantineHtmlProps = {\n  suppressHydrationWarning: true,\n  'data-mantine-color-scheme': 'light',\n};\n```\n\n----------------------------------------\n\nTITLE: Using CSS variables for color scheme changes in line color\nDESCRIPTION: Implements dynamic line color updates based on CSS variables that react to light/dark mode toggling, enhancing adaptive theming. Utilizes PostCSS mixins or functions such as 'light/dark' or 'light-dark'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.colorSchemeColor} />\n```\n\n----------------------------------------\n\nTITLE: Type Definition for useMediaQuery Hook in Mantine\nDESCRIPTION: Provides the function signature for useMediaQuery, detailing its parameters including the media query string, optional initial value, and optional configuration options object with getInitialValueInEffect.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-media-query.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useMediaQuery(\n  query: string,\n  initialValue?: boolean,\n  options?: {\n    getInitialValueInEffect: boolean;\n  }\n): boolean;\n```\n\n----------------------------------------\n\nTITLE: Client-Side Usage of useMediaQuery Hook in Mantine\nDESCRIPTION: Demonstrates how to import and utilize the useMediaQuery hook to subscribe to media query changes, triggering re-renders on viewport resize. Highlights reliance on window.matchMedia() API and behavior when API is unavailable.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-media-query.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { HooksDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.useMediaQuery);\n```\n\n----------------------------------------\n\nTITLE: Defining CSS Variables in React Style Prop with Mantine\nDESCRIPTION: Explains how to assign CSS variables via the style prop in Mantine components, allowing dynamic styling through CSS variables, extending beyond standard React.CSSProperties constraints.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box style={{ '--radius': '0.5rem', borderRadius: 'var(--radius)' }} />;\n}\n```\n\n----------------------------------------\n\nTITLE: HTML Output of Disabled Button\nDESCRIPTION: This HTML snippet displays the output of the TypeScript code when a button is disabled. The `data-disabled` attribute is added to the `<button>` element, indicating the disabled state. This attribute can be targeted by CSS to apply different styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<button class=\"my-button\" data-disabled>Disabled button</button>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of form.getValues in useEffect Dependencies\nDESCRIPTION: Example showing why form.getValues() should not be used in useEffect dependencies array since it returns a ref value that maintains the same reference.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/uncontrolled.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({ mode: 'uncontrolled' });\n\nuseEffect(() => {\n  // ❌ This will not work as form.getValues() is a ref value\n  // and will always be the same reference\n}, [form.getValues()]);\n```\n\n----------------------------------------\n\nTITLE: Getting Element Reference of JsonInput Textarea\nDESCRIPTION: This code shows how to get a ref to the underlying textarea element within JsonInput using GetElementRef, supporting imperative actions or focus management. It emphasizes how to access DOM elements in controlled components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/json-input.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n<GetElementRef component=\"JsonInput\" refType=\"textarea\" />\n```\n\n----------------------------------------\n\nTITLE: Adding Additional Custom Font Sizes\nDESCRIPTION: Shows how to define new font size variables beyond the default set, which can then be referenced in CSS and components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  fontSizes: {\n    xxs: '0.125rem',\n    xxl: '2rem',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing DropzoneForm Demo and Layout Components in JavaScript\nDESCRIPTION: Imports the DropzoneForm demo component which showcases usage of Dropzone with use-form, along with the Layout component used to wrap the demo page. These imports are necessary to compose the page demonstrating the integration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-use-dropzone-with-form.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { DropzoneForm } from '@/demos/DropzoneForm.demo';\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Controlling dropdown open state with dropdownOpened\nDESCRIPTION: This code demonstrates manual control over the dropdown's visibility using the 'dropdownOpened' prop, along with event handlers 'onDropdownOpen' and 'onDropdownClose' to respond to visibility changes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.dropdownOpened} />\n```\n\n----------------------------------------\n\nTITLE: Documenting Input Prop Customization with InputFeatures\nDESCRIPTION: This snippet describes how to customize the underlying input element of DateInput using the InputFeatures component, specifying element attributes like placeholder, className, etc., for advanced styling or behavior modifications.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n<InputFeatures component=\"DateInput\" element=\"input\" />\n```\n\n----------------------------------------\n\nTITLE: Demo Component for Placeholder Color Customization\nDESCRIPTION: This snippet renders the InputPlaceholderColorDemo component within the layout, demonstrating how to customize placeholder colors. It showcases practical implementation using the imported demo data to illustrate styling changes in the UI.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/inputs-placeholder-color.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={InputPlaceholderColorDemo} />\n```\n\n----------------------------------------\n\nTITLE: Changing Static Class Prefix with classNamesPrefix in MantineProvider (TypeScript)\nDESCRIPTION: Illustrates modifying the static class prefix used in component class names, enabling namespace customization for styling and avoiding conflicts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider, Text } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider classNamesPrefix=\"app\">\n      <Text>Just some text</Text>\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @mantine/vanilla-extract via Yarn/npm\nDESCRIPTION: Provides shell commands to install the @mantine/vanilla-extract package using either the Yarn or npm package manager. This package is necessary for integrating Mantine themes with the vanilla-extract CSS-in-JS library.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/vanilla-extract/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/vanilla-extract\n\n# With npm\nnpm install @mantine/vanilla-extract\n```\n\n----------------------------------------\n\nTITLE: Removing Items from a List with useListState\nDESCRIPTION: The `remove` handler removes items from the list at specified indices. It accepts the indices of the items to be removed as parameters. This example shows how to remove the items at index 0 and 2.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// remove items at given positions\nconst remove = () => handlers.remove(0, 2);\n// values -> [{ a: 4 }, { a: 2 }]\n```\n\n----------------------------------------\n\nTITLE: Defining useViewportSize Hook Signature in TypeScript\nDESCRIPTION: This TypeScript snippet provides the type definition for the `useViewportSize` hook. It shows that the hook returns an object containing `height` and `width` properties, both of which are numbers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-viewport-size.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useViewportSize(): {\n  height: number;\n  width: number;\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling dropdown transition animations with transitionProps\nDESCRIPTION: This code shows how to activate animation effects for dropdown opening and closing by passing transition properties through 'transitionProps', which are applied to the underlying Transition component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.dropdownAnimation} />\n```\n\n----------------------------------------\n\nTITLE: Controlling Style Order with CSS @layer Directive\nDESCRIPTION: Illustrates defining style layer order using @layer directive in SCSS to set precedence among multiple style sources, ensuring Mantine styles are properly layered relative to other libraries.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_2\n\nLANGUAGE: SCSS\nCODE:\n```\n@layer base, mantine, components;\n```\n\n----------------------------------------\n\nTITLE: Customizing CSS Variables Selector in MantineProvider (TypeScript)\nDESCRIPTION: Shows how to specify a CSS selector (like 'html') to which Mantine will apply generated CSS variables, enabling integration with different document structures or scoped styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider cssVariablesSelector=\"html\">\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hook Signature useDocumentTitle TypeScript\nDESCRIPTION: Defines the TypeScript signature for the `useDocumentTitle` hook. It specifies that the hook accepts a single argument, `title`, which must be a string. The hook itself does not return a value (`void`), as its primary function is a side effect (updating `document.title`). This signature indicates how the hook should be called.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-document-title.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useDocumentTitle(title: string): void;\n```\n\n----------------------------------------\n\nTITLE: TypeScript Ref Typing with useClickOutside Hook\nDESCRIPTION: Demonstrates how to properly type the ref returned by useClickOutside when using TypeScript. This ensures type safety when working with the hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-click-outside.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useClickOutside } from '@mantine/hooks';\n\nconst ref = useClickOutside<HTMLDivElement>(() =>\n  console.log('Click outside')\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Emotion Style Registry for Next.js\nDESCRIPTION: This React component, `RootStyleRegistry`, provides a server-side style registry for Emotion in a Next.js application. It uses `createCache` to generate a cache and `useServerInsertedHTML` to insert the styles into the document head. The component provides a way to flush the Emotion cache during server-side rendering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n'use client';\n\nimport { useState } from 'react';\nimport { useServerInsertedHTML } from 'next/navigation';\nimport createCache from '@emotion/cache';\nimport { CacheProvider } from '@emotion/react';\n\nexport function RootStyleRegistry({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const [{ cache, flush }] = useState(() => {\n    const cache = createCache({ key: 'my' });\n    cache.compat = true;\n    const prevInsert = cache.insert;\n    let inserted: string[] = [];\n    cache.insert = (...args) => {\n      const serialized = args[1];\n      if (cache.inserted[serialized.name] === undefined) {\n        inserted.push(serialized.name);\n      }\n      return prevInsert(...args);\n    };\n    const flush = () => {\n      const prevInserted = inserted;\n      inserted = [];\n      return prevInserted;\n    };\n    return { cache, flush };\n  });\n\n  useServerInsertedHTML(() => {\n    const names = flush();\n    if (names.length === 0) return null;\n    let styles = '';\n    for (const name of names) {\n      styles += cache.inserted[name];\n    }\n    return (\n      <style\n        data-emotion={`${cache.key} ${names.join(' ')}`}\n        dangerouslySetInnerHTML={{\n          __html: styles,\n        }}\n      />\n    );\n  });\n\n  return <CacheProvider value={cache}>{children}</CacheProvider>;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mantine Timeline Component Usage in TypeScript\nDESCRIPTION: This snippet renders usage demos of the Timeline component by importing predefined demo data and mounting it within a Demo component. It is designed to illustrate various Timeline features by passing different demo datasets as props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/timeline.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n<Demo data={TimelineDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Customizing label format with formatLabel prop\nDESCRIPTION: Illustrates how to modify the angle labels displayed on the slider using the formatLabel prop, which accepts a function returning a React node for custom display formatting.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/angle-slider.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={AngleSliderDemos.formatLabel} />\n```\n\n----------------------------------------\n\nTITLE: Applying Hover Styles with &:hover in SCSS Modules\nDESCRIPTION: Demonstrates using the standard SCSS `&:hover` pseudo-class within a CSS module file (`Element.module.css`) to change the background color of an element (`.element`) when hovered.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-add-hover-styles.mdx#_snippet_0\n\nLANGUAGE: scss\nCODE:\n```\n// Element.module.css\n.element {\n  &:hover {\n    background-color: red;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correct TextInput Usage Example\nDESCRIPTION: Illustrates the correct usage of `TextInput`, the preferred component for input fields.  It shows how `TextInput` provides accessibility and includes `Input.Wrapper` by default. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/input.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Use TextInput instead of Input everywhere you want to use Input,\n// it is accessible by default and includes Input.Wrapper\nfunction Correct() {\n  return (\n    <TextInput label=\"Input label\" description=\"Input description\" />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Progress Component Updated to Use Compound Patterns\nDESCRIPTION: Details that Progress now supports compound components for advanced customization, replacing previous internal implementations. Enables more flexible progress bar configurations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_14\n\n\n\n----------------------------------------\n\nTITLE: Using TagsInput with suggestions enabled\nDESCRIPTION: This snippet showcases the usage of TagsInput in conjunction with suggestion lists, allowing users to select predefined options using keyboard or mouse, with the flexibility to enter custom values as well.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.data} />\n```\n\n----------------------------------------\n\nTITLE: Using setValues to Update Multiple Form Values at Once\nDESCRIPTION: Shows how to use the form.setValues method to update multiple form values at once. The payload is shallow merged with current values state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: '', email: '', age: 0 },\n});\n\nform.setValues({ name: 'John', age: 21 });\nform.getValues(); // -> { name: 'John', email: '', age: 21 }\n```\n\n----------------------------------------\n\nTITLE: Getting element reference for DateTimePicker\nDESCRIPTION: This snippet shows how to obtain a reference to the DateTimePicker component, specifying the ref type and package, useful for programmatic control or focus management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n<GetElementRef\n  component=\"DateTimePicker\"\n  refType=\"button\"\n  package=\"@mantine/dates\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Invalid Data Example for Tree\nDESCRIPTION: Illustrates an invalid data structure for the Tree component, highlighting the requirement for unique `value` keys. This example is helpful in understanding data validation rules.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// ❌ Invalid data, values are not unique (components is used twice)\nconst data = [\n  {\n    value: 'src',\n    label: 'src',\n    children: [{ value: 'components', label: 'components' }],\n  },\n  { value: 'components', label: 'components' },\n];\n```\n\n----------------------------------------\n\nTITLE: Rendering DatePickerInput Input Props Configurator Demo in JSX\nDESCRIPTION: Displays an interactive demo for configuring input-related props of the DatePickerInput component, helping users understand various available input options and their effects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_10\n\nLANGUAGE: JSX\nCODE:\n```\n<InputFeatures component=\"DatePickerInput\" element=\"button\" />\n\n<Demo data={DatePickerInputDemos.configurator} />\n```\n\n----------------------------------------\n\nTITLE: Usage Example Showing Media Query Subscription and Demo Integration\nDESCRIPTION: Provides an example of how to render a demo component that responds to media query changes using the useMediaQuery hook, illustrating dynamic responsiveness in the UI.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-media-query.mdx#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n`<Demo data={HooksDemos.useMediaQueryDemo} />`\n```\n\n----------------------------------------\n\nTITLE: Controlling stroke dash pattern in lines\nDESCRIPTION: Sets 'strokeDasharray' to define dashed or solid lines by specifying dash and gap lengths. Commonly used for emphasizing or style differentiation in the data series.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_16\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.strokeDasharray} />\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Notifications Styles in TypeScript (TSX)\nDESCRIPTION: Imports the global styles for Mantine notifications in a TypeScript React project. This import should be placed at the root of the application to ensure notification components render correctly styled.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/notifications/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Enhancing accessibility with InputAccessibility\nDESCRIPTION: This snippet demonstrates the use of 'InputAccessibility' API to improve ARIA attributes and assistive technology support, ensuring that TagsInput is accessible to all users.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\n<InputAccessibility component=\"TagsInput\" />\n```\n\n----------------------------------------\n\nTITLE: Accessing TipTap Editor Context in Custom Component\nDESCRIPTION: Shows how to use the useRichTextEditorContext hook to access the TipTap Editor instance from context and create custom functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\nimport { useRichTextEditorContext } from '@mantine/tiptap';\n\nfunction Demo() {\n  const { editor } = useRichTextEditorContext();\n  return (\n    <Button\n      onClick={() => editor?.chain().focus().toggleBold().run()}\n    >\n      Make bold\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting X axis padding with 'xAxisProps'\nDESCRIPTION: Sets padding around the X axis via 'xAxisProps' to control the offset between the chart ends and the axis. Useful for aesthetic spacing or data clarity.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.xAxisOffset} />\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Font Sizes in Theme with TypeScript\nDESCRIPTION: Shows how to add or override font size variables in the theme configuration, automatically generating corresponding CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  fontSizes: {\n    xs: '0.5rem',\n    sm: '0.75rem',\n    md: '1rem',\n    lg: '1.25rem',\n    xl: '1.5rem',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Demo: Usage example for DateTimePicker\nDESCRIPTION: This demo illustrates how to use the DateTimePicker component with predefined usage data, showcasing its basic functionality and integration within the layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-time-picker.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DateTimePickerDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Defining Styles in a CSS Module (CSS)\nDESCRIPTION: Demonstrates creating a simple CSS module file (`Button.module.css`) with a single class (`.button`). This file defines styles that will be locally scoped when imported into a component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n/* Button.module.css */\n.button {\n  color: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring usePagination Boundaries Option\nDESCRIPTION: Demonstrates how to customize the number of visible page items at the beginning and end of the page range using the `boundaries` option during the initialization of the `usePagination` hook.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-pagination.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { usePagination } from '@mantine/hooks';\n\nconst pagination = usePagination({ total: 20, boundaries: 3 });\n```\n\n----------------------------------------\n\nTITLE: CSS module styles for conditional component styling\nDESCRIPTION: CSS module that defines styles for the TextInput component with required label and error state. Works with the previous React component example.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_6\n\nLANGUAGE: scss\nCODE:\n```\n.labelRequired {\n  color: var(--mantine-color-red-filled);\n}\n\n.inputError {\n  background-color: var(--mantine-color-red-light);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding labels to X and Y axes\nDESCRIPTION: Uses 'xAxisLabel' and 'yAxisLabel' props to display descriptive labels for axes. Improves chart comprehension by clearly indicating what each axis represents.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.axisLabels} />\n```\n\n----------------------------------------\n\nTITLE: Install Stylelint VSCode Extension\nDESCRIPTION: Provides a URL link to the Visual Studio Code extension that enables real-time CSS linting within the editor, improving developer workflow.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nhttps://marketplace.visualstudio.com/items?itemName=stylelint.vscode-stylelint\n```\n\n----------------------------------------\n\nTITLE: Deprecation of @mantine/prism in Favor of @mantine/code-highlight\nDESCRIPTION: The old Prism-based package is deprecated; developers should switch to @mantine/code-highlight which uses highlight.js for syntax highlighting, supporting modern standards.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_24\n\n\n\n----------------------------------------\n\nTITLE: Tabs API Renames and Style Changes\nDESCRIPTION: Describes renaming of selector keys (to 'list'), types (to 'TabsTabProps'), and props ('onTabChange' to 'onChange','position' to 'justify'), to improve consistency.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_17\n\n\n\n----------------------------------------\n\nTITLE: Using regular styles prop in both versions\nDESCRIPTION: Demonstrates how regular styles prop without nested selectors works the same in both 6.x and 7.x.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/6x-to-7x.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n// Works both in 6.x and 7.x\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <TextInput\n      styles={{\n        input: {\n          color: 'red',\n        },\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Store with Yarn\nDESCRIPTION: This command installs the @mantine/store package using Yarn. It adds the package as a dependency to your project, allowing you to use its global state management capabilities.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/store/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @mantine/store\n```\n\n----------------------------------------\n\nTITLE: Adding Overlay Demo in BarChart\nDESCRIPTION: This snippet shows a new demo rendering a BarChart with overlay features, illustrating custom overlay configurations or visual enhancements within bar charts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-15-0.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={BarChartDemos.overlay} />\n```\n\n----------------------------------------\n\nTITLE: Implementing Hotkeys with useHotkeys\nDESCRIPTION: This snippet demonstrates the basic usage of the `useHotkeys` hook. It defines hotkey-handler pairs. When specific key combinations are pressed, the associated console log messages are executed. The `useHotkeys` hook takes an array of hotkey definitions as its primary argument.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-hotkeys.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useHotkeys } from '@mantine/hooks';\n\nfunction Demo() {\n  // ctrl + J and ⌘ + J to toggle color scheme\n  // ctrl + K and ⌘ + K to search\n  useHotkeys([\n    ['mod+J', () => console.log('Toggle color scheme')],\n    ['ctrl+K', () => console.log('Trigger search')],\n    ['alt+mod+shift+X', () => console.log('Rick roll')],\n  ]);\n\n  return null;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing zod and mantine-form-zod-resolver (bash)\nDESCRIPTION: Commands for installing Zod and the Mantine form resolver package via yarn. Prerequisites: Node.js environment with yarn as a package manager.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add zod mantine-form-zod-resolver\n```\n\n----------------------------------------\n\nTITLE: Disabling tooltip and interactions\nDESCRIPTION: Sets 'withTooltip' to false, removing the tooltip, cursor line, and user interactions, resulting in a static, non-interactive chart display.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_21\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.noTooltip} />\n```\n\n----------------------------------------\n\nTITLE: Using Next.js Link with Mantine Button\nDESCRIPTION: Demonstrates making a Mantine Button act as a Next.js Link component for client-side routing by setting the component prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Link from 'next/link';\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button component={Link} href=\"/hello\">\n      Next link button\n    </Button>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installation Command for Stylelint and Config Package\nDESCRIPTION: Provides a script to install Stylelint and the standard SCSS configuration package via command line, facilitating CSS linting setup.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n<InstallScript packages=\"stylelint stylelint-config-standard-scss\" />\n```\n\n----------------------------------------\n\nTITLE: Disabling Static Classes in MantineProvider (TypeScript)\nDESCRIPTION: Shows how to disable static CSS classes for components by setting 'withStaticClasses' to false, which may be desirable for minimal class names or styling control.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider withStaticClasses={false}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useClickOutside Hook\nDESCRIPTION: Shows the full TypeScript type definition for the useClickOutside hook, including its parameters and return type. The hook accepts a handler function, optional events array, and optional nodes array.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-click-outside.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useClickOutside<T extends HTMLElement = any>(\n  handler: () => void,\n  events?: string[] | null,\n  nodes?: HTMLElement[]\n): React.MutableRefObject<T>;\n```\n\n----------------------------------------\n\nTITLE: Setting Root Font Size with CSS\nDESCRIPTION: This snippet demonstrates how to specify the base font size of the HTML root element in CSS, which affects rem unit scaling throughout the application. Setting \":root { font-size: 10px; }\" overrides the browser default. No dependencies are required except standard CSS support. The only input is the CSS declaration itself, which sets the base for all rem calculations in the DOM.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/rem.mdx#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n:root {\n  font-size: 10px;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing DEFAULT_THEME from Mantine Core (TypeScript/React)\nDESCRIPTION: This snippet demonstrates how to import the `DEFAULT_THEME` object from the `@mantine/core` package. This object contains the default configuration for Mantine's theme, useful for extending or inspecting the base styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/default-theme.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { DEFAULT_THEME } from '@mantine/core';\n```\n\n----------------------------------------\n\nTITLE: Using Redirect Component for Navigation (JSX)\nDESCRIPTION: This snippet renders the 'Redirect' component in the JSX output, passing the target URL '/x/notifications' via the 'to' prop. When this component is rendered, it triggers a client-side navigation to the specified route, effectively redirecting the user.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/notifications.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Redirect to=\"/x/notifications\" />\n```\n\n----------------------------------------\n\nTITLE: ColorSwatch Component Demo\nDESCRIPTION: Renders a component demo for ColorSwatch, showcasing additional functionality or customization options.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/color-swatch.mdx#_snippet_4\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ColorSwatchDemos.component} />\n```\n\n----------------------------------------\n\nTITLE: Displaying Usage Demos for Badge Component in Mantine (JSX/React)\nDESCRIPTION: This snippet uses the <Demo> component to display interactive Badge usage examples by passing demo data sourced from BadgeDemos. These data-driven demos illustrate various Badge configurations, such as gradients, rounded variants, sections, full width, custom variant color resolvers, auto contrast, and styles API. No explicit imports are shown for Demo or custom components, but their usage requires registration in the parent framework.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/badge.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={BadgeDemos.usage} />\n<Gradient component=\"Badge\" />\n<Demo data={BadgeDemos.gradient} />\n<Demo data={BadgeDemos.rounded} />\n<Demo data={BadgeDemos.sections} />\n<Demo data={BadgeDemos.fullWidth} />\n<Demo data={BadgeDemos.variantColorsResolver} />\n<AutoContrast component=\"Badge\" />\n<Demo data={BadgeDemos.autoContrast} />\n<StylesApiSelectors component=\"Badge\" />\n<Demo data={BadgeDemos.stylesApi} />\n```\n\n----------------------------------------\n\nTITLE: Rendering Basic List Demo with Configurator\nDESCRIPTION: Uses a custom `<Demo>` component to render a basic configuration example of the Mantine List component. The actual code and configuration details are provided by the `ListDemos.configurator` object.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/list.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={ListDemos.configurator} />\n```\n\n----------------------------------------\n\nTITLE: Group Component Prop Renames and Additions\nDESCRIPTION: Details prop updates such as 'position' to 'justify', 'noWrap' to 'wrap=\"nowrap\"', and new 'preventGrowOverflow' prop, facilitating flexible flexbox layouts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_16\n\n\n\n----------------------------------------\n\nTITLE: Using onValuesChange Callback for Form Value Changes\nDESCRIPTION: Proper way to observe form value changes using the onValuesChange callback instead of useEffect with form values.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/uncontrolled.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n  onValuesChange: (values) => {\n    // ✅ This will be called on every form values change\n    console.log(values);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering vertical orientation LineChart\nDESCRIPTION: Sets 'orientation=\"vertical\"' to render the chart vertically. Useful for specific visualization needs such as category bars or alternative layouts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_25\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.vertical} />\n```\n\n----------------------------------------\n\nTITLE: Rendering Layout with Metadata\nDESCRIPTION: This snippet renders the page layout by passing the metadata object to the Layout component, which structures the page according to the project's layout conventions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/inputs-placeholder-color.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Starting the RedwoodJS Development Server (Bash)\nDESCRIPTION: Runs the RedwoodJS development server using the `yarn rw dev` command after completing the Mantine setup steps. This command starts the application locally for development.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/redwood.mdx#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nyarn rw dev\n```\n\n----------------------------------------\n\nTITLE: Rendering Tree Component with Layout\nDESCRIPTION: Renders the Tree component within a layout using the `MDX_DATA.Tree` content. This sets the stage for displaying the Tree component in the application, integrating it with a predefined layout structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport default Layout(MDX_DATA.Tree);\n```\n\n----------------------------------------\n\nTITLE: Adjusting line stroke width\nDESCRIPTION: Sets 'strokeWidth' to control the thickness of all lines in the chart, aiding in visual emphasis or aesthetic balance.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_23\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.strokeWidth} />\n```\n\n----------------------------------------\n\nTITLE: Removing Values from Storage with useLocalStorage in React\nDESCRIPTION: Shows how to use the removeValue callback returned by the useLocalStorage hook to clear values from localStorage. When a value is removed, it is reset to the specified defaultValue.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useLocalStorage } from '@mantine/hooks';\n\nconst [value, setValue, removeValue] = useLocalStorage({\n  key: 'color-scheme',\n  defaultValue: 'light',\n});\n```\n\n----------------------------------------\n\nTITLE: Install Mantine Hooks with Yarn\nDESCRIPTION: This command installs the @mantine/hooks package using Yarn. It adds the package to your project's dependencies, allowing you to use the hooks in your React components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/hooks/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @mantine/hooks\n```\n\n----------------------------------------\n\nTITLE: Support for withErrorStyles Prop in Inputs\nDESCRIPTION: Enables customization of error styling on inputs by supporting the withErrorStyles prop, offering more control over error indication presentations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_28\n\n\n\n----------------------------------------\n\nTITLE: Importing Layout and MDX Data in Next.js\nDESCRIPTION: Imports Layout component and MDX data, then renders MDX content wrapped in the Layout component in a Next.js page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.NextJs);\n```\n\n----------------------------------------\n\nTITLE: Using form.initialize with TanStack Query\nDESCRIPTION: This snippet demonstrates using `form.initialize` to populate form values with data fetched using TanStack Query (react-query).  It uses `@tanstack/react-query`, `@mantine/form`, and `@mantine/core`. The `query.data` changes trigger re-initialization of the form.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const query = useQuery({\n    queryKey: ['current-user'],\n    queryFn: () => fetch('/api/users/me').then((res) => res.json()),\n  });\n\n  const form = useForm({\n    initialValues: {\n      name: '',\n      email: '',\n    },\n  });\n\n  useEffect(() => {\n    if (query.data) {\n      // Even if query.data changes, form will be initialized only once\n      form.initialize(query.data);\n    }\n  }, [query.data]);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Importing Nested Popover Demos in React\nDESCRIPTION: Imports demo components for nested popovers and layout configuration for a Mantine documentation page about handling nested popovers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/nested-popover-closes.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport {\n  NestedPopovers,\n  NestedPopoversWorking,\n} from '@/demos/NestedPopovers.demo';\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: useThrottledValue Usage Demo\nDESCRIPTION: Demonstrates how to use the useThrottledValue hook from the @docs/demos module.  It uses the HooksDemos.useThrottledValueUsage demo component to showcase the hook's functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-throttled-value.mdx#_snippet_0\n\nLANGUAGE: MDX\nCODE:\n```\n<Demo data={HooksDemos.useThrottledValueUsage} />\n```\n\n----------------------------------------\n\nTITLE: Implementing useMutationObserver hook in Mantine\nDESCRIPTION: Demonstrates the usage of the new useMutationObserver hook which provides a way to watch for changes being made to the DOM tree.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-7-0.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={HooksDemos.useMutationObserverTarget} />\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the FloatingIndicator component in Mantine\nDESCRIPTION: Shows the usage of the new FloatingIndicator component which provides a floating visual element that can be positioned in different directions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-7-0.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={FloatingIndicatorDemos.direction} />\n```\n\n----------------------------------------\n\nTITLE: Using ScatterChart component for data visualization in Mantine\nDESCRIPTION: Example of implementing the new ScatterChart component which allows plotting of individual data points on a Cartesian grid.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-7-0.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={ScatterChartDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Custom Value Format for MonthPickerInput\nDESCRIPTION: Demonstrates using the valueFormat prop to customize the display format of selected months using dayjs formatting patterns.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.valueFormat} />\n```\n\n----------------------------------------\n\nTITLE: Setting a Property of an Item with useListState\nDESCRIPTION: The `setItemProp` handler sets a specific property of an item at a given index. It takes the index, property name, and new value as parameters. In this example, it sets the `a` property of the item at index 1 to `new-prop`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n// set item property at given position\nconst setItemProp = () => handlers.setItemProp(1, 'a', 'new-prop');\n// values -> [{ a: 8 }, { a: 'new-prop' }]\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Shadows - Mantine Theme - TSX\nDESCRIPTION: Explains how to override the default shadow styles for different scales (`xs` through `xl`) by providing custom CSS box-shadow strings in the `shadows` property of the `createTheme` function. The defined shadows are then accessible via `--mantine-shadow-*` CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_22\n\nLANGUAGE: TSX\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  shadows: {\n    xs: '0 1px 2px rgba(0, 0, 0, 0.1)',\n    sm: '0 1px 3px rgba(0, 0, 0, 0.1)',\n    md: '0 2px 4px rgba(0, 0, 0, 0.1)',\n    lg: '0 4px 8px rgba(0, 0, 0, 0.1)',\n    xl: '0 8px 16px rgba(0, 0, 0, 0.1)',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring dropdown padding and shadow\nDESCRIPTION: These snippets demonstrate styling customization of the dropdown menu's padding and shadow, improving visual appearance and spacing to match design requirements.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tags-input.mdx#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.dropdownPadding} />\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n<Demo data={TagsInputDemos.dropdownShadow} />\n```\n\n----------------------------------------\n\nTITLE: Defining useWindowScroll Hook in TypeScript React\nDESCRIPTION: TypeScript definition of the useWindowScroll hook which returns a tuple containing the current scroll position (x, y coordinates) and a function to smoothly scroll to a given position. The scroll function accepts an object with optional x and y coordinates.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-window-scroll.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useWindowScroll(): readonly [\n  { x: number; y: number },\n  (position: { x?: number; y?: number }) => void,\n];\n```\n\n----------------------------------------\n\nTITLE: Adding Styles to Components in Theme\nDESCRIPTION: This snippet shows how to extend the Mantine theme to include custom styles for existing components. The example adds a style for the 'Text' component, allowing for consistent theming across the application. This helps to avoid potential type collisions and simplifies style management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/emotion.mdx#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme, MantineTheme, TextProps } from '@mantine/core';\nimport { EmotionHelpers } from '@mantine/emotion';\n\nexport const theme = createTheme({\n  components: {\n    Text: {\n      styles: (\n        theme: MantineTheme,\n        _props: TextProps,\n        u: EmotionHelpers\n      ) => ({\n        root: {\n          [u.light]: {\n            color: theme.colors.blue[7],\n          },\n        },\n      }),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing npm-check-updates Globally\nDESCRIPTION: Installs the npm-check-updates package globally to make it available as the 'ncu' command without needing npx each time.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-update-dependencies.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install -g npm-check-updates\n```\n\n----------------------------------------\n\nTITLE: Exporting Layout Component with Metadata\nDESCRIPTION: Exports a Layout component configured with the page metadata for a Mantine documentation page about nested popovers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/nested-popover-closes.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: useListState Hook Definition\nDESCRIPTION: This code presents the TypeScript definition of the `useListState` hook, including the type of the initial value (array of `T`) and its return type (a tuple containing the array of type `T` and `UseListStateHandlers<T>`).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-list-state.mdx#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useListState<T>(\n  initialValue?: T[]\n): [T[], UseListStateHandlers<T>];\n```\n\n----------------------------------------\n\nTITLE: Opening Spotlight with a Mantine Button via spotlight.open() in React TypeScript\nDESCRIPTION: Demonstrates how to link the spotlight.open method to a Mantine Button component’s onClick handler to open the Spotlight UI. It imports Button from @mantine/core and spotlight from @mantine/spotlight, providing a practical example of integration within React components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/spotlight.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button } from '@mantine/core';\nimport { spotlight } from '@mantine/spotlight';\n\nfunction Demo() {\n  return <Button onClick={spotlight.open}>Open spotlight</Button>;\n}\n```\n\n----------------------------------------\n\nTITLE: MonthPickerInput with Configurator\nDESCRIPTION: Demonstrates various configuration options available for the MonthPickerInput component using a visual configurator.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/month-picker-input.mdx#_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={MonthPickerInputDemos.configurator} />\n```\n\n----------------------------------------\n\nTITLE: CSS module for custom Input variant styles\nDESCRIPTION: SCSS module that defines styles for a custom 'underline' variant of the Input component, using the data-variant attribute selector and Mantine's CSS mixins.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_9\n\nLANGUAGE: scss\nCODE:\n```\n.input {\n  &[data-variant='underline'] {\n    border-bottom: rem(2px) solid;\n    border-radius: 0;\n    padding-left: 0;\n    padding-right: 0;\n\n    @mixin light {\n      border-color: var(--mantine-color-gray-3);\n    }\n\n    @mixin dark {\n      border-color: var(--mantine-color-dark-3);\n    }\n\n    &:focus {\n      border-color: var(--mantine-color-blue-filled);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for React Component in Mantine\nDESCRIPTION: Imports necessary modules: demo data for the fieldset component, a layout component, and MDX content data for rendering. These imports set up dependencies required for rendering and demonstrating the component within the application.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/fieldset.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { FieldsetDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: CSS-Only Loader Component for Improved Performance\nDESCRIPTION: Highlights that Loader uses only CSS for animations, reducing HTML output and improving performance. The theme object no longer supports 'theme.loader,' and custom loaders can be configured via default props.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Importing and Setting Up DatesProvider in Next.js Layout\nDESCRIPTION: Default export setup for the DatesProvider documentation page in a Next.js application, importing necessary components and demo data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/dates-provider.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DatesProviderDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.DatesProvider);\n```\n\n----------------------------------------\n\nTITLE: Definition Signature of useFocusTrap Hook in TypeScript\nDESCRIPTION: This snippet provides the TypeScript function signature for the useFocusTrap hook. It accepts an optional boolean parameter 'active' to control if the focus trap is enabled, and returns a ref callback function that accepts an HTMLElement instance to bind the focus trap behavior. This signature clarifies the hook's inputs and outputs for type safety and use in TypeScript projects.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-focus-trap.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useFocusTrap(\n  active?: boolean\n): (instance: HTMLElement) => void;\n```\n\n----------------------------------------\n\nTITLE: Using Old Colors with MantineProvider Theme (React, TypeScript)\nDESCRIPTION: Demonstrates how to override Mantine's default dark color palette with previous color values via the theme config in MantineProvider. Requires '@mantine/core' and uses the createTheme utility for theming.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.3.0.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  colors: {\n    dark: [\n      '#C1C2C5',\n      '#A6A7AB',\n      '#909296',\n      '#5c5f66',\n      '#373A40',\n      '#2C2E33',\n      '#25262b',\n      '#1A1B1E',\n      '#141517',\n      '#101113',\n    ],\n  },\n});\n\nfunction Demo() {\n  return <MantineProvider theme={theme}>{/* Your app here */}</MantineProvider>;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing HoverCard Dependencies (TypeScript)\nDESCRIPTION: Imports necessary components for the HoverCard documentation page: `HoverCardDemos` for example implementations, `Layout` for page structure, and `MDX_DATA` for content integration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/hover-card.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HoverCardDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Import Paper Demos\nDESCRIPTION: Imports the `PaperDemos` object from the `@docs/demos` module. This object likely contains various demonstrations or example usages of the Paper component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/paper.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PaperDemos } from '@docs/demos';\n```\n\n----------------------------------------\n\nTITLE: Import Layout Component\nDESCRIPTION: Imports the `Layout` component from the '@/layout' module. This component is likely used to provide a consistent layout structure for the page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/paper.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Exporting Page Layout with MDX Data (JavaScript/TypeScript)\nDESCRIPTION: This snippet exports the page default using the Layout component, providing it with Center-specific MDX data. Purpose: ensures the documentation page uses consistent layout and renders content pulled from MDX files. Dependencies: React, project-specific Layout and MDX_DATA modules. Input: none. Output: fully rendered page with documentation content. Limitation: only works within configured Mantine documentation environment.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/center.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default Layout(MDX_DATA.Center);\n```\n\n----------------------------------------\n\nTITLE: Best Practices for Accessing Form Values with getValues vs values\nDESCRIPTION: Comparison showing why form.getValues() should be used instead of form.values to get current form values, especially after field value changes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/uncontrolled.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: 'John Doe' },\n});\n\nconst handleNameChange = () => {\n  form.setFieldValue('name', 'Test Name');\n\n  // ❌ Do not use form.values to get the current form values\n  // form.values has stale name value until next rerender in controlled mode\n  // and is always outdated in uncontrolled mode\n  console.log(form.values); // { name: 'John Doe' }\n\n  // ✅ Use form.getValues to get the current form values\n  // form.getValues always returns the latest form values\n  console.log(form.getValues()); // { name: 'Test Name' }\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Valibot Resolver for Nested Validation\nDESCRIPTION: This code demonstrates Valibot validation on nested form fields. It defines a schema with a nested object and applies it to a `@mantine/form` instance. Dependencies are the same as the previous example, including `@mantine/form`, `valibot`, and `mantine-form-valibot-resolver`. The `validate` method is called, and errors are accessed through `form.errors`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.4.0.md#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport { valibotResolver } from 'mantine-form-valibot-resolver';\nimport { minLength, object, string } from 'valibot';\nimport { useForm } from '@mantine/form';\n\nconst nestedSchema = object({\n  nested: object({\n    field: string([minLength(2, 'Field should have at least 2 letters')]),\n  }),\n});\n\nconst form = useForm({\n  initialValues: {\n    nested: {\n      field: '',\n    },\n  },\n  validate: valibotResolver(nestedSchema),\n});\n\nform.validate();\nform.errors;\n// -> {\n//  'nested.field': 'Field should have at least 2 letters',\n// }\n\n```\n\n----------------------------------------\n\nTITLE: Using Link Extension from Mantine TipTap\nDESCRIPTION: Shows how to use the custom Link extension provided by @mantine/tiptap, which is required for the Ctrl + K keyboard shortcut to work properly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/tiptap.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Use Link extension exported from the @mantine/tiptap package\nimport { useEditor } from '@tiptap/react';\nimport { Link, RichTextEditor } from '@mantine/tiptap';\n\nfunction Demo() {\n  const editor = useEditor({\n    extensions: [\n      Link,\n      // ... other extensions\n    ],\n  });\n\n  return (\n    <RichTextEditor editor={editor}>\n      <RichTextEditor.Content />\n    </RichTextEditor>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @mantinex/mantine-logo with Yarn/NPM (Bash)\nDESCRIPTION: Provides commands to install the `@mantinex/mantine-logo` package using either the Yarn or NPM package managers. Choose the command corresponding to your preferred package manager.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/mantine-logo/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantinex/mantine-logo\n\n# With npm\nnpm install @mantinex/mantine-logo\n```\n\n----------------------------------------\n\nTITLE: Implementing a Controlled Mantine Switch in TSX\nDESCRIPTION: Demonstrates how to manage the checked state of a Mantine `Switch` component using the `useState` hook in React. The `checked` prop is bound to the state variable, and the `onChange` handler updates the state based on the event's `currentTarget.checked` value. Requires `react` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/switch.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Switch } from '@mantine/core';\n\nfunction Demo() {\n  const [checked, setChecked] = useState(false);\n  return (\n    <Switch\n      checked={checked}\n      onChange={(event) => setChecked(event.currentTarget.checked)}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom SVG Loaders for Mantine in React\nDESCRIPTION: Demonstrates adding a custom SVG-based loader via Mantine's theme default props. Emphasizes setting SVG 'width' and 'height' to 'var(--loader-size)' and 'fill'/'stroke' to 'var(--loader-color)' to ensure compatibility with Mantine's 'size' and 'color' props. Note that CSS-only loaders are generally recommended due to potential performance issues with SVG animations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/loader.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// 1. Define SVG component or string\nconst MySvgLoader = () => (\n  <svg\n    style={{ width: 'var(--loader-size)', height: 'var(--loader-size)' }}\n    viewBox=\"0 0 38 38\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    stroke=\"var(--loader-color)\"\n  >\n    {/* SVG animation elements (e.g., <circle>, <animate>) go here */}\n    <g fill=\"none\" fillRule=\"evenodd\">\n      <g transform=\"translate(1 1)\" strokeWidth=\"2\">\n        <circle strokeOpacity=\".5\" cx=\"18\" cy=\"18\" r=\"18\"/>\n        <path d=\"M36 18c0-9.94-8.06-18-18-18\">\n          <animateTransform\n            attributeName=\"transform\"\n            type=\"rotate\"\n            from=\"0 18 18\"\n            to=\"360 18 18\"\n            dur=\"1s\"\n            repeatCount=\"indefinite\"/>\n        </path>\n      </g>\n    </g>\n  </svg>\n);\n\n// 2. Add to Mantine theme default props\nimport { MantineProvider, Loader, createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  components: {\n    Loader: Loader.extend({\n      defaultProps: {\n        loaders: {\n          ...Loader.defaultLoaders,\n          'my-svg': <MySvgLoader />,\n        },\n      },\n    }),\n  },\n});\n\n// Usage in a component\nfunction App() {\n  return (\n    <MantineProvider theme={theme}>\n      <Loader type=\"my-svg\" size=\"lg\" color=\"green\" />\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Avatar Component Import in Mantine\nDESCRIPTION: This snippet imports the Avatar component from the '@mantine/core' module. This is a necessary step for using the Avatar component in any React functional component within the project. This import enables access to the Avatar component and its associated functionalities, such as rendering avatar images and placeholders.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/avatar.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Avatar } from '@mantine/core';\n```\n\n----------------------------------------\n\nTITLE: useFullscreen Hook Definition\nDESCRIPTION: Defines the structure and properties of the useFullscreen hook. It returns an object containing a ref function to set the target element, a toggle function to enter/exit fullscreen, and a boolean indicating the current fullscreen state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-fullscreen.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction useFullscreen<T extends HTMLElement = any>(): {\n  readonly ref: (element: T | null) => void;\n  readonly toggle: () => Promise<void>;\n  readonly fullscreen: boolean;\n};\n```\n\n----------------------------------------\n\nTITLE: Importing OS Type Definition in TypeScript\nDESCRIPTION: This snippet demonstrates how to import the `OS` type from the `@mantine/hooks` library. This type defines the possible operating system values returned by the `use-os` hook.  It's a union type of string literals, including `undetermined`, `macos`, `ios`, `windows`, `android`, and `linux`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-os.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { OS } from '@mantine/hooks';\n\n// OS type is 'undetermined' | 'macos' | 'ios' | 'windows' | 'android' | 'linux'\n```\n\n----------------------------------------\n\nTITLE: Incorrect usage of useComputedColorScheme with SSR (TSX)\nDESCRIPTION: Illustrates an incorrect way to conditionally render elements based on the color scheme value using `useComputedColorScheme` and `getColorScheme`. This approach is incompatible with server-side rendering (SSR) and can lead to hydration mismatches.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-get-color-scheme-value-in-js.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useComputedColorScheme } from '@mantine/core';\nimport { getColorScheme } from './getColorScheme';\n\n// ❌ Not compatible with SSR\nfunction Demo() {\n  const colorScheme = useComputedColorScheme();\n\n  return (\n    <div>\n      {colorScheme === 'dark' && <div>Dark mode</div>}\n      {getColorScheme() === 'light' && <div>Light mode</div>}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Bar Overlays in BarChart, JSX/TypeScript\nDESCRIPTION: Supports rendering overlays on bars for additional visual effects or layering by providing appropriate data via BarChartDemos.overlay. The snippet implies layering but without explicit code details.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/bar-chart.mdx#_snippet_30\n\nLANGUAGE: TSX\nCODE:\n```\n<Demo data={BarChartDemos.overlay} />\n```\n\n----------------------------------------\n\nTITLE: Defining the ParseThemeColorResult Interface in Mantine Core (TypeScript)\nDESCRIPTION: Defines the TypeScript interface `ParseThemeColorResult` which specifies the structure of the object returned by the `parseThemeColor` function. This interface includes properties like `isThemeColor` (boolean), `color` (theme color key), `value` (resolved CSS color), `shade` (theme color index), and `variable` (CSS variable name) to provide comprehensive information about a parsed theme color.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ParseThemeColorResult {\n  /**\n   * True if given color is theme color, for example\n   * `blue`, `orange.9`, `pink.3` are theme colors\n   * `#fff`, `rgba(0, 0, 0, .5)` are not\n   */\n  isThemeColor: boolean;\n\n  /**\n   * Key of `theme.colors` if given color is theme color, for example\n   * if given color is `blue` it will be `blue`,\n   * if given color is `orange.9` it will be `orange`\n   */\n  color: string;\n\n  /**\n   * Resolved color value, for example\n   * if given color is `blue.7` it will be value of `theme.colors.blue[7]`,\n   * if given color is `#fff` it will be `#fff`\n   */\n  value: string;\n\n  /**\n   * If given color is theme color, this will be shade of that color\n   * for example if given color is `blue.7` it will be `7`,\n   * if given color does not have index or is not theme color then it will be `undefined`\n   */\n  shade: MantineColorShade | undefined;\n\n  /**\n   * Color CSS variable, for example\n   * `blue.7` – `--mantine-color-blue-7`,\n   * `red` – `--mantine-color-red-filled`,\n   * `white` – `--mantine-color-white`\n   * `#fff` – `undefined`\n   */\n  variable: CssVariable | undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js Application with create-next-app\nDESCRIPTION: Command usage instructions for creating a new Next.js project with TypeScript support using yarn or npm scripts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/next.mdx#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\nFollow [create-next-app](https://nextjs.org/docs/pages/api-reference/create-next-app) guide to\ncreate new Next.js application:\n\n<NpmScript\n  yarnScript=\"yarn create next-app --typescript\"\n  npmScript=\"npx create-next-app@latest --typescript\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Importing Notifications API Functions Separately in TypeScript (TSX)\nDESCRIPTION: Demonstrates how to import individual notification management functions from '@mantine/notifications' as aliases. This allows for modular usage of notification controlling methods like showing, hiding, updating, and cleaning notifications.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// alias functions\nimport {\n  cleanNotifications, // notifications.clean\n  cleanNotificationsQueue, // notifications.cleanQueue\n  hideNotification, // notifications.hide\n  showNotification, // notifications.show\n  updateNotification, // notifications.update\n  updateNotificationsState, // notifications.updateState\n} from '@mantine/notifications';\n```\n\n----------------------------------------\n\nTITLE: Rendering Custom Bullets in Mantine Timeline Using React in TypeScript\nDESCRIPTION: This example shows how to use React nodes as custom bullets in the Timeline component by passing a custom demo data set. It demonstrates advanced customization of bullet appearance beyond default styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/timeline.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n<Demo data={TimelineDemos.bullet} />\n```\n\n----------------------------------------\n\nTITLE: Initializing Mantine Combobox with useCombobox Hook in TypeScript\nDESCRIPTION: Demonstrates the creation of a Combobox component with state management provided by the useCombobox hook from Mantine. The hook returns a store that holds current state and handlers for the Combobox, and the store is passed to the Combobox component via the store prop. This setup enables flexible control over selection and dropdown behavior.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/combobox.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Combobox, useCombobox } from '@mantine/core';\n\nfunction Demo() {\n  const combobox = useCombobox();\n  return (\n    <Combobox store={combobox}>{/* Your implementation */}</Combobox>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling CSS Variable Deduplication in MantineProvider (TypeScript)\nDESCRIPTION: Shows how to set 'deduplicateCssVariables' to false to force inclusion of all CSS variables regardless of whether their values match the default theme, affecting build and runtime styles.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/theming/mantine-provider.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <MantineProvider deduplicateCssVariables={false}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configure Vite for Sass with Mantine\nDESCRIPTION: Configures Vite to automatically include the `src/_mantine.scss` file's content at the beginning of every Sass file. This allows access to global Sass variables, functions, and mixins defined for Mantine. Requires `sass` and `@vitejs/plugin-react`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/sass.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport path from 'node:path';\nimport react from '@vitejs/plugin-react';\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n  plugins: [react()],\n  css: {\n    preprocessorOptions: {\n      scss: {\n        api: 'modern-compiler',\n        additionalData: `@use \"${path.join(process.cwd(), 'src/_mantine').replace(/\\\\/g, '/')}\" as mantine;`,\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Tree Component Dependencies\nDESCRIPTION: Imports necessary components and data for the page, specifically the `TreeDemos` from '@docs/demos', the `Layout` component, and `MDX_DATA` from '@/mdx'. These imports are essential for setting up the layout and demonstrating the Tree component with various examples.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/tree.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TreeDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Providing usage and API documentation for useIntersection hook\nDESCRIPTION: Provides explanatory text detailing the purpose of useIntersection, usage instructions with code examples, and API parameters including options such as root, rootMargin, and threshold. Clarifies behavior during initial render and SSR conditions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-intersection.mdx#_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n## Usage\n\n`use-intersection` returns information about the intersection\nof a given element with its scroll container or body element with [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API):\n\n<Demo data={HooksDemos.useIntersectionDemo} />\n\n## API\n\nThe hook accepts `IntersectionObserver`'s options as its only optional argument:\n\n```tsx\nimport { useIntersection } from '@mantine/hooks';\n\nuseIntersection({\n  root: document.querySelector('#some-element'),\n  rootMargin: '0rem',\n  threshold: 1.0,\n});\n```\n\nThe hook returns a `ref` function that should be passed to the observed element, and the latest entry, as returned by `IntersectionObserver`'s callback.\nSee [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) documentation to learn everything about options.\n\nOn the first render (as well as during SSR), or when no element is being observed, the entry is `null`.\n\n```tsx\nimport { Paper } from '@mantine/core';\nimport { useIntersection } from '@mantine/hooks';\n\nfunction Demo() {\n  const { ref } = useIntersection();\n\n  return (\n    <>\n      {/* With regular element: */}\n      <div ref={ref} />\n\n      {/* With Mantine component: */}\n      <Paper ref={ref} />\n    </>\n  );\n}\n```\n\n## Definition\n\n```tsx\nfunction useIntersection<T extends HTMLElement = any>(\n  options?: ConstructorParameters<typeof IntersectionObserver>[1]\n): {\n  ref: (element: T | null) => void;\n  entry: IntersectionObserverEntry;\n};\n```\n```\n\n----------------------------------------\n\nTITLE: Handling List Fields in Uncontrolled Forms\nDESCRIPTION: Demonstration of correct and incorrect ways to handle arrays of form fields in uncontrolled mode, using wrapper elements for key management.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/uncontrolled.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\nimport { randomId } from '@mantine/hooks';\n\n// ❌ Incorrect: Do not override key prop, even in lists\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      jobs: [{ company: 'Google' }, { company: 'Facebook' }],\n    },\n  });\n\n  const fields = form.getValues().jobs.map((_, index) => (\n      <input\n        {...form.getInputProps(`jobs.${index}.company`)}\n        key={index}\n      />\n    ));\n\n  return <form>{fields}</form>;\n}\n\n// ✅ Correct: Add wrapper element and pass key to it\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      jobs: [\n        { company: 'Google', key: randomId() },\n        { company: 'Facebook', key: randomId() },\n      ],\n    },\n  });\n\n  const fields = form.getValues().jobs.map((item, index) => (\n      <div key={item.key}>\n        <input\n          {...form.getInputProps(`jobs.${index}.company`)}\n          key={form.key(`jobs.${index}.company`)}\n        />\n      </div>\n    ));\n\n  return <form>{fields}</form>;\n}\n```\n\n----------------------------------------\n\nTITLE: Google Fonts HTML snippet\nDESCRIPTION: The HTML snippet to import Google fonts in the index.html file. It preconnects to Google Fonts API and loads the specified font family (Roboto) with different font weights. It's crucial to include this in the `<head>` section of your HTML document to load the font correctly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/vite-load-fonts.mdx#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin />\n<link\n  href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap\"\n  rel=\"stylesheet\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Using useToggle with Default Boolean State in TSX\nDESCRIPTION: Shows the default behavior of `useToggle` when called without arguments. It manages a boolean state, starting with `false`, and `toggle()` flips the state between `false` and `true`. Requires installation of `@mantine/hooks`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-toggle.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useToggle } from '@mantine/hooks';\n\nconst [value, toggle] = useToggle();\n// -> value === false\ntoggle(); // -> value === true\n```\n\n----------------------------------------\n\nTITLE: Exporting Page Layout with Pill Data\nDESCRIPTION: This line exports the `Layout` component configured with the specific MDX data for the Pill component (`MDX_DATA.Pill`). This setup renders the documentation page content within the defined layout structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/pill.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default Layout(MDX_DATA.Pill);\n```\n\n----------------------------------------\n\nTITLE: Installing @mantine/charts with Yarn/NPM\nDESCRIPTION: Provides the shell commands to install the @mantine/charts package using either the Yarn or NPM package managers. These commands add the package as a dependency to your project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/charts/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/charts\n\n# With npm\nnpm install @mantine/charts\n```\n\n----------------------------------------\n\nTITLE: Creating Default Layout Export with Metadata in JavaScript\nDESCRIPTION: Exports the Layout component as the default export, supplying the meta object as a parameter. This wraps the page content (such as the DropzoneForm demo) within a consistent layout using the provided metadata.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-use-dropzone-with-form.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Rendering Inline Centering Demo (MDX/TSX)\nDESCRIPTION: This snippet provides an example of using the Center component for inline elements by passing the relevant demo data into the Demo component. It demonstrates how to center content such as icons and labels horizontally in a line. Dependencies: React, Mantine, CenterDemos.inline, Demo component. Input: CenterDemos.inline. Output: live interactive demo of inline centering. Limitation: the inline prop effect depends on Demo/CenterDemos configuration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/center.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n<Demo data={CenterDemos.inline} />\n```\n\n----------------------------------------\n\nTITLE: Configuring postcss-preset-mantine After Ejecting Create React App - JavaScript (Webpack/PostCSS)\nDESCRIPTION: This configuration snippet should be placed in postcss.config.js at the project root after ejecting CRA. It defines a plugins object to enable postcss-preset-mantine, postcss-flexbugs-fixes, postcss-preset-env, and postcss-normalize. Dependencies: require ejected CRA, the specified PostCSS plugins, and proper installation via yarn/npm. Input: none; output: PostCSS configured to process Mantine's styles. Prerequisite: ejected CRA with PostCSS loader support.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/can-i-use-mantine-with-cra.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-flexbugs-fixes': {},\n    'postcss-preset-env': {},\n    'postcss-normalize': {},\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Styling Mantine TextInput with Global CSS\nDESCRIPTION: Illustrates applying styles to Mantine components using global CSS selectors targeting specific component parts (e.g., `.mantine-TextInput-root`, `.mantine-TextInput-input`). The example applies margin, background color, and text color using CSS variables. Notes that these styles are not scoped and apply globally.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/third-party-styles.mdx#_snippet_1\n\nLANGUAGE: css\nCODE:\n```\n/* styles.css */\n\n/* Note that these styles are not scoped and\n   will be applied to all TextInput components */\n.mantine-TextInput-root {\n  margin-top: 0.8rem;\n}\n\n.mantine-TextInput-input {\n  background-color: var(--mantine-color-red-filled);\n  color: var(--mantine-color-white);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing CodeHighlight Styles in TypeScript\nDESCRIPTION: Import the necessary CSS styles for the `@mantine/code-highlight` package at the application's root level. This step is required after installation to ensure proper rendering of the code highlighting components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/code-highlight.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/code-highlight/styles.css';\n```\n\n----------------------------------------\n\nTITLE: Controlling Form Submission Event Default with onSubmitPreventDefault - Mantine useForm Hook\nDESCRIPTION: Provides a setup for the useForm hook with the onSubmitPreventDefault configuration option to control whether event.preventDefault is called on form submit. Option values include 'always' (default), 'never', and 'validation-failed'. Useful for integrating useForm with native browser form handling or server actions. Requires @mantine/form.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.15.0.md#_snippet_8\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  onSubmitPreventDefault: 'never',\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Mantine Layout with Metadata in JavaScript\nDESCRIPTION: Defines the metadata object containing page title, description, slug, category, tags, and timestamps. Imports a Layout component from the layout directory and exports a default layout initialized with the metadata. This setup supports Next.js page structure and is intended to organize page content and SEO parameters.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-that-thing-is-done.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'How that thing is done on mantine.dev website?',\n  description: 'Learn how various elements are implemented on mantine.dev website',\n  slug: 'how-that-thing-is-done',\n  category: 'about',\n  tags: ['footer', 'floating button', 'layout'],\n  created_at: 'November 16, 2024',\n  last_updated_at: 'November 16, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Installing @mantinex/dev-icons with npm\nDESCRIPTION: This snippet demonstrates how to install the @mantinex/dev-icons package using npm. The command `npm install @mantinex/dev-icons` downloads and installs the package and its dependencies. The installation modifies the `package.json` and `package-lock.json` files. No specific parameters are used, and the output includes installation progress and any dependency warnings or errors.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantinex/dev-icons/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @mantinex/dev-icons\n```\n\n----------------------------------------\n\nTITLE: Rendering the Demo Component (JSX)\nDESCRIPTION: Renders a generic `Demo` component, passing the imported `ColorSchemeColor` component as data. This is specific to the documentation or framework rendering this content and serves to display the actual color scheme demonstration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-color.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={ColorSchemeColor} />\n```\n\n----------------------------------------\n\nTITLE: Configuring Storybook Addons in main.ts for Webpack and Vite Compatibility\nDESCRIPTION: This code configures Storybook addons in the main.ts configuration file, adding styling-webpack support only for non-Vite environments and including dark mode support. Dependencies include '@storybook/addon-styling-webpack' and 'storybook-dark-mode'. It demonstrates conditional setup based on the build tool used.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/storybook.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { StorybookConfig } from '@storybook/react-vite';\n\nconst config: StorybookConfig = {\n  // ... other config properties\n  addons: [\n    // ... other addons\n    '@storybook/addon-styling-webpack', // Add only if not using Vite\n    'storybook-dark-mode'\n  ],\n};\n\nexport default config;\n```\n\n----------------------------------------\n\nTITLE: Using Demo Data to Render a Component in JSX\nDESCRIPTION: This JSX snippet demonstrates rendering a 'Demo' component with the 'MarkDemos.usage' data as its prop. It showcases data-driven UI rendering, assuming 'Demo' is a React component and 'MarkDemos' provides demo configuration or usage data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/mark.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={MarkDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Export Default Layout with Metadata\nDESCRIPTION: Exports a default React component rendering the Layout component with attached metadata, providing page structure and SEO information.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-setup-stylelint.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const meta = {\n  title: 'How can I lint CSS files?',\n  description: 'Learn how to setup Stylelint for Mantine postcss syntax',\n  slug: 'how-to-setup-stylelint',\n  category: 'tooling',\n  tags: ['stylelint', 'lint', 'postcss'],\n  created_at: 'December 27, 2023',\n  last_updated_at: 'December 27, 2023',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Layout with MDX Data for DateInput Rendering\nDESCRIPTION: This snippet imports necessary components and renders the DateInput within the Layout component by passing MDX data. It establishes the overall page structure for displaying the DateInput component, serving as a base for displaying demos and documentation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { DateInputDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.DateInput);\n```\n\n----------------------------------------\n\nTITLE: Defining Page Metadata with JavaScript for Mantine Layout\nDESCRIPTION: This snippet exports metadata related to a documentation page about Mantine styles and disabled JavaScript. It includes title, description, slug, category, tags, and timestamps, then sets up the layout for the page using a JavaScript import of the Layout component. Dependencies include the Mantine Layout component and a build system that supports ES module syntax. The snippet configures the page's content header and layout structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/disabled-js.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'My styles are broken with disabled JavaScript. What should I do?',\n  description: 'Learn how to use Mantine without JavaScript enabled',\n  slug: 'disabled-js',\n  category: 'styles',\n  tags: ['noscript'],\n  created_at: 'December 7, 2024',\n  last_updated_at: 'December 7, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Exporting a Layout-Wrapped React Component in JavaScript\nDESCRIPTION: Exports a default React component composed by wrapping MDX_DATA.AspectRatio content inside the Layout component. This structure integrates page layout with MDX-provided documentation and demos, enabling render of the AspectRatio documentation page with consistent site styling.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/aspect-ratio.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.AspectRatio);\n```\n\n----------------------------------------\n\nTITLE: Rendering Layout with MDX Data - React\nDESCRIPTION: This snippet exports a default function that renders the Layout component. It passes the MDX data for the Blockquote component to the Layout component for proper rendering and display. The Layout component handles the overall structure, while MDX data provides the specific content for the Blockquote section.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/blockquote.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.Blockquote);\n```\n\n----------------------------------------\n\nTITLE: Importing React Components and Data Modules in JavaScript\nDESCRIPTION: This snippet imports necessary modules and components including form demos, a layout component, and MDX data for use inside the file. These imports set up the required context for rendering form demonstrations within a consistent layout. Key dependencies are '@docs/demos', '@/layout', and '@/mdx'.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/recipes.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { FormDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Installing @mantine/emotion package with yarn and npm\nDESCRIPTION: Commands to install the @mantine/emotion package using either yarn or npm package managers. This package provides Emotion CSS-in-JS bindings for Mantine Core components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/emotion/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/emotion\n\n# With npm\nnpm install @mantine/emotion\n```\n\n----------------------------------------\n\nTITLE: Rendering InputMask Demo Component in React\nDESCRIPTION: Demonstrates the usage of a custom `Demo` component, passing the imported `InputMask` component as data. This renders the example showcasing the integration of 'react-imask' with Mantine's `InputBase` for input masking.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/input-mask.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={InputMask} />\n```\n\n----------------------------------------\n\nTITLE: Migration to react-number-format in NumberInput Component\nDESCRIPTION: Indicates that NumberInput now relies on react-number-format, supporting more features and cursor management enhancements. Some props have been renamed; developers should consult the documentation for migration details.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_12\n\n\n\n----------------------------------------\n\nTITLE: Rendering Overlay Usage Demo in Mantine React - JSX\nDESCRIPTION: This snippet embeds a live usage demo of the Overlay component by rendering the Demo React component. It passes the demo configuration stored in `OverlayDemos.usage` as the `data` prop, enabling hands-on experimentation of the Overlay in a documentation context. Requires Mantine's Demo and OverlayDemos components to be available, with `data` controlling the demo’s implementation details. Input is the demo data; output is the rendered interactive demonstration.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/overlay.mdx#_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={OverlayDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Markdown Header with VersionsList Component Rendering\nDESCRIPTION: Combines Markdown content with a JSX component. It displays an 'All releases' heading followed by the VersionsList component that will render the actual list of versions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/previous-versions.mdx#_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n# All releases\n\n<VersionsList />\n```\n\n----------------------------------------\n\nTITLE: Starting Vite Development Server\nDESCRIPTION: Command to start the Vite development server after setting up the Mantine integration. This launches the application in development mode with hot module replacement.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/vite.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Rendering Alert Demos and Styles API Selectors in React\nDESCRIPTION: This snippet includes demo components that display Alert configurator options and style API selectors. It helps visualize the customization and styling APIs of the Alert component in a React app.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/alert.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={AlertDemos.configurator} />\n\n<StylesApiSelectors component=\"Alert\" />\n\n<Demo data={AlertDemos.stylesApi} />\n```\n\n----------------------------------------\n\nTITLE: Improved ESM Support for Mantine Packages\nDESCRIPTION: Highlights the migration of Mantine packages to ESM modules with '.mjs' extensions, facilitating usage with 'type: module' in package.json, supporting modern build systems, and enhancing compatibility with frameworks like Remix v2.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.1.0.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Disabling Browser Zooming Using Meta Viewport Tag - HTML\nDESCRIPTION: Illustrates how to disable browser scaling globally by adding a meta viewport tag to the HTML document head. The tag sets minimum-scale and initial-scale to 1 and specifies user-scalable=no to prevent zooming altogether. This approach affects the entire application and can have accessibility drawbacks by disabling users' ability to zoom. It should be added inside the <head> section of the HTML document.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/browser-zooms-on-focus.mdx#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<meta\n  name=\"viewport\"\n  content=\"minimum-scale=1, initial-scale=1, width=device-width, user-scalable=no\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Mantine List Page\nDESCRIPTION: Imports necessary modules for the documentation page: `ListDemos` containing demonstration components for the List element, the shared `Layout` component for page structure, and `MDX_DATA` likely holding page content or metadata.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/list.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ListDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Displaying BackgroundImage Usage Demo in JSX\nDESCRIPTION: Renders the usage demo for the BackgroundImage component using the Demo component with data from BackgroundImageDemos.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/background-image.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={BackgroundImageDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Importing useScrollSpy Hook and Dependencies\nDESCRIPTION: This code imports the necessary components and dependencies for using the `useScrollSpy` hook. It imports `HooksDemos` for examples, `Layout` for page layout, and `MDX_DATA` for MDX data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-scroll-spy.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { HooksDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Rendering HoverCard Target Component Example (JSX)\nDESCRIPTION: Renders a specific `TargetComponent`, configured via the `component` prop to relate to the `HoverCard`. This likely serves as a placeholder or example target element for documentation purposes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/hover-card.mdx#_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\n<TargetComponent component=\"HoverCard\" />\n```\n\n----------------------------------------\n\nTITLE: Starting Gatsby Development Server using npm\nDESCRIPTION: Runs Gatsby's development server enabling live development and previewing of the application. This bash command requires a properly set up Gatsby project with dependencies installed. It is executed in the terminal within the project directory.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/gatsby.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run develop\n```\n\n----------------------------------------\n\nTITLE: Compiled CSS Output for Global Selector Usage (CSS)\nDESCRIPTION: Shows the resulting compiled CSS generated when using the `:global()` selector as shown in the previous SCSS example. The locally scoped class (`.test`) receives its unique name (e.g., `.m-dj3w33`), while the globally referenced class name (`.global-class-name`) remains unchanged and unscoped.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-modules.mdx#_snippet_5\n\nLANGUAGE: css\nCODE:\n```\n.m-dj3w33 .global-class-name {\n  color: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @mantine/modals with Yarn/NPM\nDESCRIPTION: Provides shell commands to install the @mantine/modals package and its required dependencies (@mantine/hooks, @mantine/core) using either the yarn or npm package manager. Choose the command appropriate for your project's package manager.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/modals/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/hooks @mantine/core @mantine/modals\n\n# With npm\nnpm install @mantine/hooks @mantine/core @mantine/modals\n```\n\n----------------------------------------\n\nTITLE: Rendering Radial Bar Chart with Layout (JavaScript)\nDESCRIPTION: This snippet renders the radial bar chart component using the imported `Layout` component and the `MDX_DATA.RadialBarChart` data. The `Layout` component is likely responsible for providing the overall structure and styling of the page. The MDX data provides context for the chart.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/radial-bar-chart.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.RadialBarChart);\n```\n\n----------------------------------------\n\nTITLE: Exporting Default Page Component - JavaScript/TypeScript\nDESCRIPTION: Exports the default component for this page. It wraps the page content within the `Layout` component, passing the previously defined `meta` object as a prop to configure the layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/floating-action-button.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Rendering Usage Example of DatePickerInput with Demo Component in JSX\nDESCRIPTION: Demonstrates rendering a usage demo for DatePickerInput by passing the corresponding demo data (`DatePickerInputDemos.usage`) to a generic `Demo` component. This allows the display of example usage code and interactive examples on the documentation page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={DatePickerInputDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Exporting Default Layout Component Configured with Form Recipe Data in JavaScript\nDESCRIPTION: This snippet exports a default component by applying a layout function to form-related MDX data. It wraps the form recipe content inside a consistent page layout, facilitating the structured presentation of form demonstrations. The key input is 'MDX_DATA.formRecipes', supplying form recipe content for rendering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/recipes.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport default Layout(MDX_DATA.formRecipes);\n```\n\n----------------------------------------\n\nTITLE: Rendering UnstyledButton Usage Demo\nDESCRIPTION: Renders a demo component showcasing the usage of the UnstyledButton component with example implementations.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/unstyled-button.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<Demo data={UnstyledButtonDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Importing Meta Data and Exporting Layout in TypeScript\nDESCRIPTION: This snippet defines metadata for a documentation page related to carousel styling issues, including title, description, tags, and timestamps, then exports a layout component passing this metadata. It sets up the contextual information for a documentation or help page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/carousel-missing-styles.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'Why my Carousel slides are in vertical orientation?',\n  description: 'You forgot to import carousel styles',\n  slug: 'carousel-missing-styles',\n  category: 'styles',\n  tags: ['carousel', '@mantine/carousel', 'broken'],\n  created_at: 'September 7, 2024',\n  last_updated_at: 'September 7, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Importing Layout and MDX Data and Exporting as Default in a Mantine/Storybook Setup\nDESCRIPTION: This snippet imports the Layout component and MDX data, then exports a default component that wraps MDX data with Layout, intended for use as the main story entry point in Storybook. It forms the basis for rendering stories with Mantine layout components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/storybook.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Storybook);\n```\n\n----------------------------------------\n\nTITLE: Usage Example for Fieldset Component with Demo Data\nDESCRIPTION: Shows how to render a demo of the fieldset component with specific usage data, illustrating how the component can be utilized within the interface. It relies on the imported demo data to visualize the component's functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/fieldset.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={FieldsetDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Exporting Metadata Object in JavaScript\nDESCRIPTION: Defines and exports a metadata object that contains descriptive information about the FAQ page, including title, description, slug, category, tags, and timestamps. This metadata is intended to be used in rendering the page layout and providing indexing information.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/vue-svelte-angular.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const meta = {\n  title: 'Can I use Mantine with Vue/Svelte/Angular/etc.?',\n  description: 'No, Mantine is a React library and does not support other frameworks/libraries',\n  slug: 'vue-svelte-angular',\n  category: 'about',\n  tags: [\n    'vue',\n    'svelte',\n    'angular',\n    'react',\n    'qwik',\n    'solid',\n    'preact',\n  ],\n  created_at: 'March 15, 2024',\n  last_updated_at: 'March 15, 2024',\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Redirect Component in TypeScript\nDESCRIPTION: Imports the `Redirect` component from a specified internal path. This component is required to perform client-side navigation using the `<Redirect>` tag.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/others/modals.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Redirect } from '@/components/Redirect';\n```\n\n----------------------------------------\n\nTITLE: Rendering CopyButton Component with Layout in React\nDESCRIPTION: This snippet renders the `CopyButton` component within a layout. It calls the `Layout` function, passing `MDX_DATA.CopyButton` as an argument to configure the page's content based on the data associated with the `CopyButton` component. This is the core of the page, which structures and sets up the display of information related to the copy button and its associated functionality.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/copy-button.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.CopyButton);\n```\n\n----------------------------------------\n\nTITLE: Exporting UnstyledButton Documentation Page\nDESCRIPTION: Exports the documentation page for the UnstyledButton component using the Layout higher-order component and MDX data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/unstyled-button.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.UnstyledButton);\n```\n\n----------------------------------------\n\nTITLE: Importing Components and Data in Mantine Project\nDESCRIPTION: This snippet imports the 'MarkDemos' from the documentation demos, the 'Layout' component from the layout directory, and 'MDX_DATA' from the MDX module. These imports set up dependencies for rendering documentation pages with layout and content data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/mark.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { MarkDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Explanation of MultiSelect Placeholder Behavior\nDESCRIPTION: Describes the purpose of the MultiSelect placeholder, noting that it indicates available selection options, and contrasts it with the Select component where the placeholder disappears upon selection. No code snippets provided.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/multiselect-value-placeholder.mdx#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Importing Mantine Demo Components and Layout - JavaScript\nDESCRIPTION: Imports demo components 'AutocompleteCity' and 'SelectCountry' from the demos folder and a general 'Layout' component used to render the page layout. These imports are required to demonstrate usage examples of Mantine's Select and Autocomplete components within the page layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/select-autocomplete-difference.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { AutocompleteCity } from '@/demos/AutocompleteCity.demo';\nimport { SelectCountry } from '@/demos/SelectCountry.demo';\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Importing React Components and Data in JavaScript\nDESCRIPTION: Imports necessary React components and data for the AspectRatio demos: AspectRatioDemos (example datasets), Layout (page wrapper), and MDX_DATA (content source). These imports are required to structure and populate the demo page dynamically using Mantine's component architecture.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/aspect-ratio.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { AspectRatioDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Importing Demo and Layout Components in Mantine\nDESCRIPTION: Imports the MultiSelect placeholder demo component and the layout component to structure documentation content within the project. Sets meta information describing the purpose and categorization of the page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/multiselect-value-placeholder.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { MultiSelectPlaceholderDemo } from '@/demos/MultiSelectPlaceholder.demo';\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies in Mantine UI\nDESCRIPTION: This snippet imports necessary modules and components from the `@docs/demos` and `@/layout` paths, along with data from `@/mdx`. This setup prepares the environment for rendering the ActionIcon demos within a layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/action-icon.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { ActionIconDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Importing and Setting Up ScrollArea Component\nDESCRIPTION: Demonstrates how to import the necessary components and set up the ScrollArea documentation page layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/scroll-area.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { ScrollAreaDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.ScrollArea);\n```\n\n----------------------------------------\n\nTITLE: Exporting Default Layout with ActionIcon Data\nDESCRIPTION: This code exports the default layout, passing the `MDX_DATA.ActionIcon` object as a prop. This sets up the layout for the ActionIcon component's documentation and demos, integrating it within the application's structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/action-icon.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default Layout(MDX_DATA.ActionIcon);\n```\n\n----------------------------------------\n\nTITLE: Exporting Kbd Component Layout in React - JavaScript/JSX\nDESCRIPTION: This snippet imports demo components, a layout utility, and Markdown-driven component metadata, then exports a page by applying the Layout function to the Kbd documentation data. It also includes a section for rendering usage demos using the Demo component and associated data. Dependencies include the project-specific Layout, MDX_DATA, and demo components; expected input is the correct structure and presence of Markdown data for the Kbd component. The output is a rendered documentation page within a React application. Limitations include requirement for properly structured demo and layout components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/kbd.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { KbdDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Kbd);\n```\n\nLANGUAGE: JSX\nCODE:\n```\n## Usage\n\n<Demo data={KbdDemos.usage} />\n```\n\n----------------------------------------\n\nTITLE: Meta information about PostCSS functions in Mantine\nDESCRIPTION: Defines metadata including title, description, tags, and timestamps for the documentation page, which aids in categorization and searchability.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/postcss-fns-inline.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'Can I use PostCSS function in inline styles?',\n  description: 'Learn where PostCSS functions can be used in Mantine',\n  slug: 'postcss-fns-inline',\n  category: 'styles',\n  tags: ['postcss', 'light-dark', 'mixin'],\n  created_at: 'September 7, 2024',\n  last_updated_at: 'September 7, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Import MDX Data\nDESCRIPTION: Imports the `MDX_DATA` object from the '@/mdx' module. This likely contains data used for rendering the MDX content of the page, specifically data related to the Paper component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/paper.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MDX_DATA } from '@/mdx';\n```\n\n----------------------------------------\n\nTITLE: Exporting React Layout with MDX Data\nDESCRIPTION: This snippet exports the default layout using the `Layout` component, passing `MDX_DATA.Changelog790` as props.  The layout likely displays the content of the changelog, structured with the imported layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-9-0.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default Layout(MDX_DATA.Changelog790);\n```\n\n----------------------------------------\n\nTITLE: Exporting Layout for useField TypeScript\nDESCRIPTION: This snippet exports a default Layout component with the data for the useField hook. This will handle the overall structure and presentation of the use-field documentation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-field.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport default Layout(MDX_DATA.useField);\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Export with Layout Component in React\nDESCRIPTION: Sets up the default export for the page by wrapping MDX_DATA.PreviousChangelogs with the Layout component. This creates the structure for the changelogs page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/previous-versions.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.PreviousChangelogs);\n```\n\n----------------------------------------\n\nTITLE: Metadata Definition for Documentation Page - JavaScript\nDESCRIPTION: Defines a metadata object describing the page title, description, slug, category, tags, and creation dates. This metadata provides information for the documentation site's organization and navigation and is passed to the Layout component to build the rendered page.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/select-autocomplete-difference.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const meta = {\n  title:\n    'What is the difference between searchable Select and Autocomplete?',\n  description:\n    'Searchable Select and Autocomplete are similar components, but they serve different purposes.',\n  slug: 'select-autocomplete-difference',\n  category: 'components',\n  tags: ['select', 'autocomplete', 'searchable', 'combobox'],\n  created_at: 'December 26, 2023',\n  last_updated_at: 'December 26, 2023',\n};\n```\n\n----------------------------------------\n\nTITLE: Select component with aria-label on clear button\nDESCRIPTION: This example demonstrates how to set `aria-label` on the clear button for accessibility purposes using the `clearButtonProps` prop. This is necessary when the `clearable` prop is set.  It is important for screen readers.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/select.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Select } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Select\n      data={[]}\n      clearable\n      clearButtonProps={{\n        'aria-label': 'Clear input',\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Uploading Files from Mantine Dropzone to AWS S3 with React and Axios (TSX)\nDESCRIPTION: This TypeScript React snippet demonstrates uploading a file dropped into the Mantine Dropzone component to an AWS S3 bucket using the Axios HTTP client. It manages the loading state to provide user feedback, triggers notifications upon success or failure of the upload, and uses the Dropzone component's onDrop event to call the upload handler. The snippet requires Mantine Dropzone, Axios, Mantine notifications, and React hooks. Input is a File object obtained from the Dropzone, and no output is returned from the UI component apart from visual state and notifications.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/dropzone-upload.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport axios from 'axios';\nimport { useState } from 'react';\nimport { Dropzone } from '@mantine/dropzone';\nimport { notifications } from '@mantine/notifications';\n\nfunction Demo() {\n  const [loading, setLoading] = useState(false);\n\n  const handleUpload = (file: File) => {\n    setLoading(true);\n\n    axios\n      .put('https://your-bucket.s3.amazonaws.com', file)\n      .then(() => {\n        notifications.showNotification({\n          title: 'File uploaded',\n          message: 'File uploaded successfully',\n          color: 'teal',\n        });\n      })\n      .catch((error) => {\n        notifications.showNotification({\n          title: 'File upload failed',\n          message: error.message,\n          color: 'red',\n        });\n      })\n      .finally(() => setLoading(false));\n  };\n\n  return (\n    <Dropzone onDrop={(files) => handleUpload(files[0])} loading={loading}>\n      {loading ? 'Uploading file...' : 'Drop file here'}\n    </Dropzone>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting the fixed elements\nDESCRIPTION: Adjusting the fixed elements. This snippet applies CSS class names to elements to handle positioning when using react-remove-scroll for modal components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/modal.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { RemoveScroll } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <div className={RemoveScroll.classNames.fullWidth}>\n        width: 100%\n      </div>\n      <div className={RemoveScroll.classNames.zeroRight}>\n        right: 0\n      </div>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Polymorphic Component Props in TypeScript\nDESCRIPTION: Shows how to extend props of polymorphic Mantine components using ElementProps utility type to handle component prop conflicts.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/typescript.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Button, ButtonProps, ElementProps } from '@mantine/core';\n\ninterface MyButtonProps\n  extends ButtonProps,\n    ElementProps<'button', keyof ButtonProps> {\n  height: number;\n}\n\nfunction MyButton({ height, ...others }: MyButtonProps) {\n  return <Button style={{ height }} {...others} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Fixed AppShell Main Padding in React (TSX)\nDESCRIPTION: Shows how to apply a fixed padding to the `AppShell.Main` area using the `padding` prop on the root `AppShell` component. This example uses a Mantine theme spacing token (`'md'`). Using this prop ensures correct offset calculations for fixed elements like Header or Navbar. Requires `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/app-shell.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { AppShell } from '@mantine/core';\n\n// Padding is always theme.spacing.md\nfunction Demo() {\n  return <AppShell padding=\"md\">{/* AppShell content */}</AppShell>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Exporting Metadata for a Mantine Layout\nDESCRIPTION: This snippet imports the Layout component and exports meta information including title, description, slug, category, tags, and timestamps to configure page properties and SEO data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/polymorphic-in-polymorphic.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title:\n    'Why I cannot use one polymorphic component in component prop of another polymorphic component?',\n  description: 'Learn how polymorphic components types work',\n  slug: 'polymorphic-in-polymorphic',\n  category: 'components',\n  tags: ['component', 'renderRoot'],\n  created_at: 'July 25, 2024',\n  last_updated_at: 'July 25, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Defining Font Family Variables in Theme using TypeScript\nDESCRIPTION: Illustrates how to set font family variables globally in Mantine theme configuration, affecting CSS variables used throughout components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  // Controls --mantine-font-family\n  fontFamily: 'Arial, sans-serif',\n\n  // Controls --mantine-font-family-monospace\n  fontFamilyMonospace: 'Courier New, monospace',\n\n  headings: {\n    // Controls --mantine-font-family-headings\n    fontFamily: 'Georgia, serif',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using React Nodes as Errors – Mantine\nDESCRIPTION: Demonstrates how to use any React node as an error message. This provides flexibility in styling and displaying error messages.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/errors.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: { name: '', email: '' },\n  initialErrors: {\n    name: <p>Paragraph error</p>, // -> error as a react element\n    email: 42, // -> error as a number\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Throttled State with Mantine's useThrottledState Hook (TSX)\nDESCRIPTION: Shows how to manage an input field's value with throttling using useThrottledState from @mantine/hooks. The throttled state ensures that updates occur at most once per 1000ms, regardless of fast input changes. Requires @mantine/core and Mantine hooks; the controlled value is displayed live in a Text component, and input is from a TextInput element. No external data fetching occurs.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.8.0.md#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Text, TextInput } from '@mantine/core';\nimport { useThrottledState } from '@mantine/hooks';\n\nfunction Demo() {\n  const [throttledValue, setThrottledValue] = useThrottledState('', 1000);\n\n  return (\n    <>\n      <TextInput\n        placeholder=\"Search\"\n        onChange={(event) => setThrottledValue(event.currentTarget.value)}\n      />\n      <Text>Throttled value: {throttledValue || '–'}</Text>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Mod Prop with Box in TypeScript\nDESCRIPTION: This code showcases several examples of using the `mod` prop on a `Box` component in Mantine.  The `mod` prop allows adding data attributes to the root element of the component. The examples demonstrate using string values, boolean values, arrays of strings and objects, and object key-value pairs for setting data attributes.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/data-attributes.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from '@mantine/core';\n\n<Box mod=\"data-button\" />;\n// -> <div data-button />\n\n<Box mod={{ opened: true }} />;\n// -> <div data-opened />\n\n<Box mod={{ opened: false }} />;\n// -> <div />\n\n<Box mod={['button', { opened: true }]} />;\n// -> <div data-button data-opened />\n\n<Box mod={{ orientation: 'horizontal' }} />;\n// -> <div data-orientation=\"horizontal\" />\n```\n\n----------------------------------------\n\nTITLE: Using PostCSS Preset Mantine\nDESCRIPTION: This code demonstrates the use of postcss-preset-mantine in a CSS file. It showcases functionalities like converting pixels to rem, em for media queries, light/dark mixins for color scheme adaptation, light-dark function for inline color scheme shortcuts, and rtl mixin for right-to-left direction support. This simplifies and enhances CSS styling within a Mantine project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_7\n\nLANGUAGE: scss\nCODE:\n```\n.demo {\n  padding: rem(20px); /* Convert px to rem */\n\n  /* Convert px to em (for media queries) */\n  @media (max-width: em(500px)) {\n  }\n\n  /* light and dark mixins to apply styles based on Mantine color scheme */\n  @mixin light {\n    background-color: var(--mantine-color-white);\n  }\n\n  @mixin dark {\n    background-color: var(--mantine-color-black);\n  }\n\n  /* light-dark function as an inline shortcut for light and dark mixins */\n  background: light-dark(\n    var(--mantine-color-white),\n    var(--mantine-color-black)\n  );\n\n  /* rtl mixin to apply styles for right-to-left direction */\n  padding-left: 1rem;\n  @mixin rtl {\n    padding-left: 0;\n    padding-right: 1rem;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Testing Utilities from Central File in TSX\nDESCRIPTION: Shows how to create a central index file (`./testing-utils/index.ts`) to re-export testing utilities from `@testing-library/react`, `@testing-library/user-event`, and the custom `render` function. This approach simplifies imports in individual test files.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/guides/jest.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport userEvent from '@testing-library/user-event';\n\nexport * from '@testing-library/react';\nexport { render } from './render';\nexport { userEvent };\n```\n\n----------------------------------------\n\nTITLE: Styling with CSS Modules in Mantine\nDESCRIPTION: This example shows how to style Mantine components using CSS modules. First, create a CSS module file (e.g., `Button.module.css`) and define your styles. Then, import the CSS module into your component and apply the styles using the `className` prop.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/overview.mdx#_snippet_5\n\nLANGUAGE: css\nCODE:\n```\n/* Button.module.css */\n.button {\n  color: red;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Color Lightness with isLightColor in Mantine Core (TSX)\nDESCRIPTION: Example using the `isLightColor` function to determine if a given color string represents a light color. This is primarily used to dynamically set a contrasting text color ('black' or 'white') against a variable background color (`bg`) for better readability.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/color-functions.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, isLightColor } from '@mantine/core';\n\ninterface DemoProps {\n  color: string;\n}\n\nexport function Demo({ color }: DemoProps) {\n  return (\n    <Box bg={color} c={isLightColor(color) ? 'black' : 'white'}>\n      Box with contrast text\n    </Box>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Supported and Unsupported Types for useSetState (TypeScript/TSX)\nDESCRIPTION: This snippet demonstrates proper and improper usage of the useSetState hook, highlighting that only objects are supported as the initial state. Attempts to use arrays or primitive values as the initial state will fail, while using objects—including objects with array properties—is valid. Requires @mantine/hooks and TypeScript; input must be an object or the hook will not function.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-set-state.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useSetState } from '@mantine/hooks';\n\nuseSetState([1, 2, 3]); // -> will not work\nuseSetState(1); // -> will not work\nuseSetState({ skills: ['JavaScript', 'TypeScript'] }); // -> works fine\n```\n\n----------------------------------------\n\nTITLE: Configuring RTL Support with DirectionProvider and useDirection Hook in @mantine/core\nDESCRIPTION: Shows how to enable right-to-left layout support by wrapping the app with DirectionProvider and toggling direction with useDirection hook. All components now include RTL styles by default, simplifying internationalization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/changelog/7-0-0.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { DirectionProvider, useDirection } from '@mantine/core';\n\nfunction App() {\n  const [direction, toggleDirection] = useDirection();\n\n  return (\n    <DirectionProvider value={direction}>\n      {/* app components */}\n      <button onClick={() => toggleDirection()}>Toggle Direction</button>\n    </DirectionProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Package with Yarn (Bash)\nDESCRIPTION: This shell command demonstrates how to install the package (represented by the `{{package}}` placeholder) using the Yarn package manager. It adds the package as a dependency to the current project.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/scripts/plop/templates/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add {{package}}\n```\n\n----------------------------------------\n\nTITLE: Selective Validation on Blur for Specific Fields with Mantine useForm in TypeScript\nDESCRIPTION: Allows validation only on specific fields when they lose focus by assigning an array of field paths to validateInputOnBlur. Supports nested fields using the FORM_INDEX constant. Improves user experience by limiting validation to relevant fields only. Depends on '@mantine/form' and FORM_INDEX. Inputs: form settings and field paths; output: form object configured for selective blur validation.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/validation.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { FORM_INDEX, useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  validateInputOnBlur: ['name', 'email', `jobs.${FORM_INDEX}.title`],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Mantine Spotlight package with package managers\nDESCRIPTION: Commands to install the Mantine Spotlight package and its dependencies using either yarn or npm package managers. The installation requires @mantine/spotlight along with core dependencies @mantine/core and @mantine/hooks.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/packages/@mantine/spotlight/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# With yarn\nyarn add @mantine/spotlight @mantine/core @mantine/hooks\n\n# With npm\nnpm install @mantine/spotlight @mantine/core @mantine/hooks\n```\n\n----------------------------------------\n\nTITLE: Defining Page Metadata - JavaScript/TypeScript\nDESCRIPTION: Defines an exported constant `meta` which is an object containing metadata for the documentation page. This information is used by the layout component for setting the page title, description, slug, category, tags, and timestamps.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/floating-action-button.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport const meta = {\n  title: 'Is there a floating action button component?',\n  description:\n    'No, but you can build it with Affix and ActionIcon components',\n  slug: 'floating-action-button',\n  category: 'components',\n  tags: ['fab', 'component'],\n  created_at: 'January 17, 2024',\n  last_updated_at: 'January 17, 2024',\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Min and Max Date Limits in DateInput\nDESCRIPTION: This snippet demonstrates configuring the `minDate` and `maxDate` props to restrict selectable date ranges. Dates outside the specified limits are rejected and revert to the last valid value, ensuring data validity.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-input.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={DateInputDemos.minMax} />\n```\n\n----------------------------------------\n\nTITLE: Running ncu Command for Mantine Updates\nDESCRIPTION: Uses the globally installed ncu command to update Mantine-related packages in package.json.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-to-update-dependencies.mdx#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nncu @mantine/* @mantinex/* postcss-preset-mantine -u\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Mantine Component Styles in React with TypeScript\nDESCRIPTION: Shows how to import CSS styles for individual Mantine components within a TypeScript React application. Dependencies include @mantine/core and understanding any inter-component dependencies such as UnstyledButton for Button. Only the styles for the specified components will be included, reducing bundle size. Multiple import statements can be used to target the required components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/mantine-styles.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport '@mantine/core/styles/UnstyledButton.css';\nimport '@mantine/core/styles/Button.css';\n```\n\n----------------------------------------\n\nTITLE: Importing Components and Demo Data - JavaScript/TypeScript\nDESCRIPTION: Imports necessary components and demo data for the page. `FloatingActionButtonDemo` contains the example code for the FAB, and `Layout` is likely used to wrap the page content with a standard layout structure.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/floating-action-button.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { FloatingActionButtonDemo } from '@/demos/FloatingActionButton.demo';\nimport { Layout } from '@/layout';\n```\n\n----------------------------------------\n\nTITLE: Setting up NavigationProgress – TSX\nDESCRIPTION: Demonstrates how to render the NavigationProgress component within a Mantine application.  It requires wrapping the component with the MantineProvider. No specific parameters are required for basic usage, and it provides visual feedback on navigation progress.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/nprogress.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { MantineProvider } from '@mantine/core';\nimport { NavigationProgress } from '@mantine/nprogress';\n\nfunction Demo() {\n  return (\n    <MantineProvider>\n      <NavigationProgress />\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Setting Up BackgroundImage Documentation Page in React\nDESCRIPTION: Imports necessary components and data for rendering the BackgroundImage documentation page. The file sets up the page structure using the Layout component and MDX data.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/background-image.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { BackgroundImageDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.BackgroundImage);\n```\n\n----------------------------------------\n\nTITLE: Referencing Z-Index - Mantine Component - TSX\nDESCRIPTION: Illustrates how to apply a Mantine predefined z-index CSS variable, such as `--mantine-z-index-max`, directly to a component prop that controls z-index. This example uses the `zIndex` prop of the Mantine `Modal` component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/css-variables.mdx#_snippet_24\n\nLANGUAGE: TSX\nCODE:\n```\nimport { Modal } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Modal\n      zIndex=\"var(--mantine-z-index-max)\"\n      opened\n      onClose={() => {}}\n    >\n      Modal content\n    </Modal>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Close Timeout for Notifications Globally and Per Notification (TSX)\nDESCRIPTION: Shows how to globally set auto close timeout for all notifications by passing autoClose prop to Notifications component and how to override auto close timeout or disable it per notification when calling notifications.show or notifications.update. The per-notification autoClose value takes precedence over the global setting.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/notifications.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Notifications } from '@mantine/notifications';\n\n// All notifications will be closed automatically in 4000ms\nfunction Demo() {\n  return <Notifications autoClose={4000} />;\n}\n\nimport { notifications } from '@mantine/notifications';\n\nnotifications.show({\n  message: 'I will close in 500ms seconds',\n  autoClose: 500,\n});\n\nnotifications.update({\n  id: 'hello',\n  message: 'I will never close',\n  autoClose: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering HoverCard Delay Configuration Demo (JSX)\nDESCRIPTION: Renders a `Demo` component showcasing how to configure open and close delays using the `openDelay` and `closeDelay` props on a HoverCard. The example data is provided by `HoverCardDemos.delay`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/hover-card.mdx#_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={HoverCardDemos.delay} />\n```\n\n----------------------------------------\n\nTITLE: Defining useEyeDropper Hook Signature - Typescript\nDESCRIPTION: This snippet defines the TypeScript signature for the `useEyeDropper` hook. It shows the hook returns an object indicating API support (`supported`) and an `open` function to activate the eye dropper. The `open` function returns a Promise that resolves to the selected color in sRGB hex format when successful.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-eye-dropper.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useEyeDropper(): {\n  supported: boolean;\n  open: (options?: {\n    signal?: AbortSignal;\n  }) => Promise<{ sRGBHex: string }>;\n};\n```\n\n----------------------------------------\n\nTITLE: Increasing Mantine TextInput Size to Prevent Browser Zooming - TypeScript/React\nDESCRIPTION: Demonstrates how to mitigate browser zoom when focusing on inputs by increasing the Mantine TextInput component's size property from the default small size to medium. This example imports the TextInput component from Mantine core and uses JSX to render it with size=\"md\", which increases the font size and input height. The snippet requires a working React environment with @mantine/core installed and is intended to be used within React functional components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/browser-zooms-on-focus.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return <TextInput size=\"md\" />;\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Inputs with Mantine Fieldset Component (TSX)\nDESCRIPTION: Introduces the new Mantine Fieldset component. This example shows how to group related input elements (like TextInput) under a common legend, improving form structure and accessibility. Requires `@mantine/core` (assuming TextInput is also imported).\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Fieldset } from '@mantine/core';\n// Assuming TextInput is also imported from '@mantine/core'\n// import { TextInput } from '@mantine/core'; \n\nfunction Demo() {\n  return (\n    <Fieldset legend=\"Personal information\">\n      {/* <TextInput label=\"Your name\" placeholder=\"Your name\" /> */}\n      {/* <TextInput label=\"Email\" placeholder=\"Email\" mt=\"md\" /> */}\n    </Fieldset>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Overlay Blur Demo in Mantine React - JSX\nDESCRIPTION: This snippet renders an interactive demonstration of the Overlay with the `blur` prop applied, showcasing backdrop-filter support. It passes overlay blur configuration from the `OverlayDemos.blur` demo object to the Demo component. Requires corresponding demo data and React setup. Can be used to observe browser support and visual effects for the blur-related customization.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/overlay.mdx#_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n<Demo data={OverlayDemos.blur} />\n```\n\n----------------------------------------\n\nTITLE: Exporting Layout Wrapped DatePickerInput MDX Content in JavaScript\nDESCRIPTION: Exports a React component that wraps the prebuilt DatePickerInput MDX documentation content inside a layout component to provide consistent page structure and styling. This setup enables modular documentation rendering.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/dates/date-picker-input.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default Layout(MDX_DATA.DatePickerInput);\n```\n\n----------------------------------------\n\nTITLE: Updating Initial Values after Form Initialization\nDESCRIPTION: Shows how to update initialValues after form was initialized using the setInitialValues handler. These values will be used in form.reset and to compare values to get dirty state.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/values.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useEffect } from 'react';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      name: '',\n      email: '',\n    },\n  });\n\n  useEffect(() => {\n    fetch('/api/user')\n      .then((res) => res.json())\n      .then((data) => {\n        // Update initial values after form was initialized\n        // These values will be used in form.reset\n        // and to compare values to get dirty state\n        form.setInitialValues(data);\n        form.setValues(data);\n      });\n  }, []);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Mantine Dropzone Styles (TSX)\nDESCRIPTION: Shows how to import the necessary CSS styles for the Mantine Dropzone component. This import should typically be placed at the root level of your application to ensure the component is styled correctly.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/x/dropzone.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport '@mantine/dropzone/styles.css';\n\n```\n\n----------------------------------------\n\nTITLE: Understanding hydration warnings and their implications\nDESCRIPTION: Clarifies that the hydration warning in this context is expected and not indicative of a bug, as the attribute 'data-mantine-color-scheme' is intentionally modified before hydration to avoid visual flash issues.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/color-scheme-hydration-warning.mdx#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Using compound components in a server component without 'use client'\nDESCRIPTION: This snippet shows an incorrect attempt to use Mantine's compound components (e.g., `<Popover.Target>`) in a server component, resulting in module resolution errors. The fix involves adding `'use client'` or replacing with regular components.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/server-components.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ❌ This will throw an error\nimport { Popover } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Popover>\n      <Popover.Target>\n        <button>Toggle popover</button>\n      </Popover.Target>\n    </Popover>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Enter/Exit Delays to Mantine Transitions (TSX)\nDESCRIPTION: Demonstrates delaying the start of enter and exit animations using the `enterDelay` and `exitDelay` props on the `Transition` component. The example uses a 'pop' transition triggered by a button click to show/hide a `Paper` element with specified delays. Dependencies include `react` and `@mantine/core`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.11.0.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { Button, Flex, Paper, Transition } from '@mantine/core';\n\nexport function Demo() {\n  const [opened, setOpened] = useState(false);\n\n  return (\n    <Flex maw={200} pos=\"relative\" justify=\"center\" m=\"auto\">\n      <Button onClick={() => setOpened(true)}>Open dropdown</Button>\n\n      <Transition mounted={opened} transition=\"pop\" enterDelay={500} exitDelay={300}>\n        {(transitionStyle) => (\n          <Paper\n            shadow=\"md\"\n            p=\"xl\"\n            h={120}\n            pos=\"absolute\"\n            inset={0}\n            bottom=\"auto\"\n            onClick={() => setOpened(false)}\n            style={{ ...transitionStyle, zIndex: 1 }}\n          >\n            Click to close\n          </Paper>\n        )}\n      </Transition>\n    </Flex>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Imports and Export of Burger Component and Usage Data\nDESCRIPTION: This snippet imports necessary modules, including demo data and layout components, and exports the default component rendering the Burger component within a predefined layout. It sets up the foundational code structure for the page, linking the 'MDX_DATA.Burger' to the layout.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/core/burger.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { BurgerDemos } from '@docs/demos';\nimport { Layout } from '@/layout';\nimport { MDX_DATA } from '@/mdx';\n\nexport default Layout(MDX_DATA.Burger);\n```\n\n----------------------------------------\n\nTITLE: Configuring gradient fill in LineChart\nDESCRIPTION: Enables gradient fill in the line chart by setting 'type=\"gradient\"'. Customizes gradient colors via 'gradientStops' array with 'offset' and 'color'. Suitable for creating visually appealing lines with smooth color transitions.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/charts/line-chart.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Demo data={LineChartDemos.gradient} />\n```\n\n----------------------------------------\n\nTITLE: Configuring Page Layout and Meta in Next.js with JavaScript\nDESCRIPTION: This snippet imports a Layout component and defines a meta object containing the page's title, description, slug, category, tags, and relevant dates for Mantine's contribution guide page. It then exports the page using the Layout function, supplying the meta as its argument. Dependencies include the Layout component located at '@/layout'. The main parameters are the meta fields, which dictate how the page appears and is categorized in the documentation. This setup expects a React/Next.js environment and requires accurate meta values for proper integration. The output is a page with configured layout and metadata, intended for Mantine documentation. There are no major limitations, but the snippet assumes the existence and correct configuration of the Layout component.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/how-can-i-contribute.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Layout } from '@/layout';\n\nexport const meta = {\n  title: 'How can I contribute to the library?',\n  description:\n    'There are multiple ways to contribute even without writing code',\n  slug: 'how-can-i-contribute',\n  category: 'about',\n  tags: ['contribute', 'pull request'],\n  created_at: 'January 3, 2024',\n  last_updated_at: 'January 3, 2024',\n};\n\nexport default Layout(meta);\n```\n\n----------------------------------------\n\nTITLE: Type Specification with useLocalStorage in TypeScript\nDESCRIPTION: Demonstrates how to specify the type of the stored value when using useLocalStorage hook with TypeScript, providing type safety and better autocompletion.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-local-storage.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useLocalStorage } from '@mantine/hooks';\n\nconst [value, setValue] = useLocalStorage<'dark' | 'light'>({\n  key: 'color-scheme',\n  defaultValue: 'light',\n});\n```\n\n----------------------------------------\n\nTITLE: Defining getOS function in TypeScript\nDESCRIPTION: This code defines the `getOS` function. It accepts an optional `options` object with a `getValueInEffect` boolean property. The function returns a string representing the OS, chosen from a union of possible OS values, which include `undetermined`, `macos`, `ios`, `windows`, `android`, and `linux`.  The function likely determines the user's operating system.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/hooks/use-os.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfunction getOS(options?: {\n  getValueInEffect: boolean;\n}):\n  | 'undetermined'\n  | 'macos'\n  | 'ios'\n  | 'windows'\n  | 'android'\n  | 'linux';\n```\n\n----------------------------------------\n\nTITLE: Limitation: Using One Polymorphic Component Inside Another\nDESCRIPTION: This snippet highlights a common limitation when nesting polymorphic components, demonstrating that type inference can fail when a polymorphic component is used as the 'component' prop of another polymorphic component, leading to unknown root element types.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/help.mantine.dev/src/pages/q/polymorphic-in-polymorphic.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n## Why I cannot use one polymorphic component in component prop of another polymorphic component?\n\nWhen you use one polymorphic component in `component` prop of another polymorphic component,\ntypes cannot be inferred correctly because the type of the root element is not known until the component is used.\n\n```tsx\nimport { Box, Button } from '@mantine/core';\n\nfunction Demo() {\n  // Types cannot be inferred correctly\n  return <Box component={Button} />;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Checkbox and Radio Card Components in Mantine\nDESCRIPTION: This snippet presents how to replace standard checkboxes and radios with customizable card components (`Checkbox.Card` and `Radio.Card`) that support accessibility and keyboard interactions. The examples include toggle logic with React's useState hook and demonstrate grouping multiple cards within `Checkbox.Group` and `Radio.Group` with corresponding state management. These components enable building more interactive, styled selection options while maintaining accessibility standards.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.10.0.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { Checkbox, Group, Text } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const [checked, setChecked] = useState(false);\n\n  return (\n    <Checkbox.Card\n      className={classes.root}\n      radius=\"md\"\n      checked={checked}\n      onClick={() => setChecked((c) => !c)}\n    >\n      <Group wrap=\"nowrap\" align=\"flex-start\">\n        <Checkbox.Indicator />\n        <div>\n          <Text className={classes.label}>@mantine/core</Text>\n          <Text className={classes.description}>\n            Core components library: inputs, buttons, overlays, etc.\n          </Text>\n        </div>\n      </Group>\n    </Checkbox.Card>\n  );\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { Checkbox, Group, Stack, Text } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst data = [\n  {\n    name: '@mantine/core',\n    description: 'Core components library: inputs, buttons, overlays, etc.',\n  }, { name: '@mantine/hooks', description: 'Collection of reusable hooks for React applications.' }, { name: '@mantine/notifications', description: 'Notifications system' },\n];\n\nfunction Demo() {\n  const [value, setValue] = useState<string[]>([]);\n\n  const cards = data.map((item) => (\n    <Checkbox.Card className={classes.root} radius=\"md\" value={item.name} key={item.name}>\n      <Group wrap=\"nowrap\" align=\"flex-start\">\n        <Checkbox.Indicator />\n        <div>\n          <Text className={classes.label}>{item.name}</Text>\n          <Text className={classes.description}>{item.description}</Text>\n        </div>\n      </Group>\n    </Checkbox.Card>\n  ));\n\n  return (\n    <>\n      <Checkbox.Group\n        value={value}\n        onChange={setValue}\n        label=\"Pick packages to install\"\n        description=\"Choose all packages that you will need in your application\"\n      >\n        <Stack pt=\"md\" gap=\"xs\">\n          {cards}\n        </Stack>\n      </Checkbox.Group>\n\n      <Text fz=\"xs\" mt=\"md\">\n        CurrentValue: {value.join(', ') || '–'}\n      </Text>\n    </>\n  );\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { Group, Radio, Text } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const [checked, setChecked] = useState(false);\n\n  return (\n    <Radio.Card\n      className={classes.root}\n      radius=\"md\"\n      checked={checked}\n      onClick={() => setChecked((c) => !c)}\n    >\n      <Group wrap=\"nowrap\" align=\"flex-start\">\n        <Radio.Indicator />\n        <div>\n          <Text className={classes.label}>@mantine/core</Text>\n          <Text className={classes.description}>\n            Core components library: inputs, buttons, overlays, etc.\n          </Text>\n        </div>\n      </Group>\n    </Radio.Card>\n  );\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useState } from 'react';\nimport { Group, Radio, Stack, Text } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst data = [\n  {\n    name: '@mantine/core',\n    description: 'Core components library: inputs, buttons, overlays, etc.',\n  }, { name: '@mantine/hooks', description: 'Collection of reusable hooks for React applications.' }, { name: '@mantine/notifications', description: 'Notifications system' },\n];\n\nfunction Demo() {\n  const [value, setValue] = useState<string | null>(null);\n\n  const cards = data.map((item) => (\n    <Radio.Card className={classes.root} radius=\"md\" value={item.name} key={item.name}>\n      <Group wrap=\"nowrap\" align=\"flex-start\">\n        <Radio.Indicator />\n        <div>\n          <Text className={classes.label}>{item.name}</Text>\n          <Text className={classes.description}>{item.description}</Text>\n        </div>\n      </Group>\n    </Radio.Card>\n  ));\n\n  return (\n    <>\n      <Radio.Group\n        value={value}\n        onChange={setValue}\n        label=\"Pick one package to install\"\n        description=\"Choose a package that you will need in your application\"\n      >\n        <Stack pt=\"md\" gap=\"xs\">\n          {cards}\n        </Stack>\n      </Radio.Group>\n\n      <Text fz=\"xs\" mt=\"md\">\n        CurrentValue: {value || '–'}\n      </Text>\n    </>\n  );\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example Mantine Sass Module Usage\nDESCRIPTION: Demonstrates how to utilize the global Mantine Sass resources (`_mantine.scss`) within a component-level Sass module file. It shows using the `rem` function for sizing, applying color scheme specific styles with `@include mantine.light` and `@include mantine.dark`, and creating responsive styles with `@include mantine.smaller-than` using defined breakpoint variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/sass.mdx#_snippet_2\n\nLANGUAGE: scss\nCODE:\n```\n// example.module.scss\n.title {\n  // light-dark function is handled by PostCSS\n  color: light-dark(\n    var(--mantine-color-black),\n    var(--mantine-color-white)\n  );\n  font-size: mantine.rem(100px);\n  font-weight: 900;\n  letter-spacing: mantine.rem(-2px);\n\n  @include mantine.light {\n    background-color: red;\n  }\n\n  @include mantine.dark {\n    background-color: blue;\n  }\n\n  @include mantine.smaller-than(mantine.$mantine-breakpoint-md) {\n    font-size: mantine.rem(50px);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom PostCSS Mixins in Mantine\nDESCRIPTION: Shows how to define custom PostCSS mixins for the mantine-postcss-preset by specifying them in the mixins option, enabling reusable style patterns.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.9.0.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {\n      autoRem: true,\n      mixins: {\n        clearfix: {\n          '&::after': {\n            content: '\"\"',\n            display: 'table',\n            clear: 'both',\n          },\n        },\n        circle: (_mixin, size) => ({\n          borderRadius: '50%',\n          width: size,\n          height: size,\n        }),\n      },\n    },\n    // ... Other plugins\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Body and :root element styles in Mantine\nDESCRIPTION: Default styles applied to the body and :root elements by Mantine, defining color scheme, font family, sizes, and other base styling using CSS variables.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/styles/global-styles.mdx#_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n:root {\n  color-scheme: var(--mantine-color-scheme);\n}\n\nbody {\n  font-family: var(--mantine-font-family);\n  font-size: var(--mantine-font-size-md);\n  line-height: var(--mantine-line-height);\n  background-color: var(--mantine-color-body);\n  color: var(--mantine-color-text);\n\n  -webkit-font-smoothing: var(--mantine-webkit-font-smoothing);\n  -moz-osx-font-smoothing: var(--mantine-moz-font-smoothing);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mantine Spotlight with Compound Components (TSX)\nDESCRIPTION: Shows the revamped Mantine Spotlight implementation using compound components (`Spotlight.Root`, `Spotlight.Search`, `Spotlight.ActionsList`, `Spotlight.Action`, `Spotlight.Empty`) and the `spotlight` object for control (e.g., `spotlight.open`). This example demonstrates filtering actions based on a search query managed by local state. Requires `@mantine/core`, `@mantine/spotlight`, and `@tabler/icons-react`.\nSOURCE: https://github.com/mantinedev/mantine/blob/master/changelog/7.0.0.md#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useState } from 'react';\nimport { IconSearch } from '@tabler/icons-react';\nimport { Button } from '@mantine/core';\nimport { Spotlight, spotlight } from '@mantine/spotlight';\n\nconst data = ['Home', 'About us', 'Contacts', 'Blog', 'Careers', 'Terms of service'];\n\nfunction Demo() {\n  const [query, setQuery] = useState('');\n\n  const items = data\n    .filter((item) => item.toLowerCase().includes(query.toLowerCase().trim()))\n    .map((item) => <Spotlight.Action key={item} label={item} />);\n\n  return (\n    <>\n      <Button onClick={spotlight.open}>Open spotlight</Button>\n\n      <Spotlight.Root query={query} onQueryChange={setQuery}>\n        <Spotlight.Search placeholder=\"Search...\" leftSection={<IconSearch stroke={1.5} />} />\n        <Spotlight.ActionsList>\n          {items.length > 0 ? items : <Spotlight.Empty>Nothing found...</Spotlight.Empty>}\n        </Spotlight.ActionsList>\n      </Spotlight.Root>\n    </>\n  );\n}\n```"
  }
]