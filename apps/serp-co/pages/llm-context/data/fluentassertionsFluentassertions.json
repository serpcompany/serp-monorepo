[
  {
    "owner": "fluentassertions",
    "repo": "fluentassertions",
    "content": "TITLE: Using AssertionScope for Batched Assertions\nDESCRIPTION: Demonstrates how to use AssertionScope to collect multiple assertion failures and report them together instead of failing on the first error.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nusing (new AssertionScope())\n{\n    5.Should().Be(10);\n    \"Actual\".Should().Be(\"Expected\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Assertions with the CustomAssertion Attribute\nDESCRIPTION: Demonstrates how to create custom assertion extensions with the CustomAssertion attribute to maintain proper subject identification in error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n    public class CustomerAssertions\n    {\n        private readonly Customer customer;\n\n        public CustomerAssertions(Customer customer)\n        {\n            this.customer = customer;\n        }\n\n        [CustomAssertion]\n        public void BeActive(string because = \"\", params object[] becauseArgs)\n        {\n            customer.Active.Should().BeTrue(because, becauseArgs);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Validating Exceptions with Fluent Assertions\nDESCRIPTION: Shows how to assert that a specific exception is thrown with a particular message and contains expected business rule violations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar recipe = new RecipeBuilder()\n  .With(new IngredientBuilder().For(\"Milk\").WithQuantity(200, Unit.Milliliters))\n  .Build();\n                    \nvar action = () => recipe.AddIngredient(\"Milk\", 100, Unit.Spoon);\n\naction\n  .Should().Throw<RuleViolationException>()\n  .WithMessage(\"*change the unit of an existing ingredient*\")\n  .And.Violations.Should().Contain(BusinessRule.CannotChangeIngredientQuantity);\n```\n\n----------------------------------------\n\nTITLE: Basic String Assertion Example in C#\nDESCRIPTION: A simple example showing a string assertion that will fail with a descriptive message. The assertion compares an account number string with an expected value, demonstrating how Fluent Assertions provides detailed failure messages showing the difference between actual and expected values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/about.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring accountNumber = \"1234567890\";\naccountNumber.Should().Be(\"0987654321\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Should() Extension Methods for Various Types in C#\nDESCRIPTION: A comprehensive set of extension methods that provide the entry point for FluentAssertions' fluent syntax. Each method extends a specific type and returns a specialized assertion class tailored for that type. These extension methods enable developers to write expressive and readable assertion code.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Specialized.TaskCompletionSourceAssertions Should(this System.Threading.Tasks.TaskCompletionSource tcs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.TimeOnlyAssertions Should(this System.TimeOnly actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.NullableTimeOnlyAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.TimeOnly? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.SimpleTimeSpanAssertions Should(this System.TimeSpan actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.TimeSpan? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Types.TypeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Type subject) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Xml.XAttributeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XAttribute actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Xml.XDocumentAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XDocument actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Xml.XElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XElement actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.BooleanAssertions Should(this bool actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.NullableBooleanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this bool? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<byte> Should(this byte actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<byte> Should([System.Diagnostics.CodeAnalysis.NotNull] this byte? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<decimal> Should(this decimal actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<decimal> Should([System.Diagnostics.CodeAnalysis.NotNull] this decimal? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<double> Should(this double actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<double> Should([System.Diagnostics.CodeAnalysis.NotNull] this double? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<float> Should(this float actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<float> Should([System.Diagnostics.CodeAnalysis.NotNull] this float? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<int> Should(this int actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<int> Should([System.Diagnostics.CodeAnalysis.NotNull] this int? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<long> Should(this long actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<long> Should([System.Diagnostics.CodeAnalysis.NotNull] this long? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.ObjectAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this object actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<sbyte> Should(this sbyte actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<sbyte> Should([System.Diagnostics.CodeAnalysis.NotNull] this sbyte? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<short> Should(this short actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<short> Should([System.Diagnostics.CodeAnalysis.NotNull] this short? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.StringAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this string actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<uint> Should(this uint actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<uint> Should([System.Diagnostics.CodeAnalysis.NotNull] this uint? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<ulong> Should(this ulong actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<ulong> Should([System.Diagnostics.CodeAnalysis.NotNull] this ulong? actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<ushort> Should(this ushort actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NullableNumericAssertions<ushort> Should([System.Diagnostics.CodeAnalysis.NotNull] this ushort? actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Using Satisfy for Nested Assertions in C#\nDESCRIPTION: Shows how to perform nested fluent assertions on complex objects using the Satisfy method. This allows for comprehensive validation of object hierarchies with multiple property checks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar productDto = new ProductDto\n{\n    Name = \"Some product name\",\n    Price = 19.95,\n    SKU = \"ABC12345\",\n    Store = new Store\n    {\n        Country = \"Germany\",\n        Quantity = 42\n    }\n};\n\nproductDto.Should().Satisfy<ProductDto>(dto =>\n{\n    dto.Name.Should().Be(\"Some product name\");\n    dto.Price.Should().Be(19.95);\n    dto.SKU.Should().EndWith(\"12345\");\n    dto.Store.Should().Satisfy<Store>(store =>\n    {\n        store.Country.Should().Be(\"Germany\");\n        store.Quantity.Should().BeGreaterThan(40);\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Assertion Extension Methods in C#\nDESCRIPTION: Defines extensive set of extension methods for various types to enable fluent assertions. Includes methods for tasks, collections, dates, streams, and reflection objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionExtensions\n{\n    public static TTo As<TTo>(this object subject) { }\n    public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.Task> action) { }\n    public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask> action) { }\n    public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.Task<TResult>> action) { }\n    // Additional methods omitted for brevity...\n}\n```\n\n----------------------------------------\n\nTITLE: Generic StringAssertions Class for String Testing in C#\nDESCRIPTION: Provides a comprehensive set of string assertion methods for testing string values. Includes methods for equality, substring checks, case validation, pattern matching, and regular expression validation with customizable error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringAssertions<TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<string, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.StringAssertions<TAssertions>\n{\n    public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLowerCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNullOrWhiteSpace(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params string[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<string> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeUpperCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAll(params string[] values) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAll(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAny(params string[] values) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAny(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWith(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveLength(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(string unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Exception Throwing with Message in C#\nDESCRIPTION: Demonstrates how to verify that a method throws a specific exception with a particular message using FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nsubject.Invoking(y => y.Foo(\"Hello\"))\n    .Should().Throw<InvalidOperationException>()\n    .WithMessage(\"Hello is not allowed at this moment\");\n```\n\n----------------------------------------\n\nTITLE: Basic String Assertions in C#\nDESCRIPTION: Demonstrates basic string assertions for null, empty, and whitespace checks using FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring theString = \"\";\ntheString.Should().NotBeNull();\ntheString.Should().BeNull();\ntheString.Should().BeEmpty();\ntheString.Should().NotBeEmpty(\"because the string is not empty\");\ntheString.Should().HaveLength(0);\ntheString.Should().BeNullOrWhiteSpace();\ntheString.Should().NotBeNullOrWhiteSpace();\n```\n\n----------------------------------------\n\nTITLE: Monitoring Events in Dynamically Generated Classes in C#\nDESCRIPTION: Shows how to monitor events in dynamically generated classes using System.Reflection.Emit. The generic Monitor<T>() method allows specifying which interface was implemented in the generated class.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nPOCOClass subject = EmitViewModelFromPOCOClass();\n\nusing var monitor = subject.Monitor<ISomeInterface>();\n\n// POCO class doesn't have INotifyPropertyChanged implemented\nmonitor.Should().Raise(\"SomeEvent\");\n```\n\n----------------------------------------\n\nTITLE: Validating Collection Elements with Fluent Assertions\nDESCRIPTION: Shows how to assert properties of collections, including validating that all elements satisfy a condition and that the collection contains a specific number of items.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<int> numbers = new[] { 1, 2, 3 };\n\nnumbers.Should().OnlyContain(n => n > 0);\nnumbers.Should().HaveCount(4, \"because we thought we put four items in the collection\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Assertions in C#\nDESCRIPTION: This class provides methods for asserting properties of exceptions, including inner exceptions and messages. It allows for filtering exceptions based on custom predicates and asserting specific inner exception types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionAssertions<TException> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Collections.Generic.IEnumerable<TException>, FluentAssertions.Specialized.ExceptionAssertions<TException>>\n    where TException : System.Exception\n{\n    public ExceptionAssertions(System.Collections.Generic.IEnumerable<TException> exceptions, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TException And { get; }\n    protected override string Identifier { get; }\n    public TException Which { get; }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> Where(System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerException(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerException<TInnerException>(string because = \"\", params object[] becauseArgs)\n        where TInnerException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerExceptionExactly(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerExceptionExactly<TInnerException>(string because = \"\", params object[] becauseArgs)\n        where TInnerException : System.Exception { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TException> WithMessage(string expectedWildcardPattern, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Subject Identification in Fluent Assertions\nDESCRIPTION: Shows how Fluent Assertions extracts the variable name from the test code to provide more meaningful failure messages with the subject clearly identified.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nstring username = \"dennis\";\nusername.Should().Be(\"jonas\");\n```\n\n----------------------------------------\n\nTITLE: Basic Object Graph Equivalence Comparison in C#\nDESCRIPTION: Demonstrates how to assert that two object graphs are structurally equivalent using the BeEquivalentTo method. This is useful for comparing complex objects like DTOs with their domain model counterparts.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order);\n```\n\n----------------------------------------\n\nTITLE: Asserting Task Completion Time in C#\nDESCRIPTION: Shows how to assert that asynchronous tasks complete within a specified time period or don't complete, including assertions for thrown exceptions during task execution.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/executiontime.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar someAsyncWork = () => SomethingReturningATask();\nawait someAsyncWork.Should().CompleteWithinAsync(100.Milliseconds());\nawait someAsyncWork.Should().NotCompleteWithinAsync(100.Milliseconds());\nawait someAsyncWork.Should().ThrowWithinAsync<InvalidOperationException>(100.Milliseconds());\n```\n\n----------------------------------------\n\nTITLE: Asserting Approximate Equality for Floating-Point Values in C#\nDESCRIPTION: Shows how to use the BeApproximately method for asserting equality of floating-point values within a specified tolerance. This is preferred over direct equality checks due to the inherent inaccuracy of floating-point representations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/numerictypes.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nfloat value = 3.1415927F;\nvalue.Should().BeApproximately(3.14F, 0.01F);\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard in Exception Message Assertion in C#\nDESCRIPTION: Shows how to use wildcard expressions in exception message assertions, which is case-insensitive and supports asterisk and question mark wildcards.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = () => subject.Foo(null);\nact\n  .Should().Throw<ArgumentNullException>()\n  .WithMessage(\"?did*\");\n```\n\n----------------------------------------\n\nTITLE: Asserting Integer Values with FluentAssertions in C#\nDESCRIPTION: Demonstrates various assertion methods for integer values, including comparisons, range checks, and custom predicates. Also shows assertions for nullable integers and other numeric types like byte.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/numerictypes.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint theInt = 5;\ntheInt.Should().BeGreaterThanOrEqualTo(5);\ntheInt.Should().BeGreaterThanOrEqualTo(3);\ntheInt.Should().BeGreaterThan(4);\ntheInt.Should().BeLessThanOrEqualTo(5);\ntheInt.Should().BeLessThan(6);\ntheInt.Should().BePositive();\ntheInt.Should().Be(5);\ntheInt.Should().NotBe(10);\ntheInt.Should().BeInRange(1, 10);\ntheInt.Should().NotBeInRange(6, 10);\ntheInt.Should().Match(x => x % 2 == 1);\n\ntheInt = 0;\n//theInt.Should().BePositive(); => Expected positive value, but found 0\n//theInt.Should().BeNegative(); => Expected negative value, but found 0\n\ntheInt = -8;\ntheInt.Should().BeNegative();\nint? nullableInt = 3;\nnullableInt.Should().Be(3);\n\ndouble theDouble = 5.1;\ntheDouble.Should().BeGreaterThan(5);\nbyte theByte = 2;\ntheByte.Should().Be(2);\n```\n\n----------------------------------------\n\nTITLE: Retrying Assertion with Timeout in C#\nDESCRIPTION: Illustrates how to retry an assertion until it succeeds or a specified time elapses, useful for testing asynchronous operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = () => service.IsReady().Should().BeTrue();\nact.Should().NotThrowAfter(10.Seconds(), 100.Milliseconds());\n```\n\n----------------------------------------\n\nTITLE: Comparing Dictionary Equality in C#\nDESCRIPTION: Shows how to assert equality between dictionaries using Fluent Assertions. The equality check validates that dictionaries have the same keys and values, using the Equals implementation of the key and value types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/dictionaries.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar dictionary1 = new Dictionary<int, string>\n{\n    { 1, \"One\" },\n    { 2, \"Two\" }\n};\n\nvar dictionary2 = new Dictionary<int, string>\n{\n    { 1, \"One\" },\n    { 2, \"Two\" }\n};\n\nvar dictionary3 = new Dictionary<int, string>\n{\n    { 3, \"Three\" },\n};\n\ndictionary1.Should().Equal(dictionary2);\ndictionary1.Should().NotEqual(dictionary3);\n```\n\n----------------------------------------\n\nTITLE: Implementing Configuration and Framework Classes for FluentAssertions in C#\nDESCRIPTION: Defines configuration classes that control global assertion behavior. These static classes provide access to configuration settings and allow resetting to defaults or specifying custom test frameworks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    public static class AssertionConfiguration\n    {\n        public static FluentAssertions.Configuration.GlobalConfiguration Current { get; }\n    }\n    public static class AssertionEngine\n    {\n        public static FluentAssertions.Configuration.GlobalConfiguration Configuration { get; }\n        public static FluentAssertions.Execution.ITestFramework TestFramework { get; set; }\n        public static void ResetToDefaults() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Validating String Properties with Fluent Assertions\nDESCRIPTION: Demonstrates string assertions with chaining for verifying that a string starts with, ends with, contains specific text, and has a specific length.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstring actual = \"ABCDEFGHI\";\nactual.Should().StartWith(\"AB\").And.EndWith(\"HI\").And.Contain(\"EF\").And.HaveLength(9);\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Methods for FluentAssertions API in C#\nDESCRIPTION: Defines the core extension methods that provide the fluent assertion syntax. These methods extend various types with Should() and other utility methods for creating assertions, monitoring events, and handling asynchronous operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n    public static class AssertionExtensions\n    {\n        public static TTo As<TTo>(this object subject) { }\n        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.Task> action) { }\n        public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask> action) { }\n        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.Task<TResult>> action) { }\n        public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask<TResult>> action) { }\n        public static System.Action Enumerating(this System.Func<System.Collections.IEnumerable> enumerable) { }\n        public static System.Action Enumerating<T>(this System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }\n        public static System.Action Enumerating<T, TResult>(this T subject, System.Func<T, System.Collections.Generic.IEnumerable<TResult>> enumerable) { }\n        public static FluentAssertions.Specialized.ExecutionTime ExecutionTime(this System.Func<System.Threading.Tasks.Task> action) { }\n        public static FluentAssertions.Specialized.ExecutionTime ExecutionTime(this System.Action action, FluentAssertions.Common.StartTimer createTimer = null) { }\n        public static FluentAssertions.Specialized.MemberExecutionTime<T> ExecutionTimeOf<T>(this T subject, System.Linq.Expressions.Expression<System.Action<T>> action, FluentAssertions.Common.StartTimer createTimer = null) { }\n        public static System.Action Invoking<T>(this T subject, System.Action<T> action) { }\n        public static System.Func<TResult> Invoking<T, TResult>(this T subject, System.Func<T, TResult> action) { }\n        public static FluentAssertions.Events.IMonitor<T> Monitor<T>(this T eventSource) { }\n        public static FluentAssertions.Events.IMonitor<T> Monitor<T>(this T eventSource, System.Action<FluentAssertions.Events.EventMonitorOptions> configureOptions) { }\n        public static FluentAssertions.Specialized.ExecutionTimeAssertions Should(this FluentAssertions.Specialized.ExecutionTime executionTime) { }\n        [System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\n        public static void Should(this FluentAssertions.Specialized.ExecutionTimeAssertions _) { }\n        [System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\n        public static void Should(this FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase _) { }\n        public static FluentAssertions.Types.MethodInfoSelectorAssertions Should(this FluentAssertions.Types.MethodInfoSelector methodSelector) { }\n        [System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\n        public static void Should(this FluentAssertions.Types.MethodInfoSelectorAssertions _) { }\n        public static FluentAssertions.Types.PropertyInfoSelectorAssertions Should(this FluentAssertions.Types.PropertyInfoSelector propertyInfoSelector) { }\n        [System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\n        public static void Should(this FluentAssertions.Types.PropertyInfoSelectorAssertions _) { }\n        public static FluentAssertions.Types.TypeSelectorAssertions Should(this FluentAssertions.Types.TypeSelector typeSelector) { }\n        [System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\n        public static void Should(this FluentAssertions.Types.TypeSelectorAssertions _) { }\n        public static FluentAssertions.Specialized.ActionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Action action) { }\n        public static FluentAssertions.Collections.StringCollectionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<string> @this) { }\n        public static FluentAssertions.Primitives.DateTimeAssertions Should(this System.DateTime actualValue) { }\n        public static FluentAssertions.Primitives.NullableDateTimeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.DateTime? actualValue) { }\n        public static FluentAssertions.Primitives.DateTimeOffsetAssertions Should(this System.DateTimeOffset actualValue) { }\n        public static FluentAssertions.Primitives.NullableDateTimeOffsetAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.DateTimeOffset? actualValue) { }\n        public static FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task> action) { }\n        public static FluentAssertions.Primitives.GuidAssertions Should(this System.Guid actualValue) { }\n        public static FluentAssertions.Primitives.NullableGuidAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Guid? actualValue) { }\n        public static FluentAssertions.Streams.BufferedStreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.BufferedStream actualValue) { }\n        public static FluentAssertions.Streams.StreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.Stream actualValue) { }\n        public static FluentAssertions.Types.AssemblyAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.Assembly assembly) { }\n        public static FluentAssertions.Types.ConstructorInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.ConstructorInfo constructorInfo) { }\n        public static FluentAssertions.Types.MethodInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.MethodInfo methodInfo) { }\n        public static FluentAssertions.Types.PropertyInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.PropertyInfo propertyInfo) { }\n        public static FluentAssertions.Primitives.SimpleTimeSpanAssertions Should(this System.TimeSpan actualValue) { }\n        public static FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.TimeSpan? actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting XML Document and Element Structure in C#\nDESCRIPTION: Demonstrates basic assertions for XML documents and elements, including checking for root elements, specific elements with count constraints, values, attributes, and namespaces.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/xml.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nxDocument.Should().HaveRoot(\"configuration\");\nxDocument.Should().HaveElement(\"settings\");\nxDocument.Should().HaveElement(\"settings\", Exactly.Once());\nxDocument.Should().HaveElement(\"settings\", AtLeast.Twice());\n\nxElement.Should().HaveValue(\"36\");\nxElement.Should().HaveAttribute(\"age\", \"36\");\nxElement.Should().HaveElement(\"address\");\nxElement.Should().HaveElementWithNamespace(\"address\", \"http://www.example.com/2012/test\");\n\nxElement.Should().HaveInnerText(\"some textanother textmore text\");\n\nxElement.Should().HaveElement(\"settings\", Exactly.Once());\nxElement.Should().HaveElement(\"settings\", AtLeast.Twice());\n```\n\n----------------------------------------\n\nTITLE: Asserting DateTime and DateTimeOffset objects with FluentAssertions in C#\nDESCRIPTION: Examples of using FluentAssertions to check various DateTime and DateTimeOffset properties including equality, comparison, date matching, and kind checking. Demonstrates the readable syntax using extension methods like March(), At(), and AsLocal().\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/datetimespans.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar theDatetime = 1.March(2010).At(22, 15).AsLocal();\n\ntheDatetime.Should().Be(1.March(2010).At(22, 15));\ntheDatetime.Should().BeAfter(1.February(2010));\ntheDatetime.Should().BeBefore(2.March(2010));\ntheDatetime.Should().BeOnOrAfter(1.March(2010));\ntheDatetime.Should().BeOnOrBefore(1.March(2010));\ntheDatetime.Should().BeSameDateAs(1.March(2010).At(22, 16));\ntheDatetime.Should().BeIn(DateTimeKind.Local);\n\ntheDatetime.Should().NotBe(1.March(2010).At(22, 16));\ntheDatetime.Should().NotBeAfter(2.March(2010));\ntheDatetime.Should().NotBeBefore(1.February(2010));\ntheDatetime.Should().NotBeOnOrAfter(2.March(2010));\ntheDatetime.Should().NotBeOnOrBefore(1.February(2010));\ntheDatetime.Should().NotBeSameDateAs(2.March(2010));\ntheDatetime.Should().NotBeIn(DateTimeKind.Utc);\n\ntheDatetime.Should().BeOneOf(\n    1.March(2010).At(21, 15),\n    1.March(2010).At(22, 15),\n    1.March(2010).At(23, 15)\n);\n\nvar theDatetimeOffset = 1.March(2010).At(22, 15).WithOffset(2.Hours());     \n\n// Asserts the point in time. \ntheDatetimeOffset.Should().Be(1.March(2010).At(21, 15).WithOffset(1.Hours()));          \ntheDatetimeOffset.Should().NotBe(1.March(2010).At(21, 15).WithOffset(1.Hours())); \n```\n\n----------------------------------------\n\nTITLE: Implementing NumericAssertionsBase Abstract Class in C#\nDESCRIPTION: Abstract base class that provides common numeric assertion methods for both regular and nullable numeric types. It includes methods for comparison (Be, BeGreaterThan), range checking (BeInRange), and type verification (BeOfType).\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class NumericAssertionsBase<T, TSubject, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertionsBase<T, TSubject, TAssertions>\n{\n    protected NumericAssertionsBase(FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }\n    public abstract TSubject Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BePositive(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(T unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(T? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Assertion Methods in C#\nDESCRIPTION: This snippet defines numerous methods for asserting various properties of types, such as having specific methods, properties, or attributes. It includes both positive and negative assertions (e.g., HaveMethod and NotHaveMethod).\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_150\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveIndexer(System.Type indexerType, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n// ... (additional methods omitted for brevity)\n```\n\n----------------------------------------\n\nTITLE: Generic Collection Assertion Classes in FluentAssertions\nDESCRIPTION: Implementation of assertion classes for different types of generic collections. These classes provide a comprehensive set of methods for validating collection contents, structure, ordering, and element properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericCollectionAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T, FluentAssertions.Collections.GenericCollectionAssertions<T>>\n{\n    public GenericCollectionAssertions(System.Collections.Generic.IEnumerable<T> actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n\npublic class GenericCollectionAssertions<TCollection, T> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T>>\n    where TCollection : System.Collections.Generic.IEnumerable<T>\n{\n    public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n\npublic class GenericCollectionAssertions<TCollection, T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TCollection, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<T>\n    where TAssertions : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>\n{\n    public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeAssignableTo(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeAssignableTo<TExpectation>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeOfType<TExpectation>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllSatisfy(System.Action<T> expected, string because = \"\", params object[] becauseArgs) { }\n    protected void AssertCollectionEndsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actual, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n    protected void AssertCollectionStartsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actualItems, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n    protected void AssertSubjectEquality<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Comparing Collection to Single Object in FluentAssertions using C#\nDESCRIPTION: Example demonstrating how to assert that all items in a collection are equivalent to a single object. Useful for validating that all collection items match a specific template.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\norderDtos.Should().AllBeEquivalentTo(singleOrder);\n```\n\n----------------------------------------\n\nTITLE: Asserting Task Result With Completion Time in C#\nDESCRIPTION: Demonstrates how to verify both the completion time of a task and its result value in a single assertion chain. This example asserts that a task completes within 100 milliseconds and returns the value 42.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/executiontime.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<Task<int>> someAsyncFunc;\n\nawait someAsyncFunc.Should().CompleteWithinAsync(100.Milliseconds()).WithResult(42);\n```\n\n----------------------------------------\n\nTITLE: Chaining Type Assertions with Which Property in C#\nDESCRIPTION: Shows how to combine type checking with subsequent assertions on the cast object using the Which property. This allows for fluent verification of properties after confirming an object's type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nsomeObject.Should().BeOfType<Exception>()\n  .Which.Message.Should().Be(\"Other Message\");\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Object and String Types in FluentAssertions\nDESCRIPTION: Provides extension methods for Object and String types to enable fluent assertions. These methods create specialized assertion objects for object reference and string validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.ObjectAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this object actualValue) { }\npublic static FluentAssertions.Primitives.StringAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this string actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Chaining Assertions on Collections and Complex Objects\nDESCRIPTION: Demonstrates how to chain assertions to perform specific validations on properties of objects contained within collections or after type assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ndictionary.Should().ContainValue(myClass).Which.SomeProperty.Should().BeGreaterThan(0);\n\nsomeObject.Should().BeOfType<Exception>().Which.Message.Should().Be(\"Other Message\");\n\nxDocument.Should().HaveElement(\"child\").Which.Should().BeOfType<XElement>().And.HaveAttribute(\"attr\", \"1\");\n```\n\n----------------------------------------\n\nTITLE: Basic Collection Assertions with FluentAssertions in C#\nDESCRIPTION: Demonstrates fundamental collection assertion methods including count verification, content checking, and item type validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<int> collection = new[] { 1, 2, 5, 8 };\n\ncollection.Should().NotBeEmpty()\n    .And.HaveCount(4)\n    .And.ContainInOrder(new[] { 2, 5 })\n    .And.ContainItemsAssignableTo<int>();\n\ncollection.Should().Equal(new List<int> { 1, 2, 5, 8 });\ncollection.Should().Equal(1, 2, 5, 8);\ncollection.Should().NotEqual(8, 2, 3, 5);\ncollection.Should().BeEquivalentTo(new[] {8, 2, 1, 5});\ncollection.Should().NotBeEquivalentTo(new[] {8, 2, 3, 5});\n\ncollection.Should().HaveCount(c => c > 3)\n  .And.OnlyHaveUniqueItems();\n\ncollection.Should().HaveCountGreaterThan(3);\ncollection.Should().HaveCountGreaterThanOrEqualTo(4);\ncollection.Should().HaveCountLessThanOrEqualTo(4);\ncollection.Should().HaveCountLessThan(5);\ncollection.Should().NotHaveCount(3);\ncollection.Should().HaveSameCount(new[] { 6, 2, 0, 5 });\ncollection.Should().NotHaveSameCount(new[] { 6, 2, 0 });\n\ncollection.Should().StartWith(1);\ncollection.Should().StartWith(new[] { 1, 2 });\ncollection.Should().EndWith(8);\ncollection.Should().EndWith(new[] { 5, 8 });\n\ncollection.Should().BeSubsetOf(new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, });\n\ncollection.Should().ContainSingle();\ncollection.Should().ContainSingle(x => x > 3);\ncollection.Should().Contain(8)\n  .And.HaveElementAt(2, 5)\n  .And.NotBeSubsetOf(new[] {11, 56});\n\ncollection.Should().Contain(x => x > 3);\ncollection.Should().Contain(collection, \"\", 5, 6); // It should contain the original items, plus 5 and 6.\n\ncollection.Should().OnlyContain(x => x < 10);\ncollection.Should().ContainItemsAssignableTo<int>();\ncollection.Should().NotContainItemsAssignableTo<string>();\n\ncollection.Should().ContainInOrder(new[] { 1, 5, 8 });\ncollection.Should().NotContainInOrder(new[] { 5, 1, 2 });\n\ncollection.Should().ContainInConsecutiveOrder(new[] { 2, 5, 8 });\ncollection.Should().NotContainInConsecutiveOrder(new[] { 1, 5, 8});\n\ncollection.Should().NotContain(82);\ncollection.Should().NotContain(new[] { 82, 83 });\ncollection.Should().NotContainNulls();\ncollection.Should().NotContain(x => x > 10);\n\nobject boxedValue = 2;\ncollection.Should().ContainEquivalentOf(boxedValue); // Compared by object equivalence\nobject unexpectedBoxedValue = 82;\ncollection.Should().NotContainEquivalentOf(unexpectedBoxedValue); // Compared by object equivalence\n\nconst int successor = 5;\nconst int predecessor = 5;\ncollection.Should().HaveElementPreceding(successor, element);\ncollection.Should().HaveElementSucceeding(predecessor, element);\n\ncollection.Should().BeEmpty();\ncollection.Should().BeNullOrEmpty();\ncollection.Should().NotBeNullOrEmpty();\n\nIEnumerable<int> otherCollection = new[] { 1, 2, 5, 8, 1 };\nIEnumerable<int> anotherCollection = new[] { 10, 20, 50, 80, 10 };\ncollection.Should().IntersectWith(otherCollection);\ncollection.Should().NotIntersectWith(anotherCollection);\n\nvar singleEquivalent = new[] { new { Size = 42 } };\nsingleEquivalent.Should().ContainSingle()\n    .Which.Should().BeEquivalentTo(new { Size = 42 });\n```\n\n----------------------------------------\n\nTITLE: Asserting Method Execution Time in C#\nDESCRIPTION: Demonstrates how to use Fluent Assertions to verify that a method execution time does not exceed a specified duration. The example shows checking a potentially slow method against a 500 millisecond threshold.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/executiontime.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SomePotentiallyVerySlowClass\n{\n    public void ExpensiveMethod()\n    {\n        for (short i = 0; i < short.MaxValue; i++)\n        {\n            string tmp = \" \";\n            if (!string.IsNullOrEmpty(tmp))\n            {\n                tmp += \" \";\n            }\n        }\n    }\n}\nvar subject = new SomePotentiallyVerySlowClass();\nsubject.ExecutionTimeOf(s => s.ExpensiveMethod()).Should().BeLessThanOrEqualTo(500.Milliseconds());\n```\n\n----------------------------------------\n\nTITLE: Property-Based Collection Ordering Assertions in C#\nDESCRIPTION: Demonstrates how to assert collection ordering based on a property of complex objects without requiring IComparable implementation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ncollection.Should().BeInAscendingOrder(x => x.SomeProperty);\ncollection.Should().BeInDescendingOrder(x => x.SomeProperty);\ncollection.Should().NotBeInAscendingOrder(x => x.SomeProperty);\ncollection.Should().NotBeInDescendingOrder(x => x.SomeProperty);\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Collection Assertions in C#\nDESCRIPTION: Generic collection assertion classes providing fluent assertion capabilities for various collection types. Includes methods for type checking, equivalency testing, and element validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericCollectionAssertions<TCollection, T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TCollection, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<T>\n    where TAssertions : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>\n{\n    public FluentAssertions.AndConstraint<TAssertions> AllBeAssignableTo(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Order and Content (C#)\nDESCRIPTION: These methods assert specific ordering and content properties of collections, such as containing elements in consecutive or specific order.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(params T[] expected) { }\npublic FluentAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> ContainInOrder(params T[] expected) { }\npublic FluentAssertions.AndConstraint<TAssertions> ContainInOrder(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> ContainItemsAssignableTo<TExpectation>(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Null Values in C#\nDESCRIPTION: Demonstrates how to use FluentAssertions to check if an object is null or not null. These assertions verify the existence or non-existence of an object with an optional reason parameter.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nobject theObject = null;\ntheObject.Should().BeNull(\"because the value is null\");\ntheObject.Should().NotBeNull();\n\ntheObject = \"whatever\";\ntheObject.Should().BeOfType<string>(\"because a {0} is set\", typeof(string));\ntheObject.Should().BeOfType(typeof(string), \"because a {0} is set\", typeof(string));\n```\n\n----------------------------------------\n\nTITLE: Asserting Dictionary Keys and Values in C#\nDESCRIPTION: Demonstrates how to verify that a dictionary contains or does not contain specific keys or values. These assertions are useful for validating the content of a dictionary without checking its complete structure.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/dictionaries.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ndictionary.Should().ContainKey(1);\ndictionary.Should().ContainKeys(1, 2);\ndictionary.Should().NotContainKey(9);\ndictionary.Should().NotContainKeys(9, 10);\ndictionary.Should().ContainValue(\"One\");\ndictionary.Should().ContainValues(\"One\", \"Two\");\ndictionary.Should().NotContainValue(\"Nine\");\ndictionary.Should().NotContainValues(\"Nine\", \"Ten\");\n```\n\n----------------------------------------\n\nTITLE: Basic Enum Assertions in Fluent Assertions\nDESCRIPTION: Demonstrates basic enum assertion methods including Be, NotBe, BeOneOf, HaveFlag, and NotHaveFlag. These methods provide simple equality checks and flag verification for enum values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/enums.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nenum MyEnum { One = 1, Two = 2, Three = 3}\n\nmyEnum = MyEnum.One;\n\nmyEnum.Should().Be(MyEnum.One);\nmyEnum.Should().NotBe(MyEnum.Two);\nmyEnum.Should().BeOneOf(MyEnum.One, MyEnum.Two);\n\nregexOptions.Should().HaveFlag(RegexOptions.Global);\nregexOptions.Should().NotHaveFlag(RegexOptions.CaseInsensitive);\n```\n\n----------------------------------------\n\nTITLE: Custom Comparison Behavior by Type in FluentAssertions using C#\nDESCRIPTION: Example showing how to apply custom comparison logic for all members of a specific type. Provides a concise way to handle special types like DateTime throughout an object graph.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => options \n    .Using<DateTime>(ctx => ctx.Subject.Should().BeCloseTo(ctx.Expectation, 1.Seconds()))\n    .WhenTypeIs<DateTime>());\n```\n\n----------------------------------------\n\nTITLE: Asserting Object is One of Multiple Options in C#\nDESCRIPTION: Shows how to verify that an object equals one of several provided options using the BeOneOf method in FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ntheObject.Should().BeOneOf(obj1, obj2, obj3);\n```\n\n----------------------------------------\n\nTITLE: Collection Assertion Methods in C#\nDESCRIPTION: A collection of method signatures for performing assertions on collections. Includes methods for checking ordering, content, uniqueness, and other collection properties. Each method returns an AndConstraint for fluent chaining.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeSubsetOf(System.Collections.Generic.IEnumerable<T> unexpectedSuperset, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(T unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(params T[] unexpected) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(params T[] unexpected) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo<TExpectation>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainNulls(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainNulls<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = \"\", params object[] becauseArgs)\n    where TKey :  class { }\npublic FluentAssertions.AndConstraint<TAssertions> NotEqual(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveCount(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotIntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Satisfy(params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }\npublic FluentAssertions.AndConstraint<TAssertions> Satisfy(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression<System.Func<T, bool>>> predicates, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(params System.Action<T>[] elementInspectors) { }\npublic FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(System.Collections.Generic.IEnumerable<System.Action<T>> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(System.Collections.Generic.IEnumerable<T> expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(T element, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\nprotected static System.Collections.Generic.IEnumerable<TExpectation> RepeatAsManyAs<TExpectation>(TExpectation value, System.Collections.Generic.IEnumerable<T> enumerable) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Task Completion with Expected Result in C#\nDESCRIPTION: Shows how to verify both the timely completion of a TaskCompletionSource and its expected result value. This combines timeout validation with result verification in a single fluent assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/specialized.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar tcs = new TaskCompletionSource<bool>();\nawait tcs.Should().CompleteWithinAsync(1.Seconds()).WithResult(true);\n```\n\n----------------------------------------\n\nTITLE: Chaining Dictionary Assertions in C#\nDESCRIPTION: Shows how to chain multiple assertions together when working with dictionaries in Fluent Assertions. This allows for more complex validation, such as checking properties of dictionary values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/dictionaries.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ndictionary.Should().ContainValue(myClass)\n  .Which.SomeProperty.Should().BeGreaterThan(0);\n```\n\n----------------------------------------\n\nTITLE: Basic Event Monitoring in C#\nDESCRIPTION: Demonstrates how to monitor an object for events and assert that a specific event was raised or not raised. The Monitor() method wraps the subject object and tracks events raised during the using block's lifetime.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar subject = new EditCustomerViewModel();\nusing var monitoredSubject = subject.Monitor();\n\nsubject.Foo();\nmonitoredSubject.Should().Raise(\"NameChangedEvent\");\n\n// Or...\n\nmonitoredSubject.Should().NotRaise(\"SomeOtherEvent\");\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Generic Collections and Tasks in FluentAssertions\nDESCRIPTION: Provides extension methods for generic collections, functions, tasks, and comparable types to enable fluent assertions. These methods support validating collections, asynchronous operations, and comparable type instances.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Collections.GenericCollectionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<T> actualValue) { }\npublic static FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task<T>> action) { }\npublic static FluentAssertions.Specialized.FunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<T> func) { }\npublic static FluentAssertions.Numeric.ComparableTypeAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.IComparable<T> comparableValue) { }\npublic static FluentAssertions.Specialized.TaskCompletionSourceAssertions<T> Should<T>(this System.Threading.Tasks.TaskCompletionSource<T> tcs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Should() Extension Methods in C#\nDESCRIPTION: A set of generic extension methods that provide assertion capabilities for generic collections, async functions, functions, comparable types, and task completion sources. These methods enable type-safe assertions while maintaining the fluent API style.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Collections.GenericCollectionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<T> actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task<T>> action) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Specialized.FunctionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<T> func) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.ComparableTypeAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.IComparable<T> comparableValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Specialized.TaskCompletionSourceAssertions<T> Should<T>(this System.Threading.Tasks.TaskCompletionSource<T> tcs) { }\n```\n\n----------------------------------------\n\nTITLE: Object Equality Assertions in C#\nDESCRIPTION: Demonstrates how to assert that two objects are equal or not equal using the Object.Equals implementation. Includes optional reason parameters to explain expectations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstring otherObject = \"whatever\";\ntheObject.Should().Be(otherObject, \"because they have the same values\");\ntheObject.Should().NotBe(otherObject);\n```\n\n----------------------------------------\n\nTITLE: String Equivalency Options in C#\nDESCRIPTION: Shows how to customize string equivalency behavior with various options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ntheString.Should().BeEquivalentTo(\"This is a string\", o => o.IgnoringLeadingWhitespace());\n```\n\n----------------------------------------\n\nTITLE: Asserting Task Completion Within a Timeframe in C#\nDESCRIPTION: Demonstrates how to use FluentAssertions to verify that a TaskCompletionSource completes within a specified timeframe. This is useful for testing asynchronous operations with timeout requirements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/specialized.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar tcs = new TaskCompletionSource<bool>();\nawait tcs.Should().CompleteWithinAsync(1.Seconds());\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Order with FluentAssertions in C#\nDESCRIPTION: Demonstrates methods for asserting that collections are in ascending or descending order using default or custom comparers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ncollection.Should().BeInAscendingOrder();\ncollection.Should().BeInDescendingOrder();\ncollection.Should().NotBeInAscendingOrder();\ncollection.Should().NotBeInDescendingOrder();\n```\n\n----------------------------------------\n\nTITLE: Implementing ExceptionAssertions Class in C#\nDESCRIPTION: Class for asserting properties of exceptions, providing methods to examine exception messages, inner exceptions, and other properties through a fluent interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_170\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExceptionAssertions<TException> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Collections.Generic.IEnumerable<TException>, FluentAssertions.Specialized.ExceptionAssertions<TException>>\n    where TException : System.Exception\n{\n    public ExceptionAssertions(System.Collections.Generic.IEnumerable<TException> exceptions, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TException And { get; }\n    protected override string Identifier { get; }\n    public TException Which { get; }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> Where(System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerException(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerException<TInnerException>(string because = \"\", params object[] becauseArgs)\n        where TInnerException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerExceptionExactly(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerExceptionExactly<TInnerException>(string because = \"\", params object[] becauseArgs)\n        where TInnerException : System.Exception { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TException> WithMessage(string expectedWildcardPattern, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeAssertions Class in C#\nDESCRIPTION: This class provides methods for asserting various aspects of types, such as inheritance, decorations, constructors, and conversion operators.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_149\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Type, FluentAssertions.Types.TypeAssertions>\n{\n    public TypeAssertions(System.Type type, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be(System.Type expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be<TExpected>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAbstract(string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom(System.Type baseType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom<TBaseClass>(string because = \"\", params object[] becauseArgs)\n        where TBaseClass :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeStatic(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveDefaultConstructor(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty(System.Type interfaceType, string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty<TInterface>(string name, string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: String Content Assertions in C#\nDESCRIPTION: Comprehensive string content validation including equality, containment, and case-insensitive comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ntheString = \"This is a String\";\ntheString.Should().Be(\"This is a String\");\ntheString.Should().NotBe(\"This is another String\");\ntheString.Should().BeEquivalentTo(\"THIS IS A STRING\");\ntheString.Should().NotBeEquivalentTo(\"THIS IS ANOTHER STRING\");\n\ntheString.Should().BeOneOf(\n    \"That is a String\",\n    \"This is a String\",\n);\n\ntheString.Should().Contain(\"is a\");\ntheString.Should().Contain(\"is a\", Exactly.Once());\ntheString.Should().Contain(\"is a\", AtLeast.Twice());\ntheString.Should().Contain(\"is a\", MoreThan.Thrice());\ntheString.Should().Contain(\"is a\", AtMost.Times(5));\ntheString.Should().Contain(\"is a\", LessThan.Twice());\ntheString.Should().ContainAll(\"should\", \"contain\", \"all\", \"of\", \"these\");\ntheString.Should().ContainAny(\"any\", \"of\", \"these\", \"will\", \"do\");\ntheString.Should().NotContain(\"is a\");\ntheString.Should().NotContainAll(\"can\", \"contain\", \"some\", \"but\", \"not\", \"all\");\ntheString.Should().NotContainAny(\"can't\", \"contain\", \"any\", \"of\", \"these\");\ntheString.Should().ContainEquivalentOf(\"WE DONT CARE ABOUT THE CASING\");\ntheString.Should().ContainEquivalentOf(\"WE DONT CARE ABOUT THE CASING\", Exactly.Once());\ntheString.Should().ContainEquivalentOf(\"WE DONT CARE ABOUT THE CASING\", AtLeast.Twice());\ntheString.Should().ContainEquivalentOf(\"WE DONT CARE ABOUT THE CASING\", MoreThan.Thrice());\ntheString.Should().ContainEquivalentOf(\"WE DONT CARE ABOUT THE CASING\", AtMost.Times(5));\ntheString.Should().ContainEquivalentOf(\"WE DONT CARE ABOUT THE CASING\", LessThan.Twice());\ntheString.Should().NotContainEquivalentOf(\"HeRe ThE CaSiNg Is IgNoReD As WeLl\");\n\ntheString.Should().StartWith(\"This\");\ntheString.Should().NotStartWith(\"This\");\ntheString.Should().StartWithEquivalentOf(\"this\");\ntheString.Should().NotStartWithEquivalentOf(\"this\");\n\ntheString.Should().EndWith(\"a String\");\ntheString.Should().NotEndWith(\"a String\");\ntheString.Should().EndWithEquivalentOf(\"a string\");\ntheString.Should().NotEndWithEquivalentOf(\"a string\");\n```\n\n----------------------------------------\n\nTITLE: Using Custom Equality Comparers with FluentAssertions in C#\nDESCRIPTION: Demonstrates how to perform equality assertions with custom comparison logic through IEqualityComparer implementations. This allows for specialized comparison behavior beyond the default Equals method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ntheObject.Should().Be(otherObject, new ObjEqualityComparer());\ntheObject.Should().NotBe(otherObject, new ObjEqualityComparer());\ntheObject.Should().BeOneOf(new[] { obj1, obj2, obj3 }, new ObjEqualityComparer());\n```\n\n----------------------------------------\n\nTITLE: Asserting DateTime proximity with BeCloseTo in FluentAssertions\nDESCRIPTION: Demonstrates how to assert that a DateTime is within or not within a specific timespan of another DateTime. This is useful when exact matches aren't needed or when working with databases that might truncate date/time values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/datetimespans.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ntheDatetime.Should().BeCloseTo(1.March(2010).At(22, 15), 2.Seconds());\n\ntheDatetime.Should().NotBeCloseTo(2.March(2010), 1.Hours());\n```\n\n----------------------------------------\n\nTITLE: Disabling Strict Ordering for Specific Collections in FluentAssertions using C#\nDESCRIPTION: Example showing how to globally enable strict ordering but disable it for specific collections. Demonstrates the flexibility of the ordering configuration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(expectation, options => options.WithStrictOrdering().WithoutStrictOrderingFor(s => s.Products));\n```\n\n----------------------------------------\n\nTITLE: Asserting Task Non-Completion Within a Timeframe in C#\nDESCRIPTION: Demonstrates how to assert that a TaskCompletionSource does not complete within a specified timeframe. This is useful for testing operations that should take longer than a given time or timeout scenarios.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/specialized.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar tcs = new TaskCompletionSource<bool>();\nawait tcs.Should().NotCompleteWithinAsync(1.Seconds());\n```\n\n----------------------------------------\n\nTITLE: Asserting String Collection Does Not Contain Match in C#\nDESCRIPTION: Shows how to use the new NotContainMatch assertion for string collections to check for absence of wildcard pattern matches.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/releases.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nList<string> strings = new List<string> { \"apple\", \"banana\", \"cherry\" };\nstrings.Should().NotContainMatch(\"*berry\");\n```\n\n----------------------------------------\n\nTITLE: Defining StringAssertions Class in C#\nDESCRIPTION: This class provides assertion methods for string objects. It includes methods for comparing strings, checking their length, matching regular expressions, and verifying various string properties like emptiness and case.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringAssertions<TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<string, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.StringAssertions<TAssertions>\n{\n    public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLowerCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNullOrWhiteSpace(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params string[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<string> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeUpperCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAll(params string[] values) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAll(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAny(params string[] values) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAny(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWith(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveLength(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(string unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeLowerCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNullOrWhiteSpace(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeUpperCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(string unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainAll(params string[] values) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainAll(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainAny(params string[] values) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Type Attributes and Characteristics using FluentAssertions in C#\nDESCRIPTION: This snippet demonstrates how to assert various characteristics of types, including checking for attributes, inheritance, and class modifiers like abstract and static.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/typesandmethods.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ntypeof(MyPresentationModel).Should().BeDecoratedWith<SomeAttribute>();\n\ntypeof(MyPresentationModel)\n  .Should().BeDecoratedWithOrInherit<SomeInheritedOrDirectlyDecoratedAttribute>();\n\ntypeof(MyPresentationModel).Should().NotBeDecoratedWith<SomeAttribute>();\ntypeof(MyPresentationModel)\n  .Should().NotBeDecoratedWithOrInherit<SomeInheritedOrDirectlyDecoratedAttribute>();\n\ntypeof(MyBaseClass).Should().BeAbstract();\ntypeof(InjectedClass).Should().NotBeStatic();\n\nMethodInfo method = GetMethod();\nmethod.Should().BeVirtual();\n\nPropertyInfo property = GetSomeProperty();\nproperty.Should().BeVirtual()\n  .And.BeDecoratedWith<SomeAttribute>();\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Boolean Types in FluentAssertions\nDESCRIPTION: Provides extension methods for boolean and nullable boolean types to enable fluent assertions. These methods create assertion objects that provide validation operations for boolean values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.BooleanAssertions Should(this bool actualValue) { }\npublic static FluentAssertions.Primitives.NullableBooleanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this bool? actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Per-Element Assertions on Collections in C#\nDESCRIPTION: Shows how to perform individual assertions on specific elements of a collection while maintaining expected order using SatisfyRespectively.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar collection = new []\n{\n    new { Id = 1, Name = \"John\", Attributes = new string[] { } },\n    new { Id = 2, Name = \"Jane\", Attributes = new string[] { \"attr\" } }\n};\ncollection.Should().SatisfyRespectively(\n    first =>\n    {\n        first.Id.Should().Be(1);\n        first.Name.Should().StartWith(\"J\");\n        first.Attributes.Should().NotBeNull();\n    },\n    second =>\n    {\n        second.Id.Should().Be(2);\n        second.Name.Should().EndWith(\"e\");\n        second.Attributes.Should().NotBeEmpty();\n    });\n```\n\n----------------------------------------\n\nTITLE: Deep Comparison of XML Elements in C#\nDESCRIPTION: Demonstrates how to perform deep structural comparisons between XML documents and elements using the BeEquivalentTo assertion.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/xml.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nxDocument.Should().BeEquivalentTo(XDocument.Parse(\"<configuration><item>value</item></configuration>\"));\nxElement.Should().BeEquivalentTo(XElement.Parse(\"<item>value</item>\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Async Function Assertions in C#\nDESCRIPTION: This class provides methods for asserting properties of generic asynchronous functions. It includes methods to assert completion within a timespan, and methods to assert that no exceptions are thrown asynchronously.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_135\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericAsyncFunctionAssertions<TResult> : FluentAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task<TResult>, FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>>\n{\n    public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAsync(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped Directory Assertions in C#\nDESCRIPTION: Shows how to implement scoped assertions for checking files across subdirectories using AssertionScope for context-aware failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic AndConstraint<DirectoryInfoAssertions> ContainFileInAllSubdirectories(\n    string filename, string because, params object[] becauseArgs)\n{\n    foreach (DirectoryInfo subDirectory in Subject.GetDirectories())\n    {\n        using (new AssertionScope(subDirectory.FullName))\n        {\n            subDirectory.Should().ContainFile(filename, because, becauseArgs);\n        }\n    }\n\n    return new AndConstraint<DirectoryInfoAssertions>(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering and Asserting on Multiple Methods in FluentAssertions\nDESCRIPTION: This snippet shows how to perform assertions on multiple methods of a class by using filtering techniques to select specific methods based on their return types, accessibility, and attribute decorations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/typesandmethods.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ntypeof(MyPresentationModel).Methods()\n  .ThatArePublicOrInternal \n  .ThatReturnVoid\n  .Should()\n  .BeVirtual(\"because this is required to intercept exceptions\")\n    .And.BeWritable()\n    .And.BeAsync();\n\ntypeof(MyController).Methods()\n  .ThatDoNotReturn<ActionResult>()\n  .ThatAreNotDecoratedWith<HttpPostAttribute>()\n  .Should().NotBeVirtual()\n    .And.NotBeAsync()\n    .And.NotReturnVoid()\n    .And.NotReturn<ActionResult>();\n\ntypeof(MyController).Methods()\n  .ThatReturn<ActionResult>()\n  .ThatAreDecoratedWith<HttpPostAttribute>()\n  .Should()\n  .BeDecoratedWith<ValidateAntiForgeryTokenAttribute>(\n    \"because all Actions with HttpPost require ValidateAntiForgeryToken\");\n```\n\n----------------------------------------\n\nTITLE: Asserting Exception with Inner Exception in C#\nDESCRIPTION: Shows how to use FluentAssertions to check for an exception with a specific inner exception and message using the arrange-act-assert pattern.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nAction act = () => subject.Foo2(\"Hello\");\n\nact.Should().Throw<InvalidOperationException>()\n    .WithInnerException<ArgumentException>()\n    .WithMessage(\"whatever\");\n```\n\n----------------------------------------\n\nTITLE: Creating Abstract NumericAssertionsBase Class in C#\nDESCRIPTION: Defines an abstract base class for numeric assertions with generic type parameters. It provides common numeric assertion methods like comparison operations, type checks, and predicate matching that work with comparable value types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_97\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class NumericAssertionsBase<T, TSubject, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertionsBase<T, TSubject, TAssertions>\n{\n    protected NumericAssertionsBase(FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }\n    public abstract TSubject Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BePositive(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(T unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(T? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting No Exception Thrown in C#\nDESCRIPTION: Demonstrates how to verify that no exceptions are thrown during method execution using FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = () => subject.Foo(\"Hello\");\nact.Should().NotThrow();\n```\n\n----------------------------------------\n\nTITLE: Asserting DateTime differences with FluentAssertions in C#\nDESCRIPTION: Shows methods for asserting time differences between DateTime objects using a fluent syntax. These methods support Before and After extensions and provide various comparison operators like less than, within, more than, at least, and exactly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/datetimespans.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ntheDatetime.Should().BeLessThan(10.Minutes()).Before(otherDatetime); // Equivalent to <\ntheDatetime.Should().BeWithin(2.Hours()).After(otherDatetime);       // Equivalent to <=\ntheDatetime.Should().BeMoreThan(1.Days()).Before(deadline);          // Equivalent to >\ntheDatetime.Should().BeAtLeast(2.Days()).Before(deliveryDate);       // Equivalent to >=\ntheDatetime.Should().BeExactly(24.Hours()).Before(appointment);      // Equivalent to ==\n```\n\n----------------------------------------\n\nTITLE: Configuring Value Type Comparison for Specific Types\nDESCRIPTION: Shows how to override the default equivalency comparison behavior for specific types, making them compare by value rather than by their members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nsubject.Should().BeEquivalentTo(expected,\n   options => options.ComparingByValue<IPAddress>());\n```\n\n----------------------------------------\n\nTITLE: Asserting Value Matches One of Multiple Options in C#\nDESCRIPTION: Demonstrates the use of BeOneOf method to assert that a value matches one of the provided options. This works for numeric types and any type implementing IComparable<T>.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/numerictypes.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvalue.Should().BeOneOf(new[] { 3, 6 });\n```\n\n----------------------------------------\n\nTITLE: Asserting NaN for Floating-Point Values in C#\nDESCRIPTION: Shows how to assert that a floating-point value is or is not NaN (Not a Number) using the BeNaN and NotBeNaN methods.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/numerictypes.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nfloat value = float.NaN;\nvalue.Should().BeNaN();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nfloat value = float.NaN;\nvalue.Should().NotBeNaN();\n```\n\n----------------------------------------\n\nTITLE: Testing Nullable Types with FluentAssertions in C#\nDESCRIPTION: Demonstrates various assertion methods for testing nullable value types including shorts, integers, and dates. Shows how to check for null values, non-null values, and conditional matching using FluentAssertions syntax. Includes examples of NotHaveValue(), BeNull(), HaveValue(), and Match() assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/nullabletypes.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nshort? theShort = null;\ntheShort.Should().NotHaveValue();\ntheShort.Should().BeNull();\ntheShort.Should().Match(x => !x.HasValue || x > 0);\n\nint? theInt = 3;\ntheInt.Should().HaveValue();\ntheInt.Should().NotBeNull();\n\nDateTime? theDate = null;\ntheDate.Should().NotHaveValue();\ntheDate.Should().BeNull();\n```\n\n----------------------------------------\n\nTITLE: String Collection Assertions with Wildcards in C#\nDESCRIPTION: Demonstrates specialized assertion methods for string collections, including wildcard pattern matching with * (zero or more characters) and ? (exactly one character).\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<string> stringCollection = new[] { \"build succeeded\", \"test failed\" };\nstringCollection.Should().AllBe(\"build succeeded\");\nstringCollection.Should().ContainMatch(\"* failed\");\n```\n\n----------------------------------------\n\nTITLE: Nesting Named AssertionScopes for Structured Failures\nDESCRIPTION: Shows how to nest AssertionScopes with meaningful names to create hierarchical failure messages that provide context for the failing assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nusing var outerScope = new AssertionScope(\"Test1\");\nusing var innerScope = new AssertionScope(\"Test2\");\nnonEmptyList.Should().BeEmpty();\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Stream Properties with FluentAssertions in C#\nDESCRIPTION: Demonstrates how to assert various properties of a MemoryStream including writability, readability, seek capability, length and position. The example uses a read-only MemoryStream initialized with a 1024-byte buffer.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/streams.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar stream = new MemoryStream(new byte[1024], writable: false);\n\nstream.Should().NotBeWritable();\nstream.Should().BeReadable();\nstream.Should().BeReadOnly();\nstream.Should().BeSeekable();\n\nstream.Should().HaveLength(1024);\nstream.Should().HavePosition(0);\n```\n\n----------------------------------------\n\nTITLE: Collection Comparison Using Custom Equality in C#\nDESCRIPTION: Shows how to compare collections using custom equality logic with lambda expressions instead of relying on type's Equals() method, useful for comparing domain entities.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npersistedCustomers.Select(c => c.Name).Should().Equal(customers.Select(c => c.Name));\npersistedCustomers.Select(c => c.Name).Should().StartWith(customers.Select(c => c.Name));\npersistedCustomers.Select(c => c.Name).Should().EndWith(customers.Select(c => c.Name));\n\npersistedCustomers.Should().Equal(customers, (c1, c2) => c1.Name == c2.Name);\npersistedCustomers.Should().StartWith(customers, (c1, c2) => c1.Name == c2.Name);\npersistedCustomers.Should().EndWith(customers, (c1, c2) => c1.Name == c2.Name);\n```\n\n----------------------------------------\n\nTITLE: Time-Based Assertions for Execution Time in C#\nDESCRIPTION: Demonstrates the various time-based assertions available for execution time verification, including less than, greater than, and approximate time comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/executiontime.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nsomeAction.ExecutionTime().Should().BeLessThanOrEqualTo(200.Milliseconds());\nsomeAction.ExecutionTime().Should().BeLessThan(200.Milliseconds());\nsomeAction.ExecutionTime().Should().BeGreaterThan(100.Milliseconds());\nsomeAction.ExecutionTime().Should().BeGreaterThanOrEqualTo(100.Milliseconds());\nsomeAction.ExecutionTime().Should().BeCloseTo(150.Milliseconds(), 50.Milliseconds());\n```\n\n----------------------------------------\n\nTITLE: Capturing and Handling Assertion Failures with AssertionScope\nDESCRIPTION: Demonstrates how to collect assertion failures without throwing exceptions by using the Discard method of AssertionScope.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var scope = new AssertionScope())\n{\n    5.Should().Be(10);\n    // other assertion left out for brevity...\n\n    // Collect all the failure messages that occurred up to this point\n    string[] failures = scope.Discard();\n\n    // The closing brace will not throw any exceptions anymore\n}\n```\n\n----------------------------------------\n\nTITLE: Excluding Properties from All Collection Elements\nDESCRIPTION: Demonstrates how to exclude a specific property from all elements in a collection regardless of their index.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options =>\n    options.For(o => o.Products)\n           .Exclude(o => o.Status));\n```\n\n----------------------------------------\n\nTITLE: Collection Element Type Assertions in C#\nDESCRIPTION: Demonstrates assertions that apply to all elements in a collection, including type checking and object equivalence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<BaseType> collection = new BaseType[] { new DerivedType() };\n\ncollection.Should().AllBeAssignableTo<DerivedType>();\ncollection.Should().AllBeOfType<DerivedType>();\ncollection.Should().AllBeEquivalentTo(referenceObject);\n```\n\n----------------------------------------\n\nTITLE: Implementing BeNaN Methods for Floating-Point Assertions in C#\nDESCRIPTION: Extension methods for asserting that floating-point values are NaN (Not a Number). These methods support both float and double types in nullable and non-nullable variants. They allow for fluent assertion chaining through AndConstraint return type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Key-Value Pairs in Dictionaries in C#\nDESCRIPTION: Demonstrates how to assert that a dictionary contains or does not contain specific key-value pairs. This can be done using KeyValuePair objects or by specifying the key and value separately.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/dictionaries.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nKeyValuePair<int, string> item1 = new KeyValuePair<int, string>(1, \"One\");\nKeyValuePair<int, string> item2 = new KeyValuePair<int, string>(2, \"Two\");\n\ndictionary.Should().Contain(item1);\ndictionary.Should().Contain(item1, item2);\ndictionary.Should().Contain(2, \"Two\");\ndictionary.Should().NotContain(item1);\ndictionary.Should().NotContain(item1, item2);\ndictionary.Should().NotContain(9, \"Nine\");\n```\n\n----------------------------------------\n\nTITLE: Asserting Specific Exception Not Thrown in C#\nDESCRIPTION: Shows how to verify that a specific exception type is not thrown, while ignoring other exception types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = () => subject.Foo(\"Hello\");\nact.Should().NotThrow<InvalidOperationException>();\n```\n\n----------------------------------------\n\nTITLE: Including Specific Properties in Comparison\nDESCRIPTION: Demonstrates how to explicitly include only specific properties in the comparison, either by direct property expression or with a predicate.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => options\n    .Including(o => o.OrderNumber)\n    .Including(pi => pi.Name == \"Date\"));\n```\n\n----------------------------------------\n\nTITLE: Custom Comparison Behavior for Specific Members in FluentAssertions using C#\nDESCRIPTION: Example demonstrating how to override the default comparison behavior for specific members based on property path. Allows for custom assertions on specific properties like date comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => options\n    .Using<DateTime>(ctx => ctx.Subject.Should().BeCloseTo(ctx.Expectation, 1.Seconds()))\n    .When(info => info.Path.EndsWith(\"Date\")));\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionExtensions Static Class in C#\nDESCRIPTION: Defines a large set of extension methods for various types to enable fluent assertions. This includes methods for type conversion, asynchronous operations, enumerations, and specific assertions for different data types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionExtensions\n{\n    public static TTo As<TTo>(this object subject) { }\n    public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.Task> action) { }\n    public static System.Func<System.Threading.Tasks.Task> Awaiting<T>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask> action) { }\n    public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.Task<TResult>> action) { }\n    public static System.Func<System.Threading.Tasks.Task<TResult>> Awaiting<T, TResult>(this T subject, System.Func<T, System.Threading.Tasks.ValueTask<TResult>> action) { }\n    public static System.Action Enumerating(this System.Func<System.Collections.IEnumerable> enumerable) { }\n    public static System.Action Enumerating<T>(this System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }\n    public static System.Action Enumerating<T, TResult>(this T subject, System.Func<T, System.Collections.Generic.IEnumerable<TResult>> enumerable) { }\n    public static FluentAssertions.Specialized.ExecutionTime ExecutionTime(this System.Func<System.Threading.Tasks.Task> action) { }\n    public static FluentAssertions.Specialized.ExecutionTime ExecutionTime(this System.Action action, FluentAssertions.Common.StartTimer createTimer = null) { }\n    public static FluentAssertions.Specialized.MemberExecutionTime<T> ExecutionTimeOf<T>(this T subject, System.Linq.Expressions.Expression<System.Action<T>> action, FluentAssertions.Common.StartTimer createTimer = null) { }\n    public static System.Action Invoking<T>(this T subject, System.Action<T> action) { }\n    public static System.Func<TResult> Invoking<T, TResult>(this T subject, System.Func<T, TResult> action) { }\n    public static FluentAssertions.Specialized.ExecutionTimeAssertions Should(this FluentAssertions.Specialized.ExecutionTime executionTime) { }\n    [System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\n    public static void Should(this FluentAssertions.Specialized.ExecutionTimeAssertions _) { }\n    [System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\n    public static void Should(this FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase _) { }\n    public static FluentAssertions.Types.MethodInfoSelectorAssertions Should(this FluentAssertions.Types.MethodInfoSelector methodSelector) { }\n    [System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\n    public static void Should(this FluentAssertions.Types.MethodInfoSelectorAssertions _) { }\n    public static FluentAssertions.Types.PropertyInfoSelectorAssertions Should(this FluentAssertions.Types.PropertyInfoSelector propertyInfoSelector) { }\n    [System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\n    public static void Should(this FluentAssertions.Types.PropertyInfoSelectorAssertions _) { }\n    public static FluentAssertions.Types.TypeSelectorAssertions Should(this FluentAssertions.Types.TypeSelector typeSelector) { }\n    [System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\n    public static void Should(this FluentAssertions.Types.TypeSelectorAssertions _) { }\n    public static FluentAssertions.Specialized.ActionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Action action) { }\n    public static FluentAssertions.Collections.StringCollectionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<string> @this) { }\n    public static FluentAssertions.Primitives.DateTimeAssertions Should(this System.DateTime actualValue) { }\n    public static FluentAssertions.Primitives.NullableDateTimeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.DateTime? actualValue) { }\n    public static FluentAssertions.Primitives.DateTimeOffsetAssertions Should(this System.DateTimeOffset actualValue) { }\n    public static FluentAssertions.Primitives.NullableDateTimeOffsetAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.DateTimeOffset? actualValue) { }\n    public static FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Func<System.Threading.Tasks.Task> action) { }\n    public static FluentAssertions.Primitives.GuidAssertions Should(this System.Guid actualValue) { }\n    public static FluentAssertions.Primitives.NullableGuidAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Guid? actualValue) { }\n    public static FluentAssertions.Streams.BufferedStreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.BufferedStream actualValue) { }\n    public static FluentAssertions.Streams.StreamAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.IO.Stream actualValue) { }\n    public static FluentAssertions.Types.AssemblyAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.Assembly assembly) { }\n    public static FluentAssertions.Types.ConstructorInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.ConstructorInfo constructorInfo) { }\n    public static FluentAssertions.Types.MethodInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.MethodInfo methodInfo) { }\n    public static FluentAssertions.Types.PropertyInfoAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Reflection.PropertyInfo propertyInfo) { }\n    public static FluentAssertions.Primitives.SimpleTimeSpanAssertions Should(this System.TimeSpan actualValue) { }\n    public static FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.TimeSpan? actualValue) { }\n    public static FluentAssertions.Types.TypeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Type subject) { }\n    public static FluentAssertions.Xml.XAttributeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XAttribute actualValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable Enum Assertions in C#\nDESCRIPTION: Defines the NullableEnumAssertions class which extends EnumAssertions to provide assertion methods for nullable enum values. It includes methods to check for null, value presence, and enum-specific assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_114\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableEnumAssertions<TEnum, TAssertions> : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>\n    where TEnum :  struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, TAssertions>\n{\n    public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: FluentActions for Testing Behaviors in FluentAssertions (C#)\nDESCRIPTION: Static methods that wrap various actions and functions to facilitate testing behaviors including async operations and enumeration. These methods provide a convenient way to assert exceptions and behaviors from different operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class FluentActions\n{\n    public static System.Func<System.Threading.Tasks.Task> Awaiting(System.Func<System.Threading.Tasks.Task> action) { }\n    public static System.Func<System.Threading.Tasks.Task<T>> Awaiting<T>(System.Func<System.Threading.Tasks.Task<T>> func) { }\n    public static System.Action Enumerating(System.Func<System.Collections.IEnumerable> enumerable) { }\n    public static System.Action Enumerating<T>(System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }\n    public static System.Action Invoking(System.Action action) { }\n    public static System.Func<T> Invoking<T>(System.Func<T> func) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Fluent Downcasting with As<T> in C#\nDESCRIPTION: Demonstrates how to downcast an object to a derived type in a fluent manner using the As<T> extension method, allowing for continued assertion chains on the derived type's properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\ncustomer.Animals.First().As<Human>().Height.Should().Be(178);\n```\n\n----------------------------------------\n\nTITLE: Type Assignability and Predicate Matching in C#\nDESCRIPTION: Demonstrates how to check if an object is assignable to a specific type and how to use predicate functions to verify object properties with the Match method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar ex = new ArgumentException();\nex.Should().BeAssignableTo<Exception>(\"because it is an exception\");\nex.Should().NotBeAssignableTo<DateTime>(\"because it is an exception\");\n\nvar dummy = new Object();\ndummy.Should().Match(d => (d.ToString() == \"System.Object\"));\ndummy.Should().Match<string>(d => (d == \"System.Object\"));\ndummy.Should().Match((string d) => (d == \"System.Object\"));\n```\n\n----------------------------------------\n\nTITLE: ReferenceTypeAssertions Methods for Object Comparison in C#\nDESCRIPTION: Provides methods for asserting various conditions on reference types, including object identity comparison, type checking, null checking, and predicate matching. These methods support the fluent API pattern with customizable error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeSameAs(TSubject expected, string because = \"\", params object[] becauseArgs) { }\npublic override bool Equals(object obj) { }\npublic FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TSubject, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Match<T>(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs)\n    where T : TSubject { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeOfType<T>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeSameAs(TSubject unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Satisfy<T>(System.Action<T> assertion)\n    where T : TSubject { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Exceptions in Yielded Enumerables in C#\nDESCRIPTION: Demonstrates how to assert exceptions in methods that return IEnumerable or IEnumerable<T> and use the yield keyword.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<IEnumerable<char>> func = () => obj.SomeMethodThatUsesYield(\"blah\");\nfunc.Enumerating().Should().Throw<ArgumentException>();\n```\n\n----------------------------------------\n\nTITLE: Importing Fluent Assertions Namespace in C#\nDESCRIPTION: Imports the FluentAssertions namespace to bring extension methods into the current scope, enabling the fluent assertion syntax in tests.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing FluentAssertions;\n```\n\n----------------------------------------\n\nTITLE: Using Custom IEqualityComparer with BeEquivalentTo in C#\nDESCRIPTION: Demonstrates how to use a custom IEqualityComparer with the BeEquivalentTo assertion for more flexible object comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/releases.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nobj1.Should().BeEquivalentTo(obj2, options => options.Using<MyType>(new MyCustomComparer()));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Enum Assertion Behavior Changes in Fluent Assertions v6\nDESCRIPTION: Code example showing the behavior differences between v5 and v6 when asserting enums, including enum equality issues when comparing across enum types and with integral values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum MyEnum { One = 1 }\npublic enum MyOtherEnum { One = 1 }\n\nMyEnum.One.Should().Be(MyEnum.One);\n\nMyEnum.One.Should().Be(MyOtherEnum.One);\nMyEnum.One.Should().Be(1);\n1.As<object>().Should().Be(MyOtherEnum.One);\n```\n\n----------------------------------------\n\nTITLE: Collection Assertion with Custom Message in C#\nDESCRIPTION: An example of a collection assertion with a customized failure message using string formatting. The assertion checks if an array contains at least one item matching a condition, and includes a formatted explanation that will appear in the failure message.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/about.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar numbers = new[] { 1, 2, 3 };\nnumbers.Should().Contain(item => item > 3, \"at least {0} item should be larger than 3\", 1);\n```\n\n----------------------------------------\n\nTITLE: Implementing Delegate Assertions in C#\nDESCRIPTION: This abstract class extends DelegateAssertionsBase and provides methods for asserting that a delegate does not throw an exception, throws a specific exception, or throws an exact exception type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class DelegateAssertions<TDelegate, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>\n    where TDelegate : System.Delegate\n    where TAssertions : FluentAssertions.Specialized.DelegateAssertions<TDelegate, TAssertions>\n{\n    protected DelegateAssertions(TDelegate @delegate, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected abstract void InvokeSubject();\n    public FluentAssertions.AndConstraint<TAssertions> NotThrow<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> Throw<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowExactly<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeExtensions Static Class in C#\nDESCRIPTION: Extension methods that provide entry points to the fluent assertion API for types, methods, and properties. These methods allow for selecting and filtering types from assemblies and collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TypeExtensions\n{\n    public static FluentAssertions.Types.MethodInfoSelector Methods(this FluentAssertions.Types.TypeSelector typeSelector) { }\n    public static FluentAssertions.Types.MethodInfoSelector Methods(this System.Type type) { }\n    public static FluentAssertions.Types.PropertyInfoSelector Properties(this FluentAssertions.Types.TypeSelector typeSelector) { }\n    public static FluentAssertions.Types.PropertyInfoSelector Properties(this System.Type type) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Reflection.Assembly assembly) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Date and Time Component Assertion Methods in FluentAssertions\nDESCRIPTION: Methods for asserting that date/time components do not match specific values. These methods allow validating that a DateTime or DateTimeOffset does not have specific days, hours, minutes, months, offsets, seconds, or years.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_111\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveOffset(System.TimeSpan unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Serialization Assertions in C#\nDESCRIPTION: Shows how to verify that an object can be properly serialized and deserialized using XML serialization or data contract serialization in FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\ntheObject.Should().BeXmlSerializable();\ntheObject.Should().BeDataContractSerializable();\n```\n\n----------------------------------------\n\nTITLE: Regular Expression Assertions in C#\nDESCRIPTION: Demonstrates using regular expressions for advanced string pattern matching.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nsomeString.Should().MatchRegex(\"h.*\\\\sworld.$\");\nsomeString.Should().MatchRegex(new Regex(\"h.*\\\\sworld.$\"));\nsubject.Should().NotMatchRegex(new Regex(\".*earth.*\"));\nsubject.Should().NotMatchRegex(\".*earth.*\");\n```\n\n----------------------------------------\n\nTITLE: Asserting Collections with Custom Culture Comparisons in C#\nDESCRIPTION: Shows how to use culture-specific comparisons for collection ordering assertions, overriding the default StringComparer.Ordinal behavior introduced in v6.9.0.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ncollection.Should().BeInAscendingOrder(item => item.SomeProp, StringComparer.CurrentCulture);\ncollection.Should().BeInDescendingOrder(item => item.SomeProp, StringComparer.CurrentCulture);\ncollection.Should().NotBeInAscendingOrder(item => item.SomeProp, StringComparer.CurrentCulture);\ncollection.Should().NotBeInDescendingOrder(item => item.SomeProp, StringComparer.CurrentCulture);\n```\n\n----------------------------------------\n\nTITLE: Implementing Selection Rule in C#\nDESCRIPTION: Example implementation of IMemberSelectionRule interface showing how to select all public properties for equivalency assertion. Includes logic for member selection and custom ToString implementation for debugging.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\ninternal class AllPublicPropertiesSelectionRule : IMemberSelectionRule\n{\n    public bool IncludesMembers => false;\n\n    public IEnumerable<IMember> SelectMembers(INode currentNode\n        IEnumerable<IMember> selectedMembers, MemberSelectionContext context)\n    {\n            IEnumerable<IMember> selectedNonPrivateProperties = context.Type\n                .GetNonPrivateProperties()\n                .Select(info => new Property(info, currentNode));\n\n        return selectedMembers.Union(selectedNonPrivateProperties).ToList();\n    }\n\n    public override string ToString()\n    {\n        return \"Include all non-private properties\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Boolean Assertions in FluentAssertions\nDESCRIPTION: Shows how to use NotBeFalse() and NotBeTrue() methods in FluentAssertions, which are particularly useful for nullable booleans to ensure a value is neither true/false or null.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/booleans.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ntheBoolean.Should().NotBeFalse();\ntheBoolean.Should().NotBeTrue();\n```\n\n----------------------------------------\n\nTITLE: Using FluentActions for Concise Exception Assertions in C#\nDESCRIPTION: Demonstrates how to use the FluentActions static class for more concise exception assertions in a single statement.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nFluentActions.Invoking(() => MyClass.Create(null)).Should().Throw<ArgumentNullException>();\n```\n\n----------------------------------------\n\nTITLE: Type Assertion Extensions for FluentAssertions in C#\nDESCRIPTION: Collection of Should() extension methods providing assertion capabilities for various C# types. Includes support for primitives (bool, int, etc.), nullable types, collections, XML types, and custom assertions. Methods are marked with NotNull attribute where appropriate.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Types.TypeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Type subject) { }\npublic static FluentAssertions.Xml.XAttributeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XAttribute actualValue) { }\npublic static FluentAssertions.Xml.XDocumentAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XDocument actualValue) { }\npublic static FluentAssertions.Xml.XElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XElement actualValue) { }\npublic static FluentAssertions.Primitives.BooleanAssertions Should(this bool actualValue) { }\npublic static FluentAssertions.Primitives.NullableBooleanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this bool? actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Asserting Exceptions in Async Methods in C#\nDESCRIPTION: Shows an alternative way to assert exceptions in asynchronous methods using the Awaiting method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = asyncObject.Awaiting(x => x.ThrowAsync<ArgumentException>());\nawait act.Should().ThrowAsync<ArgumentException>();\n```\n\n----------------------------------------\n\nTITLE: PropertyChanged Event Monitoring Shortcut in C#\nDESCRIPTION: Demonstrates specialized shortcut methods for monitoring PropertyChanged events. These methods simplify verifying that a property change notification was raised or not raised for a specific property.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nmonitoredSubject.Should().RaisePropertyChangeFor(x => x.SomeProperty);\n```\n\n----------------------------------------\n\nTITLE: Asserting on Method Return Types in FluentAssertions\nDESCRIPTION: This code demonstrates how to assert on the properties of method return types, checking class contracts and ensuring immutability of return types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/typesandmethods.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ntypeof(MyDataReader).Methods()\n  .ReturnTypes()\n  .Properties()\n  .Should()\n  .NotBeWritable(\"all the return types should be immutable\");\n```\n\n----------------------------------------\n\nTITLE: Boolean Implication Assertion in FluentAssertions\nDESCRIPTION: Demonstrates the Imply() method which allows testing logical implication between boolean values, based on the mathematical concept of implication.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/booleans.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nbool anotherBoolean = true;\ntheBoolean.Should().Imply(anotherBoolean);\n```\n\n----------------------------------------\n\nTITLE: Asserting Approximate Inequality for Floating-Point Values in C#\nDESCRIPTION: Demonstrates the use of NotBeApproximately method to assert that a floating-point value is not within a specified range of another value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/numerictypes.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nfloat value = 3.5F;\nvalue.Should().NotBeApproximately(2.5F, 0.5F);\n```\n\n----------------------------------------\n\nTITLE: Testing BufferedStream Properties with FluentAssertions in C#\nDESCRIPTION: Shows how to test BufferedStream-specific properties using FluentAssertions, specifically focusing on buffer size assertions. The example creates a BufferedStream with a 1024-byte buffer and verifies its size.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/streams.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar stream = new BufferedStream(new MemoryStream(), 1024)\n\nsubject.Should().HaveBufferSize(1024);\nsubject.Should().NotHaveBufferSize(2048);\n```\n\n----------------------------------------\n\nTITLE: Implementing Numeric Assertion Methods in C#\nDESCRIPTION: Defines methods for asserting numeric values with comparisons like greater than, less than, in range, etc. These methods support chaining via AndConstraint return types and allow custom error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_134\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BePositive(string because = \"\", params object[] becauseArgs) { }\npublic override bool Equals(object obj) { }\npublic FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBe(T unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBe(T? unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Properties (C#)\nDESCRIPTION: These methods assert various properties of collections, such as emptiness, being a subset, and containing specific elements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeSubsetOf(System.Collections.Generic.IEnumerable<T> expectedSuperset, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> Contain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> Contain(T expected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting specific date and time components with FluentAssertions in C#\nDESCRIPTION: Demonstrates how to assert specific parts of DateTime and DateTimeOffset objects such as day, month, year, hour, minute, second, and timezone offset. These methods allow for targeted assertions when only certain date/time components matter.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/datetimespans.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ntheDatetime.Should().HaveDay(1);\ntheDatetime.Should().HaveMonth(3);\ntheDatetime.Should().HaveYear(2010);\ntheDatetime.Should().HaveHour(22);\ntheDatetime.Should().HaveMinute(15);\ntheDatetime.Should().HaveSecond(0);\n\ntheDatetime.Should().NotHaveDay(2);\ntheDatetime.Should().NotHaveMonth(4);\ntheDatetime.Should().NotHaveYear(2011);\ntheDatetime.Should().NotHaveHour(23);\ntheDatetime.Should().NotHaveMinute(16);\ntheDatetime.Should().NotHaveSecond(1);\n\nvar theDatetimeOffset = 1.March(2010).AsUtc().WithOffset(2.Hours());\n\ntheDatetimeOffset.Should().HaveOffset(2);\ntheDatetimeOffset.Should().NotHaveOffset(3);\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeApproximately Extension Methods in C#\nDESCRIPTION: Extension methods for asserting that numeric values are not approximately equal within a specified precision. Supports decimal, double, and float types with both nullable and non-nullable variants.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Assertion Classes in C#\nDESCRIPTION: Defines classes for DateTime assertions with methods for comparing dates, checking date components, and verifying time ranges. Supports nullable DateTimes and provides extensive methods for various date-time comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_137\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateTimeAssertions : FluentAssertions.Primitives.DateTimeAssertions<FluentAssertions.Primitives.DateTimeAssertions>\n{\n    public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class DateTimeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n{\n    public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTime? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTime nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeIn(System.DateTimeKind expectedKind, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTime[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTime>[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime?> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveHour(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMinute(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveSecond(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTime distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeIn(System.DateTimeKind unexpectedKind, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Filtering Event Assertions with Sender and Arguments in C#\nDESCRIPTION: Shows how to verify events with specific sender and event arguments. This example filters the PropertyChanged event to verify it was raised for a specific property with the expected sender.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nmonitoredSubject\n  .Should().Raise(\"PropertyChanged\")\n  .WithSender(subject)\n  .WithArgs<PropertyChangedEventArgs>(args => args.PropertyName == \"SomeProperty\");\n```\n\n----------------------------------------\n\nTITLE: Verifying Enum Integral Values in Fluent Assertions\nDESCRIPTION: Demonstrates how to verify that an enum has a specific integral value using the HaveValue method. This allows assertion against the underlying numeric value of an enum.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/enums.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nMyEnum.One.Should().HaveValue(1);\nMyEnum.One.Should().NotHaveValue(2);\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Numeric Types in FluentAssertions\nDESCRIPTION: Provides extension methods for various numeric types (byte, decimal, double, float, int, long, etc.) and their nullable counterparts to enable fluent assertions. These methods create specialized assertion objects for numeric validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Numeric.NumericAssertions<byte> Should(this byte actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<byte> Should([System.Diagnostics.CodeAnalysis.NotNull] this byte? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<decimal> Should(this decimal actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<decimal> Should([System.Diagnostics.CodeAnalysis.NotNull] this decimal? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<double> Should(this double actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<double> Should([System.Diagnostics.CodeAnalysis.NotNull] this double? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<float> Should(this float actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<float> Should([System.Diagnostics.CodeAnalysis.NotNull] this float? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<int> Should(this int actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<int> Should([System.Diagnostics.CodeAnalysis.NotNull] this int? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<long> Should(this long actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<long> Should([System.Diagnostics.CodeAnalysis.NotNull] this long? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<sbyte> Should(this sbyte actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<sbyte> Should([System.Diagnostics.CodeAnalysis.NotNull] this sbyte? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<short> Should(this short actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<short> Should([System.Diagnostics.CodeAnalysis.NotNull] this short? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<uint> Should(this uint actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<uint> Should([System.Diagnostics.CodeAnalysis.NotNull] this uint? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<ulong> Should(this ulong actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<ulong> Should([System.Diagnostics.CodeAnalysis.NotNull] this ulong? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<ushort> Should(this ushort actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<ushort> Should([System.Diagnostics.CodeAnalysis.NotNull] this ushort? actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Basic Boolean Assertions in FluentAssertions\nDESCRIPTION: Demonstrates the basic assertions for boolean values in FluentAssertions, including BeFalse(), BeTrue(), Be(), and NotBe() methods. These methods can be used to verify expected boolean states with optional failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/booleans.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nbool theBoolean = false;\ntheBoolean.Should().BeFalse(\"it's set to false\");\n\ntheBoolean = true;\ntheBoolean.Should().BeTrue();\ntheBoolean.Should().Be(otherBoolean);\ntheBoolean.Should().NotBe(false);\n```\n\n----------------------------------------\n\nTITLE: IEquivalencyOptions Interface Definition in C#\nDESCRIPTION: Defines configuration options for equivalency comparisons, including case sensitivity, whitespace handling, member visibility, and custom rules for comparing different types of objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_74\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEquivalencyOptions\n{\n    bool AllowInfiniteRecursion { get; }\n    bool? CompareRecordsByValue { get; }\n    FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    FluentAssertions.Equivalency.CyclicReferenceHandling CyclicReferenceHandling { get; }\n    FluentAssertions.Equivalency.EnumEquivalencyHandling EnumEquivalencyHandling { get; }\n    bool ExcludeNonBrowsableOnExpectation { get; }\n    bool IgnoreCase { get; }\n    bool IgnoreLeadingWhitespace { get; }\n    bool IgnoreNewlineStyle { get; }\n    bool IgnoreNonBrowsableOnSubject { get; }\n    bool IgnoreTrailingWhitespace { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }\n    bool IsRecursive { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberMatchingRule> MatchingRules { get; }\n    FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberSelectionRule> SelectionRules { get; }\n    FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }\n    bool UseRuntimeTyping { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep> UserEquivalencySteps { get; }\n    FluentAssertions.Equivalency.EqualityStrategy GetEqualityStrategy(System.Type type);\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Exceptions in Async Methods in C#\nDESCRIPTION: Demonstrates how to verify that an asynchronously executed method throws or doesn't throw an exception using FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = () => asyncObject.ThrowAsync<ArgumentException>();\nawait act.Should().ThrowAsync<InvalidOperationException>();\nawait act.Should().NotThrowAsync();\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Equality (C#)\nDESCRIPTION: These methods assert equality between collections, allowing for custom equality comparisons and different types of expectations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> Equal(params T[] elements) { }\npublic FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Equal<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Custom String Comparison in C#\nDESCRIPTION: Demonstrates using custom string comparers for equivalency checks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ntheString.Should().BeEquivalentTo(\"THIS IS A STRING\", o => o.Using(StringComparer.OrdinalIgnoreCase));\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Graph Inequality in C#\nDESCRIPTION: Shows how to verify that two object graphs are not structurally equivalent using the NotBeEquivalentTo method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().NotBeEquivalentTo(order);\n```\n\n----------------------------------------\n\nTITLE: Excluding Missing Members from Comparison\nDESCRIPTION: Demonstrates how to compare only the members that both object graphs have in common, ignoring members that exist in one but not the other.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => \n    options.ExcludingMissingMembers());\n```\n\n----------------------------------------\n\nTITLE: Implementing EventAssertions<T> in C#\nDESCRIPTION: Defines the EventAssertions<T> class which extends ReferenceTypeAssertions. It provides methods for asserting event raising and property changes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventAssertions<T> : FluentAssertions.Primitives.ReferenceTypeAssertions<T, FluentAssertions.Events.EventAssertions<T>>\n{\n    protected EventAssertions(FluentAssertions.Events.IMonitor<T> monitor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.Events.IMonitor<T> Monitor { get; }\n    public void NotRaise(string eventName, string because = \"\", params object[] becauseArgs) { }\n    public void NotRaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Events.IEventRecording Raise(string eventName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Events.IEventRecording RaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Element Assertions in C#\nDESCRIPTION: Methods for asserting collection elements, including containment, count verification, and element positioning checks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\n\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> ContainSingle(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Assertions in C#\nDESCRIPTION: Generic class that provides assertion methods specific to DateTime values. It includes methods for comparing dates (BeAfter, BeBefore), checking proximity (BeCloseTo), and validating time ranges.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_107\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n{\n    public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTime? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTime nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeIn(System.DateTimeKind expectedKind, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTime[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTime>[] validValues) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeOnly Assertions Implementation in C#\nDESCRIPTION: Defines assertion methods for TimeOnly type including comparisons, validations and time component checks. Implements a fluent interface pattern for chaining assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic class TimeOnlyAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.TimeOnlyAssertions<TAssertions>\n{\n    public TimeOnlyAssertions(System.TimeOnly? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.TimeOnly? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeOnly expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.TimeOnly expected, string because = \"\", params object[] becauseArgs) { }\n    // ... additional methods\n}\n```\n\n----------------------------------------\n\nTITLE: Ordering Assertions in FluentAssertions C#\nDESCRIPTION: Extension methods for asserting collection ordering including ascending and descending order checks with optional custom comparers and property selectors.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting TimeSpan proximity with BeCloseTo in FluentAssertions\nDESCRIPTION: Shows how to use BeCloseTo and NotBeCloseTo assertions with TimeSpan objects to check if they are within a specified precision of each other. This is useful when exact TimeSpan matches aren't required.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/datetimespans.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ntimeSpan.Should().BeCloseTo(new TimeSpan(13, 0, 0), 10.Ticks());\ntimeSpan.Should().NotBeCloseTo(new TimeSpan(14, 0, 0), 10.Ticks());\n```\n\n----------------------------------------\n\nTITLE: Global Configuration Settings for FluentAssertions using C#\nDESCRIPTION: Example demonstrating how to set global configuration options for all equivalency comparisons. Shows how to modify default behavior across an entire test suite.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\nAssertionConfiguration.Current.Equivalency.Modify(options => \n   options.ComparingEnumsByName);\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific Properties from Comparison\nDESCRIPTION: Shows how to exclude specific properties from the comparison using lambda expressions to identify the property path.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => \n    options.Excluding(o => o.Customer.Name));\n```\n\n----------------------------------------\n\nTITLE: Implementing FluentActions Utility Class in C#\nDESCRIPTION: A static utility class that provides methods for wrapping actions and functions in a way that allows assertion of their behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentActions\n{\n    public static System.Func<System.Threading.Tasks.Task> Awaiting(System.Func<System.Threading.Tasks.Task> action) { }\n    public static System.Func<System.Threading.Tasks.Task<T>> Awaiting<T>(System.Func<System.Threading.Tasks.Task<T>> func) { }\n    public static System.Action Enumerating(System.Func<System.Collections.IEnumerable> enumerable) { }\n    public static System.Action Enumerating<T>(System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }\n    public static System.Action Invoking(System.Action action) { }\n    public static System.Func<T> Invoking<T>(System.Func<T> func) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Assertions on Guid Objects with FluentAssertions in C#\nDESCRIPTION: This snippet demonstrates various Guid assertions using FluentAssertions. It shows how to check if Guids are equal or not equal to other Guids, verify that a Guid is not empty, confirm that a Guid is empty, and perform equality checks against string representations of Guids.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/guids.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nGuid theGuid = Guid.NewGuid();\nGuid sameGuid = theGuid;\nGuid otherGuid = Guid.NewGuid();\n\ntheGuid.Should().Be(sameGuid);\ntheGuid.Should().NotBe(otherGuid);\ntheGuid.Should().NotBeEmpty();\n\nGuid.Empty.Should().BeEmpty();\n\ntheGuid.Should().Be(\"11111111-aaaa-bbbb-cccc-999999999999\");\ntheGuid.Should().NotBe(\"00000000-0000-0000-0000-000000000001\");\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeNaN Methods for Floating-Point Types in FluentAssertions\nDESCRIPTION: Extension methods that assert whether double and float values are NOT NaN (Not a Number). These methods work with both nullable and non-nullable types and support custom failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> NotBeNaN(this FluentAssertions.Numeric.NumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> NotBeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting PropertyChanged Event Was Not Raised in C#\nDESCRIPTION: Shows how to verify that a PropertyChanged event was not raised for a specific property using the NotRaisePropertyChangeFor method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nmonitoredSubject.Should().NotRaisePropertyChangeFor(x => x.SomeProperty);\n```\n\n----------------------------------------\n\nTITLE: Asserting ArgumentNullException with Parameter Name in C#\nDESCRIPTION: Illustrates how to verify that an ArgumentNullException is thrown with a specific parameter name using FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = () => subject.Foo(null);\n\nact.Should().Throw<ArgumentNullException>()\n    .WithParameterName(\"message\");\n```\n\n----------------------------------------\n\nTITLE: Defining GlobalConfiguration Class in C#\nDESCRIPTION: This class provides global configuration options for FluentAssertions, including equivalency and formatting settings, and test framework specification.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class GlobalConfiguration\n{\n    public GlobalConfiguration() { }\n    public FluentAssertions.Configuration.GlobalEquivalencyOptions Equivalency { get; set; }\n    public FluentAssertions.Configuration.GlobalFormattingOptions Formatting { get; set; }\n    public FluentAssertions.Configuration.TestFramework? TestFramework { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Uniform Assertions on All Collection Elements in C#\nDESCRIPTION: Demonstrates how to apply the same assertions to all elements in a collection using AllSatisfy.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar collection = new []\n{\n    new { Id = 1, Name = \"John\", Attributes = new string[] { } },\n    new { Id = 2, Name = \"Jane\", Attributes = new string[] { \"attr\" } }\n};\ncollection.Should().AllSatisfy(x =>\n{\n    x.Id.Should().BePositive();\n    x.Name.Should().StartWith(\"J\");\n    x.Attributes.Should().NotBeNull();\n});\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Task and Enumerable Return Types in FluentAssertions\nDESCRIPTION: This snippet shows how to unwrap IEnumerable<T> or Task<T> return types to perform assertions on the underlying types' properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/typesandmethods.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ntypeof(MyDataReader).Methods()\n  .ReturnTypes()\n  .UnwrapTaskTypes()\n  .UnwrapEnumerableTypes()\n  .Properties()\n  .Should()\n  .NotBeWritable(\"all the return types should be immutable\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Collection Ordering in FluentAssertions using C#\nDESCRIPTION: Example showing how to enforce strict ordering when comparing collections. By default, FluentAssertions ignores item order in collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(expectation, options => options.WithStrictOrdering());\n```\n\n----------------------------------------\n\nTITLE: Object Graph Equivalence in Collections with FluentAssertions in C#\nDESCRIPTION: Shows how to assert presence of equivalent items in a collection using object graph comparison rules rather than reference equality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ncollection.Should().ContainEquivalentOf(boxedValue);\ncollection.Should().NotContainEquivalentOf(unexpectedBoxedValue);\n```\n\n----------------------------------------\n\nTITLE: Excluding Properties by Path Expression\nDESCRIPTION: Demonstrates how to exclude properties using a context-based predicate that examines the full path to the property.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => options \n    .Excluding(ctx => ctx.Path == \"Level.Level.Text\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeAssertions Class for FluentAssertions in C#\nDESCRIPTION: This class extends DateTimeAssertions<DateTimeAssertions> to provide assertion methods for DateTime objects. It's a concrete implementation of the generic DateTimeAssertions class in the FluentAssertions library.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeAssertions : FluentAssertions.Primitives.DateTimeAssertions<FluentAssertions.Primitives.DateTimeAssertions>\n{\n    public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: AtLeast Occurrence Constraints in FluentAssertions (C#)\nDESCRIPTION: Static methods for creating occurrence constraints that specify a minimum number of expected occurrences. These constraints are used with event monitoring and collection assertions to verify minimum occurrence requirements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class AtLeast\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Dictionary Count in C#\nDESCRIPTION: Shows how to validate the number of items in a dictionary using Fluent Assertions. This includes checking for exact counts and comparing counts between dictionaries or between a dictionary and a collection.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/dictionaries.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ndictionary.Should().HaveCount(2);\ndictionary.Should().NotHaveCount(3);\n\ndictionary1.Should().HaveSameCount(dictionary2);\ndictionary1.Should().NotHaveSameCount(dictionary3);\n\ndictionary1.Should().HaveSameCount(dictionary2.Keys);\ndictionary1.Should().NotHaveSameCount(dictionary3.Keys);\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Assertion Extensions\nDESCRIPTION: Extension methods for asserting exception conditions including inner exceptions, messages and parameter names. Supports async operations with Task return types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithMessage<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string expectedWildcardPattern, string because = \"\", params object[] becauseArgs)\n            where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Equivalent Content in Collections (C#)\nDESCRIPTION: These methods assert that a collection contains equivalent elements, allowing for custom equivalency options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Excluding Multiple Properties with Anonymous Objects\nDESCRIPTION: Demonstrates how to exclude multiple properties at once using an anonymous object syntax, which is more concise than chaining multiple Excluding() calls.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => \n    options.Excluding(o => new { o.Customer.Name, o.Customer.LastName, o.Vat }));\n```\n\n----------------------------------------\n\nTITLE: Character Case Validation in C#\nDESCRIPTION: Alternative approach for case validation using character-level assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ntheString.Should().OnlyContain(char.IsUpper);\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Assertions in C#\nDESCRIPTION: Defines the EventAssertions class that provides methods to verify event raising behaviors. It allows asserting that events are raised or not raised, including property change events.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventAssertions<T> : FluentAssertions.Primitives.ReferenceTypeAssertions<T, FluentAssertions.Events.EventAssertions<T>>\n    {\n        protected EventAssertions(FluentAssertions.Events.IMonitor<T> monitor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.Events.IMonitor<T> Monitor { get; }\n        public void NotRaise(string eventName, string because = \"\", params object[] becauseArgs) { }\n        public void NotRaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.Events.IEventRecording Raise(string eventName, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.Events.IEventRecording RaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Asserting TimeSpan objects with FluentAssertions in C#\nDESCRIPTION: Examples of assertions specific to TimeSpan objects, including sign checking (positive/negative), equality, inequality, and comparison operations like less than and greater than. Shows the fluent syntax using methods like Hours().\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/datetimespans.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar timeSpan = new TimeSpan(12, 59, 59);\ntimeSpan.Should().BePositive();\ntimeSpan.Should().BeNegative();\ntimeSpan.Should().Be(12.Hours());\ntimeSpan.Should().NotBe(1.Days());\ntimeSpan.Should().BeLessThan(someOtherTimeSpan);\ntimeSpan.Should().BeLessThanOrEqualTo(someOtherTimeSpan);\ntimeSpan.Should().BeGreaterThan(someOtherTimeSpan);\ntimeSpan.Should().BeGreaterThanOrEqualTo(someOtherTimeSpan);\n```\n\n----------------------------------------\n\nTITLE: Ignoring Broken Event Accessors in C#\nDESCRIPTION: Demonstrates how to configure the event monitor to ignore exceptions thrown by event accessors. This is useful when you're not interested in events that might throw exceptions during subscription or unsubscription.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar subject = new EditCustomerViewModel();\nusing var monitoredSubject = subject.Monitor(options => options.IgnoreEventAccessorExceptions());\n```\n\n----------------------------------------\n\nTITLE: DateTime Extension Methods in C#\nDESCRIPTION: Provides extension methods for DateTime and DateTimeOffset manipulation, including microsecond and nanosecond precision, and fluent date creation syntax.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_87\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class FluentDateTimeExtensions\n{\n    public static System.DateTime AddMicroseconds(this System.DateTime self, long microseconds) { }\n    public static System.DateTimeOffset AddMicroseconds(this System.DateTimeOffset self, long microseconds) { }\n    public static System.DateTime AddNanoseconds(this System.DateTime self, long nanoseconds) { }\n    // ... additional methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionScope Class in C#\nDESCRIPTION: Defines the AssertionScope class which implements IDisposable to provide a scoped context for assertions. It includes various constructors, properties for formatting options and current scope, and methods for handling assertion failures.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_112\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssertionScope : System.IDisposable\n{\n    public AssertionScope() { }\n    public AssertionScope(FluentAssertions.Execution.IAssertionStrategy assertionStrategy) { }\n    public AssertionScope(System.Func<string> name) { }\n    public AssertionScope(string name) { }\n    public FluentAssertions.Formatting.FormattingOptions FormattingOptions { get; }\n    public System.Func<string> Name { get; }\n    public static FluentAssertions.Execution.AssertionScope Current { get; }\n    public void AddPreFormattedFailure(string formattedFailureMessage) { }\n    public void AppendTracing(string tracingBlock) { }\n    public string[] Discard() { }\n    public void Dispose() { }\n    public bool HasFailures() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Endings (C#)\nDESCRIPTION: These methods assert that a collection ends with specific elements or sequences.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> EndWith(System.Collections.Generic.IEnumerable<T> expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> EndWith(T element, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> EndWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Equivalency Assertions with Interfaces in C#\nDESCRIPTION: Illustrates how equivalency assertions work with interfaces in FluentAssertions 6.0. Shows different scenarios of comparing objects implementing interfaces and how the assertions behave.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I\n{\n    int II { get; set; }\n}\n\nclass A : I\n{\n    public int II { get; set; }\n    public int AA { get; set; }\n}\n\nA[] items = new[] { new A() { AA = 42 } };\n\nitems.Should().BeEquivalentTo((I)new A()); // (1)\nitems.Should().BeEquivalentTo(new I[] { new A() }); // (2)\nitems.Should().BeEquivalentTo(new List<I> { new A() }); // (3)\nitems.Should().BeEquivalentTo(new I[] { new A() }, opt => opt); // (4)\n```\n\n----------------------------------------\n\nTITLE: Order-Independent Element Assertions in C#\nDESCRIPTION: Shows how to verify that a collection contains elements satisfying specific conditions without caring about the order using Satisfy.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar collection = new []\n{\n    new { Id = 1, Name = \"John\", Attributes = new string[] { } },\n    new { Id = 2, Name = \"Jane\", Attributes = new string[] { \"attr\" } }\n};\n\ncollection.Should().Satisfy(\n    e => e.Id == 2 && e.Name == \"Jane\" && e.Attributes == null,\n    e => e.Id == 1 && e.Name == \"John\" && e.Attributes != null && e.Attributes.Length > 0);\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionChain in C#\nDESCRIPTION: Class that implements the fluent assertion chain pattern in FluentAssertions. It provides methods for condition checking, failure reporting, and customizing assertion messages with a fluent API design.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_110\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssertionChain\n{\n    public string CallerIdentifier { get; }\n    public bool HasOverriddenCallerIdentifier { get; }\n    public bool Succeeded { get; }\n    public FluentAssertions.Execution.AssertionChain UsingLineBreaks { get; }\n    public void AddReportable(string key, System.Func<string> getValue) { }\n    public void AddReportable(string key, string value) { }\n    public FluentAssertions.Execution.AssertionChain BecauseOf(FluentAssertions.Execution.Reason reason) { }\n    public FluentAssertions.Execution.AssertionChain BecauseOf(string because, params object[] becauseArgs) { }\n    public FluentAssertions.Execution.Continuation FailWith(System.Func<FluentAssertions.Execution.FailReason> getFailureReason) { }\n    public FluentAssertions.Execution.Continuation FailWith(string message) { }\n    public FluentAssertions.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders) { }\n    public FluentAssertions.Execution.Continuation FailWith(string message, params object[] args) { }\n    public FluentAssertions.Execution.AssertionChain ForCondition(bool condition) { }\n    public FluentAssertions.Execution.AssertionChain ForConstraint(FluentAssertions.OccurrenceConstraint constraint, int actualOccurrences) { }\n    public FluentAssertions.Execution.GivenSelector<T> Given<T>(System.Func<T> selector) { }\n    public void OverrideCallerIdentifier(System.Func<string> getCallerIdentifier) { }\n    public void ReuseOnce() { }\n    public FluentAssertions.Execution.AssertionChain WithCallerPostfix(string postfix) { }\n    public FluentAssertions.Execution.AssertionChain WithDefaultIdentifier(string identifier) { }\n    public FluentAssertions.Execution.Continuation WithExpectation(string message, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n    public FluentAssertions.Execution.Continuation WithExpectation(string message, object arg1, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Collection Assertions Classes in C#\nDESCRIPTION: Classes for making assertions on collections with different levels of type constraints. These classes provide methods for asserting collection properties, ordering, element types, and equivalence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nnamespace FluentAssertions.Collections\n{\n    public class GenericCollectionAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T, FluentAssertions.Collections.GenericCollectionAssertions<T>>\n    {\n        public GenericCollectionAssertions(System.Collections.Generic.IEnumerable<T> actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    }\n    public class GenericCollectionAssertions<TCollection, T> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T>>\n        where TCollection : System.Collections.Generic.IEnumerable<T>\n    {\n        public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    }\n    public class GenericCollectionAssertions<TCollection, T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TCollection, TAssertions>\n        where TCollection : System.Collections.Generic.IEnumerable<T>\n        where TAssertions : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>\n    {\n        public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.AndConstraint<TAssertions> AllBeAssignableTo(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeAssignableTo<TExpectation>(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> AllBeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeOfType<TExpectation>(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> AllSatisfy(System.Action<T> expected, string because = \"\", params object[] becauseArgs) { }\n        protected void AssertCollectionEndsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actual, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n        protected void AssertCollectionStartsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actualItems, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n        protected void AssertSubjectEquality<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(string because = \"\", params object[] becauseArgs) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Assertion Base Class in C#\nDESCRIPTION: Defines the base class for dictionary assertions that provides common assertion methods for dictionary-like collections. Includes methods for comparing dictionaries, checking keys and values, and other dictionary-specific assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, System.Collections.Generic.KeyValuePair<TKey, TValue>, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n    where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.KeyValuePair<TKey, TValue> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(TKey key, TValue value, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Collections.WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(params TKey[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(System.Collections.Generic.IEnumerable<TKey> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TValue> ContainValue(TValue expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(params TValue[] expected) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(System.Collections.Generic.IEnumerable<TValue> expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NumericAssertions Class in C#\nDESCRIPTION: Defines a NumericAssertions class that extends NumericAssertions<T, TAssertions> for implementing fluent assertions for non-nullable numeric types. It provides a constructor that accepts a value and an AssertionChain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_98\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NumericAssertions<T> : FluentAssertions.Numeric.NumericAssertions<T, FluentAssertions.Numeric.NumericAssertions<T>>\n    where T :  struct, System.IComparable<T>\n{\n    public NumericAssertions(T value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic ComparableTypeAssertions Base Class in C#\nDESCRIPTION: Implements a generic base class for comparable type assertions that provides various comparison methods. This class extends ReferenceTypeAssertions and includes methods for equality, range, and comparison operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_94\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ComparableTypeAssertions<T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.IComparable<T>, TAssertions>\n    where TAssertions : FluentAssertions.Numeric.ComparableTypeAssertions<T, TAssertions>\n{\n    public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params T[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<T> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeRankedEquallyTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(T unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeRankedEquallyTo(T unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SubsequentOrderingAssertions Class in C#\nDESCRIPTION: This class extends GenericCollectionAssertions to provide methods for asserting the ordering of elements in a collection, including ascending and descending order checks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class SubsequentOrderingAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T>\n{\n    public SubsequentOrderingAssertions(System.Collections.Generic.IEnumerable<T> actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Event Monitor Details Directly in C#\nDESCRIPTION: Demonstrates direct interaction with the monitor using GetRecordingFor, MonitoredEvents, and OccurredEvents. This example shows how to examine monitored events and create custom assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar eventSource = new ClassThatRaisesEventsItself();\n\nusing IMonitor monitor = eventSource.Monitor<IEventRaisingInterface>();\n\nEventMetadata[] metadata = monitor.MonitoredEvents;\n\nmetadata.Should().BeEquivalentTo(new[]\n{\n    new\n    {\n        EventName = nameof(IEventRaisingInterface.InterfaceEvent),\n        HandlerType = typeof(EventHandler)\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing BeTrue assertion with AssertionChain in v8.0\nDESCRIPTION: Updated implementation of the BeTrue assertion method using AssertionChain instead of Execute.Assertion in v8.0. This demonstrates the new pattern for building assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic AndConstraint<TAssertions> BeTrue(string because = \"\", params object[] becauseArgs)\n{\n    assertionChain\n        .ForCondition(Subject == true)\n        .BecauseOf(because, becauseArgs)\n        .FailWith(\"Expected {context:boolean} to be {0}{reason}, but found {1}.\", true, Subject);\n\n    return new AndConstraint<TAssertions>((TAssertions)this);\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Task Completion with Result in C#\nDESCRIPTION: Shows how to use the new WithResult extension method to assert task completion with a specific result.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/releases.md#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nawait task.Should().CompleteWithinAsync(TimeSpan.FromSeconds(1)).WithResult(expectedResult);\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic ObjectAssertions in C#\nDESCRIPTION: Defines a generic class for assertions on object values, extending ReferenceTypeAssertions. Provides methods for equality, equivalence, and type checking with various overloads for custom comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_134\n\nLANGUAGE: C#\nCODE:\n```\npublic class ObjectAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.ObjectAssertions<TSubject, TAssertions>\n{\n    public ObjectAssertions(TSubject value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TSubject[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Assembly References in C#\nDESCRIPTION: Demonstrates how to verify if one assembly references another or explicitly does not reference it. These assertions are useful for enforcing architectural boundaries between different layers of an application.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/assemblies.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nassembly.Should().Reference(otherAssembly);\nassembly.Should().NotReference(otherAssembly);\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyValidationContext Class in C#\nDESCRIPTION: Implements the IEquivalencyValidationContext interface to provide context information during equivalency validation, including the current node being validated, options, and trace information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_44\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyValidationContext : FluentAssertions.Equivalency.IEquivalencyValidationContext\n{\n    public EquivalencyValidationContext(FluentAssertions.Equivalency.INode root, FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public FluentAssertions.Equivalency.INode CurrentNode { get; }\n    public FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    public FluentAssertions.Execution.Reason Reason { get; set; }\n    public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; set; }\n    public FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext Clone() { }\n    public bool IsCyclicReference(object expectation) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Where Clause for Exception Assertion in C#\nDESCRIPTION: Demonstrates an alternative syntax for asserting exceptions using the Where method to check specific properties of the exception.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar act = () => subject.Foo(null);\nact.Should().Throw<ArgumentNullException>().Where(e => e.Message.StartsWith(\"did\"));\n```\n\n----------------------------------------\n\nTITLE: Exception Assertions Implementation in C#\nDESCRIPTION: Generic class for asserting exception conditions with support for inner exceptions and message validation. Inherits from ReferenceTypeAssertions and provides fluent methods for exception verification.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionAssertions<TException> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Collections.Generic.IEnumerable<TException>, FluentAssertions.Specialized.ExceptionAssertions<TException>>\n    where TException : System.Exception\n{\n    public ExceptionAssertions(System.Collections.Generic.IEnumerable<TException> exceptions, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TException And { get; }\n    protected override string Identifier { get; }\n    public TException Which { get; }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> Where(System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerException(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerException<TInnerException>(string because = \"\", params object[] becauseArgs)\n        where TInnerException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerExceptionExactly(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerExceptionExactly<TInnerException>(string because = \"\", params object[] becauseArgs)\n        where TInnerException : System.Exception { }\n    public virtual FluentAssertions.Specialized.ExceptionAssertions<TException> WithMessage(string expectedWildcardPattern, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Property and Field Inclusion Options\nDESCRIPTION: Shows different configuration options for including or excluding properties and fields, including internal members, in the comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n// Include properties (which is the default)\norderDto.Should().BeEquivalentTo(order, options => options\n    .IncludingProperties());\n\n// Include fields\norderDto.Should().BeEquivalentTo(order, options => options\n    .IncludingFields());\n\n// Include internal properties as well\norderDto.Should().BeEquivalentTo(order, options => options\n    .IncludingInternalProperties());\n\n// And the internal fields\norderDto.Should().BeEquivalentTo(order, options => options\n    .IncludingInternalFields());\n\n// Exclude Fields\norderDto.Should().BeEquivalentTo(order, options => options\n    .ExcludingFields());\n\n// Exclude Properties\norderDto.Should().BeEquivalentTo(order, options => options\n    .ExcludingProperties());\n```\n\n----------------------------------------\n\nTITLE: Updating Collection Assertions in C#\nDESCRIPTION: Demonstrates changes in collection assertions due to the removal of non-generic collection support. Shows how to adapt code to work with the new generic-focused API.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable subject;\n\nsubject.Should().HaveCount(42); // No longer compiles\nsubject.Cast<object>().Should().HaveCount(42);\n```\n\n----------------------------------------\n\nTITLE: Implementing BeCloseTo Extension Methods for Various Numeric Types in C#\nDESCRIPTION: These extension methods add the BeCloseTo assertion for different numeric types in FluentAssertions. They check if a numeric value is close to a specified value within a given delta.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte nearbyValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short nearbyValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int nearbyValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long nearbyValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte nearbyValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort nearbyValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint nearbyValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong nearbyValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Using FluentActions with Static Import for Exception Assertions in C#\nDESCRIPTION: Shows how to make exception assertions even more concise by using a static import of FluentActions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nusing static FluentAssertions.FluentActions;\n\n...\n\nInvoking(() => MyClass.Create(null)).Should().Throw<ArgumentNullException>();\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionChain Class for Fluent Assertions\nDESCRIPTION: Core class for building fluent assertion chains with methods for adding context, conditions, and failure handling. Supports a fluent API pattern for expressive test assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssertionChain\n{\n    public string CallerIdentifier { get; }\n    public bool HasOverriddenCallerIdentifier { get; }\n    public bool Succeeded { get; }\n    public FluentAssertions.Execution.AssertionChain UsingLineBreaks { get; }\n    public void AddReportable(string key, System.Func<string> getValue) { }\n    public void AddReportable(string key, string value) { }\n    public FluentAssertions.Execution.AssertionChain BecauseOf(FluentAssertions.Execution.Reason reason) { }\n    public FluentAssertions.Execution.AssertionChain BecauseOf(string because, params object[] becauseArgs) { }\n    public FluentAssertions.Execution.Continuation FailWith(System.Func<FluentAssertions.Execution.FailReason> getFailureReason) { }\n    public FluentAssertions.Execution.Continuation FailWith(string message) { }\n    public FluentAssertions.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders) { }\n    public FluentAssertions.Execution.Continuation FailWith(string message, params object[] args) { }\n    public FluentAssertions.Execution.AssertionChain ForCondition(bool condition) { }\n    public FluentAssertions.Execution.AssertionChain ForConstraint(FluentAssertions.OccurrenceConstraint constraint, int actualOccurrences) { }\n    public FluentAssertions.Execution.GivenSelector<T> Given<T>(System.Func<T> selector) { }\n    public void OverrideCallerIdentifier(System.Func<string> getCallerIdentifier) { }\n    public void ReuseOnce() { }\n    public FluentAssertions.Execution.AssertionChain WithCallerPostfix(string postfix) { }\n    public FluentAssertions.Execution.AssertionChain WithDefaultIdentifier(string identifier) { }\n    public FluentAssertions.Execution.Continuation WithExpectation(string message, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n    public FluentAssertions.Execution.Continuation WithExpectation(string message, object arg1, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n    public FluentAssertions.Execution.Continuation WithExpectation(string message, object arg1, object arg2, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n    public FluentAssertions.Execution.AssertionChain WithReportable(string name, System.Func<string> content) { }\n    public static FluentAssertions.Execution.AssertionChain GetOrCreate() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ExceptionAssertions<TException> Class in C#\nDESCRIPTION: Class for fluent assertions on collections of exceptions. Provides methods to assert on exception messages, inner exceptions, and properties via predicates. Inherits from ReferenceTypeAssertions and is constrained to work with Exception types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_137\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExceptionAssertions<TException> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Collections.Generic.IEnumerable<TException>, FluentAssertions.Specialized.ExceptionAssertions<TException>>\n        where TException : System.Exception\n    {\n        public ExceptionAssertions(System.Collections.Generic.IEnumerable<TException> exceptions, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public TException And { get; }\n        protected override string Identifier { get; }\n        public TException Which { get; }\n        public FluentAssertions.Specialized.ExceptionAssertions<TException> Where(System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerException(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n        public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerException<TInnerException>(string because = \"\", params object[] becauseArgs)\n            where TInnerException : System.Exception { }\n        public FluentAssertions.Specialized.ExceptionAssertions<System.Exception> WithInnerExceptionExactly(System.Type innerException, string because = \"\", params object[] becauseArgs) { }\n        public virtual FluentAssertions.Specialized.ExceptionAssertions<TInnerException> WithInnerExceptionExactly<TInnerException>(string because = \"\", params object[] becauseArgs)\n            where TInnerException : System.Exception { }\n        public virtual FluentAssertions.Specialized.ExceptionAssertions<TException> WithMessage(string expectedWildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: DateTime Assertions Class Implementation in C#\nDESCRIPTION: Defines assertion methods for DateTime-related properties including day, hour, minute, month, offset, second, and year validations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_121\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Assertions in C#\nDESCRIPTION: Generic class that provides assertion methods specific to boolean values. It includes methods like BeTrue(), BeFalse(), and Imply() for logical operations on boolean values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic class BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n{\n    public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public bool? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(bool expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeFalse(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeTrue(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Imply(bool consequent, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(bool unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Reference Equality in C#\nDESCRIPTION: Shows how to verify that two variables reference the same object instance in memory using BeSameAs or different instances using NotBeSameAs.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/basicassertions.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ntheObject = otherObject;\ntheObject.Should().BeSameAs(otherObject);\ntheObject.Should().NotBeSameAs(otherObject);\n```\n\n----------------------------------------\n\nTITLE: Asserting Negative Collection Properties (C#)\nDESCRIPTION: These methods assert that a collection does not have certain properties, such as not being empty or not being equivalent to another collection.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Using nested WithExpectation in v8.0\nDESCRIPTION: Updated implementation of building complex assertions using the new nested WithExpectation pattern in v8.0. This eliminates the need for explicit ClearExpectation calls.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nassertionChain\n    .BecauseOf(because, becauseArgs)\n    .WithExpectation(\"Expected {context:the time} to be within {0} from {1}{reason}, \", precision, nearbyTime, chain => chain\n      .ForCondition(Subject is not null)\n      .FailWith(\"but found <null>.\")\n      .Then\n      .ForCondition(Subject?.IsCloseTo(nearbyTime, precision) == true)\n      .FailWith(\"but {0} was off by {1}.\", Subject, difference)\n    );\n```\n\n----------------------------------------\n\nTITLE: Implementing Execution Time Assertions in C#\nDESCRIPTION: This class provides methods for asserting the execution time of actions or tasks. It includes methods for comparing execution time to expected durations, with options for greater than, less than, and close to assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExecutionTimeAssertions\n{\n    public ExecutionTimeAssertions(FluentAssertions.Specialized.ExecutionTime executionTime, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeCloseTo(System.TimeSpan expectedDuration, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThan(System.TimeSpan minDuration, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThanOrEqualTo(System.TimeSpan minDuration, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThan(System.TimeSpan maxDuration, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThanOrEqualTo(System.TimeSpan maxDuration, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: String Assertion Methods in C#\nDESCRIPTION: Collection of string assertion methods for comparing, matching and validating string values. Includes methods for case checking, content validation, and pattern matching with support for regular expressions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_138\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeLowerCased(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Using Custom Assertions in Tests\nDESCRIPTION: Shows how to use custom assertion extensions in test code to create more readable domain-specific assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nmyClient.Should().BeActive(\"because we don't work with old clients\");\n```\n\n----------------------------------------\n\nTITLE: Instantiating BooleanAssertions with AssertionChain in v8.0\nDESCRIPTION: Updated implementation for instantiating BooleanAssertions using the new AssertionChain pattern in v8.0. This shows how to create and pass the AssertionChain to enable improved assertion chaining.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static BooleanAssertions Should(this bool actualValue)\n{\n    return new BooleanAssertions(actualValue, AssertionChain.GetOrCreate());\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Types from an Assembly with Filtering in FluentAssertions\nDESCRIPTION: This code shows how to select and assert on types from an assembly that match specific criteria, such as having certain attributes, implementing interfaces, or being in specific namespaces.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/typesandmethods.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar types = typeof(ClassWithSomeAttribute).Assembly.Types()\n  .ThatAreDecoratedWith<SomeAttribute>()\n  .ThatImplement<ISomeInterface>()\n  .ThatAreUnderNamespace(\"Internal.Main.Test\");\n\ntypes.Should().BeInNamespace(\"Internal.Main.Test.ISomeInterfaceTests\");\n\nvar properties = types.Properties().ThatArePublicOrInternal;\nproperties.Should().BeVirtual();\n```\n\n----------------------------------------\n\nTITLE: Implementing ComparableTypeAssertions for Numeric Assertions in C#\nDESCRIPTION: Definition of assertion classes for comparable types in FluentAssertions. These classes provide methods like BeGreaterThan, BeLessThan, and BeInRange to verify comparable values meet specific conditions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_103\n\nLANGUAGE: C#\nCODE:\n```\npublic class ComparableTypeAssertions<T> : FluentAssertions.Numeric.ComparableTypeAssertions<T, FluentAssertions.Numeric.ComparableTypeAssertions<T>>\n{\n    public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class ComparableTypeAssertions<T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.IComparable<T>, TAssertions>\n    where TAssertions : FluentAssertions.Numeric.ComparableTypeAssertions<T, TAssertions>\n{\n    public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeTrue assertion in previous versions\nDESCRIPTION: Example of how assertion methods like BeTrue were implemented using Execute.Assertion before v8.0. This shows the old pattern for condition checking and failure message construction.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic AndConstraint<TAssertions> BeTrue(string because = \"\", params object[] becauseArgs)\n{\n    Execute.Assertion\n        .ForCondition(Subject == true)\n        .BecauseOf(because, becauseArgs)\n        .FailWith(\"Expected {context:boolean} to be {0}{reason}, but found {1}.\", true, Subject);\n\n    return new AndConstraint<TAssertions>((TAssertions)this);\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Assertion Extensions in FluentAssertions (C#)\nDESCRIPTION: Extension methods for asserting various aspects of exceptions, including inner exceptions, messages, and parameter names. These methods work with task-based exception assertions to provide detailed validation of exception properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> Where<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerException<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerException<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception\n    where TInnerException : System.Exception { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerExceptionExactly<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerExceptionExactly<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception\n    where TInnerException : System.Exception { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithMessage<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string expectedWildcardPattern, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.Specialized.ExceptionAssertions<TException> WithParameterName<TException>(this FluentAssertions.Specialized.ExceptionAssertions<TException> parent, string paramName, string because = \"\", params object[] becauseArgs)\n    where TException : System.ArgumentException { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithParameterName<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string paramName, string because = \"\", params object[] becauseArgs)\n    where TException : System.ArgumentException { }\n```\n\n----------------------------------------\n\nTITLE: Creating Basic DirectoryInfo Extension Method in C#\nDESCRIPTION: Demonstrates how to create a basic extension method for DirectoryInfo that returns a custom assertions class. Uses AssertionChain to support potential chaining constructs.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class DirectoryInfoExtensions\n{\n    public static DirectoryInfoAssertions Should(this DirectoryInfo instance)\n    {\n      return new DirectoryInfoAssertions(instance, AssertionChain.GetOrCreate());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeApproximately Methods for Floating-Point Types in FluentAssertions\nDESCRIPTION: Extension methods that assert whether decimal, double, and float values are approximately equal to an expected value within a specified precision. These methods support the fluent assertion syntax and allow for custom failure messages through the 'because' parameter.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeApproximately Methods for Numeric Assertions in C#\nDESCRIPTION: Extension methods for asserting that numeric values are not approximately equal within a specified precision. These methods support decimal, double, and float types in both nullable and non-nullable variants, enabling fluent assertion chaining.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Fluent Actions Utility in C#\nDESCRIPTION: Static methods for creating action wrappers in fluent assertion contexts. These methods support different scenarios like invoking actions, awaiting tasks, and enumerating collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentActions\n{\n    public static System.Func<System.Threading.Tasks.Task> Awaiting(System.Func<System.Threading.Tasks.Task> action) { }\n    public static System.Func<System.Threading.Tasks.Task<T>> Awaiting<T>(System.Func<System.Threading.Tasks.Task<T>> func) { }\n    public static System.Action Enumerating(System.Func<System.Collections.IEnumerable> enumerable) { }\n    public static System.Action Enumerating<T>(System.Func<System.Collections.Generic.IEnumerable<T>> enumerable) { }\n    public static System.Action Invoking(System.Action action) { }\n    public static System.Func<T> Invoking<T>(System.Func<T> func) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Assertions in C#\nDESCRIPTION: This snippet defines the DateTimeAssertions class for asserting conditions on DateTime objects. It includes methods for comparing dates, checking time ranges, and verifying DateTime properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_118\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n{\n    public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTime? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTime nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeIn(System.DateTimeKind expectedKind, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTime[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTime>[] validValues) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic SimpleTimeSpanAssertions in C#\nDESCRIPTION: Generic base class for TimeSpan assertions, providing methods for comparison and value checking. Contains methods for checking if a TimeSpan is greater than, less than, close to or equal to an expected value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_161\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SimpleTimeSpanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>\n{\n    public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.TimeSpan? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.TimeSpan nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Collection Assertion Methods in FluentAssertions\nDESCRIPTION: These method signatures represent various collection assertion methods for validating different conditions like checking if collections don't contain specific elements, validating order, checking for nulls, and verifying uniqueness.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(params T[] unexpected) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(params T[] unexpected) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo<TExpectation>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainNulls(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainNulls<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = \"\", params object[] becauseArgs)\n    where TKey :  class { }\npublic FluentAssertions.AndConstraint<TAssertions> NotEqual(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveCount(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotIntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Satisfy(params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }\npublic FluentAssertions.AndConstraint<TAssertions> Satisfy(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression<System.Func<T, bool>>> predicates, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(params System.Action<T>[] elementInspectors) { }\npublic FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(System.Collections.Generic.IEnumerable<System.Action<T>> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(System.Collections.Generic.IEnumerable<T> expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(T element, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\nprotected static System.Collections.Generic.IEnumerable<TExpectation> RepeatAsManyAs<TExpectation>(TExpectation value, System.Collections.Generic.IEnumerable<T> enumerable) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Additional Negative Collection Properties (C#)\nDESCRIPTION: These methods assert that a collection does not have certain properties, such as not being null or empty, not being a subset, or not containing specific elements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeSubsetOf(System.Collections.Generic.IEnumerable<T> unexpectedSuperset, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(T unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Setting Global Value Type Comparison Options\nDESCRIPTION: Shows how to configure global equivalency options to compare specific types by value rather than by members, affecting all assertions in the application.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nAssertionConfiguration.Current.Equivalency.Modify(options => options\n    .ComparingByValue<DirectoryInfo>());\n```\n\n----------------------------------------\n\nTITLE: Casting Collections in F# with FluentAssertions\nDESCRIPTION: Demonstrates how to handle overload resolution issues when asserting on collections in F#. Shows the requirement to cast collections to sequences for basic assertions to work.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/fsharp.md#2025-04-23_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nlet x = [1; 2]\nx.Should().Contain(1, \"\") // Overload resolution error for \"Should\"\n(x :> seq<_>).Should().Contain(1, \"\") // OK, but only gives access to GenericCollectionAssertions<_>\n```\n\n----------------------------------------\n\nTITLE: Asserting Descending Order in Collections (C#)\nDESCRIPTION: These methods assert that a collection is in descending order. They offer various overloads to specify custom comparers or property expressions for ordering.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Collection Assertion Methods in FluentAssertions\nDESCRIPTION: This snippet shows method signatures for collection assertions like NotContain, OnlyContain, StartWith, etc. These methods allow for fluent assertion chains when testing collections in C#, supporting various overloads for different testing scenarios.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(T unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(params T[] unexpected) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(params T[] unexpected) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainInOrder(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainItemsAssignableTo<TExpectation>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainNulls(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainNulls<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = \"\", params object[] becauseArgs)\n    where TKey :  class { }\npublic FluentAssertions.AndConstraint<TAssertions> NotEqual(System.Collections.Generic.IEnumerable<T> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveCount(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotIntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyContain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> OnlyHaveUniqueItems<TKey>(System.Linq.Expressions.Expression<System.Func<T, TKey>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Satisfy(params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }\npublic FluentAssertions.AndConstraint<TAssertions> Satisfy(System.Collections.Generic.IEnumerable<System.Linq.Expressions.Expression<System.Func<T, bool>>> predicates, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(params System.Action<T>[] elementInspectors) { }\npublic FluentAssertions.AndConstraint<TAssertions> SatisfyRespectively(System.Collections.Generic.IEnumerable<System.Action<T>> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(System.Collections.Generic.IEnumerable<T> expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(T element, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\nprotected static System.Collections.Generic.IEnumerable<TExpectation> RepeatAsManyAs<TExpectation>(TExpectation value, System.Collections.Generic.IEnumerable<T> enumerable) { }\n```\n\n----------------------------------------\n\nTITLE: Mapping Members with Different Types in FluentAssertions using C#\nDESCRIPTION: Examples for mapping properties between different types in an object graph. Demonstrates how to specify the source and destination types when comparing objects with different structures.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n// Using names\norderDto.Should().BeEquivalentTo(order, options => options\n    .WithMapping<Order, OrderDto>(\"Name\", \"OrderName\"));\n\n// Using expressions\norderDto.Should().BeEquivalentTo(order, options => options\n    .WithMapping<Order, OrderDto>(e => e.Name, s => s.OrderName));\n```\n\n----------------------------------------\n\nTITLE: Property Info Selector Assertions in FluentAssertions\nDESCRIPTION: Defines methods for making assertions about selected properties in the FluentAssertions library. This class provides methods to assert that selected properties have specific characteristics such as being decorated with specific attributes, being virtual, or being writable.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_153\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoSelectorAssertions\n{\n    public PropertyInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.PropertyInfo[] properties) { }\n    protected string Context { get; }\n    public System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> SubjectProperties { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Chaining XML Assertions in C#\nDESCRIPTION: Shows how to chain multiple assertions on XML elements for more complex validation scenarios, including type checking and attribute validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/xml.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nxDocument.Should().HaveElement(\"child\")\n  .Which.Should().BeOfType<XElement>()\n    .And.HaveAttribute(\"attr\", \"1\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Assertions in C#\nDESCRIPTION: Defines classes for asserting against Stream and BufferedStream objects, with methods to verify stream properties like readability, writability, position, and buffer size.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_138\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace FluentAssertions.Streams\n{\n    public class BufferedStreamAssertions : FluentAssertions.Streams.BufferedStreamAssertions<FluentAssertions.Streams.BufferedStreamAssertions>\n    {\n        public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    }\n    public class BufferedStreamAssertions<TAssertions> : FluentAssertions.Streams.StreamAssertions<System.IO.BufferedStream, TAssertions>\n        where TAssertions : FluentAssertions.Streams.BufferedStreamAssertions<TAssertions>\n    {\n        public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.AndConstraint<TAssertions> HaveBufferSize(int expected, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotHaveBufferSize(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    }\n    public class StreamAssertions : FluentAssertions.Streams.StreamAssertions<System.IO.Stream, FluentAssertions.Streams.StreamAssertions>\n    {\n        public StreamAssertions(System.IO.Stream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    }\n    public class StreamAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n        where TSubject : System.IO.Stream\n        where TAssertions : FluentAssertions.Streams.StreamAssertions<TSubject, TAssertions>\n    {\n        public StreamAssertions(TSubject stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.AndConstraint<TAssertions> BeReadOnly(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> BeReadable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> BeSeekable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> BeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> HaveLength(long expected, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> HavePosition(long expected, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotBeReadOnly(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotBeReadable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotBeSeekable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotBeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotHaveLength(long unexpected, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotHavePosition(long unexpected, string because = \"\", params object[] becauseArgs) { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IValueFormatter in Fluent Assertions v6\nDESCRIPTION: Example showing the new signature of the Format method in custom IValueFormatter implementations, using FormattedObjectGraph instead of returning strings directly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild)\n{\n    string result = \"\\\"\" + value + \"\\\"\";\n\n    if (context.UseLineBreaks)\n    {\n        formattedGraph.AddFragmentOnNewLine(result);\n    }\n    else\n    {\n        formattedGraph.AddFragment(result);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Numeric Assertion Extensions in C#\nDESCRIPTION: Extension methods for numeric assertions including NotBeCloseTo and NotBeNaN checks for various numeric types. These methods provide fluent assertion capabilities for floating point and integer comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong distantValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom DirectoryInfo Assertions Class in C#\nDESCRIPTION: Shows implementation of a custom assertions class for DirectoryInfo with a ContainFile assertion method. Includes chain handling, custom failure messages, and condition checking.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DirectoryInfoAssertions :\n    ReferenceTypeAssertions<DirectoryInfo, DirectoryInfoAssertions>\n{\n    private AssertionChain chain;\n\n    public DirectoryInfoAssertions(DirectoryInfo instance, AssertionChain chain)\n        : base(instance)\n    {\n        this.chain = chain;\n    }\n\n    protected override string Identifier => \"directory\";\n\n    [CustomAssertion]\n    public AndConstraint<DirectoryInfoAssertions> ContainFile(\n        string filename, string because = \"\", params object[] becauseArgs)\n    {\n        chain\n            .BecauseOf(because, becauseArgs)\n            .ForCondition(!string.IsNullOrEmpty(filename))\n            .FailWith(\"You can't assert a file exist if you don't pass a proper name\")\n            .Then\n            .Given(() => Subject.GetFiles())\n            .ForCondition(files => files.Any(fileInfo => fileInfo.Name.Equals(filename)))\n            .FailWith(\"Expected {context:directory} to contain {0}{reason}, but found {1}.\",\n                _ => filename, files => files.Select(file => file.Name));\n\n        return new AndConstraint<DirectoryInfoAssertions>(this);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeApproximately Methods for Numeric Assertions in C#\nDESCRIPTION: Extension methods for asserting approximate equality of numeric values with a specified precision. These methods support decimal, double, and float types in both nullable and non-nullable variants. They return an AndConstraint to allow for chained assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Numeric Assertion Extensions in C#\nDESCRIPTION: Extension methods for numeric assertions, specifically for checking approximate equality of decimal values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Assertion Classes in C#\nDESCRIPTION: Defines classes for boolean assertions with methods to check true/false conditions and logical implications. Supports nullable booleans and provides a fluent API pattern for chainable assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_136\n\nLANGUAGE: csharp\nCODE:\n```\npublic class BooleanAssertions : FluentAssertions.Primitives.BooleanAssertions<FluentAssertions.Primitives.BooleanAssertions>\n{\n    public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n{\n    public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public bool? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(bool expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeFalse(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeTrue(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Imply(bool consequent, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(bool unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TypeSelectorAssertions Class for Type Collection Assertions (C#)\nDESCRIPTION: Provides assertion capabilities for collections of types. Allows asserting conditions that apply to all types in the collection, such as checking if all types are decorated with specific attributes or belong to specific namespaces.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_156\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeSelectorAssertions\n{\n    public TypeSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Type[] types) { }\n    public System.Collections.Generic.IEnumerable<System.Type> Subject { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeInNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeUnderNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeInNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeUnderNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MoreThan Occurrence Constraints in C#\nDESCRIPTION: Static methods defining 'MoreThan' occurrence constraints for assertions. These methods allow specifying minimum occurrence requirements like more than once, twice, or a custom number.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic static class MoreThan\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: DelegateAssertionsBase Abstract Class in FluentAssertions.Specialized\nDESCRIPTION: Base abstract class for delegate assertions that provides common implementation for assertion methods. It includes internal methods for handling assertions related to exceptions being thrown or not thrown by delegates.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_135\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class DelegateAssertionsBase<TDelegate, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TDelegate, FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>>\n    where TDelegate : System.Delegate\n    where TAssertions : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>\n{\n    protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal(System.Exception exception, string because, object[] becauseArgs) { }\n    protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)\n        where TException : System.Exception { }\n    protected FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Action Assertions Implementation\nDESCRIPTION: Implementation of assertion methods specifically for System.Action delegates, providing functionality to verify exception throwing behavior and timing constraints.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActionAssertions : FluentAssertions.Specialized.DelegateAssertions<System.Action, FluentAssertions.Specialized.ActionAssertions>\n{\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    protected override void InvokeSubject() { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrow(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating BooleanAssertions in previous versions\nDESCRIPTION: Example of how BooleanAssertions was instantiated in AssertionExtensions before v8.0. This shows the pattern for extension methods that enable fluent assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static BooleanAssertions Should(this bool actualValue)\n{\n    return new BooleanAssertions(actualValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for Dictionaries in FluentAssertions\nDESCRIPTION: Provides extension methods for dictionaries and key-value pair collections to enable fluent assertions. These methods support validating dictionaries and key-value pair collections through specialized assertion objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IDictionary<TKey, TValue>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IDictionary<TKey, TValue> actualValue) { }\npublic static FluentAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> actualValue) { }\npublic static FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue> Should<TCollection, TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this TCollection actualValue)\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }\n```\n\n----------------------------------------\n\nTITLE: Defining IEquivalencyOptions Interface in C#\nDESCRIPTION: Interface specifying available configuration options for equivalency validation, including handling of cyclic references, enums, case sensitivity, and member selection rules.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEquivalencyOptions\n{\n    bool AllowInfiniteRecursion { get; }\n    bool? CompareRecordsByValue { get; }\n    FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    FluentAssertions.Equivalency.CyclicReferenceHandling CyclicReferenceHandling { get; }\n    FluentAssertions.Equivalency.EnumEquivalencyHandling EnumEquivalencyHandling { get; }\n    bool ExcludeNonBrowsableOnExpectation { get; }\n    bool IgnoreCase { get; }\n    bool IgnoreLeadingWhitespace { get; }\n    bool IgnoreNewlineStyle { get; }\n    bool IgnoreNonBrowsableOnSubject { get; }\n    bool IgnoreTrailingWhitespace { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }\n    bool IsRecursive { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberMatchingRule> MatchingRules { get; }\n    FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberSelectionRule> SelectionRules { get; }\n    FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }\n    bool UseRuntimeTyping { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep> UserEquivalencySteps { get; }\n    FluentAssertions.Equivalency.EqualityStrategy GetEqualityStrategy(System.Type type);\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Enums by Name in FluentAssertions using C#\nDESCRIPTION: Example demonstrating how to configure enum comparison to use names instead of numeric values. By default, enums are compared by their underlying values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(expectation, options => options.ComparingEnumsByName());\n```\n\n----------------------------------------\n\nTITLE: Mapping Deeply Nested Members in FluentAssertions using C#\nDESCRIPTION: Examples showing how to map deeply nested members when comparing complex object graphs. Includes both string-based paths and expression-based approaches for targeting nested properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n// Using dotted property paths \nrootSubject.Should().BeEquivalentTo(rootExpectation, options => options\n    .WithMapping(\"Parent.Collection[].Member\", \"Parent.Collection[].Member\"));\n\n// Using expressions\nrootSubject.Should().BeEquivalentTo(rootExpectation, options => options\n    .WithMapping<SubjectType>(e => e.Parent.Collection[0].Member, s => s.Parent.Collection[0].Member));\n```\n\n----------------------------------------\n\nTITLE: Regex Match Count Assertions in C#\nDESCRIPTION: Shows how to assert on the number of regex matches in a string.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nsomeString.Should().MatchRegex(\"h.*\\\\sworld.$\", Exactly.Once());\nsomeString.Should().MatchRegex(new Regex(\"h.*\\\\sworld.$\"), AtLeast.Twice());\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Serialization Assertion Methods in C#\nDESCRIPTION: These extension methods add assertions for object serialization in FluentAssertions. They check if an object is serializable using DataContractSerializer and XmlSerializer.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ObjectAssertionsExtensions\n{\n    public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable<T>(this FluentAssertions.Primitives.ObjectAssertions assertions, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<T>, FluentAssertions.Equivalency.EquivalencyOptions<T>> options, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeXmlSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Count (C#)\nDESCRIPTION: These methods assert various properties related to the count of elements in a collection.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> HaveCount(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveCount(System.Linq.Expressions.Expression<System.Func<int, bool>> countPredicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveCountGreaterThan(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveCountGreaterThanOrEqualTo(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveCountLessThan(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveCountLessThanOrEqualTo(int expected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: DateTime Assertion Methods in FluentAssertions\nDESCRIPTION: A collection of assertion methods for DateTime values, including methods to check equality, comparison, date components, and more. These methods are part of a generic DateTime assertions class.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_110\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime> validValues, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime?> validValues, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }\npublic override bool Equals(object obj) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveHour(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveMinute(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveSecond(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime? unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTime distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeIn(System.DateTimeKind unexpectedKind, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Verifying Assembly Signing in C#\nDESCRIPTION: Shows how to verify an assembly's signing status by checking its public key or confirming it is unsigned. Useful for ensuring correct package signing and preventing unintended signing changes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/assemblies.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nassembly.Should().HavePublicKey(\"e0851575614491c6d25018fadb75\");\nassembly.Should().BeUnsigned();\n```\n\n----------------------------------------\n\nTITLE: Implementing Numeric Assertion Extensions in C#\nDESCRIPTION: Extension methods for approximate equality assertions on numeric values. These methods provide precision-based equality checks for decimal, double, and float types, supporting both regular and nullable values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic static class NumericAssertionsExtensions\n{\n    public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fluent Action Wrappers\nDESCRIPTION: Static methods for wrapping various types of actions (sync/async) in a fluent interface. Supports Task-based async operations and enumeration operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Func<System.Threading.Tasks.Task> Awaiting(System.Func<System.Threading.Tasks.Task> action) { }\npublic static System.Action Invoking(System.Action action) { }\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffsetAssertions<TAssertions> Generic Class Definition in FluentAssertions\nDESCRIPTION: Definition of the generic DateTimeOffsetAssertions<TAssertions> class that provides assertion methods for DateTimeOffset values. This class contains numerous methods for comparing DateTimeOffset values in various ways.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_109\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeOffsetAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n{\n    public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTimeOffset? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTimeOffset nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTimeOffset[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTimeOffset>[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset?> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveHour(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMinute(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveOffset(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveSecond(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTimeOffset distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Generic EnumAssertions Class with Comprehensive Enum Validation Methods\nDESCRIPTION: Fully-featured generic class for enum assertions that provides methods for validating enum values, flags, names, and values. Includes methods for equality checks, value comparison, flag operations, and predicate matching.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_115\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EnumAssertions<TEnum, TAssertions>\n    where TEnum :  struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>\n{\n    public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TEnum? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TEnum expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TEnum? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeDefined(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TEnum[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TEnum> validValues, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveFlag(TEnum expectedFlag, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveSameNameAs<T>(T expected, string because = \"\", params object[] becauseArgs)\n        where T :  struct, System.Enum { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveSameValueAs<T>(T expected, string because = \"\", params object[] becauseArgs)\n        where T :  struct, System.Enum { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(decimal expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TEnum?, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TEnum unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TEnum? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeDefined(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveFlag(TEnum unexpectedFlag, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveSameNameAs<T>(T unexpected, string because = \"\", params object[] becauseArgs)\n        where T :  struct, System.Enum { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveSameValueAs<T>(T unexpected, string because = \"\", params object[] becauseArgs)\n        where T :  struct, System.Enum { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(decimal unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncFunctionAssertions Class Definition in FluentAssertions.Specialized\nDESCRIPTION: Generic class for assertions on asynchronous functions. It provides methods to verify asynchronous operations, such as checking if they complete within a timespan or if they throw specific exceptions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_134\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AsyncFunctionAssertions<TTask, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<System.Func<TTask>, TAssertions>\n    where TTask : System.Threading.Tasks.Task\n    where TAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<TTask, TAssertions>\n{\n    protected AsyncFunctionAssertions(System.Func<TTask> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotThrowAsync<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowAsync<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowExactlyAsync<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowWithinAsync<TException>(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LessThan Occurrence Constraints in C#\nDESCRIPTION: Static methods defining 'LessThan' occurrence constraints for assertions. These methods allow specifying maximum occurrence requirements like less than twice, thrice, or a custom number.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic static class LessThan\n{\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StringAssertions Class in C#\nDESCRIPTION: This snippet defines the StringAssertions class, which inherits from StringAssertions<StringAssertions>. It provides a constructor that takes a string value and an AssertionChain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_162\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringAssertions : FluentAssertions.Primitives.StringAssertions<FluentAssertions.Primitives.StringAssertions>\n{\n    public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GuidAssertions<TAssertions> in FluentAssertions\nDESCRIPTION: Generic implementation of GuidAssertions providing fluent assertion methods for GUID values. It includes methods to assert equality, emptiness, and other GUID-specific validations using fluent syntax.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic class GuidAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.GuidAssertions<TAssertions>\n{\n    public GuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.Guid? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.Guid unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(string unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ActionAssertions Class Definition in FluentAssertions.Specialized\nDESCRIPTION: Definition of the ActionAssertions class that provides assertion capabilities for System.Action delegates. It includes constructors and methods to verify that actions don't throw exceptions or don't throw after a specified wait time.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_133\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActionAssertions : FluentAssertions.Specialized.DelegateAssertions<System.Action, FluentAssertions.Specialized.ActionAssertions>\n{\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    protected override void InvokeSubject() { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrow(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TypeAssertions Class Definition in C#\nDESCRIPTION: The TypeAssertions class inherits from ReferenceTypeAssertions and provides fluent assertion methods for System.Type objects. It includes a constructor that takes a Type object and an AssertionChain, and numerous methods for verifying various aspects of types like inheritance, access modifiers, and member presence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_154\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TypeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Type, FluentAssertions.Types.TypeAssertions>\n{\n    public TypeAssertions(System.Type type, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be(System.Type expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be<TExpected>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAbstract(string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom(System.Type baseType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom<TBaseClass>(string because = \"\", params object[] becauseArgs)\n        where TBaseClass :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeStatic(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveDefaultConstructor(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty(System.Type interfaceType, string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty<TInterface>(string name, string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveIndexer(System.Type indexerType, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty(System.Type propertyType, string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty<TProperty>(string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement(System.Type interfaceType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement<TInterface>(string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe(System.Type unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe<TUnexpected>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAbstract(string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom(System.Type baseType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom<TBaseClass>(string because = \"\", params object[] becauseArgs)\n        where TBaseClass :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeStatic(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic DateTimeAssertions<TAssertions> Class for FluentAssertions in C#\nDESCRIPTION: This generic class provides a wide range of assertion methods for DateTime objects, including comparisons, component checks, and time-based assertions. It's a core part of the FluentAssertions library for DateTime testing.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n{\n    public DateTimeAssertions(System.DateTime? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTime? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTime? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTime nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeIn(System.DateTimeKind expectedKind, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTime[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTime>[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTime?> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTime expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveHour(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMinute(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveSecond(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTime? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTime distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeIn(System.DateTimeKind unexpectedKind, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTime unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: IValueFormatter Interface Definition for Custom Value Formatting in C#\nDESCRIPTION: Interface that defines the contract for custom value formatters in FluentAssertions. Implementers must be able to determine if they can handle a specific value type and provide formatted string representation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_94\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IValueFormatter\n{\n    bool CanHandle(object value);\n    void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Value Formatters to an AssertionScope\nDESCRIPTION: Shows how to add custom value formatters to an AssertionScope to customize the string representation of objects in assertion failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nusing var scope = new AssertionScope();\n\nvar formatter = new CustomFormatter();\nscope.FormattingOptions.AddFormatter(formatter);\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic GenericDictionaryAssertions Class in C#\nDESCRIPTION: This snippet defines a more generic version of GenericDictionaryAssertions with additional type parameters. It includes various assertion methods for dictionary-like collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, System.Collections.Generic.KeyValuePair<TKey, TValue>, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n    where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.KeyValuePair<TKey, TValue> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(TKey key, TValue value, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Collections.WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(params TKey[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(System.Collections.Generic.IEnumerable<TKey> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TValue> ContainValue(TValue expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(params TValue[] expected) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(System.Collections.Generic.IEnumerable<TValue> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal<T>(T expected, string because = \"\", params object[] becauseArgs)\n        where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] items) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> items, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.KeyValuePair<TKey, TValue> item, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(TKey key, TValue value, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKey(TKey unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(params TKey[] unexpected) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(System.Collections.Generic.IEnumerable<TKey> unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainValue(TValue unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FluentDateTimeExtensions in C#\nDESCRIPTION: Defines extension methods for DateTime and DateTimeOffset to provide a fluent API for date and time operations. It includes methods for creating dates with specific months, adding microseconds, and timezone conversions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_120\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentDateTimeExtensions\n{\n    public static System.DateTime AddMicroseconds(this System.DateTime self, long microseconds) { }\n    public static System.DateTimeOffset AddMicroseconds(this System.DateTimeOffset self, long microseconds) { }\n    public static System.DateTime AddNanoseconds(this System.DateTime self, long nanoseconds) { }\n    public static System.DateTimeOffset AddNanoseconds(this System.DateTimeOffset self, long nanoseconds) { }\n    public static System.DateTime After(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }\n    public static System.DateTime April(this int day, int year) { }\n    public static System.DateTime AsLocal(this System.DateTime dateTime) { }\n    public static System.DateTime AsUtc(this System.DateTime dateTime) { }\n    public static System.DateTime At(this System.DateTime date, System.TimeSpan time) { }\n    public static System.DateTime At(this System.DateTime date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }\n    public static System.DateTimeOffset At(this System.DateTimeOffset date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }\n    public static System.DateTime August(this int day, int year) { }\n    public static System.DateTime Before(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }\n    public static System.DateTime December(this int day, int year) { }\n    public static System.DateTime February(this int day, int year) { }\n    public static System.DateTime January(this int day, int year) { }\n    public static System.DateTime July(this int day, int year) { }\n    public static System.DateTime June(this int day, int year) { }\n    public static System.DateTime March(this int day, int year) { }\n    public static System.DateTime May(this int day, int year) { }\n    public static int Microsecond(this System.DateTime self) { }\n    public static int Microsecond(this System.DateTimeOffset self) { }\n    public static int Nanosecond(this System.DateTime self) { }\n    public static int Nanosecond(this System.DateTimeOffset self) { }\n    public static System.DateTime November(this int day, int year) { }\n    public static System.DateTime October(this int day, int year) { }\n    public static System.DateTime September(this int day, int year) { }\n    public static System.DateTimeOffset WithOffset(this System.DateTime self, System.TimeSpan offset) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Equality Assertions in FluentAssertions C#\nDESCRIPTION: Methods for comparing collections for equality, including element-wise comparison and custom equality comparers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> Equal(params T[] elements) { }\npublic FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Equal<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Configuring Fluent Assertions Using AssertionEngineInitializer\nDESCRIPTION: Demonstrates how to use the AssertionEngineInitializer attribute to execute code before the first assertion is run, allowing global configuration of assertion behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: AssertionEngineInitializer(typeof(Initializer), nameof(Initializer.Initialize))]\n\npublic static class Initializer\n{\n    public static void Initialize()\n    {\n        AssertionConfiguration.Current.Equivalency.Modify(options => options\n          .ComparingByValue<DirectoryInfo>());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeCloseTo Extension Methods in C#\nDESCRIPTION: Extension methods for asserting that numeric values are within a specified delta of an expected value. Supports various integer types including byte, short, int, long and their unsigned variants.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte nearbyValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short nearbyValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Numeric Approximation Assertions in FluentAssertions (C#)\nDESCRIPTION: Extension methods for asserting approximate equality of numeric values with a specified precision. These methods support decimal, double, and float types with both nullable and non-nullable variants.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Extension Methods for Time Unit Manipulation in C#\nDESCRIPTION: A collection of extension methods for converting between various time units including hours, minutes, seconds, milliseconds, microseconds, nanoseconds, and ticks. These methods enable a fluent API for time-related operations in tests.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_92\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.TimeSpan Hours(this double hours) { }\npublic static System.TimeSpan Hours(this int hours) { }\npublic static System.TimeSpan Hours(this int hours, System.TimeSpan offset) { }\npublic static int Microseconds(this System.TimeSpan self) { }\npublic static System.TimeSpan Microseconds(this int microseconds) { }\npublic static System.TimeSpan Microseconds(this long microseconds) { }\npublic static System.TimeSpan Milliseconds(this double milliseconds) { }\npublic static System.TimeSpan Milliseconds(this int milliseconds) { }\npublic static System.TimeSpan Minutes(this double minutes) { }\npublic static System.TimeSpan Minutes(this int minutes) { }\npublic static System.TimeSpan Minutes(this int minutes, System.TimeSpan offset) { }\npublic static int Nanoseconds(this System.TimeSpan self) { }\npublic static System.TimeSpan Nanoseconds(this int nanoseconds) { }\npublic static System.TimeSpan Nanoseconds(this long nanoseconds) { }\npublic static System.TimeSpan Seconds(this double seconds) { }\npublic static System.TimeSpan Seconds(this int seconds) { }\npublic static System.TimeSpan Seconds(this int seconds, System.TimeSpan offset) { }\npublic static System.TimeSpan Ticks(this int ticks) { }\npublic static System.TimeSpan Ticks(this long ticks) { }\npublic static double TotalMicroseconds(this System.TimeSpan self) { }\npublic static double TotalNanoseconds(this System.TimeSpan self) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ExecutionTime Class in C#\nDESCRIPTION: Class for measuring and recording the execution time of both synchronous actions and asynchronous tasks, providing construction options with custom timers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_171\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExecutionTime\n{\n    public ExecutionTime(System.Action action, FluentAssertions.Common.StartTimer createTimer) { }\n    public ExecutionTime(System.Func<System.Threading.Tasks.Task> action, FluentAssertions.Common.StartTimer createTimer) { }\n    protected ExecutionTime(System.Action action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }\n    protected ExecutionTime(System.Func<System.Threading.Tasks.Task> action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Base GenericDictionaryAssertions Class Implementation in FluentAssertions\nDESCRIPTION: The core implementation of dictionary assertions that inherits from GenericCollectionAssertions. This class provides methods for asserting conditions on dictionaries like containing specific keys or values, equivalence checks, and equality validations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, System.Collections.Generic.KeyValuePair<TKey, TValue>, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n    where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.KeyValuePair<TKey, TValue> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(TKey key, TValue value, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Collections.WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(params TKey[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(System.Collections.Generic.IEnumerable<TKey> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TValue> ContainValue(TValue expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(params TValue[] expected) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(System.Collections.Generic.IEnumerable<TValue> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal<T>(T expected, string because = \"\", params object[] becauseArgs)\n        where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] items) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> items, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.KeyValuePair<TKey, TValue> item, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(TKey key, TValue value, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKey(TKey unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(params TKey[] unexpected) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(System.Collections.Generic.IEnumerable<TKey> unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainValue(TValue unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainValues(params TValue[] unexpected) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainValues(System.Collections.Generic.IEnumerable<TValue> unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotEqual<T>(T unexpected, string because = \"\", params object[] becauseArgs)\n        where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }\n}\n```\n\n----------------------------------------\n\nTITLE: Action Assertions Implementation in C#\nDESCRIPTION: Provides assertion methods for Action delegates with support for exception checking and asynchronous operations. Extends DelegateAssertions for common delegate testing functionality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActionAssertions : FluentAssertions.Specialized.DelegateAssertions<System.Action, FluentAssertions.Specialized.ActionAssertions>\n{\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    protected override void InvokeSubject() { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrow(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Lambda Execution Time in C#\nDESCRIPTION: Shows how to verify the execution time of an arbitrary action using a lambda expression. This example asserts that a sleep operation executes within 200 milliseconds.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/executiontime.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar someAction = () => Thread.Sleep(100);\nsomeAction.ExecutionTime().Should().BeLessThanOrEqualTo(200.Milliseconds());\n```\n\n----------------------------------------\n\nTITLE: Occurrence Constraint Extensions Implementation\nDESCRIPTION: Extension methods for defining occurrence constraints with exact, minimum and maximum counts.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.OccurrenceConstraint TimesExactly(this int times) { }\npublic static FluentAssertions.OccurrenceConstraint TimesOrLess(this int times) { }\npublic static FluentAssertions.OccurrenceConstraint TimesOrMore(this int times) { }\n```\n\n----------------------------------------\n\nTITLE: Defining PropertyInfoAssertions Methods in C#\nDESCRIPTION: This snippet defines methods for asserting various properties of PropertyInfo objects, such as virtuality, writability, and return types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn(System.Type propertyType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn<TReturn>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return(System.Type propertyType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return<TReturn>(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Numeric Assertions in C#\nDESCRIPTION: This snippet defines the NumericAssertions class for asserting conditions on numeric values. It includes methods for comparison, range checking, and type verification.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_116\n\nLANGUAGE: C#\nCODE:\n```\npublic class NumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertions<T, TAssertions>\n{\n    public NumericAssertions(T value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public override T Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic StreamAssertions for Stream Type Testing in C#\nDESCRIPTION: Generic implementation of StreamAssertions that provides various methods for testing properties of Stream objects like readability, writability, length, and position. This class is the foundation for all stream-related assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_150\n\nLANGUAGE: C#\nCODE:\n```\npublic class StreamAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.IO.Stream\n    where TAssertions : FluentAssertions.Streams.StreamAssertions<TSubject, TAssertions>\n{\n    public StreamAssertions(TSubject stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeReadOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSeekable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveLength(long expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HavePosition(long expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeReadOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSeekable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveLength(long unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHavePosition(long unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeApproximately Extension Methods in C#\nDESCRIPTION: Extension methods for asserting approximate equality of decimal, double, and float values within a specified precision. These methods allow for floating-point comparison with tolerance.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double expectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Excluding Properties in Collection Elements\nDESCRIPTION: Shows how to exclude a specific property from a specific element in a collection by using its index.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => \n    options.Excluding(o => o.Products[1].Status));\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeCloseTo Methods for Integer Assertions in C#\nDESCRIPTION: Extension methods for asserting that integer values are not close to a target value within a specified delta. These methods support various integer types and their unsigned variants, providing fluent assertion capabilities via AndConstraint.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte distantValue, byte delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short distantValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int distantValue, uint delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long distantValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte distantValue, byte delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort distantValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint distantValue, uint delta, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncFunctionAssertions Class in C#\nDESCRIPTION: Generic class for asserting behavior of asynchronous functions, with methods to verify completion time and exception handling for Task-returning operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_167\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AsyncFunctionAssertions<TTask, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<System.Func<TTask>, TAssertions>\n    where TTask : System.Threading.Tasks.Task\n    where TAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<TTask, TAssertions>\n{\n    protected AsyncFunctionAssertions(System.Func<TTask> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotThrowAsync<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowAsync<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowExactlyAsync<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowWithinAsync<TException>(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Content Assertions in FluentAssertions C#\nDESCRIPTION: Methods for asserting collection content including emptiness checks, subset verification, and element containment with custom predicates.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeSubsetOf(System.Collections.Generic.IEnumerable<T> expectedSuperset, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> Contain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Overriding Global Strict Ordering in FluentAssertions using C#\nDESCRIPTION: Example demonstrating how to override a global strict ordering configuration in a specific test. Shows the relationship between global and local configuration options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\nAssertionConfiguration.Current.Equivalency.Modify(options => options.WithStrictOrdering());\n\norderDto.Should().BeEquivalentTo(expectation, options => options.WithoutStrictOrdering());\n```\n\n----------------------------------------\n\nTITLE: Collection Equivalency Assertions in C#\nDESCRIPTION: Methods for checking collection equivalency with optional custom configuration and comparison options. Includes both positive and negative assertion patterns.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, string because = \"\", params object[] becauseArgs) { }\n\npublic FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Collection Assertions in C#\nDESCRIPTION: Classes that provide assertion capabilities for generic collections. These classes include methods for verifying collection contents, ordering, equivalence, and other properties with a fluent API.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericCollectionAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T, FluentAssertions.Collections.GenericCollectionAssertions<T>>\n{\n    public GenericCollectionAssertions(System.Collections.Generic.IEnumerable<T> actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class GenericCollectionAssertions<TCollection, T> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T>>\n    where TCollection : System.Collections.Generic.IEnumerable<T>\n{\n    public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class GenericCollectionAssertions<TCollection, T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TCollection, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<T>\n    where TAssertions : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, T, TAssertions>\n{\n    public GenericCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeAssignableTo(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeAssignableTo<TExpectation>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TExpectation>> AllBeOfType<TExpectation>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllSatisfy(System.Action<T> expected, string because = \"\", params object[] becauseArgs) { }\n    protected void AssertCollectionEndsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actual, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n    protected void AssertCollectionStartsWith<TActual, TExpectation>(System.Collections.Generic.IEnumerable<TActual> actualItems, System.Collections.Generic.ICollection<TExpectation> expected, System.Func<TActual, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n    protected void AssertSubjectEquality<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Raising Extensions in C#\nDESCRIPTION: Extension methods for asserting on raised events. These methods allow verification of event arguments and senders through fluent assertion syntax.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic static class EventRaisingExtensions\n{\n    public static FluentAssertions.Events.IEventRecording WithArgs<T>(this FluentAssertions.Events.IEventRecording eventRecording, System.Linq.Expressions.Expression<System.Func<T, bool>> predicate) { }\n    public static FluentAssertions.Events.IEventRecording WithArgs<T>(this FluentAssertions.Events.IEventRecording eventRecording, params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }\n    public static FluentAssertions.Events.IEventRecording WithSender(this FluentAssertions.Events.IEventRecording eventRecording, object expectedSender) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Ascending Order in Collections (C#)\nDESCRIPTION: This method asserts that a collection is in ascending order based on a specified property and comparer. It returns an AndConstraint for method chaining.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing GivenSelector Class for Targeted Assertions\nDESCRIPTION: Generic class that enables assertions on specific selections from an object. Supports a Given-Then pattern for more targeted and readable assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_84\n\nLANGUAGE: C#\nCODE:\n```\npublic class GivenSelector<T>\n{\n    public bool Succeeded { get; }\n    public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message) { }\n    public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params System.Func<T, object>[] args) { }\n    public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params object[] args) { }\n    public FluentAssertions.Execution.GivenSelector<T> ForCondition(System.Func<T, bool> predicate) { }\n    public FluentAssertions.Execution.GivenSelector<TOut> Given<TOut>(System.Func<T, TOut> selector) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DateTimeRangeAssertions Class Implementation in FluentAssertions\nDESCRIPTION: Class for asserting that DateTime values fall within specific time ranges. Provides methods to validate that a DateTime is before or after a specific target with customizable error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_113\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateTimeRangeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n{\n    protected DateTimeRangeAssertions(TAssertions parentAssertions, FluentAssertions.Execution.AssertionChain assertionChain, System.DateTime? subject, FluentAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> After(System.DateTime target, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Before(System.DateTime target, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: OccurrenceConstraintExtensions for Fluent Assertion Counts in C#\nDESCRIPTION: Extension methods that facilitate specifying occurrence constraints in test assertions. These methods provide a fluent interface for expressing how many times a condition should be met.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_93\n\nLANGUAGE: C#\nCODE:\n```\npublic static class OccurrenceConstraintExtensions\n{\n    public static FluentAssertions.OccurrenceConstraint TimesExactly(this int times) { }\n    public static FluentAssertions.OccurrenceConstraint TimesOrLess(this int times) { }\n    public static FluentAssertions.OccurrenceConstraint TimesOrMore(this int times) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FunctionAssertions<T> Class in C#\nDESCRIPTION: Class for making assertions about generic functions returning type T. Extends DelegateAssertions and provides methods to assert that functions don't throw exceptions and proper handling of invocation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\npublic class FunctionAssertions<T> : FluentAssertions.Specialized.DelegateAssertions<System.Func<T>, FluentAssertions.Specialized.FunctionAssertions<T>>\n    {\n        public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n        protected override string Identifier { get; }\n        protected override void InvokeSubject() { }\n        public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrow(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing ExecutionTimeAssertions Class in C#\nDESCRIPTION: Class for asserting execution time measurements, with methods to verify that an operation's duration is close to, greater than, or less than expected values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_172\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ExecutionTimeAssertions\n{\n    public ExecutionTimeAssertions(FluentAssertions.Specialized.ExecutionTime executionTime, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeCloseTo(System.TimeSpan expectedDuration, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThan(System.TimeSpan minDuration, string because = \"\", params object[] becauseArgs) { }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeAssertions Class in FluentAssertions\nDESCRIPTION: Definition of the TypeAssertions class which extends ReferenceTypeAssertions to provide a fluent interface for asserting properties of System.Type objects. It includes methods for asserting type characteristics such as inheritance, decoration with attributes, access modifiers, and presence of members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_162\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Type, FluentAssertions.Types.TypeAssertions>\n{\n    public TypeAssertions(System.Type type, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be(System.Type expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be<TExpected>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAbstract(string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom(System.Type baseType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom<TBaseClass>(string because = \"\", params object[] becauseArgs)\n        where TBaseClass :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeStatic(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveDefaultConstructor(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty(System.Type interfaceType, string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty<TInterface>(string name, string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveIndexer(System.Type indexerType, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty(System.Type propertyType, string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty<TProperty>(string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement(System.Type interfaceType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement<TInterface>(string because = \"\", params object[] becauseArgs)\n        where TInterface :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe(System.Type unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe<TUnexpected>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAbstract(string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom(System.Type baseType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom<TBaseClass>(string because = \"\", params object[] becauseArgs)\n        where TBaseClass :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeStatic(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XML Element Assertions in C#\nDESCRIPTION: The XmlElementAssertions class provides methods for asserting properties of XML elements, such as attributes, child elements, and inner text. It inherits from XmlNodeAssertions<XmlElement, XmlElementAssertions>.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_162\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlElementAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlElement, FluentAssertions.Xml.XmlElementAssertions>\n{\n    public XmlElementAssertions(System.Xml.XmlElement xmlElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElement(string expectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveInnerText(string expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic ObjectAssertions in C#\nDESCRIPTION: Generic base class for object-based assertions, providing methods for equality, equivalence and collection membership checks. Extends ReferenceTypeAssertions to leverage common reference type assertion functionality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_158\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ObjectAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.ObjectAssertions<TSubject, TAssertions>\n{\n    public ObjectAssertions(TSubject value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TSubject[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Execution Time Measurement in C#\nDESCRIPTION: Classes for measuring and asserting execution time of synchronous and asynchronous operations. Includes support for duration comparisons and precision-based assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExecutionTime\n{\n    public ExecutionTime(System.Action action, FluentAssertions.Common.StartTimer createTimer) { }\n    public ExecutionTime(System.Func<System.Threading.Tasks.Task> action, FluentAssertions.Common.StartTimer createTimer) { }\n    protected ExecutionTime(System.Action action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }\n    protected ExecutionTime(System.Func<System.Threading.Tasks.Task> action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }\n}\n\npublic class ExecutionTimeAssertions\n{\n    public ExecutionTimeAssertions(FluentAssertions.Specialized.ExecutionTime executionTime, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeCloseTo(System.TimeSpan expectedDuration, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThan(System.TimeSpan minDuration, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThanOrEqualTo(System.TimeSpan minDuration, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThan(System.TimeSpan maxDuration, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThanOrEqualTo(System.TimeSpan maxDuration, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NumericAssertions Classes in C#\nDESCRIPTION: Defines class structure for numeric assertions with generic type constraints. These classes provide a foundation for asserting against numeric values, with appropriate inheritance and constraints for structs implementing IComparable.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_135\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NumericAssertions<T> : FluentAssertions.Numeric.NumericAssertions<T, FluentAssertions.Numeric.NumericAssertions<T>>\n    where T :  struct, System.IComparable<T>\n{\n    public NumericAssertions(T value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class NumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertions<T, TAssertions>\n{\n    public NumericAssertions(T value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public override T Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeNaN Extension Methods for Double and Float in C#\nDESCRIPTION: These extension methods add the BeNaN assertion for double and float types in FluentAssertions. They check if a numeric value is NaN (Not a Number).\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Null and Empty States for Dictionaries in C#\nDESCRIPTION: Demonstrates how to check if a dictionary is null, not null, empty, or not empty using Fluent Assertions. These are basic assertions that validate the initialization state of a dictionary.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/dictionaries.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<int, string> dictionary;\ndictionary.Should().BeNull();\n\ndictionary = new Dictionary<int, string>();\ndictionary.Should().NotBeNull();\ndictionary.Should().BeEmpty();\ndictionary.Add(1, \"first element\");\ndictionary.Should().NotBeEmpty();\n```\n\n----------------------------------------\n\nTITLE: Creating Enum Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting on enum values and nullable enum values, returning appropriate assertion objects for fluent assertion chains.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.EnumAssertions<TEnum> Should<TEnum>(this TEnum @enum)\n    where TEnum :  struct, System.Enum { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.NullableEnumAssertions<TEnum> Should<TEnum>([System.Diagnostics.CodeAnalysis.NotNull] this TEnum? @enum)\n    where TEnum :  struct, System.Enum { }\n```\n\n----------------------------------------\n\nTITLE: Defining Exception Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting on exceptions, allowing checking of exception properties, inner exceptions, and messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> Where<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerException<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerException<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception\n    where TInnerException : System.Exception { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerExceptionExactly<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerExceptionExactly<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception\n    where TInnerException : System.Exception { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithMessage<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string expectedWildcardPattern, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Specialized.ExceptionAssertions<TException> WithParameterName<TException>(this FluentAssertions.Specialized.ExceptionAssertions<TException> parent, string paramName, string because = \"\", params object[] becauseArgs)\n    where TException : System.ArgumentException { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithParameterName<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string paramName, string because = \"\", params object[] becauseArgs)\n    where TException : System.ArgumentException { }\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Properties (C#)\nDESCRIPTION: These methods assert various properties of collections, such as being null or empty, being a subset, containing specific elements, or having a specific count.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeSubsetOf(System.Collections.Generic.IEnumerable<T> expectedSuperset, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> Contain(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> Contain(T expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveCount(int expected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Reflection Extensions in C#\nDESCRIPTION: Extension methods that provide reflection capabilities for examining types, properties, and methods. These extensions enable fluent access to reflection information for assemblies and types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TypeExtensions\n{\n    public static FluentAssertions.Types.MethodInfoSelector Methods(this FluentAssertions.Types.TypeSelector typeSelector) { }\n    public static FluentAssertions.Types.MethodInfoSelector Methods(this System.Type type) { }\n    public static FluentAssertions.Types.PropertyInfoSelector Properties(this FluentAssertions.Types.TypeSelector typeSelector) { }\n    public static FluentAssertions.Types.PropertyInfoSelector Properties(this System.Type type) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Reflection.Assembly assembly) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Assertion Methods in C#\nDESCRIPTION: This snippet shows a selection of assertion methods available in the StringAssertions<TAssertions> class. These methods allow for various string comparisons and checks, including equality, emptiness, case sensitivity, and content matching.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_164\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeLowerCased(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Contain(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> EndWith(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveLength(int expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Dictionary Assertion Extension Methods in C#\nDESCRIPTION: Extension methods for IDictionary and IEnumerable<KeyValuePair> that return GenericDictionaryAssertions objects, enabling fluent assertions on dictionary types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TSubject, TAssertions>(this FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IDictionary<TKey, TValue>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IDictionary<TKey, TValue> actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> actualValue) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue> Should<TCollection, TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this TCollection actualValue)\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeRangeAssertions Class in C#\nDESCRIPTION: Class for asserting DateTime range conditions. Similar to DateTimeOffsetRangeAssertions, it provides methods to check if a DateTime value is before or after a target value within a specified time range.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_109\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateTimeRangeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n{\n    protected DateTimeRangeAssertions(TAssertions parentAssertions, FluentAssertions.Execution.AssertionChain assertionChain, System.DateTime? subject, FluentAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> After(System.DateTime target, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Before(System.DateTime target, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OccurrenceConstraintExtensions in C#\nDESCRIPTION: Extension methods for integer values to create occurrence constraints. These methods provide a fluent syntax for specifying how many times an event should occur in assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_87\n\nLANGUAGE: C#\nCODE:\n```\npublic static class OccurrenceConstraintExtensions\n{\n    public static FluentAssertions.OccurrenceConstraint TimesExactly(this int times) { }\n    public static FluentAssertions.OccurrenceConstraint TimesOrLess(this int times) { }\n    public static FluentAssertions.OccurrenceConstraint TimesOrMore(this int times) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Assertions in FluentAssertions\nDESCRIPTION: Classes for asserting event raising behavior in the FluentAssertions library. These enable verification of whether events were raised and provide access to event metadata and recording.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_84\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventAssertions<T> : FluentAssertions.Primitives.ReferenceTypeAssertions<T, FluentAssertions.Events.EventAssertions<T>>\n{\n    protected EventAssertions(FluentAssertions.Events.IMonitor<T> monitor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.Events.IMonitor<T> Monitor { get; }\n    public void NotRaise(string eventName, string because = \"\", params object[] becauseArgs) { }\n    public void NotRaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Events.IEventRecording Raise(string eventName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Events.IEventRecording RaisePropertyChangeFor(System.Linq.Expressions.Expression<System.Func<T, object>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventMetadata\n{\n    public EventMetadata(string eventName, System.Type handlerType) { }\n    public string EventName { get; }\n    public System.Type HandlerType { get; }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventMonitorOptions\n{\n    public EventMonitorOptions() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumAssertions Class in C#\nDESCRIPTION: Non-generic EnumAssertions class that inherits from the generic version. Provides a way to create assertions for enum values with a simpler type signature while maintaining all functionality from the generic base class.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_110\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EnumAssertions<TEnum> : FluentAssertions.Primitives.EnumAssertions<TEnum, FluentAssertions.Primitives.EnumAssertions<TEnum>>\n    where TEnum :  struct, System.Enum\n{\n    public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Should Extension Methods for Collections in C#\nDESCRIPTION: Defines Should extension methods for generic collections and dictionaries. These methods return appropriate collection assertion types, enabling fluent assertions on various collection types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Collections.GenericCollectionAssertions<T> Should<T>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IEnumerable<T> actualValue) { }\npublic static FluentAssertions.Collections.GenericDictionaryAssertions<System.Collections.Generic.IDictionary<TKey, TValue>, TKey, TValue> Should<TKey, TValue>([System.Diagnostics.CodeAnalysis.NotNull] this System.Collections.Generic.IDictionary<TKey, TValue> actualValue) { }\n// ... (similar methods for other collection types)\n```\n\n----------------------------------------\n\nTITLE: XElementAssertions Class Implementation in C#\nDESCRIPTION: Class providing fluent assertions for XElement objects with methods to verify attributes, elements, and values. Inherits from ReferenceTypeAssertions and includes methods for both positive and negative assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_193\n\nLANGUAGE: C#\nCODE:\n```\npublic class XElementAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XElement, FluentAssertions.Xml.XElementAssertions>\n{\n    public XElementAssertions(System.Xml.Linq.XElement xElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> Be(System.Xml.Linq.XElement expected, string because = \"\", params object[] becauseArgs) { }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Equivalence (C#)\nDESCRIPTION: These methods assert equivalence between collections, allowing for custom equivalency options and configurations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> ContainEquivalentOf<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract ReferenceTypeAssertions in C#\nDESCRIPTION: Defines an abstract base class for assertions on reference types. Provides common functionality for type checking, null checking, and manages the assertion chain and subject under test.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_135\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ReferenceTypeAssertions<TSubject, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n{\n    protected ReferenceTypeAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }\n    protected abstract string Identifier { get; }\n    public TSubject Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, T> BeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, T> BeOfType<T>(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable Boolean Assertions in C#\nDESCRIPTION: Defines the NullableBooleanAssertions class which extends BooleanAssertions to provide assertion methods for nullable boolean values. It includes methods to check for null, specific boolean values, and value presence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_112\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableBooleanAssertions<TAssertions> : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<TAssertions>\n{\n    public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(bool? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(bool? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeFalse(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeTrue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Assertion Extensions in C#\nDESCRIPTION: Extension methods for asynchronous assertions that allow checking task results against expected values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> task, T expected, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> task, T expected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing StructuralEqualityEquivalencyStep in C#\nDESCRIPTION: Class for performing structural equality checks in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to compare objects by their structure rather than reference.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic class StructuralEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public StructuralEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FluentTimeSpanExtensions in C#\nDESCRIPTION: Defines extension methods for TimeSpan to provide a fluent API for time interval operations. It includes methods for creating and manipulating time spans with various units from nanoseconds to days.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_121\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentTimeSpanExtensions\n{\n    public const long TicksPerMicrosecond = 10;\n    public const double TicksPerNanosecond = 0.01D;\n    public static System.TimeSpan And(this System.TimeSpan sourceTime, System.TimeSpan offset) { }\n    public static System.TimeSpan Days(this double days) { }\n    public static System.TimeSpan Days(this int days) { }\n    public static System.TimeSpan Days(this int days, System.TimeSpan offset) { }\n    public static System.TimeSpan Hours(this double hours) { }\n    public static System.TimeSpan Hours(this int hours) { }\n    public static System.TimeSpan Hours(this int hours, System.TimeSpan offset) { }\n    public static int Microseconds(this System.TimeSpan self) { }\n    public static System.TimeSpan Microseconds(this int microseconds) { }\n    public static System.TimeSpan Microseconds(this long microseconds) { }\n    public static System.TimeSpan Milliseconds(this double milliseconds) { }\n    public static System.TimeSpan Milliseconds(this int milliseconds) { }\n    public static System.TimeSpan Minutes(this double minutes) { }\n    public static System.TimeSpan Minutes(this int minutes) { }\n    public static System.TimeSpan Minutes(this int minutes, System.TimeSpan offset) { }\n    public static int Nanoseconds(this System.TimeSpan self) { }\n    public static System.TimeSpan Nanoseconds(this int nanoseconds) { }\n    public static System.TimeSpan Nanoseconds(this long nanoseconds) { }\n    public static System.TimeSpan Seconds(this double seconds) { }\n    public static System.TimeSpan Seconds(this int seconds) { }\n    public static System.TimeSpan Seconds(this int seconds, System.TimeSpan offset) { }\n    public static System.TimeSpan Ticks(this int ticks) { }\n    public static System.TimeSpan Ticks(this long ticks) { }\n    public static double TotalMicroseconds(this System.TimeSpan self) { }\n    public static double TotalNanoseconds(this System.TimeSpan self) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NonGenericAsyncFunctionAssertions Class for Task in C#\nDESCRIPTION: A specialized assertion class for asynchronous functions returning non-generic Task. It provides methods to verify completion, timing constraints, and exception handling for non-generic async operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_177\n\nLANGUAGE: C#\nCODE:\n```\npublic class NonGenericAsyncFunctionAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task, FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>\n{\n    public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAsync(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeApproximately Extension Method for Float in C#\nDESCRIPTION: This extension method adds the BeApproximately assertion for float values in FluentAssertions. It checks if a float value is approximately equal to an expected value within a specified precision.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float expectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ComparableTypeAssertions<T, TAssertions> in FluentAssertions.Numeric\nDESCRIPTION: A generic base class for assertions on comparable types implementing IComparable<T>. Provides methods like Be, BeGreaterThan, BeLessThan, and BeInRange for comparing values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_115\n\nLANGUAGE: C#\nCODE:\n```\npublic class ComparableTypeAssertions<T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.IComparable<T>, TAssertions>\n    where TAssertions : FluentAssertions.Numeric.ComparableTypeAssertions<T, TAssertions>\n{\n    public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeInRange(T minimumValue, T maximumValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(T expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Serialization Extension Methods for ObjectAssertions in C#\nDESCRIPTION: Extension methods for validating DataContract and XML serialization capabilities of objects. These methods allow for testing whether an object can be successfully serialized using different serialization frameworks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable<T>(this FluentAssertions.Primitives.ObjectAssertions assertions, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<T>, FluentAssertions.Equivalency.EquivalencyOptions<T>> options, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeXmlSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ActionAssertions Class in C#\nDESCRIPTION: Class for asserting behavior of Action delegates, providing methods to verify that actions do or do not throw exceptions within specific time intervals.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_166\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ActionAssertions : FluentAssertions.Specialized.DelegateAssertions<System.Action, FluentAssertions.Specialized.ActionAssertions>\n{\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public ActionAssertions(System.Action subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    protected override void InvokeSubject() { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrow(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ActionAssertions> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Single Element in Collections (C#)\nDESCRIPTION: These methods assert that a collection contains a single element, optionally matching a predicate.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> ContainSingle(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> ContainSingle(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeApproximately Methods for Floating-Point Types in FluentAssertions\nDESCRIPTION: Extension methods that assert whether decimal, double, and float values are NOT approximately equal to an unexpected value within a specified precision. These methods handle both nullable and non-nullable numeric types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ConstructorInfoAssertions for Testing Constructors in C#\nDESCRIPTION: The ConstructorInfoAssertions class extends MethodBaseAssertions to provide specific assertions for constructors. It enables testing constructor properties through reflection.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_153\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConstructorInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.ConstructorInfo, FluentAssertions.Types.ConstructorInfoAssertions>\n{\n    public ConstructorInfoAssertions(System.Reflection.ConstructorInfo constructorInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Function Assertions in C#\nDESCRIPTION: This class provides methods for asserting properties of functions, including methods to assert that a function does not throw an exception, or does not throw after a specified wait time and poll interval.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_134\n\nLANGUAGE: C#\nCODE:\n```\npublic class FunctionAssertions<T> : FluentAssertions.Specialized.DelegateAssertions<System.Func<T>, FluentAssertions.Specialized.FunctionAssertions<T>>\n{\n    public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    protected override void InvokeSubject() { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrow(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NonGenericAsyncFunctionAssertions in C#\nDESCRIPTION: Defines a class for asserting against non-generic async functions (System.Func<Task>), with methods to verify completion timing and exception behaviors.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_136\n\nLANGUAGE: csharp\nCODE:\n```\npublic NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\npublic NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\npublic System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\npublic System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\npublic System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAsync(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Property-Based Collection Assertions in C#\nDESCRIPTION: Shows how to check for unique items or null values in collections using property expressions for better failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/collections.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ncollection.Select(x => x.SomeProperty).Should().OnlyHaveUniqueItems();\n\ncollection.Should().OnlyHaveUniqueItems(x => x.SomeProperty);\ncollection.Should().NotContainNulls(x => x.SomeProperty);\n```\n\n----------------------------------------\n\nTITLE: Asserting Task Results in FluentAssertions (C#)\nDESCRIPTION: Extension methods for asserting specific results of Task objects with generic constraints. These methods allow comparing the actual task result with an expected value and providing custom failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> task, T expected, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> task, T expected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Generic Dictionary Assertions Base Class in FluentAssertions\nDESCRIPTION: This class is the base implementation for dictionary assertions, extending the generic collection assertions. It provides methods for asserting dictionary properties like key containment, value containment, and equivalence testing with various overloads.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, System.Collections.Generic.KeyValuePair<TKey, TValue>, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n    where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(System.Collections.Generic.KeyValuePair<TKey, TValue> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(TKey key, TValue value, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Collections.WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(params TKey[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainKeys(System.Collections.Generic.IEnumerable<TKey> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TValue> ContainValue(TValue expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(params TValue[] expected) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, System.Collections.Generic.IEnumerable<TValue>> ContainValues(System.Collections.Generic.IEnumerable<TValue> expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal<T>(T expected, string because = \"\", params object[] becauseArgs)\n        where T : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(params System.Collections.Generic.KeyValuePair<TKey, TValue>[] items) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> items, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(System.Collections.Generic.KeyValuePair<TKey, TValue> item, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContain(TKey key, TValue value, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKey(TKey unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(params TKey[] unexpected) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainKeys(System.Collections.Generic.IEnumerable<TKey> unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainValue(TValue unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyStep Classes for Object Comparison in C#\nDESCRIPTION: This code defines multiple classes implementing IEquivalencyStep interface for different types of object comparison. Each class handles a specific data type or comparison scenario like dictionaries, enumerables, strings, value types, and more.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic class AutoConversionStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public AutoConversionStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic NullableBooleanAssertions Class with Boolean Validation Methods\nDESCRIPTION: Generic class for nullable boolean assertions that extends BooleanAssertions with methods for nullable-specific validations. Adds methods for checking null state and value presence in addition to boolean value assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_119\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableBooleanAssertions<TAssertions> : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<TAssertions>\n{\n    public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(bool? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(bool? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeFalse(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeTrue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Relationships (C#)\nDESCRIPTION: These methods assert relationships between collections, such as having the same count or intersecting.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> HaveSameCount<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> otherCollection, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> IntersectWith(System.Collections.Generic.IEnumerable<T> otherCollection, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: String Assertion Methods in FluentAssertions\nDESCRIPTION: A collection of method signatures for string assertions in the FluentAssertions library. These methods provide various ways to assert conditions on strings, such as checking for emptiness, case, content matching, and pattern matching.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_131\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeLowerCased(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeNullOrWhiteSpace(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeUpperCased(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContain(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainAll(params string[] values) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainAll(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainAny(params string[] values) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainAny(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotContainEquivalentOf(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotEndWith(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotEndWithEquivalentOf(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotEndWithEquivalentOf(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotMatchRegex(string regularExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotMatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotStartWith(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: XElementAssertions Methods for XML Element Testing in C#\nDESCRIPTION: Method signatures for the XElementAssertions class which provides assertion methods for testing XML elements. These methods allow checking for attributes, elements, values, and equivalence between XML elements with fluent syntax.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_157\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(System.Xml.Linq.XName expectedName, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(string expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(System.Xml.Linq.XName expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveValue(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBe(System.Xml.Linq.XElement unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBeEquivalentTo(System.Xml.Linq.XElement unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(string unexpectedName, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(System.Xml.Linq.XName unexpectedName, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(string unexpectedName, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(System.Xml.Linq.XName unexpectedName, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(string unexpectedElement, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Using AllTypes Fluent Syntax for Assembly Type Filtering in FluentAssertions\nDESCRIPTION: This snippet demonstrates an alternative, more fluent syntax for selecting types from an assembly with various filtering criteria, including positive and negative filters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/typesandmethods.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nAllTypes.From(assembly)\n  .ThatAreDecoratedWith<SomeAttribute>()\n  .ThatImplement<ISomeInterface>()\n  .ThatDeriveFrom<IDisposable>()\n  .ThatAreUnderNamespace(\"Internal.Main.Test\");\n\nAllTypes.From(assembly)\n  .ThatAreNotDecoratedWith<SomeAttribute>()\n  .ThatDoNotImplement<ISomeInterface>()\n  .ThatDoNotDeriveFrom<IDisposable>()\n  .ThatAreNotUnderNamespace(\"Internal.Main\")\n  .ThatAreNotInNamespace(\"Internal.Main.Test\");\n```\n\n----------------------------------------\n\nTITLE: Implementing TaskCompletionSourceAssertions Classes in C#\nDESCRIPTION: Defines assertion classes for TaskCompletionSource objects, both generic and non-generic variants, with methods to verify completion timing.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_137\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TaskCompletionSourceAssertions : FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase\n{\n    public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource tcs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource tcs, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n}\npublic class TaskCompletionSourceAssertionsBase\n{\n    protected TaskCompletionSourceAssertionsBase(FluentAssertions.Common.IClock clock) { }\n    public override bool Equals(object obj) { }\n}\npublic class TaskCompletionSourceAssertions<T> : FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase\n{\n    public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeApproximately Extension Methods for Numeric Types in C#\nDESCRIPTION: These extension methods add the NotBeApproximately assertion for various numeric types in FluentAssertions. They check if a numeric value is not approximately equal to an unexpected value within a specified precision.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal? unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, double? unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, float? unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<decimal>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<decimal> parent, decimal unexpectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<double> parent, double unexpectedValue, double precision, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> NotBeApproximately(this FluentAssertions.Numeric.NumericAssertions<float> parent, float unexpectedValue, float precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Type Property and Structural Assertion Methods in FluentAssertions\nDESCRIPTION: A comprehensive set of methods for the TypeAssertions class that enable fluent assertions about type characteristics including access modifiers, static/abstract/sealed nature, inheritance relationships, and method/property existence. Each method follows a fluent interface pattern allowing method chaining through AndConstraint returns.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_189\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeStatic(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> HaveDefaultConstructor(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveExplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty(System.Type interfaceType, string name, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> HaveExplicitProperty<TInterface>(string name, string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveImplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveIndexer(System.Type indexerType, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.MethodInfo> HaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty(System.Type propertyType, string name, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.PropertyInfo> HaveProperty<TProperty>(string name, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement(System.Type interfaceType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Implement<TInterface>(string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe(System.Type unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBe<TUnexpected>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAbstract(string because = \"\", params object[] becauseArgs) { }\npublic new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\npublic new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom(System.Type baseType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeDerivedFrom<TBaseClass>(string because = \"\", params object[] becauseArgs)\n    where TBaseClass :  class { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeSealed(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotBeStatic(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveDefaultConstructor(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitProperty(System.Type interfaceType, string name, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitProperty<TInterface>(string name, string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveIndexer(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveProperty(string name, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic EnumAssertions Class in C#\nDESCRIPTION: Generic class for asserting Enum values with fluent syntax. Provides methods for checking enum equality, whether values are defined, belong to a set of valid values, or have specific flags set. Uses generic constraints to support extension and chaining.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_111\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EnumAssertions<TEnum, TAssertions>\n    where TEnum :  struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>\n{\n    public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TEnum? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TEnum expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TEnum? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeDefined(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TEnum[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TEnum> validValues, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveFlag(TEnum expectedFlag, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Function Assertions Class\nDESCRIPTION: Generic class implementing assertions for asynchronous functions, supporting Task-based operations and exception verification in async contexts.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncFunctionAssertions<TTask, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<System.Func<TTask>, TAssertions>\n    where TTask : System.Threading.Tasks.Task\n    where TAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<TTask, TAssertions>\n{\n    protected AsyncFunctionAssertions(System.Func<TTask> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WithStrictOrderingFor Method\nDESCRIPTION: Configures strict ordering for a specific collection property. When enabled, collections must have items in the same order to be considered equivalent.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing XML Attribute and Document Assertions\nDESCRIPTION: Provides assertion classes for XML attributes and documents, enabling validation of XML structure and content through a fluent interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_192\n\nLANGUAGE: C#\nCODE:\n```\npublic class XAttributeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, FluentAssertions.Xml.XAttributeAssertions>\n{\n    public XAttributeAssertions(System.Xml.Linq.XAttribute attribute, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> Be(System.Xml.Linq.XAttribute expected, string because = \"\", params object[] becauseArgs) { }\n    // ... additional XML assertion methods\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TypeAssertions Class for Type-level Assertions in C#\nDESCRIPTION: This class provides methods for asserting various properties and characteristics of types, such as access modifiers, constructors, methods, and implemented interfaces.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_163\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeAssertions\n{\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SubsequentOrderingAssertions Class in C#\nDESCRIPTION: Generic class for handling ordered collection assertions with methods for checking ascending and descending order of properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic class SubsequentOrderingAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T>\n{\n    public SubsequentOrderingAssertions(System.Collections.Generic.IEnumerable<T> actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfoAssertions Class in C#\nDESCRIPTION: A class that provides assertion methods for PropertyInfo objects, allowing validation of property characteristics like readability, writability, and virtuality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoAssertions : FluentAssertions.Types.MemberInfoAssertions<System.Reflection.PropertyInfo, FluentAssertions.Types.PropertyInfoAssertions>\n    {\n        public PropertyInfoAssertions(System.Reflection.PropertyInfo propertyInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeReadable(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Core Constraint Classes for FluentAssertions in C#\nDESCRIPTION: Defines the core constraint classes that facilitate the fluent API pattern. These classes include AndConstraint and AndWhichConstraint, which enable method chaining and allow assertions to be combined in a natural language style.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace FluentAssertions\n{\n    public class AggregateExceptionExtractor : FluentAssertions.Specialized.IExtractExceptions\n    {\n        public AggregateExceptionExtractor() { }\n        public System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)\n            where T : System.Exception { }\n    }\n    public class AndConstraint<TParent>\n    {\n        public AndConstraint(TParent parent) { }\n        public TParent And { get; }\n    }\n    public class AndWhichConstraint<TParent, TSubject> : FluentAssertions.AndConstraint<TParent>\n    {\n        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects) { }\n        public AndWhichConstraint(TParent parent, TSubject subject) { }\n        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix) { }\n        public AndWhichConstraint(TParent parent, TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix = \"\") { }\n        public TSubject Subject { get; }\n        public TSubject Which { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Monitoring Subset of Events Using Generic Monitor in C#\nDESCRIPTION: Demonstrates how to limit event monitoring to a specific interface by using the generic version of Monitor(). This approach allows monitoring only events defined in the specified interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar subject = new ClassWithManyEvents();\nusing var monitor = subject.Monitor<IInterfaceWithFewEvents>();\n```\n\n----------------------------------------\n\nTITLE: Defining ExecutionTimeAssertions Class in C#\nDESCRIPTION: Class for making assertions about execution time measurements. Provides methods to assert whether execution times are within expected durations, greater than, less than, or close to specified time spans.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_139\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExecutionTimeAssertions\n    {\n        public ExecutionTimeAssertions(FluentAssertions.Specialized.ExecutionTime executionTime, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeCloseTo(System.TimeSpan expectedDuration, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThan(System.TimeSpan minDuration, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeGreaterThanOrEqualTo(System.TimeSpan minDuration, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThan(System.TimeSpan maxDuration, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Specialized.ExecutionTimeAssertions> BeLessThanOrEqualTo(System.TimeSpan maxDuration, string because = \"\", params object[] becauseArgs) { }\n        public override bool Equals(object obj) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining SimpleTimeSpanAssertions Class in C#\nDESCRIPTION: This class provides assertion methods for TimeSpan objects. It includes methods for comparing TimeSpan values, checking if they are positive or negative, and verifying if they are close to expected values within a specified precision.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleTimeSpanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>\n{\n    public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.TimeSpan? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.TimeSpan nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BePositive(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.TimeSpan unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.TimeSpan distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IExtractExceptions Interface in C#\nDESCRIPTION: Interface for extracting exceptions of a specific type from a caught exception. Provides a method to filter exceptions by type, supporting more complex assertion scenarios involving nested or wrapped exceptions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IExtractExceptions\n    {\n        System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)\n            where T : System.Exception;\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Exception Assertions in C#\nDESCRIPTION: This code snippet defines methods for asserting exceptions in asynchronous operations. It includes methods for asserting that no exception is thrown, that a specific exception is thrown, and that an exact exception type is thrown within a given timespan.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotThrowAsync<TException>(string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\npublic System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowAsync<TException>(string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\npublic System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowExactlyAsync<TException>(string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\npublic System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> ThrowWithinAsync<TException>(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs)\n    where TException : System.Exception { }\n```\n\n----------------------------------------\n\nTITLE: Cross-Enum Comparison in Fluent Assertions\nDESCRIPTION: Shows how to compare enums of different types using HaveSameValueAs and HaveSameNameAs methods. These methods allow comparison based on either the enum names or their underlying values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/enums.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nenum SameNameEnum { One = 11 }\nenum SameValueEnum { OneOne = 1 }\n\nMyEnum.One.Should().HaveSameNameAs(SameNameEnum.One);\nMyEnum.One.Should().HaveSameValueAs(SameValueEnum.OneOne);\n\nMyEnum.One.Should().NotHaveSameNameAs(SameValueEnum.OneOne);\nMyEnum.One.Should().NotHaveSameValueAs(SameNameEnum.One);\n```\n\n----------------------------------------\n\nTITLE: Implementing Type and Assembly Assertions in C#\nDESCRIPTION: Defines classes for asserting against Assembly and various reflection types, with methods to verify assembly signatures, references, and member attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_139\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace FluentAssertions.Types\n{\n    public static class AllTypes\n    {\n        public static FluentAssertions.Types.TypeSelector From(System.Reflection.Assembly assembly) { }\n    }\n    public class AssemblyAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Reflection.Assembly, FluentAssertions.Types.AssemblyAssertions>\n    {\n        public AssemblyAssertions(System.Reflection.Assembly assembly, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeSignedWithPublicKey(string publicKey, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeUnsigned(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.AssemblyAssertions, System.Type> DefineType(string @namespace, string name, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> NotReference(System.Reflection.Assembly assembly, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> Reference(System.Reflection.Assembly assembly, string because = \"\", params object[] becauseArgs) { }\n    }\n    public class ConstructorInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.ConstructorInfo, FluentAssertions.Types.ConstructorInfoAssertions>\n    {\n        public ConstructorInfoAssertions(System.Reflection.ConstructorInfo constructorInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n    }\n    public abstract class MemberInfoAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n        where TSubject : System.Reflection.MemberInfo\n        where TAssertions : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>\n    {\n        protected MemberInfoAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting on events, allowing filtering by sender and argument predicates.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Events.IEventRecording WithArgs<T>(this FluentAssertions.Events.IEventRecording eventRecording, System.Linq.Expressions.Expression<System.Func<T, bool>> predicate) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Events.IEventRecording WithArgs<T>(this FluentAssertions.Events.IEventRecording eventRecording, params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Events.IEventRecording WithSender(this FluentAssertions.Events.IEventRecording eventRecording, object expectedSender) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing BeCloseTo Methods for Integer Assertions in C#\nDESCRIPTION: Extension methods for asserting that integer values are close to a target value within a specified delta. These methods support various integer types (byte, short, int, long) and their unsigned variants. They allow for fluent assertion chaining via AndConstraint.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte nearbyValue, byte delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short nearbyValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int nearbyValue, uint delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long nearbyValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte nearbyValue, byte delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort nearbyValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint nearbyValue, uint delta, string because = \"\", params object[] becauseArgs) { }\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong nearbyValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing FluentDateTimeExtensions for DateTime Operations\nDESCRIPTION: Static extension methods for DateTime and DateTimeOffset classes providing fluent API for date and time operations. Includes methods for date creation, conversion, and precision timing.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentDateTimeExtensions\n{\n    public static System.DateTime AddMicroseconds(this System.DateTime self, long microseconds) { }\n    public static System.DateTimeOffset AddMicroseconds(this System.DateTimeOffset self, long microseconds) { }\n    public static System.DateTime AddNanoseconds(this System.DateTime self, long nanoseconds) { }\n    public static System.DateTimeOffset AddNanoseconds(this System.DateTimeOffset self, long nanoseconds) { }\n    public static System.DateTime After(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }\n    public static System.DateTime April(this int day, int year) { }\n    public static System.DateTime AsLocal(this System.DateTime dateTime) { }\n    public static System.DateTime AsUtc(this System.DateTime dateTime) { }\n    public static System.DateTime At(this System.DateTime date, System.TimeSpan time) { }\n    public static System.DateTime At(this System.DateTime date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }\n    public static System.DateTimeOffset At(this System.DateTimeOffset date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }\n    public static System.DateTime August(this int day, int year) { }\n    public static System.DateTime Before(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }\n    public static System.DateTime December(this int day, int year) { }\n    public static System.DateTime February(this int day, int year) { }\n    public static System.DateTime January(this int day, int year) { }\n    public static System.DateTime July(this int day, int year) { }\n    public static System.DateTime June(this int day, int year) { }\n    public static System.DateTime March(this int day, int year) { }\n    public static System.DateTime May(this int day, int year) { }\n    public static int Microsecond(this System.DateTime self) { }\n    public static int Microsecond(this System.DateTimeOffset self) { }\n    public static int Nanosecond(this System.DateTime self) { }\n    public static int Nanosecond(this System.DateTimeOffset self) { }\n    public static System.DateTime November(this int day, int year) { }\n    public static System.DateTime October(this int day, int year) { }\n    public static System.DateTime September(this int day, int year) { }\n    public static System.DateTimeOffset WithOffset(this System.DateTime self, System.TimeSpan offset) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Serialization Assertions in FluentAssertions\nDESCRIPTION: Extension methods for asserting that objects can be serialized using DataContract and XML serialization. These methods allow testing serialization capabilities with custom equivalency options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable<T>(this FluentAssertions.Primitives.ObjectAssertions assertions, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<T>, FluentAssertions.Equivalency.EquivalencyOptions<T>> options, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeXmlSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining ComparableTypeAssertions in C# for FluentAssertions\nDESCRIPTION: This code defines the ComparableTypeAssertions class, which provides methods for making assertions on comparable types. It includes methods for comparing values, checking ranges, and asserting equality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic class ComparableTypeAssertions<T, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<System.IComparable<T>, TAssertions>\n    where TAssertions : FluentAssertions.Numeric.ComparableTypeAssertions<T, TAssertions>\n{\n    public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(T expected, string because = \"\", params object[] becauseArgs) { }\n    // ... other methods ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OccurredEvent Class for Event Tracking\nDESCRIPTION: Class representing an event that has occurred during monitoring. Stores event details including name, parameters, sequence number, and timestamp for later analysis.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic class OccurredEvent\n{\n    public OccurredEvent() { }\n    public string EventName { get; set; }\n    public object[] Parameters { get; set; }\n    public int Sequence { get; set; }\n    public System.DateTime TimestampUtc { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Assertion Methods in C#\nDESCRIPTION: This snippet shows the implementation of various assertion methods for strings in the StringAssertions<TAssertions> class. It includes methods for comparing, containing, and matching strings with different criteria.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_136\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringAssertions<TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<string, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.StringAssertions<TAssertions>\n{\n    public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLowerCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNullOrWhiteSpace(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params string[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<string> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeUpperCased(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Contain(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAll(params string[] values) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAll(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAny(params string[] values) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainAny(System.Collections.Generic.IEnumerable<string> values, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainEquivalentOf(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWith(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> EndWithEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveLength(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchEquivalentOf(string wildcardPattern, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(string regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> MatchRegex(System.Text.RegularExpressions.Regex regularExpression, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(string unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Dictionary Assertions Class in FluentAssertions\nDESCRIPTION: This class implements dictionary-specific assertions for FluentAssertions. It extends the generic collection assertions and provides a constructor that takes a collection of key-value pairs and an assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue> : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue>>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Method Info Selector Assertions in FluentAssertions\nDESCRIPTION: Defines methods for making assertions about selected methods in the FluentAssertions library. This class provides methods to assert that selected methods have specific characteristics such as access modifiers, being async, virtual, or decorated with specific attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_150\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoSelectorAssertions\n{\n    public MethodInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.MethodInfo[] methods) { }\n    protected string Context { get; }\n    public System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> SubjectMethods { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> Be(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeAsync(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBe(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeAsync(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for XML Types in FluentAssertions\nDESCRIPTION: Provides extension methods for XDocument and XElement types to enable fluent assertions. These methods allow for XML validation and verification through a fluent API.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Xml.XDocumentAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XDocument actualValue) { }\npublic static FluentAssertions.Xml.XElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XElement actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Retrying Async Assertion with Timeout in C#\nDESCRIPTION: Illustrates how to retry an asynchronous assertion until it succeeds or a specified time elapses, useful for testing asynchronous operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nStopwatch watch = Stopwatch.StartNew();\nvar act = async () =>\n{\n    if (watch.ElapsedMilliseconds <= 1000)\n    {\n        throw new ArgumentException(\"The wait time has not yet elapsed.\");\n    }\n\n    await Task.CompletedTask;\n};\n\nawait act.Should().ThrowAsync<ArgumentException>();\nawait act.Should().NotThrowAfterAsync(2.Seconds(), 100.Milliseconds());\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Filtering Extensions for IEnumerable<Type> in C#\nDESCRIPTION: Extension methods for filtering collections of System.Type objects based on various criteria such as inheritance, implementation, namespace, or decoration with attributes. These methods enable fluent type filtering in reflection scenarios.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TypeEnumerableExtensions\n{\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreInNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreUnderNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatDeriveFrom<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatImplement<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatSatisfy(this System.Collections.Generic.IEnumerable<System.Type> types, System.Func<System.Type, bool> predicate) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> UnwrapEnumerableTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> UnwrapTaskTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DelegateAssertions Abstract Class in FluentAssertions.Specialized\nDESCRIPTION: Abstract class for delegate assertions that extends DelegateAssertionsBase. It provides methods for asserting that delegates throw or don't throw specific exceptions when invoked, with the actual invocation mechanism left to derived classes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_136\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class DelegateAssertions<TDelegate, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>\n    where TDelegate : System.Delegate\n    where TAssertions : FluentAssertions.Specialized.DelegateAssertions<TDelegate, TAssertions>\n{\n    protected DelegateAssertions(TDelegate @delegate, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected abstract void InvokeSubject();\n    public FluentAssertions.AndConstraint<TAssertions> NotThrow<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> Throw<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowExactly<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SimpleTimeSpanAssertions Class in C#\nDESCRIPTION: Non-generic class for TimeSpan assertions, extending the generic SimpleTimeSpanAssertions class. Provides a concrete implementation for TimeSpan assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_160\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SimpleTimeSpanAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<FluentAssertions.Primitives.SimpleTimeSpanAssertions>\n{\n    public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ModuleInitializer in .NET 5+\nDESCRIPTION: Implementation of module initialization using ModuleInitializerAttribute for configuring Fluent Assertions defaults in .NET 5 and higher applications.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static class Initializer\n{\n    [ModuleInitializer]\n    public static void SetDefaults()\n    {\n        AssertionConfiguration.Current.Equivalency.Modify(\n            options => { <configure here> });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Order and Structure (C#)\nDESCRIPTION: These methods assert specific ordering and structural properties of collections, such as containing elements in consecutive order, starting or ending with specific elements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(params T[] expected) { }\npublic FluentAssertions.AndConstraint<TAssertions> ContainInConsecutiveOrder(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> ContainInOrder(params T[] expected) { }\npublic FluentAssertions.AndConstraint<TAssertions> ContainInOrder(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> EndWith(System.Collections.Generic.IEnumerable<T> expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> EndWith(T element, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeNaN Extension Methods for Double and Float in C#\nDESCRIPTION: These extension methods add the NotBeNaN assertion for double and float types in FluentAssertions. They check if a numeric value is not NaN (Not a Number).\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> NotBeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> NotBeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> NotBeNaN(this FluentAssertions.Numeric.NumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> NotBeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing SubsequentOrderingAssertions Class in C#\nDESCRIPTION: Defines a class for chaining multiple ordering assertions on collections with a fluent API. It provides methods to assert that collections are in ascending or descending order based on specified properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_45\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SubsequentOrderingAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T>\n{\n    public SubsequentOrderingAssertions(System.Collections.Generic.IEnumerable<T> actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ObjectAssertions in C#\nDESCRIPTION: Defines a class for fluent assertions on object values. Extends the generic version and provides additional assertion methods with comparison capabilities using custom comparers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic class ObjectAssertions : FluentAssertions.Primitives.ObjectAssertions<object, FluentAssertions.Primitives.ObjectAssertions>\n{\n    public ObjectAssertions(object value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> Be<TExpectation>(TExpectation expected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeOneOf<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> validValues, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> NotBe<TExpectation>(TExpectation unexpected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MethodBaseAssertions Abstract Class in C#\nDESCRIPTION: An abstract base class for assertions on MethodBase objects. It provides common assertions for method-like members regarding access modifiers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MethodBaseAssertions<TSubject, TAssertions> : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>\n        where TSubject : System.Reflection.MethodBase\n        where TAssertions : FluentAssertions.Types.MethodBaseAssertions<TSubject, TAssertions>\n    {\n        protected MethodBaseAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public FluentAssertions.AndConstraint<TAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<TAssertions> NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Boolean Assertions in C#\nDESCRIPTION: This snippet defines the BooleanAssertions class for asserting conditions on boolean values. It includes methods for checking true/false conditions and logical implications.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\npublic class BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n{\n    public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public bool? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(bool expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeFalse(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeTrue(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Imply(bool consequent, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(bool unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Assertion Extensions in FluentAssertions (C#)\nDESCRIPTION: Extension methods for asserting against enum values, supporting both standard and nullable enum types. These methods initialize the fluent assertion chain for enum-specific assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.Primitives.EnumAssertions<TEnum> Should<TEnum>(this TEnum @enum)\n    where TEnum :  struct, System.Enum { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.Primitives.NullableEnumAssertions<TEnum> Should<TEnum>([System.Diagnostics.CodeAnalysis.NotNull] this TEnum? @enum)\n    where TEnum :  struct, System.Enum { }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Extension Methods in C#\nDESCRIPTION: Defines extension methods for DateTime and DateTimeOffset to provide fluent manipulation capabilities. These methods include adding time components, converting between time zones, and creating specific dates.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_84\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentDateTimeExtensions\n    {\n        public static System.DateTime AddMicroseconds(this System.DateTime self, long microseconds) { }\n        public static System.DateTimeOffset AddMicroseconds(this System.DateTimeOffset self, long microseconds) { }\n        public static System.DateTime AddNanoseconds(this System.DateTime self, long nanoseconds) { }\n        public static System.DateTimeOffset AddNanoseconds(this System.DateTimeOffset self, long nanoseconds) { }\n        public static System.DateTime After(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }\n        public static System.DateTime April(this int day, int year) { }\n        public static System.DateTime AsLocal(this System.DateTime dateTime) { }\n        public static System.DateTime AsUtc(this System.DateTime dateTime) { }\n        public static System.DateTime At(this System.DateTime date, System.TimeSpan time) { }\n        public static System.DateTime At(this System.DateTime date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }\n        public static System.DateTimeOffset At(this System.DateTimeOffset date, int hours, int minutes, int seconds = 0, int milliseconds = 0, int microseconds = 0, int nanoseconds = 0) { }\n        public static System.DateTime August(this int day, int year) { }\n        public static System.DateTime Before(this System.TimeSpan timeDifference, System.DateTime sourceDateTime) { }\n        public static System.DateTime December(this int day, int year) { }\n        public static System.DateTime February(this int day, int year) { }\n        public static System.DateTime January(this int day, int year) { }\n        public static System.DateTime July(this int day, int year) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Enum Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting on enum values. These methods enable fluent assertions for both regular and nullable enum types, with appropriate type constraints.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic static class EnumAssertionsExtensions\n{\n    public static FluentAssertions.Primitives.EnumAssertions<TEnum> Should<TEnum>(this TEnum @enum)\n        where TEnum :  struct, System.Enum { }\n    public static FluentAssertions.Primitives.NullableEnumAssertions<TEnum> Should<TEnum>([System.Diagnostics.CodeAnalysis.NotNull] this TEnum? @enum)\n        where TEnum :  struct, System.Enum { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StringCollectionAssertions Class in C#\nDESCRIPTION: This snippet defines the StringCollectionAssertions class, which inherits from GenericCollectionAssertions and provides methods for asserting properties of string collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringCollectionAssertions<TCollection, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, string, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<string>\n    where TAssertions : FluentAssertions.Collections.StringCollectionAssertions<TCollection, TAssertions>\n{\n    public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(params string[] expectation) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, string> ContainMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<string> expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal(params string[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ObjectAssertions in C#\nDESCRIPTION: Concrete implementation of assertions for object values. Inherits from ObjectAssertions<T,T> and adds specialized methods for comparing objects using custom equality comparers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_120\n\nLANGUAGE: C#\nCODE:\n```\npublic class ObjectAssertions : FluentAssertions.Primitives.ObjectAssertions<object, FluentAssertions.Primitives.ObjectAssertions>\n{\n    public ObjectAssertions(object value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> Be<TExpectation>(TExpectation expected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeOneOf<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> validValues, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> NotBe<TExpectation>(TExpectation unexpected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic StringCollectionAssertions Class in C#\nDESCRIPTION: Defines a generic class for making assertions on collections of strings with a specific collection type, inheriting from the more generic StringCollectionAssertions class.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StringCollectionAssertions<TCollection> : FluentAssertions.Collections.StringCollectionAssertions<TCollection, FluentAssertions.Collections.StringCollectionAssertions<TCollection>>\n    where TCollection : System.Collections.Generic.IEnumerable<string>\n{\n    public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumAssertions Methods\nDESCRIPTION: Method signatures for EnumAssertions class, providing various assertion methods for enum values including equality testing, flag testing, and value validation. Methods return AndConstraint for fluent chaining.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_153\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> Be(TEnum? expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeDefined(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TEnum[] validValues) { }\npublic FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TEnum> validValues, string because = \"\", params object[] becauseArgs) { }\npublic override bool Equals(object obj) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveFlag(TEnum expectedFlag, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveSameNameAs<T>(T expected, string because = \"\", params object[] becauseArgs)\n    where T :  struct, System.Enum { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveSameValueAs<T>(T expected, string because = \"\", params object[] becauseArgs)\n    where T :  struct, System.Enum { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveValue(decimal expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TEnum?, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBe(TEnum unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBe(TEnum? unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeDefined(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveFlag(TEnum unexpectedFlag, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveSameNameAs<T>(T unexpected, string because = \"\", params object[] becauseArgs)\n    where T :  struct, System.Enum { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveSameValueAs<T>(T unexpected, string because = \"\", params object[] becauseArgs)\n    where T :  struct, System.Enum { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveValue(decimal unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Property Info Selector in FluentAssertions\nDESCRIPTION: Defines methods for selecting and filtering property information in the FluentAssertions library. This class implements IEnumerable<PropertyInfo> and provides methods and properties for filtering properties based on various criteria such as being abstract, static, virtual, or decorated with specific attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_152\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>, System.Collections.IEnumerable\n{\n    public PropertyInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public PropertyInfoSelector(System.Type type) { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreAbstract { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotAbstract { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotStatic { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotVirtual { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatArePublicOrInternal { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreStatic { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreVirtual { get; }\n    public System.Collections.Generic.IEnumerator<System.Reflection.PropertyInfo> GetEnumerator() { }\n    public FluentAssertions.Types.PropertyInfoSelector NotOfType<TReturn>() { }\n    public FluentAssertions.Types.PropertyInfoSelector OfType<TReturn>() { }\n    public FluentAssertions.Types.TypeSelector ReturnTypes() { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public System.Reflection.PropertyInfo[] ToArray() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Exactly Occurrence Constraints in FluentAssertions (C#)\nDESCRIPTION: Static methods for creating occurrence constraints that specify an exact number of expected occurrences. These constraints are used with event monitoring and collection assertions to verify exact occurrence requirements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Exactly\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Equality Equivalency Step Implementation\nDESCRIPTION: Example implementation of a basic equivalency step for non-recursive equality comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SimpleEqualityEquivalencyStep : IEquivalencyStep\n{\n    public EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IValidateChildNodeEquivalency nestedValidator)\n    {\n        if (!context.Options.IsRecursive && !context.CurrentNode.IsRoot)\n        {\n            comparands.Subject.Should().Be(comparands.Expectation, context.Reason.FormattedMessage, context.Reason.Arguments);\n\n            return EquivalencyResult.EquivalencyProven;\n        }\n\n        return EquivalencyResult.ContinueWithNext;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: EnumAssertions Generic Class Implementation in FluentAssertions\nDESCRIPTION: Non-generic facade class for enum assertions that inherits from the generic version. This class simplifies working with enum assertions by providing a concrete implementation with fixed generic parameters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_114\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EnumAssertions<TEnum> : FluentAssertions.Primitives.EnumAssertions<TEnum, FluentAssertions.Primitives.EnumAssertions<TEnum>>\n    where TEnum :  struct, System.Enum\n{\n    public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic DateTimeOffsetAssertions Class Definition\nDESCRIPTION: Generic base class for DateTimeOffset assertions providing extensive validation methods including equality, comparison, range checks and component validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_120\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeOffsetAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n{\n    public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTimeOffset? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    // ... additional assertion methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Should Extension Methods for Primitive Types in C#\nDESCRIPTION: Defines Should extension methods for various primitive types like bool, byte, decimal, etc. These methods return appropriate numeric or boolean assertion types, allowing for fluent assertions on primitive values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Primitives.BooleanAssertions Should(this bool actualValue) { }\npublic static FluentAssertions.Primitives.NullableBooleanAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this bool? actualValue) { }\npublic static FluentAssertions.Numeric.NumericAssertions<byte> Should(this byte actualValue) { }\npublic static FluentAssertions.Numeric.NullableNumericAssertions<byte> Should([System.Diagnostics.CodeAnalysis.NotNull] this byte? actualValue) { }\n// ... (similar methods for other primitive types)\n```\n\n----------------------------------------\n\nTITLE: Asserting Collection Equality (C#)\nDESCRIPTION: These methods assert that a collection is equal to another collection, with options for custom equality comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> Equal(params T[] elements) { }\npublic FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<T> expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> Equal<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> expectation, System.Func<T, TExpectation, bool> equalityComparison, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffset Assertions Implementation in C#\nDESCRIPTION: Defines a class containing assertion methods for DateTimeOffset values with various comparison operations like Be, BeAfter, BeBefore, BeCloseTo etc. Includes methods for checking specific date components and offset values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_138\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeOffsetAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n{\n    public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTimeOffset? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenericAsyncFunctionAssertions<TResult> Class in C#\nDESCRIPTION: Class for making assertions about asynchronous functions returning Task<TResult>. Provides methods for asserting async functions complete within timespan and don't throw exceptions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericAsyncFunctionAssertions<TResult> : FluentAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task<TResult>, FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>>\n    {\n        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAsync(string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining IEquivalencyOptions Interface\nDESCRIPTION: Defines an interface for equivalency options that control the behavior of equivalency validation. Contains properties for various comparison strategies and collections of rules.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEquivalencyOptions\n{\n    bool AllowInfiniteRecursion { get; }\n    bool? CompareRecordsByValue { get; }\n    FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    FluentAssertions.Equivalency.CyclicReferenceHandling CyclicReferenceHandling { get; }\n    FluentAssertions.Equivalency.EnumEquivalencyHandling EnumEquivalencyHandling { get; }\n    bool ExcludeNonBrowsableOnExpectation { get; }\n    bool IgnoreCase { get; }\n    bool IgnoreLeadingWhitespace { get; }\n    bool IgnoreNewlineStyle { get; }\n    bool IgnoreNonBrowsableOnSubject { get; }\n    bool IgnoreTrailingWhitespace { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }\n    bool IsRecursive { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberMatchingRule> MatchingRules { get; }\n    FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberSelectionRule> SelectionRules { get; }\n    FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }\n    bool UseRuntimeTyping { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep> UserEquivalencySteps { get; }\n    FluentAssertions.Equivalency.EqualityStrategy GetEqualityStrategy(System.Type type);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BooleanAssertions Class in C#\nDESCRIPTION: Defines a BooleanAssertions class that extends BooleanAssertions<TAssertions> for implementing fluent assertions for boolean values. It provides a constructor that accepts a nullable boolean value and an AssertionChain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_100\n\nLANGUAGE: csharp\nCODE:\n```\npublic class BooleanAssertions : FluentAssertions.Primitives.BooleanAssertions<FluentAssertions.Primitives.BooleanAssertions>\n{\n    public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Monitor with Options in C#\nDESCRIPTION: Shows how to configure the event monitor by passing an options lambda to the Monitor method. This allows customizing the behavior of the monitor.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/eventmonitoring.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar subject = new EditCustomerViewModel();\nusing var monitoredSubject = subject.Monitor(options => ...);\n```\n\n----------------------------------------\n\nTITLE: Implementing SelfReferenceEquivalencyOptions Generic Class in C#\nDESCRIPTION: Abstract base class providing fluent configuration options for equivalency comparison. Offers numerous methods to customize how equivalency is determined, including handling of specific types, member selection, and recursive comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_92\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class SelfReferenceEquivalencyOptions<TSelf> : FluentAssertions.Equivalency.IEquivalencyOptions\n    where TSelf : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>\n{\n    protected SelfReferenceEquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }\n    public bool? CompareRecordsByValue { get; }\n    public FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    public bool IgnoreCase { get; }\n    public bool IgnoreLeadingWhitespace { get; }\n    public bool IgnoreNewlineStyle { get; }\n    public bool IgnoreTrailingWhitespace { get; }\n    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]\n    protected FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }\n    public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }\n    protected TSelf AddMatchingRule(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }\n    protected TSelf AddSelectionRule(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }\n    public TSelf AllowingInfiniteRecursion() { }\n    public TSelf ComparingByMembers(System.Type type) { }\n    public TSelf ComparingByMembers<T>() { }\n    public TSelf ComparingByValue(System.Type type) { }\n    public TSelf ComparingByValue<T>() { }\n    public TSelf ComparingEnumsByName() { }\n    public TSelf ComparingEnumsByValue() { }\n    public TSelf ComparingRecordsByMembers() { }\n    public TSelf ComparingRecordsByValue() { }\n    public TSelf Excluding(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }\n    public TSelf ExcludingExplicitlyImplementedProperties() { }\n    public TSelf ExcludingFields() { }\n    public TSelf ExcludingMissingMembers() { }\n    public TSelf ExcludingNonBrowsableMembers() { }\n    public TSelf ExcludingProperties() { }\n    public TSelf IgnoringCase() { }\n    public TSelf IgnoringCyclicReferences() { }\n    public TSelf IgnoringLeadingWhitespace() { }\n    public TSelf IgnoringNewlineStyle() { }\n    public TSelf IgnoringNonBrowsableMembersOnSubject() { }\n    public TSelf IgnoringTrailingWhitespace() { }\n    public TSelf Including(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }\n    public TSelf IncludingAllDeclaredProperties() { }\n    public TSelf IncludingAllRuntimeProperties() { }\n    public TSelf IncludingFields() { }\n    public TSelf IncludingInternalFields() { }\n    public TSelf IncludingInternalProperties() { }\n    public TSelf IncludingNestedObjects() { }\n    public TSelf IncludingProperties() { }\n    public TSelf PreferringDeclaredMemberTypes() { }\n    public TSelf PreferringRuntimeMemberTypes() { }\n    public TSelf ThrowingOnMissingMembers() { }\n    public override string ToString() { }\n    public TSelf Using(FluentAssertions.Equivalency.IEquivalencyStep equivalencyStep) { }\n    public TSelf Using(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }\n    public TSelf Using(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }\n    public TSelf Using(FluentAssertions.Equivalency.IOrderingRule orderingRule) { }\n    public TSelf Using(System.Collections.Generic.IEqualityComparer<string> comparer) { }\n    public FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>.Restriction<TProperty> Using<TProperty>(System.Action<FluentAssertions.Equivalency.IAssertionContext<TProperty>> action) { }\n    public TSelf Using<T>(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public TSelf Using<T, TEqualityComparer>()\n        where TEqualityComparer : System.Collections.Generic.IEqualityComparer<T>, new () { }\n    public TSelf WithAutoConversion() { }\n    public TSelf WithAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithStrictOrdering() { }\n    public TSelf WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithTracing(FluentAssertions.Equivalency.Tracing.ITraceWriter writer = null) { }\n    public TSelf WithoutAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithoutMatchingRules() { }\n    public TSelf WithoutRecursing() { }\n    public TSelf WithoutSelectionRules() { }\n    public TSelf WithoutStrictOrdering() { }\n    public TSelf WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public class Restriction<TMember>\n    {\n        public Restriction(TSelf options, System.Action<FluentAssertions.Equivalency.IAssertionContext<TMember>> action) { }\n        public TSelf When(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n        public TSelf WhenTypeIs<TMemberType>()\n            where TMemberType : TMember { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamAssertions in C#\nDESCRIPTION: Defines the StreamAssertions class for asserting properties of System.IO.Stream objects. It includes methods for checking if a stream is readable, writable, seekable, and has specific length or position.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic class StreamAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.IO.Stream\n    where TAssertions : FluentAssertions.Streams.StreamAssertions<TSubject, TAssertions>\n{\n    public StreamAssertions(TSubject stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeReadOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSeekable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveLength(long expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HavePosition(long expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeReadOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSeekable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveLength(long unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHavePosition(long unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DirectoryInfo Value Formatter\nDESCRIPTION: Complete implementation of a custom value formatter for DirectoryInfo objects, showing how to handle both inline and line-break formatting.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DirectoryInfoValueFormatter : IValueFormatter\n{\n    public bool CanHandle(object value)\n    {\n        return value is DirectoryInfo;\n    }\n\n    void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild)\n    {\n        var info = (DirectoryInfo)value;\n        string result = $\"{info.FullName} ({info.GetFiles().Length} files, {info.GetDirectories().Length} directories)\";\n\n        if (context.UseLineBreaks)\n        {\n            // Forces the result to be added as a separate line in the final output\n            formattedGraph.AddLine(result);\n        }\n        else\n        {\n            // Appends the result to any existing fragments on the current line\n            formattedGraph.AddFragment(result);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Assertion Continuation Classes in C#\nDESCRIPTION: Defines the Continuation, ContinuationOfGiven, and GivenSelector classes that support fluent assertion chains. These classes allow for conditional assertions and managing the flow of assertion logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic class Continuation\n    {\n        public FluentAssertions.Execution.AssertionChain Then { get; }\n    }\n    public class ContinuationOfGiven<TSubject>\n    {\n        public bool Succeeded { get; }\n        public FluentAssertions.Execution.GivenSelector<TSubject> Then { get; }\n    }\n    public class GivenSelector<T>\n    {\n        public bool Succeeded { get; }\n        public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message) { }\n        public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params System.Func<T, object>[] args) { }\n        public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params object[] args) { }\n        public FluentAssertions.Execution.GivenSelector<T> ForCondition(System.Func<T, bool> predicate) { }\n        public FluentAssertions.Execution.GivenSelector<TOut> Given<TOut>(System.Func<T, TOut> selector) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Core Assertion Classes Implementation in C#\nDESCRIPTION: Implements core assertion classes including AggregateExceptionExtractor, AndConstraint, and AndWhichConstraint for building fluent assertion chains. Provides base functionality for assertion composition.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AggregateExceptionExtractor : FluentAssertions.Specialized.IExtractExceptions\n{\n    public AggregateExceptionExtractor() { }\n    public System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)\n        where T : System.Exception { }\n}\npublic class AndConstraint<TParent>\n{\n    public AndConstraint(TParent parent) { }\n    public TParent And { get; }\n}\npublic class AndWhichConstraint<TParent, TSubject> : FluentAssertions.AndConstraint<TParent>\n{\n    public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects) { }\n    public AndWhichConstraint(TParent parent, TSubject subject) { }\n    public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix) { }\n    public AndWhichConstraint(TParent parent, TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix = \"\") { }\n    public TSubject Subject { get; }\n    public TSubject Which { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: XML Node Equivalence Assertion Methods\nDESCRIPTION: Methods for asserting equivalence between XML nodes, including both positive and negative assertions. These methods compare structural and content equality between XML nodes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_176\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Xml.XmlNode expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(System.Xml.XmlNode unexpected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing BeNaN Methods for Floating-Point Types in FluentAssertions\nDESCRIPTION: Extension methods that assert whether double and float values are NaN (Not a Number). These methods work with both nullable and non-nullable types and provide a consistent way to check for this special floating-point value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic XML Node Assertions in C#\nDESCRIPTION: The generic XmlNodeAssertions<TSubject, TAssertions> class provides methods for asserting XML node equivalence. It inherits from ReferenceTypeAssertions<TSubject, TAssertions> and is constrained to XML node types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_164\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.Xml.XmlNode\n    where TAssertions : FluentAssertions.Xml.XmlNodeAssertions<TSubject, TAssertions>\n{\n    public XmlNodeAssertions(TSubject xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Xml.XmlNode expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(System.Xml.XmlNode unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Event Assertions in C#\nDESCRIPTION: Shows the changes in chaining event assertions in FluentAssertions 6.0. Demonstrates how to adapt code to the new behavior where event constraining extensions return only matching events.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nfoo\n    .ShouldRaise(\"SomeEvent\")\n         .WithArgs<string>(args => args == \"some event payload\")\n         .WithArgs<string>(args => args == \"other payload\");\n```\n\nLANGUAGE: csharp\nCODE:\n```\nfoo\n    .ShouldRaise(\"SomeEvent\")\n    .WithArgs<string>(args => args == \"some event payload\");\n\nfoo\n    .ShouldRaise(\"SomeEvent\")\n    .WithArgs<string>(args => args == \"other payload\");\n```\n\n----------------------------------------\n\nTITLE: Async Function Assertions Implementation in C#\nDESCRIPTION: Implements assertion methods for asynchronous functions returning Task objects. Provides timing and completion verification for async operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic class AsyncFunctionAssertions<TTask, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<System.Func<TTask>, TAssertions>\n    where TTask : System.Threading.Tasks.Task\n    where TAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<TTask, TAssertions>\n{\n    protected AsyncFunctionAssertions(System.Func<TTask> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<TAssertions>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Static Formatter Registry for Managing Value Formatters\nDESCRIPTION: Static class that serves as a registry for IValueFormatter implementations. Provides methods to add, remove, and access formatters, as well as a central ToString method that delegates to the appropriate formatter for a given value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_97\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Formatter\n{\n    public static System.Collections.Generic.IEnumerable<FluentAssertions.Formatting.IValueFormatter> Formatters { get; }\n    public static void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public static void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public static string ToString(object value, FluentAssertions.Formatting.FormattingOptions options = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Nullable DateTimeOffset Assertions in C#\nDESCRIPTION: Generic implementation for nullable DateTimeOffset assertions providing methods for checking null values and value validation with custom error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeOffsetAssertions<TAssertions> : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<TAssertions>\n{\n    public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionFailedException Class\nDESCRIPTION: Custom exception class thrown when assertions fail. Inherits from System.Exception and is used to report assertion failures throughout the FluentAssertions library.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionFailedException : System.Exception\n{\n    public AssertionFailedException(string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: XDocumentAssertions Class Implementation in C#\nDESCRIPTION: Defines the XDocumentAssertions class that extends ReferenceTypeAssertions to provide fluent assertion methods for XDocument objects. It includes methods to verify document structure, element presence, and equivalence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_160\n\nLANGUAGE: C#\nCODE:\n```\npublic class XDocumentAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XDocument, FluentAssertions.Xml.XDocumentAssertions>\n{\n    public XDocumentAssertions(System.Xml.Linq.XDocument document, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> Be(System.Xml.Linq.XDocument expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> BeEquivalentTo(System.Xml.Linq.XDocument expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBe(System.Xml.Linq.XDocument unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBeEquivalentTo(System.Xml.Linq.XDocument unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(string unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Serialization Assertions in C#\nDESCRIPTION: Extension method for asserting that an object is data contract serializable. This method extends ObjectAssertions to verify serialization capabilities.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing AssemblyAssertions in C#\nDESCRIPTION: Defines the AssemblyAssertions class for asserting properties of System.Reflection.Assembly objects. It includes methods for checking assembly signatures, type definitions, and references.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssemblyAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Reflection.Assembly, FluentAssertions.Types.AssemblyAssertions>\n{\n    public AssemblyAssertions(System.Reflection.Assembly assembly, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeSignedWithPublicKey(string publicKey, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeUnsigned(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.AssemblyAssertions, System.Type> DefineType(string @namespace, string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> NotReference(System.Reflection.Assembly assembly, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> Reference(System.Reflection.Assembly assembly, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericDictionaryEquivalencyStep in C#\nDESCRIPTION: Class for comparing generic dictionaries in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to handle specialized generic dictionary comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_100\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public GenericDictionaryEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffset Range Assertions in C#\nDESCRIPTION: Implements range-based assertions for DateTimeOffset values, allowing comparison of time spans and relative positioning of dates using Before and After operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_139\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeOffsetRangeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n{\n    protected DateTimeOffsetRangeAssertions(TAssertions parentAssertions, FluentAssertions.Execution.AssertionChain assertionChain, System.DateTimeOffset? subject, FluentAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> After(System.DateTimeOffset target, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Before(System.DateTimeOffset target, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Negative Collection Properties (C#)\nDESCRIPTION: These methods assert that collections do not have certain properties, such as not being empty, not being in a specific order, or not being equivalent to another collection.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeNullOrEmpty(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeSubsetOf(System.Collections.Generic.IEnumerable<T> unexpectedSuperset, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalency Step Interface in C#\nDESCRIPTION: Interface for steps in the equivalency validation pipeline, with a method to handle the validation of a pair of objects and return a result indicating whether to continue validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEquivalencyStep\n{\n    FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ObjectAssertions Generic Class in C#\nDESCRIPTION: Abstract class for assertions on objects. Inherits from ReferenceTypeAssertions<T,T> and provides methods for equality, equivalence, and value comparison with various overloads for custom comparers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_121\n\nLANGUAGE: C#\nCODE:\n```\npublic class ObjectAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.ObjectAssertions<TSubject, TAssertions>\n{\n    public ObjectAssertions(TSubject value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params TSubject[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<TSubject> validValues, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(TSubject unexpected, System.Collections.Generic.IEqualityComparer<TSubject> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo<TExpectation>(TExpectation unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>, FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>> config, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: GenericDictionaryAssertions Class Declaration in FluentAssertions\nDESCRIPTION: Defines a generic dictionary assertion class that inherits from GenericDictionaryAssertions with four type parameters. This class serves as a convenience wrapper with a simpler constructor signature.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue> : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue>>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NonGenericAsyncFunctionAssertions Class in C#\nDESCRIPTION: Class for making assertions about non-generic async functions returning Task. Provides methods to assert that async void methods complete within timespan and don't throw exceptions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic class NonGenericAsyncFunctionAssertions : FluentAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task, FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>\n    {\n        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public NonGenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions>> NotThrowAsync(string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining NumericAssertionsBase in C# for FluentAssertions\nDESCRIPTION: This abstract class serves as a base for numeric assertions in FluentAssertions. It provides common functionality for asserting on numeric types, including methods for equality checks and comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_133\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class NumericAssertionsBase<T, TSubject, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertionsBase<T, TSubject, TAssertions>\n{\n    protected NumericAssertionsBase(FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }\n    public abstract TSubject Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(T? expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AllTypes Static Helper for Assembly Type Selection in C#\nDESCRIPTION: The AllTypes static class provides a utility method to select all types from a given assembly, enabling assertions on assembly contents. This serves as an entry point for type-related assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_151\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AllTypes\n{\n    public static FluentAssertions.Types.TypeSelector From(System.Reflection.Assembly assembly) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XML-related EquivalencySteps in C#\nDESCRIPTION: Classes for comparing XML types like XAttribute, XDocument, and XElement in FluentAssertions equivalency validation. These extend the generic EquivalencyStep class to handle XML-specific comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_108\n\nLANGUAGE: C#\nCODE:\n```\npublic class XAttributeEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XAttribute>\n{\n    public XAttributeEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class XDocumentEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XDocument>\n{\n    public XDocumentEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class XElementEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XElement>\n{\n    public XElementEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Member Selection Extensions in FluentAssertions\nDESCRIPTION: Extension methods for selecting and filtering members (methods and properties) from types in an assembly. These methods return selector objects that enable further filtering and assertions on type members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TypeExtensions\n{\n    public static FluentAssertions.Types.MethodInfoSelector Methods(this FluentAssertions.Types.TypeSelector typeSelector) { }\n    public static FluentAssertions.Types.MethodInfoSelector Methods(this System.Type type) { }\n    public static FluentAssertions.Types.PropertyInfoSelector Properties(this FluentAssertions.Types.TypeSelector typeSelector) { }\n    public static FluentAssertions.Types.PropertyInfoSelector Properties(this System.Type type) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Reflection.Assembly assembly) { }\n    public static FluentAssertions.Types.TypeSelector Types(this System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic AndConstraint Class in C#\nDESCRIPTION: Defines the AndConstraint generic class which is used to chain assertions in a fluent manner. It holds a reference to the parent object and provides an 'And' property for continuing the assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class AndConstraint<TParent>\n{\n    public AndConstraint(TParent parent) { }\n    public TParent And { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: XML Element Inner Text Assertion Method\nDESCRIPTION: Method for asserting the inner text content of an XML element, comparing it with an expected value. Returns an AndConstraint for chaining additional assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_173\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveInnerText(string expected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing FluentTimeSpanExtensions for TimeSpan Operations\nDESCRIPTION: Static extension methods for TimeSpan class providing fluent API for time duration operations. Includes constants for high-precision timing and methods for creating time spans.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentTimeSpanExtensions\n{\n    public const long TicksPerMicrosecond = 10;\n    public const double TicksPerNanosecond = 0.01D;\n    public static System.TimeSpan And(this System.TimeSpan sourceTime, System.TimeSpan offset) { }\n    public static System.TimeSpan Days(this double days) { }\n    public static System.TimeSpan Days(this int days) { }\n    public static System.TimeSpan Days(this int days, System.TimeSpan offset) { }\n}\n```\n\n----------------------------------------\n\nTITLE: String Assertion Method Signatures in C#\nDESCRIPTION: Method signatures for string assertions, including pattern matching, regex comparisons, and string prefix/suffix verification with various equivalency options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_173\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotMatchEquivalentOf(string wildcardPattern, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotMatchRegex(string regularExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotMatchRegex(System.Text.RegularExpressions.Regex regularExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotStartWith(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotStartWithEquivalentOf(string unexpected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWith(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> StartWithEquivalentOf(string expected, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IMember Interface in C#\nDESCRIPTION: Interface representing a member (property or field) that can be used in equivalency validation, providing information about the member's type, accessibility, and methods to get its value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_50\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMember : FluentAssertions.Equivalency.INode\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    bool IsBrowsable { get; }\n    System.Type ReflectedType { get; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    object GetValue(object obj);\n}\n```\n\n----------------------------------------\n\nTITLE: Type Assertions Negative Methods in FluentAssertions (C#)\nDESCRIPTION: Contains methods for asserting that a type does not have specific characteristics. These include checking that a type doesn't have certain constructors, conversion operators, methods, properties, or interface implementations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_157\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveConstructor(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, System.Reflection.ConstructorInfo> NotHaveDefaultConstructor(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitMethod(System.Type interfaceType, string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitMethod<TInterface>(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitProperty(System.Type interfaceType, string name, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveExplicitProperty<TInterface>(string name, string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator(System.Type sourceType, System.Type targetType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveImplicitConversionOperator<TSource, TTarget>(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveIndexer(System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveMethod(string name, System.Collections.Generic.IEnumerable<System.Type> parameterTypes, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotHaveProperty(string name, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotImplement(System.Type interfaceType, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> NotImplement<TInterface>(string because = \"\", params object[] becauseArgs)\n    where TInterface :  class { }\n```\n\n----------------------------------------\n\nTITLE: Implementing XmlAssertionExtensions Static Class in C#\nDESCRIPTION: Extension methods for XML assertions that provide entry points to the fluent assertion API for XML elements and nodes. These methods allow for making assertions on XML structures.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic static class XmlAssertionExtensions\n{\n    public static FluentAssertions.Xml.XmlElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlElement actualValue) { }\n    public static FluentAssertions.Xml.XmlNodeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlNode actualValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TypeSelector Class for Type Filtering in FluentAssertions (C#)\nDESCRIPTION: Defines a TypeSelector class that enables fluent filtering of System.Type collections. It implements IEnumerable<Type> and provides methods for filtering types based on characteristics like inheritance, implementation, namespaces, and attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_155\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeSelector : System.Collections.Generic.IEnumerable<System.Type>, System.Collections.IEnumerable\n{\n    public TypeSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public TypeSelector(System.Type type) { }\n    public System.Collections.Generic.IEnumerator<System.Type> GetEnumerator() { }\n    public FluentAssertions.Types.TypeSelector ThatAreAbstract() { }\n    public FluentAssertions.Types.TypeSelector ThatAreClasses() { }\n    public FluentAssertions.Types.TypeSelector ThatAreDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.TypeSelector ThatAreDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.TypeSelector ThatAreInNamespace(string @namespace) { }\n    public FluentAssertions.Types.TypeSelector ThatAreInterfaces() { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotAbstract() { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotClasses() { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotInNamespace(string @namespace) { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotInterfaces() { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotSealed() { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotStatic() { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotUnderNamespace(string @namespace) { }\n    public FluentAssertions.Types.TypeSelector ThatAreNotValueTypes() { }\n    public FluentAssertions.Types.TypeSelector ThatAreSealed() { }\n    public FluentAssertions.Types.TypeSelector ThatAreStatic() { }\n    public FluentAssertions.Types.TypeSelector ThatAreUnderNamespace(string @namespace) { }\n    public FluentAssertions.Types.TypeSelector ThatAreValueTypes() { }\n    public FluentAssertions.Types.TypeSelector ThatDeriveFrom<TBase>() { }\n    public FluentAssertions.Types.TypeSelector ThatDoNotDeriveFrom<TBase>() { }\n    public FluentAssertions.Types.TypeSelector ThatDoNotImplement<TInterface>() { }\n    public FluentAssertions.Types.TypeSelector ThatImplement<TInterface>() { }\n    public FluentAssertions.Types.TypeSelector ThatSatisfy(System.Func<System.Type, bool> predicate) { }\n    public System.Type[] ToArray() { }\n    public FluentAssertions.Types.TypeSelector UnwrapEnumerableTypes() { }\n    public FluentAssertions.Types.TypeSelector UnwrapTaskTypes() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffsetAssertions Generic Class in C#\nDESCRIPTION: Generic class for asserting DateTimeOffset values with fluent syntax. Provides numerous methods for comparing DateTimeOffset values, checking time components, and validating offsets. The methods return AndConstraint objects to support method chaining in assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_107\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateTimeOffsetAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n{\n    public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateTimeOffset? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateTimeOffset? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeAtLeast(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.DateTimeOffset nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeExactly(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeExactly(System.DateTimeOffset? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeLessThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeMoreThan(System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateTimeOffset[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateTimeOffset>[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateTimeOffset?> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSameDateAs(System.DateTimeOffset expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> BeWithin(System.TimeSpan timeSpan) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveHour(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMinute(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveOffset(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveSecond(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateTimeOffset? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.DateTimeOffset distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeExactly(System.DateTimeOffset? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSameDateAs(System.DateTimeOffset unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveHour(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveMinute(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveOffset(System.TimeSpan unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveSecond(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Property Comparison Override in Structural Equivalency\nDESCRIPTION: Example of the BeEquivalentTo method with property comparison override using the Using and WhenTypeIs methods to handle DateTime comparison with a custom tolerance.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, opt => opt\n    .Using<DateTime>(ctx => ctx.Subject.Should().BeCloseTo(ctx.Expectation, 1.Seconds()))\n    .WhenTypeIs<DateTime>());\n```\n\n----------------------------------------\n\nTITLE: Implementing Various Equivalency Step Classes for Type Comparison in C#\nDESCRIPTION: A collection of IEquivalencyStep implementations for different data types. These steps form a pipeline for comparing objects by type, with specialized handling for dictionaries, enumerables, enums, XML elements, and more.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionRuleEquivalencyStep<TSubject> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public AssertionRuleEquivalencyStep(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate, System.Action<FluentAssertions.Equivalency.IAssertionContext<TSubject>> assertionAction) { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\npublic class AutoConversionStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public AutoConversionStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\npublic class DictionaryEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Collections.IDictionary>\n{\n    public DictionaryEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\npublic class EnumEqualityStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public EnumEqualityStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class EnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public EnumerableEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class EqualityComparerEquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public EqualityComparerEquivalencyStep(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\npublic class GenericDictionaryEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public GenericDictionaryEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class GenericEnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public GenericEnumerableEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class ReferenceEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public ReferenceEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class RunAllUserStepsEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public RunAllUserStepsEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class SimpleEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public SimpleEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class StringEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public StringEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class StructuralEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public StructuralEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class ValueTypeEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public ValueTypeEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\npublic class XAttributeEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XAttribute>\n{\n    public XAttributeEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\npublic class XDocumentEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XDocument>\n{\n    public XDocumentEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\npublic class XElementEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XElement>\n{\n    public XElementEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Assertions in C#\nDESCRIPTION: Base implementation for object assertions providing methods for equality comparison and reference checking with support for custom comparers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic class ObjectAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.ObjectAssertions<TSubject, TAssertions>\n{\n    public ObjectAssertions(TSubject value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TSubject expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo<TExpectation>(TExpectation expectation, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IValueFormatter for Integer Types in C#\nDESCRIPTION: A collection of formatter classes for handling integer value types in FluentAssertions. These classes implement the IValueFormatter interface which provides methods to check if the formatter can handle a specific value type and to format the value for display in assertion messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_98\n\nLANGUAGE: C#\nCODE:\n```\npublic class Int32ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public Int32ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class Int64ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public Int64ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class SByteValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public SByteValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class UInt16ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public UInt16ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class UInt32ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public UInt32ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class UInt64ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public UInt64ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Assembly Assertions in C#\nDESCRIPTION: Class providing fluent assertions for Assembly objects, including methods to verify assembly signatures, type definitions, and references.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_181\n\nLANGUAGE: C#\nCODE:\n```\npublic AssemblyAssertions(System.Reflection.Assembly assembly, FluentAssertions.Execution.AssertionChain assertionChain) { }\nprotected override string Identifier { get; }\npublic FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeSignedWithPublicKey(string publicKey, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableNumericAssertions in C# for FluentAssertions\nDESCRIPTION: This snippet shows the NullableNumericAssertions class, which provides assertion methods for nullable numeric types. It includes methods for checking null values, matching predicates, and asserting on the presence of values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableNumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T?, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NullableNumericAssertions<T, TAssertions>\n{\n    public NullableNumericAssertions(T? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public override T? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    // ... other methods ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeSelector for Filtering Types in C#\nDESCRIPTION: This class provides methods for selecting and filtering types based on various criteria such as being abstract, classes, interfaces, or decorated with specific attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_164\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeSelector : System.Collections.Generic.IEnumerable<System.Type>, System.Collections.IEnumerable\n{\n    public TypeSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public TypeSelector(System.Type type) { }\n    public System.Collections.Generic.IEnumerator<System.Type> GetEnumerator() { }\n    public FluentAssertions.Types.TypeSelector ThatAreAbstract() { }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Serialization Assertions in C#\nDESCRIPTION: Extension methods for testing object serialization capabilities including XML and DataContract serialization checks. Provides methods to verify if objects can be properly serialized.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ObjectAssertionsExtensions\n{\n    public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n    public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeXmlSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: EquivalencyPlan Class Implementation in C#\nDESCRIPTION: The EquivalencyPlan class manages a collection of equivalency steps that define how comparison is performed. It implements IEnumerable<IEquivalencyStep> and provides methods to add, insert, and remove steps.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_68\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyPlan : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep>, System.Collections.IEnumerable\n{\n    public EquivalencyPlan() { }\n    public void Add<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void AddAfter<TPredecessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Clear() { }\n    public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IEquivalencyStep> GetEnumerator() { }\n    public void Insert<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void InsertBefore<TSuccessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Remove<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep { }\n    public void Reset() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AndWhichConstraint Class in C#\nDESCRIPTION: Defines the AndWhichConstraint class that extends AndConstraint. It provides additional functionality for assertions on collections or individual subjects, including support for assertion chains and path postfixes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class AndWhichConstraint<TParent, TSubject> : FluentAssertions.AndConstraint<TParent>\n{\n    public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects) { }\n    public AndWhichConstraint(TParent parent, TSubject subject) { }\n    public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public AndWhichConstraint(TParent parent, System.Collections.Generic.IEnumerable<TSubject> subjects, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix) { }\n    public AndWhichConstraint(TParent parent, TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain, string pathPostfix = \"\") { }\n    public TSubject Subject { get; }\n    public TSubject Which { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MethodInfoAssertions for Method Testing in C#\nDESCRIPTION: MethodInfoAssertions extends MethodBaseAssertions to provide specific assertions for testing methods. It includes assertions for method return types, virtuality, and async implementation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_156\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>\n{\n    public MethodInfoAssertions(System.Reflection.MethodInfo methodInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeAsync(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeAsync(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn(System.Type returnType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn<TReturn>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturnVoid(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return(System.Type returnType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return<TReturn>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> ReturnVoid(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyValidationContext Class\nDESCRIPTION: Implements the context for equivalency validation, tracking the current node, options, and reason. Provides methods for creating nested contexts for collections, dictionaries, and nested members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\npublic class EquivalencyValidationContext : FluentAssertions.Equivalency.IEquivalencyValidationContext\n{\n    public EquivalencyValidationContext(FluentAssertions.Equivalency.INode root, FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public FluentAssertions.Equivalency.INode CurrentNode { get; }\n    public FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    public FluentAssertions.Execution.Reason Reason { get; set; }\n    public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; set; }\n    public FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext Clone() { }\n    public bool IsCyclicReference(object expectation) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeAssertions Class in C#\nDESCRIPTION: This class extends ReferenceTypeAssertions for Type objects. It provides methods for asserting various properties of a Type, such as inheritance, decoration, and modifiers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_188\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Type, FluentAssertions.Types.TypeAssertions>\n{\n    public TypeAssertions(System.Type type, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be(System.Type expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> Be<TExpected>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAbstract(string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public new FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.TypeAssertions, TAttribute> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom(System.Type baseType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeDerivedFrom<TBaseClass>(string because = \"\", params object[] becauseArgs)\n        where TBaseClass :  class { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeAssertions> BeSealed(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Member Selection Rule Interface in C#\nDESCRIPTION: Interface for rules that determine which members of an object should be included in equivalency validation, with methods to select members based on context.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberSelectionRule\n{\n    bool IncludesMembers { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> SelectMembers(FluentAssertions.Equivalency.INode currentNode, System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> selectedMembers, FluentAssertions.Equivalency.MemberSelectionContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateOnlyAssertions Class for FluentAssertions in C#\nDESCRIPTION: This class provides assertion methods for DateOnly objects, including comparisons, component checks, and range validations. It's part of the FluentAssertions library for more expressive unit testing.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateOnlyAssertions<TAssertions>\n    where TAssertions : DateOnlyAssertions<TAssertions>\n{\n    public DateOnlyAssertions(System.DateOnly? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.DateOnly? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateOnly expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.DateOnly? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeAfter(System.DateOnly expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeBefore(System.DateOnly expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrAfter(System.DateOnly expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOnOrBefore(System.DateOnly expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.DateOnly[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(params System.Nullable<System.DateOnly>[] validValues) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateOnly> validValues, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOneOf(System.Collections.Generic.IEnumerable<System.DateOnly?> validValues, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveDay(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveMonth(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveYear(int expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateOnly unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.DateOnly? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAfter(System.DateOnly unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeBefore(System.DateOnly unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrAfter(System.DateOnly unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOnOrBefore(System.DateOnly unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveDay(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveMonth(int unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveYear(int unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Assertions Implementation in C#\nDESCRIPTION: Provides comprehensive assertion methods for enum types including value comparison, flag checking, and name validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumAssertions<TEnum, TAssertions>\n    where TEnum : struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>\n{\n    public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TEnum? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TEnum expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeDefined(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ValueTypeEquivalencyStep in C#\nDESCRIPTION: Class for comparing value types in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to handle specialized value type comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_107\n\nLANGUAGE: C#\nCODE:\n```\npublic class ValueTypeEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public ValueTypeEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericAsyncFunctionAssertions Class for Task<TResult> in C#\nDESCRIPTION: A specialized assertion class for asynchronous functions returning Task<TResult>. It extends AsyncFunctionAssertions and provides methods to verify completion, timing constraints, and exception handling for generic async operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_175\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericAsyncFunctionAssertions<TResult> : FluentAssertions.Specialized.AsyncFunctionAssertions<System.Threading.Tasks.Task<TResult>, FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>>\n{\n    public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public GenericAsyncFunctionAssertions(System.Func<System.Threading.Tasks.Task<TResult>> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAfterAsync(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<TResult>, TResult>> NotThrowAsync(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HaveElement with AssertionChain and caller postfix\nDESCRIPTION: Implementation of the HaveElement assertion using AssertionChain and WithCallerPostfix to improve error messages in chained assertions. This shows how to properly pass context between chained assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic AndWhichConstraint<XElementAssertions, XElement> HaveElement(XName expected,\n    string because = \"\", params object[] becauseArgs)\n{\n    xElement = Subject!.Element(expected);\n\n    assertionChain\n        .ForCondition(xElement is not null)\n        .BecauseOf(because, becauseArgs)\n        .FailWith(\n            \"Expected {context:subject} to have child element {0}{reason}, but no such child element was found.\",\n            expected.ToString().EscapePlaceholders());\n\n    return new AndWhichConstraint<XElementAssertions, XElement>(this, xElement, assertionChain, \"/\" + expected);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable Value Assertions in C#\nDESCRIPTION: Methods for asserting null or value states in nullable types. These methods check if a nullable value is null, has a value, or is equal to an expected value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_154\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTime Extension Methods in C#\nDESCRIPTION: Extension methods for DateTime providing fluent month creation and time component extraction. These methods allow for creating DateTime objects for specific months and extracting microsecond/nanosecond components.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_85\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.DateTime June(this int day, int year) { }\npublic static System.DateTime March(this int day, int year) { }\npublic static System.DateTime May(this int day, int year) { }\npublic static int Microsecond(this System.DateTime self) { }\npublic static int Microsecond(this System.DateTimeOffset self) { }\npublic static int Nanosecond(this System.DateTime self) { }\npublic static int Nanosecond(this System.DateTimeOffset self) { }\npublic static System.DateTime November(this int day, int year) { }\npublic static System.DateTime October(this int day, int year) { }\npublic static System.DateTime September(this int day, int year) { }\npublic static System.DateTimeOffset WithOffset(this System.DateTime self, System.TimeSpan offset) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing IValueFormatter for Floating-Point and Other Numeric Types in C#\nDESCRIPTION: Formatter classes for handling floating-point and specialized numeric types in FluentAssertions. These classes implement the IValueFormatter interface to format values like Single and TimeSpan for display in assertion messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_99\n\nLANGUAGE: C#\nCODE:\n```\npublic class SingleValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public SingleValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class TimeSpanValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public TimeSpanValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FluentTimeSpanExtensions in C#\nDESCRIPTION: Extension methods for TimeSpan creation and manipulation. These methods provide a fluent syntax for creating TimeSpan objects with different time units and combining them with other TimeSpan values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_86\n\nLANGUAGE: C#\nCODE:\n```\npublic static class FluentTimeSpanExtensions\n{\n    public const long TicksPerMicrosecond = 10;\n    public const double TicksPerNanosecond = 0.01D;\n    public static System.TimeSpan And(this System.TimeSpan sourceTime, System.TimeSpan offset) { }\n    public static System.TimeSpan Days(this double days) { }\n    public static System.TimeSpan Days(this int days) { }\n    public static System.TimeSpan Days(this int days, System.TimeSpan offset) { }\n    public static System.TimeSpan Hours(this double hours) { }\n    public static System.TimeSpan Hours(this int hours) { }\n    public static System.TimeSpan Hours(this int hours, System.TimeSpan offset) { }\n    public static int Microseconds(this System.TimeSpan self) { }\n    public static System.TimeSpan Microseconds(this int microseconds) { }\n    public static System.TimeSpan Microseconds(this long microseconds) { }\n    public static System.TimeSpan Milliseconds(this double milliseconds) { }\n    public static System.TimeSpan Milliseconds(this int milliseconds) { }\n    public static System.TimeSpan Minutes(this double minutes) { }\n    public static System.TimeSpan Minutes(this int minutes) { }\n    public static System.TimeSpan Minutes(this int minutes, System.TimeSpan offset) { }\n    public static int Nanoseconds(this System.TimeSpan self) { }\n    public static System.TimeSpan Nanoseconds(this int nanoseconds) { }\n    public static System.TimeSpan Nanoseconds(this long nanoseconds) { }\n    public static System.TimeSpan Seconds(this double seconds) { }\n    public static System.TimeSpan Seconds(this int seconds) { }\n    public static System.TimeSpan Seconds(this int seconds, System.TimeSpan offset) { }\n    public static System.TimeSpan Ticks(this int ticks) { }\n    public static System.TimeSpan Ticks(this long ticks) { }\n    public static double TotalMicroseconds(this System.TimeSpan self) { }\n    public static double TotalNanoseconds(this System.TimeSpan self) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Assertion Chain Implementation in C#\nDESCRIPTION: Implements the core assertion chain functionality for FluentAssertions, allowing for fluent assertion syntax and conditional failure handling.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_86\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class AssertionChain\n{\n    public string CallerIdentifier { get; }\n    public bool HasOverriddenCallerIdentifier { get; }\n    public bool Succeeded { get; }\n    public FluentAssertions.Execution.AssertionChain UsingLineBreaks { get; }\n    // ... additional methods\n}\n```\n\n----------------------------------------\n\nTITLE: Type Filtering Extensions in FluentAssertions\nDESCRIPTION: Extension methods for filtering collections of System.Type objects based on various criteria such as namespace, inheritance, attributes, and class status. These methods facilitate test assertions about types in assemblies.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TypeEnumerableExtensions\n{\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreInNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreUnderNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatDeriveFrom<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatImplement<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatSatisfy(this System.Collections.Generic.IEnumerable<System.Type> types, System.Func<System.Type, bool> predicate) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> UnwrapEnumerableTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> UnwrapTaskTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n}\n```\n\n----------------------------------------\n\nTITLE: XAttributeAssertions Class Implementation in C#\nDESCRIPTION: Defines the XAttributeAssertions class that extends ReferenceTypeAssertions to provide fluent assertion methods for XAttribute objects. It includes methods to verify attribute values and equivalence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_159\n\nLANGUAGE: C#\nCODE:\n```\npublic class XAttributeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, FluentAssertions.Xml.XAttributeAssertions>\n{\n    public XAttributeAssertions(System.Xml.Linq.XAttribute attribute, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> Be(System.Xml.Linq.XAttribute expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> HaveValue(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> NotBe(System.Xml.Linq.XAttribute unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Enumerable Equivalency Comparison in FluentAssertions\nDESCRIPTION: Classes for comparing enumerable collections, including both generic and non-generic implementations. These steps handle how collections should be compared for equivalency.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public EnumerableEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericEnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public GenericEnumerableEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic StringCollectionAssertions Class with Custom Assertions in C#\nDESCRIPTION: Defines a fully generic implementation of string collection assertions that provides methods for comparing collections of strings with various equivalency options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StringCollectionAssertions<TCollection, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, string, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<string>\n    where TAssertions : FluentAssertions.Collections.StringCollectionAssertions<TCollection, TAssertions>\n{\n    public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(params string[] expectation) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, string> ContainMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<string> expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal(params string[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateOnlyAssertions Class in C#\nDESCRIPTION: Defines a DateOnlyAssertions class that extends DateOnlyAssertions<TAssertions> for implementing fluent assertions for DateOnly values. It provides a constructor that accepts a nullable DateOnly value and an AssertionChain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_102\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateOnlyAssertions : FluentAssertions.Primitives.DateOnlyAssertions<FluentAssertions.Primitives.DateOnlyAssertions>\n{\n    public DateOnlyAssertions(System.DateOnly? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringCollectionAssertions Generic Class in C#\nDESCRIPTION: Generic class definition for string collection assertions with type constraints for IEnumerable<string>. Includes methods for comparing collections and matching patterns.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringCollectionAssertions<TCollection, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, string, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<string>\n    where TAssertions : FluentAssertions.Collections.StringCollectionAssertions<TCollection, TAssertions>\n{\n    public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(params string[] expectation) { }\n    public FluentAssertions.AndConstraint<TAssertions> ContainMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfoSelectorAssertions Class in C#\nDESCRIPTION: This class provides methods for asserting properties of selected PropertyInfo objects. It includes methods for checking decorations, virtuality, and writability of properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_187\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoSelectorAssertions\n{\n    public PropertyInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.PropertyInfo[] properties) { }\n    protected string Context { get; }\n    public System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> SubjectProperties { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Member Matching Rule Interface in C#\nDESCRIPTION: Interface for rules that match members of the expected object with members of the subject under test during equivalency validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberMatchingRule\n{\n    FluentAssertions.Equivalency.IMember Match(FluentAssertions.Equivalency.IMember expectedMember, object subject, FluentAssertions.Equivalency.INode parent, FluentAssertions.Equivalency.IEquivalencyOptions options, FluentAssertions.Execution.AssertionChain assertionChain);\n}\n```\n\n----------------------------------------\n\nTITLE: XML Element Attribute Assertion Methods\nDESCRIPTION: Methods for asserting the presence of attributes on an XML element, including methods for attributes with and without namespaces. These methods check for the existence of attributes with specific names and values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_171\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Numeric Assertion Extensions for Decimal, Double and Float Types\nDESCRIPTION: Extension methods for numeric assertions that check if values are approximately equal within a specified precision. Supports both nullable and non-nullable numeric types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<decimal>> BeApproximately(this FluentAssertions.Numeric.NullableNumericAssertions<decimal> parent, decimal expectedValue, decimal precision, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing PredicateLambdaExpressionValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of predicate lambda expressions in assertion results, transforming them into readable representations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_99\n\nLANGUAGE: C#\nCODE:\n```\npublic class PredicateLambdaExpressionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public PredicateLambdaExpressionValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffsetAssertions Class Definition\nDESCRIPTION: Class definition for DateTimeOffset assertions that inherits from the generic base class. Provides constructor for nullable DateTimeOffset values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_119\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeOffsetAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<FluentAssertions.Primitives.DateTimeOffsetAssertions>\n{\n    public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtLeast Occurrence Constraints in C#\nDESCRIPTION: Static methods defining 'AtLeast' occurrence constraints for assertions. These methods allow specifying minimum occurrence expectations like Once, Twice, or a custom number of times.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AtLeast\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: MoreThan Occurrence Constraints in FluentAssertions (C#)\nDESCRIPTION: Static methods for creating occurrence constraints that specify a lower bound (more than) of expected occurrences. These constraints are used with event monitoring and collection assertions to verify occurrence counts above a specific threshold.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class MoreThan\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MethodInfoAssertions Class in C#\nDESCRIPTION: A concrete class for assertions on MethodInfo objects. Provides methods to assert method characteristics like async, virtual, and return types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>\n    {\n        public MethodInfoAssertions(System.Reflection.MethodInfo methodInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        protected override string Identifier { get; }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeAsync(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeAsync(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn(System.Type returnType, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn<TReturn>(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturnVoid(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return(System.Type returnType, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return<TReturn>(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> ReturnVoid(string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Value Formatters in C#\nDESCRIPTION: Defines various value formatters that implement the IValueFormatter interface to format different types of objects for display in assertion messages. These formatters handle specific types like AggregateException, byte values, and DateTimeOffset.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic class AggregateExceptionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public AggregateExceptionValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n\npublic class AttributeBasedFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public AttributeBasedFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n\npublic class ByteValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public ByteValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n\npublic class DateTimeOffsetValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n\n```\n\n----------------------------------------\n\nTITLE: Defining ExecutionTime Class in C#\nDESCRIPTION: Class for capturing execution time of actions and async functions. Provides a base for measuring performance with different timer implementations through the StartTimer delegate.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_138\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExecutionTime\n    {\n        public ExecutionTime(System.Action action, FluentAssertions.Common.StartTimer createTimer) { }\n        public ExecutionTime(System.Func<System.Threading.Tasks.Task> action, FluentAssertions.Common.StartTimer createTimer) { }\n        protected ExecutionTime(System.Action action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }\n        protected ExecutionTime(System.Func<System.Threading.Tasks.Task> action, string actionDescription, FluentAssertions.Common.StartTimer createTimer) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Dictionary Assertion Class Definition in C#\nDESCRIPTION: Defines the GenericDictionaryAssertions class which provides fluent assertions for dictionary-like collections. It extends the GenericDictionaryAssertions base class with specific type parameters and includes a constructor that accepts key-value pairs and an assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue> : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue>>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MethodInfoSelector for Method Collection Operations in C#\nDESCRIPTION: MethodInfoSelector implements IEnumerable to provide collection functionality for working with method collections. It enables filtering and selection of methods from types or type collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_157\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>, System.Collections.IEnumerable\n{\n    public MethodInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public MethodInfoSelector(System.Type type) { }\n    public FluentAssertions.Types.MethodInfoSelector ThatArePublicOrInternal { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: XML Element Child Element Assertion Methods\nDESCRIPTION: Methods for asserting the presence of child elements within an XML element, including methods for elements with and without namespaces. Returns AndWhichConstraint to allow further assertions on the found element.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_172\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElement(string expectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IMemberMatchingRule Interface for FluentAssertions in C#\nDESCRIPTION: This interface defines a method for matching members during equivalency comparisons, taking into account the expected member, subject, parent, options, and assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberMatchingRule\n{\n    FluentAssertions.Equivalency.IMember Match(FluentAssertions.Equivalency.IMember expectedMember, object subject, FluentAssertions.Equivalency.INode parent, FluentAssertions.Equivalency.IEquivalencyOptions options, FluentAssertions.Execution.AssertionChain assertionChain);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyOptions Class in C#\nDESCRIPTION: Defines a non-generic class for configuring equivalency comparison options with a fluent interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_65\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyOptions : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions>\n{\n    public EquivalencyOptions() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ITestFramework Interface in C#\nDESCRIPTION: Defines the ITestFramework interface which allows FluentAssertions to integrate with different test frameworks. It provides a standardized way to throw assertion failures in the test framework's format.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestFramework\n{\n    bool IsAvailable { get; }\n    [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n    void Throw(string message);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeCloseTo Methods for Integer Types in FluentAssertions\nDESCRIPTION: Extension methods that assert whether integer values (byte, short, int, long, etc.) are close to an expected value within a specified delta. These methods provide precise control over acceptable deviations for integer comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte nearbyValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short nearbyValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int nearbyValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long nearbyValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte nearbyValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort nearbyValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint nearbyValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> BeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong nearbyValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: C# Method Info Selector Class Definition\nDESCRIPTION: Class providing fluent interface for selecting and filtering method information using reflection. Includes methods for filtering by return type, abstract/virtual status, and attribute decoration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_158\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoSelector {\n    public FluentAssertions.Types.MethodInfoSelector ThatDoNotReturnVoid { get; }\n    public FluentAssertions.Types.MethodInfoSelector ThatReturnVoid { get; }\n    public System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo> GetEnumerator() { }\n    public FluentAssertions.Types.TypeSelector ReturnTypes() { }\n    public FluentAssertions.Types.MethodInfoSelector ThatAreAbstract() { }\n    public FluentAssertions.Types.MethodInfoSelector ThatAreAsync() { }\n    // ... other methods\n}\n```\n\n----------------------------------------\n\nTITLE: Static Formatter Class for Managing Value Formatters\nDESCRIPTION: The static Formatter class provides central access to all registered value formatters and contains utilities for adding, removing, and using formatters to convert objects to string representations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Formatter\n{\n    public static System.Collections.Generic.IEnumerable<FluentAssertions.Formatting.IValueFormatter> Formatters { get; }\n    public static void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public static void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public static string ToString(object value, FluentAssertions.Formatting.FormattingOptions options = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WithoutStrictOrderingFor Method\nDESCRIPTION: Configures a collection property to be compared without considering item order. Allows collections with the same items in different orders to be equivalent.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n```\n\n----------------------------------------\n\nTITLE: Event Raising Extensions in FluentAssertions (C#)\nDESCRIPTION: Extension methods for asserting event raising conditions including argument predicates and sender verification. These methods are used after monitoring events to verify specific characteristics of raised events.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.Events.IEventRecording WithArgs<T>(this FluentAssertions.Events.IEventRecording eventRecording, System.Linq.Expressions.Expression<System.Func<T, bool>> predicate) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.Events.IEventRecording WithArgs<T>(this FluentAssertions.Events.IEventRecording eventRecording, params System.Linq.Expressions.Expression<System.Func<T, bool>>[] predicates) { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic static FluentAssertions.Events.IEventRecording WithSender(this FluentAssertions.Events.IEventRecording eventRecording, object expectedSender) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing MultidimensionalArrayFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of multidimensional arrays in assertion results, displaying the structure and content of the array.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_97\n\nLANGUAGE: C#\nCODE:\n```\npublic class MultidimensionalArrayFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public MultidimensionalArrayFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic GuidAssertions Class with GUID Validation Methods\nDESCRIPTION: Generic class for GUID assertions that provides methods for validating GUID values. Includes methods for equality checks, emptiness checks, and string representation validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_117\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GuidAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.GuidAssertions<TAssertions>\n{\n    public GuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.Guid? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.Guid unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(string unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEmpty(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AtMost Occurrence Constraints in C#\nDESCRIPTION: Static methods defining 'AtMost' occurrence constraints for assertions. These methods allow specifying maximum occurrence expectations like Once, Twice, or a custom number of times.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AtMost\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Occurrence Constraint Utility Classes in C#\nDESCRIPTION: Static utility classes (AtLeast, AtMost, Exactly, LessThan, MoreThan) that provide methods to create occurrence constraints for testing event occurrences.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AtLeast\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AtMost\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Exactly\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static class LessThan\n{\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static class MoreThan\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WithMapping Method using String Paths\nDESCRIPTION: Maps a member from the expectation to a differently named member in the subject using string paths. This allows comparing objects with different property names.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing StringCollectionAssertions Class in C#\nDESCRIPTION: Defines a class for making assertions on collections of strings that inherits from the generic StringCollectionAssertions class.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_45\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StringCollectionAssertions : FluentAssertions.Collections.StringCollectionAssertions<System.Collections.Generic.IEnumerable<string>>\n{\n    public StringCollectionAssertions(System.Collections.Generic.IEnumerable<string> actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssemblyAssertions for Testing Assembly Properties in C#\nDESCRIPTION: AssemblyAssertions class provides methods for testing properties of .NET assemblies, including digital signatures, type definitions, and assembly references. These assertions help validate assembly-level characteristics.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_152\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssemblyAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Reflection.Assembly, FluentAssertions.Types.AssemblyAssertions>\n{\n    public AssemblyAssertions(System.Reflection.Assembly assembly, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeSignedWithPublicKey(string publicKey, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> BeUnsigned(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.AssemblyAssertions, System.Type> DefineType(string @namespace, string name, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> NotReference(System.Reflection.Assembly assembly, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.AssemblyAssertions> Reference(System.Reflection.Assembly assembly, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MemberSelectionContext Class in C#\nDESCRIPTION: Provides context for member selection during equivalency comparison, including visibility settings for fields and properties. Contains information about compile-time and runtime types, and the equivalency options being used.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_86\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MemberSelectionContext\n{\n    public MemberSelectionContext(System.Type compileTimeType, System.Type runtimeType, FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }\n    public FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }\n    public System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DictionaryEquivalencyStep in C#\nDESCRIPTION: Class for comparing dictionaries in FluentAssertions equivalency validation. It extends the generic EquivalencyStep class for IDictionary objects to handle dictionary-specific equivalency logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_96\n\nLANGUAGE: C#\nCODE:\n```\npublic class DictionaryEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Collections.IDictionary>\n{\n    public DictionaryEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableSimpleTimeSpanAssertions in C#\nDESCRIPTION: Concrete implementation of assertions for nullable TimeSpan values. Inherits from NullableSimpleTimeSpanAssertions<T> and provides a constructor for initializing with a nullable TimeSpan value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_116\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableSimpleTimeSpanAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions>\n{\n    public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RunAllUserStepsEquivalencyStep in C#\nDESCRIPTION: Class for executing all user-defined equivalency steps in FluentAssertions. It implements the IEquivalencyStep interface to run custom steps configured by the user during object comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_103\n\nLANGUAGE: C#\nCODE:\n```\npublic class RunAllUserStepsEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public RunAllUserStepsEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EquivalencyOptions Methods in C#\nDESCRIPTION: Method signatures for the EquivalencyOptions<TExpectation> class that allow configuring how equivalency comparisons are performed, including member inclusion, mapping, and ordering rules.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_67\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Including(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TSubject>(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expectationMemberPath, System.Linq.Expressions.Expression<System.Func<TSubject, object>> subjectMemberPath) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(System.Linq.Expressions.Expression<System.Func<TNestedExpectation, object>> expectationMember, System.Linq.Expressions.Expression<System.Func<TNestedSubject, object>> subjectMember) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(string expectationMemberName, string subjectMemberName) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IAssertionStrategy Interface in C#\nDESCRIPTION: Defines the IAssertionStrategy interface which abstracts different strategies for handling assertion failures. It includes methods to handle failures and access failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_116\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAssertionStrategy\n{\n    System.Collections.Generic.IEnumerable<string> FailureMessages { get; }\n    System.Collections.Generic.IEnumerable<string> DiscardFailures();\n    void HandleFailure(string message);\n    void ThrowIfAny(System.Collections.Generic.IDictionary<string, object> context);\n}\n```\n\n----------------------------------------\n\nTITLE: C# Property Info Assertions Class\nDESCRIPTION: Class for making assertions about property information, inheriting from MemberInfoAssertions. Includes methods for asserting property readability, writability, and return types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_160\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoAssertions : FluentAssertions.Types.MemberInfoAssertions<System.Reflection.PropertyInfo, FluentAssertions.Types.PropertyInfoAssertions> {\n    public PropertyInfoAssertions(System.Reflection.PropertyInfo propertyInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    // ... assertion methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MethodInfoSelector Class in C#\nDESCRIPTION: A class that enables LINQ-style filtering of MethodInfo objects based on various criteria like access modifiers, return types, and attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_142\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>, System.Collections.IEnumerable\n    {\n        public MethodInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n        public MethodInfoSelector(System.Type type) { }\n        public FluentAssertions.Types.MethodInfoSelector ThatArePublicOrInternal { get; }\n        public FluentAssertions.Types.MethodInfoSelector ThatDoNotReturnVoid { get; }\n        public FluentAssertions.Types.MethodInfoSelector ThatReturnVoid { get; }\n        public System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo> GetEnumerator() { }\n        public FluentAssertions.Types.TypeSelector ReturnTypes() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreAbstract() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreAsync() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreDecoratedWith<TAttribute>()\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreNotAbstract() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreNotAsync() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWith<TAttribute>()\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreNotStatic() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreNotVirtual() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreStatic() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatAreVirtual() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatDoNotReturn<TReturn>() { }\n        public FluentAssertions.Types.MethodInfoSelector ThatReturn<TReturn>() { }\n        public System.Reflection.MethodInfo[] ToArray() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining CyclicReferenceHandling Enum in C#\nDESCRIPTION: Enum to specify how cyclic references should be handled during equivalency validation, with options to ignore or throw exceptions for circular references.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum CyclicReferenceHandling\n{\n    Ignore = 0,\n    ThrowException = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract EquivalencyStep<T> Class Implementation in C#\nDESCRIPTION: Base class for implementing equivalency steps that define how specific types are compared. It implements IEquivalencyStep and provides a template method pattern.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_70\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class EquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    protected EquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    protected abstract FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeSpan Assertion Methods in C#\nDESCRIPTION: This snippet defines the SimpleTimeSpanAssertions<TAssertions> class with various assertion methods for TimeSpan objects. It includes comparisons and checks for specific time-related conditions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_137\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleTimeSpanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>\n{\n    public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.TimeSpan? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.TimeSpan nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BePositive(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.TimeSpan unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.TimeSpan distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OrderingRuleCollection Class for FluentAssertions in C#\nDESCRIPTION: This class represents a collection of ordering rules used in equivalency comparisons, providing methods for adding rules and checking ordering strictness.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrderingRuleCollection : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule>, System.Collections.IEnumerable\n{\n    public OrderingRuleCollection() { }\n    public OrderingRuleCollection(System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule> orderingRules) { }\n    public void Add(FluentAssertions.Equivalency.IOrderingRule rule) { }\n    public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IOrderingRule> GetEnumerator() { }\n    public bool IsOrderingStrictFor(FluentAssertions.Equivalency.IObjectInfo objectInfo) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic NullableGuidAssertions in C#\nDESCRIPTION: Defines a generic class for assertions on nullable Guid values, extending GuidAssertions. Provides methods to assert nullability, value existence, and value comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableGuidAssertions<TAssertions> : FluentAssertions.Primitives.GuidAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableGuidAssertions<TAssertions>\n{\n    public NullableGuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Exactly Occurrence Constraints in C#\nDESCRIPTION: Static methods defining 'Exactly' occurrence constraints for assertions. These methods allow specifying exact occurrence expectations like Once, Twice, or a custom number of times.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Exactly\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FunctionAssertions Class for Func Assertions in C#\nDESCRIPTION: Definition of a specialized assertion class for System.Func<T> delegates. It extends DelegateAssertions and provides methods to verify function execution behavior like not throwing exceptions and timing constraints.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_174\n\nLANGUAGE: C#\nCODE:\n```\npublic class FunctionAssertions<T> : FluentAssertions.Specialized.DelegateAssertions<System.Func<T>, FluentAssertions.Specialized.FunctionAssertions<T>>\n{\n    public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FunctionAssertions(System.Func<T> subject, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    protected override string Identifier { get; }\n    protected override void InvokeSubject() { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrow(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.FunctionAssertions<T>, T> NotThrowAfter(System.TimeSpan waitTime, System.TimeSpan pollInterval, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalency Validation Context Interface in C#\nDESCRIPTION: Interface defining the context for equivalency validation, with access to the current node, options, and methods for creating contexts for nested validations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEquivalencyValidationContext\n{\n    FluentAssertions.Equivalency.INode CurrentNode { get; }\n    FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    FluentAssertions.Execution.Reason Reason { get; }\n    FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext Clone();\n    bool IsCyclicReference(object expectation);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumerableEquivalencyStep in C#\nDESCRIPTION: Class for comparing enumerable collections in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to handle collection comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_98\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public EnumerableEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamAssertions Class for Stream Objects in C#\nDESCRIPTION: A specialized assertion class for System.IO.Stream objects that provides methods to verify stream properties like readability, writability, seekability, length, and position. It serves as a base class for more specific stream assertion classes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_179\n\nLANGUAGE: C#\nCODE:\n```\npublic class StreamAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.IO.Stream\n    where TAssertions : FluentAssertions.Streams.StreamAssertions<TSubject, TAssertions>\n{\n    public StreamAssertions(TSubject stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeReadOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSeekable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveLength(long expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HavePosition(long expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeReadOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSeekable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeWriteOnly(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveLength(long unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHavePosition(long unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableEnumAssertions in C#\nDESCRIPTION: Defines a class for fluent assertions on nullable enum values. Inherits from the generic version and provides assertion capabilities specific to nullable enum types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableEnumAssertions<TEnum> : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, FluentAssertions.Primitives.NullableEnumAssertions<TEnum>>\n    where TEnum :  struct, System.Enum\n{\n    public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumEqualityStep in C#\nDESCRIPTION: Class for comparing enum types in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to handle specialized enum comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_97\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumEqualityStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public EnumEqualityStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Failure Reason and Assertion Strategy Interfaces in C#\nDESCRIPTION: Implements the FailReason class and IAssertionStrategy interface for handling assertion failures. These components are used to format failure messages and manage assertion behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic class FailReason\n    {\n        public FailReason(string message, params object[] args) { }\n        public object[] Args { get; }\n        public string Message { get; }\n    }\n    public interface IAssertionStrategy\n    {\n        System.Collections.Generic.IEnumerable<string> FailureMessages { get; }\n        System.Collections.Generic.IEnumerable<string> DiscardFailures();\n        void HandleFailure(string message);\n        void ThrowIfAny(System.Collections.Generic.IDictionary<string, object> context);\n    }\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffsetAssertions Class Definition in FluentAssertions\nDESCRIPTION: Definition of the DateTimeOffsetAssertions class that inherits from the generic DateTimeOffsetAssertions<T> class. This class provides a constructor that accepts a nullable DateTimeOffset value and an assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_108\n\nLANGUAGE: C#\nCODE:\n```\npublic class DateTimeOffsetAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<FluentAssertions.Primitives.DateTimeOffsetAssertions>\n{\n    public DateTimeOffsetAssertions(System.DateTimeOffset? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OccurrenceConstraintExtensions in C#\nDESCRIPTION: Defines extension methods for integers to create occurrence constraints for assertion operations. These methods help in specifying how many times a condition should be met.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic static class OccurrenceConstraintExtensions\n{\n    public static FluentAssertions.OccurrenceConstraint TimesExactly(this int times) { }\n    public static FluentAssertions.OccurrenceConstraint TimesOrLess(this int times) { }\n    public static FluentAssertions.OccurrenceConstraint TimesOrMore(this int times) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BeNaN Extension Methods in C#\nDESCRIPTION: Extension methods for asserting that floating-point values are NaN (Not a Number). Supports both nullable and non-nullable float and double types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NullableNumericAssertions<double>> BeNaN(this FluentAssertions.Numeric.NullableNumericAssertions<double> parent, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<float>> BeNaN(this FluentAssertions.Numeric.NumericAssertions<float> parent, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: AtMost Occurrence Constraints in FluentAssertions (C#)\nDESCRIPTION: Static methods for creating occurrence constraints that specify a maximum number of expected occurrences. These constraints are used with event monitoring and collection assertions to verify maximum occurrence requirements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class AtMost\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeEnumerableExtensions Static Class in C#\nDESCRIPTION: Static extension methods for IEnumerable<Type> that provide filtering capabilities for types based on various criteria such as inheritance, decoration with attributes, namespace location, and more.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TypeEnumerableExtensions\n{\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreInNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWith<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotDecoratedWithOrInherit<TAttribute>(this System.Collections.Generic.IEnumerable<System.Type> types)\n        where TAttribute : System.Attribute { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreNotStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreStatic(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreUnderNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatDeriveFrom<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatImplement<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatSatisfy(this System.Collections.Generic.IEnumerable<System.Type> types, System.Func<System.Type, bool> predicate) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> UnwrapEnumerableTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> UnwrapTaskTypes(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OrderStrictness Enum in C#\nDESCRIPTION: Enum defining the strictness levels for collection ordering in equivalency comparison. Offers options for strict ordering, non-strict ordering, or treating order as irrelevant.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_89\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum OrderStrictness\n{\n    Strict = 0,\n    NotStrict = 1,\n    Irrelevant = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Descending Order in Collections (C#)\nDESCRIPTION: These methods assert that a collection is in descending order. They offer overloads for custom comparers, comparison functions, and property selectors.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing AutoConversionStep in FluentAssertions.Equivalency.Steps\nDESCRIPTION: Implementation of IEquivalencyStep that handles automatic type conversion during equivalency comparison. Provides support for comparing values of different but compatible types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_95\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AutoConversionStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public AutoConversionStep() { }\n\n```\n\n----------------------------------------\n\nTITLE: Type Selector Methods in C#\nDESCRIPTION: Method definitions for TypeSelector class that allows filtering and manipulating collections of Types. These methods enable selecting types based on inheritance, interfaces, or custom predicates.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_152\n\nLANGUAGE: csharp\nCODE:\n```\npublic FluentAssertions.Types.TypeSelector ThatDoNotDeriveFrom<TBase>() { }\npublic FluentAssertions.Types.TypeSelector ThatDoNotImplement<TInterface>() { }\npublic FluentAssertions.Types.TypeSelector ThatImplement<TInterface>() { }\npublic FluentAssertions.Types.TypeSelector ThatSatisfy(System.Func<System.Type, bool> predicate) { }\npublic System.Type[] ToArray() { }\npublic FluentAssertions.Types.TypeSelector UnwrapEnumerableTypes() { }\npublic FluentAssertions.Types.TypeSelector UnwrapTaskTypes() { }\n```\n\n----------------------------------------\n\nTITLE: Defining NullableGuidAssertions Generic Class in C#\nDESCRIPTION: Abstract class for assertions on nullable Guid types. Provides methods to assert equality, nullability, and value existence. Inheritors must implement the concrete assertion class.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_115\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableGuidAssertions<TAssertions> : FluentAssertions.Primitives.NullableGuidAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableGuidAssertions<TAssertions>\n{\n    public NullableGuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delegate Assertions Base Class in C#\nDESCRIPTION: This abstract class serves as a base for delegate assertions. It provides internal methods for asserting that a delegate does not throw an exception or throws a specific exception type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class DelegateAssertionsBase<TDelegate, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TDelegate, FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>>\n    where TDelegate : System.Delegate\n    where TAssertions : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>\n{\n    protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal(System.Exception exception, string because, object[] becauseArgs) { }\n    protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)\n        where TException : System.Exception { }\n    protected FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TaskCompletionSourceAssertions<T> Class in C#\nDESCRIPTION: Class for making assertions about TaskCompletionSource<T> objects. Provides methods to assert that tasks complete or don't complete within specified timeframes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic class TaskCompletionSourceAssertions<T> : FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase\n    {\n        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n        public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n        public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: EquivalencyValidationContext Class Implementation in C#\nDESCRIPTION: Represents the context for validating equivalency between objects, maintaining state about the current node, options, and providing methods to create child contexts for nested members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_71\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyValidationContext : FluentAssertions.Equivalency.IEquivalencyValidationContext\n{\n    public EquivalencyValidationContext(FluentAssertions.Equivalency.INode root, FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public FluentAssertions.Equivalency.INode CurrentNode { get; }\n    public FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    public FluentAssertions.Execution.Reason Reason { get; set; }\n    public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; set; }\n    public FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext Clone() { }\n    public bool IsCyclicReference(object expectation) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyStep<T> Abstract Class in C#\nDESCRIPTION: Abstract base class for implementing custom equivalency validation steps. Provides a template method pattern with the Handle method that delegates to the abstract OnHandle method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_43\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class EquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    protected EquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    protected abstract FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Result Assertion Extensions in C#\nDESCRIPTION: Extension methods that assert expected results for asynchronous operations. These methods support fluent assertions for generic async functions and task completion sources.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.GenericAsyncFunctionAssertions<T>, T>> task, T expected, string because = \"\", params object[] becauseArgs) { }\npublic static System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> WithResult<T>(this System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> task, T expected, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing SingleValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of Single/float values in assertion results, likely with special handling for NaN, Infinity, and floating-point precision.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\npublic class SingleValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public SingleValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WhoseValueConstraint Class for Dictionary Assertions in C#\nDESCRIPTION: Defines a constraint class for performing assertions on specific dictionary values. It extends AndConstraint to facilitate fluent chaining of assertions on dictionaries.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> : FluentAssertions.AndConstraint<TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n    where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>\n{\n    public WhoseValueConstraint(TAssertions parentConstraint, TValue value) { }\n    public TValue WhoseValue { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionScope Class for Scoped Assertions\nDESCRIPTION: Class that manages the scope of assertions, allowing multiple assertions to be combined. Implements IDisposable to provide scope-based assertion handling.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_81\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssertionScope : System.IDisposable\n{\n    public AssertionScope() { }\n    public AssertionScope(FluentAssertions.Execution.IAssertionStrategy assertionStrategy) { }\n    public AssertionScope(System.Func<string> name) { }\n    public AssertionScope(string name) { }\n    public FluentAssertions.Formatting.FormattingOptions FormattingOptions { get; }\n    public System.Func<string> Name { get; }\n    public static FluentAssertions.Execution.AssertionScope Current { get; }\n    public void AddPreFormattedFailure(string formattedFailureMessage) { }\n    public void AppendTracing(string tracingBlock) { }\n    public string[] Discard() { }\n    public void Dispose() { }\n    public bool HasFailures() { }\n}\n```\n\n----------------------------------------\n\nTITLE: GuidAssertions Class Implementation in FluentAssertions\nDESCRIPTION: Non-generic facade class for GUID assertions that inherits from the generic version. This class simplifies working with GUID assertions by providing a concrete implementation with fixed generic parameters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_116\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GuidAssertions : FluentAssertions.Primitives.GuidAssertions<FluentAssertions.Primitives.GuidAssertions>\n{\n    public GuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TaskCompletionSourceAssertions Class for TCS<T> in C#\nDESCRIPTION: A specialized assertion class for TaskCompletionSource<T>. It extends TaskCompletionSourceAssertionsBase and provides methods to verify completion status and timing constraints for task completion sources.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_178\n\nLANGUAGE: C#\nCODE:\n```\npublic class TaskCompletionSourceAssertions<T> : FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase\n{\n    public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TaskCompletionSourceAssertions(System.Threading.Tasks.TaskCompletionSource<T> tcs, FluentAssertions.Execution.AssertionChain assertionChain, FluentAssertions.Common.IClock clock) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndWhichConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>, T>> CompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n    public System.Threading.Tasks.Task<FluentAssertions.AndConstraint<FluentAssertions.Specialized.TaskCompletionSourceAssertions<T>>> NotCompleteWithinAsync(System.TimeSpan timeSpan, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NullableEnumAssertions<TEnum> Class\nDESCRIPTION: Non-generic implementation of assertions for nullable enum values of type TEnum. It inherits from the generic version with itself as the TAssertions parameter for fluent interface support.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_149\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableEnumAssertions<TEnum> : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, FluentAssertions.Primitives.NullableEnumAssertions<TEnum>>\n    where TEnum :  struct, System.Enum\n{\n    public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Numeric Assertions Class in C#\nDESCRIPTION: Definition of the NullableNumericAssertions generic class which provides assertion methods for nullable numeric types. It extends NumericAssertionsBase and includes methods specific to nullable values like BeNull() and HaveValue().\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableNumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T?, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NullableNumericAssertions<T, TAssertions>\n{\n    public NullableNumericAssertions(T? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public override T? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T?, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic IMonitor Interface in FluentAssertions\nDESCRIPTION: Generic interface for monitoring events on objects of type T. Provides access to monitored and occurred events, and methods for managing event recordings and creating assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMonitor<T> : System.IDisposable\n{\n    FluentAssertions.Events.EventMetadata[] MonitoredEvents { get; }\n    FluentAssertions.Events.OccurredEvent[] OccurredEvents { get; }\n    T Subject { get; }\n    void Clear();\n    FluentAssertions.Events.IEventRecording GetRecordingFor(string eventName);\n    FluentAssertions.Events.EventAssertions<T> Should();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConversionSelector Class for Equivalency Comparison in C#\nDESCRIPTION: Defines a class for selecting when type conversion should be applied during equivalency comparisons. It provides methods to include or exclude conversions based on custom predicates.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_58\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ConversionSelector\n{\n    public ConversionSelector() { }\n    public FluentAssertions.Equivalency.ConversionSelector Clone() { }\n    public void Exclude(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public void Include(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public void IncludeAll() { }\n    public bool RequiresConversion(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.INode currentNode) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Ordering Assertions in C#\nDESCRIPTION: Methods for verifying collection ordering (ascending/descending) with support for custom comparers and property-based comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInAscendingOrder(string because = \"\", params object[] becauseArgs) { }\n\npublic FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> BeInDescendingOrder(string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IEventRecording Interface in FluentAssertions\nDESCRIPTION: Interface for event recording functionality that inherits from IEnumerable to allow iteration through recorded events. Provides properties for accessing event metadata.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEventRecording : System.Collections.Generic.IEnumerable<FluentAssertions.Events.OccurredEvent>, System.Collections.IEnumerable\n{\n    System.Type EventHandlerType { get; }\n    string EventName { get; }\n    object EventObject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMemberSelectionRule Interface\nDESCRIPTION: Defines an interface for rules that select which members to include in equivalency validation. Allows filtering members based on various criteria like visibility, name, or type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberSelectionRule\n{\n    bool IncludesMembers { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> SelectMembers(FluentAssertions.Equivalency.INode currentNode, System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> selectedMembers, FluentAssertions.Equivalency.MemberSelectionContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MethodInfoAssertions in C#\nDESCRIPTION: Defines the MethodInfoAssertions class for asserting properties of System.Reflection.MethodInfo objects. It includes methods for checking method modifiers, return types, and asynchronous behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>\n{\n    public MethodInfoAssertions(System.Reflection.MethodInfo methodInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeAsync(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeAsync(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn(System.Type returnType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturn<TReturn>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> NotReturnVoid(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return(System.Type returnType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> Return<TReturn>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>> ReturnVoid(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DelegateAssertions Class in C#\nDESCRIPTION: Abstract class for delegate assertions that builds on DelegateAssertionsBase, adding specific methods for asserting exception behavior when invoking delegates.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_169\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class DelegateAssertions<TDelegate, TAssertions> : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>\n    where TDelegate : System.Delegate\n    where TAssertions : FluentAssertions.Specialized.DelegateAssertions<TDelegate, TAssertions>\n{\n    protected DelegateAssertions(TDelegate @delegate, FluentAssertions.Specialized.IExtractExceptions extractor, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected abstract void InvokeSubject();\n    public FluentAssertions.AndConstraint<TAssertions> NotThrow<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> Throw<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowExactly<TException>(string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: XElementAssertions Class Implementation in C#\nDESCRIPTION: Defines the XElementAssertions class which extends ReferenceTypeAssertions to provide assertion capabilities for XML elements. Contains methods for verifying element attributes, child elements, values, and equivalence with other elements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_168\n\nLANGUAGE: C#\nCODE:\n```\npublic class XElementAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XElement, FluentAssertions.Xml.XElementAssertions>\n{\n    public XElementAssertions(System.Xml.Linq.XElement xElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> Be(System.Xml.Linq.XElement expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> BeEquivalentTo(System.Xml.Linq.XElement expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(string expectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(System.Xml.Linq.XName expectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(string expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(System.Xml.Linq.XName expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveValue(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBe(System.Xml.Linq.XElement unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBeEquivalentTo(System.Xml.Linq.XElement unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(string unexpectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(System.Xml.Linq.XName unexpectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(string unexpectedName, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(System.Xml.Linq.XName unexpectedName, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(string unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: IEquivalencyValidationContext Interface Definition in C#\nDESCRIPTION: Interface for the context used during equivalency validation, providing access to the current node, options, and methods to create derived contexts for nested members and collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_76\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEquivalencyValidationContext\n{\n    FluentAssertions.Equivalency.INode CurrentNode { get; }\n    FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    FluentAssertions.Execution.Reason Reason { get; }\n    FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext Clone();\n    bool IsCyclicReference(object expectation);\n}\n```\n\n----------------------------------------\n\nTITLE: Example of chained XML assertions\nDESCRIPTION: An example showing how chained assertions are used on XML elements. This demonstrates the context for understanding caller identifier amendments in v8.0.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar element = XElement.Parse(\n                \"\"\"\n                <parent>\n                    <child />\n                    <child />\n                </parent>\n                \"\"\");\n\n\nelement.Should().HaveElement(\"child\", AtLeast.Twice()).Which.Should().HaveCount(1);\n```\n\n----------------------------------------\n\nTITLE: Implementing Value Formatters for FluentAssertions in C#\nDESCRIPTION: A collection of value formatters for different types in the FluentAssertions.Formatting namespace. These formatters handle how different types are displayed in assertion failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_88\n\nLANGUAGE: C#\nCODE:\n```\nnamespace FluentAssertions.Formatting\n{\n    public class AggregateExceptionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public AggregateExceptionValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class AttributeBasedFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public AttributeBasedFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class ByteValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public ByteValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class DateOnlyValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public DateOnlyValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class DateTimeOffsetValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public DateTimeOffsetValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class DecimalValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public DecimalValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class DefaultValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public DefaultValueFormatter() { }\n        public virtual bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n        protected virtual System.Reflection.MemberInfo[] GetMembers(System.Type type) { }\n        protected virtual string TypeDisplayName(System.Type type) { }\n    }\n    public class DictionaryValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public DictionaryValueFormatter() { }\n        protected virtual int MaxItems { get; }\n        public virtual bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class DoubleValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public DoubleValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class EnumValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public EnumValueFormatter() { }\n        public virtual bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class EnumerableValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public EnumerableValueFormatter() { }\n        protected virtual int MaxItems { get; }\n        public virtual bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class ExceptionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public ExceptionValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n    public class ExpressionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n    {\n        public ExpressionValueFormatter() { }\n        public bool CanHandle(object value) { }\n        public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparands Class for Equivalency Comparison in C#\nDESCRIPTION: Defines a class that holds the subject and expectation objects being compared during an equivalency assertion. It provides methods to determine expected types and properly format the comparison for error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_57\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Comparands\n{\n    public Comparands() { }\n    public Comparands(object subject, object expectation, System.Type compileTimeType) { }\n    public System.Type CompileTimeType { get; set; }\n    public object Expectation { get; set; }\n    public System.Type RuntimeType { get; }\n    public object Subject { get; set; }\n    public System.Type GetExpectedType(FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Should Extension Methods for XML Types in C#\nDESCRIPTION: Defines Should extension methods for XAttribute, XDocument, and XElement, returning their respective assertion types. These methods enable fluent assertions on XML-related objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Xml.XAttributeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XAttribute actualValue) { }\npublic static FluentAssertions.Xml.XDocumentAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XDocument actualValue) { }\npublic static FluentAssertions.Xml.XElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.Linq.XElement actualValue) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Should Extension Method for System.Type in C#\nDESCRIPTION: Defines a Should extension method for System.Type, returning TypeAssertions. This allows for fluent assertions on type objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.Types.TypeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Type subject) { }\n```\n\n----------------------------------------\n\nTITLE: Stream Assertions Implementation in C#\nDESCRIPTION: Classes for asserting conditions on buffered streams. Provides specialized assertions for stream operations and state verification.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic class BufferedStreamAssertions : FluentAssertions.Streams.BufferedStreamAssertions<FluentAssertions.Streams.BufferedStreamAssertions>\n{\n    public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n\npublic class BufferedStreamAssertions<TAssertions> : FluentAssertions.Streams.StreamAssertions<System.IO.BufferedStream, TAssertions>\n    where TAssertions : FluentAssertions.Streams.BufferedStreamAssertions<TAssertions>\n{\n    public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic SimpleTimeSpanAssertions Class in C#\nDESCRIPTION: Provides a generic base class for TimeSpan assertions with methods for comparing TimeSpan values. Includes methods for equality, relative comparison (greater/less than), and proximity assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleTimeSpanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>\n{\n    public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.TimeSpan? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeCloseTo(System.TimeSpan nearbyTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeGreaterThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThan(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeLessThanOrEqualTo(System.TimeSpan expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNegative(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BePositive(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(System.TimeSpan unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeCloseTo(System.TimeSpan distantTime, System.TimeSpan precision, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeSpanCondition Enumeration in FluentAssertions\nDESCRIPTION: Enum definition for TimeSpanCondition in FluentAssertions, used to specify time-based comparison conditions. It includes values for different comparison operations like MoreThan, AtLeast, Exactly, Within, and LessThan.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_132\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum TimeSpanCondition\n{\n    MoreThan = 0,\n    AtLeast = 1,\n    Exactly = 2,\n    Within = 3,\n    LessThan = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAssertionContext Interface\nDESCRIPTION: Defines an interface for assertion contexts containing the subject, expectation, and reason information. Provides access to the selected node in the object graph during assertion.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAssertionContext<TSubject>\n{\n    string Because { get; set; }\n    object[] BecauseArgs { get; set; }\n    TSubject Expectation { get; }\n    FluentAssertions.Equivalency.INode SelectedNode { get; }\n    TSubject Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IClock Interface in C#\nDESCRIPTION: Defines an interface for clock operations used in testing, including delays and timer management for time-dependent tests.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_52\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IClock\n{\n    void Delay(System.TimeSpan timeToDelay);\n    System.Threading.Tasks.Task DelayAsync(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken);\n    FluentAssertions.Common.ITimer StartTimer();\n}\n```\n\n----------------------------------------\n\nTITLE: XDocumentAssertions Class Implementation in C#\nDESCRIPTION: Defines the XDocumentAssertions class which extends ReferenceTypeAssertions to provide assertion capabilities for XML documents. Contains methods for comparing documents, checking for elements and their values, and verifying document structure.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_167\n\nLANGUAGE: C#\nCODE:\n```\npublic class XDocumentAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XDocument, FluentAssertions.Xml.XDocumentAssertions>\n{\n    public XDocumentAssertions(System.Xml.Linq.XDocument document, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> Be(System.Xml.Linq.XDocument expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> BeEquivalentTo(System.Xml.Linq.XDocument expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBe(System.Xml.Linq.XDocument unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBeEquivalentTo(System.Xml.Linq.XDocument unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(string unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: C# Method Info Selector Assertions Class\nDESCRIPTION: Class for making assertions about method information using FluentAssertions. Provides methods to assert access modifiers, async status, and attribute decoration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_159\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoSelectorAssertions {\n    public MethodInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.MethodInfo[] methods) { }\n    protected string Context { get; }\n    public System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> SubjectMethods { get; }\n    // ... assertion methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GlobalEquivalencyOptions Class in C#\nDESCRIPTION: Defines a class for global equivalency comparison options that apply to all equivalency assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_57\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GlobalEquivalencyOptions\n{\n    public GlobalEquivalencyOptions() { }\n    public FluentAssertions.Equivalency.EquivalencyPlan Plan { get; }\n    public FluentAssertions.Equivalency.EquivalencyOptions<T> CloneDefaults<T>() { }\n    public void Modify(System.Func<FluentAssertions.Equivalency.EquivalencyOptions, FluentAssertions.Equivalency.EquivalencyOptions> configureOptions) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Fluent Count Assertions in C#\nDESCRIPTION: Alternative fluent syntax for specifying count-based assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\ntheString.Should().Contain(\"is a\", 4.TimesExactly());\ntheString.Should().Contain(\"is a\", 4.TimesOrMore());\ntheString.Should().Contain(\"is a\", 4.TimesOrLess());\n```\n\n----------------------------------------\n\nTITLE: XML Assertion Extensions in FluentAssertions\nDESCRIPTION: Extension methods providing assertion capabilities for XML elements and nodes. These methods return specialized assertion objects for validating XML structure and content.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\npublic static class XmlAssertionExtensions\n{\n    public static FluentAssertions.Xml.XmlElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlElement actualValue) { }\n    public static FluentAssertions.Xml.XmlNodeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlNode actualValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Assertion Scope in C#\nDESCRIPTION: Defines the AssertionScope class that manages the context for a group of related assertions. It provides methods for tracking failures and configuring assertion behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_79\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssertionScope : System.IDisposable\n    {\n        public AssertionScope() { }\n        public AssertionScope(FluentAssertions.Execution.IAssertionStrategy assertionStrategy) { }\n        public AssertionScope(System.Func<string> name) { }\n        public AssertionScope(string name) { }\n        public FluentAssertions.Formatting.FormattingOptions FormattingOptions { get; }\n        public System.Func<string> Name { get; }\n        public static FluentAssertions.Execution.AssertionScope Current { get; }\n        public void AddPreFormattedFailure(string formattedFailureMessage) { }\n        public void AppendTracing(string tracingBlock) { }\n        public string[] Discard() { }\n        public void Dispose() { }\n        public bool HasFailures() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: XElementAssertions Class Definition in C#\nDESCRIPTION: Partial definition of XElementAssertions class for making assertions about XML elements. Includes methods to verify element equivalence and attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_156\n\nLANGUAGE: csharp\nCODE:\n```\npublic class XElementAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XElement, FluentAssertions.Xml.XElementAssertions>\n{\n    public XElementAssertions(System.Xml.Linq.XElement xElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> Be(System.Xml.Linq.XElement expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> BeEquivalentTo(System.Xml.Linq.XElement expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(string expectedName, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining IEquivalencyValidationContext Interface in C#\nDESCRIPTION: Interface providing context information during equivalency validation, including the current node, options, and methods to create context for nested validation scenarios.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_49\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEquivalencyValidationContext\n{\n    FluentAssertions.Equivalency.INode CurrentNode { get; }\n    FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    FluentAssertions.Execution.Reason Reason { get; }\n    FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext Clone();\n    bool IsCyclicReference(object expectation);\n}\n```\n\n----------------------------------------\n\nTITLE: Using WithExpectation and ClearExpectation in previous versions\nDESCRIPTION: Example of how WithExpectation was used with ClearExpectation in previous versions to build complex assertion failure messages. This pattern required explicit clearing of expectations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov8.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nExecute.Assertion\n    .BecauseOf(because, becauseArgs)\n    .WithExpectation(\"Expected {context:the time} to be within {0} from {1}{reason}, \", precision, nearbyTime)\n    .ForCondition(Subject is not null)\n    .FailWith(\"but found <null>.\")\n    .Then\n    .ForCondition(Subject?.IsCloseTo(nearbyTime, precision) == true)\n    .FailWith(\"but {0} was off by {1}.\", Subject, difference)\n    .Then\n    .ClearExpectation();\n```\n\n----------------------------------------\n\nTITLE: Implementing BeDataContractSerializable Method for Object Assertions in FluentAssertions\nDESCRIPTION: Extension method that asserts whether an object can be serialized using DataContractSerializer. This method is part of the ObjectAssertionsExtensions class and supports custom failure messages through the 'because' parameter.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ObjectAssertionsExtensions\n{\n    public static FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeDataContractSerializable(this FluentAssertions.Primitives.ObjectAssertions assertions, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableGuidAssertions in C#\nDESCRIPTION: Defines a class for fluent assertions on nullable Guid values. Inherits from the generic version and provides assertion capabilities specific to nullable Guid types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableGuidAssertions : FluentAssertions.Primitives.NullableGuidAssertions<FluentAssertions.Primitives.NullableGuidAssertions>\n{\n    public NullableGuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XML Assertion Extensions in C#\nDESCRIPTION: Extension methods for creating assertions on XML elements and nodes. These methods enable testing XML content with a fluent syntax, allowing for verification of XML structure and content.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic static class XmlAssertionExtensions\n{\n    public static FluentAssertions.Xml.XmlElementAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlElement actualValue) { }\n    public static FluentAssertions.Xml.XmlNodeAssertions Should([System.Diagnostics.CodeAnalysis.NotNull] this System.Xml.XmlNode actualValue) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Ordering for Specific Collections in FluentAssertions using C#\nDESCRIPTION: Example demonstrating how to enforce strict ordering only for specific collection properties. Allows for fine-grained control over ordering requirements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(expectation, options => options.WithStrictOrderingFor(s => s.Products));\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffsetRangeAssertions Class Implementation in FluentAssertions\nDESCRIPTION: Class for asserting that DateTimeOffset values fall within specific time ranges. Provides methods to validate that a DateTimeOffset is before or after a specific target with customizable error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_112\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateTimeOffsetRangeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n{\n    protected DateTimeOffsetRangeAssertions(TAssertions parentAssertions, FluentAssertions.Execution.AssertionChain assertionChain, System.DateTimeOffset? subject, FluentAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> After(System.DateTimeOffset target, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Before(System.DateTimeOffset target, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GetSubjectId Delegate in C#\nDESCRIPTION: Delegate that returns a string identifier for a subject being validated, useful for generating descriptive error messages or logging.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_45\n\nLANGUAGE: csharp\nCODE:\n```\npublic delegate string GetSubjectId();\n```\n\n----------------------------------------\n\nTITLE: Implementing Excluding Method in EquivalencyOptions\nDESCRIPTION: Excludes a specific property from the equivalency comparison using a lambda expression. This allows for ignoring certain properties during comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Excluding(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing String-Based WithMapping Method for Nested Types\nDESCRIPTION: Maps a member from a nested expectation type to a differently named member in a nested subject type using string names. Provides an alternative to lambda expressions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(string expectationMemberName, string subjectMemberName) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing DictionaryEquivalencyStep in C#\nDESCRIPTION: Defines the DictionaryEquivalencyStep class which extends EquivalencyStep<IDictionary>. It handles equivalency validation for dictionaries.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic class DictionaryEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Collections.IDictionary>\n{\n    public DictionaryEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic NullableDateTimeAssertions Class with DateTime Validation Methods\nDESCRIPTION: Generic class for nullable DateTime assertions that extends DateTimeAssertions with methods for nullable-specific validations. Adds methods for checking null state and value presence in addition to DateTime value assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_121\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableDateTimeAssertions<TAssertions> : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableDateTimeAssertions<TAssertions>\n{\n    public NullableDateTimeAssertions(System.DateTime? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamAssertions Class for Stream Assertions in C#\nDESCRIPTION: StreamAssertions class implementation that extends the generic StreamAssertions class specifically for System.IO.Stream instances. This class provides a clean entry point for making assertions on Stream objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_149\n\nLANGUAGE: C#\nCODE:\n```\npublic class StreamAssertions : FluentAssertions.Streams.StreamAssertions<System.IO.Stream, FluentAssertions.Streams.StreamAssertions>\n{\n    public StreamAssertions(System.IO.Stream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: LessThan Occurrence Constraints in FluentAssertions (C#)\nDESCRIPTION: Static methods for creating occurrence constraints that specify an upper bound (less than) of expected occurrences. These constraints are used with event monitoring and collection assertions to verify occurrence counts below a specific threshold.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class LessThan\n{\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ITimer Interface for Time Measurement in C#\nDESCRIPTION: Defines an interface for timer operations used in time-based assertions. It extends IDisposable to ensure proper resource cleanup and provides an Elapsed property to measure time duration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_50\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ITimer : System.IDisposable\n{\n    System.TimeSpan Elapsed { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: XmlElementAssertions Class Definition in C#\nDESCRIPTION: Class definition for XmlElementAssertions which extends XmlNodeAssertions to provide specialized assertions for XmlElement objects. The class includes methods for verifying attributes, elements, and inner text with namespace support.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_158\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlElementAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlElement, FluentAssertions.Xml.XmlElementAssertions>\n{\n    public XmlElementAssertions(System.Xml.XmlElement xmlElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElement(string expectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XmlElementAssertions, System.Xml.XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveInnerText(string expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Formatters to Nested AssertionScopes\nDESCRIPTION: Demonstrates how formatters are inherited in nested AssertionScopes, allowing inner scopes to access formatters defined in outer scopes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nusing var outerScope = new AssertionScope();\n\nvar outerFormatter = new OuterFormatter();\nvar innerFormatter = new InnerFormatter();\nouterScope.FormattingOptions.AddFormatter(outerFormatter);\n\nusing var innerScope = new AssertionScope();\ninnerScope.FormattingOptions.AddFormatter(innerFormatter);\n\n// At this point outerFormatter and innerFormatter will be available\n```\n\n----------------------------------------\n\nTITLE: Implementing XML Node Assertions in C#\nDESCRIPTION: The XmlNodeAssertions class provides a base for XML node assertions. It inherits from the generic XmlNodeAssertions<XmlNode, XmlNodeAssertions> class.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_163\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlNode, FluentAssertions.Xml.XmlNodeAssertions>\n{\n    public XmlNodeAssertions(System.Xml.XmlNode xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: MSTest Assembly Initialization Configuration\nDESCRIPTION: Implementation of assembly-level initialization for MSTest using AssemblyInitializeAttribute to configure Fluent Assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n[TestClass]\npublic static class TestInitializer\n{\n    [AssemblyInitialize]\n    public static void SetDefaults(TestContext context)\n    {\n        AssertionConfiguration.Current.Equivalency.Modify(\n            options => { <configure here> });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IEquivalencyValidationContext Interface\nDESCRIPTION: Defines an interface for equivalency validation contexts. Provides access to the current node being compared and methods for creating nested contexts.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEquivalencyValidationContext\n{\n    FluentAssertions.Equivalency.INode CurrentNode { get; }\n    FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    FluentAssertions.Execution.Reason Reason { get; }\n    FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember);\n    FluentAssertions.Equivalency.IEquivalencyValidationContext Clone();\n    bool IsCyclicReference(object expectation);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Including Method in EquivalencyOptions\nDESCRIPTION: Explicitly includes a specific property in the equivalency comparison using a lambda expression. Useful when working with selective inclusion rules.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Including(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic EquivalencyOptions<T> Class in C#\nDESCRIPTION: Generic version of EquivalencyOptions that provides type-specific configuration methods for equivalency validation, including methods for including, excluding, and mapping members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_40\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyOptions<TExpectation> : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>>\n{\n    public EquivalencyOptions() { }\n    public EquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<System.Collections.Generic.IEnumerable<TExpectation>> AsCollection() { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Excluding(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n    public FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TExpectation, System.Collections.Generic.IEnumerable<TNext>>> expression) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Including(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TSubject>(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expectationMemberPath, System.Linq.Expressions.Expression<System.Func<TSubject, object>> subjectMemberPath) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(System.Linq.Expressions.Expression<System.Func<TNestedExpectation, object>> expectationMember, System.Linq.Expressions.Expression<System.Func<TNestedSubject, object>> subjectMember) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(string expectationMemberName, string subjectMemberName) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MemberExecutionTime<T> Class in C#\nDESCRIPTION: Class for measuring execution time of member methods on subjects of type T. Inherits from ExecutionTime and provides a way to test performance of specific methods on objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic class MemberExecutionTime<T> : FluentAssertions.Specialized.ExecutionTime\n    {\n        public MemberExecutionTime(T subject, System.Linq.Expressions.Expression<System.Action<T>> action, FluentAssertions.Common.StartTimer createTimer) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime vs. Declared Type Handling\nDESCRIPTION: Shows how to configure whether the comparison should use compile-time (declared) types or runtime types when selecting members to compare.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nDto orderDto = new OrderDto();\n\n// Use the runtime type of the members of orderDto\norderDto.Should().BeEquivalentTo(order, options => \n    options.PreferringRuntimeMemberTypes());\n\n// Use the declared type information of the members of orderDto\norderDto.Should().BeEquivalentTo(order, options => \n    options.PreferringDeclaredMemberTypes());\n```\n\n----------------------------------------\n\nTITLE: Implementing UInt64ValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of UInt64/ulong values in assertion results. It provides methods to check if it can handle a value type and to format the value accordingly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_108\n\nLANGUAGE: C#\nCODE:\n```\npublic class UInt64ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public UInt64ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pathway Class for FluentAssertions in C#\nDESCRIPTION: This class represents a pathway in the object graph during equivalency comparisons, including methods for creating and describing pathways.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic class Pathway : System.IEquatable<FluentAssertions.Equivalency.Pathway>\n{\n    public Pathway(FluentAssertions.Equivalency.Pathway parent, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }\n    public Pathway(string path, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }\n    public string Description { get; }\n    public string Name { get; }\n    public string Path { get; }\n    public string PathAndName { get; }\n    public override string ToString() { }\n    public delegate string GetDescription(string pathAndName);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic WithMapping Method for Nested Types\nDESCRIPTION: Maps a member from a nested expectation type to a differently named member in a nested subject type using lambda expressions. Supports deep property mapping.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(System.Linq.Expressions.Expression<System.Func<TNestedExpectation, object>> expectationMember, System.Linq.Expressions.Expression<System.Func<TNestedSubject, object>> subjectMember) { }\n```\n\n----------------------------------------\n\nTITLE: XmlElementAssertions Class Implementation in C#\nDESCRIPTION: Class for asserting XML element properties including attributes, elements, and inner text. Extends XmlNodeAssertions with XML-specific assertion capabilities.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_194\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlElementAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlElement, FluentAssertions.Xml.XmlElementAssertions>\n{\n    public XmlElementAssertions(System.Xml.XmlElement xmlElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    // Additional methods omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Continuation and ContinuationOfGiven Classes in C#\nDESCRIPTION: Defines Continuation and ContinuationOfGiven classes which enable fluent chaining of assertions. These classes are fundamental to the library's fluent API design pattern.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_113\n\nLANGUAGE: C#\nCODE:\n```\npublic class Continuation\n{\n    public FluentAssertions.Execution.AssertionChain Then { get; }\n}\n\npublic class ContinuationOfGiven<TSubject>\n{\n    public bool Succeeded { get; }\n    public FluentAssertions.Execution.GivenSelector<TSubject> Then { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic NullableDateTimeOffsetAssertions in C#\nDESCRIPTION: Defines a generic class for assertions on nullable DateTimeOffset values, extending DateTimeOffsetAssertions. Provides methods to assert nullability and value existence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeOffsetAssertions<TAssertions> : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<TAssertions>\n{\n    public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: StringAssertions Class Definition in C#\nDESCRIPTION: Defines a non-generic StringAssertions class that inherits from the generic version for string assertions. It provides a constructor that takes a string value and an assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringAssertions : FluentAssertions.Primitives.StringAssertions<FluentAssertions.Primitives.StringAssertions>\n{\n    public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: XmlNodeAssertions Class Definition in C#\nDESCRIPTION: Simple class definition for XmlNodeAssertions that inherits from the generic XmlNodeAssertions class, providing assertion capabilities for XmlNode objects. This class specializes the generic version for standard XmlNode types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_159\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlNode, FluentAssertions.Xml.XmlNodeAssertions>\n{\n    public XmlNodeAssertions(System.Xml.XmlNode xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EquivalencyResult Enum in C#\nDESCRIPTION: Enum representing possible results of an equivalency validation step, indicating whether the validation should continue with the next step or if equivalency has been proven.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum EquivalencyResult\n{\n    ContinueWithNext = 0,\n    EquivalencyProven = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: XElementAssertions Class Implementation in C#\nDESCRIPTION: Defines the XElementAssertions class that extends ReferenceTypeAssertions to provide fluent assertion methods for XElement objects. It includes methods to verify element attributes, child elements, values, and equivalence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_161\n\nLANGUAGE: C#\nCODE:\n```\npublic class XElementAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XElement, FluentAssertions.Xml.XElementAssertions>\n{\n    public XElementAssertions(System.Xml.Linq.XElement xElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> Be(System.Xml.Linq.XElement expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> BeEquivalentTo(System.Xml.Linq.XElement expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(string expectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttribute(System.Xml.Linq.XName expectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(string expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveAttributeWithValue(System.Xml.Linq.XName expectedName, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XElementAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> HaveValue(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBe(System.Xml.Linq.XElement unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotBeEquivalentTo(System.Xml.Linq.XElement unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(string unexpectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttribute(System.Xml.Linq.XName unexpectedName, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(string unexpectedName, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveAttributeWithValue(System.Xml.Linq.XName unexpectedName, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(string unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Equivalency Options with EquivalencyOptions Class Methods in C#\nDESCRIPTION: Methods for configuring equivalency options that allow fine-tuning how assertions are performed, including collection handling, member exclusion/inclusion, mapping between different types, and ordering configuration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<System.Collections.Generic.IEnumerable<TExpectation>> AsCollection() { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Excluding(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\npublic FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TExpectation, System.Collections.Generic.IEnumerable<TNext>>> expression) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Including(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TSubject>(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expectationMemberPath, System.Linq.Expressions.Expression<System.Func<TSubject, object>> subjectMemberPath) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(System.Linq.Expressions.Expression<System.Func<TNestedExpectation, object>> expectationMember, System.Linq.Expressions.Expression<System.Func<TNestedSubject, object>> subjectMember) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TNestedExpectation, TNestedSubject>(string expectationMemberName, string subjectMemberName) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing StringCollectionAssertions Class Hierarchy in C#\nDESCRIPTION: Defines a hierarchy of string collection assertion classes that provide specialized methods for asserting conditions on collections of strings. The classes use generic type parameters to support different collection types while maintaining a fluent interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_44\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StringCollectionAssertions : FluentAssertions.Collections.StringCollectionAssertions<System.Collections.Generic.IEnumerable<string>>\n{\n    public StringCollectionAssertions(System.Collections.Generic.IEnumerable<string> actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class StringCollectionAssertions<TCollection> : FluentAssertions.Collections.StringCollectionAssertions<TCollection, FluentAssertions.Collections.StringCollectionAssertions<TCollection>>\n    where TCollection : System.Collections.Generic.IEnumerable<string>\n{\n    public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\npublic class StringCollectionAssertions<TCollection, TAssertions> : FluentAssertions.Collections.GenericCollectionAssertions<TCollection, string, TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<string>\n    where TAssertions : FluentAssertions.Collections.StringCollectionAssertions<TCollection, TAssertions>\n{\n    public StringCollectionAssertions(TCollection actualValue, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> AllBe(string expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(params string[] expectation) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Collections.Generic.IEnumerable<string> expectation, System.Func<FluentAssertions.Equivalency.EquivalencyOptions<string>, FluentAssertions.Equivalency.EquivalencyOptions<string>> config, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, string> ContainMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal(System.Collections.Generic.IEnumerable<string> expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> Equal(params string[] expected) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotContainMatch(string wildcardPattern, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionConfiguration and AssertionEngine Static Classes in C#\nDESCRIPTION: Defines static classes for managing global assertion configuration and the assertion engine. These classes provide access to global settings and allow resetting to default configurations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionConfiguration\n{\n    public static FluentAssertions.Configuration.GlobalConfiguration Current { get; }\n}\n\npublic static class AssertionEngine\n{\n    public static FluentAssertions.Configuration.GlobalConfiguration Configuration { get; }\n    public static FluentAssertions.Execution.ITestFramework TestFramework { get; set; }\n    public static void ResetToDefaults() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GlobalConfiguration Class in C#\nDESCRIPTION: Defines a class for global configuration settings used throughout the FluentAssertions framework.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_56\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GlobalConfiguration\n{\n    public GlobalConfiguration() { }\n    public FluentAssertions.Configuration.GlobalEquivalencyOptions Equivalency { get; set; }\n    public FluentAssertions.Configuration.GlobalFormattingOptions Formatting { get; set; }\n    public FluentAssertions.Configuration.TestFramework? TestFramework { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeSelectorAssertions Class for Type Validation\nDESCRIPTION: Defines assertions for type collections with methods to verify type decorations, namespace membership, and sealing characteristics. Supports fluent assertion chaining.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_191\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeSelectorAssertions\n{\n    public TypeSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Type[] types) { }\n    public System.Collections.Generic.IEnumerable<System.Type> Subject { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    // ... additional assertion methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic EquivalencyOptions Class in C#\nDESCRIPTION: Defines a generic class for configuring typed equivalency comparison options with a fluent interface, including member exclusions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_66\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyOptions<TExpectation> : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>>\n{\n    public EquivalencyOptions() { }\n    public EquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<System.Collections.Generic.IEnumerable<TExpectation>> AsCollection() { }\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Excluding(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expression) { }\n    public FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TExpectation, System.Collections.Generic.IEnumerable<TNext>>> expression) { }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeCloseTo Methods for Integer Types in FluentAssertions\nDESCRIPTION: Extension methods that assert whether integer values (byte, short, int, long, etc.) are NOT close to a distant value within a specified delta. These methods provide negative checks to complement the BeCloseTo methods.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte distantValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short distantValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int distantValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long distantValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte distantValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort distantValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint distantValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong distantValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Configuring Record Type Comparison Behavior\nDESCRIPTION: Demonstrates how to customize the comparison of record types by switching between value-based and member-based comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nactual.Should().BeEquivalentTo(expected, options => options\n    .ComparingRecordsByValue()\n    .ComparingByMembers<MyRecord>());\n```\n\n----------------------------------------\n\nTITLE: Implementing NullValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of null values in assertion results, typically displaying them as '<null>'.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_98\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public NullValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion Failure Exception in C#\nDESCRIPTION: Implements the AssertionFailedException class that represents a failed assertion. It inherits from System.Exception and is thrown when assertions fail.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionFailedException : System.Exception\n    {\n        public AssertionFailedException(string message) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing GlobalConfiguration Class for FluentAssertions in C#\nDESCRIPTION: Provides a central configuration class for global settings in FluentAssertions. It contains properties for configuring equivalency comparison, formatting options, and test framework integration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_53\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GlobalConfiguration\n{\n    public GlobalConfiguration() { }\n    public FluentAssertions.Configuration.GlobalEquivalencyOptions Equivalency { get; set; }\n    public FluentAssertions.Configuration.GlobalFormattingOptions Formatting { get; set; }\n    public FluentAssertions.Configuration.TestFramework? TestFramework { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfoAssertions Class in C#\nDESCRIPTION: This class extends MemberInfoAssertions for PropertyInfo objects. It provides methods for asserting various properties of a PropertyInfo object, such as readability, writability, and return type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_185\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoAssertions : FluentAssertions.Types.MemberInfoAssertions<System.Reflection.PropertyInfo, FluentAssertions.Types.PropertyInfoAssertions>\n{\n    public PropertyInfoAssertions(System.Reflection.PropertyInfo propertyInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn(System.Type propertyType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn<TReturn>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return(System.Type propertyType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return<TReturn>(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyOptions Class in C#\nDESCRIPTION: Base equivalency options class that inherits from SelfReferenceEquivalencyOptions, providing configuration options for equivalency validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyOptions : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions>\n{\n    public EquivalencyOptions() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Occurred Event Class in C#\nDESCRIPTION: Defines the OccurredEvent class that represents an event that has been raised. It captures event details including name, parameters, sequence number, and timestamp.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic class OccurredEvent\n    {\n        public OccurredEvent() { }\n        public string EventName { get; set; }\n        public object[] Parameters { get; set; }\n        public int Sequence { get; set; }\n        public System.DateTime TimestampUtc { get; set; }\n    }\n```\n\n----------------------------------------\n\nTITLE: NullableBooleanAssertions Class Implementation in FluentAssertions\nDESCRIPTION: Non-generic facade class for nullable boolean assertions that inherits from the generic version. This class simplifies working with nullable boolean assertions by providing a concrete implementation with fixed generic parameters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_118\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableBooleanAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<FluentAssertions.Primitives.NullableBooleanAssertions>\n{\n    public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WithMapping Method using Lambda Expressions\nDESCRIPTION: Maps a member from the expectation to a differently named member in the subject using lambda expressions. Provides type-safe property mapping.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> WithMapping<TSubject>(System.Linq.Expressions.Expression<System.Func<TExpectation, object>> expectationMemberPath, System.Linq.Expressions.Expression<System.Func<TSubject, object>> subjectMemberPath) { }\n```\n\n----------------------------------------\n\nTITLE: NotBeDecoratedWith Method Signatures in C#\nDESCRIPTION: Method signatures for assertion methods that verify a member is not decorated with a specific attribute type. Supports both simple type check and predicate-based attribute evaluation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n```\n\n----------------------------------------\n\nTITLE: Implementing ObjectAssertions Class in C#\nDESCRIPTION: Non-generic class for making assertions on object instances. Extends the generic ObjectAssertions class with object-specific comparison methods using IEqualityComparer.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_157\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ObjectAssertions : FluentAssertions.Primitives.ObjectAssertions<object, FluentAssertions.Primitives.ObjectAssertions>\n{\n    public ObjectAssertions(object value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> Be<TExpectation>(TExpectation expected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> BeOneOf<TExpectation>(System.Collections.Generic.IEnumerable<TExpectation> validValues, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Primitives.ObjectAssertions> NotBe<TExpectation>(TExpectation unexpected, System.Collections.Generic.IEqualityComparer<TExpectation> comparer, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsCollection Method in EquivalencyOptions\nDESCRIPTION: Configures equivalency options to treat the expectation as a collection of items. This allows for collection-specific comparison behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.EquivalencyOptions<System.Collections.Generic.IEnumerable<TExpectation>> AsCollection() { }\n```\n\n----------------------------------------\n\nTITLE: Defining TypeSelectorAssertions for Asserting on Type Collections in C#\nDESCRIPTION: This class provides methods for making assertions on collections of types, such as checking if they are decorated with specific attributes or belong to certain namespaces.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_165\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeSelectorAssertions\n{\n    public TypeSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Type[] types) { }\n    public System.Collections.Generic.IEnumerable<System.Type> Subject { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyPlan Class in C#\nDESCRIPTION: Manages a collection of equivalency steps that are executed in sequence during equivalency validation. Provides methods to add, insert, and remove steps from the validation pipeline.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_41\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyPlan : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep>, System.Collections.IEnumerable\n{\n    public EquivalencyPlan() { }\n    public void Add<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void AddAfter<TPredecessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Clear() { }\n    public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IEquivalencyStep> GetEnumerator() { }\n    public void Insert<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void InsertBefore<TSuccessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Remove<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep { }\n    public void Reset() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SelfReferenceEquivalencyOptions Abstract Class in C#\nDESCRIPTION: Generic abstract base class that implements fluent configuration options for equivalency comparison with self-referencing capabilities for derived types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SelfReferenceEquivalencyOptions<TSelf> : FluentAssertions.Equivalency.IEquivalencyOptions\n    where TSelf : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>\n{\n    protected SelfReferenceEquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }\n    public bool? CompareRecordsByValue { get; }\n    public FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    public bool IgnoreCase { get; }\n    public bool IgnoreLeadingWhitespace { get; }\n    public bool IgnoreNewlineStyle { get; }\n    public bool IgnoreTrailingWhitespace { get; }\n    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]\n    protected FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }\n    public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }\n    protected TSelf AddMatchingRule(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }\n    protected TSelf AddSelectionRule(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }\n    public TSelf AllowingInfiniteRecursion() { }\n    public TSelf ComparingByMembers(System.Type type) { }\n    public TSelf ComparingByMembers<T>() { }\n    public TSelf ComparingByValue(System.Type type) { }\n    public TSelf ComparingByValue<T>() { }\n    public TSelf ComparingEnumsByName() { }\n    public TSelf ComparingEnumsByValue() { }\n    public TSelf ComparingRecordsByMembers() { }\n    public TSelf ComparingRecordsByValue() { }\n    public TSelf Excluding(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }\n    public TSelf ExcludingExplicitlyImplementedProperties() { }\n    public TSelf ExcludingFields() { }\n    public TSelf ExcludingMissingMembers() { }\n    public TSelf ExcludingNonBrowsableMembers() { }\n    public TSelf ExcludingProperties() { }\n    public TSelf IgnoringCase() { }\n    public TSelf IgnoringCyclicReferences() { }\n    public TSelf IgnoringLeadingWhitespace() { }\n    public TSelf IgnoringNewlineStyle() { }\n    public TSelf IgnoringNonBrowsableMembersOnSubject() { }\n    public TSelf IgnoringTrailingWhitespace() { }\n    public TSelf Including(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }\n    public TSelf IncludingAllDeclaredProperties() { }\n    public TSelf IncludingAllRuntimeProperties() { }\n    public TSelf IncludingFields() { }\n    public TSelf IncludingInternalFields() { }\n    public TSelf IncludingInternalProperties() { }\n    public TSelf IncludingNestedObjects() { }\n    public TSelf IncludingProperties() { }\n    public TSelf PreferringDeclaredMemberTypes() { }\n    public TSelf PreferringRuntimeMemberTypes() { }\n    public TSelf ThrowingOnMissingMembers() { }\n    public override string ToString() { }\n    public TSelf Using(FluentAssertions.Equivalency.IEquivalencyStep equivalencyStep) { }\n    public TSelf Using(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }\n    public TSelf Using(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }\n    public TSelf Using(FluentAssertions.Equivalency.IOrderingRule orderingRule) { }\n    public TSelf Using(System.Collections.Generic.IEqualityComparer<string> comparer) { }\n    public FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>.Restriction<TProperty> Using<TProperty>(System.Action<FluentAssertions.Equivalency.IAssertionContext<TProperty>> action) { }\n    public TSelf Using<T>(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public TSelf Using<T, TEqualityComparer>()\n        where TEqualityComparer : System.Collections.Generic.IEqualityComparer<T>, new () { }\n    public TSelf WithAutoConversion() { }\n    public TSelf WithAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithStrictOrdering() { }\n    public TSelf WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithTracing(FluentAssertions.Equivalency.Tracing.ITraceWriter writer = null) { }\n    public TSelf WithoutAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithoutMatchingRules() { }\n    public TSelf WithoutRecursing() { }\n    public TSelf WithoutSelectionRules() { }\n    public TSelf WithoutStrictOrdering() { }\n    public TSelf WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public class Restriction<TMember>\n    {\n        public Restriction(TSelf options, System.Action<FluentAssertions.Equivalency.IAssertionContext<TMember>> action) { }\n        public TSelf When(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n        public TSelf WhenTypeIs<TMemberType>()\n            where TMemberType : TMember { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfoSelectorAssertions Class in C#\nDESCRIPTION: This class provides methods for asserting properties of selected PropertyInfo objects, such as decorations, virtuality, and writability.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoSelectorAssertions\n{\n    public PropertyInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.PropertyInfo[] properties) { }\n    protected string Context { get; }\n    public System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> SubjectProperties { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoSelectorAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SelfReferenceEquivalencyOptions Abstract Class for FluentAssertions in C#\nDESCRIPTION: This abstract class provides a wide range of configuration options for equivalency assertions, including methods for including/excluding members, setting comparison rules, and configuring tracing.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SelfReferenceEquivalencyOptions<TSelf> : FluentAssertions.Equivalency.IEquivalencyOptions\n    where TSelf : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>\n{\n    protected SelfReferenceEquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }\n    public bool? CompareRecordsByValue { get; }\n    public FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    public bool IgnoreCase { get; }\n    public bool IgnoreLeadingWhitespace { get; }\n    public bool IgnoreNewlineStyle { get; }\n    public bool IgnoreTrailingWhitespace { get; }\n    [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]\n    protected FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }\n    public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }\n    protected TSelf AddMatchingRule(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }\n    protected TSelf AddSelectionRule(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }\n    public TSelf AllowingInfiniteRecursion() { }\n    public TSelf ComparingByMembers(System.Type type) { }\n    public TSelf ComparingByMembers<T>() { }\n    public TSelf ComparingByValue(System.Type type) { }\n    public TSelf ComparingByValue<T>() { }\n    public TSelf ComparingEnumsByName() { }\n    public TSelf ComparingEnumsByValue() { }\n    public TSelf ComparingRecordsByMembers() { }\n    public TSelf ComparingRecordsByValue() { }\n    public TSelf Excluding(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }\n    public TSelf ExcludingExplicitlyImplementedProperties() { }\n    public TSelf ExcludingFields() { }\n    public TSelf ExcludingMissingMembers() { }\n    public TSelf ExcludingNonBrowsableMembers() { }\n    public TSelf ExcludingProperties() { }\n    public TSelf IgnoringCase() { }\n    public TSelf IgnoringCyclicReferences() { }\n    public TSelf IgnoringLeadingWhitespace() { }\n    public TSelf IgnoringNewlineStyle() { }\n    public TSelf IgnoringNonBrowsableMembersOnSubject() { }\n    public TSelf IgnoringTrailingWhitespace() { }\n    public TSelf Including(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IMemberInfo, bool>> predicate) { }\n    public TSelf IncludingAllDeclaredProperties() { }\n    public TSelf IncludingAllRuntimeProperties() { }\n    public TSelf IncludingFields() { }\n    public TSelf IncludingInternalFields() { }\n    public TSelf IncludingInternalProperties() { }\n    public TSelf IncludingNestedObjects() { }\n    public TSelf IncludingProperties() { }\n    public TSelf PreferringDeclaredMemberTypes() { }\n    public TSelf PreferringRuntimeMemberTypes() { }\n    public TSelf ThrowingOnMissingMembers() { }\n    public override string ToString() { }\n    public TSelf Using(FluentAssertions.Equivalency.IEquivalencyStep equivalencyStep) { }\n    public TSelf Using(FluentAssertions.Equivalency.IMemberMatchingRule matchingRule) { }\n    public TSelf Using(FluentAssertions.Equivalency.IMemberSelectionRule selectionRule) { }\n    public TSelf Using(FluentAssertions.Equivalency.IOrderingRule orderingRule) { }\n    public TSelf Using(System.Collections.Generic.IEqualityComparer<string> comparer) { }\n    public FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>.Restriction<TProperty> Using<TProperty>(System.Action<FluentAssertions.Equivalency.IAssertionContext<TProperty>> action) { }\n    public TSelf Using<T>(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public TSelf Using<T, TEqualityComparer>()\n        where TEqualityComparer : System.Collections.Generic.IEqualityComparer<T>, new () { }\n    public TSelf WithAutoConversion() { }\n    public TSelf WithAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithStrictOrdering() { }\n    public TSelf WithStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithTracing(FluentAssertions.Equivalency.Tracing.ITraceWriter writer = null) { }\n    public TSelf WithoutAutoConversionFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public TSelf WithoutMatchingRules() { }\n    public TSelf WithoutRecursing() { }\n    public TSelf WithoutSelectionRules() { }\n    public TSelf WithoutStrictOrdering() { }\n    public TSelf WithoutStrictOrderingFor(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public class Restriction<TMember>\n    {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract MethodBaseAssertions for Method and Constructor Testing in C#\nDESCRIPTION: Abstract class extending MemberInfoAssertions to provide assertions specific to methods and constructors. Focuses on testing access modifiers for methods and constructors.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_155\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MethodBaseAssertions<TSubject, TAssertions> : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>\n    where TSubject : System.Reflection.MethodBase\n    where TAssertions : FluentAssertions.Types.MethodBaseAssertions<TSubject, TAssertions>\n{\n    protected MethodBaseAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Automatic Type Conversion for Properties\nDESCRIPTION: Demonstrates how to enable automatic conversion between different property types during comparison, using a path-based predicate to specify which properties should be converted.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nsubject.Should().BeEquivalentTo(expectation, options => options\n    .WithAutoConversionFor(x => x.Path.Contains(\"Birthdate\")));\n```\n\n----------------------------------------\n\nTITLE: Defining EqualityStrategy Enum in C#\nDESCRIPTION: Defines an enumeration for specifying different strategies for comparing objects for equality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_64\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum EqualityStrategy\n{\n    Equals = 0,\n    Members = 1,\n    ForceEquals = 2,\n    ForceMembers = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic BooleanAssertions Base Class in C#\nDESCRIPTION: Implements a generic base class for boolean assertions with methods specifically designed for boolean operations. It includes methods for checking true/false values and logical implications.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_101\n\nLANGUAGE: csharp\nCODE:\n```\npublic class BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n{\n    public BooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public bool? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(bool expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeFalse(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeTrue(string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Imply(bool consequent, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(bool unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeExtensions for DateTime Conversion in C#\nDESCRIPTION: Provides extension methods for converting DateTime objects to DateTimeOffset. These methods facilitate testing code that deals with time zone offsets.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_48\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class DateTimeExtensions\n{\n    public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime) { }\n    public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime, System.TimeSpan offset) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Method Info Assertions in C#\nDESCRIPTION: Class providing assertions for MethodInfo objects, including checks for async/virtual methods and return types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_184\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.MethodInfo, FluentAssertions.Types.MethodInfoAssertions>\n{\n    public MethodInfoAssertions(System.Reflection.MethodInfo methodInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoAssertions> BeAsync(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Event Monitor Options in C#\nDESCRIPTION: Implements the EventMonitorOptions class that configures behavior for event monitoring. It provides fluent options for handling event accessor exceptions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventMonitorOptions\n    {\n        public EventMonitorOptions() { }\n        public FluentAssertions.Events.EventMonitorOptions IgnoringEventAccessorExceptions() { }\n        public FluentAssertions.Events.EventMonitorOptions RecordingEventsWithBrokenAccessor() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Generic NumericAssertions Base Class in C#\nDESCRIPTION: Implements a generic base class for non-nullable numeric assertions that extends NumericAssertionsBase. It provides a constructor for initializing with a value and an AssertionChain, plus access to the underlying Subject.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_99\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertions<T, TAssertions>\n{\n    public NumericAssertions(T value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public override T Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DelegateAssertionsBase Class in C#\nDESCRIPTION: Abstract base class for delegate assertions, providing common functionality for asserting exception behavior across different delegate types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_168\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class DelegateAssertionsBase<TDelegate, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TDelegate, FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>>\n    where TDelegate : System.Delegate\n    where TAssertions : FluentAssertions.Specialized.DelegateAssertionsBase<TDelegate, TAssertions>\n{\n    protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal(System.Exception exception, string because, object[] becauseArgs) { }\n    protected FluentAssertions.AndConstraint<TAssertions> NotThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)\n        where TException : System.Exception { }\n    protected FluentAssertions.Specialized.ExceptionAssertions<TException> ThrowInternal<TException>(System.Exception exception, string because, object[] becauseArgs)\n        where TException : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableEnumAssertions<TEnum, TAssertions> Class\nDESCRIPTION: Generic implementation of assertions for nullable enum values, extending EnumAssertions<TEnum, TAssertions>. It provides methods specific to nullable enums like BeNull and HaveValue.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_150\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableEnumAssertions<TEnum, TAssertions> : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>\n    where TEnum :  struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, TAssertions>\n{\n    public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NestedExclusionOptionBuilder in C#\nDESCRIPTION: Builder class for configuring nested exclusion rules in equivalency comparison. Allows for fluent configuration of which nested properties should be excluded from comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_88\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NestedExclusionOptionBuilder<TExpectation, TCurrent>\n{\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Exclude(System.Linq.Expressions.Expression<System.Func<TCurrent, object>> expression) { }\n    public FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TCurrent, System.Collections.Generic.IEnumerable<TNext>>> expression) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GenericDictionaryAssertions Class in C#\nDESCRIPTION: This snippet defines the GenericDictionaryAssertions class, which inherits from GenericDictionaryAssertions with specific type parameters. It provides a constructor for initializing the assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryAssertions<TCollection, TKey, TValue> : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue>>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n{\n    public GenericDictionaryAssertions(TCollection keyValuePairs, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Equivalency Validation Steps with EquivalencyPlan Class in C#\nDESCRIPTION: Provides a collection to manage the steps in an equivalency validation pipeline. Supports adding, inserting, and removing steps with control over the order of execution.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class EquivalencyPlan : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep>, System.Collections.IEnumerable\n{\n    public EquivalencyPlan() { }\n    public void Add<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void AddAfter<TPredecessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Clear() { }\n    public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IEquivalencyStep> GetEnumerator() { }\n    public void Insert<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void InsertBefore<TSuccessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Remove<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep { }\n    public void Reset() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeSelector Class in C#\nDESCRIPTION: This class provides methods for filtering and selecting types based on various criteria. It implements IEnumerable<Type> and includes methods for selecting types based on their characteristics, such as being abstract, classes, or decorated with specific attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_151\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeSelector : System.Collections.Generic.IEnumerable<System.Type>, System.Collections.IEnumerable\n{\n    public TypeSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public TypeSelector(System.Type type) { }\n    public System.Collections.Generic.IEnumerator<System.Type> GetEnumerator() { }\n    public FluentAssertions.Types.TypeSelector ThatAreAbstract() { }\n    public FluentAssertions.Types.TypeSelector ThatAreClasses() { }\n    // ... (additional methods omitted for brevity)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionRuleEquivalencyStep in C#\nDESCRIPTION: Defines the AssertionRuleEquivalencyStep class which implements IEquivalencyStep. It handles equivalency validation for assertion rules.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionRuleEquivalencyStep<TSubject> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public AssertionRuleEquivalencyStep(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate, System.Action<FluentAssertions.Equivalency.IAssertionContext<TSubject>> assertionAction) { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SimpleEqualityEquivalencyStep in C#\nDESCRIPTION: Class for performing simple equality checks in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to compare objects using their Equals method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public SimpleEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfoSelector Class in C#\nDESCRIPTION: This class provides methods for selecting and filtering PropertyInfo objects based on various criteria such as abstractness, visibility, and type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>, System.Collections.IEnumerable\n{\n    public PropertyInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public PropertyInfoSelector(System.Type type) { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreAbstract { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotAbstract { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotStatic { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotVirtual { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatArePublicOrInternal { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreStatic { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreVirtual { get; }\n    public System.Collections.Generic.IEnumerator<System.Reflection.PropertyInfo> GetEnumerator() { }\n    public FluentAssertions.Types.PropertyInfoSelector NotOfType<TReturn>() { }\n    public FluentAssertions.Types.PropertyInfoSelector OfType<TReturn>() { }\n    public FluentAssertions.Types.TypeSelector ReturnTypes() { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public System.Reflection.PropertyInfo[] ToArray() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Restriction Class for Fluent Equivalency Configuration in C#\nDESCRIPTION: Defines methods for configuring equivalency restriction options in FluentAssertions. Provides predicate-based and type-based filtering for member comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic Restriction(TSelf options, System.Action<FluentAssertions.Equivalency.IAssertionContext<TMember>> action) { }\npublic TSelf When(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\npublic TSelf WhenTypeIs<TMemberType>()\n    where TMemberType : TMember { }\n```\n\n----------------------------------------\n\nTITLE: FormattedObjectGraph Class for Structured Output\nDESCRIPTION: This class manages the formatted output graph, handling indentation, line counts, and conversion to string. It provides methods for adding content with proper formatting and tracking the number of lines generated.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_126\n\nLANGUAGE: C#\nCODE:\n```\npublic class FormattedObjectGraph\n{\n    public FormattedObjectGraph(int maxLines) { }\n    public int LineCount { get; }\n    public static int SpacesPerIndentation { get; }\n    public void AddFragment(string fragment) { }\n    public void AddFragmentOnNewLine(string fragment) { }\n    public void AddLine(string content) { }\n    public void AddLineOrFragment(string fragment) { }\n    public override string ToString() { }\n    public System.IDisposable WithIndentation() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Members with Different Names in FluentAssertions using C#\nDESCRIPTION: Code examples demonstrating how to map properties with different names when comparing objects using BeEquivalentTo. Shows both string-based and expression-based approaches for mapping simple properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n// Using names with the expectation member name first. Then the subject's member name.\norderDto.Should().BeEquivalentTo(order, options => options\n    .WithMapping(\"Name\", \"OrderName\"));\n\n// Using expressions, but again, with expectation first, subject last.\norderDto.Should().BeEquivalentTo(order, options => options\n    .WithMapping<OrderDto>(e => e.Name, s => s.OrderName));\n```\n\n----------------------------------------\n\nTITLE: Implementing MethodInfoFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of MethodInfo objects in assertion results. It provides human-readable representations of method definitions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_96\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public MethodInfoFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic DateOnlyAssertions Base Class in C#\nDESCRIPTION: Begins implementation of a generic base class for DateOnly type assertions. This class would contain specific methods for date assertions like date comparisons and date-specific validations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_103\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateOnlyAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateOnlyAssertions<TAssertions>\n{\n```\n\n----------------------------------------\n\nTITLE: Implementing IValueFormatter Interface in C#\nDESCRIPTION: The IValueFormatter interface defines the contract for all value formatters in FluentAssertions. It requires implementations to specify what types they can handle and how to format those types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IValueFormatter\n{\n    bool CanHandle(object value);\n    void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TimeSpanCondition Enum in C#\nDESCRIPTION: Enumeration of conditions for comparing time spans, including MoreThan, AtLeast, Exactly, Within, and LessThan.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_165\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum TimeSpanCondition\n{\n    MoreThan = 0,\n    AtLeast = 1,\n    Exactly = 2,\n    Within = 3,\n    LessThan = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReferenceTypeAssertions Abstract Class in C#\nDESCRIPTION: Abstract base class for assertions on reference types, providing type checking and reference equality methods. Contains foundational assertion methods that all reference type assertions build upon.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_159\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ReferenceTypeAssertions<TSubject, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n{\n    protected ReferenceTypeAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }\n    protected abstract string Identifier { get; }\n    public TSubject Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, T> BeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, T> BeOfType<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSameAs(TSubject expected, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TSubject, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match<T>(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs)\n        where T : TSubject { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOfType<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSameAs(TSubject unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Satisfy<T>(System.Action<T> assertion)\n        where T : TSubject { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NestedExclusionOptionBuilder for Fluent Configuration in C#\nDESCRIPTION: Generic builder class that enables fluent configuration of nested exclusions in the equivalency comparison system.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic class NestedExclusionOptionBuilder<TExpectation, TCurrent>\n{\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Exclude(System.Linq.Expressions.Expression<System.Func<TCurrent, object>> expression) { }\n    public FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TCurrent, System.Collections.Generic.IEnumerable<TNext>>> expression) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReferenceTypeAssertions Abstract Class in C#\nDESCRIPTION: Base abstract class for all reference type assertions. Provides common methods for type checking, nullability testing, and reference equality assertions that are applicable to any reference type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class ReferenceTypeAssertions<TSubject, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n{\n    protected ReferenceTypeAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.Execution.AssertionChain CurrentAssertionChain { get; }\n    protected abstract string Identifier { get; }\n    public TSubject Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, T> BeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeOfType(System.Type expectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, T> BeOfType<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeSameAs(TSubject expected, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<TSubject, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match<T>(System.Linq.Expressions.Expression<System.Func<T, bool>> predicate, string because = \"\", params object[] becauseArgs)\n        where T : TSubject { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo(System.Type type, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeAssignableTo<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOfType(System.Type unexpectedType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeOfType<T>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeSameAs(TSubject unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Satisfy<T>(System.Action<T> assertion)\n        where T : TSubject { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic NullableEnumAssertions in C#\nDESCRIPTION: Defines a generic class for assertions on nullable enum values, extending EnumAssertions. Provides methods to assert nullability and value existence with enum-specific constraints.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableEnumAssertions<TEnum, TAssertions> : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>\n    where TEnum :  struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, TAssertions>\n{\n    public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<TAssertions, TEnum> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: IEquivalencyStep Interface Definition in C#\nDESCRIPTION: Defines a step in the equivalency comparison process that can handle comparing specific types of objects and report whether equivalency has been proven or should continue to the next step.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_75\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEquivalencyStep\n{\n    FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionFailedException Class in C#\nDESCRIPTION: Defines the AssertionFailedException class which is thrown when an assertion fails. It inherits from System.Exception and contains a constructor that takes a message parameter.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_111\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionFailedException : System.Exception\n{\n    public AssertionFailedException(string message) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyPlan Class\nDESCRIPTION: Defines a class that manages the sequence of equivalency steps to be executed during equivalency validation. Implements IEnumerable to allow iterating through the steps.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\npublic class EquivalencyPlan : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep>, System.Collections.IEnumerable\n{\n    public EquivalencyPlan() { }\n    public void Add<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void AddAfter<TPredecessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Clear() { }\n    public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IEquivalencyStep> GetEnumerator() { }\n    public void Insert<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void InsertBefore<TSuccessor, TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep, new () { }\n    public void Remove<TStep>()\n        where TStep : FluentAssertions.Equivalency.IEquivalencyStep { }\n    public void Reset() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionRuleEquivalencyStep in FluentAssertions.Equivalency.Steps\nDESCRIPTION: Implementation of IEquivalencyStep that applies custom assertion rules based on a predicate. This class is used to add custom assertions for specific object types during equivalency comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_94\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AssertionRuleEquivalencyStep<TSubject> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public AssertionRuleEquivalencyStep(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate, System.Action<FluentAssertions.Equivalency.IAssertionContext<TSubject>> assertionAction) { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GivenSelector Class in C#\nDESCRIPTION: Defines the GivenSelector generic class which provides condition-based assertion capabilities. It enables building complex assertion chains with different failure messages based on conditions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_115\n\nLANGUAGE: C#\nCODE:\n```\npublic class GivenSelector<T>\n{\n    public bool Succeeded { get; }\n    public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message) { }\n    public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params System.Func<T, object>[] args) { }\n    public FluentAssertions.Execution.ContinuationOfGiven<T> FailWith(string message, params object[] args) { }\n    public FluentAssertions.Execution.GivenSelector<T> ForCondition(System.Func<T, bool> predicate) { }\n    public FluentAssertions.Execution.GivenSelector<TOut> Given<TOut>(System.Func<T, TOut> selector) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GenericEnumerableEquivalencyStep in C#\nDESCRIPTION: Class for comparing generic enumerable collections in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to handle specialized generic collection comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_101\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericEnumerableEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public GenericEnumerableEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: NullableDateTimeAssertions Class Implementation in FluentAssertions\nDESCRIPTION: Non-generic facade class for nullable DateTime assertions that inherits from the generic version. This class simplifies working with nullable DateTime assertions by providing a concrete implementation with fixed generic parameters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_120\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableDateTimeAssertions : FluentAssertions.Primitives.NullableDateTimeAssertions<FluentAssertions.Primitives.NullableDateTimeAssertions>\n{\n    public NullableDateTimeAssertions(System.DateTime? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FailReason Class for Assertion Failure Details\nDESCRIPTION: Class that encapsulates the reason for an assertion failure, including a message and arguments. Used to provide detailed information about why assertions failed.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_83\n\nLANGUAGE: C#\nCODE:\n```\npublic class FailReason\n{\n    public FailReason(string message, params object[] args) { }\n    public object[] Args { get; }\n    public string Message { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: XmlNodeFormatter Class for Formatting XML in Test Output\nDESCRIPTION: Class implementing IValueFormatter interface to format XML nodes in test failure messages. Handles conversion of XML nodes to readable string representations for display in test results.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_177\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XmlNodeFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract OccurrenceConstraint Class in FluentAssertions\nDESCRIPTION: Base class for constraints that verify occurrences of specific elements in collections. The class provides a constructor accepting an expected count parameter for defining occurrence expectations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class OccurrenceConstraint\n{\n    protected OccurrenceConstraint(int expectedCount) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OccurrenceConstraint Abstract Class in C#\nDESCRIPTION: An abstract base class for constraints that deal with occurrence counts. It provides a foundation for implementing various constraints that verify the number of occurrences of elements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class OccurrenceConstraint\n{\n    protected OccurrenceConstraint(int expectedCount) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MethodInfoSelectorAssertions Class in C#\nDESCRIPTION: A class that provides assertion methods for a collection of MethodInfo objects, allowing bulk validation of multiple methods at once.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoSelectorAssertions\n    {\n        public MethodInfoSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Reflection.MethodInfo[] methods) { }\n        protected string Context { get; }\n        public System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> SubjectMethods { get; }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> Be(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeAsync(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n        public override bool Equals(object obj) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBe(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeAsync(string because = \"\", params object[] becauseArgs) { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n            where TAttribute : System.Attribute { }\n        public FluentAssertions.AndConstraint<FluentAssertions.Types.MethodInfoSelectorAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: IMemberMatchingRule Interface Definition in C#\nDESCRIPTION: Defines a rule for matching members between expectation and subject objects during equivalency comparison, allowing for custom member mapping strategies.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_79\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMemberMatchingRule\n{\n    FluentAssertions.Equivalency.IMember Match(FluentAssertions.Equivalency.IMember expectedMember, object subject, FluentAssertions.Equivalency.INode parent, FluentAssertions.Equivalency.IEquivalencyOptions options, FluentAssertions.Execution.AssertionChain assertionChain);\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Assertions Implementation in C#\nDESCRIPTION: Provides assertion capabilities for enum types with generic constraints ensuring the type parameter is an enum. Includes basic comparison operations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_140\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnumAssertions<TEnum, TAssertions>\n    where TEnum : struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions>\n{\n    public EnumAssertions(TEnum subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public TEnum? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(TEnum expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Node Interface in C#\nDESCRIPTION: Interface representing a node in the object graph being validated, with properties for accessing type information, paths, and context about the validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic interface INode\n{\n    int Depth { get; }\n    FluentAssertions.Equivalency.Pathway Expectation { get; }\n    FluentAssertions.Equivalency.GetSubjectId GetSubjectId { get; }\n    bool IsRoot { get; }\n    System.Type ParentType { get; }\n    bool RootIsCollection { get; }\n    FluentAssertions.Equivalency.Pathway Subject { get; }\n    System.Type Type { get; }\n```\n\n----------------------------------------\n\nTITLE: Implementing For Method in EquivalencyOptions\nDESCRIPTION: Configures options for a nested enumerable property. Returns a builder to further customize equivalency options for the specified nested collection.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TExpectation, System.Collections.Generic.IEnumerable<TNext>>> expression) { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic NullableSimpleTimeSpanAssertions in C#\nDESCRIPTION: Generic assertion class for nullable TimeSpan values, extending SimpleTimeSpanAssertions. Provides methods for checking equality, null values, and value existence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_156\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableSimpleTimeSpanAssertions<TAssertions> : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<TAssertions>\n{\n    public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Property Info Assertions in FluentAssertions\nDESCRIPTION: Defines methods for making assertions about property information in the FluentAssertions library. This class inherits from MemberInfoAssertions and provides methods to assert that properties have specific characteristics such as being readable, writable, virtual, or having specific return types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_151\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoAssertions : FluentAssertions.Types.MemberInfoAssertions<System.Reflection.PropertyInfo, FluentAssertions.Types.PropertyInfoAssertions>\n{\n    public PropertyInfoAssertions(System.Reflection.PropertyInfo propertyInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeReadable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> BeWritable(FluentAssertions.Common.CSharpAccessModifier accessModifier, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeReadable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeVirtual(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotBeWritable(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn(System.Type propertyType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> NotReturn<TReturn>(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return(System.Type propertyType, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.PropertyInfoAssertions> Return<TReturn>(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Class Formatter Implementation\nDESCRIPTION: Example of extending DefaultValueFormatter to customize formatting for a specific class type, excluding string members and namespace.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nclass CustomClassFormatter : DefaultValueFormatter\n{\n    public override bool CanHandle(object value) => value is CustomClass;\n\n    protected override MemberInfo[] GetMembers(Type type) =>\n        base.GetMembers(type).Where(e => e.GetUnderlyingType() != typeof(string));\n\n    protected override string TypeDisplayName(Type type) => type.Name;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Continuation Classes for Fluent Assertions\nDESCRIPTION: Set of classes that enable fluent continuation of assertions. Provides mechanisms for chaining assertions with Then syntax and managing assertion state.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\npublic class Continuation\n{\n    public FluentAssertions.Execution.AssertionChain Then { get; }\n}\n\npublic class ContinuationOfGiven<TSubject>\n{\n    public bool Succeeded { get; }\n    public FluentAssertions.Execution.GivenSelector<TSubject> Then { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeSelector Class for Type Filtering in C#\nDESCRIPTION: Defines a TypeSelector class that implements IEnumerable<Type> to provide fluent filtering of .NET types. Includes methods for filtering by class characteristics, namespace, inheritance, and more.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_190\n\nLANGUAGE: C#\nCODE:\n```\npublic class TypeSelector : System.Collections.Generic.IEnumerable<System.Type>, System.Collections.IEnumerable\n{\n    public TypeSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public TypeSelector(System.Type type) { }\n    public System.Collections.Generic.IEnumerator<System.Type> GetEnumerator() { }\n    public FluentAssertions.Types.TypeSelector ThatAreAbstract() { }\n    // ... additional type filtering methods\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EqualityComparerEquivalencyStep<T> in C#\nDESCRIPTION: Generic class for comparing objects using a custom IEqualityComparer<T> in FluentAssertions. It allows for specialized comparison logic to be injected into the equivalency validation process.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_99\n\nLANGUAGE: C#\nCODE:\n```\npublic class EqualityComparerEquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public EqualityComparerEquivalencyStep(System.Collections.Generic.IEqualityComparer<T> comparer) { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IValidateChildNodeEquivalency Interface in C#\nDESCRIPTION: Interface that provides a contract for validating equivalency between child nodes in the object graph. It has a single method to assert equivalency between comparands within a specific validation context.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_84\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IValidateChildNodeEquivalency\n{\n    void AssertEquivalencyOf(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OrderingRuleCollection in C#\nDESCRIPTION: Collection class for ordering rules that determines how strict ordering should be applied during equivalency comparison of collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic class OrderingRuleCollection : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule>, System.Collections.IEnumerable\n{\n    public OrderingRuleCollection() { }\n    public OrderingRuleCollection(System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule> orderingRules) { }\n    public void Add(FluentAssertions.Equivalency.IOrderingRule rule) { }\n    public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IOrderingRule> GetEnumerator() { }\n    public bool IsOrderingStrictFor(FluentAssertions.Equivalency.IObjectInfo objectInfo) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic NullableNumericAssertions Base Class in C#\nDESCRIPTION: Implements a generic base class for nullable numeric assertions that extends NumericAssertionsBase. This class provides nullable-specific assertion methods like BeNull, HaveValue, and Match.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_96\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableNumericAssertions<T, TAssertions> : FluentAssertions.Numeric.NumericAssertionsBase<T, T?, TAssertions>\n    where T :  struct, System.IComparable<T>\n    where TAssertions : FluentAssertions.Numeric.NullableNumericAssertions<T, TAssertions>\n{\n    public NullableNumericAssertions(T? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public override T? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Match(System.Linq.Expressions.Expression<System.Func<T?, bool>> predicate, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Object Graph Formatting Infrastructure for FluentAssertions\nDESCRIPTION: Classes that provide infrastructure for formatting object graphs in assertion failure messages. Includes delegate definitions, context objects, and configuration options to control formatting behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_96\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate void FormatChild(string childPath, object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph);\npublic class FormattedObjectGraph\n{\n    public FormattedObjectGraph(int maxLines) { }\n    public int LineCount { get; }\n    public static int SpacesPerIndentation { get; }\n    public void AddFragment(string fragment) { }\n    public void AddFragmentOnNewLine(string fragment) { }\n    public void AddLine(string content) { }\n    public void AddLineOrFragment(string fragment) { }\n    public override string ToString() { }\n    public System.IDisposable WithIndentation() { }\n}\npublic class FormattingContext\n{\n    public FormattingContext() { }\n    public bool UseLineBreaks { get; set; }\n}\npublic class FormattingOptions\n{\n    public FormattingOptions() { }\n    public int MaxDepth { get; set; }\n    public int MaxLines { get; set; }\n    public bool UseLineBreaks { get; set; }\n    public void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyOptions Classes in C#\nDESCRIPTION: Defines classes that hold configuration options for equivalency assertions. The generic version allows for more strongly-typed expectations while maintaining the fluent interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_60\n\nLANGUAGE: csharp\nCODE:\n```\npublic class EquivalencyOptions : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions>\n{\n    public EquivalencyOptions() { }\n}\npublic class EquivalencyOptions<TExpectation> : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<FluentAssertions.Equivalency.EquivalencyOptions<TExpectation>>\n{\n    public EquivalencyOptions() { }\n    public EquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IEquivalencyStep Interface\nDESCRIPTION: Defines an interface for equivalency validation steps. Each step is responsible for handling a specific aspect of equivalency validation and returning a result.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEquivalencyStep\n{\n    FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StartTimer Delegate for Timer Creation in C#\nDESCRIPTION: Defines a delegate for creating timer instances used in time-based assertions. This delegate is used by the IClock interface to create new timer instances.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_51\n\nLANGUAGE: csharp\nCODE:\n```\npublic delegate FluentAssertions.Common.ITimer StartTimer();\n```\n\n----------------------------------------\n\nTITLE: IOrderingRule Interface Definition in C#\nDESCRIPTION: Defines a rule for determining whether strict ordering should be used when comparing collections at a specific point in the object graph.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_83\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IOrderingRule\n{\n    FluentAssertions.Equivalency.OrderStrictness Evaluate(FluentAssertions.Equivalency.IObjectInfo objectInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OrderingRuleCollection Class in C#\nDESCRIPTION: Collection class for ordering rules used in equivalency comparison. Provides methods to add rules and check if strict ordering should be applied for a specific object during comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_90\n\nLANGUAGE: csharp\nCODE:\n```\npublic class OrderingRuleCollection : System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule>, System.Collections.IEnumerable\n{\n    public OrderingRuleCollection() { }\n    public OrderingRuleCollection(System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IOrderingRule> orderingRules) { }\n    public void Add(FluentAssertions.Equivalency.IOrderingRule rule) { }\n    public System.Collections.Generic.IEnumerator<FluentAssertions.Equivalency.IOrderingRule> GetEnumerator() { }\n    public bool IsOrderingStrictFor(FluentAssertions.Equivalency.IObjectInfo objectInfo) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMemberInfo Interface\nDESCRIPTION: Defines an interface for member information, containing metadata about a member including name, path, type, and accessibility modifiers for getters and setters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberInfo\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    string Name { get; }\n    string Path { get; set; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Method Info Selector API in FluentAssertions\nDESCRIPTION: Defines methods for selecting and filtering method information in the FluentAssertions library. This class provides fluent methods for filtering methods based on various criteria such as return type, being static, virtual, abstract, async, or decorated with specific attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_149\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Types.TypeSelector ReturnTypes() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreAbstract() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreAsync() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreDecoratedWith<TAttribute>()\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreNotAbstract() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreNotAsync() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWith<TAttribute>()\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()\n    where TAttribute : System.Attribute { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreNotStatic() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreNotVirtual() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreStatic() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatAreVirtual() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatDoNotReturn<TReturn>() { }\npublic FluentAssertions.Types.MethodInfoSelector ThatReturn<TReturn>() { }\npublic System.Reflection.MethodInfo[] ToArray() { }\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableDateTimeOffsetAssertions<TAssertions> Class\nDESCRIPTION: Generic implementation of assertions for nullable DateTimeOffset values, extending DateTimeOffsetAssertions<TAssertions>. It provides additional methods specific to nullable types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeOffsetAssertions<TAssertions> : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<TAssertions>\n{\n    public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AutoConversionStep in C#\nDESCRIPTION: Defines the AutoConversionStep class which implements IEquivalencyStep. It handles automatic conversion during equivalency validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic class AutoConversionStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public AutoConversionStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Suppressing License Warning in Fluent Assertions 8\nDESCRIPTION: Code to suppress the soft license warning in Fluent Assertions 8 by implementing an AssertionEngineInitializer that sets License.Accepted to true. This adds an assembly-level attribute that calls the initializer method during test execution.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: FluentAssertions.Extensibility.AssertionEngineInitializer(\n    typeof(AssertionEngineInitializer),\n    nameof(AssertionEngineInitializer.AcknowledgeSoftWarning))]\n\npublic static class AssertionEngineInitializer\n{\n    public static void AcknowledgeSoftWarning()\n    {\n        License.Accepted = true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reason Class for Assertion Context\nDESCRIPTION: Class that represents the reason for an assertion, with a formatted message and arguments. Used to provide context for why an assertion was made.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_88\n\nLANGUAGE: C#\nCODE:\n```\npublic class Reason\n{\n    public Reason(string formattedMessage, object[] arguments) { }\n    public object[] Arguments { get; set; }\n    public string FormattedMessage { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Collection Extensions in C#\nDESCRIPTION: Extension methods for filtering and manipulating collections of Type objects. Includes methods for filtering by namespace, inheritance, attributes, and other type characteristics.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic static class TypeEnumerableExtensions\n{\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreClasses(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatAreInNamespace(this System.Collections.Generic.IEnumerable<System.Type> types, string @namespace) { }\n    public static System.Collections.Generic.IEnumerable<System.Type> ThatImplement<T>(this System.Collections.Generic.IEnumerable<System.Type> types) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SubjectInfoExtensions for Member Access Modifier Checking in C#\nDESCRIPTION: Extension methods for FluentAssertions.Equivalency.IMemberInfo to check property getter and setter access modifiers. Provides utility methods to filter members based on their access level.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic static class SubjectInfoExtensions\n{\n    public static bool WhichGetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichGetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichSetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichSetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract MemberInfoAssertions for Reflection Member Testing in C#\nDESCRIPTION: Abstract base class for assertions on reflection members (fields, properties, methods, etc.). Provides common attribute-related assertions that apply to all member types, enabling verification of custom attributes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_154\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MemberInfoAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.Reflection.MemberInfo\n    where TAssertions : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>\n{\n    protected MemberInfoAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n}\n```\n\n----------------------------------------\n\nTITLE: XmlNodeAssertions Class Definition and Constructor\nDESCRIPTION: Declaration of the XmlNodeAssertions class that inherits from the generic XmlNodeAssertions class. Provides a constructor that takes an XmlNode instance and an assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_174\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlNode, FluentAssertions.Xml.XmlNodeAssertions>\n{\n    public XmlNodeAssertions(System.Xml.XmlNode xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: SimpleTimeSpanAssertions Class Definition in C#\nDESCRIPTION: Defines a non-generic SimpleTimeSpanAssertions class that inherits from the generic version for TimeSpan assertions. It provides a constructor that takes a nullable TimeSpan value and an assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_127\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleTimeSpanAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<FluentAssertions.Primitives.SimpleTimeSpanAssertions>\n{\n    public SimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringEqualityEquivalencyStep in C#\nDESCRIPTION: Class for specialized string comparison in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to handle string-specific comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public StringEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Extension Methods in C#\nDESCRIPTION: Implements extension methods for TimeSpan manipulation with support for fluent syntax and various time unit conversions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_88\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class FluentTimeSpanExtensions\n{\n    public const long TicksPerMicrosecond = 10;\n    public const double TicksPerNanosecond = 0.01D;\n    public static System.TimeSpan And(this System.TimeSpan sourceTime, System.TimeSpan offset) { }\n    public static System.TimeSpan Days(this double days) { }\n    // ... additional methods\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAssertionStrategy Interface\nDESCRIPTION: Interface for different assertion failure handling strategies. Defines methods for handling, retrieving, and discarding failures, allowing for custom assertion behavior.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_85\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAssertionStrategy\n{\n    System.Collections.Generic.IEnumerable<string> FailureMessages { get; }\n    System.Collections.Generic.IEnumerable<string> DiscardFailures();\n    void HandleFailure(string message);\n    void ThrowIfAny(System.Collections.Generic.IDictionary<string, object> context);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Assembly Metadata and Internal Visibility in C#\nDESCRIPTION: Sets the repository URL for the assembly and configures internal visibility for testing projects. This allows specific assemblies to access internal members of the FluentAssertions library.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadata(\"RepositoryUrl\", \"https://github.com/fluentassertions/fluentassertions\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"Benchmarks, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"FluentAssertions.Equivalency.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"FluentAssertions.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n```\n\n----------------------------------------\n\nTITLE: Defining Member Info Interface in C#\nDESCRIPTION: Interface providing metadata about a member, including its name, path, type, and accessibility modifiers for getters and setters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberInfo\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    string Name { get; }\n    string Path { get; set; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dictionary Equivalency Comparison in FluentAssertions\nDESCRIPTION: Classes for comparing dictionary types, including both generic and non-generic dictionaries. These steps determine how dictionary objects should be compared for equivalency.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_80\n\nLANGUAGE: C#\nCODE:\n```\npublic class DictionaryEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Collections.IDictionary>\n{\n    public DictionaryEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class GenericDictionaryEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public GenericDictionaryEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GlobalFormattingOptions Class in C#\nDESCRIPTION: Defines a class for global formatting options that control how objects are formatted in assertion failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_58\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GlobalFormattingOptions : FluentAssertions.Formatting.FormattingOptions\n{\n    public GlobalFormattingOptions() { }\n    public string ValueFormatterAssembly { get; set; }\n    public FluentAssertions.Common.ValueFormatterDetectionMode ValueFormatterDetectionMode { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MemberFactory Static Class for FluentAssertions in C#\nDESCRIPTION: This static class provides a method for creating IMember instances from MemberInfo and parent node information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\npublic static class MemberFactory\n{\n    public static FluentAssertions.Equivalency.IMember Create(System.Reflection.MemberInfo memberInfo, FluentAssertions.Equivalency.INode parent) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XElementValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of XElement objects from System.Xml.Linq in assertion results, displaying XML elements in a readable format.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_112\n\nLANGUAGE: C#\nCODE:\n```\npublic class XElementValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XElementValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NullableDateTimeOffsetAssertions Class\nDESCRIPTION: Concrete implementation of NullableDateTimeOffsetAssertions for asserting on nullable DateTimeOffset values. It inherits from the generic implementation for type-safety.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeOffsetAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<FluentAssertions.Primitives.NullableDateTimeOffsetAssertions>\n{\n    public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Scoped Value Formatter\nDESCRIPTION: Example of adding a custom formatter within a specific assertion scope.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nusing var scope = new AssertionScope();\n\nvar formatter = new CustomFormatter();\nscope.FormattingOptions.AddFormatter(formatter);\n```\n\n----------------------------------------\n\nTITLE: Defining Member Interface in C#\nDESCRIPTION: Interface representing a member (property or field) in a type, with methods to access its value and determine accessibility characteristics.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMember : FluentAssertions.Equivalency.INode\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    bool IsBrowsable { get; }\n    System.Type ReflectedType { get; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    object GetValue(object obj);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Formatting Infrastructure in FluentAssertions\nDESCRIPTION: Core formatting infrastructure classes used by FluentAssertions to generate readable output for assertion failures. These classes handle the formatting and display of objects in error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_89\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate void FormatChild(string childPath, object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph);\npublic class FormattedObjectGraph\n{\n    public FormattedObjectGraph(int maxLines) { }\n    public int LineCount { get; }\n    public static int SpacesPerIndentation { get; }\n    public void AddFragment(string fragment) { }\n    public void AddFragmentOnNewLine(string fragment) { }\n    public void AddLine(string content) { }\n    public void AddLineOrFragment(string fragment) { }\n    public override string ToString() { }\n    public System.IDisposable WithIndentation() { }\n}\npublic static class Formatter\n{\n    public static System.Collections.Generic.IEnumerable<FluentAssertions.Formatting.IValueFormatter> Formatters { get; }\n    public static void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public static void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MemberSelectionContext Class for FluentAssertions in C#\nDESCRIPTION: This class represents the context for member selection during equivalency comparisons, including compile-time and runtime types, and visibility options for fields and properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic class MemberSelectionContext\n{\n    public MemberSelectionContext(System.Type compileTimeType, System.Type runtimeType, FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }\n    public FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }\n    public System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FailReason Class in C#\nDESCRIPTION: Defines the FailReason class which encapsulates failure messages and their formatting arguments. This class is used to build descriptive error messages for assertion failures.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_114\n\nLANGUAGE: C#\nCODE:\n```\npublic class FailReason\n{\n    public FailReason(string message, params object[] args) { }\n    public object[] Args { get; }\n    public string Message { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableSimpleTimeSpanAssertions in C#\nDESCRIPTION: Defines a class for fluent assertions on nullable TimeSpan values. Inherits from the generic version and provides assertion capabilities specific to nullable TimeSpan types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_131\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableSimpleTimeSpanAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions>\n{\n    public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SubjectInfoExtensions for Member Access Checking in C#\nDESCRIPTION: Static extension methods for IMemberInfo that provide convenient ways to check access modifiers of property getters and setters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\npublic static class SubjectInfoExtensions\n{\n    public static bool WhichGetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichGetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichSetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichSetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableSimpleTimeSpanAssertions Class in C#\nDESCRIPTION: Class for making assertions on nullable TimeSpan values. Extends SimpleTimeSpanAssertions to provide specific assertion functionality for nullable TimeSpan types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_155\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableSimpleTimeSpanAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions>\n{\n    public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Obsolete Extension Methods for AndConstraint in FluentAssertions\nDESCRIPTION: Collection of obsolete methods that warn against incorrect usage of the fluent API when chaining methods. These methods throw compiler warnings when developers incorrectly call Should() directly after And() in the assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.BooleanAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.GuidAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.GuidAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TSubject, TAssertions>(this FluentAssertions.Numeric.NumericAssertionsBase<TSubject, TSubject, TAssertions> _)\n    where TSubject :  struct, System.IComparable<TSubject>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertions<TSubject, TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TEnum, TAssertions>(this FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions> _)\n    where TEnum :  struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions> { }\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n    \"ly following \\'And\\'\", true)]\npublic static void Should<TSubject, TAssertions>(this FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableDateTimeAssertions<TAssertions> Class\nDESCRIPTION: Generic implementation of assertions for nullable DateTime values, extending DateTimeAssertions<TAssertions>. It adds methods specific to nullable types like BeNull, HaveValue, etc.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_146\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeAssertions<TAssertions> : FluentAssertions.Primitives.DateTimeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableDateTimeAssertions<TAssertions>\n{\n    public NullableDateTimeAssertions(System.DateTime? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMemberSelectionRule Interface for FluentAssertions in C#\nDESCRIPTION: This interface defines methods for selecting members during equivalency comparisons, including a property to check if members are included and a method to select members based on the current node and context.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberSelectionRule\n{\n    bool IncludesMembers { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> SelectMembers(FluentAssertions.Equivalency.INode currentNode, System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> selectedMembers, FluentAssertions.Equivalency.MemberSelectionContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AggregateExceptionExtractor Class in C#\nDESCRIPTION: Defines the AggregateExceptionExtractor class which implements the IExtractExceptions interface. This class is responsible for extracting exceptions of a specific type from an AggregateException.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class AggregateExceptionExtractor : FluentAssertions.Specialized.IExtractExceptions\n{\n    public AggregateExceptionExtractor() { }\n    public System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)\n        where T : System.Exception { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeSpan Extension Methods Implementation\nDESCRIPTION: Extension methods for TimeSpan manipulation including conversions for hours, minutes, seconds, milliseconds, microseconds, nanoseconds and ticks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_89\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.TimeSpan Hours(this double hours) { }\npublic static System.TimeSpan Hours(this int hours) { }\npublic static System.TimeSpan Hours(this int hours, System.TimeSpan offset) { }\n```\n\n----------------------------------------\n\nTITLE: Interface Declarations for Equivalency System\nDESCRIPTION: Core interfaces defining the equivalency comparison system including IMember, IObjectInfo, IOrderingRule and IValidateChildNodeEquivalency. These interfaces provide the foundation for comparing objects and their members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IObjectInfo\n{\n    System.Type CompileTimeType { get; }\n    System.Type ParentType { get; }\n    string Path { get; set; }\n    System.Type RuntimeType { get; }\n    [System.Obsolete(\"Use CompileTimeType or RuntimeType instead\")]\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotBeCloseTo Extension Methods for Various Numeric Types in C#\nDESCRIPTION: These extension methods add the NotBeCloseTo assertion for different numeric types in FluentAssertions. They check if a numeric value is not close to a specified distant value within a given delta.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<byte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<byte> parent, byte distantValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<short>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<short> parent, short distantValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<int>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<int> parent, int distantValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<long>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<long> parent, long distantValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<sbyte>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<sbyte> parent, sbyte distantValue, byte delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ushort>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ushort> parent, ushort distantValue, ushort delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<uint>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<uint> parent, uint distantValue, uint delta, string because = \"\", params object[] becauseArgs) { }\npublic static FluentAssertions.AndConstraint<FluentAssertions.Numeric.NumericAssertions<ulong>> NotBeCloseTo(this FluentAssertions.Numeric.NumericAssertions<ulong> parent, ulong distantValue, ulong delta, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining BufferedStreamAssertions Class in C#\nDESCRIPTION: Class for making assertions about BufferedStream objects. Extends the generic BufferedStreamAssertions<T> to provide specialized assertions for buffered streams.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic class BufferedStreamAssertions : FluentAssertions.Streams.BufferedStreamAssertions<FluentAssertions.Streams.BufferedStreamAssertions>\n    {\n        public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing StringValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of string values in assertion results. It likely adds appropriate quotation marks and escapes special characters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_103\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public StringValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableBooleanAssertions<TAssertions> Class\nDESCRIPTION: Generic implementation of assertions for nullable boolean values, extending BooleanAssertions<TAssertions>. It provides additional methods specific to nullable booleans like BeNull, HaveValue, etc.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_144\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableBooleanAssertions<TAssertions> : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<TAssertions>\n{\n    public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(bool? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBe(bool? unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeFalse(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeTrue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pathway for Tracking Comparison Path in C#\nDESCRIPTION: Class that represents a path in the object graph during equivalency comparison, providing context and description about the current comparison location.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic class Pathway : System.IEquatable<FluentAssertions.Equivalency.Pathway>\n{\n    public Pathway(FluentAssertions.Equivalency.Pathway parent, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }\n    public Pathway(string path, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }\n    public string Description { get; }\n    public string Name { get; }\n    public string Path { get; }\n    public string PathAndName { get; }\n    public override string ToString() { }\n    public delegate string GetDescription(string pathAndName);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ConversionSelector Class in C#\nDESCRIPTION: Implements a class that determines whether a conversion is needed when comparing objects during equivalency validation. Provides methods to include or exclude specific conditions for conversion.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ConversionSelector\n{\n    public ConversionSelector() { }\n    public FluentAssertions.Equivalency.ConversionSelector Clone() { }\n    public void Exclude(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public void Include(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public void IncludeAll() { }\n    public bool RequiresConversion(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.INode currentNode) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Assertion Attributes in C#\nDESCRIPTION: Custom attributes that mark methods and assemblies as providing custom assertions for the FluentAssertions library.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic class CustomAssertionAttribute : System.Attribute\n{\n    public CustomAssertionAttribute() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly)]\npublic sealed class CustomAssertionsAssemblyAttribute : System.Attribute\n{\n    public CustomAssertionsAssemblyAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: IMemberSelectionRule Interface Definition in C#\nDESCRIPTION: Defines a rule for selecting which members of an object should be included in equivalency comparison, with a method to filter or transform the collection of selected members.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_80\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMemberSelectionRule\n{\n    bool IncludesMembers { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> SelectMembers(FluentAssertions.Equivalency.INode currentNode, System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMember> selectedMembers, FluentAssertions.Equivalency.MemberSelectionContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MemberInfoAssertions in C#\nDESCRIPTION: Defines an abstract base class MemberInfoAssertions for asserting properties of System.Reflection.MemberInfo objects. It includes methods for checking attribute decorations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_147\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MemberInfoAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.Reflection.MemberInfo\n    where TAssertions : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>\n{\n    protected MemberInfoAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>, TAttribute> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic NullableSimpleTimeSpanAssertions in C#\nDESCRIPTION: Defines a generic class for assertions on nullable TimeSpan values, extending SimpleTimeSpanAssertions. Provides methods to assert nullability, value existence, and value comparison.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_132\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableSimpleTimeSpanAssertions<TAssertions> : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<TAssertions>\n{\n    public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionRuleEquivalencyStep Class in C#\nDESCRIPTION: Generic class that implements an equivalency step for applying custom assertion rules during equivalency comparison, part of the equivalency steps namespace.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic class AssertionRuleEquivalencyStep<TSubject> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Constructor Assertions in C#\nDESCRIPTION: Class extending MethodBaseAssertions to provide assertions specific to constructor information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_182\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConstructorInfoAssertions : FluentAssertions.Types.MethodBaseAssertions<System.Reflection.ConstructorInfo, FluentAssertions.Types.ConstructorInfoAssertions>\n{\n    public ConstructorInfoAssertions(System.Reflection.ConstructorInfo constructorInfo, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Event Monitor Interface in C#\nDESCRIPTION: Defines the IMonitor<T> interface for monitoring events on objects. It provides methods to get event recordings and assertions, as well as tracking occurred events.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMonitor<T> : System.IDisposable\n    {\n        FluentAssertions.Events.EventMetadata[] MonitoredEvents { get; }\n        FluentAssertions.Events.OccurredEvent[] OccurredEvents { get; }\n        T Subject { get; }\n        void Clear();\n        FluentAssertions.Events.IEventRecording GetRecordingFor(string eventName);\n        FluentAssertions.Events.EventAssertions<T> Should();\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable DateTimeOffset Assertions in C#\nDESCRIPTION: Implementation of assertion classes for nullable DateTimeOffset values with generic type constraints. Provides methods for null checking and value validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_122\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeOffsetAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<FluentAssertions.Primitives.NullableDateTimeOffsetAssertions>\n{\n    public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NestedExclusionOptionBuilder Class for FluentAssertions in C#\nDESCRIPTION: This class provides methods for building nested exclusion options in equivalency comparisons, allowing for fine-grained control over member exclusions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class NestedExclusionOptionBuilder<TExpectation, TCurrent>\n{\n    public FluentAssertions.Equivalency.EquivalencyOptions<TExpectation> Exclude(System.Linq.Expressions.Expression<System.Func<TCurrent, object>> expression) { }\n    public FluentAssertions.Equivalency.NestedExclusionOptionBuilder<TExpectation, TNext> For<TNext>(System.Linq.Expressions.Expression<System.Func<TCurrent, System.Collections.Generic.IEnumerable<TNext>>> expression) { }\n}\n```\n\n----------------------------------------\n\nTITLE: FormattingOptions Class Definition in C#\nDESCRIPTION: Configuration class for formatting options including maximum depth, lines and line break settings. Provides methods to add and remove custom formatters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\npublic class FormattingOptions\n{\n    public FormattingOptions() { }\n    public int MaxDepth { get; set; }\n    public int MaxLines { get; set; }\n    public bool UseLineBreaks { get; set; }\n    public void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatter Configuration and Utilities\nDESCRIPTION: Static utilities and configuration classes for managing formatters and formatting options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_92\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Formatter\n{\n    public static System.Collections.Generic.IEnumerable<FluentAssertions.Formatting.IValueFormatter> Formatters { get; }\n    public static void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public static void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public static string ToString(object value, FluentAssertions.Formatting.FormattingOptions options = null) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Equivalency Step in C#\nDESCRIPTION: Abstract base class for implementing equivalency steps that participate in the validation pipeline. Handles the basic flow and delegates specific implementation to derived classes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class EquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    protected EquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    protected abstract FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalency Options Interface in C#\nDESCRIPTION: Interface for configuring how equivalency is determined, including case sensitivity, whitespace handling, member inclusion rules, and custom equivalency steps.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEquivalencyOptions\n{\n    bool AllowInfiniteRecursion { get; }\n    bool? CompareRecordsByValue { get; }\n    FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    FluentAssertions.Equivalency.CyclicReferenceHandling CyclicReferenceHandling { get; }\n    FluentAssertions.Equivalency.EnumEquivalencyHandling EnumEquivalencyHandling { get; }\n    bool ExcludeNonBrowsableOnExpectation { get; }\n    bool IgnoreCase { get; }\n    bool IgnoreLeadingWhitespace { get; }\n    bool IgnoreNewlineStyle { get; }\n    bool IgnoreNonBrowsableOnSubject { get; }\n    bool IgnoreTrailingWhitespace { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }\n    FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }\n    bool IsRecursive { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberMatchingRule> MatchingRules { get; }\n    FluentAssertions.Equivalency.OrderingRuleCollection OrderingRules { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IMemberSelectionRule> SelectionRules { get; }\n    FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; }\n    bool UseRuntimeTyping { get; }\n    System.Collections.Generic.IEnumerable<FluentAssertions.Equivalency.IEquivalencyStep> UserEquivalencySteps { get; }\n    FluentAssertions.Equivalency.EqualityStrategy GetEqualityStrategy(System.Type type);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SimpleTimeSpanAssertions in C#\nDESCRIPTION: Concrete implementation of assertions for TimeSpan values. Inherits from SimpleTimeSpanAssertions<T> to provide fluent assertions for TimeSpan objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic class SimpleTimeSpanAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<FluentAssertions.Primitives.SimpleTimeSpanAssertions>\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SByteValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of SByte values in assertion results. It provides methods to check if it can handle a value type and to format the value accordingly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_101\n\nLANGUAGE: C#\nCODE:\n```\npublic class SByteValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public SByteValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pathway Class in C#\nDESCRIPTION: Represents a path through the object graph during equivalency comparison. Tracks the current location in the object hierarchy and provides a description of the path for error messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_91\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Pathway : System.IEquatable<FluentAssertions.Equivalency.Pathway>\n{\n    public Pathway(FluentAssertions.Equivalency.Pathway parent, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }\n    public Pathway(string path, string name, FluentAssertions.Equivalency.Pathway.GetDescription getDescription) { }\n    public string Description { get; }\n    public string Name { get; }\n    public string Path { get; }\n    public string PathAndName { get; }\n    public override string ToString() { }\n    public delegate string GetDescription(string pathAndName);\n}\n```\n\n----------------------------------------\n\nTITLE: TypeSelectorAssertions Class Definition in C#\nDESCRIPTION: Definition of TypeSelectorAssertions class that provides assertion methods for collections of types. Includes methods to verify decoration with attributes, namespace containment, and type characteristics.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_153\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TypeSelectorAssertions\n{\n    public TypeSelectorAssertions(FluentAssertions.Execution.AssertionChain assertionChain, params System.Type[] types) { }\n    public System.Collections.Generic.IEnumerable<System.Type> Subject { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeInNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> BeUnderNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWith<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeDecoratedWithOrInherit<TAttribute>(System.Linq.Expressions.Expression<System.Func<TAttribute, bool>> isMatchingAttributePredicate, string because = \"\", params object[] becauseArgs)\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeInNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeSealed(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Types.TypeSelectorAssertions> NotBeUnderNamespace(string @namespace, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionEngineInitializerAttribute in C#\nDESCRIPTION: Defines an attribute for initializing the assertion engine. This attribute can be applied to assemblies to specify a type and method that should be called to initialize the assertion engine.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_83\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple=true)]\n    public sealed class AssertionEngineInitializerAttribute : System.Attribute\n    {\n        public AssertionEngineInitializerAttribute(System.Type type, string methodName) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Caller Identification Utility in C#\nDESCRIPTION: A static utility class for identifying the caller of an assertion, used internally by the FluentAssertions library.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CallerIdentifier\n{\n    public static System.Action<string> Logger { get; set; }\n    public static string[] DetermineCallerIdentities() { }\n    public static string DetermineCallerIdentity() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable Enum Assertions in C#\nDESCRIPTION: Assertion classes for nullable enum types with generic constraints. Provides methods for null checking and enum value validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableEnumAssertions<TEnum> : FluentAssertions.Primitives.NullableEnumAssertions<TEnum, FluentAssertions.Primitives.NullableEnumAssertions<TEnum>>\n    where TEnum :  struct, System.Enum\n{\n    public NullableEnumAssertions(TEnum? subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableDateTimeOffsetAssertions in C#\nDESCRIPTION: Defines a class for fluent assertions on nullable DateTimeOffset values. Inherits from the generic version and provides assertion capabilities specific to nullable DateTimeOffset types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeOffsetAssertions : FluentAssertions.Primitives.NullableDateTimeOffsetAssertions<FluentAssertions.Primitives.NullableDateTimeOffsetAssertions>\n{\n    public NullableDateTimeOffsetAssertions(System.DateTimeOffset? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NullableBooleanAssertions in FluentAssertions\nDESCRIPTION: Concrete implementation of NullableBooleanAssertions class for asserting on nullable boolean values. It inherits from the generic version to provide a simpler API for common use cases.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_143\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableBooleanAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<FluentAssertions.Primitives.NullableBooleanAssertions>\n{\n    public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Using/WhenTypeIs Combination Causing Compile Error in v6\nDESCRIPTION: Example showing how v6 introduces compile-time constraints between the type parameters of Using and WhenTypeIs, preventing mismatched types that would cause runtime errors.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar subject = new { Value = \"One\" };\nvar expectation = new { Value = \"Two\" };\n\nsubject.Should().BeEquivalentTo(expectation, opt => opt\n    .Using<int>(e => e.Subject.Should().Be(e.Expectation))\n    .WhenTypeIs<string>()\n);\n```\n\n----------------------------------------\n\nTITLE: Defining IMemberMatchingRule Interface\nDESCRIPTION: Defines an interface for rules that match members between expectation and subject. Used to determine which members should be compared with each other during equivalency validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMemberMatchingRule\n{\n    FluentAssertions.Equivalency.IMember Match(FluentAssertions.Equivalency.IMember expectedMember, object subject, FluentAssertions.Equivalency.INode parent, FluentAssertions.Equivalency.IEquivalencyOptions options, FluentAssertions.Execution.AssertionChain assertionChain);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining INode Interface\nDESCRIPTION: Defines an interface for nodes in an object graph during equivalency validation. Contains information about the node's type, path, depth, and parent type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\npublic interface INode\n{\n    int Depth { get; }\n    FluentAssertions.Equivalency.Pathway Expectation { get; }\n    FluentAssertions.Equivalency.GetSubjectId GetSubjectId { get; }\n    bool IsRoot { get; }\n    System.Type ParentType { get; }\n    bool RootIsCollection { get; }\n    FluentAssertions.Equivalency.Pathway Subject { get; }\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NullableDateTimeAssertions Class\nDESCRIPTION: Concrete implementation of NullableDateTimeAssertions for asserting on nullable DateTime values. It serves as a non-generic wrapper over the generic implementation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateTimeAssertions : FluentAssertions.Primitives.NullableDateTimeAssertions<FluentAssertions.Primitives.NullableDateTimeAssertions>\n{\n    public NullableDateTimeAssertions(System.DateTime? expected, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IExtractExceptions Interface for Exception Extraction in C#\nDESCRIPTION: An interface that defines the contract for extracting exceptions of specific types from an actual exception. Used by various assertion classes to filter and process exceptions for targeted assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_176\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IExtractExceptions\n{\n    System.Collections.Generic.IEnumerable<T> OfType<T>(System.Exception actualException)\n        where T : System.Exception;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Occurrence Constraint Classes\nDESCRIPTION: Static classes providing fluent interface for specifying occurrence constraints like Once, Twice, Thrice, or specific number of times.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Exactly\n{\n    public static FluentAssertions.OccurrenceConstraint Once() { }\n    public static FluentAssertions.OccurrenceConstraint Thrice() { }\n    public static FluentAssertions.OccurrenceConstraint Times(int expected) { }\n    public static FluentAssertions.OccurrenceConstraint Twice() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ComparableTypeAssertions<T> in FluentAssertions.Numeric\nDESCRIPTION: A non-generic assertion class for comparable types that inherits from the generic ComparableTypeAssertions class. Provides fluent assertion methods for types implementing IComparable<T>.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_114\n\nLANGUAGE: C#\nCODE:\n```\npublic class ComparableTypeAssertions<T> : FluentAssertions.Numeric.ComparableTypeAssertions<T, FluentAssertions.Numeric.ComparableTypeAssertions<T>>\n{\n    public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Value Formatters for Different Data Types in FluentAssertions\nDESCRIPTION: Collection of specialized formatters that implement IValueFormatter to handle different data types like exceptions, enumerables, decimals, and more. Each formatter provides type-specific string representations for assertion messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_95\n\nLANGUAGE: C#\nCODE:\n```\npublic class AggregateExceptionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public AggregateExceptionValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class AttributeBasedFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public AttributeBasedFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class ByteValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public ByteValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class DateTimeOffsetValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public DateTimeOffsetValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class DecimalValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public DecimalValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class DefaultValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public DefaultValueFormatter() { }\n    public virtual bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    protected virtual System.Reflection.MemberInfo[] GetMembers(System.Type type) { }\n    protected virtual string TypeDisplayName(System.Type type) { }\n}\npublic class DictionaryValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public DictionaryValueFormatter() { }\n    protected virtual int MaxItems { get; }\n    public virtual bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class DoubleValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public DoubleValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class EnumValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public EnumValueFormatter() { }\n    public virtual bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class EnumerableValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public EnumerableValueFormatter() { }\n    protected virtual int MaxItems { get; }\n    public virtual bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class ExceptionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public ExceptionValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class ExpressionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public ExpressionValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class GuidValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public GuidValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class Int16ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public Int16ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GlobalEquivalencyOptions Class in C#\nDESCRIPTION: Provides configuration options for equivalency comparisons used throughout the FluentAssertions library. It defines methods for cloning and modifying equivalency options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_54\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GlobalEquivalencyOptions\n{\n    public GlobalEquivalencyOptions() { }\n    public FluentAssertions.Equivalency.EquivalencyPlan Plan { get; }\n    public FluentAssertions.Equivalency.EquivalencyOptions<T> CloneDefaults<T>() { }\n    public void Modify(System.Func<FluentAssertions.Equivalency.EquivalencyOptions, FluentAssertions.Equivalency.EquivalencyOptions> configureOptions) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Classes in C#\nDESCRIPTION: Configuration classes for managing global settings, equivalency options, and formatting options in FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\npublic class GlobalConfiguration\n{\n    public GlobalConfiguration() { }\n    public FluentAssertions.Configuration.GlobalEquivalencyOptions Equivalency { get; set; }\n    public FluentAssertions.Configuration.GlobalFormattingOptions Formatting { get; set; }\n    public FluentAssertions.Configuration.TestFramework? TestFramework { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NullableGuidAssertions Class\nDESCRIPTION: Concrete implementation of NullableGuidAssertions for asserting on nullable Guid values. It inherits from the generic version to provide a simpler API for common use cases.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_151\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableGuidAssertions : FluentAssertions.Primitives.NullableGuidAssertions<FluentAssertions.Primitives.NullableGuidAssertions>\n{\n    public NullableGuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MemberVisibility Enum with Flags in C#\nDESCRIPTION: Enum with the [Flags] attribute to define different types of member visibility that can be combined. Used to specify which members should be included in equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_87\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Flags]\npublic enum MemberVisibility\n{\n    None = 0,\n    Internal = 1,\n    Public = 2,\n    ExplicitlyImplemented = 4,\n    DefaultInterfaceProperties = 8,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ConversionSelector Class in C#\nDESCRIPTION: Defines a class for selecting which object types require conversion during equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_61\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ConversionSelector\n{\n    public ConversionSelector() { }\n    public FluentAssertions.Equivalency.ConversionSelector Clone() { }\n    public void Exclude(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public void Include(System.Linq.Expressions.Expression<System.Func<FluentAssertions.Equivalency.IObjectInfo, bool>> predicate) { }\n    public void IncludeAll() { }\n    public bool RequiresConversion(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.INode currentNode) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalency Step Interface\nDESCRIPTION: Method signature for implementing custom equivalency steps in Fluent Assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nEquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IValidateChildNodeEquivalency nestedValidator);\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyStep Abstract Class\nDESCRIPTION: Provides a base class for implementing equivalency steps with generic typing. Contains the Handle method required by the IEquivalencyStep interface and a protected abstract OnHandle method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class EquivalencyStep<T> : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    protected EquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n    protected abstract FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator);\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Assertion Attributes in FluentAssertions (C#)\nDESCRIPTION: Attribute classes for marking custom assertions and custom assertion assemblies in FluentAssertions. These attributes are used to indicate methods and assemblies that extend the base assertion functionality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic class CustomAssertionAttribute : System.Attribute\n{\n    public CustomAssertionAttribute() { }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly)]\npublic sealed class CustomAssertionsAssemblyAttribute : System.Attribute\n{\n    public CustomAssertionsAssemblyAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Enumerable Custom Class Formatter\nDESCRIPTION: Implementation of a custom formatter for IEnumerable<CustomClass> that limits the number of items displayed to 5.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nclass EnumerableCustomClassFormatter : EnumerableValueFormatter\n{\n    protected override int MaxItems => 5;\n\n    public override bool CanHandle(object value) => value is IEnumerable<CustomClass>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GuidAssertions Class in FluentAssertions\nDESCRIPTION: Class definition for GuidAssertions which inherits from GuidAssertions<GuidAssertions> to provide fluent assertions for System.Guid values. This class serves as a non-generic wrapper for the generic implementation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_141\n\nLANGUAGE: C#\nCODE:\n```\npublic class GuidAssertions : FluentAssertions.Primitives.GuidAssertions<FluentAssertions.Primitives.GuidAssertions>\n{\n    public GuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: INode Interface Definition in C#\nDESCRIPTION: Represents a node in the object graph being compared, with properties for the subject and expectation pathways, depth information, and type metadata.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_81\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface INode\n{\n    int Depth { get; }\n    FluentAssertions.Equivalency.Pathway Expectation { get; }\n    FluentAssertions.Equivalency.GetSubjectId GetSubjectId { get; }\n    bool IsRoot { get; }\n    System.Type ParentType { get; }\n    bool RootIsCollection { get; }\n    FluentAssertions.Equivalency.Pathway Subject { get; }\n    System.Type Type { get; }\n    void AdjustForRemappedSubject(FluentAssertions.Equivalency.IMember subjectMember);\n}\n```\n\n----------------------------------------\n\nTITLE: SelfReferenceEquivalencyOptions Class Implementation\nDESCRIPTION: Generic class implementing equivalency options with fluent configuration methods for customizing comparison behavior. Includes methods for handling recursion, member selection, and value comparison strategies.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_78\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class SelfReferenceEquivalencyOptions<TSelf> : FluentAssertions.Equivalency.IEquivalencyOptions\n    where TSelf : FluentAssertions.Equivalency.SelfReferenceEquivalencyOptions<TSelf>\n{\n    protected SelfReferenceEquivalencyOptions(FluentAssertions.Equivalency.IEquivalencyOptions defaults) { }\n    public bool? CompareRecordsByValue { get; }\n    public FluentAssertions.Equivalency.ConversionSelector ConversionSelector { get; }\n    public bool IgnoreCase { get; }\n    // Additional members omitted for brevity\n}\n```\n\n----------------------------------------\n\nTITLE: Generic XmlNodeAssertions<TSubject, TAssertions> Class Definition\nDESCRIPTION: Generic base class for XML node assertions with type constraints. TSubject must be an XmlNode, and TAssertions must be the derived assertion class. Inherits from ReferenceTypeAssertions to provide common assertion functionality.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_175\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.Xml.XmlNode\n    where TAssertions : FluentAssertions.Xml.XmlNodeAssertions<TSubject, TAssertions>\n{\n    public XmlNodeAssertions(TSubject xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable DateOnly Assertions in C#\nDESCRIPTION: Defines the NullableDateOnlyAssertions class which extends DateOnlyAssertions to provide assertion methods for nullable DateOnly values. It includes methods to check for null and value presence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_113\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableDateOnlyAssertions<TAssertions> : FluentAssertions.Primitives.DateOnlyAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableDateOnlyAssertions<TAssertions>\n{\n    public NullableDateOnlyAssertions(System.DateOnly? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReferenceEqualityEquivalencyStep in C#\nDESCRIPTION: Class for performing reference equality checks in FluentAssertions equivalency validation. It implements the IEquivalencyStep interface to verify if two objects are the same instance.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\npublic class ReferenceEqualityEquivalencyStep : FluentAssertions.Equivalency.IEquivalencyStep\n{\n    public ReferenceEqualityEquivalencyStep() { }\n    public FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Value Type Comparison\nDESCRIPTION: Example of configuring global options for comparing specific types by value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nAssertionConfiguration.Current.Equivalency.Modify(options => options\n    .ComparingByValue<DirectoryInfo>());\n```\n\n----------------------------------------\n\nTITLE: Implementing MemberFactory Static Class in C#\nDESCRIPTION: Static utility class for creating IMember instances from reflection MemberInfo objects. The factory method attaches the member to a parent node in the object graph.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_85\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class MemberFactory\n{\n    public static FluentAssertions.Equivalency.IMember Create(System.Reflection.MemberInfo memberInfo, FluentAssertions.Equivalency.INode parent) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MemberSelectionContext for Equivalency Comparison in C#\nDESCRIPTION: Class that provides context for member selection during equivalency comparison, containing information about which members should be included based on visibility.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\npublic class MemberSelectionContext\n{\n    public MemberSelectionContext(System.Type compileTimeType, System.Type runtimeType, FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public FluentAssertions.Equivalency.MemberVisibility IncludedFields { get; }\n    public FluentAssertions.Equivalency.MemberVisibility IncludedProperties { get; }\n    public System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Exception Assertion Extensions in C#\nDESCRIPTION: Extension methods for asserting on exceptions. These methods enable detailed assertions on exception properties, messages, inner exceptions, and parameter names for argument exceptions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ExceptionAssertionsExtensions\n{\n    public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> Where<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Linq.Expressions.Expression<System.Func<TException, bool>> exceptionExpression, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerException<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerException<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception\n        where TInnerException : System.Exception { }\n    public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<System.Exception>> WithInnerExceptionExactly<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, System.Type innerException, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TInnerException>> WithInnerExceptionExactly<TException, TInnerException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception\n        where TInnerException : System.Exception { }\n    public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithMessage<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string expectedWildcardPattern, string because = \"\", params object[] becauseArgs)\n        where TException : System.Exception { }\n    public static FluentAssertions.Specialized.ExceptionAssertions<TException> WithParameterName<TException>(this FluentAssertions.Specialized.ExceptionAssertions<TException> parent, string paramName, string because = \"\", params object[] becauseArgs)\n        where TException : System.ArgumentException { }\n    public static System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> WithParameterName<TException>(this System.Threading.Tasks.Task<FluentAssertions.Specialized.ExceptionAssertions<TException>> task, string paramName, string because = \"\", params object[] becauseArgs)\n        where TException : System.ArgumentException { }\n}\n```\n\n----------------------------------------\n\nTITLE: XmlElementAssertions Class Definition and Constructor\nDESCRIPTION: Declaration of the XmlElementAssertions class that inherits from XmlNodeAssertions. Includes the constructor that takes an XmlElement instance and an assertion chain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_170\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlElementAssertions : FluentAssertions.Xml.XmlNodeAssertions<System.Xml.XmlElement, FluentAssertions.Xml.XmlElementAssertions>\n{\n    public XmlElementAssertions(System.Xml.XmlElement xmlElement, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n```\n\n----------------------------------------\n\nTITLE: Implementing CallerIdentifier Utility in C#\nDESCRIPTION: A utility class for determining caller identities in test code. It provides methods to identify the caller and a configurable logger for recording identification information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic static class CallerIdentifier\n{\n    public static System.Action<string> Logger { get; set; }\n    public static string[] DetermineCallerIdentities() { }\n    public static string DetermineCallerIdentity() { }\n}\n```\n\n----------------------------------------\n\nTITLE: IObjectInfo Interface Definition in C#\nDESCRIPTION: Provides information about an object being compared, including its compile-time and runtime types, parent type, and path within the object graph.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_82\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IObjectInfo\n{\n    System.Type CompileTimeType { get; }\n    System.Type ParentType { get; }\n    string Path { get; set; }\n    System.Type RuntimeType { get; }\n    [System.Obsolete(\"Use CompileTimeType or RuntimeType instead\")]\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NotHaveElementWithValue Method for XElement Assertions\nDESCRIPTION: Method signature for asserting that an XElement does not have a child element with a specific value. It returns an AndConstraint to support fluent chaining of assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_169\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<FluentAssertions.Xml.XElementAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: XML Assertions with XName Parameters in C#\nDESCRIPTION: Shows how to use XName objects for XML assertions, allowing for namespace-qualified element and attribute assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/xml.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nxElement.Should().HaveAttribute(XName.Get(\"age\", \"http://www.example.com/2012/test\"), \"36\");\nxElement.Should().HaveElement(XName.Get(\"address\", \"http://www.example.com/2012/test\"));\n\nxAttribute.Should().HaveValue(\"Amsterdam\");\n```\n\n----------------------------------------\n\nTITLE: Defining IEquivalencyStep Interface in C#\nDESCRIPTION: Interface for implementing a step in the equivalency validation process, providing a method to handle the comparison of two objects according to specific validation logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_48\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEquivalencyStep\n{\n    FluentAssertions.Equivalency.EquivalencyResult Handle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency valueChildNodes);\n}\n```\n\n----------------------------------------\n\nTITLE: CallerIdentifier Utility for FluentAssertions (C#)\nDESCRIPTION: A static class providing methods to determine and log caller identities for diagnostics and reporting purposes. Includes logger configuration and methods to retrieve caller identity information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class CallerIdentifier\n{\n    public static System.Action<string> Logger { get; set; }\n    public static string[] DetermineCallerIdentities() { }\n    public static string DetermineCallerIdentity() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Member Factory for Creating Member Instances in C#\nDESCRIPTION: Static factory class that creates member instances for reflection-based member information within the equivalency comparison framework.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\npublic static class MemberFactory\n{\n    public static FluentAssertions.Equivalency.IMember Create(System.Reflection.MemberInfo memberInfo, FluentAssertions.Equivalency.INode parent) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IValueFormatter for Various Types in C#\nDESCRIPTION: This snippet shows the structure of several classes implementing the IValueFormatter interface for different data types such as SingleValue, String, Task, TimeSpan, and various integer types. Each class includes methods for handling and formatting specific value types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_130\n\nLANGUAGE: C#\nCODE:\n```\npublic class SingleValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public SingleValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeExtensions Class in C#\nDESCRIPTION: Provides extension methods for converting DateTime objects to DateTimeOffset objects, supporting time zone offset handling.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_51\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class DateTimeExtensions\n{\n    public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime) { }\n    public static System.DateTimeOffset ToDateTimeOffset(this System.DateTime dateTime, System.TimeSpan offset) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tracing Infrastructure for Equivalency Debugging in C#\nDESCRIPTION: Defines interfaces and classes for tracing the execution of equivalency comparisons. Provides a way to generate detailed logs of comparison operations for debugging and diagnostics.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate string GetTraceMessage(FluentAssertions.Equivalency.INode node);\npublic interface ITraceWriter\n{\n    System.IDisposable AddBlock(string trace);\n    void AddSingle(string trace);\n    string ToString();\n}\npublic class StringBuilderTraceWriter : FluentAssertions.Equivalency.Tracing.ITraceWriter\n{\n    public StringBuilderTraceWriter() { }\n    public System.IDisposable AddBlock(string trace) { }\n    public void AddSingle(string trace) { }\n    public override string ToString() { }\n}\npublic class Tracer\n{\n    public override string ToString() { }\n    public System.IDisposable WriteBlock(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }\n    public void WriteLine(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalency Result Enumeration in C#\nDESCRIPTION: Enumeration defining possible results from an equivalency step, indicating whether validation should continue with the next step or if equivalency is proven and validation can stop.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic enum EquivalencyResult\n{\n    ContinueWithNext = 0,\n    EquivalencyProven = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableTimeOnlyAssertions in C#\nDESCRIPTION: Concrete implementation of assertions for nullable TimeOnly values. Inherits from NullableTimeOnlyAssertions<T> and provides a constructor for initializing with a nullable TimeOnly value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_118\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableTimeOnlyAssertions : FluentAssertions.Primitives.NullableTimeOnlyAssertions<FluentAssertions.Primitives.NullableTimeOnlyAssertions>\n{\n    public NullableTimeOnlyAssertions(System.TimeOnly? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: xUnit Custom Test Framework Configuration\nDESCRIPTION: Implementation of custom xUnit test framework for configuring Fluent Assertions, including the framework class and assembly attribute.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace MyNamespace\n{\n    using Xunit.Abstractions;\n    using Xunit.Sdk;\n\n    public class MyFramework: XunitTestFramework\n    {\n        public MyFramework(IMessageSink messageSink)\n            : base(messageSink)\n        {\n            AssertionConfiguration.Current.Equivalency.Modify(\n                options => { <configure here> });\n        }\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: Xunit.TestFramework(\"MyNamespace.MyFramework\", \"MyAssembly.Facts\")]\n```\n\n----------------------------------------\n\nTITLE: Excluding Properties from Nested Collections\nDESCRIPTION: Shows how to exclude properties from deeply nested collections using multiple For() method calls to navigate the object hierarchy.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options =>\n    options.For(o => o.Products)\n           .For(o => o.Parts)\n           .Exclude(o => o.Name));\n```\n\n----------------------------------------\n\nTITLE: Implementing SubjectInfoExtensions Static Class in C#\nDESCRIPTION: Static extension methods for the IMemberInfo interface to check for getter and setter access modifiers. Provides methods to check if getters and setters have or don't have specific access modifiers.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_93\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class SubjectInfoExtensions\n{\n    public static bool WhichGetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichGetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichSetterDoesNotHave(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n    public static bool WhichSetterHas(this FluentAssertions.Equivalency.IMemberInfo memberInfo, FluentAssertions.Common.CSharpAccessModifier accessModifier) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableGuidAssertions<TAssertions> Class\nDESCRIPTION: Generic implementation of assertions for nullable Guid values, extending GuidAssertions<TAssertions>. It adds methods specific to nullable Guid types like Be with nullable parameters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_152\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableGuidAssertions<TAssertions> : FluentAssertions.Primitives.GuidAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableGuidAssertions<TAssertions>\n{\n    public NullableGuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid? expected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XML Node Formatter in C#\nDESCRIPTION: The XmlNodeFormatter class implements the IValueFormatter interface to provide custom formatting for XML nodes. It includes methods to determine if it can handle a value and to format the value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_165\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XmlNodeFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IValueFormatter for Reflection and Special Types in C#\nDESCRIPTION: Formatter classes for handling reflection objects and special types in FluentAssertions. These implementations of IValueFormatter can format values like PropertyInfo, MethodInfo, MultidimensionalArray, and Task for display in assertion messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_101\n\nLANGUAGE: C#\nCODE:\n```\npublic class MethodInfoFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public MethodInfoFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class MultidimensionalArrayFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public MultidimensionalArrayFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class NullValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public NullValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class PredicateLambdaExpressionValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public PredicateLambdaExpressionValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class PropertyInfoFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public PropertyInfoFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class TaskFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public TaskFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Obsolete Should Methods for AndConstraint in C#\nDESCRIPTION: Defines obsolete Should methods for various assertion types. These methods are marked as obsolete to prevent asserting on the AndConstraint itself, guiding users to remove the Should() method directly following 'And'.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.BooleanAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions> { }\n// ... (similar methods for other assertion types)\n```\n\n----------------------------------------\n\nTITLE: Implementing XML Element Equivalency Steps in FluentAssertions\nDESCRIPTION: Specialized steps for XML element comparison in FluentAssertions, covering XElement, XDocument, and XAttribute types. These steps handle XML-specific equality comparison logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\npublic class XAttributeEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XAttribute>\n{\n    public XAttributeEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class XDocumentEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XDocument>\n{\n    public XDocumentEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class XElementEquivalencyStep : FluentAssertions.Equivalency.EquivalencyStep<System.Xml.Linq.XElement>\n{\n    public XElementEquivalencyStep() { }\n    protected override FluentAssertions.Equivalency.EquivalencyResult OnHandle(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context, FluentAssertions.Equivalency.IValidateChildNodeEquivalency nestedValidator) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GetSubjectId Delegate\nDESCRIPTION: Defines a delegate for obtaining a string identifier for a subject. Used in equivalency validation to generate descriptive identifiers for subject objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate string GetSubjectId();\n```\n\n----------------------------------------\n\nTITLE: Implementing Reason Class in C#\nDESCRIPTION: Defines the Reason class which stores formatted messages and their arguments for assertion failures. It provides properties to access both the message and arguments.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_118\n\nLANGUAGE: C#\nCODE:\n```\npublic class Reason\n{\n    public Reason(string formattedMessage, object[] arguments) { }\n    public object[] Arguments { get; set; }\n    public string FormattedMessage { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IObjectInfo Interface for FluentAssertions in C#\nDESCRIPTION: This interface defines properties for object information used in equivalency comparisons, including compile-time and runtime types, parent type, and path.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IObjectInfo\n{\n    System.Type CompileTimeType { get; }\n    System.Type ParentType { get; }\n    string Path { get; set; }\n    System.Type RuntimeType { get; }\n    [System.Obsolete(\"Use CompileTimeType or RuntimeType instead\")]\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalency Enums for Comparison Options in C#\nDESCRIPTION: Defines several enumerations that control equivalency comparison behavior including handling of cyclic references, enum comparisons, and overall equality strategy.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_59\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum CyclicReferenceHandling\n{\n    Ignore = 0,\n    ThrowException = 1,\n}\npublic enum EnumEquivalencyHandling\n{\n    ByValue = 0,\n    ByName = 1,\n}\npublic enum EqualityStrategy\n{\n    Equals = 0,\n    Members = 1,\n    ForceEquals = 2,\n    ForceMembers = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: IMember Interface Definition in C#\nDESCRIPTION: Extends INode to represent a member (property or field) of an object, with methods to access its value and metadata about accessibility and type information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_77\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMember : FluentAssertions.Equivalency.INode\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    bool IsBrowsable { get; }\n    System.Type ReflectedType { get; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    object GetValue(object obj);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XmlReaderValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of XmlReader objects in assertion results, converting the XML reader content to a readable format.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_113\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlReaderValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XmlReaderValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IMemberInfo Interface Stub in C#\nDESCRIPTION: Partial interface definition for IMemberInfo, which likely extends functionality for accessing member information in equivalency validation.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_51\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMemberInfo\n```\n\n----------------------------------------\n\nTITLE: Formatting Delegate Definition in FluentAssertions\nDESCRIPTION: The FormatChild delegate is used to format child objects within a complex object structure, allowing for recursive formatting of nested objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_125\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate void FormatChild(string childPath, object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph);\n```\n\n----------------------------------------\n\nTITLE: Defining OrderStrictness Enum for FluentAssertions in C#\nDESCRIPTION: This enum defines the levels of ordering strictness used in equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\npublic enum OrderStrictness\n{\n    Strict = 0,\n    NotStrict = 1,\n    Irrelevant = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NullableSimpleTimeSpanAssertions Generic Class in C#\nDESCRIPTION: Abstract class for assertions on nullable TimeSpan types. Inherits from SimpleTimeSpanAssertions<T> and adds methods for asserting nullability and value existence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_117\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableSimpleTimeSpanAssertions<TAssertions> : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions<TAssertions>\n{\n    public NullableSimpleTimeSpanAssertions(System.TimeSpan? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.TimeSpan? expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Formatters in Nested AssertionScopes\nDESCRIPTION: Demonstrates how modifications to formatters in nested scopes don't affect the parent scope, providing isolation between different assertion contexts.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nusing var outerScope = new AssertionScope();\n\nvar outerFormatter = new OuterFormatter();\nvar innerFormatter = new InnerFormatter();\nouterScope.FormattingOptions.AddFormatter(outerFormatter);\n\nusing (var innerScope = new AssertionScope())\n{\n  innerScope.FormattingOptions.AddFormatter(innerFormatter);\n  innerScope.FormattingOptions.RemoveFormatter(outerFormatter);\n\n  // innerScope only contains innerFormatter\n}\n\n// outerScope still contains outerFormatter\n```\n\n----------------------------------------\n\nTITLE: Disabling Recursion in Object Graph Comparison\nDESCRIPTION: Demonstrates how to exclude nested objects from comparison by disabling recursion, which prevents the comparison from traversing into child objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options => \n    options.ExcludingNestedObjects());\n```\n\n----------------------------------------\n\nTITLE: Defining IMember Interface\nDESCRIPTION: Defines an interface for members (properties/fields) in an object graph. Extends INode and provides access to the member's declaring type, accessibility, and value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMember : FluentAssertions.Equivalency.INode\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    bool IsBrowsable { get; }\n    System.Type ReflectedType { get; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    object GetValue(object obj);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Member Info Assertions in C#\nDESCRIPTION: Abstract base class for member info assertions, providing common functionality for attribute decoration checks.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_183\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class MemberInfoAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.Reflection.MemberInfo\n    where TAssertions : FluentAssertions.Types.MemberInfoAssertions<TSubject, TAssertions>\n{\n    protected MemberInfoAssertions(TSubject subject, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Int64ValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of Int64/long values in assertion results. It provides methods to check if it can handle a value type and to format the value accordingly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_94\n\nLANGUAGE: C#\nCODE:\n```\npublic class Int64ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public Int64ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TaskFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of Task objects in assertion results, likely displaying their status and result if completed.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_104\n\nLANGUAGE: C#\nCODE:\n```\npublic class TaskFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public TaskFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Validation Context with EquivalencyValidationContext Class in C#\nDESCRIPTION: Implements context for equivalency validation, tracking current node, options, and tracing information. Provides methods for context manipulation when validating nested objects and collections.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic class EquivalencyValidationContext : FluentAssertions.Equivalency.IEquivalencyValidationContext\n{\n    public EquivalencyValidationContext(FluentAssertions.Equivalency.INode root, FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public FluentAssertions.Equivalency.INode CurrentNode { get; }\n    public FluentAssertions.Equivalency.IEquivalencyOptions Options { get; }\n    public FluentAssertions.Execution.Reason Reason { get; set; }\n    public FluentAssertions.Equivalency.Tracing.ITraceWriter TraceWriter { get; set; }\n    public FluentAssertions.Equivalency.Tracing.Tracer Tracer { get; }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsCollectionItem<TItem>(string index) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsDictionaryItem<TKey, TExpectation>(TKey key) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext AsNestedMember(FluentAssertions.Equivalency.IMember expectationMember) { }\n    public FluentAssertions.Equivalency.IEquivalencyValidationContext Clone() { }\n    public bool IsCyclicReference(object expectation) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Specific Attribute Property Values in FluentAssertions\nDESCRIPTION: This example demonstrates how to check that an attribute has specific property values using a predicate expression.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/typesandmethods.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ntypeWithAttribute.Should()\n  .BeDecoratedWith<DummyClassAttribute>(a => ((a.Name == \"Unexpected\") && a.IsEnabled));\n```\n\n----------------------------------------\n\nTITLE: License Management for FluentAssertions (C#)\nDESCRIPTION: A static class that manages license acceptance status for the FluentAssertions library. This simple utility class allows setting and checking license acceptance state.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class License\n{\n    public static bool Accepted { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IOrderingRule Interface for FluentAssertions in C#\nDESCRIPTION: This interface defines a method for evaluating the ordering strictness of an object during equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IOrderingRule\n{\n    FluentAssertions.Equivalency.OrderStrictness Evaluate(FluentAssertions.Equivalency.IObjectInfo objectInfo);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EnumEquivalencyHandling Enum in C#\nDESCRIPTION: Defines an enumeration for specifying how enum values should be compared during equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_63\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum EnumEquivalencyHandling\n{\n    ByValue = 0,\n    ByName = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfoFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of PropertyInfo objects in assertion results. It provides human-readable representations of property definitions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_100\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public PropertyInfoFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IValueFormatter for String and XML-Related Types in C#\nDESCRIPTION: Formatter classes for handling string values and XML-related types in FluentAssertions. These classes implement the IValueFormatter interface to format values like strings, XElement, XDocument, and XmlReader for assertion messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_100\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public StringValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class XAttributeValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XAttributeValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class XDocumentValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XDocumentValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class XElementValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XElementValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\npublic class XmlReaderValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XmlReaderValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EquivalencyResult Enumeration\nDESCRIPTION: Defines the possible outcomes of an equivalency step. Values indicate whether the equivalency has been proven or if the validation should continue with the next step.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\npublic enum EquivalencyResult\n{\n    ContinueWithNext = 0,\n    EquivalencyProven = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Value Formatter Implementations\nDESCRIPTION: Collection of IValueFormatter implementations for formatting different value types including primitives, enums, collections, and complex objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_91\n\nLANGUAGE: C#\nCODE:\n```\npublic class DefaultValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public DefaultValueFormatter() { }\n    public virtual bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n    protected virtual System.Reflection.MemberInfo[] GetMembers(System.Type type) { }\n    protected virtual string TypeDisplayName(System.Type type) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining License Management in C#\nDESCRIPTION: A static utility class for managing license acceptance for the FluentAssertions library.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic static class License\n{\n    public static bool Accepted { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TaskCompletionSourceAssertionsBase Class in C#\nDESCRIPTION: Base class for assertions on TaskCompletionSource objects. Provides common functionality for testing async code completion through TaskCompletionSource implementations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_145\n\nLANGUAGE: C#\nCODE:\n```\npublic class TaskCompletionSourceAssertionsBase\n    {\n        protected TaskCompletionSourceAssertionsBase(FluentAssertions.Common.IClock clock) { }\n        public override bool Equals(object obj) { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Using Tracing for Diagnostic Output in FluentAssertions using C#\nDESCRIPTION: Example showing how to capture diagnostic tracing information for successful assertions. Useful for understanding how FluentAssertions compared two object graphs.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\nobject object1 = [...];\nobject object2 = [...];\nvar traceWriter = new StringBuilderTraceWriter();            \nobject1.Should().BeEquivalentTo(object2, opts => opts.WithTracing(traceWriter));             \nstring trace = traceWriter.ToString();\n```\n\n----------------------------------------\n\nTITLE: Excluding Non-Browsable Members in FluentAssertions using C#\nDESCRIPTION: Example showing how to exclude hidden members (marked with EditorBrowsable attribute) when comparing objects. Useful for types with contract-required members that aren't logically part of the type.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nclass DataType\n{\n    public int X { get; }\n\n    [EditorBrowsable(EditorBrowsableState.Never)]\n    public int Y => throw new NotImplementedException();\n}\n\nDataType original, derived;\n\nderived.Should().BeEquivalentTo(original, options => options\n    .ExcludingNonBrowsableMembers());\n```\n\n----------------------------------------\n\nTITLE: Using WithOffset Extension Method for DateTime in C#\nDESCRIPTION: Demonstrates the new WithOffset extension method for DateTime to easily create DateTimeOffset objects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/releases.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nDateTime date = DateTime.Now;\nDateTimeOffset dateOffset = date.WithOffset(TimeSpan.FromHours(2));\n```\n\n----------------------------------------\n\nTITLE: Implementing Tracing Support for Equivalency Assertions in FluentAssertions\nDESCRIPTION: Classes for tracing the equivalency comparison process, providing detailed logs of comparison steps. Includes interfaces and implementations for writing trace messages during assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_83\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate string GetTraceMessage(FluentAssertions.Equivalency.INode node);\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITraceWriter\n{\n    System.IDisposable AddBlock(string trace);\n    void AddSingle(string trace);\n    string ToString();\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringBuilderTraceWriter : FluentAssertions.Equivalency.Tracing.ITraceWriter\n{\n    public StringBuilderTraceWriter() { }\n    public System.IDisposable AddBlock(string trace) { }\n    public void AddSingle(string trace) { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class Tracer\n{\n    public override string ToString() { }\n    public System.IDisposable WriteBlock(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }\n    public void WriteLine(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DateTimeOffsetRangeAssertions Class in C#\nDESCRIPTION: Class for asserting DateTimeOffset range conditions. Provides methods to check if a DateTimeOffset value is before or after a target value within a specified time range. Uses generic constraints to support method chaining in assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_108\n\nLANGUAGE: csharp\nCODE:\n```\npublic class DateTimeOffsetRangeAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions>\n{\n    protected DateTimeOffsetRangeAssertions(TAssertions parentAssertions, FluentAssertions.Execution.AssertionChain assertionChain, System.DateTimeOffset? subject, FluentAssertions.Primitives.TimeSpanCondition condition, System.TimeSpan timeSpan) { }\n    public FluentAssertions.AndConstraint<TAssertions> After(System.DateTimeOffset target, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> Before(System.DateTimeOffset target, string because = \"\", params object[] becauseArgs) { }\n    public override bool Equals(object obj) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeSpanValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of TimeSpan values in assertion results, providing a readable representation of time durations.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_105\n\nLANGUAGE: C#\nCODE:\n```\npublic class TimeSpanValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public TimeSpanValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing License Property in C#\nDESCRIPTION: A static class for license acceptance status in the FluentAssertions framework. This allows tracking whether the license has been accepted by the user.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\npublic static class License\n{\n    public static bool Accepted { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Event Metadata Class in C#\nDESCRIPTION: Implements the EventMetadata class that stores information about an event including its name and handler type. This provides metadata context for event monitoring and assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\npublic class EventMetadata\n    {\n        public EventMetadata(string eventName, System.Type handlerType) { }\n        public string EventName { get; }\n        public System.Type HandlerType { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Including Assertion Comparison Template\nDESCRIPTION: Jekyll template inclusion for displaying assertion comparisons across different data types and scenarios. Used to render comparison tables for various assertion types.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/tips.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"Collections\"               examples=site.data.tips.collections %}\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"Comparable and Numerics\"   examples=site.data.tips.comparable %}\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"DateTimes\"                 examples=site.data.tips.datetimes %}\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"Dictionaries\"              examples=site.data.tips.dictionaries %}\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"Exceptions\"                examples=site.data.tips.exceptions %}\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"Nullables\"                 examples=site.data.tips.nullables %}\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"Strings\"                   examples=site.data.tips.strings %}\n{% include assertion-comparison.html header1=\"Assertion\" header2=\"Improvement\" caption=\"Types\"                     examples=site.data.tips.types %}\n```\n\n----------------------------------------\n\nTITLE: Defining ValueFormatterDetectionMode Enum in C#\nDESCRIPTION: Defines an enumeration of detection modes for value formatters. These values control how custom value formatters are detected and loaded by the assertion framework.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_52\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum ValueFormatterDetectionMode\n{\n    Disabled = 0,\n    Specific = 1,\n    Scan = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IValidateChildNodeEquivalency Interface for FluentAssertions in C#\nDESCRIPTION: This interface defines a method for asserting the equivalency of child nodes during object comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IValidateChildNodeEquivalency\n{\n    void AssertEquivalencyOf(FluentAssertions.Equivalency.Comparands comparands, FluentAssertions.Equivalency.IEquivalencyValidationContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: C# Property Info Selector Class\nDESCRIPTION: Class for selecting and filtering property information using reflection. Provides methods for filtering properties by type, abstract/virtual status, and attribute decoration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_161\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>, System.Collections.IEnumerable {\n    public PropertyInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public PropertyInfoSelector(System.Type type) { }\n    // ... selector properties and methods\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Scoped Formatters\nDESCRIPTION: Example of working with formatters in nested assertion scopes, showing formatter inheritance.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nusing var outerScope = new AssertionScope();\n\nvar outerFormatter = new OuterFormatter();\nvar innerFormatter = new InnerFormatter();\nouterScope.FormattingOptions.AddFormatter(outerFormatter);\n\nusing var innerScope = new AssertionScope();\ninnerScope.FormattingOptions.AddFormatter(innerFormatter);\n```\n\n----------------------------------------\n\nTITLE: IValueFormatter Interface Definition in C#\nDESCRIPTION: Core interface that defines the contract for value formatters in FluentAssertions. Includes methods for checking if a formatter can handle a value type and formatting the value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_90\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IValueFormatter\n{\n    bool CanHandle(object value);\n    void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Comparands Class in C#\nDESCRIPTION: Defines a class for holding the subject and expected values during equivalency comparisons, along with type information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_60\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Comparands\n{\n    public Comparands() { }\n    public Comparands(object subject, object expectation, System.Type compileTimeType) { }\n    public System.Type CompileTimeType { get; set; }\n    public object Expectation { get; set; }\n    public System.Type RuntimeType { get; }\n    public object Subject { get; set; }\n    public System.Type GetExpectedType(FluentAssertions.Equivalency.IEquivalencyOptions options) { }\n    public override string ToString() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Int32ValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of Int32 values in assertion results. It provides methods to check if it can handle a value type and to format the value accordingly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_93\n\nLANGUAGE: C#\nCODE:\n```\npublic class Int32ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public Int32ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestFramework Enum in C#\nDESCRIPTION: Defines an enumeration of supported test frameworks that can be integrated with FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_59\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum TestFramework\n{\n    XUnit2 = 0,\n    XUnit3 = 1,\n    TUnit = 2,\n    MsTest = 3,\n    NUnit = 4,\n    MSpec = 5,\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Assertions in F# with FluentAssertions\nDESCRIPTION: Shows how to work with dictionary assertions in F# when overload resolution fails, requiring direct construction of assertion objects instead of using the fluent interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/fsharp.md#2025-04-23_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nlet x = dict [\"A\", 1; \"B\", 2]\n\n// All of these give overload resolution errors for \"Should\"\nx.Should().ContainKey(1, \"\")\n(x :> IDictionary<_,_>).Should().ContainKey(1, \"\") \n(x :> seq<KeyValuePair<_,_>>).Should().Contain(KeyValuePair(\"A\", 1), \"\")\n\n// You have to construct the desired assertion directly\nGenericDictionaryAssertions<_, _, _>(x).ContainKey(\"A\", \"\")\nGenericCollectionAssertions<_, _, _>(x).Contain(KeyValuePair(\"A\", 1), \"\")\n```\n\n----------------------------------------\n\nTITLE: Collection Comparison with Property Exclusion in FluentAssertions using C#\nDESCRIPTION: Example showing how to compare collections while excluding specific nested properties. This allows for flexible comparison of collections with complex object elements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\norderDtos.Should().BeEquivalentTo(orders, options => options.Excluding(o => o.Customer.Name));\n```\n\n----------------------------------------\n\nTITLE: Wildcard Pattern Matching in C#\nDESCRIPTION: Shows how to use wildcard patterns for string matching assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nemailAddress.Should().Match(\"*@*.com\");\nhomeAddress.Should().NotMatch(\"*@*.com\");\n\nemailAddress.Should().MatchEquivalentOf(\"*@*.COM\");\nemailAddress.Should().NotMatchEquivalentOf(\"*@*.COM\");\n```\n\n----------------------------------------\n\nTITLE: Defining Event Recording Interface in C#\nDESCRIPTION: Declares the IEventRecording interface that represents recorded event information. It extends IEnumerable to allow iterating through occurred events and provides properties to access event metadata.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IEventRecording : System.Collections.Generic.IEnumerable<FluentAssertions.Events.OccurredEvent>, System.Collections.IEnumerable\n    {\n        System.Type EventHandlerType { get; }\n        string EventName { get; }\n        object EventObject { get; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableNumericAssertions Class in C#\nDESCRIPTION: Defines a NullableNumericAssertions class for nullable numeric types that extends NullableNumericAssertions<T, TAssertions>. It's constrained to work with value types that implement IComparable<T>.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_95\n\nLANGUAGE: csharp\nCODE:\n```\npublic class NullableNumericAssertions<T> : FluentAssertions.Numeric.NullableNumericAssertions<T, FluentAssertions.Numeric.NullableNumericAssertions<T>>\n    where T :  struct, System.IComparable<T>\n{\n    public NullableNumericAssertions(T? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Changes Documentation in Markdown\nDESCRIPTION: Detailed documentation of breaking changes in FluentAssertions library, including platform support changes, API modifications, and behavioral changes\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/releases.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n### Breaking Changes\n\n* Dropped support for .NET Framework 4.5, .NET Standard 1.3 and 1.6 - [#1227](https://github.com/fluentassertions/fluentassertions/pull/1227).\n* Dropped support for older test frameworks such as MSTest v1, NSpec v1 and v2, XUnit v1, Gallio and MBUnit - [#1227](https://github.com/fluentassertions/fluentassertions/pull/1227).\n* Removed `[Not]Have{Im,Ex}plictConversionOperator` (they had typos) - [#1221](https://github.com/fluentassertions/fluentassertions/pull/1221).\n  * Use the equivalent assertions without the typo \"plict\" instead.\n* Removed `NotBeAscendingInOrder`/`NotBeDescendingInOrder` - [#1221](https://github.com/fluentassertions/fluentassertions/pull/1221).\n  * Use `NotBeInAscendingOrder`/`NotBeInDescendingOrder` instead.\n```\n\n----------------------------------------\n\nTITLE: Defining IAssertionContext<TSubject> Interface in C#\nDESCRIPTION: Interface representing the context of an assertion, providing access to the subject and expectation being compared, along with additional context such as reason for the assertion.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IAssertionContext<TSubject>\n{\n    string Because { get; set; }\n    object[] BecauseArgs { get; set; }\n    TSubject Expectation { get; }\n    FluentAssertions.Equivalency.INode SelectedNode { get; }\n    TSubject Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Guid Assertions Class Implementation in C#\nDESCRIPTION: Implements assertion methods for GUID validation including equality checks and empty GUID verification.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_123\n\nLANGUAGE: C#\nCODE:\n```\npublic class GuidAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.GuidAssertions<TAssertions>\n{\n    public GuidAssertions(System.Guid? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public System.Guid? Subject { get; }\n    public FluentAssertions.AndConstraint<TAssertions> Be(System.Guid expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeEmpty(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: ValueFormatter Attribute Definition in C#\nDESCRIPTION: Custom attribute for marking formatter methods. Can only be applied to methods as specified by the AttributeUsage attribute.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_92\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic class ValueFormatterAttribute : System.Attribute\n{\n    public ValueFormatterAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ValueFormatterDetectionMode Enum in C#\nDESCRIPTION: Defines an enumeration for configuring how value formatters are detected and loaded in the assertion framework.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_55\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum ValueFormatterDetectionMode\n{\n    Disabled = 0,\n    Specific = 1,\n    Scan = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Format Method for Value Formatter\nDESCRIPTION: Method signature for implementing custom value formatting in Fluent Assertions, showing the core formatting interface that needs to be implemented.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);\n```\n\n----------------------------------------\n\nTITLE: XmlNodeFormatter Class Implementation in C#\nDESCRIPTION: Formatter class implementing IValueFormatter interface for XML node formatting. Provides custom formatting for XML nodes in assertion messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_195\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XmlNodeFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CSharpAccessModifier Enum in C#\nDESCRIPTION: Defines an enumeration of access modifiers available in C#, used for reflection and type analysis.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_50\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum CSharpAccessModifier\n{\n    Public = 0,\n    Private = 1,\n    Protected = 2,\n    Internal = 3,\n    ProtectedInternal = 4,\n    InvalidForCSharp = 5,\n    PrivateProtected = 6,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ITestFramework Interface\nDESCRIPTION: Interface for test framework integration. Provides methods for checking framework availability and throwing exceptions in a way that's compatible with the test framework.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_87\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITestFramework\n{\n    bool IsAvailable { get; }\n    [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n    void Throw(string message);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XDocumentValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of XDocument objects from System.Xml.Linq in assertion results, displaying XML documents in a readable format.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_111\n\nLANGUAGE: C#\nCODE:\n```\npublic class XDocumentValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XDocumentValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Excluding Multiple Properties from Collection Elements\nDESCRIPTION: Shows how to exclude multiple properties from all elements in a collection using anonymous object syntax after a For() call.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/objectgraphs.md#2025-04-23_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\norderDto.Should().BeEquivalentTo(order, options =>\n    options.For(o => o.Products)\n           .Exclude(o => new { o.Name, o.Price }));\n```\n\n----------------------------------------\n\nTITLE: Defining CyclicReferenceHandling Enum in C#\nDESCRIPTION: Defines an enumeration for handling cyclic references during object graph traversal in equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_62\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum CyclicReferenceHandling\n{\n    Ignore = 0,\n    ThrowException = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Assertion Chain Class in FluentAssertions.Execution Namespace\nDESCRIPTION: Defines the AssertionChain class that manages a sequence of related assertions. It provides methods for condition checking, failure handling, and customizing assertion messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class AssertionChain\n    {\n        public string CallerIdentifier { get; }\n        public bool HasOverriddenCallerIdentifier { get; }\n        public bool Succeeded { get; }\n        public FluentAssertions.Execution.AssertionChain UsingLineBreaks { get; }\n        public void AddReportable(string key, System.Func<string> getValue) { }\n        public void AddReportable(string key, string value) { }\n        public FluentAssertions.Execution.AssertionChain BecauseOf(FluentAssertions.Execution.Reason reason) { }\n        public FluentAssertions.Execution.AssertionChain BecauseOf(string because, params object[] becauseArgs) { }\n        public FluentAssertions.Execution.Continuation FailWith(System.Func<FluentAssertions.Execution.FailReason> getFailureReason) { }\n        public FluentAssertions.Execution.Continuation FailWith(string message) { }\n        public FluentAssertions.Execution.Continuation FailWith(string message, params System.Func<object>[] argProviders) { }\n        public FluentAssertions.Execution.Continuation FailWith(string message, params object[] args) { }\n        public FluentAssertions.Execution.AssertionChain ForCondition(bool condition) { }\n        public FluentAssertions.Execution.AssertionChain ForConstraint(FluentAssertions.OccurrenceConstraint constraint, int actualOccurrences) { }\n        public FluentAssertions.Execution.GivenSelector<T> Given<T>(System.Func<T> selector) { }\n        public void OverrideCallerIdentifier(System.Func<string> getCallerIdentifier) { }\n        public void ReuseOnce() { }\n        public FluentAssertions.Execution.AssertionChain WithCallerPostfix(string postfix) { }\n        public FluentAssertions.Execution.AssertionChain WithDefaultIdentifier(string identifier) { }\n        public FluentAssertions.Execution.Continuation WithExpectation(string message, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n        public FluentAssertions.Execution.Continuation WithExpectation(string message, object arg1, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n        public FluentAssertions.Execution.Continuation WithExpectation(string message, object arg1, object arg2, System.Action<FluentAssertions.Execution.AssertionChain> chain) { }\n        public FluentAssertions.Execution.AssertionChain WithReportable(string name, System.Func<string> content) { }\n        public static FluentAssertions.Execution.AssertionChain GetOrCreate() { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining MemberVisibility Enum for FluentAssertions in C#\nDESCRIPTION: This enum defines flags for member visibility options used in equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\n[System.Flags]\npublic enum MemberVisibility\n{\n    None = 0,\n    Internal = 1,\n    Public = 2,\n    ExplicitlyImplemented = 4,\n    DefaultInterfaceProperties = 8,\n}\n```\n\n----------------------------------------\n\nTITLE: FluentAssertions Changelog Entry\nDESCRIPTION: Markdown formatted changelog documenting multiple versions of the FluentAssertions library, including detailed lists of fixes and new features for each version. Includes fixes for DateTimeOffset assertions, improvements to BeEquivalentTo behavior, and enhancements to failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/releases.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n### Fixes\n* Fixed formatting error when checking nullable `DateTimeOffset` with\n`BeWithin(...).Before(...)` - [#2312](https://github.com/fluentassertions/fluentassertions/pull/2312)\n* `BeEquivalentTo` will now find and can map subject properties that are implemented through an explicitly-implemented interface - [#2152](https://github.com/fluentassertions/fluentassertions/pull/2152)\n* Fixed that the `because` and `becauseArgs` were not passed down the equivalency tree - [#2318](https://github.com/fluentassertions/fluentassertions/pull/2318)\n```\n\n----------------------------------------\n\nTITLE: Defining EqualityStrategy Enum in C#\nDESCRIPTION: Enum defining strategies for equality comparison, determining whether objects should be compared using their Equals method or by comparing their members individually.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum EqualityStrategy\n{\n    Equals = 0,\n    Members = 1,\n    ForceEquals = 2,\n    ForceMembers = 3,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EnumEquivalencyHandling Enum in C#\nDESCRIPTION: Enum specifying how enum values should be compared during equivalency validation, either by comparing underlying values or by comparing names.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum EnumEquivalencyHandling\n{\n    ByValue = 0,\n    ByName = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Including MSTest Migration Comparison Template\nDESCRIPTION: Jekyll template inclusion for displaying migration comparisons between MSTest and FluentAssertions. Shows equivalent assertions and their failure messages.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/tips.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n{% include assertion-comparison.html header1=\"MSTest\" header2=\"Fluent Assertions\" idPrefix=\"mstest-\" caption=\"Assert\"            examples=site.data.mstest-migration.assert %}\n{% include assertion-comparison.html header1=\"MSTest\" header2=\"Fluent Assertions\" idPrefix=\"mstest-\" caption=\"CollectionAssert\"  examples=site.data.mstest-migration.collectionAssert %}\n{% include assertion-comparison.html header1=\"MSTest\" header2=\"Fluent Assertions\" idPrefix=\"mstest-\" caption=\"StringAssert\"      examples=site.data.mstest-migration.stringAssert %}\n{% include assertion-comparison.html header1=\"MSTest\" header2=\"Fluent Assertions\" idPrefix=\"mstest-\" caption=\"Exceptions\"        examples=site.data.mstest-migration.exceptions %}\n```\n\n----------------------------------------\n\nTITLE: Defining MaxLinesExceededException in FluentAssertions\nDESCRIPTION: A custom exception that inherits from System.Exception, used when a formatter output exceeds the maximum number of lines allowed in the assertion output.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_95\n\nLANGUAGE: C#\nCODE:\n```\npublic class MaxLinesExceededException : System.Exception\n{\n    public MaxLinesExceededException() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Obsolete Should() Methods to Prevent Misuse of AndConstraint in C#\nDESCRIPTION: A set of obsolete method overloads that throw errors when developers mistakenly call Should() after an And method. These methods prevent a common mistake in the fluent assertion pattern where developers chain a Should() call directly after an And method.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.BooleanAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateOnlyAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateOnlyAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeOffsetRangeAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeOffsetAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeRangeAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.GuidAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.GuidAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.SimpleTimeSpanAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.TimeOnlyAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.TimeOnlyAssertions<TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TSubject, TAssertions>(this FluentAssertions.Numeric.NumericAssertionsBase<TSubject, TSubject, TAssertions> _)\n    where TSubject :  struct, System.IComparable<TSubject>\n    where TAssertions : FluentAssertions.Numeric.NumericAssertions<TSubject, TAssertions> { }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the \\'AndConstraint\\' itself. Remove the \\'Should()\\' method direct\" +\n            \"ly following \\'And\\'\", true)]\npublic static void Should<TEnum, TAssertions>(this FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions> _)\n    where TEnum :  struct, System.Enum\n    where TAssertions : FluentAssertions.Primitives.EnumAssertions<TEnum, TAssertions> { }\n```\n\n----------------------------------------\n\nTITLE: Event Monitoring Interfaces and Classes in C#\nDESCRIPTION: Defines interfaces and classes for monitoring events in the FluentAssertions framework. Includes IEventRecording, IMonitor<T>, and OccurredEvent for tracking event occurrences and their metadata.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_85\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEventRecording : System.Collections.Generic.IEnumerable<FluentAssertions.Events.OccurredEvent>, System.Collections.IEnumerable\n{\n    System.Type EventHandlerType { get; }\n    string EventName { get; }\n    object EventObject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Monitoring Options Methods in FluentAssertions\nDESCRIPTION: Definition of methods for EventMonitorOptions class that provide configuration for ignoring exceptions when accessing events or recording events with broken accessors.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.Events.EventMonitorOptions IgnoringEventAccessorExceptions() { }\npublic FluentAssertions.Events.EventMonitorOptions RecordingEventsWithBrokenAccessor() { }\n```\n\n----------------------------------------\n\nTITLE: MaxLinesExceededException for Handling Output Limits\nDESCRIPTION: This exception is thrown when the formatted output exceeds the maximum number of lines specified in the formatting options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_129\n\nLANGUAGE: C#\nCODE:\n```\npublic class MaxLinesExceededException : System.Exception\n{\n    public MaxLinesExceededException() { }\n}\n```\n\n----------------------------------------\n\nTITLE: IAssertionContext Interface Definition in C#\nDESCRIPTION: Generic interface for assertion contexts that provides access to the subject, expectation, and reason information used in assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_73\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IAssertionContext<TSubject>\n{\n    string Because { get; set; }\n    object[] BecauseArgs { get; set; }\n    TSubject Expectation { get; }\n    FluentAssertions.Equivalency.INode SelectedNode { get; }\n    TSubject Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Assertion Attributes in C#\nDESCRIPTION: Attribute classes for marking custom assertions in the FluentAssertions framework. These attributes help identify methods and assemblies that contain custom assertion logic.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic class CustomAssertionAttribute : System.Attribute\n{\n    public CustomAssertionAttribute() { }\n}\n\n[System.AttributeUsage(System.AttributeTargets.Assembly)]\npublic sealed class CustomAssertionsAssemblyAttribute : System.Attribute\n{\n    public CustomAssertionsAssemblyAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Asserting Exceptions in Yielded Enumerables in C#\nDESCRIPTION: Shows an alternative way to assert exceptions in methods that return IEnumerable and use the yield keyword.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/exceptions.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nobj.Enumerating(x => x.SomeMethodThatUsesYield(\"blah\")).Should().Throw<ArgumentException>();\n```\n\n----------------------------------------\n\nTITLE: Implementing UInt16ValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of UInt16/ushort values in assertion results. It provides methods to check if it can handle a value type and to format the value accordingly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_106\n\nLANGUAGE: C#\nCODE:\n```\npublic class UInt16ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public UInt16ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining INode Interface for FluentAssertions in C#\nDESCRIPTION: This interface defines properties and methods for representing a node in the object graph during equivalency comparisons, including depth, expectation, subject, and type information.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\npublic interface INode\n{\n    int Depth { get; }\n    FluentAssertions.Equivalency.Pathway Expectation { get; }\n    FluentAssertions.Equivalency.GetSubjectId GetSubjectId { get; }\n    bool IsRoot { get; }\n    System.Type ParentType { get; }\n    bool RootIsCollection { get; }\n    FluentAssertions.Equivalency.Pathway Subject { get; }\n    System.Type Type { get; }\n    void AdjustForRemappedSubject(FluentAssertions.Equivalency.IMember subjectMember);\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Context and Options Classes\nDESCRIPTION: These classes provide configuration options for the formatting process, including settings for maximum depth, maximum lines, line breaks, and custom formatters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_128\n\nLANGUAGE: C#\nCODE:\n```\npublic class FormattingContext\n{\n    public FormattingContext() { }\n    public bool UseLineBreaks { get; set; }\n}\n\npublic class FormattingOptions\n{\n    public FormattingOptions() { }\n    public int MaxDepth { get; set; }\n    public int MaxLines { get; set; }\n    public bool UseLineBreaks { get; set; }\n    public void AddFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n    public void RemoveFormatter(FluentAssertions.Formatting.IValueFormatter formatter) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ITimer Interface in C#\nDESCRIPTION: Defines an interface for timers used in testing, tracking elapsed time and supporting disposal.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_53\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface ITimer : System.IDisposable\n{\n    System.TimeSpan Elapsed { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AllTypes Utility Class for Assembly Type Selection in C#\nDESCRIPTION: A static utility class that provides entry points for selecting and filtering types from assemblies for assertions. It returns a TypeSelector that can be used to create type-based assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_180\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AllTypes\n{\n    public static FluentAssertions.Types.TypeSelector From(System.Reflection.Assembly assembly) { }\n}\n```\n\n----------------------------------------\n\nTITLE: XDocumentAssertions Class Definition in C#\nDESCRIPTION: Definition of XDocumentAssertions class for asserting properties of XML documents. Includes methods to verify document structure, content, and equivalence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_155\n\nLANGUAGE: csharp\nCODE:\n```\npublic class XDocumentAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XDocument, FluentAssertions.Xml.XDocumentAssertions>\n{\n    public XDocumentAssertions(System.Xml.Linq.XDocument document, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> Be(System.Xml.Linq.XDocument expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> BeEquivalentTo(System.Xml.Linq.XDocument expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElement(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(string expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>> HaveElement(System.Xml.Linq.XName expected, FluentAssertions.OccurrenceConstraint occurrenceConstraint, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(string expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveElementWithValue(System.Xml.Linq.XName expectedElement, string expectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndWhichConstraint<FluentAssertions.Xml.XDocumentAssertions, System.Xml.Linq.XElement> HaveRoot(System.Xml.Linq.XName expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBe(System.Xml.Linq.XDocument unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotBeEquivalentTo(System.Xml.Linq.XDocument unexpected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(string unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElement(System.Xml.Linq.XName unexpectedElement, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(string unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XDocumentAssertions> NotHaveElementWithValue(System.Xml.Linq.XName unexpectedElement, string unexpectedValue, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AssertionEngineInitializerAttribute in C#\nDESCRIPTION: Defines an attribute for initializing the assertion engine at assembly level. It allows specifying a type and method name that will be called during initialization.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_119\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple=true)]\npublic sealed class AssertionEngineInitializerAttribute : System.Attribute\n{\n    public AssertionEngineInitializerAttribute(System.Type type, string methodName) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ICloneable2 Interface\nDESCRIPTION: Simple interface that defines a Clone method for creating copies of objects. Appears to be an alternative to the standard ICloneable interface.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_86\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ICloneable2\n{\n    object Clone();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining StartTimer Delegate in C#\nDESCRIPTION: Defines a delegate type for starting timers, used for dependency injection in time-dependent tests.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_54\n\nLANGUAGE: csharp\nCODE:\n```\npublic delegate FluentAssertions.Common.ITimer StartTimer();\n```\n\n----------------------------------------\n\nTITLE: Defining MemberVisibility Flags Enum in C#\nDESCRIPTION: Flag enumeration that specifies visibility options for members (fields and properties) in the equivalency comparison system.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\n[System.Flags]\npublic enum MemberVisibility\n{\n    None = 0,\n    Internal = 1,\n    Public = 2,\n    ExplicitlyImplemented = 4,\n    DefaultInterfaceProperties = 8,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TestFramework Enum for Test Framework Integration in C#\nDESCRIPTION: Defines an enumeration of supported test frameworks for integration with FluentAssertions. This enables proper exception handling and test output formatting based on the test framework in use.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_56\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum TestFramework\n{\n    XUnit2 = 0,\n    XUnit3 = 1,\n    TUnit = 2,\n    MsTest = 3,\n    NUnit = 4,\n    MSpec = 5,\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Chained Assertions Usage in C#\nDESCRIPTION: Demonstrates how to use chained assertions with custom DirectoryInfo assertions to verify both file existence and path properties.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ndirectoryInfo.Should().ContainFile(\"trace.dmp\").Which.Path.Should().BeginWith(\"c:\\\\files\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Framework in App.config for Fluent Assertions\nDESCRIPTION: Shows how to explicitly specify the test framework in app.config when Fluent Assertions cannot automatically detect it in .NET 4.7 or .NET 6.0 projects.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/introduction.md#2025-04-23_snippet_6\n\nLANGUAGE: xml\nCODE:\n```\n<configuration>\n  <appSettings>\n    <!-- Supported values: nunit, xunit2, xunit3, mstestv2, mspec and tunit -->\n    <add key=\"FluentAssertions.TestFramework\" value=\"nunit\"/>\n  </appSettings>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Defining IMember Interface for FluentAssertions in C#\nDESCRIPTION: This interface defines properties for member information used in equivalency comparisons, including the declaring type, accessibility, name, and type of the member.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    string Name { get; }\n    string Path { get; set; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfoSelector Class in C#\nDESCRIPTION: This class provides methods for selecting and filtering PropertyInfo objects. It implements IEnumerable<PropertyInfo> and includes various properties and methods for refining property selection based on different criteria.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_186\n\nLANGUAGE: C#\nCODE:\n```\npublic class PropertyInfoSelector : System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo>, System.Collections.IEnumerable\n{\n    public PropertyInfoSelector(System.Collections.Generic.IEnumerable<System.Type> types) { }\n    public PropertyInfoSelector(System.Type type) { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreAbstract { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotAbstract { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotStatic { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotVirtual { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatArePublicOrInternal { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreStatic { get; }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreVirtual { get; }\n    public System.Collections.Generic.IEnumerator<System.Reflection.PropertyInfo> GetEnumerator() { }\n    public FluentAssertions.Types.PropertyInfoSelector NotOfType<TReturn>() { }\n    public FluentAssertions.Types.PropertyInfoSelector OfType<TReturn>() { }\n    public FluentAssertions.Types.TypeSelector ReturnTypes() { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWith<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public FluentAssertions.Types.PropertyInfoSelector ThatAreNotDecoratedWithOrInherit<TAttribute>()\n        where TAttribute : System.Attribute { }\n    public System.Reflection.PropertyInfo[] ToArray() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WhoseValueConstraint Class in C#\nDESCRIPTION: Defines a class for making assertions on the values of key-value pairs in a dictionary, allowing for chaining of assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_49\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WhoseValueConstraint<TCollection, TKey, TValue, TAssertions> : FluentAssertions.AndConstraint<TAssertions>\n    where TCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>\n    where TAssertions : FluentAssertions.Collections.GenericDictionaryAssertions<TCollection, TKey, TValue, TAssertions>\n{\n    public WhoseValueConstraint(TAssertions parentConstraint, TValue value) { }\n    public TValue WhoseValue { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Specific Element Properties in Collections (C#)\nDESCRIPTION: These methods assert properties of specific elements within a collection, such as their position or relationships to other elements.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndWhichConstraint<TAssertions, T> HaveElementAt(int index, T element, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveElementPreceding(T successor, T expectation, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> HaveElementSucceeding(T predecessor, T expectation, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: XAttributeAssertions Class Definition in C#\nDESCRIPTION: Definition of XAttributeAssertions class for making assertions about XML attributes. Provides methods to verify attribute values and identity.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_154\n\nLANGUAGE: csharp\nCODE:\n```\npublic class XAttributeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, FluentAssertions.Xml.XAttributeAssertions>\n{\n    public XAttributeAssertions(System.Xml.Linq.XAttribute attribute, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> Be(System.Xml.Linq.XAttribute expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> HaveValue(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> NotBe(System.Xml.Linq.XAttribute unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: TimeSpanCondition Enumeration Definition\nDESCRIPTION: Enumeration defining different types of TimeSpan comparison conditions used in timing-related assertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_139\n\nLANGUAGE: C#\nCODE:\n```\npublic enum TimeSpanCondition\n{\n    MoreThan = 0,\n    AtLeast = 1,\n    Exactly = 2,\n    Within = 3,\n    LessThan = 4,\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly Metadata and InternalsVisibleTo Declarations in C#\nDESCRIPTION: Declares assembly metadata including repository URL and internal visibility permissions for test and benchmark projects. Uses strong-name public keys for security.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadata(\"RepositoryUrl\", \"https://github.com/fluentassertions/fluentassertions\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"Benchmarks, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"FluentAssertions.Equivalency.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"FluentAssertions.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionEngineInitializer\nDESCRIPTION: Example of using AssertionEngineInitializer attribute for configuring Fluent Assertions across different .NET versions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/extensibility.md#2025-04-23_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: AssertionEngineInitializer(typeof(Initializer), nameof(Initializer.Initialize))]\n\npublic static class Initializer\n{\n    public static void Initialize()\n    {\n        AssertionConfiguration.Current.Equivalency.Modify(options => options\n          .ComparingByValue<DirectoryInfo>());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OrderStrictness Enum in C#\nDESCRIPTION: Enumeration defining the strictness levels for collection ordering in equivalency comparisons, with options for strict, not strict, or irrelevant ordering.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\npublic enum OrderStrictness\n{\n    Strict = 0,\n    NotStrict = 1,\n    Irrelevant = 2,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Utility Interfaces for FluentAssertions in C#\nDESCRIPTION: Implements utility interfaces ICloneable2, ITestFramework, and Reason class used across the FluentAssertions framework. These components support core functionality for assertions and test framework integration.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_82\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ICloneable2\n    {\n        object Clone();\n    }\n    public interface ITestFramework\n    {\n        bool IsAvailable { get; }\n        [System.Diagnostics.CodeAnalysis.DoesNotReturn]\n        void Throw(string message);\n    }\n    public class Reason\n    {\n        public Reason(string formattedMessage, object[] arguments) { }\n        public object[] Arguments { get; set; }\n        public string FormattedMessage { get; set; }\n    }\n```\n\n----------------------------------------\n\nTITLE: Running Spellcheck in PowerShell\nDESCRIPTION: Command to run the spellcheck target using the build script in a PowerShell environment before submitting documentation changes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n.\\build.ps1 --target spellcheck\n```\n\n----------------------------------------\n\nTITLE: Defining NullableTimeOnlyAssertions Generic Class in C#\nDESCRIPTION: Abstract class for assertions on nullable TimeOnly types. Inherits from TimeOnlyAssertions<T> and adds methods for asserting nullability and value existence.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_119\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableTimeOnlyAssertions<TAssertions> : FluentAssertions.Primitives.TimeOnlyAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableTimeOnlyAssertions<TAssertions>\n{\n    public NullableTimeOnlyAssertions(System.TimeOnly? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotHaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SubsequentOrderingAssertions Class in C#\nDESCRIPTION: Defines a class for making assertions about the ordering of elements in a collection after an initial ordering has been established.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_48\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SubsequentOrderingAssertions<T> : FluentAssertions.Collections.GenericCollectionAssertions<System.Collections.Generic.IEnumerable<T>, T>\n{\n    public SubsequentOrderingAssertions(System.Collections.Generic.IEnumerable<T> actualValue, System.Linq.IOrderedEnumerable<T> previousOrderedEnumerable, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Collections.SubsequentOrderingAssertions<T>> ThenBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Case Validation Assertions in C#\nDESCRIPTION: Shows assertions for validating string case (upper/lower) with FluentAssertions.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/strings.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ntheString.Should().BeUpperCased();\ntheString.Should().NotBeUpperCased();\ntheString.Should().BeLowerCased();\ntheString.Should().NotBeLowerCased();\n```\n\n----------------------------------------\n\nTITLE: Generic XmlNodeAssertions Class Definition in C#\nDESCRIPTION: Generic base class for all XML node assertions that extends ReferenceTypeAssertions. This class provides common methods for equivalence testing between XML nodes and serves as the foundation for more specialized XML assertion classes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_160\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeAssertions<TSubject, TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<TSubject, TAssertions>\n    where TSubject : System.Xml.XmlNode\n    where TAssertions : FluentAssertions.Xml.XmlNodeAssertions<TSubject, TAssertions>\n{\n    public XmlNodeAssertions(TSubject xmlNode, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<TAssertions> BeEquivalentTo(System.Xml.XmlNode expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> NotBeEquivalentTo(System.Xml.XmlNode unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CSharpAccessModifier Enum in C#\nDESCRIPTION: Defines an enumeration of C# access modifiers used for reflection-based assertions. The enum encapsulates all possible access modifiers in C#.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum CSharpAccessModifier\n{\n    Public = 0,\n    Private = 1,\n    Protected = 2,\n    Internal = 3,\n    ProtectedInternal = 4,\n    InvalidForCSharp = 5,\n    PrivateProtected = 6,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Bundler in Ruby\nDESCRIPTION: Command to install the Bundler gem, which is a prerequisite for building the Fluent Assertions documentation site.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: ruby\nCODE:\n```\ngem install bundler\n```\n\n----------------------------------------\n\nTITLE: Implementing GlobalFormattingOptions Class in C#\nDESCRIPTION: Extends FormattingOptions to provide global formatting configuration for value representation in assertion messages. It includes properties for customizing value formatter discovery.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_55\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GlobalFormattingOptions : FluentAssertions.Formatting.FormattingOptions\n{\n    public GlobalFormattingOptions() { }\n    public string ValueFormatterAssembly { get; set; }\n    public FluentAssertions.Common.ValueFormatterDetectionMode ValueFormatterDetectionMode { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: IMemberInfo Interface Definition in C#\nDESCRIPTION: Provides basic information about a member, including its name, path, type, and accessibility modifiers for getters and setters.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_78\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMemberInfo\n{\n    System.Type DeclaringType { get; }\n    FluentAssertions.Common.CSharpAccessModifier GetterAccessibility { get; }\n    string Name { get; }\n    string Path { get; set; }\n    FluentAssertions.Common.CSharpAccessModifier SetterAccessibility { get; }\n    System.Type Type { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IClock Interface for Time-Based Testing in C#\nDESCRIPTION: Defines an interface for abstracting clock operations to facilitate testing time-dependent code. It provides methods for introducing delays and measuring elapsed time.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_49\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IClock\n{\n    void Delay(System.TimeSpan timeToDelay);\n    System.Threading.Tasks.Task DelayAsync(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken);\n    FluentAssertions.Common.ITimer StartTimer();\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Boolean Assertions Implementation in C#\nDESCRIPTION: Defines assertion methods for nullable boolean values with null checking and value comparison capabilities.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_124\n\nLANGUAGE: C#\nCODE:\n```\npublic class NullableBooleanAssertions<TAssertions> : FluentAssertions.Primitives.BooleanAssertions<TAssertions>\n    where TAssertions : FluentAssertions.Primitives.NullableBooleanAssertions<TAssertions>\n{\n    public NullableBooleanAssertions(bool? value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    public FluentAssertions.AndConstraint<TAssertions> BeNull(string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<TAssertions> HaveValue(string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: XAttributeAssertions Class Declaration for XML Attribute Testing (C#)\nDESCRIPTION: Defines the XAttributeAssertions class that extends ReferenceTypeAssertions to provide specialized assertions for XML attributes (System.Xml.Linq.XAttribute objects).\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_158\n\nLANGUAGE: C#\nCODE:\n```\npublic class XAttributeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, FluentAssertions.Xml.XAttributeAssertions>\n{\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion Context Interface in C#\nDESCRIPTION: Interface defining the context for an assertion, containing the subject under test, the expected value, and explanatory information about the assertion.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IAssertionContext<TSubject>\n{\n    string Because { get; set; }\n    object[] BecauseArgs { get; set; }\n    TSubject Expectation { get; }\n    FluentAssertions.Equivalency.INode SelectedNode { get; }\n    TSubject Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: GetSubjectId Delegate Definition in C#\nDESCRIPTION: Defines a delegate that returns a string identifier for a subject in equivalency comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_72\n\nLANGUAGE: csharp\nCODE:\n```\npublic delegate string GetSubjectId();\n```\n\n----------------------------------------\n\nTITLE: Asserting Non-Ordering in Collections (C#)\nDESCRIPTION: These methods assert that a collection is not in a specific order (ascending or descending), with various overloads for custom comparisons.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInAscendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Collections.Generic.IComparer<T> comparer, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder(System.Func<T, T, int> comparison, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, string because = \"\", params object[] becauseArgs) { }\npublic FluentAssertions.AndConstraint<TAssertions> NotBeInDescendingOrder<TSelector>(System.Linq.Expressions.Expression<System.Func<T, TSelector>> propertyExpression, System.Collections.Generic.IComparer<TSelector> comparer, string because = \"\", params object[] becauseArgs) { }\n```\n\n----------------------------------------\n\nTITLE: Defining Equivalency Tracing Components in C#\nDESCRIPTION: Interfaces and classes for tracing equivalency validation in FluentAssertions. This includes the ITraceWriter interface, GetTraceMessage delegate, and StringBuilderTraceWriter class for tracking validation steps.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_109\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate string GetTraceMessage(FluentAssertions.Equivalency.INode node);\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic interface ITraceWriter\n{\n    System.IDisposable AddBlock(string trace);\n    void AddSingle(string trace);\n    string ToString();\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringBuilderTraceWriter : FluentAssertions.Equivalency.Tracing.ITraceWriter\n{\n    public StringBuilderTraceWriter() { }\n    public System.IDisposable AddBlock(string trace) { }\n    public void AddSingle(string trace) { }\n    public override string ToString() { }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic class Tracer\n{\n    public override string ToString() { }\n    public System.IDisposable WriteBlock(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }\n    public void WriteLine(FluentAssertions.Equivalency.Tracing.GetTraceMessage getTraceMessage) { }\n}\n```\n\n----------------------------------------\n\nTITLE: XAttributeAssertions Class Implementation in C#\nDESCRIPTION: Defines the XAttributeAssertions class which inherits from ReferenceTypeAssertions to provide assertion capabilities for XML attributes. Contains methods for comparing XML attributes and verifying their values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_166\n\nLANGUAGE: C#\nCODE:\n```\npublic class XAttributeAssertions : FluentAssertions.Primitives.ReferenceTypeAssertions<System.Xml.Linq.XAttribute, FluentAssertions.Xml.XAttributeAssertions>\n{\n    public XAttributeAssertions(System.Xml.Linq.XAttribute attribute, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> Be(System.Xml.Linq.XAttribute expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> HaveValue(string expected, string because = \"\", params object[] becauseArgs) { }\n    public FluentAssertions.AndConstraint<FluentAssertions.Xml.XAttributeAssertions> NotBe(System.Xml.Linq.XAttribute unexpected, string because = \"\", params object[] becauseArgs) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining GetSubjectId Delegate in C#\nDESCRIPTION: Delegate for obtaining a string identifier for the subject being validated, used in various parts of the equivalency validation system.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\npublic delegate string GetSubjectId();\n```\n\n----------------------------------------\n\nTITLE: MemberVisibility Enum Definition\nDESCRIPTION: Flag enum defining visibility levels for members during equivalency comparison, including None, Internal, Public, and ExplicitlyImplemented options.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_77\n\nLANGUAGE: C#\nCODE:\n```\n[System.Flags]\npublic enum MemberVisibility\n{\n    None = 0,\n    Internal = 1,\n    Public = 2,\n    ExplicitlyImplemented = 4,\n    DefaultInterfaceProperties = 8,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OccurrenceConstraint Abstract Class in C#\nDESCRIPTION: Abstract base class for occurrence constraints that requires an expected count parameter in the constructor. This class serves as a foundation for implementing specific occurrence validation rules.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class OccurrenceConstraint\n{\n    protected OccurrenceConstraint(int expectedCount) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StringAssertions<TAssertions> Class in C#\nDESCRIPTION: This snippet defines the generic StringAssertions<TAssertions> class, which inherits from ReferenceTypeAssertions<string, TAssertions>. It includes a constructor and a protected Identifier property.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_163\n\nLANGUAGE: C#\nCODE:\n```\npublic class StringAssertions<TAssertions> : FluentAssertions.Primitives.ReferenceTypeAssertions<string, TAssertions>\n    where TAssertions : FluentAssertions.Primitives.StringAssertions<TAssertions>\n{\n    public StringAssertions(string value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n    protected override string Identifier { get; }\n    // ... (other methods)\n}\n```\n\n----------------------------------------\n\nTITLE: XmlNodeFormatter Class Definition in C#\nDESCRIPTION: Class that implements IValueFormatter to provide custom formatting for XML nodes in assertion messages. This formatter helps display XML node differences in a human-readable format when assertions fail.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_161\n\nLANGUAGE: C#\nCODE:\n```\npublic class XmlNodeFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XmlNodeFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Assembly Metadata and InternalsVisibleTo Attributes in C#\nDESCRIPTION: Sets up assembly metadata for the repository URL and configures internals visibility to specific test assemblies. These attributes allow test projects to access internal members of the FluentAssertions library.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: System.Reflection.AssemblyMetadata(\"RepositoryUrl\", \"https://github.com/fluentassertions/fluentassertions\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"Benchmarks, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"FluentAssertions.Equivalency.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(@\"FluentAssertions.Specs, PublicKey=00240000048000009400000006020000002400005253413100040000010001002d25ff515c85b13ba08f61d466cff5d80a7f28ba197bbf8796085213e7a3406f970d2a4874932fed35db546e89af2da88c194bf1b7f7ac70de7988c78406f7629c547283061282a825616eb7eb48a9514a7570942936020a9bb37dca9ff60b778309900851575614491c6d25018fadb75828f4c7a17bf2d7dc86e7b6eafc5d8f\")]\n```\n\n----------------------------------------\n\nTITLE: EquivalencyResult Enum Definition in C#\nDESCRIPTION: Defines possible results from an equivalency step's handling process, indicating whether to continue to the next step or if equivalency has been proven.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.0.verified.txt#2025-04-23_snippet_69\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum EquivalencyResult\n{\n    ContinueWithNext = 0,\n    EquivalencyProven = 1,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing XAttributeValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of XAttribute objects from System.Xml.Linq in assertion results, displaying attributes in XML format.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_110\n\nLANGUAGE: C#\nCODE:\n```\npublic class XAttributeValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public XAttributeValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Enum Definition Status in Fluent Assertions\nDESCRIPTION: Shows how to check if an enum value is defined in the enum type using BeDefined and NotBeDefined. This is useful for validating that a cast to an enum type is a valid defined value.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/enums.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar myEnum = (MyEnum)1;\nmyEnum.Should().BeDefined();\n\nmyEnum = (MyEnum)99;\nmyEnum.Should().NotBeDefined();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Enum Equivalency Changes with String and Integer Comparison in v6\nDESCRIPTION: Examples of assertions that fail in v6 due to new constraints on how enums are compared during equivalency checks, showing both string name and value equivalency scenarios.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/_pages/upgradingtov6.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar subject = new { Value = \"One\" };\nvar expectation = new { Value = MyOtherEnum.One };\nsubject.Should().BeEquivalentTo(expectation,  opt => opt.ComparingEnumsByName());\n\nvar subject = new { Value = 1 };\nvar expectation = new { Value = MyOtherEnum.One };\nsubject.Should().BeEquivalentTo(expectation,  opt => opt.ComparingEnumsByValue());\n```\n\n----------------------------------------\n\nTITLE: Exception and Attribute Definitions for FluentAssertions in C#\nDESCRIPTION: Definition of a custom exception and an attribute used in the FluentAssertions framework. MaxLinesExceededException is thrown when output exceeds limits, and ValueFormatterAttribute marks methods that can format values.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_102\n\nLANGUAGE: C#\nCODE:\n```\npublic class MaxLinesExceededException : System.Exception\n{\n    public MaxLinesExceededException() { }\n}\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic class ValueFormatterAttribute : System.Attribute\n{\n    public ValueFormatterAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Obsolete Assertion Methods in C#\nDESCRIPTION: Collection of obsolete Should() methods marked with the Obsolete attribute. These methods are marked as obsolete to prevent asserting on AndConstraint itself and guide users to remove the Should() method following And.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.BooleanAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.BooleanAssertions<TAssertions> { }\n[System.Obsolete(\"You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'\", true)]\npublic static void Should<TAssertions>(this FluentAssertions.Primitives.DateTimeAssertions<TAssertions> _)\n    where TAssertions : FluentAssertions.Primitives.DateTimeAssertions<TAssertions> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing UInt32ValueFormatter in FluentAssertions\nDESCRIPTION: A class implementing IValueFormatter interface to handle formatting of UInt32/uint values in assertion results. It provides methods to check if it can handle a value type and to format the value accordingly.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_107\n\nLANGUAGE: C#\nCODE:\n```\npublic class UInt32ValueFormatter : FluentAssertions.Formatting.IValueFormatter\n{\n    public UInt32ValueFormatter() { }\n    public bool CanHandle(object value) { }\n    public void Format(object value, FluentAssertions.Formatting.FormattedObjectGraph formattedGraph, FluentAssertions.Formatting.FormattingContext context, FluentAssertions.Formatting.FormatChild formatChild) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ValueFormatterAttribute in FluentAssertions\nDESCRIPTION: A custom attribute that can be applied to methods, likely used to mark methods that should be used as custom formatters in FluentAssertions. Applies only to methods.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net47.verified.txt#2025-04-23_snippet_109\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Method)]\npublic class ValueFormatterAttribute : System.Attribute\n{\n    public ValueFormatterAttribute() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Jekyll Server with Batch File\nDESCRIPTION: Alternative method to start the Jekyll server using a batch file, which likely contains the same command as the direct Ruby execution.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/README.md#2025-04-23_snippet_2\n\nLANGUAGE: batch\nCODE:\n```\nrun.bat\n```\n\n----------------------------------------\n\nTITLE: Building and Serving Jekyll Site\nDESCRIPTION: Commands to install dependencies and start the Jekyll server for local development of the Fluent Assertions documentation site.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/README.md#2025-04-23_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nbundle install\n```\n\nLANGUAGE: ruby\nCODE:\n```\nbundle exec jekyll serve\n```\n\n----------------------------------------\n\nTITLE: Running Spellcheck in Bash\nDESCRIPTION: Command to run the spellcheck target using the build script in a bash environment before submitting documentation changes.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh --target spellcheck\n```\n\n----------------------------------------\n\nTITLE: Implementing ComparableTypeAssertions Class in C#\nDESCRIPTION: Defines a ComparableTypeAssertions class that extends ComparableTypeAssertions<T, TAssertions> for implementing fluent assertions for comparable types. It provides a constructor that accepts an IComparable value and an AssertionChain.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/net6.0.verified.txt#2025-04-23_snippet_93\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ComparableTypeAssertions<T> : FluentAssertions.Numeric.ComparableTypeAssertions<T, FluentAssertions.Numeric.ComparableTypeAssertions<T>>\n{\n    public ComparableTypeAssertions(System.IComparable<T> value, FluentAssertions.Execution.AssertionChain assertionChain) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BufferedStreamAssertions<TAssertions> Class in C#\nDESCRIPTION: Generic base class for making assertions about BufferedStream objects. Extends StreamAssertions to provide type-specific assertions for buffered streams with a fluent API pattern.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_148\n\nLANGUAGE: C#\nCODE:\n```\npublic class BufferedStreamAssertions<TAssertions> : FluentAssertions.Streams.StreamAssertions<System.IO.BufferedStream, TAssertions>\n        where TAssertions : FluentAssertions.Streams.BufferedStreamAssertions<TAssertions>\n    {\n        public BufferedStreamAssertions(System.IO.BufferedStream stream, FluentAssertions.Execution.AssertionChain assertionChain) { }\n\n```\n\n----------------------------------------\n\nTITLE: Replacing Culture-Sensitive String Comparisons in .NET\nDESCRIPTION: List of deprecated string comparison methods and their recommended replacements. These recommendations aim to prevent culture-sensitive string comparison issues by using ordinal comparisons instead.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Src/FluentAssertions/BannedSymbols.txt#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.StringComparison.CurrentCulture         // Use Ordinal instead\nSystem.StringComparison.CurrentCultureIgnoreCase  // Use OrdinalIgnoreCase instead\nSystem.StringComparison.InvariantCulture         // Use Ordinal instead\nSystem.StringComparison.InvariantCultureIgnoreCase // Use OrdinalIgnoreCase instead\nSystem.Globalization.CultureInfo.CurrentCulture   // Use InvariantCulture instead\n```\n\n----------------------------------------\n\nTITLE: Google AdSense Publisher Configuration for FluentAssertions\nDESCRIPTION: This configuration line establishes the relationship between the FluentAssertions project and Google AdSense. It includes the domain (google.com), publisher ID (pub-2541295231849242), relationship type (DIRECT), and verification code (f08c47fec0942fa0).\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/docs/ads.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ngoogle.com, pub-2541295231849242, DIRECT, f08c47fec0942fa0\n```\n\n----------------------------------------\n\nTITLE: Implementing AssertionEngineInitializerAttribute\nDESCRIPTION: Attribute for marking assembly-level assertion engine initializers. Used to initialize the assertion engine with custom configurations at assembly load time.\nSOURCE: https://github.com/fluentassertions/fluentassertions/blob/main/Tests/Approval.Tests/ApprovedApi/FluentAssertions/netstandard2.1.verified.txt#2025-04-23_snippet_89\n\nLANGUAGE: C#\nCODE:\n```\n[System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple=true)]\npublic sealed class AssertionEngineInitializerAttribute : System.Attribute\n{\n    public AssertionEngineInitializerAttribute(System.Type type, string methodName) { }\n}\n```"
  }
]