[
  {
    "owner": "47ng",
    "repo": "nuqs",
    "content": "TITLE: Basic String State Sync with useQueryState in TSX\nDESCRIPTION: This snippet demonstrates replacing React's `useState` with `nuqs`'s `useQueryState` to synchronize a 'name' state with the URL query string. It shows reading the current value from the URL, updating it via input, and clearing it by setting the state to `null`, which removes the query parameter. Requires `useQueryState` from `nuqs`.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/basic-usage.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { useQueryState } from 'nuqs'\n\nexport function Demo() {\n  const [name, setName] = useQueryState('name')\n  return (\n    <>\n      <input value={name || ''} onChange={e => setName(e.target.value)} />\n      <button onClick={() => setName(null)}>Clear</button>\n      <p>Hello, {name || 'anonymous visitor'}!</p>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating nuqs Adapter - Next.js App Router - TSX\nDESCRIPTION: This snippet shows how to integrate the `NuqsAdapter` into a Next.js application using the App Router. The adapter should wrap the main application children within the root layout file (`src/app/layout.tsx`) to provide the necessary context for nuqs to function correctly.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/adapters.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/next/app'\nimport { type ReactNode } from 'react'\n\nexport default function RootLayout({\n  children\n}: {\n  children: ReactNode\n}) {\n  return (\n    <html>\n      <body>\n        <NuqsAdapter>{children}</NuqsAdapter>\n      </body>\n    </html>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in Next.js (app router)\nDESCRIPTION: This snippet shows how to wrap your root layout component with the NuqsAdapter for Next.js app router compatibility (>=14.2.0). This provides the necessary context for nuqs hooks.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// src/app/layout.tsx\nimport { NuqsAdapter } from 'nuqs/adapters/next/app'\nimport { type ReactNode } from 'react'\n\nexport default function RootLayout({ children }: { children: ReactNode }) {\n  return (\n    <html>\n      <body>\n        <NuqsAdapter>{children}</NuqsAdapter>\n      </body>\n    </html>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating nuqs Adapter - React SPA (Vite) - TSX\nDESCRIPTION: This snippet illustrates integrating the `NuqsAdapter` in a standard React SPA, typically using a build tool like Vite. The adapter wraps the root application component (`<App />`) during the initial render setup in `src/main.tsx`. Note that in this configuration, the `shallow: false` option for query state updates will not trigger a full-page navigation.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/adapters.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/react'\n\ncreateRoot(document.getElementById('root')!).render(\n  <NuqsAdapter>\n    <App />\n  </NuqsAdapter>\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in Plain React (SPA)\nDESCRIPTION: This snippet shows how to wrap your application's root component with the NuqsAdapter in a standard React single-page application setup (e.g., using Vite or CRA).\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/react'\n\ncreateRoot(document.getElementById('root')!).render(\n  <NuqsAdapter>\n    <App />\n  </NuqsAdapter>\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in React Router v6\nDESCRIPTION: This snippet shows how to wrap the React Router v6 RouterProvider with the NuqsAdapter to integrate nuqs functionality.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/react-router/v6'\nimport { createBrowserRouter, RouterProvider } from 'react-router-dom'\nimport App from './App'\n\nconst router = createBrowserRouter([\n  {\n    path: '/',\n    element: <App />\n  }\n])\n\nexport function ReactRouter() {\n  return (\n    <NuqsAdapter>\n      <RouterProvider router={router} />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using searchParamsCache in a Next.js page component\nDESCRIPTION: This snippet shows how a Next.js page component receives search parameters, calls 'parse' for type safety, and accesses the parsed query values. It also illustrates rendering search results based on parameters and demonstrates using cache in a nested server component.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_27\n\nLANGUAGE: TypeScript\nCODE:\n```\n// page.tsx\nimport { searchParamsCache } from './searchParams'\n\nexport default function Page({\n  searchParams\n}: {\n  searchParams: Record<string, string | string[] | undefined>\n}) {\n  // Parse searchParams to get type-safe values\n  const { q: query } = searchParamsCache.parse(searchParams)\n  return (\n    <div>\n      <h1>Search Results for {query}</h1>\n      <Results />\n    </div>\n  )\n}\n\nfunction Results() {\n  // Access type-safe search param 'maxResults' in server components\n  const maxResults = searchParamsCache.get('maxResults')\n  return <span>Showing up to {maxResults} results</span>\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Loader in Next.js App Router\nDESCRIPTION: Shows how to use the loadSearchParams function in a Next.js app router page component to parse search parameters and pass them to a Map component.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// [!code word:loadSearchParams]\nimport { loadSearchParams } from './search-params'\nimport type { SearchParams } from 'nuqs/server'\n\ntype PageProps = {\n  searchParams: Promise<SearchParams>\n}\n\nexport default async function Page({ searchParams }: PageProps) {\n  const { latitude, longitude } = await loadSearchParams(searchParams)\n  return <Map\n    lat={latitude}\n    lng={longitude}\n  />\n\n  // Pro tip: you don't *have* to await the result.\n  // Pass the Promise object to children components wrapped in <Suspense>\n  // to benefit from PPR / dynamicIO and serve a static outer shell\n  // immediately, while streaming in the dynamic parts that depend on\n  // the search params when they become available.\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in Next.js (pages router)\nDESCRIPTION: This snippet shows how to wrap your custom _app component with the NuqsAdapter for Next.js pages router compatibility (>=14.2.0). This sets up the necessary context for nuqs.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// src/pages/_app.tsx\nimport type { AppProps } from 'next/app'\nimport { NuqsAdapter } from 'nuqs/adapters/next/pages'\n\nexport default function MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <NuqsAdapter>\n      <Component {...pageProps} />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Loader in API Routes\nDESCRIPTION: Shows how to use loadSearchParams in both Next.js app router and pages router API routes to parse search parameters from requests.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// App router, eg: app/api/location/route.ts\nexport async function GET(request: Request) {\n  const { latitude, longitude } = loadSearchParams(request)\n  // ...\n}\n\n// Pages router, eg: pages/api/location.ts\nimport type { NextApiRequest, NextApiResponse } from 'next'\nexport default function handler(\n  request: NextApiRequest,\n  response: NextApiResponse\n) {\n  const { latitude, longitude } = loadSearchParams(request.query)\n}\n```\n\n----------------------------------------\n\nTITLE: Using useQueryState Hook in React\nDESCRIPTION: This client component example shows the basic usage of the useQueryState hook. It retrieves and updates a query parameter named 'name', providing a state value and an updater function similar to React.useState.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n'use client' // Only works in client components\n\nimport { useQueryState } from 'nuqs'\n\nexport default () => {\n  const [name, setName] = useQueryState('name')\n  return (\n    <>\n      <h1>Hello, {name || 'anonymous visitor'}!</h1>\n      <input value={name || ''} onChange={e => setName(e.target.value)} />\n      <button onClick={() => setName(null)}>Clear</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing CounterButton Component with Vitest (v2) - Typescript\nDESCRIPTION: This example shows how to test a `CounterButton` component using Vitest and React Testing Library, utilizing `withNuqsTestingAdapter` to manage initial search parameters and track URL updates. It asserts that the counter increments upon a button click and verifies the corresponding changes in the URL. This version uses the `OnUrlUpdateFunction` type.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/testing.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// [!code word:withNuqsTestingAdapter]\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { withNuqsTestingAdapter, type OnUrlUpdateFunction } from 'nuqs/adapters/testing'\nimport { describe, expect, it, vi } from 'vitest'\nimport { CounterButton } from './counter-button'\n\nit('should increment the count when clicked', async () => {\n  const user = userEvent.setup()\n  const onUrlUpdate = vi.fn<OnUrlUpdateFunction>()\n  render(<CounterButton />, {\n    // 1. Setup the test by passing initial search params / querystring:\n    wrapper: withNuqsTestingAdapter({ searchParams: '?count=42', onUrlUpdate })\n  })\n  // 2. Act\n  const button = screen.getByRole('button')\n  await user.click(button)\n  // 3. Assert changes in the state and in the (mocked) URL\n  expect(button).toHaveTextContent('count is 43')\n  expect(onUrlUpdate).toHaveBeenCalledOnce()\n  const event = onUrlUpdate.mock.calls[0][0]!\n  expect(event.queryString).toBe('?count=43')\n  expect(event.searchParams.get('count')).toBe('43')\n  expect(event.options.history).toBe('push')\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring Default Values and Inferring Types in TypeScript\nDESCRIPTION: This snippet shows two methods for providing default values to `useQueryState`: via an options object (`{ defaultValue: '' }`) or using the `.withDefault` method on a parser (`parseAsInteger.withDefault(0)`). It highlights how providing a default value removes `null` from the state variable's TypeScript type, simplifying state management. Requires `useQueryState` and parsers from `nuqs`.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/basic-usage.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst [search] = useQueryState('search', { defaultValue: '' })\n//      ^? string\n\nconst [count] = useQueryState('count', parseAsInteger)\n//      ^? number | null -> no default value = nullable\n\nconst [count] = useQueryState('count', parseAsInteger.withDefault(0))\n//      ^? number\n```\n\n----------------------------------------\n\nTITLE: Using Reusable Query Hook in React Components (TSX)\nDESCRIPTION: Demonstrates how to consume the `useCoordinates` custom hook in different React components (`MapView` and `MapControls`). `MapView` shows read-only access to the query state, while `MapControls` shows how to access and use the setter function to update the query parameters via input fields, highlighting state synchronization across components.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/tips-tricks.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { useCoordinates } from '../hooks/useCoordinates'\n\nfunction MapView() {\n  const [{ lat, lng }] = useCoordinates() // Read-only\n  return (\n    <div>\n      Latitude: {lat}\n      Longitude: {lng}\n    </div>\n  )\n}\n\nfunction MapControls() {\n  const [{ lat, lng }, setCoordinates] = useCoordinates()\n  return (\n    <div>\n      <input\n        type=\"number\"\n        value={lat}\n        onChange={(e) => setCoordinates({ lat: e.target.valueAsNumber })}\n      />\n      <input\n        type=\"number\"\n        value={lng}\n        onChange={(e) => setCoordinates({ lng: e.target.valueAsNumber })}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Related Queries with useQueryStates\nDESCRIPTION: Shows how to use useQueryStates to manage multiple query parameters that should be updated together, with type definitions and default values for each parameter.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\nimport { useQueryStates, parseAsFloat } from 'nuqs'\n\nconst [coordinates, setCoordinates] = useQueryStates(\n  {\n    lat: parseAsFloat.withDefault(45.18),\n    lng: parseAsFloat.withDefault(5.72)\n  },\n  {\n    history: 'push'\n  }\n)\n\nconst { lat, lng } = coordinates\n\n// Set all (or a subset of) the keys in one go:\nconst search = await setCoordinates({\n  lat: Math.random() * 180 - 90,\n  lng: Math.random() * 360 - 180\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Parsers and URL Key Mappings for nuqs useQueryStates in TypeScript\nDESCRIPTION: Illustrates the creation of reusable parser objects with default values and corresponding urlKeys mappings with appropriate TypeScript typing using UrlKeys helper type. This pattern facilitates sharing consistent parsing and URL key remapping configurations across multiple components and nuqs features like loaders or serializers. Inputs are parser objects and urlKeys; outputs are typed objects to configure query state hooks in a DRY manner.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/batching.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// [!code word:UrlKeys]\nimport { type UrlKeys } from 'nuqs' // or 'nuqs/server'\n\nexport const coordinatesParsers = {\n  latitude: parseAsFloat.withDefault(45.18),\n  longitude: parseAsFloat.withDefault(5.72)\n}\n\nexport const coordinatesUrlKeys: UrlKeys<typeof coordinatesParsers> = {\n  latitude: 'lat',\n  longitude: 'lng'\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified State Updates with Default Values in TSX\nDESCRIPTION: Following the demonstration of setting default values, this snippet shows how state updater functions (`setCount`) for a state variable (like `count`) become simpler. Because a default value is configured, the state variable `c` inside the updater callback is guaranteed not to be `null`, eliminating the need for null checks like `c ?? 0`. Requires `useQueryState` configured with a default value.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/basic-usage.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst increment = () => setCount(c => c + 1) // c will never be null\nconst decrement = () => setCount(c => c - 1) // c will never be null\nconst clearCount = () => setCount(null) // Remove query from the URL\n```\n\n----------------------------------------\n\nTITLE: Using Default Values with useQueryState\nDESCRIPTION: Demonstrates how to specify default values for query parameters to simplify state handling. The default value is used when the query parameter is not present in the URL.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_14\n\nLANGUAGE: ts\nCODE:\n```\nconst [count, setCount] = useQueryState('count', parseAsInteger.withDefault(0))\n\nconst increment = () => setCount(c => c + 1) // c will never be null\nconst decrement = () => setCount(c => c - 1) // c will never be null\nconst clearCount = () => setCount(null) // Remove query from the URL\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Parsers with useQueryState\nDESCRIPTION: This TSX snippet illustrates creating a custom parser for useQueryState using parse and serialize functions. The example converts a query string representation to a number (hexadecimal) and back.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQueryState } from 'nuqs'\n\nexport default () => {\n  const [hex, setHex] = useQueryState('hex', {\n    // TypeScript will automatically infer it's a number\n    // based on what `parse` returns.\n    parse: (query: string) => parseInt(query, 16),\n    serialize: value => value.toString(16)\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Sharing Parser Definitions Between Server and Client Components\nDESCRIPTION: Shows how to share search parameter parser definitions between server components using cache and client components using useQueryStates.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  parseAsFloat,\n  createSearchParamsCache\n} from 'nuqs/server'\n\nexport const coordinatesParsers = {\n  lat: parseAsFloat.withDefault(45.18),\n  lng: parseAsFloat.withDefault(5.72)\n}\nexport const coordinatesCache = createSearchParamsCache(coordinatesParsers)\n\n```\n\n----------------------------------------\n\nTITLE: Integrating nuqs with React Transitions (TSX)\nDESCRIPTION: Illustrates using React's `useTransition` hook with `nuqs`. By passing the `startTransition` function and `shallow: false` to `useQueryState` options, components can display loading states during server re-renders triggered by query state updates.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport React from 'react'\nimport { useQueryState, parseAsString } from 'nuqs'\n\nfunction ClientComponent({ data }) {\n  // 1. Provide your own useTransition hook:\n  const [isLoading, startTransition] = React.useTransition()\n  const [query, setQuery] = useQueryState(\n    'query',\n    // 2. Pass the `startTransition` as an option:\n    parseAsString().withOptions({ startTransition, shallow: false })\n  )\n  // 3. `isLoading` will be true while the server is re-rendering\n  // and streaming RSC payloads, when the query is updated via `setQuery`.\n\n  // Indicate loading state\n  if (isLoading) return <div>Loading...</div>\n\n  // Normal rendering with data\n  return <div>...</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating nuqs Adapter - Remix - TSX\nDESCRIPTION: This snippet demonstrates integrating the `NuqsAdapter` into a Remix application. The adapter should wrap the `<Outlet />` component, typically within the root route file (`app/root.tsx`), to provide the nuqs context to all nested routes.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/adapters.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/remix'\n\n// ...\n\nexport default function App() {\n  return (\n    <NuqsAdapter>\n      <Outlet />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Returned Promises from setState\nDESCRIPTION: Demonstrates how to use the Promise returned by setState to know when URL updates have been applied, providing access to the updated URLSearchParams.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_23\n\nLANGUAGE: ts\nCODE:\n```\nconst randomCoordinates = React.useCallback(() => {\n  setLat(42)\n  return setLng(12)\n}, [])\n\nrandomCoordinates().then((search: URLSearchParams) => {\n  search.get('lat') // 42\n  search.get('lng') // 12, has been queued and batch-updated\n})\n```\n\n----------------------------------------\n\nTITLE: Type inference for parser return types using inferParserType\nDESCRIPTION: This snippet illustrates how to infer the TypeScript type of the value returned by a parser using 'inferParserType'. It shows examples with nullable and non-nullable parsers, as well as inferring types from objects of parsers, aiding in type safety and developer experience.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_31\n\nLANGUAGE: TypeScript\nCODE:\n```\n// inferParserType usage with parseAsInteger\nimport { parseAsInteger, type inferParserType } from 'nuqs'\n\nconst intNullable = parseAsInteger\nconst intNonNull = parseAsInteger.withDefault(0)\n\n// Types:\n// number | null\ntype NullableInt = inferParserType<typeof intNullable>\n// number\ntype NonNullInt = inferParserType<typeof intNonNull>\n\n// Inferring type over an object of parsers\nconst parsers = {\n  a: parseAsInteger,\n  b: parseAsBoolean.withDefault(false)\n}\n// Result type: { a: number | null, b: boolean }\ntype ParsedObject = inferParserType<typeof parsers>\n\n```\n\n----------------------------------------\n\nTITLE: Updating Multiple URL Query Keys with Call-Level Options Using nuqs useQueryStates in TypeScript\nDESCRIPTION: Demonstrates how to override parser and global options at the call-level when updating multiple URL query states managed by useQueryStates, specifically toggling the 'shallow' option to false during a batch update. Dependencies include React and nuqs. Inputs are object with keys and values plus optional second parameter for update options; output is updated URL with specified option behavior.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/batching.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nsetCoordinates(\n  {\n    lat: 42,\n    lng: 12\n  },\n  // [!code highlight:3]\n  {\n    shallow: false\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Updating startTransition Usage with shallow Option\nDESCRIPTION: Diff showing the required change to maintain server updates when using the startTransition option in nuqs v2.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/migrations/v2.mdx#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\nuseQueryState('q', {\n  startTransition: true,\n+ shallow: false\n})\n```\n\n----------------------------------------\n\nTITLE: JSON Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Demonstrates how to use the `parseAsJson` parser from `nuqs` for encoding JSON in the query string. It highlights the importance of providing a validation function, such as a Zod schema, to ensure the integrity and type safety of the parsed data. This example demonstrates creating a Zod schema and using its `parse` method as the validation function. It shows how to use `useQueryState` with `parseAsJson`.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsJson } from 'nuqs'\nimport { z } from 'zod'\n\nconst schema = z.object({\n  pkg: z.string(),\n  version: z.number(),\n  worksWith: z.array(z.string())\n})\n\n// This parser is a function, don't forget to call it with the parse function\n// as an argument.\n// [!code word:parseAsJson()]\nconst [json, setJson] = useQueryState('json', parseAsJson(schema.parse))\n\nsetJson({\n  pkg: 'nuqs',\n  version: 2,\n  worksWith: ['Next.js', 'React', 'Remix', 'React Router', 'and more']\n})\n```\n\n----------------------------------------\n\nTITLE: Array Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Shows how to use `parseAsArrayOf` in `nuqs` to parse arrays of a specific type from a search parameter. The example shows how to parse an array of integers using `parseAsArrayOf(parseAsInteger)` and demonstrates customizing the separator with `parseAsArrayOf(parseAsInteger, ';')`.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsArrayOf, parseAsInteger } from 'nuqs'\n\nparseAsArrayOf(parseAsInteger)\n\n// Optionally, customise the separator\nparseAsArrayOf(parseAsInteger, ';')\n```\n\n----------------------------------------\n\nTITLE: Configuring History Management in useQueryState\nDESCRIPTION: Shows how to configure the history mode for query state updates, either replacing the current history entry or pushing a new one. This affects browser Back button behavior.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_15\n\nLANGUAGE: ts\nCODE:\n```\n// Default: replace current history with new state\nuseQueryState('foo', { history: 'replace' })\n\n// Append state changes to history:\nuseQueryState('foo', { history: 'push' })\n```\n\n----------------------------------------\n\nTITLE: String Enum Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Illustrates how to use `parseAsStringEnum` in `nuqs` to handle string enums. The example showcases the declaration of a string enum, `Direction`, and how to parse it using `Object.values(Direction)` to get the enum's values.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nenum Direction {\n  up = 'UP',\n  down = 'DOWN',\n  left = 'LEFT',\n  right = 'RIGHT'\n}\n\nparseAsStringEnum<Direction>(Object.values(Direction))\n```\n\n----------------------------------------\n\nTITLE: Creating Serializer with createSerializer in TypeScript\nDESCRIPTION: This snippet demonstrates the basic usage of the `createSerializer` function. It takes an object describing search parameters and returns a function. This function takes an object with values for the described parameters, which are then rendered to a query string. The code imports various parsing functions from 'nuqs/server'. It creates a search params object defining the types of the parameters like `search`, `limit`, `from`, `to` and `sortBy`, and uses `createSerializer` to generate a serialize function. This is then called to generate a query string with the serialized search params.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/utilities.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  createSerializer,\n  parseAsInteger,\n  parseAsIsoDateTime,\n  parseAsString,\n  parseAsStringLiteral\n} from 'nuqs/server' // can also be imported from 'nuqs' in client code\n\nconst searchParams = {\n  search: parseAsString,\n  limit: parseAsInteger,\n  from: parseAsIsoDateTime,\n  to: parseAsIsoDateTime,\n  sortBy: parseAsStringLiteral(['asc', 'desc'] as const)\n}\n\n// Create a serializer function by passing the description of the search params to accept\nconst serialize = createSerializer(searchParams)\n\n// Then later, pass it some values (a subset) and render them to a query string\nserialize({\n  search: 'foo bar',\n  limit: 10,\n  from: new Date('2024-01-01'),\n  // here, we omit `to`, which won't be added\n  sortBy: null // null values are also not rendered\n})\n// ?search=foo+bar&limit=10&from=2024-01-01T00:00:00.000Z\n```\n\n----------------------------------------\n\nTITLE: Using NuqsTestingAdapter for Component Testing\nDESCRIPTION: Example of how to use the testing adapter to unit test components that use nuqs hooks, showing setup, actions, and assertions with Vitest and Testing Library.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/migrations/v2.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { NuqsTestingAdapter, type UrlUpdateEvent } from 'nuqs/adapters/testing'\nimport { describe, expect, it, vi } from 'vitest'\nimport { CounterButton } from './counter-button'\n\nit('should increment the count when clicked', async () => {\n  const user = userEvent.setup()\n  const onUrlUpdate = vi.fn<[UrlUpdateEvent]>()\n  render(<CounterButton />, {\n    // Setup the test by passing initial search params / querystring:\n    wrapper: ({ children }) => (\n      <NuqsTestingAdapter searchParams=\"?count=1\" onUrlUpdate={onUrlUpdate}>\n        {children}\n      </NuqsTestingAdapter>\n    )\n  })\n  // Act\n  const button = screen.getByRole('button')\n  await user.click(button)\n  // Assert changes in the state and in the (mocked) URL\n  expect(button).toHaveTextContent('count is 2')\n  expect(onUrlUpdate).toHaveBeenCalledOnce()\n  expect(onUrlUpdate.mock.calls[0][0].queryString).toBe('?count=2')\n  expect(onUrlUpdate.mock.calls[0][0].searchParams.get('count')).toBe('2')\n  expect(onUrlUpdate.mock.calls[0][0].options.history).toBe('push')\n})\n```\n\n----------------------------------------\n\nTITLE: Awaiting URLSearchParams Promise After Batched Updates with nuqs useQueryState in TypeScript\nDESCRIPTION: Illustrates how to await the Promise returned by useQueryState setter functions to know precisely when the URL has been updated and access the updated URLSearchParams object. Shows batching of updates inside a React callback and returns the Promise from the last setState call so outside code can handle completion. Requires React, nuqs, and asynchronous handling support. Input is the state update values; output is a Promise resolving to the URLSearchParams representing the current URL query state.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/batching.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst randomCoordinates = React.useCallback(() => {\n  setLat(42)\n  return setLng(12)\n}, [])\n\nrandomCoordinates().then((search: URLSearchParams) => {\n  search.get('lat') // 42\n  search.get('lng') // 12, has been queued and batch-updated\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Import Path from nuqs/parsers to nuqs/server\nDESCRIPTION: Diff showing how to update import paths from the renamed export nuqs/parsers to nuqs/server.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/migrations/v2.mdx#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n- import { parseAsInteger, createSearchParamsCache } from 'nuqs/parsers'\n+ import { parseAsInteger, createSearchParamsCache } from 'nuqs/server'\n```\n\n----------------------------------------\n\nTITLE: Using Transitions with useQueryState in React Server Components\nDESCRIPTION: Shows how to integrate with React's useTransition hook to handle loading states while server components re-render after URL updates.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport React from 'react'\nimport { useQueryState, parseAsString } from 'nuqs'\n\nfunction ClientComponent({ data }) {\n  // 1. Provide your own useTransition hook:\n  const [isLoading, startTransition] = React.useTransition()\n  const [query, setQuery] = useQueryState(\n    'query',\n    // 2. Pass the `startTransition` as an option:\n    parseAsString().withOptions({\n      startTransition,\n      shallow: false // opt-in to notify the server (Next.js only)\n    })\n  )\n  // 3. `isLoading` will be true while the server is re-rendering\n  // and streaming RSC payloads, when the query is updated via `setQuery`.\n\n  // Indicate loading state\n  if (isLoading) return <div>Loading...</div>\n\n  // Normal rendering with data\n  return <div>{/*...*/}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Parsers with Builder Pattern\nDESCRIPTION: Shows how to create custom parsers using the createParser function and compose them with existing parsers. Includes an example for hex color parsing.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_21\n\nLANGUAGE: ts\nCODE:\n```\nimport { createParser, parseAsHex } from 'nuqs'\n\n// Wrapping your parser/serializer in `createParser`\n// gives it access to the builder pattern & server-side\n// parsing capabilities:\nconst hexColorSchema = createParser({\n  parse(query) {\n    if (query.length !== 6) {\n      return null // always return null for invalid inputs\n    }\n    return {\n      // When composing other parsers, they may return null too.\n      r: parseAsHex.parse(query.slice(0, 2)) ?? 0x00,\n      g: parseAsHex.parse(query.slice(2, 4)) ?? 0x00,\n      b: parseAsHex.parse(query.slice(4)) ?? 0x00\n    }\n  },\n  serialize({ r, g, b }) {\n    return (\n      parseAsHex.serialize(r) +\n      parseAsHex.serialize(g) +\n      parseAsHex.serialize(b)\n    )\n  }\n})\n  // Eg: set common options directly\n  .withOptions({ history: 'push' })\n\n// Or on usage:\nuseQueryState(\n  'tribute',\n  hexColorSchema.withDefault({\n    r: 0x66,\n    g: 0x33,\n    b: 0x99\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Using a Loader in Remix/React Router\nDESCRIPTION: Shows how to use loadSearchParams in a Remix or React Router loader function to parse search parameters from the request object.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// [!code word:loadSearchParams]\nexport function loader({ request }: LoaderFunctionArgs) {\n  const { latitude, longitude } = loadSearchParams(request) // request.url works too\n  // Do some server-side calculations with the coordinates\n  return ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding canonical URL for SEO with Next.js metadata\nDESCRIPTION: This snippet sets up a canonical URL in Next.js metadata to prevent SEO crawlers from indexing query strings. For pages where query parameters define content, the canonical URL includes the relevant query string, maintaining SEO integrity.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_34\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Next.js metadata for canonical URL\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  alternates: {\n    canonical: '/url/path/without/querystring'\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using a Loader in Client-Side React\nDESCRIPTION: Demonstrates client-side usage of loadSearchParams for one-off parsing of non-reactive search parameters from various sources.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n// Note: you can also use this client-side (or anywhere, really),\n// for a one-off parsing of non-reactive search params:\n\nloadSearchParams('https://example.com?latitude=42&longitude=12')\nloadSearchParams(location.search)\nloadSearchParams(new URL(...))\nloadSearchParams(new URLSearchParams(...))\n```\n\n----------------------------------------\n\nTITLE: Installing nuqs with npm - Shell\nDESCRIPTION: This command illustrates installing the nuqs package via npm, the default Node.js package manager. The approach is compatible across most JavaScript and Node.js projects and requires npm installed globally. Successful execution will add nuqs to package.json; errors may occur if network or permissions fail.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/installation.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpm install nuqs\n```\n\n----------------------------------------\n\nTITLE: Using Shorter Search Params Keys with URL Mapping\nDESCRIPTION: Demonstrates how to use readable variable names in code while mapping them to shorter keys in the URL using the urlKeys configuration.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\nexport const coordinatesParsers = {\n  // Use human-readable variable names throughout your codebase\n  latitude: parseAsFloat.withDefault(45.18),\n  longitude: parseAsFloat.withDefault(5.72)\n}\nexport const coordinatesCache = createSearchParamsCache(coordinatesParsers, {\n  urlKeys: {\n    // Remap them to read from shorter keys in the URL\n    latitude: 'lat',\n    longitude: 'lng'\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Wrapping Client Component with Suspense for useQueryState\nDESCRIPTION: This TSX snippet shows how to wrap a client component (`Client`) that uses `useQueryState` within a `<Suspense>` boundary in its parent component (`Page`). The `'use client'` directive is added to the parent component as an immediate fix to resolve the 'Missing Suspense boundary' error in Next.js, although separating client/server components is preferred.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/troubleshooting.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { Suspense } from 'react';\nimport { useQueryState } from 'nuqs';\n\nexport default function Page() {\n  return (\n    <Suspense>\n      <Client />\n    </Suspense>\n  )\n}\n\nfunction Client() {\n  const [foo, setFoo] = useQueryState('foo')\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Updating localStorage.debug for nuqs v2\nDESCRIPTION: JavaScript code to run in the browser console to update your debug configuration for nuqs v2's logging system.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/migrations/v2.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nif (localStorage.debug) {\n  localStorage.debug = localStorage.debug.replace('next-usequerystate', 'nuqs')\n}\n```\n\n----------------------------------------\n\nTITLE: String Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Demonstrates how to use the `parseAsString` parser from `nuqs` to handle string-based search parameters, including setting default values and options.  It shows how to use the builder pattern to specify default values and options like `shallow: false`. This is useful when declaring a search params object.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsString } from 'nuqs'\n\nexport const searchParamsParsers = {\n  q: parseAsString.withDefault('').withOptions({\n    shallow: false\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Using NuqsTestingAdapter directly - Typescript\nDESCRIPTION: This snippet demonstrates the direct usage of the `NuqsTestingAdapter` component, wrapping a component that uses nuqs. It provides an alternative to the `withNuqsTestingAdapter` higher-order component.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/testing.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// [!code word:NuqsTestingAdapter]\nimport { NuqsTestingAdapter } from 'nuqs/adapters/testing'\n\n<NuqsTestingAdapter>\n  <ComponentsUsingNuqs/>\n</NuqsTestingAdapter>\n```\n\n----------------------------------------\n\nTITLE: Using useQueryState to set canonical URLs based on query params\nDESCRIPTION: This example shows how to generate a dynamic canonical URL in Next.js based on query parameters like 'v' for a video ID. It employs 'useQueryState' and schema parsing with 'parseAsString' to form the canonical URL, ensuring accurate URL indexing.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_35\n\nLANGUAGE: TypeScript\nCODE:\n```\n// generateMetadata with useQueryState\nimport type { Metadata, ResolvingMetadata } from 'next'\nimport { useQueryState } from 'nuqs'\nimport { parseAsString } from 'nuqs/server'\n\ntype Props = {\n  searchParams: { [key: string]: string | string[] | undefined }\n}\n\nexport async function generateMetadata({\n  searchParams\n}: Props): Promise<Metadata> {\n  const videoId = parseAsString.parseServerSide(searchParams.v)\n  return {\n    alternates: {\n      canonical: `/watch?v=${videoId}`\n    }\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Persisting Default Values in URL with nuqs (TypeScript)\nDESCRIPTION: Demonstrates how to configure `useQueryState` to keep the search parameter in the URL even when its value matches the `defaultValue`, by setting `clearOnDefault: false`. The default behavior is to remove the parameter.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nuseQueryState('search', {\n  defaultValue: '',\n  clearOnDefault: false\n})\n```\n\n----------------------------------------\n\nTITLE: Parsing Search Parameters Using Loader Functions\nDESCRIPTION: Demonstrates how to use the createLoader function for one-off parsing of search parameters from various input sources like strings, URL objects or Requests.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createLoader } from 'nuqs' // or 'nuqs/server'\n\nconst searchParams = {\n  q: parseAsString,\n  page: parseAsInteger.withDefault(1)\n}\n\nconst loadSearchParams = createLoader(searchParams)\n\nconst { q, page } = loadSearchParams('?q=hello&page=2')\n```\n\n----------------------------------------\n\nTITLE: Integrating nuqs Adapter - React Router v7 - TSX\nDESCRIPTION: This snippet demonstrates integrating the `NuqsAdapter` with React Router version 7. The adapter should wrap the `<Outlet />` component, typically in a layout route, similar to the Remix integration, to provide the nuqs context to nested routes. Ensure you import the adapter from `nuqs/adapters/react-router/v7`.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/adapters.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/react-router/v7'\nimport { Outlet } from 'react-router'\n\n// ...\n\nexport default function App() {\n  return (\n    <NuqsAdapter>\n      <Outlet />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Shallow Routing in nuqs (TypeScript)\nDESCRIPTION: Configures `useQueryState` to disable shallow routing by setting `shallow: false`. This causes updates to trigger server-side rendering or data fetching based on the new query parameters.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nuseQueryState('foo', { shallow: false })\n```\n\n----------------------------------------\n\nTITLE: Using Base Parameter with Serializer in TypeScript\nDESCRIPTION: This snippet demonstrates the usage of a base parameter in the `serialize` function. The base parameter is used to append or amend the search parameters to a given URL or search string. It shows how to serialize search parameters to various inputs like a string, `URLSearchParams` object, and a `URL` object, as well as how passing `null` removes existing values. It uses the `serialize` function (obtained from `createSerializer`) and provides it with a base URL or URLSearchParams, along with an object of search params.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/utilities.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nserialize('/path?baz=qux', { foo: 'bar' }) // /path?baz=qux&foo=bar\n\nconst search = new URLSearchParams('?baz=qux')\nserialize(search, { foo: 'bar' }) // ?baz=qux&foo=bar\n\nconst url = new URL('https://example.com/path?baz=qux')\nserialize(url, { foo: 'bar' }) // https://example.com/path?baz=qux&foo=bar\n\n// Passing null removes existing values\nserialize('?remove=me', { foo: 'bar', remove: null }) // ?foo=bar\n```\n\n----------------------------------------\n\nTITLE: Integrating nuqs Adapter - React Router v6 - TSX\nDESCRIPTION: This snippet shows how to integrate the `NuqsAdapter` with React Router version 6. The adapter should wrap the `RouterProvider` component, which provides the router context to the application. Only `BrowserRouter` is currently supported.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/adapters.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/react-router/v6'\nimport { createBrowserRouter, RouterProvider } from 'react-router-dom'\nimport App from './App'\n\nconst router = createBrowserRouter([\n  {\n    path: '/',\n    element: <App />\n  }\n])\n\nexport function ReactRouter() {\n  return (\n    <NuqsAdapter>\n      <RouterProvider router={router} />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logs in localStorage - JavaScript\nDESCRIPTION: This code snippet demonstrates how to enable debug logs for the `nuqs` library in the browser. It sets the `debug` item in `localStorage` to `nuqs`. Upon page reload, log lines will be prefixed with `[nuqs]` or `[nuq+]` depending on which function is used.  This is for debugging purposes.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/debugging.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// In your devtools:\nlocalStorage.setItem('debug', 'nuqs')\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in Remix\nDESCRIPTION: This snippet demonstrates how to include the NuqsAdapter in your Remix root component to provide the necessary context for nuqs hooks.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// app/root.tsx\nimport { NuqsAdapter } from 'nuqs/adapters/remix'\n\n// ...\n\nexport default function App() {\n  return (\n    <NuqsAdapter>\n      <Outlet />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding History Mode in setState\nDESCRIPTION: Demonstrates how to override the history mode when updating state, regardless of the mode specified when creating the hook.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nconst [query, setQuery] = useQueryState('q', { history: 'push' })\n\n// This overrides the hook declaration setting:\nsetQuery(null, { history: 'replace' })\n```\n\n----------------------------------------\n\nTITLE: Using Search Params Cache in Next.js Page Component\nDESCRIPTION: Demonstrates how to use searchParamsCache in a Next.js page component to parse search parameters and access them in both the page and nested components.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { searchParamsCache } from './searchParams'\nimport { type SearchParams } from 'nuqs/server'\n\ntype PageProps = {\n  searchParams: Promise<SearchParams> // Next.js 15+: async searchParams prop\n}\n\nexport default async function Page({ searchParams }: PageProps) {\n  // ⚠️ Don't forget to call `parse` here.\n  // You can access type-safe values from the returned object:\n  const { q: query } = await searchParamsCache.parse(searchParams)\n  return (\n    <div>\n      <h1>Search Results for {query}</h1>\n      <Results />\n    </div>\n  )\n}\n\nfunction Results() {\n  // Access type-safe search params in children server components:\n  const maxResults = searchParamsCache.get('maxResults')\n  return <span>Showing up to {maxResults} results</span>\n}\n```\n\n----------------------------------------\n\nTITLE: Using Optimistic Search Params in React Router/Remix (TSX)\nDESCRIPTION: Illustrates how to use `useOptimisticSearchParams` from `nuqs/adapters` in React Router or Remix applications. This hook provides read-only, reactive access to search parameters, reflecting shallow updates made by nuqs.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useOptimisticSearchParams } from 'nuqs/adapters/remix' // or '…/react-router/v6' or '…/react-router/v7'\n\nfunction Component() {\n  // Note: this is read-only, but reactive to all URL changes\n  const searchParams = useOptimisticSearchParams()\n  return <div>{searchParams.get('foo')}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Throttling URL Updates in useQueryState\nDESCRIPTION: Demonstrates how to configure throttling of URL updates to avoid browser rate-limiting issues when making frequent state changes.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_18\n\nLANGUAGE: ts\nCODE:\n```\nuseQueryState('foo', {\n  // Send updates to the server maximum once every second\n  shallow: false,\n  throttleMs: 1000\n})\n\n// You can also pass the option on calls to setState:\nsetState('bar', { throttleMs: 1000 })\n```\n\n----------------------------------------\n\nTITLE: Accessing Cache in Server Component\nDESCRIPTION: Demonstrates how to access the search params cache in a server component, both retrieving all values and accessing individual keys.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { coordinatesCache } from './searchParams'\n\nexport function Server() {\n  const { lat, lng } = coordinatesCache.all()\n  // or access keys individually:\n  const lat = coordinatesCache.get('lat')\n  const lng = coordinatesCache.get('lng')\n  return (\n    <span>\n      Latitude: {lat} - Longitude: {lng}\n    </span>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing nuqs with pnpm - Shell\nDESCRIPTION: Demonstrates how to install the nuqs package using pnpm, a fast, disk space-efficient package manager. Run this command in your project directory as a prerequisite for integrating nuqs into any compatible JavaScript framework. Expects pnpm to be installed globally; outputs package installation logs or errors.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/installation.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add nuqs\n```\n\n----------------------------------------\n\nTITLE: Configuring Parsers with Builder Pattern\nDESCRIPTION: Demonstrates the builder pattern for configuring parsers with default values and options in a fluent API style.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_20\n\nLANGUAGE: ts\nCODE:\n```\nuseQueryState(\n  'counter',\n  parseAsInteger.withDefault(0).withOptions({\n    history: 'push',\n    shallow: false\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Wrapping Root Layout with nuqs Adapter in TypeScript\nDESCRIPTION: This snippet demonstrates how to integrate the `NuqsAdapter` into the root layout of a One application. It imports the `NuqsAdapter` and wraps the `<Slot>` component, ensuring that the adapter is applied to all child routes. This allows the application to utilize the adapter functionality for managing query parameters.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/community-adapters/onejs.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n```tsx title=\"app/_layout.tsx\" /NuqsAdapter/\nimport { NuqsAdapter } from './nuqs-one-adapter'\nimport { Slot } from 'one'\n\nexport default function Layout() {\n  return (\n    <>\n      {typeof document !== 'undefined' && (\n        <>\n          <meta charSet=\"utf-8\" />\n          <meta httpEquiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n          <meta\n            name=\"viewport\"\n            content=\"width=device-width, initial-scale=1, maximum-scale=5\"\n          />\n          <link rel=\"icon\" href=\"/favicon.svg\" />\n        </>\n      )}\n      <NuqsAdapter>\n        <Slot />\n      </NuqsAdapter>\n    </>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Conflicting Parsers Issue with useQueryState\nDESCRIPTION: This TypeScript snippet demonstrates a potential issue where using different parsers (parseAsInteger, parseAsFloat) for the same query state key ('foo') can lead to unexpected behavior. The last update dictates the state for all hooks sharing the key, potentially causing type mismatches.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/troubleshooting.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst [int] = useQueryState('foo', parseAsInteger)\nconst [float, setFloat] = useQueryState('foo', parseAsFloat)\n\nsetFloat(1.234)\n\n// `int` is now 1.234, instead of 1\n```\n\n----------------------------------------\n\nTITLE: Reading and Setting Multiple Query Keys Simultaneously with nuqs useQueryStates Hook in TypeScript\nDESCRIPTION: Shows usage of the useQueryStates hook for managing multiple related URL query parameters as an object with typed parsers and default values, allowing batch updates and global options like history mode. Demonstrates destructuring to extract keys and an example of setting multiple keys atomically with a single update call. Inputs are an object with keys and new values; output is updated URLSearchParams after state setter returns. Requires nuqs library with parseAsFloat and React hooks support.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/batching.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { useQueryStates, parseAsFloat } from 'nuqs'\n\nconst [coordinates, setCoordinates] = useQueryStates(\n  {\n    lat: parseAsFloat.withDefault(45.18),\n    lng: parseAsFloat.withDefault(5.72)\n  },\n  {\n    history: 'push'\n  }\n)\n\nconst { lat, lng } = coordinates\n\n// Set all (or a subset of) the keys in one go:\nconst search = await setCoordinates({\n  lat: Math.random() * 180 - 90,\n  lng: Math.random() * 360 - 180\n})\n```\n\n----------------------------------------\n\nTITLE: Testing CounterButton Component with Vitest (v1) - Typescript\nDESCRIPTION: This example shows how to test a `CounterButton` component using Vitest and React Testing Library, utilizing `withNuqsTestingAdapter` to manage initial search parameters and track URL updates. It asserts that the counter increments upon a button click and verifies the corresponding changes in the URL.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/testing.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// [!code word:withNuqsTestingAdapter]\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { withNuqsTestingAdapter, type UrlUpdateEvent } from 'nuqs/adapters/testing'\nimport { describe, expect, it, vi } from 'vitest'\nimport { CounterButton } from './counter-button'\n\nit('should increment the count when clicked', async () => {\n  const user = userEvent.setup()\n  const onUrlUpdate = vi.fn<[UrlUpdateEvent]>()\n  render(<CounterButton />, {\n    // 1. Setup the test by passing initial search params / querystring:\n    wrapper: withNuqsTestingAdapter({ searchParams: '?count=42', onUrlUpdate })\n  })\n  // 2. Act\n  const button = screen.getByRole('button')\n  await user.click(button)\n  // 3. Assert changes in the state and in the (mocked) URL\n  expect(button).toHaveTextContent('count is 43')\n  expect(onUrlUpdate).toHaveBeenCalledOnce()\n  const event = onUrlUpdate.mock.calls[0][0]!\n  expect(event.queryString).toBe('?count=43')\n  expect(event.searchParams.get('count')).toBe('43')\n  expect(event.options.history).toBe('push')\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Parser (Star Rating) with nuqs (TypeScript)\nDESCRIPTION: Demonstrates how to create a custom parser for a 'star rating' data type using `nuqs.createParser`. The parser converts between a string representation using '★' characters and a numeric value representing the number of stars (clamped at 5). It requires implementing both a `parse` function (string to number) and a `serialize` function (number to string).\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/making-your-own.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createParser } from 'nuqs'\n\nconst parseAsStarRating = createParser({\n  parse(queryValue) {\n    const inBetween = queryValue.split('★')\n    const isValid = inBetween.length > 1 && inBetween.every(s => s === '')\n    if (!isValid) return null\n    const numStars = inBetween.length - 1\n    return Math.min(5, numStars)\n  },\n  serialize(value) {\n    return Array.from({length: value}, () => '★').join('')\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring nuqs Adapter - React SPA (Vite) - TSX\nDESCRIPTION: This snippet shows how to configure the `NuqsAdapter` in a React SPA (like one built with Vite) to perform a full-page navigation when a query state configured with `shallow: false` is updated. This option is useful for notifying a non-JavaScript backend server about URL changes for potential server-side rendering or routing.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/adapters.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ncreateRoot(document.getElementById('root')!).render(\n  <NuqsAdapter fullPageNavigationOnShallowFalseUpdates>\n    <App />\n  </NuqsAdapter>\n)\n```\n\n----------------------------------------\n\nTITLE: package.json script update for ESM with Jest - JSON\nDESCRIPTION: This snippet demonstrates how to modify the test script in package.json to include the `--experimental-vm-modules` flag when using Jest with ESM-only packages like nuqs.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/testing.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"test\": \"NODE_OPTIONS=\\\"$NODE_OPTIONS --experimental-vm-modules\\\" jest\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Scroll-to-Top on Update in nuqs (TypeScript)\nDESCRIPTION: Demonstrates configuring `useQueryState` to scroll the page to the top upon state updates by setting the `scroll: true` option. The default behavior is no scrolling.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nuseQueryState('foo', { scroll: true })\n```\n\n----------------------------------------\n\nTITLE: Using Shorter Keys with Serializer in TypeScript\nDESCRIPTION: This snippet demonstrates how to use shorter keys when creating a serializer. This is achieved by providing an `urlKeys` object to `createSerializer`. This allows you to map variable names, like `latitude`, `longitude`, and `zoomLevel` to shorter keys like `lat`, `lng`, and `z` respectively. The user defines variable names for their domain logic and the `urlKeys` object allows it to be remapped to shorter keys that can be used in the URL when calling the serializer function.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/utilities.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst serialize = createSerializer(\n  {\n    // 1. Use variable names that make sense for your domain/business logic\n    latitude: parseAsFloat,\n    longitude: parseAsFloat,\n    zoomLevel: parseAsInteger\n  },\n  {\n    // 2. Remap them to shorter keys in the URL\n    urlKeys: {\n      latitude: 'lat',\n      longitude: 'lng',\n      zoomLevel: 'z'\n    }\n  }\n)\n\n// 3. Use your variable names when calling the serializer,\n// and the shorter keys will be rendered in the URL:\nserialize({\n  latitude: 45.18,\n  longitude: 5.72,\n  zoomLevel: 12\n})\n// ?lat=45.18&lng=5.72&z=12\n```\n\n----------------------------------------\n\nTITLE: Using a Loader in Next.js Pages Router\nDESCRIPTION: Demonstrates how to use loadSearchParams in a Next.js pages router within getServerSideProps to access and process query parameters.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// [!code word:loadSearchParams]\nimport type { GetServerSidePropsContext } from 'next'\n\nexport async function getServerSideProps({ query }: GetServerSidePropsContext) {\n  const { latitude, longitude } = loadSearchParams(query)\n  // Do some server-side calculations with the coordinates\n  return {\n    props: { ... }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Batch Updating URL Query Parameters with nuqs useQueryState Hook in TypeScript\nDESCRIPTION: Demonstrates how to batch multiple updates to URL query parameters asynchronously within a single event loop tick using separate useQueryState hooks for 'lat' and 'lng'. It includes defining setters via useQueryState, performing simultaneous updates, and highlights that URL updates are applied async and batched. Dependencies include React and the nuqs library. Inputs are new coordinate values and outputs are updated URL params reflected in the browser address bar asynchronously.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/batching.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst MultipleQueriesDemo = () => {\n  const [lat, setLat] = useQueryState('lat', parseAsFloat)\n  const [lng, setLng] = useQueryState('lng', parseAsFloat)\n  const randomCoordinates = React.useCallback(() => {\n    setLat(Math.random() * 180 - 90)\n    setLng(Math.random() * 360 - 180)\n  }, [])\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Canonical URL Without Query Strings in Next.js App Router\nDESCRIPTION: This snippet demonstrates how to set a canonical URL in Next.js metadata to instruct search engines to ignore query strings for local-only state. It uses the Next.js app router metadata object to define a canonical URL without query parameters.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/seo.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Metadata } from 'next'\n\nexport const metadata: Metadata = {\n  alternates: {\n    canonical: '/url/path/without/querystring'\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing Multiple URL Search Parameters at Once Using nuqs useQueryStates Setter in TypeScript\nDESCRIPTION: Provides a succinct method to clear all managed query parameters by passing null to the useQueryStates setter function, which removes the specified keys from the URL while leaving unrelated search params untouched. Requires nuqs and React. Input is a null call to the setter, output is a URL query string with those keys removed.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/batching.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst clearAll = () => setCoordinates(null)\n```\n\n----------------------------------------\n\nTITLE: Configuring ESLint Parser Options for TypeScript Projects in JavaScript\nDESCRIPTION: This snippet demonstrates how to export a customized ESLint configuration using tseslint that specifies multiple TypeScript configuration files for type-aware lint rules. It sets the parserOptions property to include relevant tsconfig files and specifies the root directory using import.meta.dirname. Required dependencies include TypeScript, tseslint, ESLint, and optional configuration files ('tsconfig.node.json', 'tsconfig.app.json'). The configuration allows for advanced linting rules, expecting input as an array of tsconfig paths, and outputs an ESLint-ready configuration object. Ensure all referenced tsconfig files exist in the project.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react-router/v6/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default tseslint.config({\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using Shared Parser Definitions in Client Component\nDESCRIPTION: Shows how to use the shared parser definitions with useQueryStates in a client component for type-safe search param handling.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { useQueryStates } from 'nuqs'\nimport { coordinatesParsers } from './searchParams'\n\nexport function Client() {\n  const [{ lat, lng }, setCoordinates] = useQueryStates(coordinatesParsers)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Numeric Literal Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Explains how to use the `parseAsNumberLiteral` parser in `nuqs` to restrict the allowed values of a numeric search parameter to a predefined set of numeric literals. The example defines the accepted values as a `const` array with `as const` and passes it to the parser.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsNumberLiteral } from 'nuqs'\n\n// List accepted values\nconst diceSides = [1, 2, 3, 4, 5, 6] as const\n\n// Then pass it to the parser\nparseAsNumberLiteral(diceSides)\n```\n\n----------------------------------------\n\nTITLE: Throttling nuqs URL Updates (TSX)\nDESCRIPTION: Shows how to throttle URL updates by setting the `throttleMs` option in `useQueryState`. This example combines it with `shallow: false` to limit server requests to once per second.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nuseQueryState('foo', {\n  // Send updates to the server maximum once every second\n  shallow: false,\n  throttleMs: 1000\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a server-side searchParams cache for nested components\nDESCRIPTION: This snippet illustrates defining additional parsers for complex parameters like 'lat' and 'lng', creating a cache, and sharing it between server and client components. It shows parsing on server-side and accessing search params within nested components.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_28\n\nLANGUAGE: TypeScript\nCODE:\n```\n// searchParams.ts\nimport { parseAsFloat, createSearchParamsCache } from 'nuqs/server'\n\nexport const coordinatesParsers = {\n  lat: parseAsFloat.withDefault(45.18),\n  lng: parseAsFloat.withDefault(5.72)\n}\nexport const coordinatesCache = createSearchParamsCache(coordinatesParsers)\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n// page.tsx\nimport { coordinatesCache } from './searchParams'\nimport { Server } from './server'\nimport { Client } from './client'\n\nexport default async function Page({ searchParams }) {\n  await coordinatesCache.parse(searchParams)\n  return (\n    <> \n      <Server />\n      <Suspense>\n        <Client />\n      </Suspense>\n    </>\n  )\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n// server.tsx\nimport { coordinatesCache } from './searchParams'\n\nexport function Server() {\n  const { lat, lng } = coordinatesCache.all()\n  const latVal = coordinatesCache.get('lat')\n  const lngVal = coordinatesCache.get('lng')\n  return (\n    <span>\n      Latitude: {latVal} - Longitude: {lngVal}\n    </span>\n  )\n}\n\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n// client.tsx\n// prettier-ignore\n;'use client'\n\nimport { useQueryStates } from 'nuqs'\nimport { coordinatesParsers } from './searchParams'\n\nexport function Client() {\n  const [{ lat, lng }, setCoordinates] = useQueryStates(coordinatesParsers)\n  // Implementation details here\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating nuqs Adapter for One in TypeScript\nDESCRIPTION: This snippet defines a custom adapter for the nuqs library to integrate with the One framework. It uses the `unstable_createAdapterProvider` function from 'nuqs/adapters/custom' to create a provider and implements the necessary logic for managing URL parameters. It fetches the active parameters from `one` and updates the URL using `router.push` or `router.replace` based on history options.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/community-adapters/onejs.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n```tsx title=\"app/nuqs-one-adapter.tsx\"\nimport {\n  type unstable_AdapterOptions as AdapterOptions,\n  unstable_createAdapterProvider as createAdapterProvider,\n  renderQueryString\n} from 'nuqs/adapters/custom'\nimport { useActiveParams, useRouter } from 'one'\n\nfunction useNuqsOneAdapter() {\n  const router = useRouter()\n  const searchParams = new URLSearchParams(useActiveParams() as {})\n  const updateUrl = (search: URLSearchParams, options: AdapterOptions) => {\n    if (options.history === 'push') {\n      router.push(renderQueryString(search), {\n        scroll: options.scroll\n      })\n    } else {\n      router.replace(renderQueryString(search), {\n        scroll: options.scroll\n      })\n    }\n  }\n  return {\n    searchParams,\n    updateUrl\n  }\n}\n\nexport const NuqsAdapter = createAdapterProvider(useNuqsOneAdapter)\n\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling History Push in nuqs (TypeScript)\nDESCRIPTION: Configures `useQueryState` to push a new browser history entry for each state change using the `history: 'push'` option. This allows users to navigate back through state updates.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nuseQueryState('foo', { history: 'push' })\n```\n\n----------------------------------------\n\nTITLE: Using createSerializer to generate URL query strings from search parameters\nDESCRIPTION: This example demonstrates creating a serializer function with 'createSerializer' by defining search parameter parsers. The serializer converts parameter values into URL query strings, omitting nulls or undefined values, which can then be used to set link URLs with state.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_29\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Serializer creation with parameter definitions\nimport {\n  createSerializer,\n  parseAsInteger,\n  parseAsIsoDateTime,\n  parseAsString,\n  parseAsStringLiteral\n} from 'nuqs/server'\n\nconst searchParams = {\n  search: parseAsString,\n  limit: parseAsInteger,\n  from: parseAsIsoDateTime,\n  to: parseAsIsoDateTime,\n  sortBy: parseAsStringLiteral(['asc', 'desc'] as const)\n}\n\nconst serialize = createSerializer(searchParams)\n\nserialize({\n  search: 'foo bar',\n  limit: 10,\n  from: new Date('2024-01-01'),\n  // 'to' omitted\n  sortBy: null\n})\n// Produces: ?search=foo+bar&limit=10&from=2024-01-01T00:00:00.000Z\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Server-Side Rendering with Shallow Option\nDESCRIPTION: Shows how to control whether query updates notify the server for Next.js applications. Controls re-running getServerSideProps or re-rendering Server Components.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_17\n\nLANGUAGE: ts\nCODE:\n```\nconst [state, setState] = useQueryState('foo', { shallow: false })\n\n// You can also pass the option on calls to setState:\nsetState('bar', { shallow: false })\n```\n\n----------------------------------------\n\nTITLE: Creating a serializer with a base URL or path\nDESCRIPTION: This snippet shows how to generate a URL query string by appending search parameters to a base URL or path. The 'serialize' function can accept a string, URLSearchParams, or URL object as the base, and merge the provided parameters accordingly. Null values remove existing parameters.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_30\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Using string base\nserialize('/path?baz=qux', { foo: 'bar' }) // /path?baz=qux&foo=bar\n\n// Using URLSearchParams\nconst search = new URLSearchParams('?baz=qux')\nserialize(search, { foo: 'bar' }) // ?baz=qux&foo=bar\n\n// Using URL object\nconst url = new URL('https://example.com/path?baz=qux')\nserialize(url, { foo: 'bar' }) // https://example.com/path?baz=qux&foo=bar\n\n// Removing parameter with null\nserialize('?remove=me', { foo: 'bar', remove: null }) // ?foo=bar\n\n```\n\n----------------------------------------\n\nTITLE: Defining Equality Check for Custom nuqs Parsers (TypeScript)\nDESCRIPTION: Shows how to provide a custom equality function (`eq`) within a `createParser` definition. This is necessary for the `clearOnDefault` option to work correctly with complex state types that require non-reference equality checks, such as Date objects.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst dateParser = createParser({\n  parse: (value: string) => new Date(value.slice(0, 10)),\n  serialize: (date: Date) => date.toISOString().slice(0, 10),\n  eq: (a: Date, b: Date) => a.getTime() === b.getTime() // [!code highlight]\n})\n```\n\n----------------------------------------\n\nTITLE: Hexadecimal Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Demonstrates how to use the `parseAsHex` parser from `nuqs` to encode integers in hexadecimal format. It sets a default hexadecimal value of `0x00` using `.withDefault()` when using `useQueryState`.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsHex } from 'nuqs'\n\nuseQueryState('hex', parseAsHex.withDefault(0x00))\n```\n\n----------------------------------------\n\nTITLE: Unit Testing React Components with Nuqs Testing Adapter - TypeScript\nDESCRIPTION: Illustrates usage of the NuqsTestingAdapter in combination with Vitest and React Testing Library for unit testing React components that consume Nuqs hooks. The test sets initial URL search params (`?count=42`), renders the component inside the testing adapter wrapper, simulates a user click on a button, and asserts that both the component's UI and the mocked URL state update correctly. The adapter supports mocking URL behavior and capturing URL update events, enabling isolated component tests unrelated to routing frameworks. Key parameters include `searchParams` (initial URL query string) and `onUrlUpdate` callback to monitor URL changes.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/blog/nuqs-2.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { NuqsTestingAdapter, type UrlUpdateEvent } from 'nuqs/adapters/testing'\nimport { describe, expect, it, vi } from 'vitest'\nimport { CounterButton } from './counter-button'\n\nit('should increment the count when clicked', async () => {\n  const user = userEvent.setup()\n  const onUrlUpdate = vi.fn<[UrlUpdateEvent]>()\n  render(<CounterButton />, {\n    // 1. Setup the test by passing initial search params / querystring:\n    wrapper: ({ children }) => (\n      <NuqsTestingAdapter searchParams=\"?count=42\" onUrlUpdate={onUrlUpdate}>\n        {children}\n      </NuqsTestingAdapter>\n    )\n  })\n  // 2. Act\n  const button = screen.getByRole('button')\n  await user.click(button)\n  // 3. Assert changes in the state and in the (mocked) URL\n  expect(button).toHaveTextContent('count is 43')\n  expect(onUrlUpdate).toHaveBeenCalledOnce()\n  expect(onUrlUpdate.mock.calls[0][0].queryString).toBe('?count=43')\n  expect(onUrlUpdate.mock.calls[0][0].searchParams.get('count')).toBe('43')\n  expect(onUrlUpdate.mock.calls[0][0].options.history).toBe('push')\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in Next.js App Router\nDESCRIPTION: Code example showing how to wrap a Next.js app router application with the NuqsAdapter component to enable nuqs v2 functionality.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/migrations/v2.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/next/app'\nimport { type ReactNode } from 'react'\n\nexport default function RootLayout({\n  children\n}: {\n  children: ReactNode\n}) {\n  return (\n    <html>\n      <body>\n        <NuqsAdapter>{children}</NuqsAdapter>\n      </body>\n    </html>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Waku Layout with NuqsAdapter (TSX)\nDESCRIPTION: This snippet demonstrates how to integrate the custom `NuqsAdapter` into a Waku application's root layout. By wrapping the main application content (`{children}`) with `<NuqsAdapter>`, it ensures that `nuqs` can manage query parameters and interact with the Waku router across the application. It also includes standard layout setup and Waku's `getConfig` for rendering configuration.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/community-adapters/waku.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Suspense, type ReactNode } from 'react';\n\nimport { NuqsAdapter } from './nuqs-waku-adapter'\n\ntype LayoutProps = { children: ReactNode };\n\nexport default async function Layout({ children }: LayoutProps) {\n  return (\n      <>\n        <NuqsAdapter>\n          <Suspense>\n            {children}\n          </Suspense>\n        </NuqsAdapter>\n      </>\n  );\n}\n\nexport const getConfig = async () => {\n  return {\n    render: 'dynamic',\n    // render: 'static', // works but can cause hydration warnings\n  } as const;\n};\n\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in Next.js Pages Router\nDESCRIPTION: Code example showing how to wrap a Next.js pages router application with the NuqsAdapter component to enable nuqs v2 functionality.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/migrations/v2.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AppProps } from 'next/app'\nimport { NuqsAdapter } from 'nuqs/adapters/next/pages'\n\nexport default function MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <NuqsAdapter>\n      <Component {...pageProps} />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Testing custom parsers - Typescript\nDESCRIPTION: This snippet demonstrates how to test custom parsers created with `createParser` from nuqs using the provided testing utilities `isParserBijective`, `testParseThenSerialize`, and `testSerializeThenParse`.  It ensures bijectivity by verifying that parsing and then serializing a value returns the original value, and vice versa.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/testing.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  isParserBijective,\n  testParseThenSerialize,\n  testSerializeThenParse\n} from 'nuqs/testing'\n\nit('is bijective', () => {\n  // Passing tests return true\n  expect(isParserBijective(parseAsInteger, '42', 42)).toBe(true)\n  // Failing test throws an error\n  expect(() => isParserBijective(parseAsInteger, '42', 47)).toThrowError()\n\n  // You can also test either side separately:\n  expect(testParseThenSerialize(parseAsInteger, '42')).toBe(true)\n  expect(testSerializeThenParse(parseAsInteger, 42)).toBe(true)\n  // Those will also throw an error if the test fails,\n  // which makes it easier to isolate which side failed:\n  expect(() => testParseThenSerialize(parseAsInteger, 'not a number')).toThrowError()\n  expect(() => testSerializeThenParse(parseAsInteger, NaN)).toThrowError()\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Waku Adapter for nuqs (TSX)\nDESCRIPTION: This snippet implements the `useNuqsAdapter` hook, which provides the necessary interface for `nuqs` to manage URL state within a Waku application. It uses Waku's `useRouter` hook to access path and query information and update the URL, handling both deep and shallow updates, and manually manages scrolling behaviour.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/community-adapters/waku.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n\"use client\";\n\nimport {\n  type unstable_AdapterOptions as AdapterOptions,\n  unstable_createAdapterProvider as createAdapterProvider,\n  renderQueryString,\n} from \"nuqs/adapters/custom\";\n// import { useRouter_UNSTABLE as useRouter } from \"waku\";\n// if waku v0.22 or later:\nimport { useRouter } from \"waku\";\n\nfunction useNuqsAdapter() {\n  const { path, query, push, replace } = useRouter();\n  const searchParams = new URLSearchParams(query);\n  const updateUrl = (search: URLSearchParams, options: AdapterOptions) => {\n    const query = renderQueryString(search);\n    const url = path + query + location.hash;\n    if (options.shallow) {\n      options.history === \"push\"\n        ? history.pushState(null, \"\", url)\n        : history.replaceState(null, \"\", url);\n    } else {\n      const updateMethod = options.history === \"push\" ? push : replace;\n      // bypass waku's typesafe route check by using `as never`\n      updateMethod(url as never);\n    }\n    // Waku router does not scroll unless the pathname changes\n    if (options.scroll) {\n      window.scrollTo(0, 0);\n    }\n  };\n  return {\n    searchParams,\n    updateUrl,\n  };\n}\n\nexport const NuqsAdapter = createAdapterProvider(useNuqsAdapter);\n\n\n```\n\n----------------------------------------\n\nTITLE: Parsing and Accessing Search Params Cache with nuqs in a Next.js Page (TypeScript/TSX)\nDESCRIPTION: This TypeScript/TSX snippet demonstrates initializing a search params cache using nuqs's createSearchParamsCache and parsing incoming search parameters in a Next.js server component. It shows the required dependencies from 'nuqs/server', including parseAsInteger and parseAsString, and how to set up default values for parameters. The Page function expects a searchParams prop (as a Promise<SearchParams>), and parses them before rendering. The Results child component accesses cache values using the get method, which presumes that parsing occurred at the top-level component. All components require nuqs to be installed and follow Next.js server component patterns; input is the searchParams object, and output is rendered UI with correct state.\nSOURCE: https://github.com/47ng/nuqs/blob/next/errors/NUQS-500.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// page.tsx\nimport {\n  createSearchParamsCache,\n  parseAsInteger,\n  parseAsString,\n  type SearchParams\n} from 'nuqs/server'\n\nconst cache = createSearchParamsCache({\n  q: parseAsString,\n  maxResults: parseAsInteger.withDefault(10)\n})\n\nexport default function Page({\n  searchParams\n}: {\n  searchParams: Promise<SearchParams>\n}) {\n  // ⚠️ Don't forget to call `parse` here:\n  const { q: query } = await cache.parse(searchParams)\n  return (\n    <div>\n      <h1>Search Results for {query}</h1>\n      <Results />\n    </div>\n  )\n}\n\nfunction Results() {\n  // In order to get search params from child server components:\n  const maxResults = cache.get('maxResults')\n  return <span>Showing up to {maxResults} results</span>\n}\n```\n\n----------------------------------------\n\nTITLE: Jest Configuration for ESM - Typescript\nDESCRIPTION: This snippet shows the configuration needed in jest.config.ts to support ESM modules when using nuqs. It extends the file extensions to treat as ESM and disables transforms.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/testing.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst config: Config = {\n  // <Other options here>\n  // [!code highlight:2]\n  extensionsToTreatAsEsm: [\".ts\", \".tsx\"],\n  transform: {}\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a type-safe searchParams cache in TypeScript using Nuqs\nDESCRIPTION: This snippet demonstrates how to import Nuqs server utilities, define a cache for specific search parameters with default parsers, and export it for use in Next.js server components. It enables type-safe parsing of query parameters like 'q' and 'maxResults'.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\n// searchParams.ts\nimport {\n  createSearchParamsCache,\n  parseAsInteger,\n  parseAsString\n} from 'nuqs/server'\n\n// Define a cache for search parameters with default values and types\nexport const searchParamsCache = createSearchParamsCache({\n  // 'q' expects a string, defaulting to empty string\n  q: parseAsString.withDefault(''),\n  // 'maxResults' expects an integer, defaulting to 10\n  maxResults: parseAsInteger.withDefault(10)\n})\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Parsers with useQueryState\nDESCRIPTION: This TypeScript snippet demonstrates using various built-in parsers provided by nuqs to handle different data types (integer, float, boolean, Date, array, JSON, enums, literals) when reading from and writing to query parameters.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  parseAsString,\n  parseAsInteger,\n  parseAsFloat,\n  parseAsBoolean,\n  parseAsTimestamp,\n  parseAsIsoDateTime,\n  parseAsArrayOf,\n  parseAsJson,\n  parseAsStringEnum,\n  parseAsStringLiteral,\n  parseAsNumberLiteral\n} from 'nuqs'\n\nuseQueryState('tag') // defaults to string\nuseQueryState('count', parseAsInteger)\nuseQueryState('brightness', parseAsFloat)\nuseQueryState('darkMode', parseAsBoolean)\nuseQueryState('after', parseAsTimestamp) // state is a Date\nuseQueryState('date', parseAsIsoDateTime) // state is a Date\nuseQueryState('array', parseAsArrayOf(parseAsInteger)) // state is number[]\nuseQueryState('json', parseAsJson<Point>()) // state is a Point\n\n// Enums (string-based only)\nenum Direction {\n  up = 'UP',\n  down = 'DOWN',\n  left = 'LEFT',\n  right = 'RIGHT'\n}\n\nconst [direction, setDirection] = useQueryState(\n  'direction',\n  parseAsStringEnum<Direction>(Object.values(Direction)) // pass a list of allowed values\n    .withDefault(Direction.up)\n)\n\n// Literals (string-based only)\nconst colors = ['red', 'green', 'blue'] as const\n\nconst [color, setColor] = useQueryState(\n  'color',\n  parseAsStringLiteral(colors) // pass a readonly list of allowed values\n    .withDefault('red')\n)\n\n// Literals (number-based only)\nconst diceSides = [1, 2, 3, 4, 5, 6] as const\n\nconst [side, setSide] = useQueryState(\n  'side',\n  parseAsNumberLiteral(diceSides) // pass a readonly list of allowed values\n    .withDefault(4)\n)\n```\n\n----------------------------------------\n\nTITLE: Migrating from queryTypes to Individual Parser Exports\nDESCRIPTION: Diff showing how to migrate from the deprecated queryTypes object to the individual parseAsXYZ functions for better tree-shaking.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/migrations/v2.mdx#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n- import { queryTypes } from 'nuqs'\n+ import { parseAsString, parseAsInteger, ... } from 'nuqs'\n\n- useQueryState('q',    queryTypes.string.withOptions({ ... }))\n- useQueryState('page', queryTypes.integer.withDefault(1))\n+ useQueryState('q',    parseAsString.withOptions({ ... }))\n+ useQueryState('page', parseAsInteger.withDefault(1))\n```\n\n----------------------------------------\n\nTITLE: Configuring nuqs Hook with Options (TypeScript)\nDESCRIPTION: Demonstrates how to configure `nuqs` options at the hook initialization level using the `withOptions` builder pattern on a parser. This example sets the `history` option to 'push'.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst [state, setState] = useQueryState(\n  'foo',\n  parseAsString.withOptions({ history: 'push' })\n)\n```\n\n----------------------------------------\n\nTITLE: Remapping Variables to Short URL Keys with urlKeys Option in nuqs useQueryStates Hook in TypeScript\nDESCRIPTION: Shows how to use the urlKeys option in useQueryStates to map descriptive variable names to shorter, URL-friendly query parameter keys, improving readability in code while keeping URLs compact. This maintains setter API consistency but changes how parameters appear in the actual URL. Inputs are parsers object with defaults and urlKeys mapping; output is URL with remapped search keys.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/batching.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst [{ latitude, longitude }, setCoordinates] = useQueryStates(\n  {\n    // Use variable names that make sense in your codebase\n    latitude: parseAsFloat.withDefault(45.18),\n    longitude: parseAsFloat.withDefault(5.72)\n  },\n  {\n    urlKeys: {\n      // And remap them to shorter keys in the URL\n      latitude: 'lat',\n      longitude: 'lng'\n    }\n  }\n)\n\n// No changes in the setter API, but the keys are remapped to:\n// ?lat=45.18&lng=5.72\nsetCoordinates({\n  latitude: 45.18,\n  longitude: 5.72\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Content-Defining Query Strings in Next.js Canonical URLs with nuqs\nDESCRIPTION: This example shows how to properly handle SEO for pages where query strings define content, similar to YouTube's watch URLs. It uses nuqs to parse a YouTube video ID from query parameters and includes it in the canonical URL while validating its format.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/seo.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Metadata, ResolvingMetadata } from 'next'\nimport { notFound } from \"next/navigation\";\nimport { createParser, parseAsString, type SearchParams } from 'nuqs/server'\n\ntype Props = {\n  searchParams: Promise<SearchParams>\n}\n\n// Normally you'd reuse custom parsers across your application,\n// but for this example we'll define it here.\nconst youTubeVideoIdRegex = /^[^\"&?\\/\\s]{11}$/i\nconst parseAsYouTubeVideoId = createParser({\n  parse(query) {\n    if (!youTubeVideoIdRegex.test(query)) {\n      return null\n    }\n    return query\n  },\n  serialize(videoId) {\n    return videoId\n  }\n})\n\nexport async function generateMetadata({\n  searchParams\n}: Props): Promise<Metadata> {\n  const videoId = parseAsYouTubeVideoId.parseServerSide((await searchParams).v)\n  if (!videoId) {\n    notFound()\n  }\n  return {\n    alternates: {\n      canonical: `/watch?v=${videoId}`\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Nuqs components with Testing Library and Vitest\nDESCRIPTION: This example demonstrates how to test components that use 'useQueryStates' or 'useQueryState' by wrapping them with 'NuqsTestingAdapter'. It setups initial search params, simulates user actions, and verifies URL and component state updates, facilitating isolated testing of state-dependent components.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_32\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Test setup using Testing Library and Vitest\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { NuqsTestingAdapter, type UrlUpdateEvent } from 'nuqs/adapters/testing'\nimport { describe, expect, it, vi } from 'vitest'\nimport { CounterButton } from './counter-button'\n\nit('should increment the count when clicked', async () => {\n  const user = userEvent.setup()\n  const onUrlUpdate = vi.fn<[UrlUpdateEvent]>()\n  render(<CounterButton />, {\n    wrapper: ({ children }) => (\n      <NuqsTestingAdapter searchParams=\"?count=42\" onUrlUpdate={onUrlUpdate}>\n        {children}\n      </NuqsTestingAdapter>\n    )\n  })\n  // Initial state assertions\n  const button = screen.getByRole('button')\n  expect(button).toHaveTextContent('count is 42')\n  await user.click(button)\n  // Verify state and URL updates\n  expect(button).toHaveTextContent('count is 43')\n  expect(onUrlUpdate).toHaveBeenCalledOnce()\n  expect(onUrlUpdate.mock.calls[0][0].queryString).toBe('?count=43')\n  expect(onUrlUpdate.mock.calls[0][0].searchParams.get('count')).toBe('43')\n  expect(onUrlUpdate.mock.calls[0][0].options.history).toBe('push')\n})\n\n```\n\n----------------------------------------\n\nTITLE: Creating Dedicated Hook to Avoid Parser Conflicts\nDESCRIPTION: This TypeScript snippet presents the recommended solution to avoid parser conflicts. It defines a custom hook `useIntFloat` that manages a single query state key ('foo') with a consistent parser (parseAsFloat). Other desired formats (like integer) are derived from the parsed float value within the hook.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/troubleshooting.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useIntFloat() {\n  const [float, setFloat] = useQueryState('foo', parseAsFloat)\n  const int = Math.floor(float)\n  return [{int, float}, setFloat] as const\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Null State from Parsers without Default in TSX\nDESCRIPTION: This snippet illustrates the challenge of updating state (`count`) retrieved using `useQueryState` with a parser (`parseAsInteger`) when no value is present in the URL (resulting in `null`). It shows how state updates (`setCount`) must explicitly handle the potential `null` value using the nullish coalescing operator (`??`). Requires `useQueryState` and `parseAsInteger` from `nuqs`.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/basic-usage.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQueryState, parseAsInteger } from 'nuqs'\n\nexport default () => {\n  const [count, setCount] = useQueryState('count', parseAsInteger)\n  return (\n    <>\n      <pre>count: {count}</pre>\n      <button onClick={() => setCount(0)}>Reset</button>\n      {/* handling null values in setCount is annoying: */}\n      <button onClick={() => setCount(c => (c ?? 0) + 1)}>+</button>\n      <button onClick={() => setCount(c => (c ?? 0) - 1)}>-</button>\n      <button onClick={() => setCount(null)}>Clear</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Lossy Parser (Geo Coordinate) with nuqs (TypeScript)\nDESCRIPTION: Illustrates a custom parser for a geographic coordinate that uses a potentially 'lossy' serializer. The `parse` function uses `parseFloat` to convert the string to a number, while the `serialize` function uses `toFixed(4)` to format the number, losing precision. This snippet also shows how such a parser would be used with `useQueryState` and highlights the issue where reloading the page will parse the less precise serialized value from the URL.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/making-your-own.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst geoCoordParser = {\n  parse: parseFloat,\n  serialize: v => v.toFixed(4) // Loses precision\n}\n\nconst [lat, setLat] = useQueryState('lat', geoCoordParser)\n```\n\n----------------------------------------\n\nTITLE: Initializing Nuqs React Adapter in a React SPA - TypeScript\nDESCRIPTION: Demonstrates how to wrap a React application with the Nuqs Adapter for React SPA environments using TypeScript. This adapter makes Nuqs hooks universal and compatible across frameworks like Next.js, Remix, and React Router, with zero code changes inside components. The code imports NuqsAdapter from 'nuqs/adapters/react' and mounts it as a parent component around the root React app. It assumes React 18+ and a React SPA environment configured with Vite or similar tooling.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/blog/nuqs-2.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { NuqsAdapter } from 'nuqs/adapters/react'\n\ncreateRoot(document.getElementById('root')!).render(\n  <NuqsAdapter>\n    <App />\n  </NuqsAdapter>\n)\n```\n\n----------------------------------------\n\nTITLE: Inferring Type from Parser Object with TypeScript\nDESCRIPTION: This snippet shows how to use `inferParserType` with an object describing parsers. It imports various functions and types from the `nuqs` library, defines an object named `parsers` containing parsers for `a` and `b`. This object is then passed to `inferParserType`, and the resulting type, which will be the original object's type with the parsers replaced by the types of the parsed values, is inferred.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/utilities.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  parseAsBoolean,\n  parseAsInteger,\n  type inferParserType\n} from 'nuqs' // or 'nuqs/server'\n\nconst parsers = {\n  a: parseAsInteger,\n  b: parseAsBoolean.withDefault(false)\n}\n\ninferParserType<typeof parsers>\n// { a: number | null, b: boolean }\n```\n\n----------------------------------------\n\nTITLE: Integrating React ESLint Plugin in tseslint Configuration (JavaScript)\nDESCRIPTION: This JavaScript snippet illustrates how to integrate the `eslint-plugin-react` into a `tseslint.config` file. It imports the plugin, adds it to the `plugins` section, sets the React version in `settings`, and includes the plugin's recommended and JSX runtime rules in the `rules` section. This enables linting for common React patterns and syntax.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// eslint.config.js\nimport react from 'eslint-plugin-react'\n\nexport default tseslint.config({\n  // Set the react version\n  settings: { react: { version: '18.3' } },\n  plugins: {\n    // Add the react plugin\n    react,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended rules\n    ...react.configs.recommended.rules,\n    ...react.configs['jsx-runtime'].rules,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Running Next.js Development Server using Bash\nDESCRIPTION: This snippet shows multiple shell commands to start the local development server for a Next.js project generated with Fumadocs. The commands include 'npm run dev', 'pnpm dev', and 'yarn dev', each corresponding to a different package manager. Users must have Node.js and one of the listed package managers installed; no additional configuration is required. Executing any of these commands will launch the application at http://localhost:3000.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n# or\npnpm dev\n# or\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Configuring tseslint Parser Options for Type-Aware Linting (JavaScript)\nDESCRIPTION: This JavaScript snippet demonstrates configuring the `languageOptions.parserOptions` within a `tseslint.config`. It specifies the `project` array pointing to `tsconfig` files and sets `tsconfigRootDir` using `import.meta.dirname`, enabling type-aware linting rules for a TypeScript project. It's a crucial step for leveraging advanced linting based on type information.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react/README.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport default tseslint.config({\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Inferring Parser Type with TypeScript\nDESCRIPTION: This snippet demonstrates the usage of `inferParserType` type helper to access the underlying type of a parser. This helper is useful for determining the type of the parsed value. The code imports `parseAsInteger` and `inferParserType` from 'nuqs' or 'nuqs/server', and applies `inferParserType` to both a nullable and a non-nullable parsed integer to demonstrate the return types.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/utilities.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { parseAsInteger, type inferParserType } from 'nuqs' // or 'nuqs/server'\n\nconst intNullable = parseAsInteger\nconst intNonNull = parseAsInteger.withDefault(0)\n\ninferParserType<typeof intNullable> // number | null\ninferParserType<typeof intNonNull> // number\n```\n\n----------------------------------------\n\nTITLE: String Literal Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Demonstrates how to use the `parseAsStringLiteral` parser in `nuqs` to restrict the allowed values of a string search parameter to a predefined set of string literals.  It shows how to define the accepted values as a `const` array with `as const` and pass it to the parser.  It also shows how to extract the type from the const array.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsStringLiteral } from 'nuqs'\n\n// List accepted values\nconst sortOrder = ['asc', 'desc'] as const\n\n// Then pass it to the parser\nparseAsStringLiteral(sortOrder)\n\n// Optional: extract the type from them\ntype SortOrder = (typeof sortOrder)[number] // 'asc' | 'desc'\n```\n\n----------------------------------------\n\nTITLE: Server-Side Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Illustrates how to import parsers from `nuqs/server` when using them in shared code that might be imported in the Next.js app router. This avoids bundling errors when using functions like `.withDefault` & `.withOptions` across shared code. It specifies that for all other frameworks, you can use either `nuqs` or `nuqs/server` interchangeably.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsString } from 'nuqs/server'\n```\n\n----------------------------------------\n\nTITLE: Index Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Explains how to use the `parseAsIndex` parser from `nuqs`, which is similar to the integer parser but adds a `+1` offset to the serialized querystring (and `-1` when parsing).  This is useful for pagination indexes and is demonstrated with the `useQueryState` hook to manage a `pageIndex` state.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsIndex } from 'nuqs'\n\nconst [pageIndex] = useQueryState('page', parseAsIndex.withDefault(0))\n```\n\n----------------------------------------\n\nTITLE: Basic Counter Example with useQueryState in React\nDESCRIPTION: A simple counter example showing how nullability can be problematic when using query string state without default values. This demonstrates the base implementation with the parseAsInteger parser.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQueryState, parseAsInteger } from 'nuqs'\n\nexport default () => {\n  const [count, setCount] = useQueryState('count', parseAsInteger)\n  return (\n    <>\n      <pre>count: {count}</pre>\n      <button onClick={() => setCount(0)}>Reset</button>\n      {/* handling null values in setCount is annoying: */}\n      <button onClick={() => setCount(c => c ?? 0 + 1)}>+</button>\n      <button onClick={() => setCount(c => c ?? 0 - 1)}>-</button>\n      <button onClick={() => setCount(null)}>Clear</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Query Hook with nuqs (TypeScript)\nDESCRIPTION: Defines a custom React hook `useCoordinates` using `nuqs`'s `useQueryStates` to manage 'lat' and 'lng' query parameters. It configures parsing as floats with a default value of 0, providing a single point of definition for these query states.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/tips-tricks.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\n\nimport { useQueryStates, parseAsFloat } from 'nuqs'\n\nexport function useCoordinates() {\n  return useQueryStates({\n    lat: parseAsFloat.withDefault(0),\n    lng: parseAsFloat.withDefault(0),\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating nuqs Adapter - Next.js Pages Router - TSX\nDESCRIPTION: This snippet demonstrates how to integrate the `NuqsAdapter` into a Next.js application using the Pages Router. The adapter should wrap the main `<Component>` rendered by `_app.tsx` to ensure the nuqs context is available to all pages.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/adapters.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AppProps } from 'next/app'\nimport { NuqsAdapter } from 'nuqs/adapters/next/pages'\n\nexport default function MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <NuqsAdapter>\n      <Component {...pageProps} />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing nuqs with yarn - Shell\nDESCRIPTION: Shows how to add the nuqs package using Yarn, an alternative JavaScript package manager known for faster installs. Requires Yarn to be set up in the project environment and is suitable for projects adhering to Yarn workflows. Command expects internet access and outputs package status after completion.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/installation.mdx#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn add nuqs\n```\n\n----------------------------------------\n\nTITLE: Integer Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Shows how to use the `parseAsInteger` parser from `nuqs` to transform a search parameter string into an integer using `parseInt` (base 10). The example demonstrates how to set a default integer value using `.withDefault()` when using the `useQueryState` hook.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsInteger } from 'nuqs'\n\nuseQueryState('int', parseAsInteger.withDefault(0))\n```\n\n----------------------------------------\n\nTITLE: Float Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Illustrates how to use the `parseAsFloat` parser from `nuqs` to convert a search parameter string into a floating-point number using `parseFloat`. It sets a default value to 0 using `.withDefault(0)` in conjunction with the `useQueryState` hook.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsFloat } from 'nuqs'\n\nuseQueryState('float', parseAsFloat.withDefault(0))\n```\n\n----------------------------------------\n\nTITLE: Testing hooks with React Testing Library - Typescript\nDESCRIPTION: This snippet demonstrates how to test hooks using React Testing Library and the `withNuqsTestingAdapter` from nuqs. It initializes the test with specific search parameters and provides a wrapper component for rendering the hook.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/testing.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { withNuqsTestingAdapter } from 'nuqs/adapters/testing'\n\nconst { result } = renderHook(() => useTheHookToTest(), {\n  wrapper: withNuqsTestingAdapter({\n    searchParams: { count: \"42\" },\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Search Params Cache in TypeScript\nDESCRIPTION: Shows how to create a searchParamsCache using createSearchParamsCache for deeply nested Server Components, defining search params with their parsers and default values.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  createSearchParamsCache,\n  parseAsInteger,\n  parseAsString\n} from 'nuqs/server'\n// Note: import from 'nuqs/server' to avoid the \"use client\" directive\n\nexport const searchParamsCache = createSearchParamsCache({\n  // List your search param keys and associated parsers here:\n  q: parseAsString.withDefault(''),\n  maxResults: parseAsInteger.withDefault(10)\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Nuqs v2 with pnpm - Bash\nDESCRIPTION: Provides the Bash command to install the latest version of the Nuqs package using pnpm. This is the prerequisite step to add Nuqs v2 to a React project and enables usage of all features described in the documentation.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/blog/nuqs-2.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add nuqs@latest\n```\n\n----------------------------------------\n\nTITLE: Creating a Loader Function for Search Params in TypeScript\nDESCRIPTION: Demonstrates how to create a loader function using createLoader to parse search params server-side. The example defines coordinate search params with default values.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// [!code word:createLoader]\nimport { parseAsFloat, createLoader } from 'nuqs/server'\n\n// Describe your search params, and reuse this in useQueryStates / createSerializer:\nexport const coordinatesSearchParams = {\n  latitude: parseAsFloat.withDefault(0),\n  longitude: parseAsFloat.withDefault(0)\n}\n\nexport const loadSearchParams = createLoader(coordinatesSearchParams)\n```\n\n----------------------------------------\n\nTITLE: Boolean Parser Usage in nuqs (TypeScript)\nDESCRIPTION: Shows how to use the `parseAsBoolean` parser from `nuqs` to handle boolean search parameters. It initializes the boolean state with a default value of `false` using `.withDefault()` alongside the `useQueryState` hook.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/parsers/built-in.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseAsBoolean } from 'nuqs'\n\nuseQueryState('bool', parseAsBoolean.withDefault(false))\n```\n\n----------------------------------------\n\nTITLE: Building Production Assets (npm)\nDESCRIPTION: Creates an optimized production build of the application. This process typically bundles and minifies code and assets, preparing the application for deployment. The output is placed in a build/ directory. Requires dependencies to be installed.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react-router/v7/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Batching Multiple Query Updates\nDESCRIPTION: Shows how multiple query updates in the same event loop tick are batched and applied to the URL asynchronously for better performance.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_22\n\nLANGUAGE: ts\nCODE:\n```\nconst MultipleQueriesDemo = () => {\n  const [lat, setLat] = useQueryState('lat', parseAsFloat)\n  const [lng, setLng] = useQueryState('lng', parseAsFloat)\n  const randomCoordinates = React.useCallback(() => {\n    setLat(Math.random() * 180 - 90)\n    setLng(Math.random() * 360 - 180)\n  }, [])\n}\n```\n\n----------------------------------------\n\nTITLE: Applying nuqs Options During State Update (TypeScript)\nDESCRIPTION: Shows how to pass options, like enabling scrolling (`scroll: true`), directly to the state updater function returned by `useQueryState`. Options passed here override those set at the hook level.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/options.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nsetState('foo', { scroll: true })\n```\n\n----------------------------------------\n\nTITLE: Using Shared Parser Definitions in Next.js Page\nDESCRIPTION: Shows how to use shared parser definitions in a Next.js page component that includes both server and client components.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/server-side.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { coordinatesCache } from './searchParams'\nimport { Server } from './server'\nimport { Client } from './client'\n\nexport default async function Page({ searchParams }) {\n  await coordinatesCache.parse(searchParams)\n  return (\n    <>\n      <Server />\n      <Suspense>\n        <Client />\n      </Suspense>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating NuqsAdapter in React Router v7\nDESCRIPTION: This snippet demonstrates how to integrate the NuqsAdapter into a React Router v7 application by wrapping the main layout component.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// app/root.tsx\nimport { NuqsAdapter } from 'nuqs/adapters/react-router/v7'\nimport { Outlet } from 'react-router'\n\n// ...\n\nexport default function App() {\n  return (\n    <NuqsAdapter>\n      <Outlet />\n    </NuqsAdapter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Development Environment with pnpm (Shell)\nDESCRIPTION: Initiates the local development environment for the nuqs project. This command builds the core library, starts the documentation/playground application, and launches various end-to-end test benches for different frameworks.\nSOURCE: https://github.com/47ng/nuqs/blob/next/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Running Full Test Suite with pnpm (Shell)\nDESCRIPTION: Executes the comprehensive test suite for the nuqs project. This includes unit tests, typing tests, and end-to-end tests against the local test bench applications to ensure code changes do not introduce regressions.\nSOURCE: https://github.com/47ng/nuqs/blob/next/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\npnpm test\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server with HMR (npm)\nDESCRIPTION: Starts the local development server for the application. It includes Hot Module Replacement (HMR) for a fast development cycle. The application will be accessible locally, typically at http://localhost:5173. Requires dependencies to be installed.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react-router/v7/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Running Lint Checks with pnpm (Shell)\nDESCRIPTION: Performs linting checks across the project codebase to enforce code style and quality standards. This command should be run before submitting changes to ensure compliance with project conventions.\nSOURCE: https://github.com/47ng/nuqs/blob/next/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\npnpm lint\n```\n\n----------------------------------------\n\nTITLE: Starting Remix Application in Production Mode\nDESCRIPTION: Command to run the built Remix application in production mode using the built-in server.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/remix/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Enabling debug logs for Nuqs in the browser\nDESCRIPTION: This snippet shows how to enable internal debug logging for Nuqs by setting a specific localStorage item. The logs are prefixed for clarity, and user timing markers are recorded, aiding in troubleshooting and performance analysis.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_33\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Enable Nuqs debug logs in browser devtools\nlocalStorage.setItem('debug', 'nuqs')\n\n```\n\n----------------------------------------\n\nTITLE: Building Remix Application for Production\nDESCRIPTION: Command to build the Remix application for production deployment, creating optimized assets.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/remix/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Installing nuqs via pnpm\nDESCRIPTION: This command demonstrates how to add the nuqs library to your project using the pnpm package manager. This is the recommended installation method.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add nuqs\n```\n\n----------------------------------------\n\nTITLE: Installing nuqs via yarn\nDESCRIPTION: This command demonstrates how to add the nuqs library to your project using the yarn package manager.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn add nuqs\n```\n\n----------------------------------------\n\nTITLE: Installing nuqs via npm\nDESCRIPTION: This command demonstrates how to add the nuqs library to your project using the npm package manager.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install nuqs\n```\n\n----------------------------------------\n\nTITLE: Installing nuqs with bun - Shell\nDESCRIPTION: Illustrates the installation of the nuqs package utilizing Bun, an experimental and highly performant JavaScript runtime and package manager. Ensures nuqs is available for Bun-powered projects; requires Bun to be present and initialized. Outputs Bun-format logs or errors related to dependencies.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/docs/content/docs/installation.mdx#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nbun add nuqs\n```\n\n----------------------------------------\n\nTITLE: Parsing Query Parameters in Server Components\nDESCRIPTION: This TSX snippet shows how to parse search parameters in a server component using parsers imported from 'nuqs/server'. The parseServerSide method is used to safely parse the potentially string or string array searchParams value.\nSOURCE: https://github.com/47ng/nuqs/blob/next/README.md#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseAsInteger } from 'nuqs/server'\n\ntype PageProps = {\n  searchParams: {\n    counter?: string | string[]\n  }\n}\n\nconst counterParser = parseAsInteger.withDefault(1)\n\nexport default function ServerPage({ searchParams }: PageProps) {\n  const counter = counterParser.parseServerSide(searchParams.counter)\n  console.log('Server side counter: %d', counter)\n  return (\n    ...\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm (Shell)\nDESCRIPTION: This command installs all necessary project dependencies using the pnpm package manager. It should be executed from the root of the monorepo after cloning the repository to set up the development environment.\nSOURCE: https://github.com/47ng/nuqs/blob/next/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Building Docker Images for Deployment\nDESCRIPTION: Demonstrates how to build a Docker image for the application using different package managers (npm, pnpm, bun). Each command targets a specific Dockerfile provided in the template (Dockerfile, Dockerfile.pnpm, Dockerfile.bun). Requires Docker installed.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react-router/v7/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# For npm\ndocker build -t my-app .\n```\n\nLANGUAGE: bash\nCODE:\n```\n# For pnpm\ndocker build -f Dockerfile.pnpm -t my-app .\n```\n\nLANGUAGE: bash\nCODE:\n```\n# For bun\ndocker build -f Dockerfile.bun -t my-app .\n```\n\n----------------------------------------\n\nTITLE: Running Remix Development Server\nDESCRIPTION: Command to start the Remix development server for local development and testing.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/remix/README.md#_snippet_0\n\nLANGUAGE: shellscript\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Running Docker Container Locally\nDESCRIPTION: Runs the previously built Docker image (my-app) as a container. It maps port 3000 on the host machine to port 3000 inside the container, making the application accessible locally at http://localhost:3000. Requires a Docker image to have been built.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react-router/v7/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -p 3000:3000 my-app\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm\nDESCRIPTION: Installs all project dependencies listed in package.json. This is the first step after cloning the repository to prepare the project for development or building. Requires Node.js and npm installed.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react-router/v7/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Integrating eslint-plugin-react with Type-Aware ESLint Configuration in JavaScript\nDESCRIPTION: This snippet shows how to enhance an ESLint configuration with eslint-plugin-react by importing the plugin, specifying the React version, and spreading recommended rule sets into the final rules object. It requires installing eslint-plugin-react along with tseslint and ESLint. Key parameters include the React version (set to '18.3') and the use of plugin rule presets. Inputs are plugin imports and optional additional rules, and output is an extended ESLint configuration for React projects. The snippet should be placed in an eslint.config.js file; compatibility with the specified React version is advised.\nSOURCE: https://github.com/47ng/nuqs/blob/next/packages/e2e/react-router/v6/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// eslint.config.js\nimport react from 'eslint-plugin-react'\n\nexport default tseslint.config({\n  // Set the react version\n  settings: { react: { version: '18.3' } },\n  plugins: {\n    // Add the react plugin\n    react,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended rules\n    ...react.configs.recommended.rules,\n    ...react.configs['jsx-runtime'].rules,\n  },\n})\n```"
  }
]