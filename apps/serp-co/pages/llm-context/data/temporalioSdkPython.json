[
  {
    "owner": "temporalio",
    "repo": "sdk-python",
    "content": "TITLE: Implementing Hello World Workflow with Temporal Python SDK\nDESCRIPTION: A complete example showing how to define a workflow, connect to a Temporal server, register a worker, and execute a workflow.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom temporalio import workflow, activity\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n\n@workflow.defn\nclass SayHello:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return f\"Hello, {name}!\"\n\nasync def main():\n    client = await Client.connect(\"localhost:7233\")\n    async with Worker(client, task_queue=\"my-task-queue\", workflows=[SayHello]):\n        result = await client.execute_workflow(SayHello.run, \"Temporal\",\n            id=\"my-workflow-id\", task_queue=\"my-task-queue\")\n        print(f\"Result: {result}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Creating a Temporal Client and Starting a Workflow in Python\nDESCRIPTION: Shows how to create a Temporal client, connect to a server with a specific namespace, start a workflow, and wait for its result. The client is used to connect to the Temporal server and execute workflows.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.client import Client\n\nasync def main():\n    # Create client connected to server at the given address and namespace\n    client = await Client.connect(\"localhost:7233\", namespace=\"my-namespace\")\n\n    # Start a workflow\n    handle = await client.start_workflow(MyWorkflow.run, \"some arg\", id=\"my-workflow-id\", task_queue=\"my-task-queue\")\n\n    # Wait for result\n    result = await handle.result()\n    print(f\"Result: {result}\")\n```\n\n----------------------------------------\n\nTITLE: Executing Temporal Workflow in Python\nDESCRIPTION: Demonstrates how to connect to a Temporal server and execute a workflow. Creates a client connection and starts the workflow execution with parameters.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom temporalio.client import Client\n\n# Import the workflow from the previous code\nfrom .workflows import SayHello\n\nasync def main():\n    # Create client connected to server at the given address\n    client = await Client.connect(\"localhost:7233\")\n\n    # Execute a workflow\n    result = await client.execute_workflow(SayHello.run, \"my name\", id=\"my-workflow-id\", task_queue=\"my-task-queue\")\n\n    print(f\"Result: {result}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Configuring Temporal Worker in Python\nDESCRIPTION: Sets up and runs a Temporal worker that processes workflows and activities. Includes client connection, worker configuration, and thread pool setup.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport concurrent.futures\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n\n# Import the activity and workflow from our other files\nfrom .activities import say_hello\nfrom .workflows import SayHello\n\nasync def main():\n    # Create client connected to server at the given address\n    client = await Client.connect(\"localhost:7233\")\n\n    # Run the worker\n    with concurrent.futures.ThreadPoolExecutor(max_workers=100) as activity_executor:\n        worker = Worker(\n          client,\n          task_queue=\"my-task-queue\",\n          workflows=[SayHello],\n          activities=[say_hello],\n          activity_executor=activity_executor,\n        )\n        await worker.run()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Workflow in Python for Temporal\nDESCRIPTION: Defines a workflow class that executes the say_hello activity. Uses workflow decorators and includes proper activity timeout configuration.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\nfrom temporalio import workflow\n\n# Import our activity, passing it through the sandbox\nwith workflow.unsafe.imports_passed_through():\n    from .activities import say_hello\n\n@workflow.defn\nclass SayHello:\n    @workflow.run\n    async def run(self, name: str) -> str:\n        return await workflow.execute_activity(\n            say_hello, name, schedule_to_close_timeout=timedelta(seconds=5)\n        )\n```\n\n----------------------------------------\n\nTITLE: Defining Activity in Python for Temporal\nDESCRIPTION: Implements a simple activity function that takes a name parameter and returns a greeting string. Uses the @activity.defn decorator to mark it as a Temporal activity.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio import activity\n\n@activity.defn\ndef say_hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Temporal Worker in Python\nDESCRIPTION: Shows how to initialize and run a Temporal worker that can host workflows and activities. Includes client connection setup and basic worker configuration.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport logging\nfrom temporalio.client import Client\nfrom temporalio.worker import Worker\n# Import your own workflows and activities\nfrom my_workflow_package import MyWorkflow, my_activity\n\nasync def run_worker(stop_event: asyncio.Event):\n    # Create client connected to server at the given address\n    client = await Client.connect(\"localhost:7233\", namespace=\"my-namespace\")\n\n    # Run the worker until the event is set\n    worker = Worker(client, task_queue=\"my-task-queue\", workflows=[MyWorkflow], activities=[my_activity])\n    async with worker:\n        await stop_event.wait()\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing a Temporal Workflow in Python\nDESCRIPTION: This snippet defines a GreetingWorkflow class using the Temporal Python SDK. It demonstrates workflow definition, activity execution, signal handling, query implementation, and update handling. The workflow continuously updates a greeting based on signals and can be completed with a final greeting.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Pass the activities through the sandbox\nwith workflow.unsafe.imports_passed_through():\n    from .my_activities import GreetingInfo, create_greeting_activity\n\n@workflow.defn\nclass GreetingWorkflow:\n    def __init__(self) -> None:\n        self._current_greeting = \"<unset>\"\n        self._greeting_info = GreetingInfo()\n        self._greeting_info_update = asyncio.Event()\n        self._complete = asyncio.Event()\n\n    @workflow.run\n    async def run(self, name: str) -> str:\n        self._greeting_info.name = name\n        while True:\n            # Store greeting\n            self._current_greeting = await workflow.execute_activity(\n                create_greeting_activity,\n                self._greeting_info,\n                start_to_close_timeout=timedelta(seconds=5),\n            )\n            workflow.logger.debug(\"Greeting set to %s\", self._current_greeting)\n            \n            # Wait for salutation update or complete signal (this can be\n            # cancelled)\n            await asyncio.wait(\n                [\n                    asyncio.create_task(self._greeting_info_update.wait()),\n                    asyncio.create_task(self._complete.wait()),\n                ],\n                return_when=asyncio.FIRST_COMPLETED,\n            )\n            if self._complete.is_set():\n                return self._current_greeting\n            self._greeting_info_update.clear()\n\n    @workflow.signal\n    async def update_salutation(self, salutation: str) -> None:\n        self._greeting_info.salutation = salutation\n        self._greeting_info_update.set()\n\n    @workflow.signal\n    async def complete_with_greeting(self) -> None:\n        self._complete.set()\n\n    @workflow.query\n    def current_greeting(self) -> str:\n        return self._current_greeting\n    \n    @workflow.update\n    def set_and_get_greeting(self, greeting: str) -> str:\n      old = self._current_greeting\n      self._current_greeting = greeting\n      return old\n```\n\n----------------------------------------\n\nTITLE: Defining a Temporal Activity in Python\nDESCRIPTION: This snippet defines a GreetingInfo dataclass and a create_greeting_activity function. The activity is used by the GreetingWorkflow to create greeting messages based on the provided GreetingInfo.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom temporalio import workflow\n\n@dataclass\nclass GreetingInfo:\n    salutation: str = \"Hello\"\n    name: str = \"<unknown>\"\n\n@activity.defn\ndef create_greeting_activity(info: GreetingInfo) -> str:\n    return f\"{info.salutation}, {info.name}!\"\n```\n\n----------------------------------------\n\nTITLE: Starting and Interacting with a Temporal Workflow in Python\nDESCRIPTION: This snippet demonstrates how to start a locally-defined workflow from a client, send signals to update the workflow state, and retrieve the final result. It showcases the typed nature of the Temporal Python SDK client operations.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.client import Client\nfrom my_workflow_package import GreetingWorkflow\n\nasync def create_greeting(client: Client) -> str:\n    # Start the workflow\n    handle = await client.start_workflow(GreetingWorkflow.run, \"my name\", id=\"my-workflow-id\", task_queue=\"my-task-queue\")\n    # Change the salutation\n    await handle.signal(GreetingWorkflow.update_salutation, \"Aloha\")\n    # Tell it to complete\n    await handle.signal(GreetingWorkflow.complete_with_greeting)\n    # Wait and return result\n    return await handle.result()\n```\n\n----------------------------------------\n\nTITLE: Testing a Workflow with Time-Skipping Environment\nDESCRIPTION: Example of testing a workflow that contains a long sleep operation using the time-skipping test environment, which automatically advances time to make tests run quickly.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.testing import WorkflowEnvironment\nfrom temporalio.worker import Worker\n\nasync def test_wait_a_day_workflow():\n    async with await WorkflowEnvironment.start_time_skipping() as env:\n        async with Worker(env.client, task_queue=\"tq1\", workflows=[WaitADayWorkflow]):\n            assert \"all done\" == await env.client.execute_workflow(WaitADayWorkflow.run, id=\"wf1\", task_queue=\"tq1\")\n```\n\n----------------------------------------\n\nTITLE: Testing a Workflow with Signal Handling\nDESCRIPTION: Example of testing a workflow that waits for a signal, showing how to start a workflow, send a signal to it, and assert the expected result.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.testing import WorkflowEnvironment\nfrom temporalio.worker import Worker\n\nasync def test_signal_workflow():\n    async with await WorkflowEnvironment.start_time_skipping() as env:\n        async with Worker(env.client, task_queue=\"tq1\", workflows=[SignalWorkflow]):\n            # Start workflow, send signal, check result\n            handle = await env.client.start_workflow(SignalWorkflow.run, id=\"wf1\", task_queue=\"tq1\")\n            await handle.signal(SignalWorkflow.some_signal)\n            assert \"got signal\" == await handle.result()\n```\n\n----------------------------------------\n\nTITLE: Defining an Activity in Python Temporal SDK\nDESCRIPTION: Demonstrates how to define a synchronous activity using the @activity.defn decorator in the Temporal Python SDK. This example shows a simple 'say hello' activity.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio import activity\n\n@activity.defn\ndef say_hello_activity(name: str) -> str:\n    return f\"Hello, {name}!\"\n```\n\n----------------------------------------\n\nTITLE: Using Pydantic Data Converter with Temporal Python SDK\nDESCRIPTION: Shows how to configure a Temporal client to use the Pydantic data converter, which enables support for Pydantic model instances and additional types like datetime in workflows and activities.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.contrib.pydantic import pydantic_data_converter\n\nclient = Client(data_converter=pydantic_data_converter, ...)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom IPv4Address Payload Converter in Temporal Python SDK\nDESCRIPTION: Shows how to create a custom EncodingPayloadConverter to handle IPv4Address types in Temporal's data conversion system. This implementation provides basic serialization and deserialization of IPv4Address objects.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass IPv4AddressEncodingPayloadConverter(EncodingPayloadConverter):\n    @property\n    def encoding(self) -> str:\n        return \"text/ipv4-address\"\n\n    def to_payload(self, value: Any) -> Optional[Payload]:\n        if isinstance(value, ipaddress.IPv4Address):\n            return Payload(\n                metadata={\"encoding\": self.encoding.encode()},\n                data=str(value).encode(),\n            )\n        else:\n            return None\n\n    def from_payload(self, payload: Payload, type_hint: Optional[Type] = None) -> Any:\n        assert not type_hint or type_hint is ipaddress.IPv4Address\n        return ipaddress.IPv4Address(payload.data.decode())\n\nclass IPv4AddressPayloadConverter(CompositePayloadConverter):\n    def __init__(self) -> None:\n        # Just add ours as first before the defaults\n        super().__init__(\n            IPv4AddressEncodingPayloadConverter(),\n            *DefaultPayloadConverter.default_encoding_payload_converters,\n        )\n\nmy_data_converter = dataclasses.replace(\n    DataConverter.default,\n    payload_converter_class=IPv4AddressPayloadConverter,\n)\n```\n\n----------------------------------------\n\nTITLE: Customizing JSON Payload Converter for IPv4Address in Temporal Python SDK\nDESCRIPTION: Demonstrates how to customize the existing JSON payload converter to handle IPv4Address types, allowing them to work in lists, unions, and other complex type hints.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass IPv4AddressJSONEncoder(AdvancedJSONEncoder):\n    def default(self, o: Any) -> Any:\n        if isinstance(o, ipaddress.IPv4Address):\n            return str(o)\n        return super().default(o)\nclass IPv4AddressJSONTypeConverter(JSONTypeConverter):\n    def to_typed_value(\n        self, hint: Type, value: Any\n    ) -> Union[Optional[Any], _JSONTypeConverterUnhandled]:\n        if issubclass(hint, ipaddress.IPv4Address):\n            return ipaddress.IPv4Address(value)\n        return JSONTypeConverter.Unhandled\n\nclass IPv4AddressPayloadConverter(CompositePayloadConverter):\n    def __init__(self) -> None:\n        json_converter = JSONPlainPayloadConverter(\n            encoder=IPv4AddressJSONEncoder,\n            custom_type_converters=[IPv4AddressJSONTypeConverter()],\n        )\n        super().__init__(\n            *[\n                c if not isinstance(c, JSONPlainPayloadConverter) else json_converter\n                for c in DefaultPayloadConverter.default_encoding_payload_converters\n            ]\n        )\n\nmy_data_converter = dataclasses.replace(\n    DataConverter.default,\n    payload_converter_class=IPv4AddressPayloadConverter,\n)\n```\n\n----------------------------------------\n\nTITLE: Waiting for Signal and Update Handlers to Complete\nDESCRIPTION: Example showing how to ensure all in-progress signal and update handler tasks have finished before a workflow completes by waiting on the workflow.all_handlers_finished condition.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nawait workflow.wait_condition(workflow.all_handlers_finished)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Workflow with Sleep Function\nDESCRIPTION: A simple workflow example that sleeps for 24 hours before returning a result, demonstrating a long-running operation that benefits from time-skipping during testing.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom temporalio import workflow\n\n@workflow.defn\nclass WaitADayWorkflow:\n    @workflow.run\n    async def run(self) -> str:\n        await asyncio.sleep(24 * 60 * 60)\n        return \"all done\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Signal-Waiting Workflow with Timeout\nDESCRIPTION: A workflow that waits for a signal with a timeout of 45 seconds, demonstrating how to combine signal handling with timeouts in workflow logic.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom temporalio import workflow\n\n@workflow.defn\nclass SignalWorkflow:\n    def __init__(self) -> None:\n        self.signal_received = False\n\n    @workflow.run\n    async def run(self) -> str:\n        # Wait for signal or timeout in 45 seconds\n        try:\n            await workflow.wait_condition(lambda: self.signal_received, timeout=45)\n            return \"got signal\"\n        except asyncio.TimeoutError:\n            return \"got timeout\"\n\n    @workflow.signal\n    def some_signal(self) -> None:\n        self.signal_received = True\n```\n\n----------------------------------------\n\nTITLE: Testing a Workflow Timeout Using Manual Time Skipping\nDESCRIPTION: Example of testing a workflow's timeout behavior by manually advancing time in the time-skipping environment, demonstrating how to test time-based conditions.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.testing import WorkflowEnvironment\nfrom temporalio.worker import Worker\n\nasync def test_signal_workflow_timeout():\n    async with await WorkflowEnvironment.start_time_skipping() as env:\n        async with Worker(env.client, task_queue=\"tq1\", workflows=[SignalWorkflow]):\n            # Start workflow, advance time past timeout, check result\n            handle = await env.client.start_workflow(SignalWorkflow.run, id=\"wf1\", task_queue=\"tq1\")\n            await env.sleep(50)\n            assert \"got timeout\" == await handle.result()\n```\n\n----------------------------------------\n\nTITLE: Implementing Workflow History Replay in Python\nDESCRIPTION: Demonstrates how to replay a workflow's history to check for non-determinism errors using the Temporal Python SDK. Takes a JSON string history and replays it using the Replayer class.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.client import WorkflowHistory\nfrom temporalio.worker import Replayer\n\nasync def run_replayer(history_str: str):\n  replayer = Replayer(workflows=[SayHello])\n  await replayer.replay_workflow(WorkflowHistory.from_json(history_str))\n```\n\n----------------------------------------\n\nTITLE: Checking Past Workflow Histories for Non-determinism\nDESCRIPTION: Shows how to verify that workflow code changes won't cause non-determinism with previously completed workflows. Lists and replays all histories for a specific workflow type.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom temporalio.client import Client, WorkflowHistory\nfrom temporalio.worker import Replayer\n\nasync def check_past_histories(my_client: Client):\n  replayer = Replayer(workflows=[SayHello])\n  await replayer.replay_workflows(\n    await my_client.list_workflows(\"WorkflowType = 'SayHello'\").map_histories(),\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating a Client for a Different Namespace in Python\nDESCRIPTION: Demonstrates how to create a new Temporal client for a different namespace using the configuration of an existing client. This allows reusing the same connection with different namespaces.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nconfig = client.config()\nconfig[\"namespace\"] = \"my-other-namespace\"\nother_ns_client = Client(**config)\n```\n\n----------------------------------------\n\nTITLE: Avoiding Sandbox Restrictions in Python Temporal Workflow\nDESCRIPTION: Demonstrates how to temporarily remove sandbox restrictions for a block of code in a Temporal workflow using a context manager.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nwith temporalio.workflow.unsafe.sandbox_unrestricted():\n```\n\n----------------------------------------\n\nTITLE: Passing Through Modules in Python Temporal Workflow Sandbox\nDESCRIPTION: Shows how to mark third-party modules as passthrough in a Temporal workflow file, allowing them to be imported without being reloaded for every workflow run.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# my_workflow_file.py\n\nfrom temporalio import workflow\n\nwith workflow.unsafe.imports_passed_through():\n    import pydantic\n\n@workflow.defn\nclass MyWorkflow:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Customizing Sandbox Restrictions for Python Temporal Worker\nDESCRIPTION: Demonstrates how to customize sandbox restrictions when creating a Temporal Worker, including passing through specific modules and setting all modules as passthrough.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nmy_worker = Worker(\n  ...,\n  workflow_runner=SandboxedWorkflowRunner(\n    restrictions=SandboxRestrictions.default.with_passthrough_modules(\"pydantic\")\n  )\n)\n\n# Alternatively, to set all modules as passthrough:\nmy_worker = Worker(\n  ...,\n  workflow_runner=SandboxedWorkflowRunner(\n    restrictions=SandboxRestrictions.default.with_passthrough_all_modules()\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Modifying Invalid Module Members in Python Temporal Sandbox\nDESCRIPTION: Shows how to customize the invalid module members restrictions in the Temporal sandbox, including removing existing restrictions and adding new ones.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nmy_restrictions = dataclasses.replace(\n    SandboxRestrictions.default,\n    invalid_module_members=SandboxRestrictions.invalid_module_members_default.with_child_unrestricted(\n      \"datetime\", \"date\", \"today\",\n    ),\n)\nmy_worker = Worker(..., workflow_runner=SandboxedWorkflowRunner(restrictions=my_restrictions))\n\n# Adding new restrictions:\nmy_restrictions = dataclasses.replace(\n    SandboxRestrictions.default,\n    invalid_module_members=SandboxRestrictions.invalid_module_members_default | SandboxMatcher(\n      children={\"datetime\": SandboxMatcher(use={\"date\"})},\n    ),\n)\nmy_worker = Worker(..., workflow_runner=SandboxedWorkflowRunner(restrictions=my_restrictions))\n```\n\n----------------------------------------\n\nTITLE: Installing Temporal Python SDK with OpenTelemetry Support\nDESCRIPTION: Command to install the Temporal Python SDK with OpenTelemetry dependencies using pip.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\npip install 'temporalio[opentelemetry]'\n```\n\n----------------------------------------\n\nTITLE: Installing Development Tools for Temporal SDK\nDESCRIPTION: Commands to install poethepoet using uv for Temporal SDK development.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nuv tool install poethepoet\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up Temporal SDK Repository\nDESCRIPTION: Commands to clone the Temporal SDK repository recursively and install dependencies using uv.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive https://github.com/temporalio/sdk-python.git\ncd sdk-python\n```\n\n----------------------------------------\n\nTITLE: Installing Temporal SDK Dependencies\nDESCRIPTION: Command to install all dependencies for the Temporal Python SDK using uv.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nuv sync --all-extras\n```\n\n----------------------------------------\n\nTITLE: Building Temporal SDK from Source\nDESCRIPTION: Command to build the Temporal Python SDK from source using uv.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\nuv build\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies for Using Built SDK\nDESCRIPTION: Commands to install wheel and the built Temporal SDK wheel file in a virtual environment.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\npip install wheel\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install /path/to/cloned/sdk-python/dist/*.whl\n```\n\n----------------------------------------\n\nTITLE: Building Temporal SDK in Development Mode\nDESCRIPTION: Command to build the Temporal SDK in development mode for quicker iteration during development.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\npoe build-develop\n```\n\n----------------------------------------\n\nTITLE: Running Temporal SDK Tests\nDESCRIPTION: Commands for running tests for the Temporal SDK using poe.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\npoe test\n```\n\nLANGUAGE: bash\nCODE:\n```\npoe test -s --log-cli-level=DEBUG -k test_sync_activity_thread_cancel_caught\n```\n\n----------------------------------------\n\nTITLE: Generating Protobuf Code for Temporal SDK\nDESCRIPTION: Docker commands to generate protobuf files for Temporal SDK without changing the local environment.\nSOURCE: https://github.com/temporalio/sdk-python/blob/main/README.md#2025-04-15_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -f scripts/_proto/Dockerfile .\ndocker run --rm -v \"${PWD}/temporalio/api:/api_new\" -v \"${PWD}/temporalio/bridge/proto:/bridge_new\" <just built image sha>\npoe format\n```"
  }
]