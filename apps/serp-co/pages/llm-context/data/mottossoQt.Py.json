[
  {
    "owner": "mottosso",
    "repo": "qt.py",
    "content": "TITLE: Installing Qt.py from PyPI\nDESCRIPTION: This snippet shows how to install Qt.py using pip, the Python package installer. This method ensures you get the latest stable release.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ pip install Qt.py\n```\n\n----------------------------------------\n\nTITLE: Accessing Qt binding version\nDESCRIPTION: This example demonstrates how to import and use the `__binding__` attribute from the `Qt` module to identify the Qt binding currently in use.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> from Qt import __binding__\n>>> __binding__\n'PyQt5'\n```\n\n----------------------------------------\n\nTITLE: Basic Qt.py usage example\nDESCRIPTION: This snippet shows how to use Qt.py to create a simple \"Hello World\" application. It imports necessary modules from `Qt` and creates a button.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nfrom Qt import QtWidgets QtCompat\n\napp = QtWidgets.QApplication(sys.argv)\nbutton = QtWidgets.QPushButton(\"Hello World\")\nbutton.show()\nQtCompat.QApplication.exec_()\n```\n\n----------------------------------------\n\nTITLE: Loading Qt Designer UI files (Python)\nDESCRIPTION: This Python snippet demonstrates how to load a Qt Designer `.ui` file using the `QtCompat.loadUi` function provided by Qt.py. This convenience function abstracts the differences between PyQt and PySide for loading UI files, providing a consistent API. It includes example usage with a QApplication and a QWidget.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom Qt import QtCompat, QtWidgets\n\napp = QtWidgets.QApplication(sys.argv)\nui = QtCompat.loadUi(uifile=\"my.ui\")\nui.show()\nQtCompat.QApplication.exec_()\n```\n\n----------------------------------------\n\nTITLE: QtCompat.QHeaderView.setSectionResizeMode usage\nDESCRIPTION: Shows how to use `QtCompat.QHeaderView.setSectionResizeMode` to set the resize mode of a header in PySide2, addressing the renaming of `setResizeMode` to `setSectionResizeMode` in Qt 5. The compatibility wrapper ensures the code works correctly regardless of Qt version.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# PySide2\n>>> from Qt import QtWidgets, QtCompat\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> view = QtWidgets.QTreeWidget()\n>>> header = view.header()\n>>> QtCompat.QHeaderView.setSectionResizeMode(header, QtWidgets.QHeaderView.Fixed)\n```\n\n----------------------------------------\n\nTITLE: Override Preferred Qt Binding (Bash)\nDESCRIPTION: This example shows how to override the preferred Qt binding using the `QT_PREFERRED_BINDING` environment variable. This variable controls the order in which Qt.py attempts to import different Qt bindings. The example demonstrates setting the variable to prefer PyQt5.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ set QT_PREFERRED_BINDING=PyQt5  # Windows\n$ export QT_PREFERRED_BINDING=PyQt5  # Unix/OSX\n$ python -c \"import Qt;print(Qt.__binding__)\"\nPyQt5\n```\n\n----------------------------------------\n\nTITLE: Using QtCompat.QHeaderView for compatibility\nDESCRIPTION: This example showcases how to use `QtCompat.QHeaderView` to handle compatibility issues between Qt4 and Qt5, specifically for setting and getting the movable state of header sections.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom Qt import QtCore, QtWidgets, QtCompat\nheader = QtWidgets.QHeaderView(QtCore.Qt.Horizontal)\nQtCompat.QHeaderView.setSectionsMovable(header, False)\nmovable = QtCompat.QHeaderView.sectionsMovable(header)\n```\n\n----------------------------------------\n\nTITLE: Convert Qt Designer UI file (Bash)\nDESCRIPTION: This example shows how to convert a Qt Designer `.ui` file into a Python file using `pyside2-uic` and then converting it with the `Qt` module to be binding independent. The `Qt --convert` command removes traces of PySide2 and replaces them with cross-compatible code, ensuring compatibility with other Qt bindings when used with Qt.py.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ pyside2-uic my_ui.ui -o my_ui.py\n$ python -m Qt --convert my_ui.py\n# Creating \"my_ui_backup.py\"..\n# Successfully converted \"my_ui.py\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Binding Code in Qt.py (Python)\nDESCRIPTION: This snippet demonstrates how to execute binding-specific code using the `__binding__` variable in Qt.py. It allows you to target specific Qt bindings (e.g., PySide) with conditional logic. The `do_pyside_stuff()` is a placeholder function that represents the binding-specific code to be executed.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nif \"PySide\" in __binding__:\n  do_pyside_stuff()\n```\n\n----------------------------------------\n\nTITLE: Standardizing Class Locations in QtSiteConfig (Python)\nDESCRIPTION: This example demonstrates how to standardize the location of Qt classes using the `update_misplaced_members` function in `QtSiteConfig.py`. It remaps the `Property` class to `QtCore.Property` for various Qt bindings (PySide2, PyQt5, PySide, PyQt4), ensuring consistent access regardless of the underlying binding.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/examples/QtSiteConfig/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef update_misplaced_members(members):\n    \"\"\"This optional function is called by Qt.py to standardize the location\n    and naming of exposed classes.\n\n    Arguments:\n        members (dict): The members considered by Qt.py\n    \"\"\"\n    # Standardize the the Property name\n    members[\"PySide2\"][\"QtCore.Property\"] = \"QtCore.Property\"\n    members[\"PyQt5\"][\"QtCore.pyqtProperty\"] = \"QtCore.Property\"\n    members[\"PySide\"][\"QtCore.Property\"] = \"QtCore.Property\"\n    members[\"PyQt4\"][\"QtCore.pyqtProperty\"] = \"QtCore.Property\"\n```\n\n----------------------------------------\n\nTITLE: Loading UI with baseinstance (Python)\nDESCRIPTION: This Python snippet shows how to use `QtCompat.loadUi` with a `baseinstance` parameter to dynamically load a UI onto an existing QWidget. This allows for more flexible integration of UI files into existing application structures.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nQtCompat.loadUi(uifile=\"my.ui\", baseinstance=QtWidgets.QWidget)\n```\n\n----------------------------------------\n\nTITLE: Correctly Adding `translate` Function in Python\nDESCRIPTION: This code snippet demonstrates the correct way to add a custom translate function in Qt. It adds the function via `QtCompat.translate` instead of overwriting the original, ensuring compatibility.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Right\nQtCompat.translate = translate\n```\n\n----------------------------------------\n\nTITLE: Conditional setResizeMode/setSectionResizeMode\nDESCRIPTION: Illustrates a conditional approach to setting the resize mode of a header based on the Qt binding.  This ensures the correct method is called, maintaining compatibility across Qt versions.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# PyQt5\n>>> from Qt import QtWidgets, __binding__\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> view = QtWidgets.QTreeWidget()\n>>> header = view.header()\n>>> if __binding__ in (\"PyQt4\", \"PySide\"):\n...   header.setResizeMode(QtWidgets.QHeaderView.Fixed)\n... else:\n...   header.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)\n```\n\n----------------------------------------\n\nTITLE: PyQt5 signal and slot aliases (Python)\nDESCRIPTION: This Python code shows how Qt.py aliases PyQt5 signal and slot classes to match PySide2 conventions, ensuring cross-binding compatibility for signal and slot handling.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# PyQt5 adheres to PySide2 signals and slots\nPyQt5.Signal = PyQt5.pyqtSignal\nPyQt5.Slot = PyQt5.pyqtSlot\n```\n\n----------------------------------------\n\nTITLE: Loading UI with Base Instance in PyQt\nDESCRIPTION: This example demonstrates how to load a .ui file into an existing widget instance (base instance) using `uic.loadUi` in PyQt4 and PyQt5. The `loadUi` function loads all widgets defined in the .ui file into the `self` instance of the `MainWindow` class.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/examples/loadUi/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# PyQt4, PyQt5\nclass MainWindow(QtWidgets.QWidget):\n    def __init__(self, parent=None):\n        QtWidgets.QWidget.__init__(self, parent)\n        uic.loadUi('uifile.ui', self)  # Loads all widgets of uifile.ui into self\n```\n\n----------------------------------------\n\nTITLE: Expose QtSiteConfig to Python (Bash)\nDESCRIPTION: This command line example shows how to expose the `QtSiteConfig.py` module to Python by modifying the `PYTHONPATH` environment variable. This ensures that Qt.py can find and use the custom configuration module. The example also demonstrates importing a module (`Qt.QtCore`) that has been removed via the configuration.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ set PYTHONPATH=/path/to\n$ python -c \"import Qt.QtCore\"\nImportError: No module named Qt.QtCore\n```\n\n----------------------------------------\n\nTITLE: Grabbing Widget (PySide2, PyQt5)\nDESCRIPTION: This snippet demonstrates how to grab a widget in PySide2 and PyQt5 using the `grab()` method directly on the `QWidget` instance. It showcases a more modern approach compared to `QPixmap.grabWidget` used in PySide.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# PySide2\n>>> from Qt import QtGui, QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> button = QtWidgets.QPushButton(\"Hello world\")\n>>> pixmap = button.grab()\n```\n\n----------------------------------------\n\nTITLE: Standardizing PyQt4's QFileDialog in QtSiteConfig (Python)\nDESCRIPTION: This example demonstrates how to standardize PyQt4's `QFileDialog` functionality using `update_compatibility_members` and `update_compatibility_decorators` in `QtSiteConfig.py`. It remaps the `QFileDialog` methods and provides a decorator to ensure PyQt4 returns the same format as other Qt bindings by converting the return of the QFileDialog methods into a tuple.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/examples/QtSiteConfig/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef update_compatibility_members(members):\n    \"\"\"This function is called by Qt.py to modify the modules it exposes.\n\n    Arguments:\n        members (dict): The members considered by Qt.py\n    \"\"\"\n    members['PyQt4'][\"QFileDialog\"] = {\n        \"getOpenFileName\": \"QtWidgets.QFileDialog.getOpenFileName\",\n        \"getOpenFileNames\": \"QtWidgets.QFileDialog.getOpenFileNames\",\n        \"getSaveFileName\": \"QtWidgets.QFileDialog.getSaveFileName\",\n    }\n\ndef update_compatibility_decorators(binding, decorators):\n    \"\"\" This function is called by Qt.py to modify the decorators applied to\n    QtCompat namespace objects. Defining this method is optional.\n\n    Arguments:\n        binding (str): The Qt binding being wrapped by Qt.py\n        decorators (dict): Maps specific decorator methods to\n            QtCompat namespace methods. See Qt._build_compatibility_members\n            for more info.\n    \"\"\"\n    if binding == 'PyQt4':\n        # QFileDialog QtCompat decorator\n        def _standardizeQFileDialog(some_function):\n            \"\"\" decorator that makes PyQt4 return conform to other bindings\n            \"\"\"\n            def wrapper(*args, **kwargs):\n                ret = some_function(*args, **kwargs)\n                # PyQt4 only returns the selected filename, force it to a\n                # standard return of the selected filename, and a empty string\n                # for the selected filter\n                return (ret, '')\n            # preserve docstring and name of original method\n            wrapper.__doc__ = some_function.__doc__\n            wrapper.__name__ = some_function.__name__\n            return wrapper\n\n        decorators.setdefault(\"QFileDialog\",{})[\"getOpenFileName\"] = \\\n            _standardizeQFileDialog\n        decorators.setdefault(\"QFileDialog\",{})[\"getOpenFileNames\"] = \\\n            _standardizeQFileDialog\n        decorators.setdefault(\"QFileDialog\",{})[\"getSaveFileName\"] = \\\n            _standardizeQFileDialog\n```\n\n----------------------------------------\n\nTITLE: Grabbing Widget with Compatibility Wrapper (PySide2)\nDESCRIPTION: This snippet illustrates a workaround for grabbing widgets in PySide2 using a compatibility wrapper `QtCompat.QWidget.grab(button)`. This is useful in cases where direct method calls might not be available or consistent across different Qt versions.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# PySide2\n>>> from Qt import QtCompat, QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> button = QtWidgets.QPushButton(\"Hello world\")\n>>> pixmap = QtCompat.QWidget.grab(button)\n```\n\n----------------------------------------\n\nTITLE: Removed Members (JSON)\nDESCRIPTION: This JSON snippet lists removed members from various Qt modules in Qt.py, primarily due to their absence in PySide 6 and PyQt6. It provides a reference for developers migrating to newer Qt versions using Qt.py.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_20\n\nLANGUAGE: JSON\nCODE:\n```\n{\n\"QtCore\": [\n    \"QAbstractState\",\n    \"QAbstractTransition\",\n    \"QEventTransition\",\n    \"QFinalState\",\n    \"QSignalTransition\",\n    \"QT_TR_NOOP_UTF8\",\n    \"QTextCodec\",\n    \"QTextDecoder\",\n    \"QTextEncoder\",\n    \"QtCriticalMsg\",\n    \"QtDebugMsg\",\n    \"QtFatalMsg\",\n    \"QtSystemMsg\",\n    \"QtWarningMsg\",\n    \"qChecksum\",\n    \"qIsNull\",\n    \"QPictureIO\"\n],\n\"QtGui\": [\n    \"qIsGray\"\n]\n,\n\"QtMultimedia\": [\n    \"QAbstractVideoBuffer\",\n    \"QAbstractVideoSurface\",\n    \"QAudio\",\n    \"QAudioDeviceInfo\",\n    \"QAudioFormat\",\n    \"QAudioInput\",\n    \"QAudioOutput\",\n    \"QVideoFrame\",\n    \"QVideoSurfaceFormat\"\n],\n\"QtNetwork\": [\n    \"QNetworkConfiguration\",\n    \"QNetworkConfigurationManager\",\n    \"QNetworkSession\"\n],\n\"QtOpenGL\": [\n    \"QGL\",\n    \"QGLContext\",\n    \"QGLFormat\",\n    \"QGLWidget\"\n],\n\"QtSql\": [\n    \"QSql\",\n    \"QSqlDatabase\",\n    \"QSqlDriver\",\n    \"QSqlDriverCreatorBase\",\n    \"QSqlError\",\n    \"QSqlField\",\n    \"QSqlIndex\",\n    \"QSqlQuery\",\n    \"QSqlQueryModel\",\n    \"QSqlRecord\",\n    \"QSqlRelation\",\n    \"QSqlRelationalDelegate\",\n    \"QSqlRelationalTableModel\",\n    \"QSqlResult\",\n    \"QSqlTableModel\"\n],\n\"QtWidgets\": [\n    \"QActionGroup\",\n    \"QDesktopWidget\",\n    \"QDirModel\",\n    \"QKeyEventTransition\",\n    \"QMouseEventTransition\",\n    \"QUndoCommand\",\n    \"QUndoGroup\",\n    \"QUndoStack\"\n],\n\"QtX11Extras\": [\n    \"QX11Info\"\n],\n\"QtXml\": [\n    \"QXmlAttributes\",\n    \"QXmlContentHandler\",\n    \"QXmlDTDHandler\",\n    \"QXmlDeclHandler\",\n    \"QXmlDefaultHandler\",\n    \"QXmlEntityResolver\",\n    \"QXmlErrorHandler\",\n    \"QXmlInputSource\",\n    \"QXmlLexicalHandler\",\n    \"QXmlLocator\",\n    \"QXmlNamespaceSupport\",\n    \"QXmlParseException\",\n    \"QXmlReader\",\n    \"QXmlSimpleReader\"\n],\n\"QtXmlPatterns\": [\n    \"QAbstractMessageHandler\",\n    \"QAbstractUriResolver\",\n    \"QAbstractXmlNodeModel\",\n    \"QAbstractXmlReceiver\",\n    \"QSourceLocation\",\n    \"QXmlFormatter\",\n    \"QXmlItem\",\n    \"QXmlName\",\n    \"QXmlNamePool\",\n    \"QXmlNodeModelIndex\",\n    \"QXmlQuery\",\n    \"QXmlResultItems\",\n    \"QXmlSchema\",\n    \"QXmlSchemaValidator\",\n    \"QXmlSerializer\"\n]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Qt.py from Anaconda\nDESCRIPTION: This snippet shows how to install Qt.py using conda, the Anaconda package manager. First you need to add the conda-forge channel, then you can install the package.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n$ conda config --add channels conda-forge\n$ conda install qt.py\n```\n\n----------------------------------------\n\nTITLE: Correct QWidget Implementation in Python\nDESCRIPTION: This code snippet shows the correct way to map QWidget. It avoids introducing bugs by simply aliasing the existing Qt binding's QWidget, eliminating the need for custom logic.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Right\nQtWidgets.QWidget = QtGui.QWidget  # No bugs\n```\n\n----------------------------------------\n\nTITLE: QApplication.instance() usage as a workaround\nDESCRIPTION: Shows how to use `QApplication.instance()` as an alternative to `qApp`. This method retrieves the current application instance and avoids the inconsistencies associated with `qApp`.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# PySide2\n>>> from Qt import QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> app == QtWidgets.QApplication.instance()\nTrue\n```\n\n----------------------------------------\n\nTITLE: Constrain Available Qt Bindings (Bash)\nDESCRIPTION: This snippet shows how to constrain the available Qt bindings using the `QT_PREFERRED_BINDING` environment variable with multiple values separated by the OS path separator (colon on Unix/OSX). It allows specifying a prioritized list of bindings, excluding others from consideration by Qt.py.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Try PyQt4 first and then PySide, but nothing else.\n$ export QT_PREFERRED_BINDING=PyQt4:PySide\n```\n\n----------------------------------------\n\nTITLE: Override Preferred Binding with JSON (JSON)\nDESCRIPTION: This JSON configuration demonstrates how to use the `QT_PREFERRED_BINDING_JSON` environment variable to control preferred Qt bindings for specific module namespaces. This allows fine-grained control over which binding is used for different parts of a project. The keys represent the module namespaces (e.g., \"Qt\", \"myproject.vendor.Qt\"), and the values are arrays of preferred bindings.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"Qt\":[\"PyQt5\"],\n    \"myproject.vendor.Qt\":[\"PyQt5\"],\n    \"default\":[\"PySide2\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Qsci module using QtSiteConfig in Python\nDESCRIPTION: This example demonstrates how to add the Qsci module (for scintilla lexer support) to Qt.py via the `update_members` function in a `QtSiteConfig.py` file. It iterates through the members dict and adds a new entry called \"Qsci\" along with a list of relevant Qsci classes.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/examples/QtSiteConfig/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef update_members(members):\n    \"\"\"An example of adding Qsci to Qt.py.\n\n    Arguments:\n        members (dict): The default list of members in Qt.py.\n            Update this dict with any modifications needed.\n    \"\"\"\n\n    # Include Qsci module for scintilla lexer support.\n    members[\"Qsci\"] = [\n        \"QsciAPIs\",\n        \"QsciAbstractAPIs\",\n        \"QsciCommand\",\n        \"QsciCommandSet\",\n        \"QsciDocument\",\n        \"QsciLexer\",\n        \"QsciLexerAVS\",\n        \"QsciLexerBash\",\n        \"QsciLexerBatch\",\n        \"QsciLexerCMake\",\n        \"QsciLexerCPP\",\n        \"QsciLexerCSS\",\n        \"QsciLexerCSharp\",\n        \"QsciLexerCoffeeScript\",\n        \"QsciLexerCustom\",\n        \"QsciLexerD\",\n        \"QsciLexerDiff\",\n        \"QsciLexerFortran\",\n        \"QsciLexerFortran77\",\n        \"QsciLexerHTML\",\n        \"QsciLexerIDL\",\n        \"QsciLexerJSON\",\n        \"QsciLexerJava\",\n        \"QsciLexerJavaScript\",\n        \"QsciLexerLua\",\n        \"QsciLexerMakefile\",\n        \"QsciLexerMarkdown\",\n        \"QsciLexerMatlab\",\n        \"QsciLexerOctave\",\n        \"QsciLexerPO\",\n        \"QsciLexerPOV\",\n        \"QsciLexerPascal\",\n        \"QsciLexerPerl\",\n        \"QsciLexerPostScript\",\n        \"QsciLexerProperties\",\n        \"QsciLexerPython\",\n        \"QsciLexerRuby\",\n        \"QsciLexerSQL\",\n        \"QsciLexerSpice\",\n        \"QsciLexerTCL\",\n        \"QsciLexerTeX\",\n        \"QsciLexerVHDL\",\n        \"QsciLexerVerilog\",\n        \"QsciLexerXML\",\n        \"QsciLexerYAML\",\n        \"QsciMacro\",\n        \"QsciPrinter\",\n        \"QsciScintilla\",\n        \"QsciScintillaBase\",\n        \"QsciStyle\",\n        \"QsciStyledText\",\n    ]\n```\n\n----------------------------------------\n\nTITLE: QAbstractItemModel.createIndex behavior in PySide\nDESCRIPTION: Demonstrates how PySide allows negative internal IDs for QAbstractItemModel indexes, whereas PyQt4 coerces them into unsigned values.  This example shows the PySide behavior and the corresponding output. It is essential to consider this difference when using internal IDs as indices.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# PySide\n>>> from Qt import QtGui\n>>> model = QtGui.QStandardItemModel()\n>>> index = model.createIndex(0, 0, -1)\n>>> int(index.internalId()) == -1\nTrue\n```\n\n----------------------------------------\n\nTITLE: Running a Docker Container\nDESCRIPTION: This command allows you to enter a pre-built Docker container for debugging purposes. It utilizes docker run with flags to remove the container after exit, provide an interactive shell, allocate a pseudo-TTY, and override the default entrypoint to use bash. You can then run various Python versions (2.7, 3.4, 3.5, 3.6, etc.) depending on the image's configuration.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/DOCKER.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm --interactive --tty --entrypoint=bash fredrikaverpil/qt.py:2017\n```\n\n----------------------------------------\n\nTITLE: Override Preferred Binding with JSON (Bash)\nDESCRIPTION: This demonstrates how to set the `QT_PREFERRED_BINDING_JSON` environment variable in a bash shell. The example uses a JSON string to specify preferences for the \"Qt\" module namespace and a fallback using `QT_PREFERRED_BINDING`\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# Try PyQt5 first and then PyQt4 for the Qt module name space.\n$ export QT_PREFERRED_BINDING_JSON=\"{\"Qt\":[\"PyQt5\",\"PyQt4\"]}\"\n# Use PyQt4 for any other Qt module name spaces.\n$ export QT_PREFERRED_BINDING=PySide2\n```\n\n----------------------------------------\n\nTITLE: QRegExpValidator constructor in PySide\nDESCRIPTION: Shows that PySide's `QRegExpValidator` constructor accepts only a `QRegExp` instance. Passing an additional `parent` argument will cause a TypeError.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# PySide, untested\n>>> from Qt import QtCore, QtGui\n>>> regex = QtCore.QRegExp(\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\")\n>>> validator = QtGui.QRegExpValidator(regex)\n>>> validator = QtGui.QRegExpValidator(regex, None)\nTraceback (most recent call last):\n...\nTypeError: ...\n```\n\n----------------------------------------\n\nTITLE: QItemSelection length in PySide\nDESCRIPTION: Demonstrates using `len(selection)` to check if a `QItemSelection` is empty in PySide. This provides a consistent way to determine if a selection is empty, even with differing attributes.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# PySide\n>>> from Qt import QtCore\n>>> selection = QtCore.QItemSelection()\n>>> len(selection)\n0\n```\n\n----------------------------------------\n\nTITLE: QHeaderView.setResizeMode in PySide2\nDESCRIPTION: Demonstrates the absence of `setResizeMode` in PySide2's `QHeaderView`, as it was renamed to `setSectionResizeMode` in Qt 5. This incompatibility is addressed using `QtCompat` or conditional logic.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# PySide2\n>>> from Qt import QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> view = QtWidgets.QTreeWidget()\n>>> header = view.header()\n>>> header.setResizeMode(QtWidgets.QHeaderView.Fixed)\nTraceback (most recent call last):\n...\nAttributeError: 'PySide2.QtWidgets.QHeaderView' object has no attribute 'setResizeMode'\n```\n\n----------------------------------------\n\nTITLE: QItemSelection attributes in PyQt5\nDESCRIPTION: Illustrates that PyQt5 only has the `isEmpty` attribute on `QItemSelection`, not `empty`. This highlights the discrepancy between PySide2 and PyQt5 regarding the availability of the `empty` attribute.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# PyQt5\n>>> from Qt import QtCore\n>>> func = QtCore.QItemSelection.isEmpty\n>>> func = QtCore.QItemSelection.empty\nTraceback (most recent call last):\n...\nAttributeError: type object 'QItemSelection' has no attribute 'empty'\n```\n\n----------------------------------------\n\nTITLE: QItemSelection attributes in PySide2\nDESCRIPTION: Shows that `QItemSelection` in PySide2 has both `isEmpty` and `empty` attributes. This snippet illustrates the existence of both attributes for checking if a selection is empty.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# PySide2\n>>> from Qt import QtCore\n>>> func = QtCore.QItemSelection.isEmpty\n>>> func = QtCore.QItemSelection.empty\n```\n\n----------------------------------------\n\nTITLE: QtCore.Slot usage in PySide\nDESCRIPTION: Shows how PySide allows specifying the return type of a `QtCore.Slot` using the `result=None` keyword argument.  This example demonstrates this capability, crucial for specific signal-slot configurations.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# PySide\n>>> from Qt import QtCore, QtWidgets\n>>> slot = QtCore.Slot(QtWidgets.QWidget, result=None)\n```\n\n----------------------------------------\n\nTITLE: QAction.triggered signal in PySide\nDESCRIPTION: Demonstrates that the `triggered` signal in PySide cannot accept any arguments. This contrasts with PyQt4 where it expects a boolean argument.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# PySide, untested\n>>> from Qt import QtCore, QtWidgets\n>>> obj = QtCore.QObject()\n>>> action = QtWidgets.QAction(obj)\n>>> action.triggered.emit()  # Note the return value (!)\nTrue\n>>> action.triggered.emit(True)\nTraceback (most recent call last):\n...\nTypeError: triggered() only accepts 0 arguments, 2 given!\n```\n\n----------------------------------------\n\nTITLE: PyQt4-Specific Test Case (Python)\nDESCRIPTION: This code snippet demonstrates how to write a test case that is specific to the PyQt4 binding within the Qt.py testing framework. The test will only run when the active binding is PyQt4.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\nif binding(\"PyQt4\"):\n    def test_something_related_to_pyqt4():\n        pass\n```\n\n----------------------------------------\n\nTITLE: QRegExpValidator constructor in PyQt4\nDESCRIPTION: Shows that PyQt4's `QRegExpValidator` constructor requires a parent argument. Not passing it will cause a TypeError.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# PyQt4, untested\n>>> from Qt import QtCore, QtGui\n>>> regex = QtCore.QRegExp(\"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\")\n>>> validator = QtGui.QRegExpValidator(regex, None)\n>>> validator = QtGui.QRegExpValidator(regex)\nTraceback (most recent call last):\n...\nTypeError: ...\n```\n\n----------------------------------------\n\nTITLE: Example of Commit Message Style in Bash\nDESCRIPTION: This code shows the expected commit message style.  It highlights the use of present-tense, imperative-style for commit messages.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# No\nChanged this and did that\n\n# No\nChanges this and does that\n\n# Yes\nChange this and do that\n```\n\n----------------------------------------\n\nTITLE: QHeaderView.setSectionResizeMode in PySide\nDESCRIPTION: Illustrates that `setSectionResizeMode` is not available in PySide's QHeaderView as the method is `setResizeMode`. This example demonstrates the error that arises from the incorrect usage.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# PySide\n>>> from Qt import QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> view = QtWidgets.QTreeWidget()\n>>> header = view.header()\n>>> header.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)\nTraceback (most recent call last):\n...\nAttributeError: 'PySide.QtGui.QHeaderView' object has no attribute 'setSectionResizeMode'\n```\n\n----------------------------------------\n\nTITLE: QtCore.Slot usage in PyQt4 (Python 2)\nDESCRIPTION: Demonstrates that PyQt4 does not support the `result` keyword argument when creating a `QtCore.Slot` in Python 2, leading to a TypeError. This highlights a difference in the API compatibility across Qt bindings.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# PyQt4, Python2\n>>> from Qt import QtCore, QtWidgets\n>>> slot = QtCore.Slot(QtWidgets.QWidget)\n>>> slot = QtCore.Slot(QtWidgets.QWidget, result=None)\nTraceback (most recent call last):\n...\nTypeError: string or ASCII unicode expected not 'NoneType'\n```\n\n----------------------------------------\n\nTITLE: QtCore.Slot usage in PyQt4 (Python 3)\nDESCRIPTION: Shows that PyQt4 does not support the `result` keyword argument when creating a `QtCore.Slot` in Python 3, resulting in a TypeError. This illustrates an incompatibility in the `QtCore.Slot` API.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# PyQt4, Python3\n>>> from Qt import QtCore, QtWidgets\n>>> slot = QtCore.Slot(QtWidgets.QWidget)\n>>> slot = QtCore.Slot(QtWidgets.QWidget, result=None)\nTraceback (most recent call last):\n...\nTypeError: bytes or ASCII string expected not 'NoneType'\n```\n\n----------------------------------------\n\nTITLE: QAction.triggered signal in PyQt4\nDESCRIPTION: Shows that the `triggered` signal in PyQt4 requires a boolean argument.  The example shows that emitting the signal without an argument causes an error.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# PyQt4, untested\n>>> from Qt import QtCore, QtWidgets\n>>> obj = QtCore.QObject()\n>>> action = QtWidgets.QAction(obj)\n>>> action.triggered.emit(True)\n>>> action.triggered.emit()\nTraceback (most recent call last):\n...\nTypeError: QAction.triggered[bool] signal has 1 argument(s) but 0 provided\n```\n\n----------------------------------------\n\nTITLE: QtWidgets.qApp availability in PySide2\nDESCRIPTION: Demonstrates that `qApp` is not directly available in `QtWidgets` when using Qt.py.  The `qApp` variable is not automatically updated, leading to inconsistencies.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# PySide2\n>>> from Qt import QtWidgets\n>>> \"qApp\" in dir(QtWidgets)\nFalse\n```\n\n----------------------------------------\n\nTITLE: QItemSelection length in PyQt4\nDESCRIPTION: Demonstrates using `len(selection)` to check if a `QItemSelection` is empty in PyQt4. This provides a cross-compatible workaround for the missing `empty` attribute.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# PyQt4\n>>> from Qt import QtCore\n>>> selection = QtCore.QItemSelection()\n>>> len(selection)\n0\n```\n\n----------------------------------------\n\nTITLE: QtCompat.wrapInstance behavior in PySide2\nDESCRIPTION: Demonstrates the behavior of `QtCompat.wrapInstance` in PySide2, where it returns a different object instance than the original. This example shows how the wrapped instance is not the same as the original, although it shares the same properties.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# PySide2, untested\n>>> from Qt import QtCompat, QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> button = QtWidgets.QPushButton(\"Hello world\")\n>>> button.setObjectName(\"MySpecialButton\")\n>>> pointer = QtCompat.getCppPointer(button)\n>>> widget = QtCompat.wrapInstance(long(pointer))\n>>> assert isinstance(widget, QtWidgets.QWidget), widget\n>>> assert widget.objectName() == button.objectName()\n>>> widget == button\nFalse\n```\n\n----------------------------------------\n\nTITLE: QtCompat.wrapInstance behavior in PyQt5\nDESCRIPTION: Shows the behavior of `QtCompat.wrapInstance` in PyQt5, where it returns the same object instance as the original.  The wrapped instance is identical to the original object.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# PyQt5\n>>> from Qt import QtCompat, QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> button = QtWidgets.QPushButton(\"Hello world\")\n>>> button.setObjectName(\"MySpecialButton\")\n>>> pointer = QtCompat.getCppPointer(button)\n>>> widget = QtCompat.wrapInstance(long(pointer))\n>>> assert isinstance(widget, QtWidgets.QWidget), widget\n>>> assert widget.objectName() == button.objectName()\n>>> widget == button\nTrue\n```\n\n----------------------------------------\n\nTITLE: Accessing Static Members from Instances (Python)\nDESCRIPTION: This snippet illustrates the change in Qt 6 where static members are no longer accessible directly from class instances. It shows the required syntax for accessing static members.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\nfont = QFont()\nfont.setWeight(QFont.Bold)\n```\n\nLANGUAGE: Python\nCODE:\n```\nfont = QFont()\nfont.setWeight(type(font).Bold)\n```\n\n----------------------------------------\n\nTITLE: Installing Qt.py via pip in Bash\nDESCRIPTION: This code snippet shows the command to install Qt.py using pip. This will install the latest version of Qt.py from PyPI.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install Qt.py\n```\n\n----------------------------------------\n\nTITLE: Running QtSiteConfig example with Python\nDESCRIPTION: These Bash commands demonstrate how to run a Python script that utilizes `QtSiteConfig.py`. The first example shows running the script from the same directory as `QtSiteConfig.py`. The second example shows how to modify the `PYTHONPATH` to include the directory containing `QtSiteConfig.py` if running from a different directory.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/examples/QtSiteConfig/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cd to/this/directory\n$ python main.py\n# Qt.QtCore was successfully removed by QSiteConfig.py\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ set PYTHONPATH=path/to/QtSiteConfig/\n$ python main.py\n# Qt.QtCore was successfully removed by QSiteConfig.py\n```\n\n----------------------------------------\n\nTITLE: Customize Qt.py with QtSiteConfig (Python)\nDESCRIPTION: This Python code demonstrates how to create a `QtSiteConfig.py` module to customize Qt.py's behavior at runtime. The `update_members` function allows modifying the modules exposed by Qt.py. In this example, the `QtCore` module is removed from the available members.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# QtSiteConfig.py\ndef update_members(members):\n    \"\"\"Called by Qt.py at run-time to modify the modules it makes available.\n\n    Arguments:\n        members (dict): The members considered by Qt.py\n    \"\"\"\n    members.pop(\"QtCore\")\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Overwriting `translate` Function in Python\nDESCRIPTION: This code snippet demonstrates an incorrect approach to modifying the `translate` function in Qt applications. It directly overwrites the original function, which can lead to incompatibility issues with other bindings.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Wrong\nold_translate_fn = QtWidgets.QApplication.translate\n\ndef translate(context, key, disambiguation=None, encoding=None, n=0):\n    return old_translate_fn(context, key, disambiguation, n)\n\n# Overwrite original with an incompatible version\nQtWidgets.QApplication.translate = staticmethod(translate)\n```\n\n----------------------------------------\n\nTITLE: Uploading to PyPI (Bash)\nDESCRIPTION: These commands are used to build and upload a new release of Qt.py to PyPI. It assumes that the user has the necessary permissions to upload to the PyPI repository.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_19\n\nLANGUAGE: Bash\nCODE:\n```\ncd Qt.py\npython .\\setup.py sdist bdist_wheel\npython -m twine upload .\\dist\\*\n```\n\n----------------------------------------\n\nTITLE: QAbstractItemModel.createIndex behavior in PyQt4\nDESCRIPTION: Demonstrates how PyQt4 coerces negative internal IDs for QAbstractItemModel indexes into large unsigned values, unlike PySide.  This code snippet provides an example of the PyQt4 behavior. It is critical to account for this divergence when dealing with internal IDs.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# PyQt4\n>>> from Qt import QtGui\n>>> model = QtGui.QStandardItemModel()\n>>> index = model.createIndex(0, 0, -1)\n>>> int(index.internalId()) == 18446744073709551615\nTrue\n```\n\n----------------------------------------\n\nTITLE: Incorrect QWidget Implementation in Python\nDESCRIPTION: This code demonstrates an anti-pattern where a custom QWidget implementation is used which introduces potential bugs by adding custom logic. This approach is discouraged as it increases the surface area for errors.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Wrong\ndef QWidget(source_binding, *args, **kwargs):\n    # Potential bug 1\n    if kwargs[\"__special_option\"] == 0x1336:\n        kwargs[\"__magic\"] = 0x1337\n\n    # Potential bug 2\n    return getattr(source_binding, \"QWidget\")(*args, *kwargs)\n\n# Potential bug 3\nQtWidgets.QWidget = lambda *args, **kwargs: QWidget(PySide, *args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: PySide2 class alias (Python)\nDESCRIPTION: This Python code shows how Qt.py aliases PySide2 classes to match the official Qt documentation, ensuring cross-binding compatibility for commonly used Qt classes.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# PySide2 adheres to the official documentation\nPySide2.QtCore.QStringListModel = PySide2.QtGui.QStringListModel\n```\n\n----------------------------------------\n\nTITLE: Grabbing Widget (PySide)\nDESCRIPTION: This snippet demonstrates how to grab a widget as a QPixmap using `QtGui.QPixmap.grabWidget` in PySide. It creates a simple application with a button and then grabs the button's contents as an image.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from Qt import QtGui, QtWidgets\n>>> app = QtWidgets.QApplication(sys.argv)\n>>> button = QtWidgets.QPushButton(\"Hello world\")\n>>> pixmap = QtGui.QPixmap.grabWidget(button)\n```\n\n----------------------------------------\n\nTITLE: Running tests using Docker (Bash)\nDESCRIPTION: These commands use Docker to run the Qt.py tests in an isolated environment. They mount the current directory into the Docker container and specify the Python version to use for testing. The commands are given for both Linux/OSX and Windows environments.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/README.md#_snippet_18\n\nLANGUAGE: Bash\nCODE:\n```\ncd Qt.py\n\n# Run nosetests (Linux/OSX)\ndocker run --rm -v $(pwd):/Qt.py -e PYTHON=2.7 fredrikaverpil/qt.py:2018\ndocker run --rm -v $(pwd):/Qt.py -e PYTHON=3.4 fredrikaverpil/qt.py:2018\ndocker run --rm -v $(pwd):/Qt.py -e PYTHON=3.5 fredrikaverpil/qt.py:2018\ndocker run --rm -v $(pwd):/Qt.py -e PYTHON=3.6 fredrikaverpil/qt.py:2018\n\n# Run nosetests (Windows)\ndocker run --rm -v %CD%:/Qt.py -e PYTHON=2.7 fredrikaverpil/qt.py:2018\ndocker run --rm -v %CD%:/Qt.py -e PYTHON=3.4 fredrikaverpil/qt.py:2018\ndocker run --rm -v %CD%:/Qt.py -e PYTHON=3.5 fredrikaverpil/qt.py:2018\ndocker run --rm -v %CD%:/Qt.py -e PYTHON=3.6 fredrikaverpil/qt.py:2018\n```\n\n----------------------------------------\n\nTITLE: Qt Enum Conversion Script Usage\nDESCRIPTION: This bash script snippet demonstrates how to use the `Qt_convert_enum.py` script to identify and replace short-form enums with fully qualified enum names in a given directory. It includes commands to install necessary dependencies and execute the script with optional flags.\nSOURCE: https://github.com/mottosso/qt.py/blob/master/CAVEATS.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n$ pip3 install Qt.py PySide2\n$ python3 .../Qt_convert_enum.py /path/to/code/directory/to/update\n```"
  }
]