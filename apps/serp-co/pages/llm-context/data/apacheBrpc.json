[
  {
    "owner": "apache",
    "repo": "brpc",
    "content": "TITLE: Configuring Build Flags and Dependencies with CMake (CMake Language)\nDESCRIPTION: This script initializes compilation policies, sets up required variables and package generators, manages optional feature toggles (GLOG, Thrift, Snappy, RDMA, etc.), checks for compiler and OS compatibility, and configures corresponding compilation flags. It also finds and validates external dependencies like LevelDB, Protobuf, Gflags, Threads, OpenSSL/BoringSSL, MesaLink and others, halting execution on missing required libraries. This ensures that all brpc dependencies are properly resolved and that build options are tuned for the target platform and feature set. The script is designed for use as the central build configuration entry point in a CMake-based C++ project and is intended to be run by invoking CMake; it expects supporting CMake modules and the project's source layout to be present. Limitations include dependency on the environmental setup and supporting CMake files; it assumes use on Unix-like systems and may need adaptation for other environments.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(POLICY CMP0042)\n    cmake_policy(SET CMP0042 NEW)\nendif()\n\nset(BRPC_VERSION 1.12.1)\n\nSET(CPACK_GENERATOR \"DEB\")\nSET(CPACK_DEBIAN_PACKAGE_MAINTAINER \"brpc authors\")\nINCLUDE(CPack)\n\nif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n    # require at least gcc 4.8\n    if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.8)\n        message(FATAL_ERROR \"GCC is too old, please install a newer version supporting C++11\")\n    endif()\nelif(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n    # require at least clang 3.3\n    if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 3.3)\n        message(FATAL_ERROR \"Clang is too old, please install a newer version supporting C++11\")\n    endif()\nelse()\n    message(WARNING \"You are using an unsupported compiler! Compilation has only been tested with Clang and GCC.\")\nendif()\n\nset(WITH_GLOG_VAL \"0\")\nif(WITH_GLOG)\n    set(WITH_GLOG_VAL \"1\")\n    set(BRPC_WITH_GLOG 1)\nendif()\n\nif(WITH_DEBUG_SYMBOLS)\n    set(DEBUG_SYMBOL \"-g\")\nendif()\n\nset(WITH_DEBUG_LOCK_VAL \"0\")\nif(WITH_DEBUG_LOCK)\n    set(WITH_DEBUG_LOCK_VAL \"1\")\nendif()\n\nif(WITH_THRIFT)\n    set(THRIFT_CPP_FLAG \"-DENABLE_THRIFT_FRAMED_PROTOCOL\")\n    find_library(THRIFT_LIB NAMES thrift)\n    if (NOT THRIFT_LIB)\n        message(FATAL_ERROR \"Fail to find Thrift\")\n    endif()\nendif()\n\nif (WITH_BTHREAD_TRACER)\n    if (NOT (CMAKE_SYSTEM_NAME STREQUAL \"Linux\")  OR NOT (CMAKE_SYSTEM_PROCESSOR MATCHES \"x86_64\"))\n        message(FATAL_ERROR \"bthread tracer is only supported on Linux x86_64 platform\")\n    endif()\n    find_path(LIBUNWIND_INCLUDE_PATH NAMES libunwind.h)\n    find_library(LIBUNWIND_LIB NAMES unwind)\n    find_library(LIBUNWIND_X86_64_LIB NAMES unwind-x86_64)\n    if (NOT LIBUNWIND_INCLUDE_PATH OR NOT LIBUNWIND_LIB)\n        message(FATAL_ERROR \"Fail to find libunwind, which is needed by bthread tracer\")\n    endif()\n    add_definitions(-DBRPC_BTHREAD_TRACER)\n    include_directories(${LIBUNWIND_INCLUDE_PATH})\nendif ()\n\nset(WITH_RDMA_VAL \"0\")\nif(WITH_RDMA)\n    set(WITH_RDMA_VAL \"1\")\nendif()\n\nset(WITH_DEBUG_BTHREAD_SCHE_SAFETY_VAL \"0\")\nif(WITH_DEBUG_BTHREAD_SCHE_SAFETY)\n    set(WITH_DEBUG_BTHREAD_SCHE_SAFETY_VAL \"1\")\nendif()\n\ninclude(GNUInstallDirs)\n\nconfigure_file(${PROJECT_SOURCE_DIR}/config.h.in ${PROJECT_SOURCE_DIR}/src/butil/config.h @ONLY)\n\nlist(APPEND CMAKE_MODULE_PATH \"${PROJECT_SOURCE_DIR}/cmake\")\n\nfind_package(GFLAGS REQUIRED)\n\ninclude_directories(\n    ${PROJECT_SOURCE_DIR}/src\n    ${CMAKE_CURRENT_BINARY_DIR}\n)\n\nexecute_process(\n    COMMAND bash -c \"${PROJECT_SOURCE_DIR}/tools/get_brpc_revision.sh ${PROJECT_SOURCE_DIR} | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE BRPC_REVISION\n)\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\n    set(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} -Wno-deprecated-declarations -Wno-inconsistent-missing-override\")\nendif()\n\nset(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} ${DEFINE_CLOCK_GETTIME} -DBRPC_WITH_GLOG=${WITH_GLOG_VAL} -DBRPC_WITH_RDMA=${WITH_RDMA_VAL} -DBRPC_DEBUG_BTHREAD_SCHE_SAFETY=${WITH_DEBUG_BTHREAD_SCHE_SAFETY_VAL} -DBRPC_DEBUG_LOCK=${WITH_DEBUG_LOCK_VAL}\")\nif (WITH_ASAN)\n    set(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} -fsanitize=address\")\n    set(CMAKE_C_FLAGS \"${CMAKE_CPP_FLAGS} -fsanitize=address\")\nendif()\nif(WITH_MESALINK)\n    set(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} -DUSE_MESALINK\")\nendif()\nset(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} -DBTHREAD_USE_FAST_PTHREAD_MUTEX -D__const__=__unused__ -D_GNU_SOURCE -DUSE_SYMBOLIZE -DNO_TCMALLOC -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -DBRPC_REVISION=\\\\\\\"${BRPC_REVISION}\\\\\\\" -D__STRICT_ANSI__\")\nset(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} ${DEBUG_SYMBOL} ${THRIFT_CPP_FLAG}\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CPP_FLAGS} -O2 -pipe -Wall -W -fPIC -fstrict-aliasing -Wno-invalid-offsetof -Wno-unused-parameter -fno-omit-frame-pointer\")\nset(CMAKE_C_FLAGS \"${CMAKE_CPP_FLAGS} -O2 -pipe -Wall -W -fPIC -fstrict-aliasing -Wno-unused-parameter -fno-omit-frame-pointer\")\n\nmacro(use_cxx11)\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\nendmacro(use_cxx11)\n\nif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n    #required by butil/crc32.cc to boost performance for 10x\n    if((CMAKE_SYSTEM_PROCESSOR MATCHES \"(x86)|(X86)|(amd64)|(AMD64)\") AND NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.4))\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -msse4 -msse4.2\")\n    elseif((CMAKE_SYSTEM_PROCESSOR MATCHES \"aarch64\"))\n        # segmentation fault in libcontext\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fno-gcse\")\n    endif()\n    if(NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0))\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-aligned-new\")\n    endif()\nendif()\n\nfind_package(Protobuf REQUIRED)\nif(Protobuf_VERSION GREATER 4.21)\n    # required by absl\n    set(CMAKE_CXX_STANDARD 17)\n\n    find_package(absl REQUIRED CONFIG)\n    set(protobuf_ABSL_USED_TARGETS\n        absl::absl_check\n        absl::absl_log\n        absl::algorithm\n        absl::base\n        absl::bind_front\n        absl::bits\n        absl::btree\n        absl::cleanup\n        absl::cord\n        absl::core_headers\n        absl::debugging\n        absl::die_if_null\n        absl::dynamic_annotations\n        absl::flags\n        absl::flat_hash_map\n        absl::flat_hash_set\n        absl::function_ref\n        absl::hash\n        absl::layout\n        absl::log_initialize\n        absl::log_severity\n        absl::memory\n        absl::node_hash_map\n        absl::node_hash_set\n        absl::optional\n        absl::span\n        absl::status\n        absl::statusor\n        absl::strings\n        absl::synchronization\n        absl::time\n        absl::type_traits\n        absl::utility\n        absl::variant\n    )\nelse()\n    use_cxx11()\nendif()\nfind_package(Threads REQUIRED)\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\n\nif(WITH_SNAPPY)\n    find_path(SNAPPY_INCLUDE_PATH NAMES snappy.h)\n    find_library(SNAPPY_LIB NAMES snappy)\n    if ((NOT SNAPPY_INCLUDE_PATH) OR (NOT SNAPPY_LIB))\n        message(FATAL_ERROR \"Fail to find snappy\")\n    endif()\n    include_directories(${SNAPPY_INCLUDE_PATH})\nendif()\n\nif(WITH_GLOG)\n    find_path(GLOG_INCLUDE_PATH NAMES glog/logging.h)\n    find_library(GLOG_LIB NAMES glog)\n    if((NOT GLOG_INCLUDE_PATH) OR (NOT GLOG_LIB))\n        message(FATAL_ERROR \"Fail to find glog\")\n    endif()\n    include_directories(${GLOG_INCLUDE_PATH})\nendif()\n\nif(WITH_MESALINK)\n    find_path(MESALINK_INCLUDE_PATH NAMES mesalink/openssl/ssl.h)\n    find_library(MESALINK_LIB NAMES mesalink)\n    if((NOT MESALINK_INCLUDE_PATH) OR (NOT MESALINK_LIB))\n        message(FATAL_ERROR \"Fail to find MesaLink\")\n    else()\n        message(STATUS \"Found MesaLink: ${MESALINK_LIB}\")\n    endif()\n    include_directories(${MESALINK_INCLUDE_PATH})\nendif()\n\nif(WITH_RDMA)\n    message(\"brpc compile with rdma\")\n    find_path(RDMA_INCLUDE_PATH NAMES infiniband/verbs.h)\n    find_library(RDMA_LIB NAMES ibverbs)\n    if((NOT RDMA_INCLUDE_PATH) OR (NOT RDMA_LIB))\n        message(FATAL_ERROR \"Fail to find ibverbs\")\n    endif()\nendif()\n\nfind_library(PROTOC_LIB NAMES protoc)\nif(NOT PROTOC_LIB)\n    message(FATAL_ERROR \"Fail to find protoc lib\")\nendif()\n\nif(WITH_BORINGSSL)\n    find_package(BoringSSL)\n    include_directories(${BORINGSSL_INCLUDE_DIR})\nelse()\n    if(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\" AND NOT OPENSSL_ROOT_DIR)\n        set(OPENSSL_ROOT_DIR\n            \"/usr/local/opt/openssl\" # Homebrew installed OpenSSL\n        )\n    endif()\n\n    find_package(OpenSSL)\n    include_directories(${OPENSSL_INCLUDE_DIR})\nendif()\n\ninclude_directories(\n        ${GFLAGS_INCLUDE_PATH}\n        ${PROTOBUF_INCLUDE_DIRS}\n        ${LEVELDB_INCLUDE_PATH}\n        )\n\nset(DYNAMIC_LIB\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES} ${protobuf_ABSL_USED_TARGETS}\n    ${LEVELDB_LIB}\n    ${PROTOC_LIB}\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${THRIFT_LIB}\n    dl\n    z)\n\nif(WITH_BORINGSSL)\n    list(APPEND DYNAMIC_LIB ${BORINGSSL_SSL_LIBRARY})\n    list(APPEND DYNAMIC_LIB ${BORINGSSL_CRYPTO_LIBRARY})\nelse()\n    list(APPEND DYNAMIC_LIB ${OPENSSL_CRYPTO_LIBRARY})\n    if(WITH_MESALINK)\n        list(APPEND DYNAMIC_LIB ${MESALINK_LIB})\n    else()\n        list(APPEND DYNAMIC_LIB ${OPENSSL_SSL_LIBRARY})\n    endif()\nendif()\n\nif(WITH_RDMA)\n    list(APPEND DYNAMIC_LIB ${RDMA_LIB})\nendif()\n\nset(BRPC_PRIVATE_LIBS \"-lgflags -lprotobuf -lleveldb -lprotoc -lssl -lcrypto -ldl -lz\")\n\nif(WITH_GLOG)\n    set(DYNAMIC_LIB ${GLOG_LIB} ${DYNAMIC_LIB})\n    set(BRPC_PRIVATE_LIBS \"-lglog ${BRPC_PRIVATE_LIBS}\")\nendif()\n\nif(WITH_SNAPPY)\n    set(DYNAMIC_LIB ${DYNAMIC_LIB} ${SNAPPY_LIB})\n    set(BRPC_PRIVATE_LIBS \"${BRPC_PRIVATE_LIBS} -lsnappy\")\nendif()\n\nif (WITH_BTHREAD_TRACER)\n    set(DYNAMIC_LIB ${DYNAMIC_LIB} ${LIBUNWIND_LIB} ${LIBUNWIND_X86_64_LIB})\n    set(BRPC_PRIVATE_LIBS \"${BRPC_PRIVATE_LIBS} -lunwind -lunwind-x86_64\")\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB} rt)\n    set(BRPC_PRIVATE_LIBS \"${BRPC_PRIVATE_LIBS} -lrt\")\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n\n```\n\n----------------------------------------\n\nTITLE: Defining Echo RPC Interfaces using Protobuf - Proto\nDESCRIPTION: Defines EchoRequest and EchoResponse messages and the EchoService with a single rpc method using Protocol Buffers syntax, enabling code generation for C++ services in brpc. The 'cc_generic_services = true' option tells protoc to generate the C++ service base classes needed for implementation. Required fields enforce field presence, and the service definition establishes the contract for the Echo functionality.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_0\n\nLANGUAGE: Proto\nCODE:\n```\noption cc_generic_services = true;\n\nmessage EchoRequest {\n      required string message = 1;\n};\nmessage EchoResponse {\n      required string message = 1;\n};\n\nservice EchoService {\n      rpc Echo(EchoRequest) returns (EchoResponse);\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing EchoService with brpc and Protobuf - C++\nDESCRIPTION: Implements the EchoService interface in C++ as generated from the protobuf definition, overriding the Echo RPC method to echo the request message. Uses brpc::ClosureGuard for safe callback handling, employs type casting for brpc-specific controller access, and ensures 'done->Run()' is always called using RAII for correct brpc lifecycle. Requires brpc and Protobuf C++ dependencies, including the generated echo.pb.h.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include \"echo.pb.h\"\n...\nclass MyEchoService : public EchoService {\npublic:\n    void Echo(::google::protobuf::RpcController* cntl_base,\n              const ::example::EchoRequest* request,\n              ::example::EchoResponse* response,\n              ::google::protobuf::Closure* done) {\n        // This RAII object calls done->Run() automatically at exit.\n        brpc::ClosureGuard done_guard(done);\n         \n        brpc::Controller* cntl = static_cast<brpc::Controller*>(cntl_base);\n \n        // fill response\n        response->set_message(request->message());\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing brpc::Channel for Single Server Connection in C++\nDESCRIPTION: This snippet outlines the overloaded Init functions for brpc::Channel tailored to connect to a single server using different parameter types. Each function requires server address and an optional pointer to ChannelOptions, defaulting to standard values if NULL. These functions are core to starting a new channel session. Input parameters are server address or endpoint; output is an initialized channel or error code.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// options\\u4e3aNULL\\u65f6\\u53d6\\u9ed8\\u8ba4\\u503c\nint Init(EndPoint server_addr_and_port, const ChannelOptions* options);\nint Init(const char* server_addr_and_port, const ChannelOptions* options);\nint Init(const char* server_addr, int port, const ChannelOptions* options);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous RPC Call with NewCallback in brpc\nDESCRIPTION: Implementation of an asynchronous RPC call using NewCallback. This approach creates a callback function that handles RPC completion and manages memory for response and controller objects.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\nstatic void OnRPCDone(MyResponse* response, brpc::Controller* cntl) {\n    // unique_ptr helps us to delete response/cntl automatically. unique_ptr in gcc 3.4 is an emulated version.\n    std::unique_ptr<MyResponse> response_guard(response);\n    std::unique_ptr<brpc::Controller> cntl_guard(cntl);\n    if (cntl->Failed()) {\n        // RPC failed. fields in response are undefined, don't use.\n    } else {\n        // RPC succeeded, response has what we want. Continue the post-processing.\n    }\n    // Closure created by NewCallback deletes itself at the end of Run.\n}\n\nMyResponse* response = new MyResponse;\nbrpc::Controller* cntl = new brpc::Controller;\nMyService_Stub stub(&channel);\n\nMyRequest request;  // you don't have to new request, even in an asynchronous call.\nrequest.set_foo(...);\ncntl->set_timeout_ms(...);\nstub.some_method(cntl, &request, response, brpc::NewCallback(OnRPCDone, response, cntl));\n```\n\n----------------------------------------\n\nTITLE: Decompressing HTTP Response Body Manually Using brpc in C++\nDESCRIPTION: This code snippet demonstrates how to manually decompress a gzip-compressed HTTP response body using brpc's gzip_decompress functionality. The example checks the Content-Encoding header, decompresses the body if needed, and swaps the decompressed data back into the response attachment. The main dependency is 'brpc/policy/gzip_compress.h', and it assumes the use of a brpc controller (cntl). The function operates on in-memory buffers and expects a 'gzip' encoded HTTP response; if decompression fails, it logs an error and aborts further processing.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_14\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/policy/gzip_compress.h>\n...\nconst std::string* encoding = cntl->http_response().GetHeader(\"Content-Encoding\");\nif (encoding != NULL && *encoding == \"gzip\") {\n    butil::IOBuf uncompressed;\n    if (!brpc::policy::GzipDecompress(cntl->response_attachment(), &uncompressed)) {\n        LOG(ERROR) << \"Fail to un-gzip response body\";\n        return;\n    }\n    cntl->response_attachment().swap(uncompressed);\n}\n// Now cntl->response_attachment() contains the decompressed data\n```\n\n----------------------------------------\n\nTITLE: Configuring Connection and RPC Timeouts in brpc (C++)\nDESCRIPTION: Shows the definition of the ChannelOptions struct in brpc that lets you configure connection timeout (connect_timeout_ms) and RPC operation timeout (timeout_ms). These options determine how long the system waits for a TCP connection and how long an RPC call may take before an error is triggered. Both parameters can be set to -1 to wait indefinitely, and their maximum values are very large (approx. 30 days). Proper configuration of these values requires understanding of network reliability and application needs. No external dependencies are required beyond standard brpc installation.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nstruct ChannelOptions {\n    ...\n    // Issue error when a connection is not established after so many\n    // milliseconds. -1 means wait indefinitely.\n    // Default: 200 (milliseconds)\n    // Maximum: 0x7fffffff (roughly 30 days)\n    int32_t connect_timeout_ms;\n\n    // Max duration of RPC over this Channel. -1 means wait indefinitely.\n    // Overridable by Controller.set_timeout_ms().\n    // Default: 500 (milliseconds)\n    // Maximum: 0x7fffffff (roughly 30 days)\n    int32_t timeout_ms;\n    ...\n};\n```\n\n----------------------------------------\n\nTITLE: Memory Fence Example - Safe Initialization\nDESCRIPTION: Shows correct usage of memory fences using std::atomic with release-acquire ordering to ensure proper thread synchronization.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/atomic_instructions.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\n// Thread1\n// std::atomic<bool> ready was initialized to false\np.init();\nready.store(true, std::memory_order_release);\n```\n\nLANGUAGE: c++\nCODE:\n```\n// Thread2\nif (ready.load(std::memory_order_acquire)) {\n    p.bar();\n}\n```\n\n----------------------------------------\n\nTITLE: Utilizing AddCommand Methods in RedisRequest with brpc in C++\nDESCRIPTION: Defines the available AddCommand functions (AddCommand, AddCommandV, and AddCommandByComponents) on RedisRequest for constructing Redis protocol commands with printf-style or binary-safe formats. Outlines input parameter types, describes error-handling behavior, and notes improved handling of quote boundaries and binary blobs compared to hiredis. Validates that on formatting errors, all further commands and calls will fail, and advises on usage for enhanced safety.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nbool AddCommand(const char* fmt, ...);\nbool AddCommandV(const char* fmt, va_list args);\nbool AddCommandByComponents(const butil::StringPiece* components, size_t n);\n```\n\n----------------------------------------\n\nTITLE: Implementing and Assigning a Custom RetryPolicy in brpc - C++\nDESCRIPTION: This C++ snippet demonstrates how to create a custom retry policy by inheriting from brpc::RetryPolicy, implementing DoRetry for custom HTTP status checks (e.g., HTTP_STATUS_FORBIDDEN), and assigning the policy instance to ChannelOptions.retry_policy. Required dependencies include brpc and its headers. The policy must remain valid during the Channel's lifetime, so singletons are recommended. The snippet shows how to activate the custom retry logic for a channel.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/retry_policy.h>\n\nclass MyRetryPolicy : public brpc::RetryPolicy {\npublic:\n    bool DoRetry(const brpc::Controller* cntl) const {\n        if (cntl->ErrorCode() == brpc::EHTTP && // http/h2 error\n            cntl->http_response().status_code() == brpc::HTTP_STATUS_FORBIDDEN) {\n            return true;\n        }\n        // Leave other cases to brpc.\n        return brpc::DefaultRetryPolicy()->DoRetry(cntl);\n    }\n};\n...\n\n// Assign the instance to ChannelOptions.retry_policy.\n// NOTE: retry_policy must be kept valid during lifetime of Channel, and Channel does not retry_policy, so in most cases RetryPolicy should be created by singleton..\nbrpc::ChannelOptions options;\nstatic MyRetryPolicy g_my_retry_policy;\noptions.retry_policy = &g_my_retry_policy;\n...\n```\n\n----------------------------------------\n\nTITLE: Initializing brpc::Channel for Server Cluster Connections in C++\nDESCRIPTION: This snippet presents the Init overload for connecting to a server cluster using naming services and load balancer configuration. Required parameters are the naming service URL, load balancer name, and a pointer to ChannelOptions. This function supports cluster discovery and flexible selection policies. Outputs are initialized channels ready for group communication or an error code.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint Init(const char* naming_service_url,\n         const char* load_balancer_name,\n         const ChannelOptions* options);\n```\n\n----------------------------------------\n\nTITLE: Creating brpc Channel for HTTP/HTTP2 - C++\nDESCRIPTION: This C++ snippet demonstrates how to initialize a brpc::Channel object for either HTTP or HTTP/2 communication by setting the protocol in ChannelOptions. It requires the brpc C++ library and proper linking to brpc and its dependencies. The snippet highlights that only the host and port parts of the URL are used, and logs an error if initialization fails. Input is a string URL and the output is the ready-to-use Channel or an error status.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::ChannelOptions options;\noptions.protocol = brpc::PROTOCOL_HTTP;  // or brpc::PROTOCOL_H2\nif (channel.Init(\"www.baidu.com\" /*any url*/, &options) != 0) {\n     LOG(ERROR) << \"Fail to initialize channel\";\n     return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating HTTP Request and Response Headers - C++\nDESCRIPTION: Shows how to retrieve and modify HTTP headers in brpc using the C++ API. Demonstrates case-insensitive header access, appending header values, and overwriting existing headers for both requests and responses. All header manipulations are performed via the Controller object passed to the service method. No extra dependencies besides brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// \\u83b7\\u5f97header\\u4e2d\\\"User-Agent\\\"\\u7684\\u503c\\uff0c\\u5927\\u5c0f\\u5199\\u4e0d\\u654f\\u611f\\u3002\\nconst std::string* user_agent_str = cntl->http_request().GetHeader(\"User-Agent\");\\nif (user_agent_str != NULL) {  // has the header\\n    LOG(TRACE) << \"User-Agent is \" << *user_agent_str;\\n}\\n...\\n \\n// \\u5728header\\u4e2d\\u589e\\u52a0\\\"Accept-encoding: gzip\\\"\\uff0c\\u5927\\u5c0f\\u5199\\u4e0d\\u654f\\u611f\\u3002\\ncntl->http_response().SetHeader(\"Accept-encoding\", \"gzip\");\\n// \\u8986\\u76d6\\u4e3a\\\"Accept-encoding: deflate\\\"\\ncntl->http_response().SetHeader(\"Accept-encoding\", \"deflate\");\\n// \\u589e\\u52a0\\u4e00\\u4e2avalue\\uff0c\\u9017\\u53f7\\u5206\\u9694\\uff0c\\u53d8\\u4e3a\\\"Accept-encoding: deflate,gzip\\\"\\ncntl->http_response().AppendHeader(\"Accept-encoding\", \"gzip\");\n```\n\n----------------------------------------\n\nTITLE: Aligning Variables by Cacheline for False Sharing Avoidance in C++\nDESCRIPTION: This code snippet refers to the approach of aligning variables or structs to cacheline boundaries using BAIDU_CACHELINE_ALIGNMENT from butil/macros.h for optimal multi-threaded performance in C++. This helps to avoid false sharing where unrelated variables on the same cacheline unintentionally hinder performance. The macro requires including <butil/macros.h>, and must be used as an annotation on struct or variable definitions. Implementation details can be found by searching for BAIDU_CACHELINE_ALIGNMENT in brpc source code.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/atomic_instructions.md#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <butil/macros.h>\\n\\nstruct alignas(64) Example {\\n    int value;\\n} BAIDU_CACHELINE_ALIGNMENT; // This tag ensures the struct is aligned to cacheline boundaries\n```\n\n----------------------------------------\n\nTITLE: Calculating Average with bvar::IntRecorder - brpc - C++\nDESCRIPTION: This code shows how to use bvar::IntRecorder to compute average values over a series of integers, such as collecting latencies. Input values are appended using <<; output is the computed average via average(). IntRecorder is a subclass of Variable and requires bvar linkage.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\n// For calculating average of numbers.\n// Example:\n//   IntRecorder latency;\n//   latency << 1 << 3 << 5;\n//   CHECK_EQ(3, latency.average());\nclass IntRecorder : public Variable;\n```\n\n----------------------------------------\n\nTITLE: Implementing bthread-local Storage Cleanup and Usage in Service Implementation (C++)\nDESCRIPTION: This example provides a complete pattern where a bthread_key_t is created in the EchoServiceImpl constructor (with a destructor for cleanup), destroyed in the destructor, and used in the Echo method to maintain per-bthread data. It leverages bthread_key_create, bthread_key_delete, bthread_getspecific, and bthread_setspecific, mirroring their pthread equivalents. This pattern ensures thread or bthread-local objects are available and cleaned up automatically for each request handled by EchoServiceImpl. Requires proper inclusion of MyThreadLocalData and brpc headers.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_34\n\nLANGUAGE: C++\nCODE:\n```\nstatic void my_thread_local_data_deleter(void* d) {\n    delete static_cast<MyThreadLocalData*>(d);\n}\n\nclass EchoServiceImpl : public example::EchoService {\npublic:\n    EchoServiceImpl() {\n        CHECK_EQ(0, bthread_key_create(&_tls2_key, my_thread_local_data_deleter));\n    }\n    ~EchoServiceImpl() {\n        CHECK_EQ(0, bthread_key_delete(_tls2_key));\n    };\n    ...\nprivate:\n    bthread_key_t _tls2_key;\n}\n\nclass EchoServiceImpl : public example::EchoService {\npublic:\n    ...\n    void Echo(google::protobuf::RpcController* cntl_base,\n              const example::EchoRequest* request,\n              example::EchoResponse* response,\n              google::protobuf::Closure* done) {\n        ...\n        // You can create bthread-local data for your own.\n        // The interfaces are similar with pthread equivalence:\n        //   pthread_key_create  -> bthread_key_create\n        //   pthread_key_delete  -> bthread_key_delete\n        //   pthread_getspecific -> bthread_getspecific\n        //   pthread_setspecific -> bthread_setspecific\n        MyThreadLocalData* tls2 = static_cast<MyThreadLocalData*>(bthread_getspecific(_tls2_key));\n        if (tls2 == NULL) {\n            tls2 = new MyThreadLocalData;\n            CHECK_EQ(0, bthread_setspecific(_tls2_key, tls2));\n        }\n        ...\n    }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Calculating Per-Second Mean Using bvar::PerSecond - C++\nDESCRIPTION: This snippet shows how to use bvar::PerSecond with an Adder to get the average value per second over a specified time window (60 seconds). The sum_per_second object calculates the per-second rate based on the Adder's accumulated value. Dependencies include the bvar library and setup for bvar::Adder. The main parameter is the reference to the Adder and the window size, with get_value() returning the averaged per-second value.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nbvar::Adder<int> sum;\n\n// sum_per_second.get_value()is summing every-second value over the last 60 seconds, if we omit the time window, it's set to 'bvar_dump_interval' by default\nbvar::PerSecond<bvar::Adder<int> > sum_per_second(&sum, 60);\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Options and Project Settings in CMake - CMake\nDESCRIPTION: This CMake script initializes the brpc project, enforces a minimum required CMake version of 2.8.12, and sets up various build options to enable or disable features such as logging (glog), security (MesaLink, BoringSSL), debugging, protocol tracing, compression (Snappy), RDMA, thread and lock debug options, and unit/fuzz testing. Dependencies include CMake itself and any third-party libraries corresponding to the chosen options. The key input is the set of option values (ON/OFF) used during CMake invocation; these control the enabled features, tests, and tools in the build. Output is the configuration of build-time compile definitions and conditional logic for subsequent CMake build steps. Limitations include reliance on specified CMake minimum version and associated feature support, as well as the availability of optional external libraries when options are enabled.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Licensed to the Apache Software Foundation (ASF) under one\\n# or more contributor license agreements.  See the NOTICE file\\n# distributed with this work for additional information\\n# regarding copyright ownership.  The ASF licenses this file\\n# to you under the Apache License, Version 2.0 (the\\n# \\\"License\\\"); you may not use this file except in compliance\\n# with the License.  You may obtain a copy of the License at\\n#\\n#   http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to in writing,\\n# software distributed under the License is distributed on an\\n# \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n# KIND, either express or implied.  See the License for the\\n# specific language governing permissions and limitations\\n# under the License.\\n\\ncmake_minimum_required(VERSION 2.8.12)\\nproject(brpc C CXX)\\n\\noption(WITH_GLOG \\\"With glog\\\" OFF)\\noption(WITH_MESALINK \\\"With MesaLink\\\" OFF)\\noption(WITH_BORINGSSL \\\"With BoringSSL\\\" OFF)\\noption(DEBUG \\\"Print debug logs\\\" OFF)\\noption(WITH_DEBUG_SYMBOLS \\\"With debug symbols\\\" ON)\\noption(WITH_THRIFT \\\"With thrift framed protocol supported\\\" OFF)\\noption(WITH_BTHREAD_TRACER \\\"With bthread tracer supported\\\" OFF)\\noption(WITH_SNAPPY \\\"With snappy\\\" OFF)\\noption(WITH_RDMA \\\"With RDMA\\\" OFF)\\noption(WITH_DEBUG_BTHREAD_SCHE_SAFETY \\\"With debugging bthread sche safety\\\" OFF)\\noption(WITH_DEBUG_LOCK \\\"With debugging lock\\\" OFF)\\noption(WITH_ASAN \\\"With AddressSanitizer\\\" OFF)\\noption(BUILD_UNIT_TESTS \\\"Whether to build unit tests\\\" OFF)\\noption(BUILD_FUZZ_TESTS \\\"Whether to build fuzz tests\\\" OFF)\\noption(BUILD_BRPC_TOOLS \\\"Whether to build brpc tools\\\" ON)\\noption(DOWNLOAD_GTEST \\\"Download and build a fresh copy of googletest. Requires Internet access.\\\" ON)\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Authentication in C++\nDESCRIPTION: Defines the Authenticator and AuthContext classes for implementing client identity verification on the server side.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nclass Authenticator {\npublic:\n    virtual int VerifyCredential(const std::string& auth_str,\n                                 const base::EndPoint& client_addr,\n                                 AuthContext* out_ctx) const = 0;\n};\n\nclass AuthContext {\npublic:\n    const std::string& user() const;\n    const std::string& group() const;\n    const std::string& roles() const;\n    const std::string& starter() const;\n    bool is_service() const;\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Memcached Channel with brpc in C++\nDESCRIPTION: Demonstrates setting up a brpc::Channel to communicate with a memcached server using the binary memcached protocol in C++. The code requires the brpc library and memcache headers, and initializes a channel to host 0.0.0.0:11211 (default memcached port) with the appropriate protocol option. Initialization errors are logged fatally and cause immediate termination. 'channel' is assumed to be a properly declared brpc::Channel instance in scope.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/memcache_client.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/memcache.h>\\n#include <brpc/channel.h>\\n \\nbrpc::ChannelOptions options;\\noptions.protocol = brpc::PROTOCOL_MEMCACHE;\\nif (channel.Init(\"0.0.0.0:11211\", &options) != 0) {  // 11211 is the default port for memcached\\n   LOG(FATAL) << \"Fail to init channel to memcached\";\\n   return -1;\\n}\\n... \n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP/2 Service Method Logic - brpc C++\nDESCRIPTION: This C++ snippet shows how to implement the service class defined by the proto, specifically the 'Echo' method. It inherits from the generated HttpService base and overrides the method signature, handling request/response via the brpc Controller. The implementation sets the response MIME type, iterates over the HTTP query parameters, appends the request body, and writes the result to the response attachment. Requires the brpc and protobuf libraries. Inputs include the request, response, and controller; output is a constructed plain text HTTP response. Limitations: request/response proto messages must be empty; all logic depends on Controller attachments and headers.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nclass HttpServiceImpl : public HttpService {\\npublic:\\n    ...\\n    virtual void Echo(google::protobuf::RpcController* cntl_base,\\n                      const HttpRequest* /*request*/,\\n                      HttpResponse* /*response*/,\\n                      google::protobuf::Closure* done) {\\n        brpc::ClosureGuard done_guard(done);\\n        brpc::Controller* cntl = static_cast<brpc::Controller*>(cntl_base);\\n \\n        // body is plain text\\n        cntl->http_response().set_content_type(\"text/plain\");\\n       \\n        // Use printed query string and body as the response.\\n        butil::IOBufBuilder os;\\n        os << \"queries:\";\\n        for (brpc::URI::QueryIterator it = cntl->http_request().uri().QueryBegin();\\n                it != cntl->http_request().uri().QueryEnd(); ++it) {\\n            os << ' ' << it->first << '=' << it->second;\\n        }\\n        os << \"\\nbody: \" << cntl->request_attachment() << '\\n';\\n        os.move_to(cntl->response_attachment());\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Parsing Protobuf from IOBuf in C++\nDESCRIPTION: Shows how to parse protobuf messages and custom formats from IOBuf using zero-copy streams.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/iobuf.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nIOBufAsZeroCopyInputStream wrapper(&iobuf);\npb_message.ParseFromZeroCopyStream(&wrapper);\n```\n\nLANGUAGE: c++\nCODE:\n```\nIOBufAsZeroCopyInputStream wrapper(&iobuf);\nCodedInputStream coded_stream(&wrapper);\ncoded_stream.ReadLittleEndian32(&value);\n...\n```\n\n----------------------------------------\n\nTITLE: Initializing Channel for Memcached Connection in C++\nDESCRIPTION: Creates a Channel configured with the memcached protocol to establish a connection to a memcached server. The code initializes the channel with the default memcached port 11211 and sets the protocol type to PROTOCOL_MEMCACHE.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/memcache_client.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/memcache.h>\n#include <brpc/channel.h>\n \nbrpc::ChannelOptions options;\noptions.protocol = brpc::PROTOCOL_MEMCACHE;\nif (channel.Init(\"0.0.0.0:11211\", &options) != 0) {  // 11211是memcached的默认端口\n   LOG(FATAL) << \"Fail to init channel to memcached\";\n   return -1;\n}\n... \n```\n\n----------------------------------------\n\nTITLE: Initializing DynamicPartitionChannel in brpc (C++)\nDESCRIPTION: This C++ snippet initializes a brpc::DynamicPartitionChannel with a custom partition parser, sets a fail_limit for RPC failures, and loads partitioning/server information from file://server_list using round-robin. Dependencies include brpc libraries and a user-defined MyPartitionParser class. Inputs include server list URI, load balancing policy, PartitionChannelOptions with fail_limit; outputs are success/failure status and operational channel object. Proper initialization enables dynamic adaptation to partition changes.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\n    ...\n    brpc::DynamicPartitionChannel channel;\n    brpc::PartitionChannelOptions options;\n    // Failure on any single partition fails the RPC immediately. You can use a more relaxed value\n    options.fail_limit = 1;                         \n    if (channel.Init(new MyPartitionParser(), \"file://server_list\", \"rr\", &options) != 0) {\n        LOG(ERROR) << \"Fail to init channel\";\n        return -1;\n    }\n    ...\n```\n\n----------------------------------------\n\nTITLE: Basic RPC Method Call using Stub in brpc\nDESCRIPTION: Example of making an RPC call using a generated protobuf stub. The stub is created with a channel reference and the desired method is called with appropriate parameters.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\nXXX_Stub stub(&channel);\nstub.some_method(controller, request, response, done);\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Authentication with brpc in C++\nDESCRIPTION: Details setting up Redis authentication by creating a brpc::policy::RedisAuthenticator with a password and assigning it to ChannelOptions before channel initialization. This enables clients to connect to password-protected Redis servers through brpc. It is essential to release any dynamically allocated authenticator object later if not managed by the library.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::ChannelOptions options;\nbrpc::policy::RedisAuthenticator* auth = new brpc::policy::RedisAuthenticator(\"my_password\");\noptions.auth = auth;\n```\n\n----------------------------------------\n\nTITLE: Using bvar::Adder for Running Sum - brpc - C++\nDESCRIPTION: This snippet demonstrates bvar::Adder, a Reducer specialization for summing up inputs (supporting both integers and floating points). Adder requires operator+ support on the stored type. Input is a sequence of values streamed in via <<; output is the final sum, queried via get_value(). Dependencies: bvar library and correct operator overload for custom types. For non-primitive types like std::string, this provides proof-of-concept string concatenation.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nbvar::Adder<int> value;\nvalue << 1 << 2 << 3 << -4;\nCHECK_EQ(2, value.get_value());\n\nbvar::Adder<double> fp_value;  // may have warning\nfp_value << 1.0 << 2.0 << 3.0 << -4.0;\nCHECK_DOUBLE_EQ(2.0, fp_value.get_value());\n```\n\n----------------------------------------\n\nTITLE: Synchronous RPC Call in brpc\nDESCRIPTION: Example of making a synchronous RPC call where the call blocks until completion. It demonstrates proper request/response handling and error checking after the call completes.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\nMyRequest request;\nMyResponse response;\nbrpc::Controller cntl;\nXXX_Stub stub(&channel);\n\nrequest.set_foo(...);\ncntl.set_timeout_ms(...);\nstub.some_method(&cntl, &request, &response, NULL);\nif (cntl.Failed()) {\n    // RPC failed. fields in response are undefined, don't use.\n} else {\n    // RPC succeeded, response has what we want.\n}\n```\n\n----------------------------------------\n\nTITLE: Performing HTTP GET Request via brpc Channel - C++\nDESCRIPTION: This snippet shows how to use brpc::Controller with an initialized channel to make an HTTP GET request. It assumes an initialized brpc::Channel object and sets the request URI before calling Channel::CallMethod, with all other parameters except Controller and 'done' set to NULL. The response is received in cntl.response_attachment() as a butil::IOBuf. Dependencies: brpc and butil libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl;\ncntl.http_request().uri() = \"www.baidu.com/index.html\";  // Request URL\nchannel.CallMethod(NULL, &cntl, NULL, NULL, NULL/*done*/);\n```\n\n----------------------------------------\n\nTITLE: Managing Synchronous and Asynchronous RPCs with ClosureGuard - C++\nDESCRIPTION: Demonstrates patterns for proper callback (done) management with brpc::ClosureGuard in synchronous and asynchronous service methods. In synchronous services, ClosureGuard ensures 'done->Run()' is always called unless released, while in asynchronous methods, 'done_guard.release()' defers completion. This pattern reduces errors from premature returns, especially in complex or error-prone code paths.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nclass MyFooService: public FooService {\npublic:\n    // Synchronous\n    void SyncFoo(::google::protobuf::RpcController* cntl_base,\n                 const ::example::EchoRequest* request,\n                 ::example::EchoResponse* response,\n                 ::google::protobuf::Closure* done) {\n         brpc::ClosureGuard done_guard(done);\n         ...\n    }\n \n    // Aynchronous\n    void AsyncFoo(::google::protobuf::RpcController* cntl_base,\n                  const ::example::EchoRequest* request,\n                  ::example::EchoResponse* response,\n                  ::google::protobuf::Closure* done) {\n         brpc::ClosureGuard done_guard(done);\n         ...\n         done_guard.release();\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Reducing Values with bvar::Reducer - brpc - C++\nDESCRIPTION: This template defines a generic Reducer for bvar, using a binary operator that must be commutative, associative, and side-effect-free. If the requirements aren't met, results may be undefined. Intended for reducing values safely across threads (e.g., summing or computing min/max). Input is a stream of values and an operator type; output is the collapsed value. Dependencies: bvar header and mindful operator definition.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\n// Reduce multiple values into one with `Op': e1 Op e2 Op e3 ...\n// `Op' shall satisfy:\n//   - associative:     a Op (b Op c) == (a Op b) Op c\n//   - commutative:     a Op b == b Op a;\n//   - no side effects: a Op b never changes if a and b are fixed.\n// otherwise the result is undefined.\ntemplate <typename T, typename Op>\nclass Reducer : public Variable;\n```\n\n----------------------------------------\n\nTITLE: Implementing and Installing a Custom Naming Service Filter - BRPC - C++\nDESCRIPTION: This snippet illustrates how to implement a tag-based server filter by deriving from brpc::NamingServiceFilter. The Accept method checks the server's tag and passes only those matching 'main'. The filter is instantiated and assigned to the ChannelOptions' ns_filter property, thus affecting which servers are considered for RPC calls. The demonstration includes correct integration of the filter with brpc's client connection workflow. Requires brpc and standard C++ libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nclass MyNamingServiceFilter : public brpc::NamingServiceFilter {\npublic:\n    bool Accept(const brpc::ServerNode& server) const {\n        return server.tag == \"main\";\n    }\n};\n\nint main() {\n    ...\n    MyNamingServiceFilter my_filter;\n    ...\n    brpc::ChannelOptions options;\n    options.ns_filter = &my_filter;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Channel Initialization for Cluster/Naming Service Connection - C++\nDESCRIPTION: This code snippet presents the Init() method used to connect a brpc Channel to a cluster using a naming service and load balancer. It requires specifying a naming_service_url, load_balancer_name, and ChannelOptions pointer. The method enables dynamic server list discovery and load balancing via different protocols (e.g., bns, file, list, http, https, consul). Inputs are the naming service parameters and options; output is a ready-to-use Channel connected to a dynamic cluster.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nint Init(const char* naming_service_url,\\n         const char* load_balancer_name,\\n         const ChannelOptions* options);\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building Partition Echo Example - CMake - CMake\nDESCRIPTION: This CMake script prepares the build environment for the Partition Echo example, specifying minimum CMake version, locating external dependencies (such as brpc, protobuf, thrift, gperftools, gflags, leveldb, and OpenSSL), and configuring platform-specific options for macOS (Darwin). It sets required C++ compiler flags, generates protobuf sources, and defines two executable targets: client and server. The file ensures all dependencies are explicitly located and added with appropriate include/link directories, supporting both static and dynamic library linking, and finalizes the build by copying supporting server_list files to the build directory. Expected inputs include valid system installations of all dependencies. Outputs are compiled client/server binaries. Limitations: build may fail if any dependency is missing or incorrectly configured.\nSOURCE: https://github.com/apache/brpc/blob/master/example/partition_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(partition_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(GPERFTOOLS_INCLUDE_DIR NAMES gperftools/heap-profiler.h)\nfind_library(GPERFTOOLS_LIBRARIES NAMES tcmalloc_and_profiler)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n\nfile(COPY ${PROJECT_SOURCE_DIR}/server_list\n     DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Adding Sub Channels to SelectiveChannel - brpc - C++\nDESCRIPTION: Demonstrates how to dynamically add a sub-channel to a SelectiveChannel using AddChannel in brpc. The second parameter, ChannelHandle, is optional for later removal; if not needed, it can be NULL. Ownership of sub-channels is always held by SelectiveChannel. The sub_channel must be a subclass of brpc::ChannelBase. Input includes a pointer to the initialized sub_channel; output is success/failure (0/-1).\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// The second parameter ChannelHandle is used to delete sub channel,\n// which can be NULL if this isn't necessary.\nif (schan.AddChannel(sub_channel, NULL/*ChannelHandle*/) != 0) { \n    LOG(ERROR) << \"Fail to add sub_channel\";\n    return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Channel Initialization Methods for Server Connection - C++\nDESCRIPTION: This C++ code lists overloaded Init() function signatures for brpc::Channel, showing several ways to connect to a single server by address or hostname with optional configuration options. The dependencies include brpc headers and a properly constructed ChannelOptions pointer. Parameters allow specification of endpoints as objects or strings, and the function returns 0 on success (channel usable) or nonzero on error.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n// Take default values when options is NULL.\\nint Init(EndPoint server_addr_and_port, const ChannelOptions* options);\\nint Init(const char* server_addr_and_port, const ChannelOptions* options);\\nint Init(const char* server_addr, int port, const ChannelOptions* options);\n```\n\n----------------------------------------\n\nTITLE: Measuring Function Latency with bvar in C++\nDESCRIPTION: C++ code snippet demonstrating how to use bvar's LatencyRecorder to monitor and record the execution time of a function. This helps identify slow functions that might be causing performance bottlenecks.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server_debugging.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n#include <butil/time.h>\n#include <bvar/bvar.h>\n \nbvar::LatencyRecorder g_foobar_latency(\"foobar\");\n \n...\nvoid search() {\n    ...\n    butil::Timer tm;\n    tm.start();\n    foobar();\n    tm.stop();\n    g_foobar_latency << tm.u_elapsed();\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Client-Side Throttling for Cluster Recovery in brpc\nDESCRIPTION: Example of initializing a channel with throttling parameters for cluster recovery. The parameters min_working_instances and hold_seconds control the recovery behavior, where min_working_instances specifies the minimum servers needed and hold_seconds sets the stabilization period.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nchannel.Init(\"http://...\", \"random:min_working_instances=6 hold_seconds=10\", &options);\n```\n\n----------------------------------------\n\nTITLE: Configuring ChannelOptions and Initializing brpc::Channel in C++\nDESCRIPTION: This snippet demonstrates how to declare a ChannelOptions object, set custom configuration values, and pass it to the brpc::Channel's Init method. The options object holds user-defined settings and is not modified by the Channel; it can be stack-allocated. Dependencies include brpc and its headers. Expected input includes a configured options object and channel; output is a ready-to-use initialized channel instance.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nbrpc::ChannelOptions options;  // \\u5305\\u542b\\u4e86\\u9ed8\\u8ba4\\u503c\noptions.xxx = yyy;\n...\nchannel.Init(..., &options);\n```\n\n----------------------------------------\n\nTITLE: Waiting for Multiple Asynchronous brpc RPCs in C++\nDESCRIPTION: Demonstrates launching two asynchronous brpc RPCs and waiting for their completion using the Join method. Assumes that controller1 and controller2 are valid brpc::Controller pointers, and stub.method1/method2 issue asynchronous requests with done callbacks. Requires brpc installed and set up, and the call_id must be captured from each Controller before starting the RPC. Join is called with the saved call_ids to block on completion and propagate results. Usage is thread-safe for multiple waiters, but ensuring the Controller is not destroyed before Join completes is critical.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_12\n\nLANGUAGE: c++\nCODE:\n```\nconst brpc::CallId cid1 = controller1->call_id();\nconst brpc::CallId cid2 = controller2->call_id();\n...\nstub.method1(controller1, request1, response1, done1);\nstub.method2(controller2, request2, response2, done2);\n...\nbrpc::Join(cid1);\nbrpc::Join(cid2);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Naming Service Filter Interface - BRPC - C++\nDESCRIPTION: This snippet demonstrates the interface for implementing server-side filtering in brpc's naming service system. It shows how to define a custom filter by subclassing the NamingServiceFilter interface and how to utilize the ServerNode structure, which contains server addressing and tags. The filter's Accept method determines whether a discovered server should be considered a candidate during load balancing, enabling tag-based or other logic. No external dependencies except brpc headers are required.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n// naming_service_filter.h\nclass NamingServiceFilter {\npublic:\n    // Return true to take this `server' as a candidate to issue RPC\n    // Return false to filter it out\n    virtual bool Accept(const ServerNode& server) const = 0;\n};\n\n// naming_service.h\nstruct ServerNode {\n    butil::EndPoint addr;\n    std::string tag;\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Nshead+Mcpack Protocol for brpc Server - C++\nDESCRIPTION: This snippet demonstrates enabling the 'nshead_mcpack' protocol for brpc servers by including its header and assigning a new brpc::policy::NsheadMcpackAdaptor to the ServerOptions' nshead_service. This protocol allows the service to handle messages composed of nshead+mcpack, providing compatibility with both mcpack and protobuf via mcpack2pb. Requires brpc and mcpack protocol support.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/policy/nshead_mcpack_protocol.h>\n...\nServerOptions options;\n...\noptions.nshead_service = new brpc::policy::NsheadMcpackAdaptor;\n```\n\n----------------------------------------\n\nTITLE: Comparing Error Reporting Methods in C++: strerror vs. berror\nDESCRIPTION: This C++ snippet contrasts standard error reporting with the custom berror facility in brpc. It sets a custom error code and prints its description using printf and various format specifiers, illustrating that only berror() yields the custom message for registered errors. Dependencies include brpc and a proper error registration; input is typically the numeric error code.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/error_code.md#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nerrno = ESTOP;\\nprintf(\\\"Describe errno: %m\\\\n\\\");                              // [Wrong] Describe errno: Unknown error -114\\nprintf(\\\"Describe errno: %s\\\\n\\\", strerror_r(errno, NULL, 0));  // [Wrong] Describe errno: Unknown error -114\\nprintf(\\\"Describe errno: %s\\\\n\\\", berror());                    // [Correct] Describe errno: the thread is stopping\\nprintf(\\\"Describe errno: %s\\\\n\\\", berror(errno));               // [Correct] Describe errno: the thread is stopping\\n\n```\n\n----------------------------------------\n\nTITLE: Initializing a Redis Channel with brpc in C++\nDESCRIPTION: Demonstrates how to create and configure a brpc::Channel instance for communicating with a Redis server using the Redis protocol. The snippet shows setting the channel protocol, initializing with the Redis server's address (typically port 6379), and error handling for connection failures. Requires brpc library headers and a running Redis instance; outputs are managed via standard error logging.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/redis.h>\n#include <brpc/channel.h>\n  \nbrpc::ChannelOptions options;\noptions.protocol = brpc::PROTOCOL_REDIS;\nbrpc::Channel redis_channel;\nif (redis_channel.Init(\"0.0.0.0:6379\", &options) != 0) {  // 6379 is the default port for redis-server\n   LOG(ERROR) << \"Fail to init channel to redis-server\";\n   return -1;\n}\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing Protocol Verification/Authentication for brpc (C++)\nDESCRIPTION: Specifies the function signature for verifying authentication or handshakes for a connection when receiving the first message. Use this for protocols requiring server-side authentication. The function should return true on successful verification; otherwise, it can close the connection, and may be left NULL for non-secure protocols.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\ntypedef bool (*Verify)(const InputMessageBase* msg);\n```\n\n----------------------------------------\n\nTITLE: Accepting a Stream in Apache brpc (C++)\nDESCRIPTION: Functions for accepting one or multiple streams on the server side. These are called in response to a client's stream creation request.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_rpc.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nint StreamAccept(StreamId* response_stream, Controller &cntl, const StreamOptions* options);\n\nint StreamAccept(StreamIds& response_stream, Controller& cntl, const StreamOptions* options);\n```\n\n----------------------------------------\n\nTITLE: Adding a Service to brpc::Server - C++\nDESCRIPTION: Illustrates creating a brpc::Server instance, instantiating the service implementation (MyEchoService), and registering the service using AddService with SERVER_DOESNT_OWN_SERVICE for manual ownership. Highlights that services can't be added after server start and describes how brpc::Server manages service lifecycle.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nbrpc::Server server;\nMyEchoService my_echo_service;\nif (server.AddService(&my_echo_service, brpc::SERVER_DOESNT_OWN_SERVICE) != 0) {\n    LOG(FATAL) << \"Fail to add my_echo_service\";\n    return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Service with Custom Restful URL Mappings - brpc C++\nDESCRIPTION: This snippet demonstrates using brpc's AddService API to register a service implementation ('queue_svc') with custom restful URL mappings. By providing a string parameter with mapping rules, developers can make methods available at URLs different from the default convention. The mappings support wildcards and suffixes, matching and redirecting requests to specified methods. Requires an initialized brpc server, a service implementation pointer, and correct mapping string syntax. Inputs: service pointer, ownership flag, mappings string. Output: registration result. Limitations: at most one wildcard per path; mapped methods no longer accessible via default URL.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nif (server.AddService(&queue_svc,\\n                      brpc::SERVER_DOESNT_OWN_SERVICE,\\n                      \"/v1/queue/start   => start,\"\\n                      \"/v1/queue/stop    => stop,\"\\n                      \"/v1/queue/stats/* => get_stats\") != 0) {\\n    LOG(ERROR) << \"Fail to add queue_svc\";\\n    return -1;\\n}\\n \\nif (server.AddService(&queue_svc,\\n                      brpc::SERVER_DOESNT_OWN_SERVICE,\\n                      \"/v1/*/start   => start,\"\\n                      \"/v1/*/stop    => stop,\"\\n                      \"*.data        => download_data\") != 0) {\\n    LOG(ERROR) << \"Fail to add queue_svc\";\\n    return -1;\\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping and Joining a brpc Server - C++\nDESCRIPTION: This C++ snippet demonstrates how to gracefully stop a running brpc server using the server.Stop() and server.Join() methods. The closewait_ms parameter is retained for compatibility but is not functional. These methods ensure that the server waits for all outstanding requests to finish before fully shutting down, and are intended to be used together to avoid extended cumulative waiting times when stopping multiple servers. No external dependencies outside the brpc library are required.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nserver.Stop(closewait_ms); // closewait_ms is useless actually, not deleted due to compatibility\nserver.Join();\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Modifying HTTP Headers in brpc - C++\nDESCRIPTION: Demonstrates how to retrieve, set, and append HTTP headers using the brpc Controller. The code shows case-insensitive retrieval for headers (e.g., 'User-Agent'), adding or overwriting headers, and appending multiple values to a single header, separated by commas. Requires brpc installed and a valid Controller pointer ('cntl'). Outputs header values to logs and modifies HTTP response headers as needed.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// Get value for header \"User-Agent\" (case insensitive)\nconst std::string* user_agent_str = cntl->http_request().GetHeader(\"User-Agent\");\nif (user_agent_str != NULL) {  // has the header\n    LOG(TRACE) << \"User-Agent is \" << *user_agent_str;\n}\n...\n \n// Add a header \"Accept-encoding: gzip\" (case insensitive)\ncntl->http_response().SetHeader(\"Accept-encoding\", \"gzip\");\n// Overwrite the previous header \"Accept-encoding: deflate\"\ncntl->http_response().SetHeader(\"Accept-encoding\", \"deflate\");\n// Append value to the previous header so that it becomes\n// \"Accept-encoding: deflate,gzip\" (values separated by comma)\ncntl->http_response().AppendHeader(\"Accept-encoding\", \"gzip\");\n```\n\n----------------------------------------\n\nTITLE: Asynchronous RPC Call with Custom Closure in C++\nDESCRIPTION: Shows how to create a custom Closure for asynchronous RPC calls to reduce memory allocations, including error handling and memory management.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\nclass OnRPCDone: public google::protobuf::Closure {\npublic:\n    void Run() {\n        std::unique_ptr<OnRPCDone> self_guard(this);\n        \n        if (cntl->Failed()) {\n            // RPC failed. response values are undefined, do not use.\n        } else {\n            // RPC succeeded, response contains the data. Start post-RPC processing.\n        }\n    }\n\n    MyResponse response;\n    brpc::Controller cntl;\n}\n\nOnRPCDone* done = new OnRPCDone;\nMyService_Stub stub(&channel);\n\nMyRequest request;\nrequest.set_foo(...);\ndone->cntl.set_timeout_ms(...);\nstub.some_method(&done->cntl, &request, &done->response, done);\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Status Codes in brpc - C++\nDESCRIPTION: Illustrates retrieving and setting HTTP status codes in brpc HTTP responses, including using symbolic constants (e.g., 'brpc::HTTP_STATUS_NOT_FOUND'). Also shows how to set status messages. Useful for error handling, diagnostics, and HTTP redirects. Dependencies: brpc, status code definitions in 'http_status_code.h'.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\n// Get Status Code\nif (cntl->http_response().status_code() == brpc::HTTP_STATUS_NOT_FOUND) {\n    LOG(FATAL) << \"FAILED: \" << controller.http_response().reason_phrase();\n}\n...\n// Set Status code\ncntl->http_response().set_status_code(brpc::HTTP_STATUS_INTERNAL_SERVER_ERROR);\ncntl->http_response().set_status_code(brpc::HTTP_STATUS_INTERNAL_SERVER_ERROR, \"My explanation of the error...\");\n```\n\n----------------------------------------\n\nTITLE: Asynchronous RPC Call with NewCallback in C++\nDESCRIPTION: Demonstrates how to make an asynchronous RPC call using NewCallback, including memory management and error handling in the callback.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\nstatic void OnRPCDone(MyResponse* response, brpc::Controller* cntl) {\n    std::unique_ptr<MyResponse> response_guard(response);\n    std::unique_ptr<brpc::Controller> cntl_guard(cntl);\n    if (cntl->Failed()) {\n        // RPC failed. response values are undefined, do not use.\n    } else {\n        // RPC succeeded, response contains the data. Start post-RPC processing.\n    }\n}\n\nMyResponse* response = new MyResponse;\nbrpc::Controller* cntl = new brpc::Controller;\nMyService_Stub stub(&channel);\n\nMyRequest request;\nrequest.set_foo(...);\ncntl->set_timeout_ms(...);\nstub.some_method(cntl, &request, response, brpc::NewCallback(OnRPCDone, response, cntl));\n```\n\n----------------------------------------\n\nTITLE: Programmatic Configuration of bvar_dump_include - brpc - C++\nDESCRIPTION: This snippet shows how to configure the bvar_dump_include flag at runtime, filtering which bvars are included in the dump. It uses gflags to ensure that changes are thread-safe and that necessary validators are triggered. Dependencies are gflags and brpc. The main input is the wildcard string for included variable names. Output is logging for success or failure of the configuration change.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\n#include <gflags/gflags.h>\n...\nif (google::SetCommandLineOption(\"bvar_dump_include\", \"*service*\").empty()) {\n    LOG(ERROR) << \"Fail to set bvar_dump_include\";\n    return -1;\n}\nLOG(INFO) << \"Successfully set bvar_dump_include to *service*\";\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Redirects with 302 Status Code in brpc - C++\nDESCRIPTION: Demonstrates how to implement an HTTP redirection by setting status code 302 (HTTP_STATUS_FOUND) and specifying a 'Location' header. This is the canonical method for guiding clients to a new resource using HTTP semantics in brpc. Dependencies: brpc, valid Controller, symbolic status codes.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\ncntl->http_response().set_status_code(brpc::HTTP_STATUS_FOUND);\ncntl->http_response().SetHeader(\"Location\", \"http://bj.bs.bae.baidu.com/family/image001(4979).jpg\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Server-Side SSL Options in C++\nDESCRIPTION: Defines the ServerSSLOptions structure for configuring SSL options on the server side, including default and additional certificates, and SNI strictness.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nstruct ServerSSLOptions {\n    CertInfo default_cert;\n    std::vector<CertInfo> certs;\n    bool strict_sni;\n    // ... Other options\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Multi-Dimensional Metric Variable with Name in bvar (C++)\nDESCRIPTION: This example shows how to globally define a multi-dimensional metric variable using the recommended constructor in bvar. It sets up a MultiDimension<Adder<int>> with a name and a list of labels. The variable is globally exposed and will be included in metric dumps if configured. Dependencies include bvar/bvar.h and bvar/multi_dimension.h.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Header in brpc Controller - C++\nDESCRIPTION: Sets an HTTP header 'Foo' with value 'value' in the http_request part of a brpc::Controller. No return value. Dependency: brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().SetHeader(\"Foo\", \"value\");\n```\n\n----------------------------------------\n\nTITLE: Querying Single-Dimensional Metric from Multi-Dimensional bvar Variable in C++\nDESCRIPTION: This code illustrates how to retrieve a pointer to a single-dimensional metric (Adder<int>) for a specific label combination from a multi-dimensional metric variable. It checks for pointer validity, updates the metric, and then returns its value. The function is safe only within the lifespan of the parent mbvar. Required headers are bvar/bvar.h and bvar/multi_dimension.h.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\n\nint get_request_count(const std::list<std::string>& request_label) {\n    // \\u83b7\\u53d6request_label\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6bvar\\u6307\\u9488\\uff0c\\u6bd4\\u5982\\uff1arequest_label = {\"tc\", \"get\", \"200\"}\n    bvar::Adder<int> *request_adder = g_request_count.get_stats(request_label);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!request_adder) {\n        return -1;\n    }\n\n    // request_adder\\u53ea\\u80fd\\u5728g_request_count\\u7684\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\n    *request_adder << 1;\n    return request_adder->get_value();\n}\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Asynchronous RPC Call with Custom Closure in brpc\nDESCRIPTION: Example of creating a custom closure class that inherits from google::protobuf::Closure for handling asynchronous RPC completion. This approach combines response and controller objects into a single allocation.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\nclass OnRPCDone: public google::protobuf::Closure {\npublic:\n    void Run() {\n        // unique_ptr helps us to delete response/cntl automatically. unique_ptr in gcc 3.4 is an emulated version.\n        std::unique_ptr<OnRPCDone> self_guard(this);\n\n        if (cntl->Failed()) {\n            // RPC failed. fields in response are undefined, don't use.\n        } else {\n            // RPC succeeded, response has what we want. Continue the post-processing.\n        }\n    }\n\n    MyResponse response;\n    brpc::Controller cntl;\n}\n\nOnRPCDone* done = new OnRPCDone;\nMyService_Stub stub(&channel);\n\nMyRequest request;  // you don't have to new request, even in an asynchronous call.\nrequest.set_foo(...);\ndone->cntl.set_timeout_ms(...);\nstub.some_method(&done->cntl, &request, &done->response, done);\n```\n\n----------------------------------------\n\nTITLE: Implementing Session Local Data in BRPC\nDESCRIPTION: Example showing how to implement and use session-local data storage in BRPC services, including factory creation and data access patterns.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_26\n\nLANGUAGE: c++\nCODE:\n```\nstruct MySessionLocalData {\n    MySessionLocalData() : x(123) {}\n    int x;\n};\n\nclass EchoServiceImpl : public example::EchoService {\npublic:\n    ...\n    void Echo(google::protobuf::RpcController* cntl_base,\n              const example::EchoRequest* request,\n              example::EchoResponse* response,\n              google::protobuf::Closure* done) {\n        ...\n        brpc::Controller* cntl = static_cast<brpc::Controller*>(cntl_base);\n\n        // Get the session-local data which is created by ServerOptions.session_local_data_factory\n        // and reused between different RPC.\n        MySessionLocalData* sd = static_cast<MySessionLocalData*>(cntl->session_local_data());\n        if (sd == NULL) {\n            cntl->SetFailed(\"Require ServerOptions.session_local_data_factory to be set with a correctly implemented instance\");\n            return;\n        }\n        ...\n```\n\n----------------------------------------\n\nTITLE: Counting Label and Stat Dimensions in bvar::MultiDimension (C++)\nDESCRIPTION: These snippets declare methods and demonstrate how to count the number of label dimensions and currently allocated single-dimensional stat variables in a MultiDimension metric. The examples show how to create the variable, retrieve a stat pointer for a label combination, and query the label and stats counts. Proper lifespan management is required for safe pointer usage. The input is a list of strings or no input, and the output is a size_t with the counts.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_12\n\nLANGUAGE: c++\nCODE:\n```\nclass MVariable {\npublic:\n    ...\n\n    // Get number of mvariable labels\n    size_t count_labels() const;\n};\n\ntemplate <typename T>\nclass MultiDimension : public MVariable {\npublic:\n    ...\n\n    // Get number of stats\n    size_t count_stats();\n};\n```\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\n\nsize_t count_labels() {\n    size_t mbvar_count_labels = g_request_count.count_labels();\n    CHECK_EQ(3, mbvar_count_labels);\n    return mbvar_count_labels;\n}\n} // namespace bar\n} // namespace foo\n```\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\n\nsize_t count_stats() {\n    // \\u83b7\\u53d6request1\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6mbvar\\u6307\\u9488\\uff0c\\u5047\\u8bberequest1_labels = {\"tc\", \"get\", \"200\"}\n    bvar::Adder<int> *request1_adder = g_request_count.get_stats(request1_labels);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!request1_adder) {\n        return -1;\n    }\n    // request1_adder\\u53ea\\u80fd\\u5728g_request_count\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\n    *request1_adder << 1;\n\n    // \\u83b7\\u53d6request2\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6mbvar\\u6307\\u9488\\uff0c\\u5047\\u8bberequest2_labels = {\"nj\", \"get\", \"200\"}\n    bvar::Adder<int> *request2_adder = g_request_count.get_stats(request2_labels);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!request2_adder) {\n        return -1;\n    }\n    // request2_adder\\u53ea\\u80fd\\u5728g_request_count\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\n    *request2_adder << 1;\n\n\n    size_t mbvar_count_stats = g_request_count.count_stats();\n    CHECK_EQ(2, mbvar_count_stats);\n    return mbvar_count_stats;\n}\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Implementing Flow Control in Apache brpc Streams (C++)\nDESCRIPTION: Functions for synchronous and asynchronous waiting until the pending buffer size is less than the maximum or an error occurs.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_rpc.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nint StreamWait(StreamId stream_id, const timespec* due_time);\n\nvoid StreamWait(StreamId stream_id, const timespec *due_time,\n                void (*on_writable)(StreamId stream_id, void* arg, int error_code),\n                void *arg);\n```\n\n----------------------------------------\n\nTITLE: Setting Query Parameter in URI in brpc Controller - C++\nDESCRIPTION: Sets a query parameter 'Foo' with value 'value' in the request URI using brpc::Controller. This is used to build or modify the request URL dynamically. Requires brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().uri().SetQuery(\"Foo\", \"value\");\n```\n\n----------------------------------------\n\nTITLE: Measuring Latency and QPS with bvar::LatencyRecorder - brpc - C++\nDESCRIPTION: bvar::LatencyRecorder defines a set of related metrics (latency, max latency, QPS, count) under a common prefix for tracking operation timing. Chronological data is pushed via <<, and statistics are aggregated for real-time visibility (configurable via the time window parameter or gflag). Dependencies: bvar; input: operation latency values; output: four variables per logical recorder for monitoring purposes.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nLatencyRecorder write_latency(\"table2_my_table_write\");  // produces 4 variables:\n                                                         //   table2_my_table_write_latency\n                                                         //   table2_my_table_write_max_latency\n                                                         //   table2_my_table_write_qps\n                                                         //   table2_my_table_write_count\n// In your write function\nwrite_latency << the_latency_of_write;\n```\n\n----------------------------------------\n\nTITLE: Accessing and Creating On-Demand bthread-local Storage (C++)\nDESCRIPTION: This snippet displays idiomatic access to bthread-local data in a thread. It checks if per-thread data is absent, creates it on demand, and stores it using bthread_setspecific for reuse. This removes redundant construction on subsequent calls within the same bthread. Proper memory management is required; a matching destructor must be registered with the key.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_33\n\nLANGUAGE: C++\nCODE:\n```\n// in some thread ...\nMyThreadLocalData* tls = static_cast<MyThreadLocalData*>(bthread_getspecific(tls_key));\nif (tls == NULL) {  // First call to bthread_getspecific (and before any bthread_setspecific) returns NULL\n    tls = new MyThreadLocalData;   // Create thread-local data on demand.\n    CHECK_EQ(0, bthread_setspecific(tls_key, tls));  // set the data so that next time bthread_getspecific in the thread returns the data.\n}\n\n```\n\n----------------------------------------\n\nTITLE: Making HTTP POST Request in brpc\nDESCRIPTION: Shows how to make an HTTP POST request by setting the HTTP method to POST and appending the request body to request_attachment(). This example demonstrates sending a JSON payload.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl;\ncntl.http_request().uri() = \"...\";  // 设置为待访问的URL\ncntl.http_request().set_method(brpc::HTTP_METHOD_POST);\ncntl.request_attachment().append(\"{\\\"message\\\":\\\"hello world!\\\"}\");\nchannel.CallMethod(NULL, &cntl, NULL, NULL, NULL/*done*/);\n```\n\n----------------------------------------\n\nTITLE: Creating and Reusing brpc::Controller Objects for RPCs in C++\nDESCRIPTION: Presents two patterns for using brpc::Controller: (snippet1) constructing a new Controller for every RPC inside a loop, and (snippet2) reusing a Controller by resetting it with Reset() each iteration. Both forms are safe; reusing a heap-allocated Controller can slightly improve performance by avoiding heap allocation/deallocation overhead. Only one RPC can use the Controller at a time.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_17\n\nLANGUAGE: c++\nCODE:\n```\n// snippet1\nfor (int i = 0; i < n; ++i) {\n    brpc::Controller controller;\n    ...\n    stub.CallSomething(..., &controller);\n}\n\n// snippet2\nbrpc::Controller controller;\nfor (int i = 0; i < n; ++i) {\n    controller.Reset();\n    ...\n    stub.CallSomething(..., &controller);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting HTTP Body from brpc Controller - C++\nDESCRIPTION: Accesses the HTTP request body as an IOBuf reference and converts it to string if needed. The first line returns a reference to the underlying IOBuf, which can be converted to std::string explicitly (copying the contents).\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_12\n\nLANGUAGE: c++\nCODE:\n```\nbutil::IOBuf& buf = cntl->request_attachment();\nstd::string str = cntl->request_attachment().to_string(); // trigger copy underlying\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Error Codes with BAIDU_REGISTER_ERRNO in C++\nDESCRIPTION: These lines show how to map custom error codes to human-readable messages using BAIDU_REGISTER_ERRNO in brpc. By registering the code and its description in the global scope, subsequent calls to berror will produce descriptive output. There are no external dependencies unless brpc is not included; error code and description strings are the main parameters.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/error_code.md#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nBAIDU_REGISTER_ERRNO(ESTOP, \\\"the thread is stopping\\\")\\nBAIDU_REGISTER_ERRNO(EMYERROR, \\\"my error\\\")\\n\n```\n\n----------------------------------------\n\nTITLE: Writing to a Stream in Apache brpc (C++)\nDESCRIPTION: Function for writing a message to a stream. It returns 0 on success or an errno on failure, such as EAGAIN for buffer overflow or EINVAL for invalid stream.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_rpc.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nint StreamWrite(StreamId stream_id, const butil::IOBuf &message);\n```\n\n----------------------------------------\n\nTITLE: Implementing Semi-synchronous brpc RPC Calls with Join in C++\nDESCRIPTION: Shows how to implement a semi-synchronous pattern by making multiple asynchronous brpc calls, then blocking for their completion using Join. The snippet places Controller and response objects on the stack, which is safe only when the done callback (here brpc::DoNothing) does not delete them. All resources are kept valid while blocking, avoiding lifetime issues. Requires brpc and correct understanding of the done callback's behavior.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_14\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl1;\nbrpc::Controller cntl2;\nMyResponse response1;\nMyResponse response2;\n...\nstub1.method1(&cntl1, &request1, &response1, brpc::DoNothing());\nstub2.method2(&cntl2, &request2, &response2, brpc::DoNothing());\n...\nbrpc::Join(cntl1.call_id());\nbrpc::Join(cntl2.call_id());\n```\n\n----------------------------------------\n\nTITLE: Getting and Setting HTTP Status Code in brpc - C++\nDESCRIPTION: Demonstrates how to read and set HTTP response status codes using the brpc Controller. Uses constants from brpc::http_status_code.h and provides for custom reason phrases. Shows usage for both signaling errors and for HTTP redirection via status code and Location header. Depends on brpc and logging.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\n// Get Status Code\\nif (cntl->http_response().status_code() == brpc::HTTP_STATUS_NOT_FOUND) {\\n    LOG(FATAL) << \"FAILED: \" << controller.http_response().reason_phrase();\\n}\\n...\\n// Set Status code\\ncntl->http_response().set_status_code(brpc::HTTP_STATUS_INTERNAL_SERVER_ERROR);\\ncntl->http_response().set_status_code(brpc::HTTP_STATUS_INTERNAL_SERVER_ERROR, \"My explanation of the error...\");\n```\n\nLANGUAGE: C++\nCODE:\n```\ncntl->http_response().set_status_code(brpc::HTTP_STATUS_FOUND);\\ncntl->http_response().SetHeader(\"Location\", \"http://bj.bs.bae.baidu.com/family/image001(4979).jpg\");\n```\n\n----------------------------------------\n\nTITLE: Declaring Resource-Oriented Service with Default Method - Protobuf\nDESCRIPTION: This proto example defines 'FileService' with a default_method to support resource-oriented HTTP/2 access patterns, such as serving files mapped to URLs. It uses empty messages to signal that the Controller object in brpc will contain all relevant data (e.g., headers, path). The option enables code generation for C++ services using brpc. Requires the protobuf compiler and brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\noption cc_generic_services = true;\\n\\nmessage HttpRequest { };\\nmessage HttpResponse { };\\n\\nservice FileService {\\n      rpc default_method(HttpRequest) returns (HttpResponse);\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Progressive HTTP Response Attachments in brpc - C++\nDESCRIPTION: Demonstrates how to create a progressive body for HTTP responses using 'CreateProgressiveAttachment'. Allows sending large/infinite responses in chunks. The returned 'ProgressiveAttachment' must be managed by 'butil::intrusive_ptr'. This snippet is the preparatory step for progressive or real-time streaming (e.g., SSE). Dependencies: brpc, brpc/progressive_attachment.h, valid Controller object.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/progressive_attachment.h>\n...\nbutil::intrusive_ptr<brpc::ProgressiveAttachment> pa = cntl->CreateProgressiveAttachment();\n```\n\n----------------------------------------\n\nTITLE: Implementing Protocol Parse Callback for brpc (C++)\nDESCRIPTION: Defines the prototype for the parse callback function required by all protocols in brpc. This function splits raw network input into protocol messages or error codes and must work symmetrically for both client and server sides. The parameters let the implementation inspect input buffers, connection state, and protocol context. Results signal message boundaries, error handling, or deferred processing pending more data.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\ntypedef ParseResult (*Parse)(butil::IOBuf* source, Socket *socket, bool read_eof, const void *arg);\n```\n\n----------------------------------------\n\nTITLE: Performing HTTP POST Request With Body - brpc C++\nDESCRIPTION: Demonstrates sending an HTTP POST by changing the HTTP method and appending a JSON body to the request attachment. Requires an initialized brpc::Channel and brpc Controller. The request body is appended as a string, and CallMethod is used to submit the request. Designed for small payloads sent as JSON or plain text.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl;\ncntl.http_request().uri() = \"...\";  // Request URL\ncntl.http_request().set_method(brpc::HTTP_METHOD_POST);\ncntl.request_attachment().append(\"{\\\"message\\\":\\\"hello world!\\\"}\");\nchannel.CallMethod(NULL, &cntl, NULL, NULL, NULL/*done*/);\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Error Codes with BAIDU_REGISTER_ERRNO\nDESCRIPTION: Demonstrates how to register custom error codes with descriptions using BAIDU_REGISTER_ERRNO macro in the global scope.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/error_code.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nBAIDU_REGISTER_ERRNO(ESTOP, \"the thread is stopping\")\nBAIDU_REGISTER_ERRNO(EMYERROR, \"my error\")\n```\n\n----------------------------------------\n\nTITLE: Executing Atomic Operations with std::atomic in C++\nDESCRIPTION: This snippet demonstrates the suite of primary atomic operations provided for std::atomic<int> in C++11, detailing their purpose, function signatures, and expected behaviors. These APIs require #include <atomic> and assume the variable x is of type std::atomic<int>. Inputs and outputs, such as how compare_exchange modifies its first argument, are noted along with limitations (such as performance degradation under contention and the chance of spurious wakeups for compare_exchange_weak). The snippet is shown in a descriptive tabular format but covers all standard usages.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/atomic_instructions.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n| Atomic Instructions(type of x is std::atomic<int>) | Descriptions                             |\\n| ---------------------------------------- | ---------------------------------------- |\\n| x.load()                                 | return the value of x.                   |\\n| x.store(n)                               | store n to x and return nothing.         |\\n| x.exchange(n)                            | set x to n and return the value just before the modification |\\n| x.compare_exchange_strong(expected_ref, desired) | If x is equal to expected_ref, set x to desired and return true. Otherwise write current x to expected_ref and return false. |\\n| x.compare_exchange_weak(expected_ref, desired) | may have [spurious wakeup](http://en.wikipedia.org/wiki/Spurious_wakeup) comparing to compare_exchange_strong |\\n| x.fetch_add(n), x.fetch_sub(n)           | do x += n, x-= n atomically. Return the value just before the modification. |\n```\n\n----------------------------------------\n\nTITLE: Implementing NamingServiceFilter for Custom ServerNode Selection in brpc (C++)\nDESCRIPTION: This snippet provides the interface definition for a NamingServiceFilter and the ServerNode structure in brpc, enabling users to filter server nodes based on customized logic during naming service resolution. Implementers supply an Accept method that returns a boolean indicating candidate eligibility. Dependencies include brpc and butil for types. Inputs are instances of ServerNode; outputs are boolean filter results.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// naming_service_filter.h\nclass NamingServiceFilter {\npublic:\n    // Return true to take this `server' as a candidate to issue RPC\n    // Return false to filter it out\n    virtual bool Accept(const ServerNode& server) const = 0;\n};\n \n// naming_service.h\nstruct ServerNode {\n    butil::EndPoint addr;\n    std::string tag;\n};\n```\n\n----------------------------------------\n\nTITLE: Customizing Method Name Handling in brpc (C++)\nDESCRIPTION: Provides the prototype for an optional callback to derive or alias the method name (RPC endpoint) for a given protocol and context. Allows users to override default method deduction by customizing behavior based on descriptors or runtime metadata.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\ntypedef const std::string& (*GetMethodName)(const google::protobuf::MethodDescriptor* method,\n                                            const Controller*);\n```\n\n----------------------------------------\n\nTITLE: Registering HTTP Protocol in Apache brpc (C++)\nDESCRIPTION: This snippet demonstrates how to create and register an HTTP protocol in Apache brpc. It defines the protocol structure with various function pointers and properties, then calls RegisterProtocol to add it to the global protocol registry.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\nProtocol http_protocol = { ParseHttpMessage,\n                           SerializeHttpRequest, PackHttpRequest,\n                           ProcessHttpRequest, ProcessHttpResponse,\n                           VerifyHttpRequest, ParseHttpServerAddress,\n                           GetHttpMethodName,\n                           CONNECTION_TYPE_POOLED_AND_SHORT,\n                           \"http\" };\nif (RegisterProtocol(PROTOCOL_HTTP, http_protocol) != 0) {\n    exit(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring HTTP/2 Service with Empty Request/Response - Protobuf\nDESCRIPTION: This snippet illustrates a proto file declaration for an HTTP/2 service in brpc. It defines empty message types for both requests and responses and outlines a service with the 'Echo' method. The 'option cc_generic_services = true;' line signals code generation for generic C++ services. Intended as the interface contract for the brpc-generated service classes, this proto enables empty body handling via the Controller object in the implementation. No external dependencies are required beyond protoc and brpc's proto generator.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\noption cc_generic_services = true;\\n \\nmessage HttpRequest { };\\nmessage HttpResponse { };\\n \\nservice HttpService {\\n      rpc Echo(HttpRequest) returns (HttpResponse);\\n};\n```\n\n----------------------------------------\n\nTITLE: Managing Sockets with SocketId and SocketUniquePtr - brpc - C++\nDESCRIPTION: This pseudo-code describes conceptual usage patterns of issuing, referencing, and failing sockets in brpc C++. Sockets are created and referenced via 64-bit SocketId for thread safety, with SocketUniquePtr handling strong ownership and automatic resource release. The key methods are Create (allocates a Socket and returns its id), Address (retrieves a SocketUniquePtr from a SocketId in a wait-free manner), and SetFailed (marks a socket as failed, after which Address returns empty until health checking resumes it). Inputs include the need to act on sockets by id; outputs are managed pointers or void, depending on the method. Usage is designed to avoid ABA and race conditions common in fd management, and epoll integration is enabled by the SocketId type. Requires brpc SDK.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/io.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n// Conceptual usage - not actual code, for illustration only\n\n// 1. Create a Socket and get its ID\nSocketId id = Socket::Create(...); // Implementation-specific params\n\n// 2. Access a Socket instance safely by its ID\nSocketUniquePtr ptr;\nif (Socket::Address(id, &ptr)) {\n    // Use ptr as a valid strong reference; ptr is auto-released\n}\n\n// 3. Mark a Socket as failed, triggering recycling/failing logic\nSocket::SetFailed(id);\n```\n\n----------------------------------------\n\nTITLE: Using bvar Variables in C++\nDESCRIPTION: Shows how to use previously defined bvar variables to record metrics like error counts, latency, and task counts in a C++ application.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n// run into read errors\nfoo::bar::g_read_error << 1;\n\n// record down the latenct, which is 23ms\nfoo::bar::g_write_latency << 23;\n\n// one task has been pushed\nfoo::bar::g_task_pushed << 1;\n```\n\n----------------------------------------\n\nTITLE: Managing SSL Certificates Dynamically in C++\nDESCRIPTION: Demonstrates methods for adding, removing, and resetting SSL certificates dynamically during server runtime.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\nint AddCertificate(const CertInfo& cert);\nint RemoveCertificate(const CertInfo& cert);\nint ResetCertificates(const std::vector<CertInfo>& certs);\n```\n\n----------------------------------------\n\nTITLE: Configuring Latency Percentiles in BRPC\nDESCRIPTION: Examples of correct settings for customizing latency percentile values through gflags configuration. Shows how to modify the default percentiles (80, 90, 99) using bvar_latency flags.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n-bvar_latency_p3=97   # p3 is changed from default 99 to 97\n-bvar_latency_p1=60 -bvar_latency_p2=80 -bvar_latency_p3=95\n```\n\n----------------------------------------\n\nTITLE: Adding a Sub Channel to ParallelChannel in brpc\nDESCRIPTION: API for adding a sub channel to a ParallelChannel with options for channel ownership and custom request/response handling.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nint AddChannel(brpc::ChannelBase* sub_channel,\n               ChannelOwnership ownership,\n               CallMapper* call_mapper,\n               ResponseMerger* response_merger);\n```\n\n----------------------------------------\n\nTITLE: Posting Large or Complex HTTP Body Using IOBufBuilder - brpc C++\nDESCRIPTION: Illustrates constructing complex or large request bodies using butil::IOBufBuilder for efficiency, and attaching it to a brpc HTTP POST request. This method should be used when the request body requires combining multiple objects and strings efficiently. Prerequisite: butil and brpc are required. The request method is set to POST, and the content is constructed then moved to the request attachment.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl;\ncntl.http_request().uri() = \"...\";  // Request URL\ncntl.http_request().set_method(brpc::HTTP_METHOD_POST);\nbutil::IOBufBuilder os;\nos << \"A lot of printing\" << printable_objects << ...;\nos.move_to(cntl.request_attachment());\nchannel.CallMethod(NULL, &cntl, NULL, NULL, NULL/*done*/);\n```\n\n----------------------------------------\n\nTITLE: Defining and Configuring a Custom NamingServiceFilter with brpc::ChannelOptions in C++\nDESCRIPTION: This code shows how to implement a custom NamingServiceFilter in brpc, filtering server nodes by tag, and how to configure a ChannelOptions structure to use the filter. The example sets up the filter to accept only nodes with tag 'main' and attaches it to the options structure for later channel initialization. Requires brpc::ChannelOptions and appropriate inheritance from brpc::NamingServiceFilter.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nclass MyNamingServiceFilter : public brpc::NamingServiceFilter {\npublic:\n    bool Accept(const brpc::ServerNode& server) const {\n        return server.tag == \"main\";\n    }\n};\n \nint main() {\n    ...\n    MyNamingServiceFilter my_filter;\n    ...\n    brpc::ChannelOptions options;\n    options.ns_filter = &my_filter;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-method HTTP Service for Custom RESTful Mapping - Protocol Buffers - protobuf\nDESCRIPTION: Specifies a QueueService in protobuf with multiple methods, used to demonstrate custom URL routing via RESTful mappings in brpc. Each method takes empty HttpRequest/HttpResponse types. This structure allows URL customization when registering the service with the brpc server. Requires generic service option enabled.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_4\n\nLANGUAGE: protobuf\nCODE:\n```\nservice QueueService {\\n    rpc start(HttpRequest) returns (HttpResponse);\\n    rpc stop(HttpRequest) returns (HttpResponse);\\n    rpc get_stats(HttpRequest) returns (HttpResponse);\\n    rpc download_data(HttpRequest) returns (HttpResponse);\\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Public Pbrpc Protocol for brpc Server - C++\nDESCRIPTION: This C++ snippet enables the 'public_pbrpc' protocol in a brpc server by including the relevant protocol header and assigning a brpc::policy::PublicPbrpcServiceAdaptor to ServerOptions' nshead_service. This lets the server accept connections over 'public_pbrpc', which is not enabled by default. Dependencies include brpc headers and the protocol module.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/policy/public_pbrpc_protocol.h>\n...\nServerOptions options;\n...\noptions.nshead_service = new brpc::policy::PublicPbrpcServiceAdaptor;\n```\n\n----------------------------------------\n\nTITLE: Redis Performance Benchmarking with Single Thread in brpc\nDESCRIPTION: Performance benchmark of Redis server using a single bthread synchronously. Shows QPS and latency metrics for Redis operations.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ ./client -use_bthread -thread_num 1\nTRACE: 02-13 19:42:04:   * 0 client.cpp:180] Accessing redis server at qps=18668 latency=50\nTRACE: 02-13 19:42:05:   * 0 client.cpp:180] Accessing redis server at qps=17043 latency=52\nTRACE: 02-13 19:42:06:   * 0 client.cpp:180] Accessing redis server at qps=16520 latency=54\n```\n\n----------------------------------------\n\nTITLE: Closing a Stream in Apache brpc (C++)\nDESCRIPTION: Function for closing a stream. After calling this, all subsequent writes will fail, waits will wake up immediately, and both sides' on_closed callbacks will be notified.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_rpc.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nint StreamClose(StreamId stream_id);\n```\n\n----------------------------------------\n\nTITLE: CallMapper Interface for ParallelChannel in brpc\nDESCRIPTION: Abstract class definition for CallMapper which converts RPCs to ParallelChannel into RPCs to sub channels, allowing request customization for each sub channel.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nclass CallMapper {\npublic:\n    virtual ~CallMapper();\n \n    virtual SubCall Map(int channel_index/*starting from 0*/,\n                        int channel_count,\n                        const google::protobuf::MethodDescriptor* method,\n                        const google::protobuf::Message* request,\n                        google::protobuf::Message* response) = 0;\n};\n```\n\n----------------------------------------\n\nTITLE: Exposing MultiDimension mbvar Variables Globally Using bvar in C++\nDESCRIPTION: This snippet illustrates creating and registering (\"exposing\") a MultiDimension mbvar variable so it can be tracked globally within the brpc metrics framework. The expose() and expose_as() functions make the variable accessible through monitoring interfaces and background dumping threads. Dependencies include bvar and multi_dimension headers. Usage of adder pointers requires adhering to the MultiDimension object's lifespan. Example demonstrates value accumulation and proper pointer checking for safety.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <bvar/bvar.h>\\n#include <bvar/multi_dimension.h>\\n\\nnamespace foo {\\nnamespace bar {\\n// \\u5b9a\\u4e49\\u4e00\\u4e2a\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\\n\\n// \\u6362\\u4e00\\u4e2a\\u540d\\5b57\\ng_request_count->expose(\"request_count_another\");\\n\\nint process_request(const std::list<std::string>& request_label) {\\n    // \\u83b7\\u53d6request_label\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6bvar\\u6307\\u9488\\uff0c\\u6bd4\\u5982\\uff1arequest_label = {\"tc\", \"get\", \"200\"}\\n    bvar::Adder<int>* adder = g_request_count.get_stats(labels_value);\\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\\n    if (!adder) {\\n        return -1;\\n    }\\n\\n    //adder\\u53ea\\u80fd\\u5728g_request_count\\u7684\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\\n    *adder << 10 << 20 << 30; // adder add up to 60\\n}\\n\\n} // namespace bar\\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Defining FileService Resource-style HTTP Service - Protocol Buffers - protobuf\nDESCRIPTION: Defines a resource-oriented HTTP/h2 service in a .proto file. The FileService has a single method, default_method, and uses empty request/response structures. This enables the mapping of dynamic paths to a service handler, e.g., /FileService/filename.txt. As with other brpc services, all API methods must be declared in proto for consistent service exposure.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\noption cc_generic_services = true;\\n\\nmessage HttpRequest { };\\nmessage HttpResponse { };\\n\\nservice FileService {\\n      rpc default_method(HttpRequest) returns (HttpResponse);\\n}\n```\n\n----------------------------------------\n\nTITLE: Redis Performance Benchmarking with Batch Commands (200 Threads)\nDESCRIPTION: Performance benchmark using 200 bthreads with batch mode (10 commands per request). Shows QPS, latency, and CPU usage of Redis server reaching 99.9% limit.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ ./client -use_bthread -thread_num 200 -batch 10\nTRACE: 02-13 19:49:09:   * 0 client.cpp:180] Accessing redis server at qps=29053 latency=6875\nTRACE: 02-13 19:49:10:   * 0 client.cpp:180] Accessing redis server at qps=29163 latency=6855\nTRACE: 02-13 19:49:11:   * 0 client.cpp:180] Accessing redis server at qps=29271 latency=6838\n \n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND \n16878 gejun     20   0 48136 2508 1004 R 99.9  0.0  13:36.59 redis-server   // thread_num=200\n```\n\n----------------------------------------\n\nTITLE: Creating a Stream in Apache brpc (C++)\nDESCRIPTION: Functions for creating one or multiple streams on the client side. These streams are established through an RPC to the specified service.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_rpc.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nint StreamCreate(StreamId* request_stream, Controller &cntl, const StreamOptions* options);\n\nint StreamCreate(StreamIds& request_streams, int request_stream_size, Controller& cntl,\n                 const StreamOptions* options);\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Method in brpc Controller - C++\nDESCRIPTION: Sets the HTTP method (e.g., POST) in a brpc::Controller for outgoing requests. This allows for methods other than GET. Dependency: brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().set_method(brpc::HTTP_METHOD_POST);\n```\n\n----------------------------------------\n\nTITLE: Logging Client Address via brpc Controller - C++\nDESCRIPTION: Shows how to retrieve and print the remote client's network address for an incoming request using brpc Controller's remote_side() method. Demonstrates both glog (LOG(INFO)) and standard C printf, using butil::endpoint2str to convert the address for human readability. These patterns are important for diagnostics and auditing in distributed RPC services.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nLOG(INFO) << \"remote_side=\" << cntl->remote_side();\nprintf(\"remote_side=%s\\n\", butil::endpoint2str(cntl->remote_side()).c_str());\n```\n\n----------------------------------------\n\nTITLE: Initializing bvar LatencyRecorder in Client Code - C++\nDESCRIPTION: Shows how to instrument C++ application logic with a bvar::LatencyRecorder, which exposes latency metrics under a specified name accessible via the /vars HTTP endpoint. This snippet requires the bvar library and proper linking with brpc. The LatencyRecorder is declared as a global/static variable, is fed latency values within a function, and automatically records and exposes statistical metrics like percentiles and CDFs. Input is a numeric latency measurement, and output is its aggregation in the bvar statistics that can be queried remotely.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/vars.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n```c++\\n#include <bvar/bvar.h>\\n\\n...\\nbvar::LatencyRecorder g_latency_recorder(\\\"client\\\");  // expose this recorder\\n... \\nvoid foo() {\\n    ...\\n    g_latency_recorder << my_latency;\\n    ...\\n}\\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Thrift Service Handler with BRPC - C++\nDESCRIPTION: This code defines a service class inheriting from brpc::ThriftService to handle incoming Thrift requests. The ProcessThriftFramedRequest method dispatches calls based on the Thrift method name and can call native handlers or set errors for unknown methods. The Echo method demonstrates request handling and asynchronous completion with ClosureGuard. Relies on the example::EchoRequest/Response classes generated by Thrift and requires inclusion of BRPC and Thrift libraries. Processes framed Thrift RPC requests to generate responses.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/thrift.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nclass EchoServiceImpl : public brpc::ThriftService {\\npublic:\\n    void ProcessThriftFramedRequest(brpc::Controller* cntl,\\n                                    brpc::ThriftFramedMessage* req,\\n                                    brpc::ThriftFramedMessage* res,\\n                                    google::protobuf::Closure* done) override {\\n        // Dispatch calls to different methods\\n        if (cntl->thrift_method_name() == \"Echo\") {\\n            return Echo(cntl, req->Cast<example::EchoRequest>(),\\n                        res->Cast<example::EchoResponse>(), done);\\n        } else {\\n            cntl->SetFailed(brpc::ENOMETHOD, \"Fail to find method=%s\",\\n                            cntl->thrift_method_name().c_str());\\n            done->Run();\\n        }\\n    }\\n\\n    void Echo(brpc::Controller* cntl,\\n              const example::EchoRequest* req,\\n              example::EchoResponse* res,\\n              google::protobuf::Closure* done) {\\n        // This object helps you to call done->Run() in RAII style. If you need\\n        // to process the request asynchronously, pass done_guard.release().\\n        brpc::ClosureGuard done_guard(done);\\n\\n        res->data = req->data + \" (processed)\";\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Server List Configuration for Partitioning (example, generic text config)\nDESCRIPTION: This text block provides sample content for the server_list file used by brpc's file naming service to configure partition locations. Each line consists of a server address followed by a partition index and the total number of partitions. Comments are allowed after #. The server_list is hot-reloaded by the DynamicPartitionChannel client, enabling live topology changes.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n0.0.0.0:8004  0/3  # The first partition of the three\n0.0.0.0:8004  1/3  # and so forth\n0.0.0.0:8004  2/3\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Body in brpc Controller - C++\nDESCRIPTION: Demonstrates two ways to append content as the HTTP request body: appending a string directly and constructing the body with IOBufBuilder then moving it. Converts the builder to the request's attachment efficiently. Dependency: butil, brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_13\n\nLANGUAGE: c++\nCODE:\n```\ncntl->request_attachment().append(\"....\");\nbutil::IOBufBuilder os; os << \"....\";\nos.move_to(cntl->request_attachment());\n```\n\n----------------------------------------\n\nTITLE: Defining and Using MultiDimension mbvar Variables in C++ with bvar\nDESCRIPTION: This C++ example demonstrates defining a global MultiDimension variable using bvar, retrieving single-dimension bvar pointers, inputting values, and logging statistical results. It showcases integration with bvar's generic types such as Adder, and demonstrates proper pointer usage. Dependencies include the bvar headers and the use of the brpc logging framework. The function expects a list of labels as input and outputs status integer values. Adder references must only be accessed during the MultiDimension's lifetime to avoid undefined behavior.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <bvar/bvar.h>\\n#include <bvar/multi_dimension.h>\\n\\nnamespace foo {\\nnamespace bar {\\n// \\u5b9a\\u4e49\\u4e00\\u4e2a\\u5168\\u5c40\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\\n// bvar::MultiDimension<bvar::Adder<int> > g_request_count(\"foo_bar\", \"request_count\", {\"idc\", \"method\", \"status\"});\\n\\nint process_request(const std::list<std::string>& request_label) {\\n    // \\u83b7\\u53d6request_label\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6bvar\\u6307\\u9488\\uff0c\\u6bd4\\u5982\\uff1arequest_label = {\"tc\", \"get\", \"200\"}\\n    bvar::Adder<int>* adder = g_request_count.get_stats(request_label);\\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\\n    if (!adder) {\\n        return -1;\\n    }\\n    // adder\\u53ea\\u80fd\\u5728g_request_count\\u7684\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\\n    // \\u7ed9adder\\u8f93\\u5165\\u4e00\\u4e9b\\u503c\\n    *adder << 1 << 2 <<3;\\n    LOG(INFO) << \"adder=\" << *adder; // adder add up to 6\\n    ...\\n    return 0;\\n}\\n\\n} // namespace bar\\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using bvar::Status to Hold and Expose Values - C++\nDESCRIPTION: This snippet provides examples of different ways to declare and expose bvar::Status, which is used for displaying periodically updated values. It supports construction with immediate value, assignment using set_value(), or exposing with a name. Tp must be std::string or compatible with boost::atomic. Dependencies: bvar and correct types for template argument.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\n// Display a rarely or periodically updated value.\n// Usage:\n//   bvar::Status<int> foo_count1(17);\n//   foo_count1.expose(\"my_value\");\n//\n//   bvar::Status<int> foo_count2;\n//   foo_count2.set_value(17);\n//\n//   bvar::Status<int> foo_count3(\"my_value\", 17);\n//\n// Notice that Tp needs to be std::string or acceptable by boost::atomic<Tp>.\ntemplate <typename Tp>\nclass Status : public Variable;\n```\n\n----------------------------------------\n\nTITLE: Exposing gflags as bvar for Monitoring via bvar::GFlag - C++\nDESCRIPTION: This snippet illustrates how to expose a gflag variable as a bvar using bvar::GFlag, enabling monitoring (such as in noah). It shows both default (matching gflag name) and prefixed exposures. Dependencies include gflags and bvar. The main parameter is the gflag name or prefix; expected output is a bvar that reflects the gflag's current value.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_22\n\nLANGUAGE: C++\nCODE:\n```\nDEFINE_int32(my_flag_that_matters, 8, \"...\");\n\n// Expose the gflag as *same-named* bvar so that it's monitored (in noah).\nstatic bvar::GFlag s_gflag_my_flag_that_matters(\"my_flag_that_matters\");\n//                                                ^\n//                                            the gflag name\n\n// Expose the gflag as a bvar named \"foo_bar_my_flag_that_matters\".\nstatic bvar::GFlag s_gflag_my_flag_that_matters_with_prefix(\"foo_bar\", \"my_flag_that_matters\");\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Server-Thread-Local Data in brpc Server (C++)\nDESCRIPTION: This snippet demonstrates how to define a thread-local data structure (MyThreadLocalData) and access it within a brpc service method using brpc::thread_local_data(). ServerOptions must have thread_local_data_factory set to enable retrieval. The code shows error handling if the factory is missing, ensuring correctness in per-thread data management and highlighting reuse across threads. Requires linking with brpc and proper setup of ServerOptions in the server.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\n#ifndef EXAMPLE_ECHO_SERVICE_H\n#define EXAMPLE_ECHO_SERVICE_H\n\nstruct MyThreadLocalData {\n    MyThreadLocalData() : y(0) {}\n    int y;\n};\n\nclass EchoServiceImpl : public example::EchoService {\npublic:\n    ...\n    void Echo(google::protobuf::RpcController* cntl_base,\n              const example::EchoRequest* request,\n              example::EchoResponse* response,\n              google::protobuf::Closure* done) {\n        ...\n        brpc::Controller* cntl = static_cast<brpc::Controller*>(cntl_base);\n\n        // Get the thread-local data which is created by ServerOptions.thread_local_data_factory\n        // and reused between different threads.\n        // \"tls\" is short for \"thread local storage\".\n        MyThreadLocalData* tls = static_cast<MyThreadLocalData*>(brpc::thread_local_data());\n        if (tls == NULL) {\n            cntl->SetFailed(\"Require ServerOptions.thread_local_data_factory \"\n                            \"to be set with a correctly implemented instance\");\n            return;\n        }\n        ...\n    }\n};\n\n#endif // EXAMPLE_ECHO_SERVICE_H\n\n```\n\n----------------------------------------\n\nTITLE: Finding and Including brpc Library\nDESCRIPTION: Locates brpc headers and library files, with dynamic linking support controlled by the LINK_SO option. Fails with an error if brpc cannot be found.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n```\n\n----------------------------------------\n\nTITLE: Examples of Exposing bvar Variables Globally in C++\nDESCRIPTION: Demonstrates different ways to expose bvar variables to the global registry using the expose() and expose_as() methods, including handling of name conflicts.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nbvar::Adder<int> count1; // create a bvar with defalut params\ncount1 << 10 << 20 << 30;   // values add up to 60.\ncount1.expose(\"count1\");  // expose the variable globally\nCHECK_EQ(\"60\", bvar::Variable::describe_exposed(\"count1\"));\ncount1.expose(\"another_name_for_count1\");  // expose the variable with another name\nCHECK_EQ(\"\", bvar::Variable::describe_exposed(\"count1\"));\nCHECK_EQ(\"60\", bvar::Variable::describe_exposed(\"another_name_for_count1\"));\n\nbvar::Adder<int> count2(\"count2\");  // exposed in constructor directly\nCHECK_EQ(\"0\", bvar::Variable::describe_exposed(\"count2\"));  // default value of Adder<int> is 0\n\nbvar::Status<std::string> status1(\"count2\", \"hello\");  // the name conflicts. if -bvar_abort_on_same_name is true,\n                                                      // program aborts, otherwise a fatal log is printed.\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Example Executables\nDESCRIPTION: Defines build targets for HTTP client, server, and benchmarking applications. Includes protocol buffer generated source files for the server target.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(http_client http_client.cpp)\nadd_executable(http_server http_server.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(benchmark_http benchmark_http.cpp)\n```\n\n----------------------------------------\n\nTITLE: Declaring MVariable and Listing Exposed Variables with bvar in C++\nDESCRIPTION: This snippet shows the declaration of the MVariable class with a static method for listing all exposed mbvariable names. It serves as the base class for multi-dimensional variables in bvar. The list_exposed function takes a pointer to a vector of strings where the names of exposed metrics will be stored and returns the number of such variables.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nclass MVariable {\npublic:\n    ...\n    // Put names of all exposed mbvariable into `names'\n    static size_t list_exposed(std::vector<std::string>* names);\n};\n```\n\n----------------------------------------\n\nTITLE: Naming Examples for bvar Variables in C++\nDESCRIPTION: Provides examples of well-formed bvar variable names following the recommended naming convention of module_class_indicator structure.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\niobuf_block_count : 29                          # module=iobuf   class=block  indicator=count\niobuf_block_memory : 237568                     # module=iobuf   class=block  indicator=memory\nprocess_memory_resident : 34709504              # module=process class=memory indicator=resident\nprocess_memory_shared : 6844416                 # module=process class=memory indicator=shared\nrpc_channel_connection_count : 0                # module=rpc     class=channel_connection  indicator=count\nrpc_controller_count : 1                        # module=rpc     class=controller indicator=count\nrpc_socket_count : 6                            # module=rpc     class=socket     indicator=count\n```\n\n----------------------------------------\n\nTITLE: BRPC Static Library Configuration\nDESCRIPTION: Configures and builds BRPC static library with dependencies and installation rules\nSOURCE: https://github.com/apache/brpc/blob/master/src/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(brpc-static STATIC $<TARGET_OBJECTS:BUTIL_LIB>\n                               $<TARGET_OBJECTS:SOURCES_LIB>\n                               $<TARGET_OBJECTS:PROTO_LIB>)\n\nif(WITH_THRIFT)\n   target_link_libraries(brpc-static ${THRIFT_LIB})\n   check_thrift_version(brpc-static)\nendif()\n\nSET_TARGET_PROPERTIES(brpc-static PROPERTIES OUTPUT_NAME brpc CLEAN_DIRECT_OUTPUT 1)\n```\n\n----------------------------------------\n\nTITLE: Exporting All Exposed mbvar Variables with MVariable::dump_exposed in C++\nDESCRIPTION: This C++ snippet demonstrates how to export all globally registered (exposed) mbvar variables by implementing a Dumper class and using the MVariable::dump_exposed static method. The Dumper virtual interface allows customized output, while DumpOptions configures dumping formats such as quoting and wildcards (some options currently unsupported). Correct use requires linking against bvar, providing a customized Dumper subclass, and optionally specifying DumpOptions. The function returns the count of dumped variables or -1 on error.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// Implement this class to write mvariables into different places.\\n// If dump() returns false, MVariable::dump_exposed() skip and continue dump.\\nclass Dumper {\\npublic:\\n    virtual bool dump(const std::string& name, const base::StringPiece& description) = 0;\\n};\\n\\n// Options for MVariable::dump_exposed().\\nstruct DumpOptions {\\n    // Contructed with default options.\\n    DumpOptions();\\n    // If this is true, string-type values will be quoted.\\n    bool quote_string;\\n    // The ? in wildcards. Wildcards in URL need to use another character\\n    // because ? is reserved.\\n    char question_mark; // \\u76ee\\u524d\\u4e0d\\u652f\\u6301\\n    // Separator for white_wildcards and black_wildcards.\\n    char wildcard_separator; // \\u76ee\\u524d\\u4e0d\\u652f\\u6301\\n    // Name matched by these wildcards (or exact names) are kept.\\n    std::string white_wildcards; // \\u76ee\\u524d\\u4e0d\\u652f\\u6301\\n    // Name matched by these wildcards (or exact names) are skipped.\\n    std::string black_wildcards; // \\u76ee\\u524d\\u4e0d\\u652f\\u6301\\n};\\n\\nclass MVariable {\\n    ...\\n    ...\\n    // Find all exposed mvariables and send them to `dumper'.\\n    // Use default options when `options' is NULL.\\n    // Return number of dumped mvariables, -1 on error.\\n    static size_t dump_exposed(Dumper* dumper, const DumpOptions* options);\\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Logging Macros in C++\nDESCRIPTION: Shows advanced logging macros in brpc, including periodic logging, conditional logging, and limited occurrence logging.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_log.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nLOG_EVERY_SECOND(INFO) << \"High-frequent logs\";\nLOG_EVERY_N(ERROR, 10) << \"High-frequent logs\";\nLOG_FIRST_N(INFO, 20) << \"Logs that prints for at most 20 times\";\nLOG_ONCE(WARNING) << \"Logs that only prints once\";\n```\n\n----------------------------------------\n\nTITLE: Making HTTP GET Request in brpc\nDESCRIPTION: Demonstrates how to make a simple HTTP GET request using brpc. Sets the target URL in the controller's http_request and calls the method through the channel. The response body is available in response_attachment().\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl;\ncntl.http_request().uri() = \"www.baidu.com/index.html\";  // 设置为待访问的URL\nchannel.CallMethod(NULL, &cntl, NULL, NULL, NULL/*done*/);\n```\n\n----------------------------------------\n\nTITLE: Server-side Handling of Thrift Requests in C++\nDESCRIPTION: C++ code showing how to implement a Thrift service in brpc by inheriting from brpc::ThriftService. This example demonstrates request processing, method dispatching, and response handling for a Thrift server.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/thrift.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nclass EchoServiceImpl : public brpc::ThriftService {\npublic:\n    void ProcessThriftFramedRequest(brpc::Controller* cntl,\n                                    brpc::ThriftFramedMessage* req,\n                                    brpc::ThriftFramedMessage* res,\n                                    google::protobuf::Closure* done) override {\n        // Dispatch calls to different methods\n        if (cntl->thrift_method_name() == \"Echo\") {\n            return Echo(cntl, req->Cast<example::EchoRequest>(),\n                        res->Cast<example::EchoResponse>(), done);\n        } else {\n            cntl->SetFailed(brpc::ENOMETHOD, \"Fail to find method=%s\",\n                            cntl->thrift_method_name().c_str());\n            done->Run();\n        }\n    }\n\n    void Echo(brpc::Controller* cntl,\n              const example::EchoRequest* req,\n              example::EchoResponse* res,\n              google::protobuf::Closure* done) {\n        // This object helps you to call done->Run() in RAII style. If you need\n        // to process the request asynchronously, pass done_guard.release().\n        brpc::ClosureGuard done_guard(done);\n\n        res->data = req->data + \" (processed)\";\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Request URI in brpc Controller - C++\nDESCRIPTION: Assigns a new URL to the request's URI field in brpc::Controller. This determines the target endpoint for the HTTP operation. Dependency: brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().uri() = \"http://www.baidu.com\";\n```\n\n----------------------------------------\n\nTITLE: Registering and Starting BRPC Thrift Server - C++\nDESCRIPTION: This snippet shows how to register a custom Thrift service implementation with BRPC server options and start the server. It assigns the service to ServerOptions.thrift_service, sets idle timeout and concurrency, then starts the server on a specified port. Requires a user-defined ThriftService implementation and expects valid runtime flags. On successful startup, the server listens for Thrift requests; otherwise, it logs an error and exits.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/thrift.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n    brpc::Server server;\\n    brpc::ServerOptions options;\\n    options.thrift_service = new EchoServiceImpl;\\n    options.idle_timeout_sec = FLAGS_idle_timeout_s;\\n    options.max_concurrency = FLAGS_max_concurrency;\\n\\n    // Start the server.\\n    if (server.Start(FLAGS_port, &options) != 0) {\\n        LOG(ERROR) << \"Fail to start EchoServer\";\\n        return -1;\\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom DataFactory for Thread-Local Data in brpc (C++)\nDESCRIPTION: The snippet defines a concrete implementation of brpc::DataFactory for handling the creation and destruction of MyThreadLocalData instances. It also shows how to assign the factory to ServerOptions before running the server. Thread safety is required as CreateData and DestroyData might be called from multiple threads. The code must be used with the brpc library and a correctly defined MyThreadLocalData.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\nclass MyThreadLocalDataFactory : public brpc::DataFactory {\npublic:\n    void* CreateData() const {\n        return new MyThreadLocalData;\n    }\n    void DestroyData(void* d) const {\n        delete static_cast<MyThreadLocalData*>(d);\n    }\n};\n\nMyThreadLocalDataFactory g_thread_local_data_factory;\n\nint main(int argc, char* argv[]) {\n    ...\n\n    brpc::Server server;\n    brpc::ServerOptions options;\n    ...\n    options.thread_local_data_factory  = &g_thread_local_data_factory;\n    ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Error Codes in C++\nDESCRIPTION: This snippet demonstrates how to declare custom error codes for use with brpc in C/C++. It includes use of macros, static constants, and language-specific 'const int' for C++ only. No external dependencies beyond a C/C++ compiler are required. Typical inputs are error names and integer values; these codes are later used in logging or error handling.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/error_code.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define ESTOP -114                // C/C++\\nstatic const int EMYERROR = 30;   // C/C++\\nconst int EMYERROR2 = -31;        // C++ only\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Error Codes in C++\nDESCRIPTION: Shows different ways to define custom error codes in C/C++ using macros, static constants, and regular constants.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/error_code.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#define ESTOP -114                // C/C++\nstatic const int EMYERROR = 30;   // C/C++\nconst int EMYERROR2 = -31;        // C++ only\n```\n\n----------------------------------------\n\nTITLE: Using bvar::Adder to Accumulate Metric Values in Multi-Dimensional Metrics (C++)\nDESCRIPTION: This code uses bvar::Adder<int> to accumulate and query a total sum for a particular label combination in a multi-dimensional metric. The get_stats method retrieves or allocates the appropriate single-dimensional variable, which is updated multiple times before reading its value. Safe access is only ensured within the parent mbvar's life.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_14\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_cost(\"request_count\", {\"idc\", \"method\", \"status\"});\n\nint request_cost_total(const std::list<std::string>& request_labels) {\n    // \\u83b7\\u53d6request\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6mbvar\\u6307\\u9488\\uff0c\\u5047\\u8bberequest_labels = {\"tc\", \"get\", \"200\"}\n    bvar::Adder<int>* cost_add = g_request_cost.get_stats(request_labels);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!cost_add) {\n        return -1;\n    }\n    // cost_add\\u53ea\\u80fd\\u5728g_request_cost\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\n    *cost_add << 1 << 2 << 3 << 4;\n    CHECK_EQ(10, cost_add->get_value());\n    return cost_add->get_value();\n}\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Building gflags with Shared and Static Libraries\nDESCRIPTION: CMake command to build gflags with both shared and static libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/getting_started.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ cmake . -DBUILD_SHARED_LIBS=1 -DBUILD_STATIC_LIBS=1\n$ make\n```\n\n----------------------------------------\n\nTITLE: Printing Server-side Address and Port with brpc::Controller in C++\nDESCRIPTION: Demonstrates how to retrieve and print the server-side (remote) address and port information from a brpc::Controller object using remote_side() and butil::endpoint2str. Only valid after the RPC completes; calling prior to completion is undefined. Useful for debugging and connection verification, requires brpc and butil dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_15\n\nLANGUAGE: c++\nCODE:\n```\nLOG(INFO) << \"remote_side=\" << cntl->remote_side();\nprintf(\"remote_side=%s\\n\", butil::endpoint2str(cntl->remote_side()).c_str());\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Parameter from URI in brpc Controller - C++\nDESCRIPTION: Retrieves a query parameter 'Foo' from the request URI using brpc::Controller. Returns pointer to std::string value if present, NULL otherwise. Dependency: brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\nconst std::string* value = cntl->http_request().uri().GetQuery(\"Foo\"); // NULL when not exist\n```\n\n----------------------------------------\n\nTITLE: Setting URL in brpc HTTP Request\nDESCRIPTION: Shows how to set the URL for an HTTP request. This is typically done by assigning a string to the uri() method of the http_request object.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().uri() = \"http://www.baidu.com\";\n```\n\n----------------------------------------\n\nTITLE: Setting Up Protobuf for HTTP Protocol Definition\nDESCRIPTION: Includes necessary modules and generates C++ code from HTTP protocol buffer definition. Includes the generated headers in the build.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER http.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Version in brpc Client\nDESCRIPTION: Demonstrates how to explicitly set the HTTP version when working with older servers that require HTTP/1.0 compatibility. By default, brpc uses HTTP/1.1 for HTTP connections.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\ncntl.http_request().set_version(1, 0);\n```\n\n----------------------------------------\n\nTITLE: Custom bvar Exposed Variable Dumping - brpc - C++\nDESCRIPTION: This example illustrates customizing variable export by subclassing Dumper and configuring DumpOptions for fine-grained control over which bvars are dumped. Dependencies include the bvar library and, if applicable, butil. Key parameters include wildcards for selective export and options for string quoting and wildcard formats. Input involves implementing subclasses and options for variable dumping; output is controlled by the virtual dump method return value and the filter logic specified by DumpOptions.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n// Implement this class to write variables into different places.\n// If dump() returns false, Variable::dump_exposed() stops and returns -1.\nclass Dumper {\npublic:\n    virtual bool dump(const std::string& name, const butil::StringPiece& description) = 0;\n};\n\n// Options for Variable::dump_exposed().\nstruct DumpOptions {\n    // Contructed with default options.\n    DumpOptions();\n    // If this is true, string-type values will be quoted.\n    bool quote_string;\n    // The ? in wildcards. Wildcards in URL need to use another character\n    // because ? is reserved.\n    char question_mark;\n    // Separator for white_wildcards and black_wildcards.\n    char wildcard_separator;\n    // Name matched by these wildcards (or exact names) are kept.\n    std::string white_wildcards;\n    // Name matched by these wildcards (or exact names) are skipped.\n    std::string black_wildcards;\n};\n\nclass Variable {\n    ...\n    ...\n    // Find all exposed variables matching `white_wildcards' but\n    // `black_wildcards' and send them to `dumper'.\n    // Use default options when `options' is NULL.\n    // Return number of dumped variables, -1 on error.\n    static int dump_exposed(Dumper* dumper, const DumpOptions* options);\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Retrieval via HTTP Path - brpc C++\nDESCRIPTION: This C++ code implements the generic 'default_method' for file or resource retrieval. It decodes the requested resource path from the normalized unresolved_path in the brpc Controller and constructs a response indicating the file being retrieved. The implementation relies on brpc and protobuf libraries. The input is an HTTP request mapped via the service URL; the output is a simple text string stored in the response attachment. Limitations: no actual file I/O is performed in this example—it's a stub for demonstration.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nclass FileServiceImpl: public FileService {\\npublic:\\n    ...\\n    virtual void default_method(google::protobuf::RpcController* cntl_base,\\n                                const HttpRequest* /*request*/,\\n                                HttpResponse* /*response*/,\\n                                google::protobuf::Closure* done) {\\n        brpc::ClosureGuard done_guard(done);\\n        brpc::Controller* cntl = static_cast<brpc::Controller*>(cntl_base);\\n        cntl->response_attachment().append(\"Getting file: \");\\n        cntl->response_attachment().append(cntl->http_request().unresolved_path());\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Redis Performance Benchmarking with Batch Commands (50 Threads)\nDESCRIPTION: Performance benchmark using 50 bthreads with batch mode (10 commands per request). Shows QPS, latency, and CPU usage of Redis server at ~94%.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ ./client -use_bthread -thread_num 50 -batch 10\nTRACE: 02-13 19:47:14:   * 0 client.cpp:180] Accessing redis server at qps=38082 latency=1307\nTRACE: 02-13 19:47:15:   * 0 client.cpp:180] Accessing redis server at qps=38267 latency=1304\nTRACE: 02-13 19:47:16:   * 0 client.cpp:180] Accessing redis server at qps=38070 latency=1305\n \n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND \n16878 gejun     20   0 48136 2436 1004 R 93.8  0.0  12:48.56 redis-server   // thread_num=50\n```\n\n----------------------------------------\n\nTITLE: Running a brpc Server Until Interrupt - C++\nDESCRIPTION: This C++ code demonstrates running a brpc server using server.RunUntilAskedToQuit(), which blocks until an interrupt (such as Ctrl-C) is received, after which the server is stopped and joined. This simplifies server management by handling shutdown signals internally. After server termination, resource cleanup code can be executed. Requires the brpc framework.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n// Wait until Ctrl-C is pressed, then Stop() and Join() the server.\nserver.RunUntilAskedToQuit();\n \n// server is stopped, write the code for releasing resources.\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using EndPoint with UDS and IPv6 in brpc\nDESCRIPTION: Code example showing how to initialize EndPoint objects for UDS and IPv6 addresses, get endpoint types, convert between formats, and use them with TCP functions.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/endpoint.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nEndPoint ep;\nstr2endpoint(\"unix:path.sock\", &ep); // 初始化一个UDS的EndPoint\nstr2endpoint(\"[::1]:8086\", &ep);  // 初始化一个IPV6的EndPoint\nstr2endpoint(\"[::1]\", 8086, &ep);  // 初始化一个IPV6的EndPoint\n \n// 获取EndPoint的类型\nsa_family_t type = get_endpoint_type(ep); // 可能为AF_INET、AF_INET6或AF_UNIX\n \n// 使用EndPoint，和原来的方式一样\nLOG(DEBUG) << ep; // 打印EndPoint\nstd::string ep_str = endpoint2str(ep).c_str(); // EndPoint转str\ntcp_listen(ep); // 用监听EndPoint表示的tcp端口\ntcp_connect(ep, NULL); // 用连接EndPoint表示的tcp端口\n \nsockaddr_storage ss;\nsocklen_t socklen = 0;\nendpoint2sockaddr(ep, &ss, &socklen); // 将EndPoint转为sockaddr结构，以便调用系统函数\n```\n\n----------------------------------------\n\nTITLE: Synchronous RPC Call in C++\nDESCRIPTION: Shows how to make a synchronous RPC call using a stub, including error handling and response processing.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\nMyRequest request;\nMyResponse response;\nbrpc::Controller cntl;\nXXX_Stub stub(&channel);\n\nrequest.set_foo(...);\ncntl.set_timeout_ms(...);\nstub.some_method(&cntl, &request, &response, NULL);\nif (cntl->Failed()) {\n    // RPC failed. response values are undefined, do not use.\n} else {\n    // RPC succeeded, response contains the reply data.\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Data to IOBuf in C++\nDESCRIPTION: Examples of serializing protobuf messages and building IOBuf with printable data.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/iobuf.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nIOBufAsZeroCopyOutputStream wrapper(&iobuf);\npb_message.SerializeToZeroCopyStream(&wrapper);\n```\n\nLANGUAGE: c++\nCODE:\n```\nIOBufBuilder os;\nos << \"anything can be sent to std::ostream\";\nos.buf();\n```\n\n----------------------------------------\n\nTITLE: Displaying Reserved Characters in HTTP Specification\nDESCRIPTION: This code snippet lists the reserved characters in HTTP specification that need to be encoded with '%'. It includes general delimiters and sub-delimiters as defined in RFC 3986.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\n       reserved    = gen-delims / sub-delims\n\n       gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n\n       sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum with bvar::Maxer - brpc - C++\nDESCRIPTION: This snippet illustrates using bvar::Maxer to track the maximum of an integer stream, leveraging std::max semantics. Maxer uses std::numeric_limits::min() as the identity and requires operator< on the type. The input is integer values; the output is the maximum so far. Not suitable for unsupported types unless specialized.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nbvar::Maxer<int> value;\nvalue << 1 << 2 << 3 << -4;\nCHECK_EQ(3, value.get_value());\n```\n\n----------------------------------------\n\nTITLE: Parsing Server Addresses for brpc Protocols (C++)\nDESCRIPTION: Defines an optional callback for converting text addresses (host:port or protocol-specific forms) into endpoint structures for brpc channels. Implement this if your protocol requires specialized parsing of server addressing; for ordinary protocols, this may be left null.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\ntypedef bool (*ParseServerAddress)(butil::EndPoint* out, const char* server_addr_and_port);\n```\n\n----------------------------------------\n\nTITLE: Logging Server Address via brpc Controller - C++\nDESCRIPTION: Logs or prints the server-side local address for the active RPC session using brpc Controller's local_side() method, again with both glog and printf. Useful for tracing, debugging, and monitoring distributed service deployments where network topology is important.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nLOG(INFO) << \"local_side=\" << cntl->local_side();\nprintf(\"local_side=%s\\n\", butil::endpoint2str(cntl->local_side()).c_str());\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of brpc::Join with Potential Controller Deletion in C++\nDESCRIPTION: Highlights an incorrect pattern where Join is invoked using controller->call_id() after the asynchronous RPC finished, making it possible that the Controller has already been deleted in the done callback. This creates a race condition and undefined behavior. The snippet assumes asynchronous methods (stub.method1/method2) and custom on_rpc_done cleanup logic, where deletion of Controller or response occurs in the callback, making the post-RPC Join dangerous and invalid.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_13\n\nLANGUAGE: c++\nCODE:\n```\nstatic void on_rpc_done(Controller* controller, MyResponse* response) {\n    ... Handle response ...\n    delete controller;\n    delete response;\n}\n\nController* controller1 = new Controller;\nController* controller2 = new Controller;\nMyResponse* response1 = new MyResponse;\nMyResponse* response2 = new MyResponse;\n...\nstub.method1(controller1, &request1, response1, google::protobuf::NewCallback(on_rpc_done, controller1, response1));\nstub.method2(controller2, &request2, response2, google::protobuf::NewCallback(on_rpc_done, controller2, response2));\n...\nbrpc::Join(controller1->call_id());   // WRONG, controller1 may be deleted by on_rpc_done\nbrpc::Join(controller2->call_id());   // WRONG, controller2 may be deleted by on_rpc_done\n```\n\n----------------------------------------\n\nTITLE: Windowed Value Sampling with bvar::Window - brpc - C++\nDESCRIPTION: bvar::Window enables windowed sampling (1 second granularity) over a counter variable, periodically reporting sampled statistics without manual data sending. Window requires a reference variable (counter) to already exist, and both construction and destruction ordering matter. Inputs: Window is parameterized with a counter type; outputs are computed sampled metrics in real time. Limitations include up-to-one-second data latency due to sampling rate.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\n// Get data within a time window.\n// The time unit is 1 second fixed.\n// Window relies on other bvar which should be constructed before this window and destructs after this window.\n// R must:\n// - have get_sampler() (not require thread-safe)\n// - defined value_type and sampler_type\ntemplate <typename R>\nclass Window : public Variable;\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Latency Monitoring in BRPC C++\nDESCRIPTION: Implementation of custom latency monitoring using BRPC's bvar library. This code demonstrates how to create a latency recorder, measure function execution time, and generate CDF graphs for monitoring request latencies.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/backup_request.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <butil/time.h>\n...\nbvar::LatencyRecorder my_func_latency(\"my_func\");\n...\nbutil::Timer tm;\ntm.start();\nmy_func();\ntm.stop();\nmy_func_latency << tm.u_elapsed();  // u represents for microsecond, and s_elapsed(), m_elapsed(), n_elapsed() correspond to second, millisecond, nanosecond.\n \n// All work is done here. My_func_qps, my_func_latency, my_func_latency_cdf and many other counters would be shown in /vars.\n```\n\n----------------------------------------\n\nTITLE: Building brpc with RDMA using CMake\nDESCRIPTION: Instructions for building brpc with RDMA support using CMake build system. This includes enabling RDMA with the WITH_RDMA option and building the rdma_performance example.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/rdma.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir bld && cd bld && cmake -DWITH_RDMA=ON ..\nmake\n\ncd example/rdma_performance  # example for rdma\nmkdir bld && cd bld && cmake ..\nmake\n```\n\n----------------------------------------\n\nTITLE: Starting brpc Server with Flexible Options - C++\nDESCRIPTION: Describes several overloads of brpc::Server::Start, supporting startup with different address specifications, with or without explicit ServerOptions. Also shows configuring non-default options before starting the server. Relies on valid ip/port strings and optional brpc::ServerOptions struct for tuning server behavior.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nint Start(const char* ip_and_port_str, const ServerOptions* opt);\nint Start(EndPoint ip_and_port, const ServerOptions* opt);\nint Start(int port, const ServerOptions* opt);\nint Start(const char *ip_str, PortRange port_range, const ServerOptions *opt);  // r32009\\u540e\\u589e\\u52a0\n```\n\nLANGUAGE: C++\nCODE:\n```\nbrpc::ServerOptions options;  // with default values\noptions.xxx = yyy;\n...\nserver.Start(..., &options);\n```\n\n----------------------------------------\n\nTITLE: Configuring brpc Servers and Channels with UDS and IPv6\nDESCRIPTION: Code example demonstrating how to start a server and initialize channels using UDS paths or IPv6 addresses in brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/endpoint.md#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nserver.Start(\"unix:path.sock\", options); // 启动server监听UDS地址\nserver.Start(\"[::0]:8086\", options);  // 启动server监听IPV6地址\n \nchannel.Init(\"unix:path.sock\", options); // 初始化single server的Channel，访问UDS地址\nchannel.Init(\"list://[::1]:8086,[::1]:8087\", \"rr\", options); // 初始化带LB的Channel，访问IPV6地址\n```\n\n----------------------------------------\n\nTITLE: Tracing bthread Call Stack Output Example in Shell\nDESCRIPTION: This snippet shows an example output of tracing a bthread call stack using the implemented mechanism. It displays the function calls in the stack trace, including system and bRPC-specific functions.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/bthread_tracer.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n#0 0x00007fdbbed500b5 __clock_gettime_2\n#1 0x000000000041f2b6 butil::cpuwide_time_ns()\n#2 0x000000000041f289 butil::cpuwide_time_us()\n#3 0x000000000041f1b9 butil::EveryManyUS::operator bool()\n#4 0x0000000000413289 (anonymous namespace)::spin_and_log()\n#5 0x00007fdbbfa58dc0 bthread::TaskGroup::task_runner()\n```\n\n----------------------------------------\n\nTITLE: Defining SSL Certificate Structure in C++\nDESCRIPTION: Defines the CertInfo structure for SSL certificates, including fields for the certificate, private key, and additional hostnames for SNI filtering.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nstruct CertInfo {\n    std::string certificate;\n    std::string private_key;\n    std::vector<std::string> sni_filters;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building brpc Streaming Echo Example - CMake\nDESCRIPTION: This CMake script configures and orchestrates building the brpc streaming_echo example for both client and server components. Dependencies include Protocol Buffers, LevelDB, OpenSSL, gflags, and optionally Thrift; the script manages finding libraries and include paths, establishing C++11 standards, and incorporating special handling for macOS. It additionally invokes shell commands to discover output directories, sets up library linkage based on the LINK_SO option, and creates two executables with proper dependencies. Expected inputs are source and proto files, with output executables ready for testing the streaming echo features of brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/example/streaming_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(streaming_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\\\".*output/include$\\\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(streaming_echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(streaming_echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(streaming_echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(streaming_echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Ubuntu/LinuxMint/WSL\nDESCRIPTION: Command to install necessary dependencies for building brpc on Ubuntu-based systems.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/getting_started.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get install -y git g++ make libssl-dev libgflags-dev libprotobuf-dev libprotoc-dev protobuf-compiler libleveldb-dev\n```\n\n----------------------------------------\n\nTITLE: Memory Reordering Example - Unsafe Initialization\nDESCRIPTION: Demonstrates potentially unsafe code due to memory reordering where thread synchronization may fail due to instruction reordering by compiler or CPU.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/atomic_instructions.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\n// Thread 1\n// bool ready was initialized to false\np.init();\nready = true;\n```\n\nLANGUAGE: c++\nCODE:\n```\n// Thread2\nif (ready) {\n    p.bar();\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Thrift Server via BRPC Channel - C++\nDESCRIPTION: This snippet illustrates how a BRPC client can call a Thrift server using C++. After including the necessary headers for channels and Thrift messages, the code sets up a BRPC Channel using the Thrift protocol and initializes it with server address and options. A ThriftStub is then created and used to make an RPC call with a native Thrift request and response message. Key parameters include the server address, load balancer, and Thrift method name. Input is a Thrift request message; output is the populated response or error logging if the call fails.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/thrift.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/channel.h>\\n#include <brpc/thrift_message.h>         // Defines ThriftStub\\n...\\n\\nDEFINE_string(server, \"0.0.0.0:8019\", \"IP Address of thrift server\");\\nDEFINE_string(load_balancer, \"\", \"The algorithm for load balancing\");\\n...\\n  \\nbrpc::ChannelOptions options;\\noptions.protocol = brpc::PROTOCOL_THRIFT;\\nbrpc::Channel thrift_channel;\\nif (thrift_channel.Init(Flags_server.c_str(), FLAGS_load_balancer.c_str(), &options) != 0) {\\n   LOG(ERROR) << \"Fail to initialize thrift channel\";\\n   return -1;\\n}\\n\\nbrpc::ThriftStub stub(&thrift_channel);\\n...\\n\\n// example::[EchoRequest/EchoResponse] are types generated by thrift\\nexample::EchoRequest req;\\nexample::EchoResponse res;\\nreq.data = \"hello\";\\n\\nstub.CallMethod(\"Echo\", &cntl, &req, &res, NULL);\\nif (cntl.Failed()) {\\n    LOG(ERROR) << \"Fail to send thrift request, \" << cntl.ErrorText();\\n    return -1;\\n} \n```\n\n----------------------------------------\n\nTITLE: Broadcaster Implementation of CallMapper for brpc ParallelChannel\nDESCRIPTION: Implementation of CallMapper that broadcasts the same request to all sub channels, creating new response objects for each channel.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\n  class Broadcaster : public CallMapper {\n  public:\n      SubCall Map(int channel_index/*starting from 0*/,\n                  const google::protobuf::MethodDescriptor* method,\n                  const google::protobuf::Message* request,\n                  google::protobuf::Message* response) {\n          // Use the method/request to pchan.\n          // response is created by `new` and the last flag tells pchan to delete response after completion of the RPC\n          return SubCall(method, request, response->New(), DELETE_RESPONSE);\n      }\n  };\n```\n\n----------------------------------------\n\nTITLE: Configuring BRPC with Thrift Support - Bash\nDESCRIPTION: These commands show how to configure and compile the BRPC library with Thrift support on various Linux distributions. Users must specify header and library paths and add the --with-thrift flag or use CMake with -DWITH_THRIFT=ON. Successfully running these commands results in a BRPC build that includes Thrift protocol support for further integration.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/thrift.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Ubuntu\\nsh config_brpc.sh --headers=/usr/include --libs=/usr/lib --with-thrift\\n# Fedora/CentOS\\nsh config_brpc.sh --headers=/usr/include --libs=/usr/lib64 --with-thrift\\n# Or use cmake\\nmkdir build && cd build && cmake ../ -DWITH_THRIFT=ON\n```\n\n----------------------------------------\n\nTITLE: Invalid Latency Percentile Configurations\nDESCRIPTION: Examples of incorrect latency percentile settings that will cause gflags parsing to fail. Values must be within [1,99] range.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n-bvar_latency_p3=100   # the value must be inside [1,99] inclusive，otherwise gflags fails to parse\n-bvar_latency_p1=-1    # ^\n```\n\n----------------------------------------\n\nTITLE: Supported Memcache Operation Methods in brpc C++ API\nDESCRIPTION: Lists the available C++ methods on the brpc::MemcacheRequest interface for issuing various memcached operations. These methods collectively cover core CRUD, atomic increment/decrement, and utility operations (e.g., flush, touch, version). Each method takes specific types and parameters tailored to each memcached command, and most return a boolean indicating request assembly success. These must be invoked before calling channel.CallMethod.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/memcache_client.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nbool Set(const Slice& key, const Slice& value, uint32_t flags, uint32_t exptime, uint64_t cas_value);\\nbool Add(const Slice& key, const Slice& value, uint32_t flags, uint32_t exptime, uint64_t cas_value);\\nbool Replace(const Slice& key, const Slice& value, uint32_t flags, uint32_t exptime, uint64_t cas_value);\\nbool Append(const Slice& key, const Slice& value, uint32_t flags, uint32_t exptime, uint64_t cas_value);\\nbool Prepend(const Slice& key, const Slice& value, uint32_t flags, uint32_t exptime, uint64_t cas_value);\\nbool Delete(const Slice& key);\\nbool Flush(uint32_t timeout);\\nbool Increment(const Slice& key, uint64_t delta, uint64_t initial_value, uint32_t exptime);\\nbool Decrement(const Slice& key, uint64_t delta, uint64_t initial_value, uint32_t exptime);\\nbool Touch(const Slice& key, uint32_t exptime);\\nbool Version();\n```\n\n----------------------------------------\n\nTITLE: Example of Updated Server List for Partition Migration (text config)\nDESCRIPTION: Expanded server_list configuration demonstrating simultaneous presence of original 3-partition and new 4-partition topologies. This configuration is used to demonstrate live partition migration: each partition is mapped to one or more servers, and the client adapts as this file changes. Useful during staged cutovers and scalable deployments.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n0.0.0.0:8004  0/3\n0.0.0.0:8004  1/3   \n0.0.0.0:8004  2/3 \n \n0.0.0.0:8005  0/4        \n0.0.0.0:8005  1/4        \n0.0.0.0:8005  2/4        \n0.0.0.0:8005  3/4\n```\n\n----------------------------------------\n\nTITLE: Batch Executing Redis Commands with brpc in C++\nDESCRIPTION: Shows how to send multiple commands (INCR, DECR, INCRBY, DECRBY) in a single RedisRequest using brpc, handle the composite response, and verify correctness by comparing reply values. Designed to demonstrate batch processing and reply sequence guarantees, this requires a connected redis_channel and checks all expected response types and values with assertions.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::RedisRequest request;\nbrpc::RedisResponse response;\nbrpc::Controller cntl;\nrequest.AddCommand(\"INCR counter1\");\nrequest.AddCommand(\"DECR counter1\");\nrequest.AddCommand(\"INCRBY counter1 10\");\nrequest.AddCommand(\"DECRBY counter1 20\");\nredis_channel.CallMethod(NULL, &cntl, &request, &response, NULL/*done*/);\nif (cntl.Failed()) {\n    LOG(ERROR) << \"Fail to access redis-server\";\n    return -1;\n}\nCHECK_EQ(4, response.reply_size());\nfor (int i = 0; i < 4; ++i) {\n    CHECK(response.reply(i).is_integer());\n    CHECK_EQ(brpc::REDIS_REPLY_INTEGER, response.reply(i).type());\n}\nCHECK_EQ(1, response.reply(0).integer());\nCHECK_EQ(0, response.reply(1).integer());\nCHECK_EQ(10, response.reply(2).integer());\nCHECK_EQ(-10, response.reply(3).integer());\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Latency Recorder in C++ for brpc\nDESCRIPTION: This snippet demonstrates how to add a custom latency recorder in C++ for brpc. It includes the necessary headers, creates a LatencyRecorder object, and shows how to record the elapsed time of a function call. The recorded data will be displayed in /vars with various counters.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/backup_request.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <butil/time.h>\n...\nbvar::LatencyRecorder my_func_latency(\"my_func\");\n...\nbutil::Timer tm;\ntm.start();\nmy_func();\ntm.stop();\nmy_func_latency << tm.u_elapsed();  // u代表微秒，还有s_elapsed(), m_elapsed(), n_elapsed()分别对应秒，毫秒，纳秒。\n\n// 好了，在/vars中会显示my_func_qps, my_func_latency, my_func_latency_cdf等很多计数器。\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting HTTP Headers in brpc\nDESCRIPTION: Shows how to access and set HTTP request headers. Headers are accessed through GetHeader() and set with SetHeader(). Header field names are case-insensitive according to HTTP standards.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nconst std::string* value = cntl->http_request().GetHeader(\"Foo\"); //不存在为NULL\n```\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().SetHeader(\"Foo\", \"value\");\n```\n\n----------------------------------------\n\nTITLE: Declaring Multi-Method Service for Custom URL Mapping - Protobuf\nDESCRIPTION: This proto snippet declares a service ('QueueService') with multiple methods suitable for mapping to various URLs via brpc's restful mapping string. Each method uses empty requests/responses, meaning all logic and data flow through the brpc Controller object. This structure enables the service to be flexibly attached to multiple endpoints as demonstrated in the C++ AddService code. Dependencies: protobuf and brpc tools.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_5\n\nLANGUAGE: protobuf\nCODE:\n```\nservice QueueService {\\n    rpc start(HttpRequest) returns (HttpResponse);\\n    rpc stop(HttpRequest) returns (HttpResponse);\\n    rpc get_stats(HttpRequest) returns (HttpResponse);\\n    rpc download_data(HttpRequest) returns (HttpResponse);\\n};\n```\n\n----------------------------------------\n\nTITLE: Building brpc with Docker\nDESCRIPTION: Commands for building and running brpc in a Docker container, which provides an isolated and consistent environment for development or deployment.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir -p ~/brpc\n$ cd ~/brpc\n$ git clone https://github.com/apache/brpc.git\n$ cd brpc\n$ docker build -t brpc:master .\n$ docker images\n$ docker run -it brpc:master /bin/bash\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for brpc on MacOS\nDESCRIPTION: Command for installing required dependencies for building brpc on MacOS using Homebrew package manager.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\nbrew install ./homebrew-formula/protobuf.rb\nbrew install openssl git gnu-getopt coreutils gflags leveldb\n```\n\n----------------------------------------\n\nTITLE: ModifyRequest Implementation of CallMapper for brpc ParallelChannel\nDESCRIPTION: Implementation of CallMapper that modifies the request before sending it to each sub channel, with memory management for copied requests.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\n  class ModifyRequest : public CallMapper {\n  public:\n    SubCall Map(int channel_index/*starting from 0*/,\n                const google::protobuf::MethodDescriptor* method,\n                const google::protobuf::Message* request,\n                google::protobuf::Message* response) {\n        FooRequest* copied_req = brpc::Clone<FooRequest>(request);\n        copied_req->set_xxx(...);\n        // Copy and modify the request\n        // The last flag tells pchan to delete the request and response after completion of the RPC\n        return SubCall(method, copied_req, response->New(), DELETE_REQUEST | DELETE_RESPONSE);\n    }\n  };\n```\n\n----------------------------------------\n\nTITLE: Setting gRPC Protocol for HTTP/2 in ChannelOptions\nDESCRIPTION: Illustrates how to set the gRPC protocol for HTTP/2 requests in ChannelOptions. This is the default protocol for gRPC and uses Protocol Buffers serialization.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_derivatives.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nh2:grpc\n```\n\n----------------------------------------\n\nTITLE: Accessing HTTP Header in brpc Controller - C++\nDESCRIPTION: Shows how to retrieve the value of an HTTP header named 'Foo' from a brpc::Controller's http_request. Returns a pointer to a std::string if found, or NULL otherwise. Dependency: brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nconst std::string* value = cntl->http_request().GetHeader(\"Foo\"); // NULL when not exist\n```\n\n----------------------------------------\n\nTITLE: Creating and Initializing bthread-key for Thread-Local Data (C++)\nDESCRIPTION: This C++ snippet shows how to define a destructor function and initialize a bthread_key_t for associating per-thread data in the brpc framework. On success, the key can be used with bthread_setspecific and bthread_getspecific. Initialization failure is logged and aborts the process. Used as a setup pattern before allocating or retrieving bthread-local objects.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\nstatic void my_data_destructor(void* data) {\n    ...\n}\n\nbthread_key_t tls_key;\n\nif (bthread_key_create(&tls_key, my_data_destructor) != 0) {\n    LOG(ERROR) << \"Fail to create tls_key\";\n    return -1;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running brpc Echo Example with CMake\nDESCRIPTION: Commands for building and running the Echo server and client example using CMake build system.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ cd example/echo_c++\n$ cmake -B build && cmake --build build -j4\n$ ./echo_server &\n$ ./echo_client\n```\n\n----------------------------------------\n\nTITLE: Registering Service with Custom RESTful Mappings - brpc API - C++\nDESCRIPTION: Demonstrates using brpc's AddService API to register a service with custom RESTful URL patterns, allowing methods to be accessed through arbitrary HTTP paths instead of /ServiceName/MethodName. Provides examples with star-matching for dynamic routing. Shows usage of butil::StringPiece for mapping strings, and notes that mappings are comma-separated in a single string argument. An error is logged if the service fails to register.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nif (server.AddService(&queue_svc,\\n                      brpc::SERVER_DOESNT_OWN_SERVICE,\\n                      \"/v1/queue/start   => start,\"\\n                      \"/v1/queue/stop    => stop,\"\\n                      \"/v1/queue/stats/* => get_stats\") != 0) {\\n    LOG(ERROR) << \"Fail to add queue_svc\";\\n    return -1;\\n}\\n \\n// \\u661f\\u53f7\\u53ef\\u51fa\\u73b0\\u5728\\u4e2d\\u95f4\\nif (server.AddService(&queue_svc,\\n                      brpc::SERVER_DOESNT_OWN_SERVICE,\\n                      \"/v1/*/start   => start,\"\\n                      \"/v1/*/stop    => stop,\"\\n                      \"*.data        => download_data\") != 0) {\\n    LOG(ERROR) << \"Fail to add queue_svc\";\\n    return -1;\\n}\n```\n\n----------------------------------------\n\nTITLE: Setting JSON Protocol for HTTP in ChannelOptions\nDESCRIPTION: Demonstrates how to set the JSON protocol for HTTP requests in ChannelOptions. This is the default behavior for HTTP/1.x.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_derivatives.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhttp:json\n```\n\n----------------------------------------\n\nTITLE: Using expose_as Method for Namespacing MultiDimension mbvar in bvar (C++)\nDESCRIPTION: This code snippet shows the expose_as method on an mbvar object to globally register a MultiDimension variable with a namespace-prefixed name. This avoids variable name collisions in larger projects. Dependencies are bvar and multi_dimension headers. The class explicitly accepts a prefix and a variable name, as shown in the provided interface comment. All exposed variables become accessible via global monitoring tools and dumpers.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nclass MVariable {\\npublic\\n    ...\\n    // Expose this mvariable with a prefix.\\n    // Example:\\n    //   namespace foo {\\n    //   namespace bar {\\n    //\\n    //      bvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\\n    //      g_request_count.expose_as(\"foo_bar\", \"request_count\");\\n    //      ...\\n    //\\n    //   }  // foo\\n    //   }  // bar\\n    int expose_as(const base::StringPiece& prefix, const base::StringPiece& name);\\n};\n```\n\n----------------------------------------\n\nTITLE: Printing Client-side Address and Port with brpc::Controller in C++\nDESCRIPTION: Retrieves the client-side (local) address and port used for a brpc RPC after its completion by calling local_side() on the Controller. The code logs and prints the network endpoint, using butil::endpoint2str for formatting. Only valid for completed RPCs; requires brpc and butil to be available.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_16\n\nLANGUAGE: c++\nCODE:\n```\nLOG(INFO) << \"local_side=\" << cntl->local_side();\nprintf(\"local_side=%s\\n\", butil::endpoint2str(cntl->local_side()).c_str());\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom PartitionParser for PartitionChannel - brpc - C++\nDESCRIPTION: Defines a custom subclass MyPartitionParser of brpc::PartitionParser to interpret partition tags of the form N/M. The ParseFromTag method splits the tag, extracts the partition index and total count, and validates the format. This is necessary for PartitionChannel's automatic partitioning. Dependency: brpc (header \\\"<brpc/partition_channel.h>\\\"), logging macros, and butil::StringPiece. Input is a tag string (e.g., '0/3'), output is a populated brpc::Partition structure or error log. Handles errors in tag parsing, ensuring proper partition configuration.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/partition_channel.h>\n...\nclass MyPartitionParser : public brpc::PartitionParser {\npublic:\n    bool ParseFromTag(const std::string& tag, brpc::Partition* out) {\n        // \"N/M\" : #N partition of M partitions.\n        size_t pos = tag.find_first_of('/');\n        if (pos == std::string::npos) {\n            LOG(ERROR) << \"Invalid tag=\" << tag;\n            return false;\n        }\n        char* endptr = NULL;\n        out->index = strtol(tag.c_str(), &endptr, 10);\n        if (endptr != tag.data() + pos) {\n            LOG(ERROR) << \"Invalid index=\" << butil::StringPiece(tag.data(), pos);\n            return false;\n        }\n        out->num_partition_kinds = strtol(tag.c_str() + pos + 1, &endptr, 10);\n        if (endptr != tag.c_str() + tag.size()) {\n            LOG(ERROR) << \"Invalid num=\" << tag.data() + pos + 1;\n            return false;\n        }\n        return true;\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Building gflags with Shared and Static Libraries\nDESCRIPTION: Commands for building gflags with both shared and static libraries enabled, which is required for building brpc with self-built dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n$ cmake . -DBUILD_SHARED_LIBS=1 -DBUILD_STATIC_LIBS=1\n$ make\n```\n\n----------------------------------------\n\nTITLE: Setting Content-Type for HTTP Request in brpc Controller - C++\nDESCRIPTION: Defines the Content-Type HTTP header for the outgoing request using brpc::Controller. Necessary for sending correct metadata with POST/PUT requests. Dependency: brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().set_content_type(\"text/plain\");\n```\n\n----------------------------------------\n\nTITLE: Using bvar::PassiveStatus with Callback for On-Demand Metrics - C++\nDESCRIPTION: This pair of snippets shows how to declare a bvar::PassiveStatus that uses a callback for on-demand metrics. The code demonstrates both simple and more advanced usage, such as fetching the username on display by passing a function that writes to a stream. Dependencies are bvar, appropriate callback definitions, and possibly POSIX for getlogin_r. Inputs include a function pointer and optional arguments; output is generated by the callback each time status is requested.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\n// Display a updated-by-need value. This is done by passing in an user callback\n// which is called to produce the value.\n// Example:\n//   int print_number(void* arg) {\n//      ...\n//      return 5;\n//   }\n//\n//   // number1 : 5\n//   bvar::PassiveStatus status1(\"number1\", print_number, arg);\n//\n//   // foo_number2 : 5\n//   bvar::PassiveStatus status2(typeid(Foo), \"number2\", print_number, arg);\ntemplate <typename Tp>\nclass PassiveStatus : public Variable;\n```\n\nLANGUAGE: C++\nCODE:\n```\nstatic void get_username(std::ostream& os, void*) {\n    char buf[32];\n    if (getlogin_r(buf, sizeof(buf)) == 0) {\n        buf[sizeof(buf)-1] = '\\0';\n        os << buf;\n    } else {\n        os << \"unknown\";\n    }\n}\nPassiveStatus<std::string> g_username(\"process_username\", get_username, NULL);\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting Content-Type in HTTP Requests/Responses - C++\nDESCRIPTION: Illustrates special handling for Content-Type headers in brpc. Shows correct usage for retrieving request Content-Type via content_type(), and setting the response Content-Type via set_content_type(). Standard GetHeader() does not work for Content-Type. On service failure, brpc overrides Content-Type to text/plain and outputs error text. Relies on brpc Controller methods.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n// Get Content-Type\\nif (cntl->http_request().content_type() == \"application/json\") {\\n    ...\\n}\\n...\\n// Set Content-Type\\ncntl->http_response().set_content_type(\"text/html\");\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Types in brpc (C++)\nDESCRIPTION: Declares an enum listing all supported protocol identifiers for brpc, including both server and client-side protocols. This list, maintained within options.proto, ensures unique, centralized protocol registration and lookup across the framework. New entries should be coordinated with the core team to prevent conflicts; changes here drive protocol handling and option parsing at runtime.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nenum ProtocolType {\n    PROTOCOL_UNKNOWN = 0;\n    PROTOCOL_BAIDU_STD = 1;\n    PROTOCOL_STREAMING_RPC = 2;\n    PROTOCOL_HULU_PBRPC = 3;\n    PROTOCOL_SOFA_PBRPC = 4;\n    PROTOCOL_RTMP = 5;\n    PROTOCOL_HTTP = 6;\n    PROTOCOL_PUBLIC_PBRPC = 7;\n    PROTOCOL_NOVA_PBRPC = 8;\n    PROTOCOL_NSHEAD_CLIENT = 9;        // implemented in brpc-ub\n    PROTOCOL_NSHEAD = 10;\n    PROTOCOL_HADOOP_RPC = 11;\n    PROTOCOL_HADOOP_SERVER_RPC = 12;\n    PROTOCOL_MONGO = 13;               // server side only\n    PROTOCOL_UBRPC_COMPACK = 14;\n    PROTOCOL_DIDX_CLIENT = 15;         // Client side only\n    PROTOCOL_REDIS = 16;               // Client side only\n    PROTOCOL_MEMCACHE = 17;            // Client side only\n    PROTOCOL_ITP = 18;\n    PROTOCOL_NSHEAD_MCPACK = 19;\n    PROTOCOL_DISP_IDL = 20;            // Client side only\n    PROTOCOL_ERSDA_CLIENT = 21;        // Client side only\n    PROTOCOL_UBRPC_MCPACK2 = 22;       // Client side only\n    // Reserve special protocol for cds-agent, which depends on FIFO right now\n    PROTOCOL_CDS_AGENT = 23;           // Client side only\n    PROTOCOL_ESP = 24;                 // Client side only\n    PROTOCOL_THRIFT = 25;              // Server side only\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Multi-Dimensional Metric Variable with Prefix and Name in bvar (C++)\nDESCRIPTION: Demonstrates how to define a multi-dimensional metric variable with both a prefix and a name using bvar. The variable is registered globally and configured to expose itself under a hierarchical name. It will participate in periodic dumps if so configured. Usage is recommended for clearer metric organization.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"foo_bar\", \"request_count\", {\"idc\", \"method\", \"status\"});\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Starting Echo Servers in Apache brpc (Bash)\nDESCRIPTION: This command launches three instances of the echo_server binary, each serving on different ports (8004, 8005, 8006). The output includes trace logs showing active ports and traffic summaries. This setup is required as a prerequisite for migration demonstrations, and assumes echo_server is built and executable. The -server_num argument specifies the number of servers to start.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ ./echo_server -server_num 3\nTRACE: 09-06 10:40:39:   * 0 server.cpp:159] EchoServer is serving on port=8004\nTRACE: 09-06 10:40:39:   * 0 server.cpp:159] EchoServer is serving on port=8005\nTRACE: 09-06 10:40:39:   * 0 server.cpp:159] EchoServer is serving on port=8006\nTRACE: 09-06 10:40:40:   * 0 server.cpp:192] S[0]=0 S[1]=0 S[2]=0 [total=0]\nTRACE: 09-06 10:40:41:   * 0 server.cpp:192] S[0]=0 S[1]=0 S[2]=0 [total=0]\nTRACE: 09-06 10:40:42:   * 0 server.cpp:192] S[0]=0 S[1]=0 S[2]=0 [total=0]\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Dimensional Metrics Constructors with bvar in C++\nDESCRIPTION: This snippet defines the MultiDimension template class for multi-dimensional metrics and documents its three different constructors. The constructors determine whether the metric will be registered globally, exposed, and included in dump files. The names, prefixes, and labels provided as arguments define how the metric is tracked and exposed. The code provides context for using each constructor appropriately and lists limitations regarding metric exposure and persistence.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\ntemplate <typename T>\nclass MultiDimension : public MVariable {\npublic:\n    // \\u4e0d\\u5efa\\u8bae\\u4f7f\\u7528\n    explicit MultiDimension(const key_type& labels);\n\n    // \\u63a8\\u8350\\u4f7f\\u7528\n    MultiDimension(const base::StringPiece& name,\n                   const key_type& labels);\n    // \\u63a8\\u8350\\u4f7f\\u7528\n    MultiDimension(const base::StringPiece& prefix,\n                   const base::StringPiece& name,\n                   const key_type& labels);\n    ...\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Thrift and Compiling on Linux - Bash\nDESCRIPTION: This snippet demonstrates the steps to download, extract, configure, compile, and install the Thrift library from source in a Linux environment. Required dependencies must be installed as per Thrift documentation. After downloading and extracting the tarball, it disables bindings for multiple languages and builds the package with specific CXXFLAGS and CPPFLAGS. Output is the installed Thrift library in the /usr directory. Requires sudo privileges for final installation.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/thrift.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://downloads.apache.org/thrift/0.18.1/thrift-0.18.1.tar.gz\\ntar -xf thrift-0.18.1.tar.gz\\ncd thrift-0.18.1/\\n./bootstrap.sh\\n./configure --prefix=/usr --with-ruby=no --with-python=no --with-java=no --with-go=no --with-perl=no --with-php=no --with-csharp=no --with-erlang=no --with-lua=no --with-nodejs=no --with-rs=no --with-py3=no CXXFLAGS='-Wno-error'\\nmake CPPFLAGS=-DFORCE_BOOST_SMART_PTR -j 4 -s\\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Basic Logging Macros in C++\nDESCRIPTION: Demonstrates the basic usage of logging macros in brpc, including different log levels and the PLOG macro for error logging.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_log.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <butil/logging.h>\n\nLOG(FATAL) << \"Fatal error occurred! contexts=\" << ...;\nLOG(WARNING) << \"Unusual thing happened ...\" << ...;\nLOG(TRACE) << \"Something just took place...\" << ...;\nLOG(TRACE) << \"Items:\" << noflush;\nLOG_IF(NOTICE, n > 10) << \"This log will only be printed when n > 10\";\nPLOG(FATAL) << \"Fail to call function setting errno\";\nVLOG(1) << \"verbose log tier 1\";\nCHECK_GT(1, 2) << \"1 can't be greater than 2\";\n```\n\n----------------------------------------\n\nTITLE: Alternative CMake Build Command for brpc\nDESCRIPTION: Alternative command for building brpc with CMake 3.13+ using the -B flag to specify the build directory.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ncmake -B build && cmake --build build -j6\n```\n\n----------------------------------------\n\nTITLE: Decompressing Gzipped HTTP Request Bodies in brpc - C++\nDESCRIPTION: Shows how to manually handle gzip-compressed HTTP request bodies using brpc and 'brpc::policy::GzipDecompress'. Checks for the 'Content-Encoding: gzip' header, decompresses the body, and swaps in the decompressed data. Requires brpc and brpc/policy/gzip_compress.h. Logs errors if decompression fails. Expects 'cntl' to be a valid Controller.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/policy/gzip_compress.h>\n...\nconst std::string* encoding = cntl->http_request().GetHeader(\"Content-Encoding\");\nif (encoding != NULL && *encoding == \"gzip\") {\n    butil::IOBuf uncompressed;\n    if (!brpc::policy::GzipDecompress(cntl->request_attachment(), &uncompressed)) {\n        LOG(ERROR) << \"Fail to un-gzip request body\";\n        return;\n    }\n    cntl->request_attachment().swap(uncompressed);\n}\n// cntl->request_attachment() contains the data after decompression\n```\n\n----------------------------------------\n\nTITLE: Using Controller.NotifyOnCancel() for Connection Monitoring in brpc\nDESCRIPTION: This code snippet shows how to use Controller.NotifyOnCancel() on the server side to be notified when a client connection is disconnected, allowing the server to clean up unused done objects.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/server_push.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nController.NotifyOnCancel()\n```\n\n----------------------------------------\n\nTITLE: Defining bvar Variables in C++\nDESCRIPTION: Demonstrates how to define different types of bvar variables including Adder, Window, LatencyRecorder, and PerSecond. Shows proper naming conventions with prefix and monitor name parameters.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n\nnamespace foo {\nnamespace bar {\n\n// bvar::Adder<T> used for running sum, we define a Adder for read_error as below\nbvar::Adder<int> g_read_error;\n\n// put another bvar inside window so that we can get the value over this period of time\nbvar::Window<bvar::Adder<int> > g_read_error_minute(\"foo_bar\", \"read_error\", &g_read_error, 60);\n//                                                     ^          ^                         ^\n//                                                    prefix1     monitor name             time window, 10 by default\n\n// bvar::LatencyRecorder is a compound varibale, can be used for troughput、qps、avg latency, latency percentile, max latency。\nbvar::LatencyRecorder g_write_latency(\"foo_bar\", \"write\");\n//                                      ^          ^\n//                                     prefix1      monitor entry, LatencyRecorder includes different bvar, and expose() will add the suffix for them by default, such as write_qps, write_latency etc\n\n// define a varible for the # of 'been-pushed task'\nbvar::Adder<int> g_task_pushed(\"foo_bar\", \"task_pushed\");\n// put nested bvar into PerSecond so that we can get the value per second within this time window. Over here what we get is the # of tasks pushed per second\nbvar::PerSecond<bvar::Adder<int> > g_task_pushed_second(\"foo_bar\", \"task_pushed_second\", &g_task_pushed);\n//       ^                                                                                             ^\n//    different from Window, PerSecond will be divided by the time winodw.                            time window is the last param, we omit here, its 10 by default\n\n}  // bar\n}  // foo\n```\n\n----------------------------------------\n\nTITLE: Initializing PartitionChannel with Custom PartitionParser - brpc - C++\nDESCRIPTION: Sets up a PartitionChannel in brpc using a custom PartitionParser, with specific options for protocol, timeout, and fail_limit. Demonstrates how to link the parser, server address, load balancer, and option structure for partitioned RPC routing. Required dependencies are brpc/partition_channel.h, an integer num_partition_kinds, the parser instance, a valid server address, and a load balancer string. The input includes partition count and settings; output is initialization success/failure (0/-1). Fail_limit controls channel-level failure policy, mirroring ParallelChannel semantics.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/partition_channel.h>\n...\nbrpc::PartitionChannel channel;\n \nbrpc::PartitionChannelOptions options;\noptions.protocol = ...;   // PartitionChannelOptions inherits ChannelOptions\noptions.timeout_ms = ...; // Same as above\noptions.fail_limit = 1;   // PartitionChannel's own settting, which means the same as that of\n                          // ParalellChannel. fail_limit=1 means the overall RPC will fail \n                          // as long as only 1 paratition fails\n \nif (channel.Init(num_partition_kinds, new MyPartitionParser(),\n                 server_address, load_balancer, &options) != 0) {\n    LOG(ERROR) << \"Fail to init PartitionChannel\";\n    return -1;\n}\n// The RPC interface is the same as regular Channel\n```\n\n----------------------------------------\n\nTITLE: Demonstrating CHECK Macros in C++\nDESCRIPTION: This snippet shows the usage of CHECK_LT and CHECK_GT macros for comparing values. It demonstrates how these macros behave when the conditions are true or false, including the output of error messages.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_log.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nCHECK_LT(1, 2) << \"This is definitely true, this log will never be seen\";\nCHECK_GT(1, 2) << \"1 can't be greater than 2\";\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for RPC Echo Example in C++\nDESCRIPTION: Sets up the CMake project for the RPC echo example, specifying minimum CMake version and project name. It also defines an option for dynamic linking.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rpcz_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(rpcz_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc with Multiple Dependencies in One Directory\nDESCRIPTION: Example showing how to build brpc when all dependencies are in the same parent directory, using config_brpc.sh to recursively search for headers and libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n$ ls my_dev\ngflags_dev protobuf_dev leveldb_dev brpc_dev\n$ cd brpc_dev\n$ sh config_brpc.sh --headers=.. --libs=..\n$ make\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Threaded Echo Example with CMake in CMake Language\nDESCRIPTION: This CMake script sets up the build process for both client and server executables for a multi-threaded echo example using C++. It searches for key dependencies (brpc, Protobuf, LevelDB, GFlags, gperftools, Thrift if enabled, OpenSSL), configures platform-specific compiler and linker flags (including macOS compatibility for clock_gettime and OpenSSL), and generates C++ protobuf sources. The targets are linked with found libraries, and the script ensures the build will fail with clear errors if dependencies are missing. Inputs include the source files and environment variables, while outputs are two executables ready for use; it requires CMake 2.8.10+, a C++11-capable compiler, and installed dependencies as specified.\nSOURCE: https://github.com/apache/brpc/blob/master/example/multi_threaded_echo_fns_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\ncmake_minimum_required(VERSION 2.8.10)\nproject(multi_threaded_echo_fns_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \".*output/include$\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(GPERFTOOLS_INCLUDE_DIR NAMES gperftools/heap-profiler.h)\nfind_library(GPERFTOOLS_LIBRARIES NAMES tcmalloc_and_profiler)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(multi_threaded_echo_fns_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(multi_threaded_echo_fns_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(multi_threaded_echo_fns_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(multi_threaded_echo_fns_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n\n```\n\n----------------------------------------\n\nTITLE: Semi-synchronous RPC Calls in C++\nDESCRIPTION: Shows how to implement semi-synchronous RPC calls by waiting for multiple asynchronous calls to complete using Join() and DoNothing().\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl1;\nbrpc::Controller cntl2;\nMyResponse response1;\nMyResponse response2;\n...\nstub1.method1(&cntl1, &request1, &response1, brpc::DoNothing());\nstub2.method2(&cntl2, &request2, &response2, brpc::DoNothing());\n...\nbrpc::Join(cntl1.call_id());\nbrpc::Join(cntl2.call_id());\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Libraries for RPC Echo Example in CMake\nDESCRIPTION: Sets up the list of dynamic libraries to be linked with the executables. Includes system-specific libraries for Darwin (macOS).\nSOURCE: https://github.com/apache/brpc/blob/master/example/rpcz_echo_c++/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Fuzzing Tests for brpc\nDESCRIPTION: Conditionally builds fuzzing test targets when BUILD_FUZZ_TESTS is enabled. Creates a static debug library, configures the output directory, and builds multiple fuzz targets with appropriate dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(BUILD_FUZZ_TESTS)\n    add_library(brpc-static-debug STATIC $<TARGET_OBJECTS:BUTIL_DEBUG_LIB>\n                                        $<TARGET_OBJECTS:SOURCES_DEBUG_LIB>\n                                        $<TARGET_OBJECTS:PROTO_LIB>)\n    # change the debug lib output dir to be different from the release output\n    set_target_properties(brpc-static-debug PROPERTIES\n            LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/test)\n\n    target_link_libraries(brpc-static-debug ${DYNAMIC_LIB})\n    if(BRPC_WITH_GLOG)\n        target_link_libraries(brpc-static-debug ${GLOG_LIB})\n    endif()\n\n    set(FUZZ_TARGETS fuzz_butil fuzz_esp fuzz_hpack fuzz_http\n        fuzz_hulu fuzz_json fuzz_redis fuzz_shead fuzz_sofa fuzz_uri)\n\n    foreach(target ${FUZZ_TARGETS})\n        add_executable(${target} fuzzing/${target}.cpp $<TARGET_OBJECTS:TEST_PROTO_LIB>)\n        target_link_libraries(${target} brpc-static-debug ${LIB_FUZZING_ENGINE})\n        set_target_properties(${target} PROPERTIES\n            BUILD_WITH_INSTALL_RPATH TRUE\n            INSTALL_RPATH \"$ORIGIN/lib\")\n    endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Using UBRawBufferRequest with brpc\nDESCRIPTION: Alternative approach using UBRawBufferRequest and UBRawBufferResponse from baidu-rpc-ub to access legacy servers. The example shows how to initialize the channel with PROTOCOL_NSHEAD_CLIENT, create and use reusable raw buffers, and construct request/response objects.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/ub_client.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Channel channel;\nbrpc::ChannelOptions opt;\nopt.protocol = brpc::PROTOCOL_NSHEAD_CLIENT; // or \"nshead_client\"\nif (channel.Init(..., &opt) != 0) {\n    LOG(ERROR) << \"Fail to init channel\";\n    return -1;\n}\n...\n \n// 构造RawBuffer，一次RPC结束后RawBuffer可以复用，类似于bsl::mempool\nconst int BUFSIZE = 10 * 1024 * 1024;\nbrpc::RawBuffer req_buf(BUFSIZE);\nbrpc::RawBuffer res_buf(BUFSIZE);\n \n// 传入RawBuffer来构造request和response\nbrpc::UBRawBufferRequest request(&req_buf);\nbrpc::UBRawBufferResponse response(&res_buf);\n         \n// Append message to `request'\nrequest.append(\"hello world\");\n// Set fields of the request nshead struct if needed\nrequest.mutable_nshead()->version = 99;\n \nbrpc::Controller cntl;\nchannel.CallMethod(NULL, &cntl, &request, &response, NULL);    // 假设channel已经通过之前所述方法Init成功\n \n// Process response. response.data() is the buffer, response.size() is the length.\n```\n\n----------------------------------------\n\nTITLE: Decompressing HTTP Response Body in brpc\nDESCRIPTION: Demonstrates how to manually decompress a gzipped HTTP response body. brpc doesn't automatically decompress responses, so users need to check the Content-Encoding header and decompress accordingly.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_12\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/policy/gzip_compress.h>\n...\nconst std::string* encoding = cntl->http_response().GetHeader(\"Content-Encoding\");\nif (encoding != NULL && *encoding == \"gzip\") {\n    butil::IOBuf uncompressed;\n    if (!brpc::policy::GzipDecompress(cntl->response_attachment(), &uncompressed)) {\n        LOG(ERROR) << \"Fail to un-gzip response body\";\n        return;\n    }\n    cntl->response_attachment().swap(uncompressed);\n}\n// cntl->response_attachment()中已经是解压后的数据了\n```\n\n----------------------------------------\n\nTITLE: Managing Content-Type Header in brpc - C++\nDESCRIPTION: Shows how to get and set the 'Content-Type' header in HTTP requests and responses using brpc. Content-Type is accessed via dedicated methods ('content_type()', 'set_content_type()'), and is specially processed by the framework. If a failure is set on the Controller, brpc overrides Content-Type to 'text/plain' automatically. Dependencies: brpc, an active Controller.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n// Get Content-Type\nif (cntl->http_request().content_type() == \"application/json\") {\n    ...\n}\n...\n// Set Content-Type\ncntl->http_response().set_content_type(\"text/html\");\n```\n\n----------------------------------------\n\nTITLE: Finding gflags Library for Command-line Parsing\nDESCRIPTION: Searches for gflags headers and library, which is required for command-line argument parsing. Fails with an error if gflags cannot be found.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc with RDMA using config_brpc script\nDESCRIPTION: Commands to compile brpc with RDMA support using the config_brpc.sh script. This method configures RDMA by specifying header and library paths, then builds the main library and example program.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/rdma.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsh config_brpc.sh --with-rdma --headers=\"/usr/include\" --libs=\"/usr/lib64 /usr/bin\"\nmake\n\ncd example/rdma_performance  # 示例程序\nmake\n```\n\n----------------------------------------\n\nTITLE: Setting a Value in Memcached with brpc in C++\nDESCRIPTION: Illustrates how to perform a SET operation against a memcached server using the brpc C++ API, including error handling. This snippet requires brpc and assumes an initialized 'channel'. It builds a MemcacheRequest with a Set operation (key=\"hello\", value=\"world\", flags, expiration, cas ignored), executes the RPC, and validates both RPC and logical results using PopSet. Failure in any step logs a fatal error and aborts. Key parameters include key, value, flags, expiration, and cas token.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/memcache_client.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n// Set key=\"hello\" value=\"world\" flags=0xdeadbeef, expire in 10s, and ignore cas\\nbrpc::MemcacheRequest request;\\nbrpc::MemcacheResponse response;\\nbrpc::Controller cntl;\\nif (!request.Set(\"hello\", \"world\", 0xdeadbeef/*flags*/, 10/*expiring seconds*/, 0/*ignore cas*/)) {\\n    LOG(FATAL) << \"Fail to SET request\";\\n    return -1;\\n} \\nchannel.CallMethod(NULL, &cntl, &request, &response, NULL/*done*/);\\nif (cntl.Failed()) {\\n    LOG(FATAL) << \"Fail to access memcached, \" << cntl.ErrorText();\\n    return -1;\\n}  \\nif (!response.PopSet(NULL)) {\\n    LOG(FATAL) << \"Fail to SET memcached, \" << response.LastError();\\n    return -1;   \\n}\\n...\n```\n\n----------------------------------------\n\nTITLE: Client-side Access to Thrift Server in C++\nDESCRIPTION: C++ code snippet demonstrating how to create a Channel with PROTOCOL_THRIFT, initialize a ThriftStub, and make a call to a Thrift server using brpc. This example shows the basic steps for client-side Thrift communication.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/thrift.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/channel.h>\n#include <brpc/thrift_message.h>         // 定义了ThriftStub\n...\n\nDEFINE_string(server, \"0.0.0.0:8019\", \"IP Address of thrift server\");\nDEFINE_string(load_balancer, \"\", \"The algorithm for load balancing\");\n...  \n\nbrpc::ChannelOptions options;\noptions.protocol = brpc::PROTOCOL_THRIFT;\nbrpc::Channel thrift_channel;\nif (thrift_channel.Init(Flags_server.c_str(), FLAGS_load_balancer.c_str(), &options) != 0) {\n   LOG(ERROR) << \"Fail to initialize thrift channel\";\n   return -1;\n}\n\nbrpc::ThriftStub stub(&thrift_channel);\n...\n\n// example::[EchoRequest/EchoResponse]是thrift生成的消息\nexample::EchoRequest req;\nexample::EchoResponse res;\nreq.data = \"hello\";\n\nstub.CallMethod(\"Echo\", &cntl, &req, &res, NULL);\n\nif (cntl.Failed()) {\n    LOG(ERROR) << \"Fail to send thrift request, \" << cntl.ErrorText();\n    return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using bvar::Maxer to Track Maximum Value in Multi-Dimensional Metrics (C++)\nDESCRIPTION: Illustrates the use of bvar::Maxer<int> within a multi-dimensional metric to track the maximum value assigned for a specific label. The metric is updated with several values and queried for the current maximum. The design ensures safety only while the parent metric exists. This pattern is suitable for max statistics in metric tracking.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_15\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Maxer<int> > g_request_cost(\"request_cost\", {\"idc\", \"method\", \"status\"});\n\nint request_cost_max(const std::list<std::string>& request_labels) {\n    // \\u83b7\\u53d6request\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6mbvar\\u6307\\u9488\\uff0c\\u5047\\u8bberequest_labels = {\"tc\", \"get\", \"200\"}\n    bvar::Maxer<int>* cost_max = g_request_cost.get_stats(request_labels);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!cost_max) {\n        return -1;\n    }\n\n    // cost_max\\u53ea\\u80fd\\u5728g_request_cost\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\n    *cost_max << 1 << 2 << 3 << 4;\n    CHECK_EQ(4, cost_max->get_value());\n    return cost_max->get_value();\n}\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries to HTTP Example Targets\nDESCRIPTION: Links the previously collected libraries to the HTTP example executables, including brpc, dynamic libraries, and gperftools for profiling.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(http_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(http_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(benchmark_http ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n```\n\n----------------------------------------\n\nTITLE: Installing and Building Google Test for Running brpc Tests on Ubuntu\nDESCRIPTION: Commands for installing and compiling Google Test framework for running brpc unit tests on Ubuntu-based systems.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get install -y cmake libgtest-dev && cd /usr/src/gtest && sudo cmake . && sudo make && sudo mv lib/libgtest* /usr/lib/ && cd -\n```\n\n----------------------------------------\n\nTITLE: Inline Stub Creation for RPC Method Call in brpc\nDESCRIPTION: Alternative approach for creating and using a stub in a single line. This approach creates a temporary stub object that is automatically destroyed after the method call.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\nXXX_Stub(&channel).some_method(controller, request, response, done);\n```\n\n----------------------------------------\n\nTITLE: Changing HTTP Protocol Version in brpc Controller - C++\nDESCRIPTION: Sets HTTP/1.0 version for a request through brpc::Controller to interface with legacy HTTP servers. This setting disables HTTP KeepAlive, as expected in HTTP/1.0. Only effective for non-h2 channels. Requires brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\ncntl.http_request().set_version(1, 0);\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc using CMake\nDESCRIPTION: Commands to build brpc using CMake build system.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/getting_started.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmkdir build && cd build && cmake .. && cmake --build . -j6\n```\n\n----------------------------------------\n\nTITLE: Running brpc Echo Example with UDS and IPv6\nDESCRIPTION: Bash commands showing how to run the echo_c++ example server and client using UDS paths and IPv6 addresses.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/endpoint.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./echo_server -listen_addr='unix:path.sock' & # 启动Server监听UDS地址\n./echo_server -listen_addr='[::0]:8080' & # 启动Server监听IPV6端口\n\n./echo_client -server='unix:path.sock' # 启动Client访问UDS地址\n./echo_client -server='[::1]:8080' # 启动Client访问IPV6端口\n```\n\n----------------------------------------\n\nTITLE: Running brpc Examples\nDESCRIPTION: Commands to compile and run the echo server and client examples in brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/getting_started.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cd example/echo_c++\n$ make\n$ ./echo_server &\n$ ./echo_client\n```\n\n----------------------------------------\n\nTITLE: Dynamically Modifying gflags for mbvar Dump Settings in C++\nDESCRIPTION: This code demonstrates how to update gflags at runtime using google::SetCommandLineOption to adjust dumping settings for mbvar (for example, switching the dump format to prometheus). This must be done instead of directly setting global variables to ensure thread safety and to trigger internal validators, like starting background dump threads. Requires linking against gflags and including related headers. Proper error handling is performed based on the return value of SetCommandLineOption.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n#include <gflags/gflags.h>\\n...\\nif (google::SetCommandLineOption(\"mbvar_dump_format\", \"prometheus\").empty()) {\\n    LOG(ERROR) << \"Fail to set mbvar_dump_format\";\\n    return -1;\\n}\\nLOG(INFO) << \"Successfully set mbvar_dump_format to prometheus\";\n```\n\n----------------------------------------\n\nTITLE: Building bthread Unit Tests\nDESCRIPTION: Creates executable targets for all bthread unit tests by iterating through matching source files. Each test is linked with gtest_main, brpc-shared-debug, and gperftools.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# bthread tests\nfile(GLOB BTHREAD_UNITTESTS \"bthread*unittest.cpp\")\nforeach(BTHREAD_UT ${BTHREAD_UNITTESTS})\n    get_filename_component(BTHREAD_UT_WE ${BTHREAD_UT} NAME_WE)\n    add_executable(${BTHREAD_UT_WE} ${BTHREAD_UT})\n    target_link_libraries(${BTHREAD_UT_WE} gtest_main\n                                           brpc-shared-debug\n                                           ${GPERFTOOLS_LIBRARIES})\n    add_test(NAME ${BTHREAD_UT_WE} COMMAND ${BTHREAD_UT_WE})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamInputHandler in Apache brpc (C++)\nDESCRIPTION: Abstract class defining callbacks for handling stream input, including receiving messages, idle timeout, and stream closure.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_rpc.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nclass StreamInputHandler {\npublic:\n    virtual int on_received_messages(StreamId id, butil::IOBuf *const messages[], size_t size) = 0;\n    virtual void on_idle_timeout(StreamId id) = 0;\n    virtual void on_closed(StreamId id) = 0;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Server Overcrowding Settings in C++\nDESCRIPTION: Demonstrates how to configure ignore_eovercrowded settings at both server and method levels. Shows example of setting overcrowding behavior for specific service methods.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_36\n\nLANGUAGE: c++\nCODE:\n```\nServerOptions.ignore_eovercrowded = true;                   // Set the default ignore_eovercrowded for all methods\nserver.IgnoreEovercrowdedOf(\"example.EchoService.Echo\") = true;\n```\n\n----------------------------------------\n\nTITLE: Building brpc Unit Tests\nDESCRIPTION: Creates executable targets for all brpc unit tests by iterating through matching source files. Each test is linked with brpc-shared-debug, gtest_main, and gperftools libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# brpc tests\nfile(GLOB BRPC_UNITTESTS \"brpc_*_unittest.cpp\")\nforeach(BRPC_UT ${BRPC_UNITTESTS})\n    get_filename_component(BRPC_UT_WE ${BRPC_UT} NAME_WE)\n    add_executable(${BRPC_UT_WE} ${BRPC_UT} $<TARGET_OBJECTS:TEST_PROTO_LIB>)\n    target_link_libraries(${BRPC_UT_WE} brpc-shared-debug\n                                        gtest_main\n                                        ${GPERFTOOLS_LIBRARIES})\n    add_test(NAME ${BRPC_UT_WE} COMMAND ${BRPC_UT_WE})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Loading bRPC Workspace Rules in Bazel using Starlark - C++\nDESCRIPTION: This snippet shows how to load and invoke bRPC workspace configuration in the Bazel WORKSPACE file using Starlark syntax. It requires the 'brpc_workspace.bzl' script to be available at the project root. The function 'brpc_workspace' initializes bRPC dependencies for Bazel builds. No parameters need to be provided; it is expected that manual setup steps detailed in the documentation were performed.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bazel_support.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n    load(\"@//:brpc_workspace.bzl\", \"brpc_workspace\")\\n    brpc_workspace();\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting Query Parameters in brpc\nDESCRIPTION: Shows how to access and set HTTP query parameters. Query parameters are accessed through GetQuery() and set with SetQuery() on the URI object.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nconst std::string* value = cntl->http_request().uri().GetQuery(\"Foo\"); // 不存在为NULL\n```\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().uri().SetQuery(\"Foo\", \"value\");\n```\n\n----------------------------------------\n\nTITLE: Security Check Shell Script for BRPC Services\nDESCRIPTION: Shell script to verify if sensitive debug services are disabled on public BRPC servers.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\ncurl -s -m 1 <HOSTNAME>:<PORT>/flags/enable_dir_service,enable_threads_service | awk '{if($3==\"false\"){++falsecnt}else if($3==\"Value\"){isrpc=1}}END{if(isrpc!=1||falsecnt==2){print \"SAFE\"}else{print \"NOT SAFE\"}}'\n```\n\n----------------------------------------\n\nTITLE: Configuring bvar Test Target\nDESCRIPTION: Prepares and builds the test_bvar executable. Removes default_variables.cpp to prevent linking into unit tests, creates a debug library for bvar, and configures test dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# test_bvar\n# -DBVAR_NOT_LINK_DEFAULT_VARIABLES not work for gcc >= 5.0, just remove the file to prevent linking into unit tests\nlist(REMOVE_ITEM BVAR_SOURCES ${PROJECT_SOURCE_DIR}/src/bvar/default_variables.cpp)\n\nadd_library(BVAR_DEBUG_LIB OBJECT ${BVAR_SOURCES})\nfile(GLOB TEST_BVAR_SRCS \"bvar_*_unittest.cpp\")\nadd_executable(test_bvar ${TEST_BVAR_SRCS}\n                         $<TARGET_OBJECTS:BVAR_DEBUG_LIB>\n                         $<TARGET_OBJECTS:BUTIL_DEBUG_LIB>)\ntarget_link_libraries(test_bvar gtest\n                                ${GPERFTOOLS_LIBRARIES}\n                                ${DYNAMIC_LIB})\nadd_test(NAME test_bvar COMMAND test_bvar)\n```\n\n----------------------------------------\n\nTITLE: Installing brpc Using vcpkg Package Manager\nDESCRIPTION: Commands for installing brpc using the vcpkg cross-platform package manager, which supports Windows, Linux, and macOS platforms.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n$ git clone https://github.com/microsoft/vcpkg.git\n$ ./bootstrap-vcpkg.bat # for powershell\n$ ./bootstrap-vcpkg.sh # for bash\n$ ./vcpkg install brpc\n```\n\n----------------------------------------\n\nTITLE: Implementing a ProgressiveReader for HTTP Bodies Using brpc in C++\nDESCRIPTION: This snippet defines the abstract interface for a ProgressiveReader to handle large or streaming HTTP bodies in brpc clients. The user must implement methods to read parts of the body as they arrive ('OnReadOnePart') and handle the end of transfer ('OnEndOfMessage'). Dependencies include 'brpc/progressive_reader.h' and 'butil::Status'. This pattern enables chunk-by-chunk reading, minimizing memory usage for large bodies (e.g., live streaming or huge downloads). Actual reading logic is provided by the user in subclass implementations of ProgressiveReader.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_client.md#_snippet_15\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/progressive_reader.h>\n...\nclass ProgressiveReader {\npublic:\n    // Called when one part was read.\n    // Error returned is treated as *permanent* and the socket where the\n    // data was read will be closed.\n    // A temporary error may be handled by blocking this function, which\n    // may block the HTTP parsing on the socket.\n    virtual butil::Status OnReadOnePart(const void* data, size_t length) = 0;\n\n    // Called when there's nothing to read anymore. The `status' is a hint for\n    // why this method is called.\n    // - status.ok(): the message is complete and successfully consumed.\n    // - otherwise: socket was broken or OnReadOnePart() failed.\n    // This method will be called once and only once. No other methods will\n    // be called after. User can release the memory of this object inside.\n    virtual void OnEndOfMessage(const butil::Status& status) = 0;\n};\n```\n\n----------------------------------------\n\nTITLE: UseFieldAsSubRequest Implementation of CallMapper for brpc ParallelChannel\nDESCRIPTION: Implementation of CallMapper that extracts sub-requests from fields in the main request, enabling different requests for different sub channels.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n  class UseFieldAsSubRequest : public CallMapper {\n  public:\n    SubCall Map(int channel_index/*starting from 0*/,\n                const google::protobuf::MethodDescriptor* method,\n                const google::protobuf::Message* request,\n                google::protobuf::Message* response) {\n        if (channel_index >= request->sub_request_size()) {\n            // Not enough sub_request. The caller doesn't provide same number of requests as number of sub channels in pchan\n            // Return Bad() to end this RPC immediately\n            return SubCall::Bad();\n        }\n        // Fetch the sub request and add a new sub response.\n        // The last flag(0) tells pchan that there is nothing to delete.\n        return SubCall(sub_method, request->sub_request(channel_index), response->add_sub_response(), 0);\n    }\n  };\n```\n\n----------------------------------------\n\nTITLE: Defining Protobuf Library and Source Files in CMake for Apache brpc\nDESCRIPTION: Creates an object library for protobuf files and defines the source files for various components of brpc. This sets up the core build targets for the project.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(PROTO_LIB OBJECT ${PROTO_SRCS} ${PROTO_HDRS})\n\nset(SOURCES\n    ${BVAR_SOURCES}\n    ${BTHREAD_SOURCES}\n    ${JSON2PB_SOURCES}\n    ${MCPACK2PB_SOURCES}\n    ${BRPC_SOURCES}\n    ${THRIFT_SOURCES}\n    )\n```\n\n----------------------------------------\n\nTITLE: Enabling Nova Protocol in brpc Server (C++)\nDESCRIPTION: Code snippet for enabling the Nova protocol in a brpc server. It requires including the nova_pbrpc_protocol header and setting the nshead_service option.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/server.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/policy/nova_pbrpc_protocol.h>\n...\nServerOptions options;\n...\noptions.nshead_service = new brpc::policy::NovaServiceAdaptor;\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc Using config_brpc.sh on Ubuntu\nDESCRIPTION: Commands for cloning and building brpc using the config_brpc.sh script on Ubuntu-based systems, specifying header and library paths.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ sh config_brpc.sh --headers=/usr/include --libs=/usr/lib\n$ make\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building Asynchronous Echo Server/Client - CMake\nDESCRIPTION: This CMake script configures the build environment for C++ asynchronous echo server and client applications using Apache brpc. It manages dependencies including Threading, Protocol Buffers (protobuf_generate_cpp), LevelDB, GFlags, and OpenSSL, with platform-specific accommodations (especially for macOS). The script sets compilation flags for C++11, debug/release optimizations, and handles static or dynamic linking of brpc. It generates protobuf source/header files, verifies all required components are found before building the targets, and links all necessary libraries when generating the final executables.\nSOURCE: https://github.com/apache/brpc/blob/master/example/auto_concurrency_limiter/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(asynchronous_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${CMAKE_SOURCE_DIR}/../.. -type d -regex \\\\\".*output/include$\\\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER cl_test.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_RegisterThriftProtocol\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(asynchronous_echo_client client.cpp ${PROTO_SRC})\nadd_executable(asynchronous_echo_server server.cpp ${PROTO_SRC})\n\ntarget_link_libraries(asynchronous_echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(asynchronous_echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL Options in BRPC Client\nDESCRIPTION: Demonstrates how to enable and configure SSL options for BRPC channels including cipher configuration, SNI name setting, and ALPN protocol preferences\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_19\n\nLANGUAGE: c++\nCODE:\n```\n// Enable client-side SSL and use default values.\noptions.mutable_ssl_options();\n\n// Enable client-side SSL and customize values.\noptions.mutable_ssl_options()->ciphers_name = \"...\";\noptions.mutable_ssl_options()->sni_name = \"...\";\n\n// Set the protocol preference of ALPN.\n// (By default ALPN is disabled.)\noptions.mutable_ssl_options()->alpn_protocols = {\"h2\", \"http/1.1\"};\n```\n\n----------------------------------------\n\nTITLE: Discovering Build Output Path with Bash - Shell\nDESCRIPTION: This embedded shell snippet is executed within CMake to find the output directory containing an 'include' folder in the project hierarchy. It uses 'find', regular expression filtering, 'head', 'xargs dirname', and 'tr' to ensure a proper output path string is captured without trailing newlines. This output path is used by the CMake script to configure prefix paths in the build system for dependency discovery.\nSOURCE: https://github.com/apache/brpc/blob/master/example/streaming_echo_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nfind ${PROJECT_SOURCE_DIR}/../.. -type d -regex \".*output/include$\" | head -n1 | xargs dirname | tr -d '\\\\n'\n```\n\n----------------------------------------\n\nTITLE: Initializing HTTP/H2 Channel in brpc\nDESCRIPTION: Creates and initializes a Channel for HTTP or H2 communication by setting the protocol in ChannelOptions. The channel can be initialized with any URL - only the host and port are used, other parts are discarded.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::ChannelOptions options;\noptions.protocol = brpc::PROTOCOL_HTTP;  // or brpc::PROTOCOL_H2\nif (channel.Init(\"www.baidu.com\" /*any url*/, &options) != 0) {\n     LOG(ERROR) << \"Fail to initialize channel\";\n     return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies on Ubuntu/LinuxMint/WSL\nDESCRIPTION: Command to install common dependencies required for building brpc on Ubuntu-based systems including git, g++, SSL, gflags, protobuf, and leveldb.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get install -y git g++ make libssl-dev libgflags-dev libprotobuf-dev libprotoc-dev protobuf-compiler libleveldb-dev\n```\n\n----------------------------------------\n\nTITLE: Installing Common Dependencies on Fedora/CentOS\nDESCRIPTION: Command for installing common development dependencies required for building brpc on Fedora or CentOS systems.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nsudo yum install git gcc-c++ make openssl-devel\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC Protobuf Message Classes in C++\nDESCRIPTION: Defines the core interfaces for customizing RPC Protobuf messages handling. Includes RpcPBMessages class for request/response message management and RpcPBMessageFactory class for message creation and destruction.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_35\n\nLANGUAGE: c++\nCODE:\n```\n// Inherit this class to customize rpc protobuf messages,\n// include request and response.\nclass RpcPBMessages {\npublic:\n    virtual ~RpcPBMessages() = default;\n    // Get protobuf request message.\n    virtual google::protobuf::Message* Request() = 0;\n    // Get protobuf response message.\n    virtual google::protobuf::Message* Response() = 0;\n};\n\n// Factory to manage `RpcPBMessages'.\nclass RpcPBMessageFactory {\npublic:\n    virtual ~RpcPBMessageFactory() = default;\n    // Get `RpcPBMessages' according to `service' and `method'.\n    // Common practice to create protobuf message:\n    // service.GetRequestPrototype(&method).New() -> request;\n    // service.GetResponsePrototype(&method).New() -> response.\n    virtual RpcPBMessages* Get(const ::google::protobuf::Service& service,\n                               const ::google::protobuf::MethodDescriptor& method) = 0;\n    // Return `RpcPBMessages' to factory.\n    virtual void Return(RpcPBMessages* protobuf_message) = 0;\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing HTTP Request/Response Body in brpc\nDESCRIPTION: Shows how to access the HTTP request or response body. The body is accessed through request_attachment() or response_attachment() as a butil::IOBuf, which can be converted to a string if needed.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\nbutil::IOBuf& buf = cntl->request_attachment();\nstd::string str = cntl->request_attachment().to_string(); // 有拷贝\n```\n\n----------------------------------------\n\nTITLE: Configuring GPerfTools for Profiling\nDESCRIPTION: Finds gperftools headers and libraries for heap profiling and TCMalloc support. Adds the include directories to the build.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nfind_path(GPERFTOOLS_INCLUDE_DIR NAMES gperftools/heap-profiler.h)\nfind_library(GPERFTOOLS_LIBRARIES NAMES tcmalloc_and_profiler)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Appending Data to IOBuf in C++\nDESCRIPTION: Demonstrates how to append another IOBuf or string to an existing IOBuf.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/iobuf.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nbuf.append(another_buf);\n```\n\nLANGUAGE: c++\nCODE:\n```\nbuf.append(str);\n```\n\n----------------------------------------\n\nTITLE: Enabling Nova pbrpc Protocol for brpc Server - C++\nDESCRIPTION: This snippet shows how to enable the 'nova_pbrpc' protocol for a brpc server by including the appropriate header and assigning a new brpc::policy::NovaServiceAdaptor to the ServerOptions' nshead_service field. This allows the server to accept connections using the nova_pbrpc protocol, which is disabled by default. Only the brpc framework and its protocol headers are required.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/policy/nova_pbrpc_protocol.h>\n...\nServerOptions options;\n...\noptions.nshead_service = new brpc::policy::NovaServiceAdaptor;\n```\n\n----------------------------------------\n\nTITLE: Configuring Build System and Dependency Discovery - CMake\nDESCRIPTION: This CMake script initializes the build process for the nshead_pb_extension client and server, specifying minimum CMake version and project settings. It defines project-specific options, discovers all required dependencies (brpc, protobuf, leveldb, thrift, gflags, OpenSSL), configures system/compiler-specific flags (e.g., for GNU/Clang or Darwin/macOS), and generates compilation/link settings accordingly. The script initializes the protobuf code generation from .proto files, sets up include directories, and adds executables for the client and server, linking all discovered libraries. System-specific configurations such as handling clock_gettime on macOS and dynamic/static linking options are covered, with all configuration steps commented for context. Inputs include paths to .proto files, C++ source files, and system-level libraries; outputs are compiled client/server binaries for the brpc protocol extensions.\nSOURCE: https://github.com/apache/brpc/blob/master/example/nshead_pb_extension_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(nshead_pb_extension_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(nshead_pb_extension_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(nshead_pb_extension_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(nshead_pb_extension_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(nshead_pb_extension_server ${BRPC_LIB} ${DYNAMIC_LIB})\n\n```\n\n----------------------------------------\n\nTITLE: Linking Apache bRPC Dependencies in Bazel BUILD File - C++\nDESCRIPTION: This snippet demonstrates how to specify bRPC and its core components as dependencies within a Bazel BUILD file. The 'deps' array lists required libraries, including 'bthread', 'brpc', 'butil', and 'bvar', sourced from the bazel external repository '@apache_brpc'. Each of these provides core runtime or utility support for projects using bRPC. Ensure that the workspace has been configured as shown in the previous snippet before using these targets.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bazel_support.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n  ...\\n  deps = [\\n    \"@apache_brpc//:bthread\",\\n    \"@apache_brpc//:brpc\",\\n    \"@apache_brpc//:butil\",\\n    \"@apache_brpc//:bvar\",\\n  ]\\n  ...\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc Using config_brpc.sh on Fedora/CentOS\nDESCRIPTION: Commands for building brpc using the config_brpc.sh script on Fedora/CentOS systems, specifying header and library paths.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n$ sh config_brpc.sh --headers=\"/usr/include\" --libs=\"/usr/lib64 /usr/bin\"\n$ make\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Serialization for brpc Protocols (C++)\nDESCRIPTION: Specifies the prototype for a callback that serializes user request objects into a transport-ready buffer for a protocol. This function uses the request Controller for additional metadata and directly modifies the output buffer. Must be implemented by protocol authors for the client side, returning success or failure based on serialization logic.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\ntypedef bool (*SerializeRequest)(butil::IOBuf* request_buf,\n                                 Controller* cntl,\n                                 const google::protobuf::Message* request);\n```\n\n----------------------------------------\n\nTITLE: Manipulating HTTP Query Strings via brpc URI API - C++\nDESCRIPTION: Shows how to work with query string parameters in HTTP requests in brpc. Demonstrates accessing query string values using GetQuery, handling cases where a key has no value, and updating query string values via SetQuery. Uses brpc's URI API for parameter handling on requests. No external dependencies required.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string* time_value = cntl->http_request().uri().GetQuery(\"time\");\\nif (time_value != NULL) {  // the query string is present\\n    LOG(TRACE) << \"time = \" << *time_value;\\n}\\n\\n...\\ncntl->http_request().uri().SetQuery(\"time\", \"2015/1/2\");\n```\n\n----------------------------------------\n\nTITLE: Installing and Building Google Test on MacOS\nDESCRIPTION: Commands for downloading and building Google Test framework on MacOS for running brpc unit tests when Homebrew's version isn't available.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/google/googletest -b release-1.10.0 && cd googletest/googletest && mkdir build && cd build && cmake -DCMAKE_CXX_FLAGS=\"-std=c++11\" .. && make\n```\n\n----------------------------------------\n\nTITLE: Initializing SelectiveChannel - brpc - C++\nDESCRIPTION: Initializes a brpc::SelectiveChannel instance in C++ with specific options such as timeout, backup request timing, and maximum retry count. The snippet demonstrates error handling during initialization. Requires brpc (header \\\"<brpc/selective_channel.h>\\\") and a valid load_balancer argument. Key parameters: \\\"timeout_ms\\\", \\\"backup_request_ms\\\", and \\\"max_retry\\\" configure channel behavior. Input includes load_balancer and brpc::ChannelOptions pointer; output is success/failure (0/-1).\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/selective_channel.h>\n...\nbrpc::SelectiveChannel schan;\nbrpc::ChannelOptions schan_options;\nschan_options.timeout_ms = ...;\nschan_options.backup_request_ms = ...;\nschan_options.max_retry = ...;\nif (schan.Init(load_balancer, &schan_options) != 0) {\n    LOG(ERROR) << \"Fail to init SelectiveChannel\";\n    return -1;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building Multi-threaded Echo Example with CMake - CMake - CMake\nDESCRIPTION: This CMake script orchestrates environment setup and dependency management to build a multi-threaded echo client and server in C++ using the brpc framework. It ensures all prerequisites (protobuf, gperftools, brpc, gflags, leveldb, OpenSSL, thrift) are available, configures flags for debug and optimization, and manages platform-specific requirements like macOS linker and OpenSSL paths. The script generates Protocol Buffer source/header files, sets up include and link directories, and defines the build for client and server targets, linking all necessary libraries and copying SSL certificates as needed. Inputs are source files and build options; outputs are the `echo_client` and `echo_server` binaries with all dependencies resolved; constraints include correct library presence and platform compatibility.\nSOURCE: https://github.com/apache/brpc/blob/master/example/multi_threaded_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(multi_threaded_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(GPERFTOOLS_INCLUDE_DIR NAMES gperftools/heap-profiler.h)\nfind_library(GPERFTOOLS_LIBRARIES NAMES tcmalloc_and_profiler)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(echo_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(echo_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n\nfile(COPY ${PROJECT_SOURCE_DIR}/key.pem\n     DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nfile(COPY ${PROJECT_SOURCE_DIR}/cert.pem\n     DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Session Local Data Factory Configuration in BRPC\nDESCRIPTION: Shows the server options configuration for session local data and implementation of the DataFactory interface for creating session local data.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_27\n\nLANGUAGE: c++\nCODE:\n```\nclass MySessionLocalDataFactory : public brpc::DataFactory {\npublic:\n    void* CreateData() const {\n        return new MySessionLocalData;\n    }\n    void DestroyData(void* d) const {\n        delete static_cast<MySessionLocalData*>(d);\n    }\n};\n\nMySessionLocalDataFactory g_session_local_data_factory;\n\nint main(int argc, char* argv[]) {\n    ...\n\n    brpc::Server server;\n    brpc::ServerOptions options;\n    ...\n    options.session_local_data_factory = &g_session_local_data_factory;\n    ...\n```\n\n----------------------------------------\n\nTITLE: Finding Output Path for brpc Library in CMake\nDESCRIPTION: Executes a bash command to find the output path of the brpc library and sets it as the CMAKE_PREFIX_PATH.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rpcz_echo_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n```\n\n----------------------------------------\n\nTITLE: Dividing Traffic with SelectiveChannel and Multiple Sub-Channels - brpc - C++\nDESCRIPTION: Creates a SelectiveChannel and dynamically inserts three regular channels, each associated with a different naming service. ChannelOptions (timeout_ms and max_retry) are set from flags. Each sub_channel is initialized with its own naming service and added to the parent channel. Requires all brpc headers, a valid FLAGS_timeout_ms, FLAGS_max_retry, and a string array ns_node_name[]. The expected input includes valid channel options and existing naming services; output is success/failure per sub-channel. Demonstrates scalable traffic division via sub-channel insertion.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nbrpc::SelectiveChannel channel;\nbrpc::ChannelOptions schan_options;\nschan_options.timeout_ms = FLAGS_timeout_ms;\nschan_options.max_retry = FLAGS_max_retry;\nif (channel.Init(\"c_murmurhash\", &schan_options) != 0) {\n    LOG(ERROR) << \"Fail to init SelectiveChannel\";\n    return -1;\n}\n \nfor (int i = 0; i < 3; ++i) {\n    brpc::Channel* sub_channel = new brpc::Channel;\n    if (sub_channel->Init(ns_node_name[i], \"rr\", NULL) != 0) {\n        LOG(ERROR) << \"Fail to init sub channel \" << i;\n        return -1;\n    }\n    if (channel.AddChannel(sub_channel, NULL/*handle for removal*/) != 0) {\n        LOG(ERROR) << \"Fail to add sub_channel to channel\";\n        return -1;\n    } \n}\n...\nXXXService_Stub stub(&channel);\nstub.FooMethod(&cntl, &request, &response, NULL);\n...\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc with Self-built Dependencies\nDESCRIPTION: Commands for building brpc with custom-built dependencies by specifying the paths to headers and libraries using config_brpc.sh.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n$ sh config_brpc.sh --headers=\"../gflags_dev /usr/include\" --libs=\"../gflags_dev /usr/lib64\"\n$ make\n```\n\n----------------------------------------\n\nTITLE: Implementing Server Push with done->Run() in brpc\nDESCRIPTION: This code snippet demonstrates how server notifies a client about an event by calling done->Run() when the corresponding local event is triggered. This is part of the remote events approach for server push in brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/server_push.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\ndone->Run()\n```\n\n----------------------------------------\n\nTITLE: Comparing Candidate Source Packages - Bash\nDESCRIPTION: This snippet downloads the official tagged source tarball from GitHub and the candidate release tarball, extracts both, and recursively compares their contents. Dependencies include 'curl', 'tar', and 'diff'. Parameters include the tag version and target file names. The expected output highlights any differences between the release candidate and the tag source package as part of the release validation process.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ncurl -Lo tag-1.0.0.tar.gz https://github.com/apache/brpc/archive/refs/tags/1.0.0.tar.gz\n\ntar xvzf tag-1.0.0.tar.gz\n\ntar xvzf apache-brpc-1.0.0-src.tar.gz\n\ndiff -r brpc-1.0.0 apache-brpc-1.0.0-src\n```\n\n----------------------------------------\n\nTITLE: Incorrect and Correct Usage of bvar::PerSecond and bvar::Window for Maximum Values - C++\nDESCRIPTION: This example demonstrates why bvar::PerSecond is unsuitable for max-tracking and illustrates the correct approach using bvar::Window. It shows that dividing a max value over a period by the time window is meaningless and instead suggests a window of 1s to retrieve the max value per second using bvar::Window. Requires bvar::Maxer and understanding of bvar API patterns.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nbvar::Maxer<int> max_value;\n\n// WRONG！max value divided by time window is pointless\nbvar::PerSecond<bvar::Maxer<int> > max_value_per_second_wrong(&max_value);\n\n// CORRECT. It's the right way to set the time window to 1s so that we can get the max value for every second\nbvar::Window<bvar::Maxer<int> > max_value_per_second(&max_value, 1);\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum with bvar::Miner - brpc - C++\nDESCRIPTION: This example demonstrates usage of bvar::Miner to determine the minimum value in a sequence. Miner employs std::min, relying on operator< and uses std::numeric_limits::max() as the identity value. Inputs are streamed ints; output is the minimum tracked. Not suitable for custom types unless proper numeric_limits and operator< exist.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nbvar::Miner<int> value;\nvalue << 1 << 2 << 3 << -4;\nCHECK_EQ(-4, value.get_value());\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto Concurrency Limiter in BRPC\nDESCRIPTION: Demonstrates how to set up automatic concurrency limiting for BRPC methods. Shows both global configuration for all methods and specific method configuration.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_23\n\nLANGUAGE: c++\nCODE:\n```\n// Set auto concurrency limiter for all methods\nbrpc::ServerOptions options;\noptions.method_max_concurrency = \"auto\";\n\n// Set auto concurrency limiter for specific method\nserver.MaxConcurrencyOf(\"example.EchoService.Echo\") = \"auto\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies and Build Targets with CMake - CMake\nDESCRIPTION: This CMake script configures the build process for a brpc-based echo example. It searches for and configures required dependencies (including brpc, protobuf, gflags, leveldb, thrift, gperftools, and OpenSSL), sets compiler flags for different platforms, and ensures proper generation of protobuf sources. It manages dynamic and static linking based on the LINK_SO option, handles macOS-specific adjustments, and defines the executable targets for client and server. CMake version and compiler compatibility are addressed, and appropriate include/link directories are set according to the detected environment.\nSOURCE: https://github.com/apache/brpc/blob/master/example/bthread_tag_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(bthread_tag_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(GPERFTOOLS_INCLUDE_DIR NAMES gperftools/heap-profiler.h)\nfind_library(GPERFTOOLS_LIBRARIES NAMES tcmalloc_and_profiler)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(echo_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(echo_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc using config_brpc.sh\nDESCRIPTION: Commands to clone brpc repository, configure, and build the project using config_brpc.sh script.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/getting_started.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ sh config_brpc.sh --headers=/usr/include --libs=/usr/lib\n$ make\n```\n\n----------------------------------------\n\nTITLE: Running brpc Tests\nDESCRIPTION: Commands to compile and run the test suite for brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/getting_started.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ cd test\n$ make\n$ sh run_tests.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project for HTTP C++ with brpc\nDESCRIPTION: Sets up the basic CMake project configuration for HTTP examples using brpc. Defines project name, minimum CMake version required, and the option to link dynamically.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(http_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Sample format for file:// naming service machine list - Plain Text\nDESCRIPTION: This snippet shows a sample content for a file listing server addresses with tags and comments, as used by the file:// naming service protocol in brpc. Each line specifies one server, optionally followed by a tag and a comment. Address/tag combinations distinguish different instances. Lines starting with # or with only comments are ignored. This file must be formatted as shown to be parsed correctly by brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n# This line is ignored\\n10.24.234.17:8080 tag1  # a comment\\n10.24.234.17:8090 tag2  # an instance different from the instance on last line\\n10.24.234.18:8080\\n10.24.234.19:8080\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building brpc Memcache Client - CMake\nDESCRIPTION: This CMake script orchestrates discovery and configuration of dependencies like brpc, Protobuf, Thrift, GFlags, LevelDB, and OpenSSL, as well as respective include paths and libraries. It dynamically resolves required paths, adjusts build flags for platform and compiler, generates protobuf sources, and defines target executables for a memcache client application. Inputs are mainly system environment and available libraries; output is the build system for memcache_client. It requires CMake 2.8.10+, proper library installations, and is intended for project integration on Unix-like systems, with special consideration for Darwin/macOS settings.\nSOURCE: https://github.com/apache/brpc/blob/master/example/memcache_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\ncmake_minimum_required(VERSION 2.8.10)\nproject(memcache_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(memcache_client client.cpp)\n\ntarget_link_libraries(memcache_client ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: Using StringSink for Log Capture in C++ Unit Tests\nDESCRIPTION: This snippet demonstrates how to use StringSink, a LogSink implementation, to capture log output in a unit test. It shows setting up the sink, logging, and verifying the captured log content.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_log.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nTEST_F(StreamingLogTest, log_at) {\n    ::logging::StringSink log_str;\n    ::logging::LogSink* old_sink = ::logging::SetLogSink(&log_str);\n    LOG_AT(FATAL, \"specified_file.cc\", 12345) << \"file/line is specified\";\n    // the file:line part should be using the argument given by us.\n    ASSERT_NE(std::string::npos, log_str.find(\"specified_file.cc:12345\"));\n    // restore the old sink.\n    ::logging::SetLogSink(old_sink);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ServerOptions for Thread-Local Data Management in brpc (C++)\nDESCRIPTION: This struct definition shows ServerOptions with configuration fields for managing thread-local data in a brpc server. The thread_local_data_factory field allows users to provide a factory for creating/deleting per-thread data, and reserved_thread_local_data pre-allocates a specified number of slots before serving starts. Proper factory implementation and understanding memory management responsibilities are prerequisites.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\nstruct ServerOptions {\n    ...\n    // The factory to create/destroy data attached to each searching thread\n    // in server.\n    // If this field is NULL, brpc::thread_local_data() is always NULL.\n    // NOT owned by Server and must be valid when Server is running.\n    // Default: NULL\n    const DataFactory* thread_local_data_factory;\n\n    // Prepare so many thread-local data before server starts, so that calls\n    // to brpc::thread_local_data() get data directly rather than calling\n    // thread_local_data_factory->Create() at first time. Useful when Create()\n    // is slow, otherwise the RPC session may be blocked by the creation\n    // of data and not served within timeout.\n    // Default: 0\n    size_t reserved_thread_local_data;\n};\n\n```\n\n----------------------------------------\n\nTITLE: Initializing brpc Channel with Custom Options - C++\nDESCRIPTION: This C++ code demonstrates how to instantiate and configure a brpc::ChannelOptions object with custom settings, followed by initializing a Channel with these options. Dependencies include the brpc framework and access to brpc::Channel and brpc::ChannelOptions. The key parameter is 'options', which allows customization of various connection behaviors before passing to channel.Init(). The input is user-defined options, and the output is a Channel object ready for use; modification of options after Init() is not allowed.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::ChannelOptions options;  // including default values\\noptions.xxx = yyy;\\n...\\nchannel.Init(..., &options);\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc Using CMake\nDESCRIPTION: Commands for building brpc using the CMake build system, creating a build directory and compiling with multiple CPU cores.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nmkdir build && cd build && cmake .. && cmake --build . -j6\n```\n\n----------------------------------------\n\nTITLE: Basic CMake Project Setup\nDESCRIPTION: Initializes CMake project and sets minimum version requirement for building bRPC examples.\nSOURCE: https://github.com/apache/brpc/blob/master/example/baidu_proxy_and_generic_call/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(baidu_proxy_and_generic_call C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Updating Version in Bazel Module - Plain Text\nDESCRIPTION: Shows the configuration for setting the brpc version in MODULE.bazel for Bazel build systems. This snippet should be placed in the module() definition with the correct version number.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\n# in MODULE.bazel\\nmodule(\\n  ...\\n  version = '1.0.0',\\n  ...\\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring brpc Echo Example Build with CMake - CMake\nDESCRIPTION: This CMake script configures the build for an echo client and server application using Apache brpc and several dependencies such as Protobuf, Thrift, GFlags, LevelDB, and OpenSSL. It detects platform-specific features (e.g., Darwin/macOS), manages inclusion paths and link libraries, applies compilation flags for C++11 support, and creates two executable targets. Key parameters controlled here include LINK_SO for controlling shared/static linking, and compiler/linker flags for performance and debugging. Outputs are 'echo_client' and 'echo_server' binaries; users must provide proper dependency installations and specify the 'echo.proto' file in the source tree. Limitations may exist if dependencies are misconfigured or missing.\nSOURCE: https://github.com/apache/brpc/blob/master/example/echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n\n```\n\n----------------------------------------\n\nTITLE: Using butil::Timer for Performance Measurement in C++\nDESCRIPTION: Shows the API for butil::Timer, which can be used alongside bvar for measuring elapsed time in different units (nanoseconds, microseconds, milliseconds, seconds).\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n#include <butil/time.h>\nnamespace butil {\nclass Timer {\npublic:\n    enum TimerType { STARTED };\n\n    Timer();\n\n    // butil::Timer tm(butil::Timer::STARTED);  // tm is already started after creation.\n    explicit Timer(TimerType);\n\n    // Start this timer\n    void start();\n\n    // Stop this timer\n    void stop();\n\n    // Get the elapse from start() to stop().\n    int64_t n_elapsed() const;  // in nanoseconds\n    int64_t u_elapsed() const;  // in microseconds\n    int64_t m_elapsed() const;  // in milliseconds\n    int64_t s_elapsed() const;  // in seconds\n};\n}  // namespace butil\n```\n\n----------------------------------------\n\nTITLE: Starting Dummy Server via brpc API - C++\nDESCRIPTION: This C++ snippet demonstrates how to manually start a brpc dummy server on a specified port using the StartDummyServerAt function. The code includes the required brpc/server.h header and should be placed at the program entry (typically within the main function). To run this, brpc must be downloaded and compiled according to the project's instructions. The port parameter (e.g., 8888) is the listening port for the dummy server, which will then expose built-in services and bvar metrics to the process. The output is a dummy server running on the provided port, with no return value.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/dummy_server.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <brpc/server.h>\\n \\n...\\n \\nint main() {\\n    ...\\n    brpc::StartDummyServerAt(8888/*port*/);\\n    ...\\n}\n```\n\n----------------------------------------\n\nTITLE: String Concatenation with bvar::Adder - brpc - C++\nDESCRIPTION: This code demonstrates bvar::Adder applied to std::string for concatenating strings. Despite inefficiency compared to ostringstream, it shows that Adder supports any type with operator+ overload. Dependencies: bvar library and std::string operator+; input is a sequence of strings, output is the concatenated result.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\n// This is just proof-of-concept, don't use it for production code because it makes a\n// bunch of temporary strings which is not efficient, use std::ostringstream instead.\nbvar::Adder<std::string> concater;\nstd::string str1 = \"world\";\nconcater << \"hello \" << str1;\nCHECK_EQ(\"hello world\", concater.get_value());\n```\n\n----------------------------------------\n\nTITLE: Submitting Release Artifacts to SVN - Bash\nDESCRIPTION: Adds new files to the SVN working copy and commits them with a release message. Authenticates using your Apache LDAP account. This step finalizes the artifact publishing process.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/brpc_svn/dev/brpc\\n\\nsvn add *\\n\\nsvn --username=lorinlee commit -m \"release 1.0.0\"\n```\n\n----------------------------------------\n\nTITLE: Enabling bvar Dump via gflags - brpc - C++\nDESCRIPTION: This snippet demonstrates enabling periodic dumping of bvar variables to a local file using the gflags library. By setting the \"bvar_dump\" flag to true via SetCommandLineOption, a background thread is launched for periodic export. Required dependencies include the gflags library and appropriate linkage to brpc/bvar. The main inputs are the flag names and values; the output is side-effect: export of data to configured files. Failure to enable results in a fatal log.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n#include <gflags/gflags.h>\n...\nint main(int argc, char* argv[]) {\n    if (google::SetCommandLineOption(\"bvar_dump\", \"true\").empty()) {\n        LOG(FATAL) << \"Fail to enable bvar dump\";\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc with RDMA using CMake\nDESCRIPTION: Commands to compile brpc with RDMA support using CMake build system. This method enables RDMA by setting the WITH_RDMA flag to ON, then builds the main library and example program.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/rdma.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir bld && cd bld && cmake -DWITH_RDMA=ON ..\nmake\n\ncd example/rdma_performance  # 示例程序\nmkdir bld && cd bld && cmake ..\nmake\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building brpc nshead Extension - CMake\nDESCRIPTION: Sets up the build environment for the brpc nshead client and server using CMake. Handles discovery and inclusion of essential dependencies (e.g., protobuf, thrift, gflags, leveldb, OpenSSL), sets compiler flags (with special handling for macOS), and defines build targets for the client and server. Key parameters include the project source directory, linkage options (dynamic/static via LINK_SO), and system-specific settings. Inputs are the CMake configuration and source files; outputs are the compiled binaries. Assumes required libraries and headers are available; build may fail if any dependency is missing.\nSOURCE: https://github.com/apache/brpc/blob/master/example/nshead_extension_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Licensed to the Apache Software Foundation (ASF) under one\\n# or more contributor license agreements.  See the NOTICE file\\n# distributed with this work for additional information\\n# regarding copyright ownership.  The ASF licenses this file\\n# to you under the Apache License, Version 2.0 (the\\n# \\\"License\\\"); you may not use this file except in compliance\\n# with the License.  You may obtain a copy of the License at\\n#\\n#   http://www.apache.org/licenses/LICENSE-2.0\\n#\\n# Unless required by applicable law or agreed to in writing,\\n# software distributed under the License is distributed on an\\n# \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\\n# KIND, either express or implied.  See the License for the\\n# specific language governing permissions and limitations\\n# under the License.\\n\\ncmake_minimum_required(VERSION 2.8.10)\\nproject(nshead_extension_c++ C CXX)\\n\\noption(LINK_SO \\\"Whether examples are linked dynamically\\\" OFF)\\n\\nexecute_process(\\n    COMMAND bash -c \\\"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\\\\\".*output/include$\\\\\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\\\"\\n    OUTPUT_VARIABLE OUTPUT_PATH\\n)\\n\\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\\n\\ninclude(FindThreads)\\ninclude(FindProtobuf)\\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\\n# include PROTO_HEADER\\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\\n\\n# Search for libthrift* by best effort. If it is not found and brpc is\\n# compiled with thrift protocol enabled, a link error would be reported.\\nfind_library(THRIFT_LIB NAMES thrift)\\nif (NOT THRIFT_LIB)\\n    set(THRIFT_LIB \\\"\\\")\\nendif()\\n\\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\\nif(LINK_SO)\\n    find_library(BRPC_LIB NAMES brpc)\\nelse()\\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\\nendif()\\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\\n    message(FATAL_ERROR \\\"Fail to find brpc\\\")\\nendif()\\ninclude_directories(${BRPC_INCLUDE_PATH})\\n\\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\\n    message(FATAL_ERROR \\\"Fail to find gflags\\\")\\nendif()\\ninclude_directories(${GFLAGS_INCLUDE_PATH})\\n\\nif(CMAKE_SYSTEM_NAME STREQUAL \\\"Darwin\\\")\\n    include(CheckFunctionExists)\\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\\n    if(NOT HAVE_CLOCK_GETTIME)\\n        set(DEFINE_CLOCK_GETTIME \\\"-DNO_CLOCK_GETTIME_IN_MAC\\\")\\n    endif()\\nendif()\\n\\nset(CMAKE_CXX_FLAGS \\\"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\\\")\\n\\nif(CMAKE_VERSION VERSION_LESS \\\"3.1.3\\\")\\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \\\"GNU\\\")\\n        set(CMAKE_CXX_FLAGS \\\"${CMAKE_CXX_FLAGS} -std=c++11\\\")\\n    endif()\\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \\\"Clang\\\")\\n        set(CMAKE_CXX_FLAGS \\\"${CMAKE_CXX_FLAGS} -std=c++11\\\")\\n    endif()\\nelse()\\n    set(CMAKE_CXX_STANDARD 11)\\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\\nendif()\\n\\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\\nfind_library(LEVELDB_LIB NAMES leveldb)\\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\\n    message(FATAL_ERROR \\\"Fail to find leveldb\\\")\\nendif()\\ninclude_directories(${LEVELDB_INCLUDE_PATH})\\n\\nif(CMAKE_SYSTEM_NAME STREQUAL \\\"Darwin\\\")\\n    set(OPENSSL_ROOT_DIR\\n        \\\"/usr/local/opt/openssl\\\"    # Homebrew installed OpenSSL\\n        )\\nendif()\\n\\nfind_package(OpenSSL)\\ninclude_directories(${OPENSSL_INCLUDE_DIR})\\n\\nset(DYNAMIC_LIB\\n    ${CMAKE_THREAD_LIBS_INIT}\\n    ${GFLAGS_LIBRARY}\\n    ${PROTOBUF_LIBRARIES}\\n    ${LEVELDB_LIB}\\n    ${OPENSSL_CRYPTO_LIBRARY}\\n    ${OPENSSL_SSL_LIBRARY}\\n    ${THRIFT_LIB}\\n    dl\\n    )\\n\\nif(CMAKE_SYSTEM_NAME STREQUAL \\\"Darwin\\\")\\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\\n        pthread\\n        \\\"-framework CoreFoundation\\\"\\n        \\\"-framework CoreGraphics\\\"\\n        \\\"-framework CoreData\\\"\\n        \\\"-framework CoreText\\\"\\n        \\\"-framework Security\\\"\\n        \\\"-framework Foundation\\\"\\n        \\\"-Wl,-U,_MallocExtension_ReleaseFreeMemory\\\"\\n        \\\"-Wl,-U,_ProfilerStart\\\"\\n        \\\"-Wl,-U,_ProfilerStop\\\"\\n        \\\"-Wl,-U,__Z13GetStackTracePPvii\\\"\\n        \\\"-Wl,-U,_mallctl\\\"\\n        \\\"-Wl,-U,_malloc_stats_print\\\"\\n    )\\nendif()\\n\\nadd_executable(nshead_extension_client client.cpp)\\nadd_executable(nshead_extension_server server.cpp)\\n\\ntarget_link_libraries(nshead_extension_client ${BRPC_LIB} ${DYNAMIC_LIB})\\ntarget_link_libraries(nshead_extension_server ${BRPC_LIB} ${DYNAMIC_LIB})\\n\n```\n\n----------------------------------------\n\nTITLE: Setting Protocol Buffers Protocol for HTTP/2 in ChannelOptions\nDESCRIPTION: Shows how to set the Protocol Buffers serialization protocol for HTTP/2 requests in ChannelOptions. This is the default behavior for HTTP/2.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_derivatives.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nh2:proto\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Request Processing for brpc (C++)\nDESCRIPTION: Defines the callback signature for handling parsed protocol requests on the server side. Implementers must perform application logic or decoding using the provided message object, and are responsible for safely releasing resources when finished, commonly via msg_base->Destroy(). Handles may be invoked concurrently in multithreaded use.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\ntypedef void (*ProcessRequest)(InputMessageBase* msg_base);\n```\n\n----------------------------------------\n\nTITLE: Sending SET and INCR Commands to Redis with brpc in C++\nDESCRIPTION: Illustrates executing single-command Redis requests—specifically SET and INCR—using brpc. Shows constructing RedisRequest objects with AddCommand, sending the call with CallMethod, and inspecting the RedisResponse for errors and results. Relies on properly initialized brpc::Channel; outputs both error and successful responses with LOG calls.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nstd::string my_key = \"my_key_1\";\nint my_number = 1;\n...\n// Execute \"SET <my_key> <my_number>\"\nbrpc::RedisRequest set_request;\nbrpc::RedisResponse response;\nbrpc::Controller cntl;\nset_request.AddCommand(\"SET %s %d\", my_key.c_str(), my_number);\nredis_channel.CallMethod(NULL, &cntl, &set_request, &response, NULL/*done*/);\nif (cntl.Failed()) {\n    LOG(ERROR) << \"Fail to access redis-server\";\n    return -1;\n}\n// Get a reply by calling response.reply(i)\nif (response.reply(0).is_error()) {\n    LOG(ERROR) << \"Fail to set\";\n    return -1;\n}\n// A reply is printable in multiple ways\nLOG(INFO) << response.reply(0).c_str()  // OK\n          << response.reply(0)          // OK\n          << response;                  // OK\n...\n \n// Execute \"INCR <my_key>\"\nbrpc::RedisRequest incr_request;\nincr_request.AddCommand(\"INCR %s\", my_key.c_str());\nresponse.Clear();\ncntl.Reset();\nredis_channel.CallMethod(NULL, &cntl, &incr_request, &response, NULL/*done*/);\nif (cntl.Failed()) {\n    LOG(ERROR) << \"Fail to access redis-server\";\n    return -1;\n}\nif (response.reply(0).is_error()) {\n    LOG(ERROR) << \"Fail to incr\";\n    return -1;\n}\n// A reply is printable in multiple ways\nLOG(INFO) << response.reply(0).integer()  // 2\n          << response.reply(0)            // (integer) 2\n          << response;                    // (integer) 2\n```\n\n----------------------------------------\n\nTITLE: Installing Profiler Tools for brpc Examples on Fedora/CentOS\nDESCRIPTION: Command for installing Google perftools on Fedora/CentOS to enable CPU and heap profilers in brpc examples.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\nsudo yum install gperftools-devel\n```\n\n----------------------------------------\n\nTITLE: Building brpc with RDMA using Bazel\nDESCRIPTION: Instructions for building brpc with RDMA support using Bazel build system. This shows how to build both the server and client components of the rdma_performance example with RDMA enabled.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/rdma.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Server\nbazel build --define=BRPC_WITH_RDMA=true example:rdma_performance_server\n# Client\nbazel build --define=BRPC_WITH_RDMA=true example:rdma_performance_client\n```\n\n----------------------------------------\n\nTITLE: Building brpc with RDMA using config_brpc script\nDESCRIPTION: Instructions for building brpc with RDMA support using the config_brpc.sh script. This includes specifying the location of headers and libraries, and building the rdma_performance example.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/rdma.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsh config_brpc.sh --with-rdma --headers=\"/usr/include\" --libs=\"/usr/lib64 /usr/bin\"\nmake\n\ncd example/rdma_performance  # example for rdma\nmake\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Packing for brpc Protocol Transmission (C++)\nDESCRIPTION: Provides the function signature for final packing of a serialized request prior to network transmission. This may include adding headers, encryption/authentication tokens, or other protocol-specific concerns. Each call outputs a new packed message, requiring details such as method descriptors and optional authentication contexts.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\ntypedef int (*PackRequest)(butil::IOBuf* msg, \n                           uint64_t correlation_id,\n                           const google::protobuf::MethodDescriptor* method,\n                           Controller* controller,\n                           const butil::IOBuf& request_buf,\n                           const Authenticator* auth);\n```\n\n----------------------------------------\n\nTITLE: Using expose_as() Method for Prefixed bvar Names in C++\nDESCRIPTION: Shows the API for the expose_as() method that allows exposing bvar variables with a namespace prefix, promoting better naming organization and avoiding name conflicts.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\n// Expose this variable with a prefix.\n// Example:\n//   namespace foo {\n//   namespace bar {\n//   class ApplePie {\n//       ApplePie() {\n//           // foo_bar_apple_pie_error\n//           _error.expose_as(\"foo_bar_apple_pie\", \"error\");\n//       }\n//   private:\n//       bvar::Adder<int> _error;\n//   };\n//   }  // foo\n//   }  // bar\nint expose_as(const butil::StringPiece& prefix, const butil::StringPiece& name);\n```\n\n----------------------------------------\n\nTITLE: Configuring Build and Installation for rpc_press - CMake\nDESCRIPTION: This CMake code locates all .cpp source files in the tools/rpc_press directory, generates an rpc_press executable, links it against the brpc-static library and an optional dynamic library (DYNAMIC_LIB), and adds an installation rule to copy the resulting binary into the designated install bindir. It requires a valid CMake environment, typically as part of a larger C++ project, and depends on the presence of brpc libraries and configuration variables PROJECT_SOURCE_DIR, DYNAMIC_LIB, and CMAKE_INSTALL_BINDIR. Inputs are file globs and variable references; the output is the rpc_press binary. All target dependencies must be correctly set for successful linking and installation.\nSOURCE: https://github.com/apache/brpc/blob/master/tools/rpc_press/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SOURCES \"${PROJECT_SOURCE_DIR}/tools/rpc_press/*.cpp\")\nadd_executable(rpc_press ${SOURCES})\ntarget_link_libraries(rpc_press brpc-static ${DYNAMIC_LIB})\ninstall(TARGETS rpc_press RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc with RDMA using Bazel\nDESCRIPTION: Commands to compile brpc RDMA server and client examples using Bazel build system. This method enables RDMA by setting the BRPC_WITH_RDMA define to true when building the example applications.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/rdma.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Server\nbazel build --define=BRPC_WITH_RDMA=true example:rdma_performance_server\n# Client\nbazel build --define=BRPC_WITH_RDMA=true example:rdma_performance_client\n```\n\n----------------------------------------\n\nTITLE: Configuring brpc with Thrift Support\nDESCRIPTION: Commands to configure brpc with Thrift support using either the config_brpc.sh script or CMake. This step is necessary to enable Thrift protocol support in brpc.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/thrift.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Ubuntu\nsh config_brpc.sh --headers=/usr/include --libs=/usr/lib --with-thrift\n# Fedora/CentOS\nsh config_brpc.sh --headers=/usr/include --libs=/usr/lib64 --with-thrift\n# Or use cmake\nmkdir build && cd build && cmake ../ -DWITH_THRIFT=1\n```\n\n----------------------------------------\n\nTITLE: Setting Data in Memcached using BRPC in C++\nDESCRIPTION: Demonstrates how to set a key-value pair in memcached with flags, expiration time, and CAS value. The example writes the key \"hello\" with value \"world\", sets flags to 0xdeadbeef, and configures a 10-second expiration time while ignoring CAS value.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/memcache_client.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n// 写入key=\"hello\" value=\"world\" flags=0xdeadbeef，10秒失效，无视cas。\nbrpc::MemcacheRequest request;\nbrpc::MemcacheResponse response;\nbrpc::Controller cntl;\nif (!request.Set(\"hello\", \"world\", 0xdeadbeef/*flags*/, 10/*expiring seconds*/, 0/*ignore cas*/)) {\n    LOG(FATAL) << \"Fail to SET request\";\n    return -1;\n} \nchannel.CallMethod(NULL, &cntl, &request, &response, NULL/*done*/);\nif (cntl.Failed()) {\n    LOG(FATAL) << \"Fail to access memcached, \" << cntl.ErrorText();\n    return -1;\n}  \nif (!response.PopSet(NULL)) {\n    LOG(FATAL) << \"Fail to SET memcached, \" << response.LastError();\n    return -1;   \n}\n...\n```\n\n----------------------------------------\n\nTITLE: Building and Installing an Executable with CMake - CMake\nDESCRIPTION: This snippet defines the CMake commands to compile the 'trackme_server' application as an executable from the 'trackme_server.cpp' source file, link it against the 'brpc-static' library and any dynamic libraries specified by the 'DYNAMIC_LIB' variable, and install the resulting binary to the location specified by 'CMAKE_INSTALL_BINDIR'. These steps require CMake to be present, the 'trackme_server.cpp' file to exist, and all necessary libraries to be available. Inputs are file names and variable references; the outputs are a built executable and its installation.\nSOURCE: https://github.com/apache/brpc/blob/master/tools/trackme_server/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(trackme_server trackme_server.cpp)\ntarget_link_libraries(trackme_server brpc-static ${DYNAMIC_LIB})\ninstall(TARGETS trackme_server RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Launching Server and Client with Tagged Task Groups in C++\nDESCRIPTION: Example showing how to start server with 3 tagged worker groups and corresponding client connections. Server configuration includes task group tags, thread concurrency settings, and event dispatcher configuration.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/bthread_tagged_task_group.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n服务端启动\n./echo_server -task_group_ntags 3 -tag1 0 -tag2 1 -bthread_concurrency 20 -bthread_min_concurrency 8 -event_dispatcher_num 1\n\n客户端启动\n./echo_client -dummy_port 8888 -server \"0.0.0.0:8002\" -use_bthread true\n./echo_client -dummy_port 8889 -server \"0.0.0.0:8003\" -use_bthread true\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Compiler Flags for Performance and Debugging\nDESCRIPTION: Configures compiler flags for optimized builds with debug information. Enables CPU profiling for brpc and sets various warning flags.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n```\n\n----------------------------------------\n\nTITLE: Disabling HTTP Body to Protobuf Conversion in brpc Service - C++\nDESCRIPTION: This C++ snippet configures a brpc::ServiceOptions object to disable automatic conversion of HTTP/h2 request bodies to protobuf requests by setting allow_http_body_to_pb to false. The service is then added to the brpc server with these customized options. This is required for legacy or custom-handling services that process HTTP requests manually instead of via protobuf. Dependencies include the brpc library, and usage of cntl->request_protocol() is relevant for further processing.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nbrpc::ServiceOptions svc_opt;\nsvc_opt.ownership = ...;\nsvc_opt.restful_mappings = ...;\nsvc_opt.allow_http_body_to_pb = false; // turn off conversion from http/h2 body to pb request\nserver.AddService(service, svc_opt);\n```\n\n----------------------------------------\n\nTITLE: Redis Performance Benchmarking with 200 Threads in brpc\nDESCRIPTION: Performance benchmark of Redis server using 200 bthreads synchronously. Shows peak QPS performance with higher latency due to request batching via single connection.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ ./client -use_bthread -thread_num 200\nTRACE: 02-13 19:43:48:   * 0 client.cpp:180] Accessing redis server at qps=411669 latency=483\nTRACE: 02-13 19:43:49:   * 0 client.cpp:180] Accessing redis server at qps=411679 latency=483\nTRACE: 02-13 19:43:50:   * 0 client.cpp:180] Accessing redis server at qps=412583 latency=482\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting HTTP Query Strings in brpc - C++\nDESCRIPTION: Demonstrates accessing and modifying query string parameters through brpc's HTTP APIs. Retrieves values by key and sets them with 'SetQuery'. Handles cases where the key exists but has an empty value, making it suitable for presence flags. Dependencies: brpc, valid Controller pointer and uri methods.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/http_service.md#_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nconst std::string* time_value = cntl->http_request().uri().GetQuery(\"time\");\nif (time_value != NULL) {  // the query string is present\n    LOG(TRACE) << \"time = \" << *time_value;\n}\n\n...\ncntl->http_request().uri().SetQuery(\"time\", \"2015/1/2\");\n```\n\n----------------------------------------\n\nTITLE: Protobuf Configuration and Dependency Finding in CMake\nDESCRIPTION: Sets up Protobuf generation and searches for required dependencies including ThreadsS, Protobuf, thrift, brpc, and gflags. This section establishes the core dependencies needed for the RDMA performance testing application.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rdma_performance/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER test.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n```\n\n----------------------------------------\n\nTITLE: Generating GPG Fingerprint - Bash\nDESCRIPTION: Prints the fingerprint of the specified GPG key for secure distribution and publication. The user ID must match your key. The fingerprint is manually pasted into your Apache user profile.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngpg --fingerprint lorinlee # user id\n```\n\n----------------------------------------\n\nTITLE: Basic Streaming Log Usage in C++\nDESCRIPTION: Examples of basic logging statements with different severity levels and conditional logging. Shows usage of LOG, LOG_IF, and PLOG macros.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/streaming_log.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <butil/logging.h>\n\nLOG(FATAL) << \"Fatal error occurred! contexts=\" << ...;\nLOG(WARNING) << \"Unusual thing happened ...\" << ...;\nLOG(TRACE) << \"Something just took place...\" << ...;\nLOG(TRACE) << \"Items:\" << noflush;\nLOG_IF(NOTICE, n > 10) << \"This log will only be printed when n > 10\";\nPLOG(FATAL) << \"Fail to call function setting errno\";\nVLOG(1) << \"verbose log tier 1\";\nCHECK_GT(1, 2) << \"1 can't be greater than 2\";\n\nLOG_EVERY_SECOND(INFO) << \"High-frequent logs\";\nLOG_EVERY_N(ERROR, 10) << \"High-frequent logs\";\nLOG_FIRST_N(INFO, 20) << \"Logs that prints for at most 20 times\";\nLOG_ONCE(WARNING) << \"Logs that only prints once\";\n```\n\n----------------------------------------\n\nTITLE: Configuring Protobuf and Threading in CMake for RPC Echo Example\nDESCRIPTION: Includes necessary CMake modules, generates C++ files from Protobuf, and sets up include directories for the generated files.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rpcz_echo_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Redis Performance Benchmarking with 50 Threads in brpc\nDESCRIPTION: Performance benchmark of Redis server using 50 bthreads synchronously. Shows significantly higher QPS and increased latency compared to single thread.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ ./client -use_bthread -thread_num 50\nTRACE: 02-13 19:42:54:   * 0 client.cpp:180] Accessing redis server at qps=301212 latency=164\nTRACE: 02-13 19:42:55:   * 0 client.cpp:180] Accessing redis server at qps=301203 latency=164\nTRACE: 02-13 19:42:56:   * 0 client.cpp:180] Accessing redis server at qps=302158 latency=164\n```\n\n----------------------------------------\n\nTITLE: Using bthread Local Storage APIs for Per-Thread Data (C++)\nDESCRIPTION: This interface definition block introduces the main bthread local storage functions: bthread_key_create, bthread_key_delete, bthread_setspecific, and bthread_getspecific. These APIs allow creating, deleting, setting, and getting per-bthread or per-pthread variables, similar to pthread equivalents. A destructor function can be registered for cleanup. Intended for use with brpc and bthread-enabled threads; improper use or deleting keys prematurely may result in memory leaks.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\n// Create a key value identifying a slot in a thread-specific data area.\n// Each thread maintains a distinct thread-specific data area.\n// `destructor', if non-NULL, is called with the value associated to that key\n// when the key is destroyed. `destructor' is not called if the value\n// associated is NULL when the key is destroyed.\n// Returns 0 on success, error code otherwise.\nextern int bthread_key_create(bthread_key_t* key, void (*destructor)(void* data));\n \n// Delete a key previously returned by bthread_key_create().\n// It is the responsibility of the application to free the data related to\n// the deleted key in any running thread. No destructor is invoked by\n// this function. Any destructor that may have been associated with key\n// will no longer be called upon thread exit.\n// Returns 0 on success, error code otherwise.\nextern int bthread_key_delete(bthread_key_t key);\n \n// Store `data' in the thread-specific slot identified by `key'.\n// bthread_setspecific() is callable from within destructor. If the application\n// does so, destructors will be repeatedly called for at most\n// PTHREAD_DESTRUCTOR_ITERATIONS times to clear the slots.\n// NOTE: If the thread is not created by brpc server and lifetime is\n// very short(doing a little thing and exit), avoid using bthread-local. The\n// reason is that bthread-local always allocate keytable on first call to\n// bthread_setspecific, the overhead is negligible in long-lived threads,\n// but noticeable in shortly-lived threads. Threads in brpc server\n// are special since they reuse keytables from a bthread_keytable_pool_t\n// in the server.\n// Returns 0 on success, error code otherwise.\n// If the key is invalid or deleted, return EINVAL.\nextern int bthread_setspecific(bthread_key_t key, void* data);\n \n// Return current value of the thread-specific slot identified by `key'.\n// If bthread_setspecific() had not been called in the thread, return NULL.\n// If the key is invalid or deleted, return NULL.\nextern void* bthread_getspecific(bthread_key_t key);\n\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags and C++ Standard\nDESCRIPTION: Configures compiler flags for optimization and warnings, sets C++11 standard based on CMake version and compiler type.\nSOURCE: https://github.com/apache/brpc/blob/master/example/cancel_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Using bvar::Miner to Track Minimum Value in Multi-Dimensional Metrics (C++)\nDESCRIPTION: This example shows bvar::Miner<int> for recording the minimum value seen for a given label combination in a multi-dimensional metric. Values are fed and the minimum is checked, with pointer access restrictions as before. This usage is appropriate for minimum statistics in monitoring scenarios.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_16\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Miner<int> > g_request_cost(\"request_cost\", {\"idc\", \"method\", \"status\"});\n\nint request_cost_min(const std::list<std::string>& request_labels) {\n    // \\u83b7\\u53d6request\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6mbvar\\u6307\\u9488\\uff0c\\u5047\\u8bberequest_labels = {\"tc\", \"get\", \"200\"}\n    bvar::Miner<int>* cost_min = g_request_cost.get_stats(request_labels);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!cost_min) {\n        return -1;\n    }\n\n    // cost_min\\u53ea\\u80fd\\u5728g_request_cost\\u751f\\u547d\\u5468\\u671f\\u5185\\u8bbf\\u95ee\\uff0c\\u5426\\u5219\\u884c\\u4e3a\\u672a\\u5b9a\\u4e49\\uff0c\\u53ef\\u80fd\\u4f1a\\u51facore\n    *cost_min << 1 << 2 << 3 << 4;\n    CHECK_EQ(1, cost_min->get_value());\n    return cost_min->get_value();\n}\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Service Description with brpc::Describable in C++\nDESCRIPTION: This snippet demonstrates how to implement a service class in C++ that customizes the description shown in the brpc /status endpoint by inheriting from brpc::Describable. By overriding the Describe method, developers can include additional status or custom logic in the output. Dependencies include brpc and a service base class (placeholder 'XXXService'). The Describe method receives an output stream and a DescribeOptions structure, and should insert the desired string or stats. This approach allows for flexible runtime information display about the current server or service instance.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/status.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nclass MyService : public XXXService, public brpc::Describable {\npublic:\n    ...\n    void Describe(std::ostream& os, const brpc::DescribeOptions& options) const {\n        os << \"my_status: blahblah\";\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Redis CLI Demo in brpc\nDESCRIPTION: Example usage of the brpc Redis command line interface. Shows various Redis commands like mset, mget, incrby, and client operations similar to the official Redis CLI.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ ./redis_cli \n     __          _     __\n    / /_  ____ _(_)___/ /_  __      _________  _____\n   / __ \\/ __ `/ / __  / / / /_____/ ___/ __ \\/ ___/\n  / /_/ / /_/ / / /_/ / /_/ /_____/ /  / /_/ / /__  \n /_.___/\\__,_/_/\\__,_/\\__,_/     /_/  / .___/\\___/  \n                                     /_/            \nThis command-line tool mimics the look-n-feel of official redis-cli, as a \ndemostration of brpc's capability of talking to redis server. The \noutput and behavior is not exactly same with the official one.\n \nredis 127.0.0.1:6379> mset key1 foo key2 bar key3 17\nOK\nredis 127.0.0.1:6379> mget key1 key2 key3\n[\"foo\", \"bar\", \"17\"]\nredis 127.0.0.1:6379> incrby key3 10\n(integer) 27\nredis 127.0.0.1:6379> client setname brpc-cli\nOK\nredis 127.0.0.1:6379> client getname\n\"brpc-cli\"\n```\n\n----------------------------------------\n\nTITLE: Querying Exposed Multi-Dimensional Metric Variable Names with bvar in C++\nDESCRIPTION: This code demonstrates how to declare and use global multi-dimensional mbvar variables and how to retrieve names of all exposed metrics by calling MVariable::list_exposed. It shows the setup, the check on the names container, and asserts the result count. Dependencies include bvar/bvar.h and bvar/multi_dimension.h. Inputs are nullptr or a vector<string> pointer; output is the number of variable names. Names are cleared and populated by the method.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u4e2a\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\n\n// \\u5b9a\\u4e49\\u53e6\\u4e00\\u4e2a\\u5168\\u5c40\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_psmi_count(\"psmi_count\", {\"product\", \"system\", \"module\", \"interface\"});\n\nsize_t mbvar_list_exposed(std::vector<std::string>* names) {\n    if (!names) {\n        return -1;\n    }\n\n    // clear\n    names.clear();\n    bvar::MVariable::list_exposed(names);\n    // names\\uff1a[ \"request_count\", \"psmi_count\" ]\n    CHECK_EQ(2, names->size());\n    return names->size();\n}\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project Configuration for bRPC Cancel Example\nDESCRIPTION: Sets up basic CMake project configuration including minimum version, project name, and dynamic linking option.\nSOURCE: https://github.com/apache/brpc/blob/master/example/cancel_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(cancel_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Copying and Installing Header Files in CMake for Apache brpc\nDESCRIPTION: Copies header files from build and source directories to the output directory, then installs them to the specified include directory. This ensures that all necessary headers are available for both building and using the library.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nfile(COPY ${CMAKE_CURRENT_BINARY_DIR}/brpc/\n        DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/output/include/brpc/\n        FILES_MATCHING\n        PATTERN \"*.h\"\n        PATTERN \"*.hpp\"\n        )\nfile(COPY ${PROJECT_SOURCE_DIR}/src/\n        DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/output/include/\n        FILES_MATCHING\n        PATTERN \"*.h\"\n        PATTERN \"*.hpp\"\n        )\ninstall(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/output/include/\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n        FILES_MATCHING\n        PATTERN \"*.h\"\n        PATTERN \"*.hpp\"\n        )\n```\n\n----------------------------------------\n\nTITLE: Configuring Linker Flags in CMake - CMake - Shell\nDESCRIPTION: This code snippet demonstrates how to append a custom linker flag using the \\\"target_link_options\\\" or \\\"add_link_options\\\" commands in CMake. The line \\\"-Wl,-U,_malloc_stats_print\\\" tells the linker to leave the symbol _malloc_stats_print undefined, which is often used for debugging or instrumented builds. Dependencies: Requires CMake, and a suitable linker (e.g., GNU ld) that understands the -U flag. Parameters: None. Outputs: Adjusts linker behavior for targets defined after this line.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n\"-Wl,-U,_malloc_stats_print\"\n```\n\n----------------------------------------\n\nTITLE: Implementing brpc HTTP Service Logic - C++\nDESCRIPTION: Implements the brpc HTTP service logic in C++ by inheriting the generated service base class from the .proto file. The overridden Echo method extracts query string and body from the HTTP request, constructs a plain-text response, and writes it to the response attachment. It demonstrates key usage of brpc Controller, IOBufBuilder for composite outputs, and direct access to HTTP headers and attachments. No third-party dependencies besides brpc and protobuf are needed.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nclass HttpServiceImpl : public HttpService {\\npublic:\\n    ...\\n    virtual void Echo(google::protobuf::RpcController* cntl_base,\\n                      const HttpRequest* /*request*/,\\n                      HttpResponse* /*response*/,\\n                      google::protobuf::Closure* done) {\\n        brpc::ClosureGuard done_guard(done);\\n        brpc::Controller* cntl = static_cast<brpc::Controller*>(cntl_base);\\n \\n        // body\\u662f\\u7eaf\\u6587\\u672c\\n        cntl->http_response().set_content_type(\\\"text/plain\\\");\\n       \\n        // \\u628a\\u8bf7\\u6c42\\u7684query-string\\u548cbody\\u6253\\u5370\\u7ed3\\u679c\\u4f5c\\u4e3a\\u56de\\u590d\\u5185\\u5bb9\\u3002\\n        butil::IOBufBuilder os;\\n        os << \\\"queries:\\\";\\n        for (brpc::URI::QueryIterator it = cntl->http_request().uri().QueryBegin();\\n                it != cntl->http_request().uri().QueryEnd(); ++it) {\\n            os << ' ' << it->first << '=' << it->second;\\n        }\\n        os << \\\"\\\\nbody: \\\" << cntl->request_attachment() << '\\\\n';\\n        os.move_to(cntl->response_attachment());\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling NSHead+MCPack Protocol in brpc Server (C++)\nDESCRIPTION: Code snippet for enabling the NSHead+MCPack protocol in a brpc server. It requires including the nshead_mcpack_protocol header and setting the nshead_service option.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/server.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/policy/nshead_mcpack_protocol.h>\n...\nServerOptions options;\n...\noptions.nshead_service = new brpc::policy::NsheadMcpackAdaptor;\n```\n\n----------------------------------------\n\nTITLE: Declaring External bvar Variables in C++\nDESCRIPTION: Shows how to declare extern bvar variables in header files to use counters defined in another file. Notes that derived variables like Window and PerSecond don't need to be declared.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar_c++.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nnamespace foo {\nnamespace bar {\n// notice g_read_error_minute and g_task_pushed_second are derived bvar, will auto update, no need to declare\nextern bvar::Adder<int> g_read_error;\nextern bvar::LatencyRecorder g_write_latency;\nextern bvar::Adder<int> g_task_pushed;\n}  // bar\n}  // foo\n```\n\n----------------------------------------\n\nTITLE: Querying bvar Metrics via Shell Command - Shell\nDESCRIPTION: Demonstrates the use of curl in a shell environment to retrieve bvar statistics reported by a brpc server. Requires curl and access to the brpc server endpoint. This snippet queries bvars with names matching 'bthread*', printing a set of metrics such as counts and percentiles to the console for inspection. Input is the URL endpoint and output is a text-based summary of available bvar values. Replace the hostname as needed for your deployment.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/vars.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n```shell\\n$ curl brpc.baidu.com:8765/vars/bthread*\\nbthread_creation_count : 125134\\nbthread_creation_latency : 3\\nbthread_creation_latency_50 : 3\\nbthread_creation_latency_90 : 5\\nbthread_creation_latency_99 : 7\\nbthread_creation_latency_999 : 12\\nbthread_creation_latency_9999 : 12\\nbthread_creation_latency_cdf : \\\"click to view\\\"\\nbthread_creation_latency_percentiles : \\\"[3,5,7,12]\\\"\\nbthread_creation_max_latency : 7\\nbthread_creation_qps : 100\\nbthread_group_status : \\\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\\"\\nbthread_num_workers : 24\\nbthread_worker_usage : 1.01056\\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Empty HTTP Service Methods - Protocol Buffers - protobuf\nDESCRIPTION: Defines a simple HTTP service interface for brpc in a .proto file, with empty request and response messages. This pattern is required even if no actual protobuf data is used so that service declarations are centralized. The service and method names determine the accessible HTTP path. There are no parameters or fields; input and output are defined via HTTP attachments and headers within the brpc Controller.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_0\n\nLANGUAGE: protobuf\nCODE:\n```\noption cc_generic_services = true;\\n \\nmessage HttpRequest { };\\nmessage HttpResponse { };\\n \\nservice HttpService {\\n      rpc Echo(HttpRequest) returns (HttpResponse);\\n};\n```\n\n----------------------------------------\n\nTITLE: Apache bRPC Committer Development Process Documentation\nDESCRIPTION: Markdown documentation detailing the prerequisites and process for becoming a committer, including voting procedures, ICLA submission, and permission management.\nSOURCE: https://github.com/apache/brpc/blob/master/community/newcommitter_en.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Here is the doc for the process and reference website information of developing committee and PPMC members.\n\n## 1. How to develop committers\n\n### Preconditions\n\n1. More than 10 commits from the contributor\n2. Contributor is willing to accept the invitation to become a committer\n3. Contributor subscribe to dev@brpc.apache.org and introduce himself by sending an email to dev@apache.org\n```\n\n----------------------------------------\n\nTITLE: Adding Component Subdirectories with CMake - CMake\nDESCRIPTION: This set of commands incorporates multiple subproject directories (parallel_http, rpc_press, rpc_replay, rpc_view, trackme_server) into the build using CMake's add_subdirectory function. Each call tells CMake to process the corresponding CMakeLists.txt in the listed subdirectory, ensuring that each module is built as part of the overall project. Dependencies are the presence of valid subdirectories and corresponding CMakeLists.txt files, and each must be correctly structured for integration.\nSOURCE: https://github.com/apache/brpc/blob/master/tools/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(parallel_http)\nadd_subdirectory(rpc_press)\nadd_subdirectory(rpc_replay)\nadd_subdirectory(rpc_view)\nadd_subdirectory(trackme_server)\n```\n\n----------------------------------------\n\nTITLE: Enabling Public PBRPC Protocol in brpc Server (C++)\nDESCRIPTION: Code snippet for enabling the Public PBRPC protocol in a brpc server. It requires including the public_pbrpc_protocol header and setting the nshead_service option.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/server.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/policy/public_pbrpc_protocol.h>\n...\nServerOptions options;\n...\noptions.nshead_service = new brpc::policy::PublicPbrpcServiceAdaptor;\n```\n\n----------------------------------------\n\nTITLE: Listing All Label Combinations of a Multi-Dimensional Metric with bvar in C++\nDESCRIPTION: This example demonstrates how to enumerate all currently allocated label combinations (stats) in a multi-dimensional metric using list_stats. It first ensures that at least two stats are created, then retrieves combinations into a vector. Frequent calls may affect write performance. The function accepts a pointer to a vector of list<string> and returns the number of label combinations found.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_13\n\nLANGUAGE: c++\nCODE:\n```\n#include <bvar/bvar.h>\n#include <bvar/multi_dimension.h>\n\nnamespace foo {\nnamespace bar {\n// \\u5b9a\\u4e49\\u4e00\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\n\nsize_t list_stats(std::vector<std::list<std::string> > *stats_names) {\n    if (!stats_names) {\n        return -1;\n    }\n\n    // clear\n    stats_names.clear();\n\n    // \\u83b7\\u53d6request1\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6mbvar\\u6307\\u9488\\uff0c\\u5047\\u8bberequest1_labels = {\"tc\", \"get\", \"200\"}\n    bvar::Adder<int> *request1_adder = g_request_count.get_stats(request1_labels);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!request1_adder) {\n        return -1;\n    }\n\n    // \\u83b7\\u53d6request2\\u5bf9\\u5e94\\u7684\\u5355\\u7ef4\\u5ea6mbvar\\u6307\\u9488\\uff0c\\u5047\\u8bberequest2_labels = {\"nj\", \"get\", \"200\"}\n    bvar::Adder<int> *request2_adder = g_request_count.get_stats(request2_labels);\n    // \\u5224\\u65ad\\u6307\\u9488\\u975e\\u7a7a\n    if (!request2_adder) {\n        return -1;\n    }\n\n    g_request_count.list_stats(stats_names);\n    // labels_names\\uff1a\n    // [\n    //      {\"tc\", \"get\", \"200\"},\n    //      {\"nj\", \"get\", \"200\"}\n    // ]\n\n    CHECK_EQ(2, stats_names.size());\n    return stats_names.size();\n}\n\n} // namespace bar\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Installing Profiler Tools for brpc Examples on MacOS\nDESCRIPTION: Command for installing Google perftools on MacOS to enable CPU and heap profilers in brpc examples.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\nbrew install gperftools\n```\n\n----------------------------------------\n\nTITLE: Adding Executable and Linking Libraries - CMake - CMake\nDESCRIPTION: Defines how to add the 'parallel_http' executable target from 'parallel_http.cpp', link it against the 'brpc-static' and '${DYNAMIC_LIB}' libraries, and install it to the appropriate binary directory. This snippet requires CMake and the availability of source file and library dependencies. Key parameters include the output target ('parallel_http'), source file, linked libraries, and the runtime installation directory. The snippet does not handle build-time configuration or validation of external dependencies, which must be defined elsewhere.\nSOURCE: https://github.com/apache/brpc/blob/master/tools/parallel_http/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(parallel_http parallel_http.cpp)\ntarget_link_libraries(parallel_http brpc-static ${DYNAMIC_LIB})\ninstall(TARGETS parallel_http RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Redis Performance Benchmarking with Pooled Connections\nDESCRIPTION: Performance benchmark using 50 bthreads with pooled connections. Shows significantly lower QPS compared to single connection due to increased I/O operations.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ ./client -use_bthread -connection_type pooled\nTRACE: 02-13 18:07:40:   * 0 client.cpp:180] Accessing redis server at qps=75986 latency=654\nTRACE: 02-13 18:07:41:   * 0 client.cpp:180] Accessing redis server at qps=75562 latency=655\nTRACE: 02-13 18:07:42:   * 0 client.cpp:180] Accessing redis server at qps=75238 latency=657\n \n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n16878 gejun     20   0 48136 2520 1004 R 99.9  0.0   9:52.33 redis-server\n```\n\n----------------------------------------\n\nTITLE: Configuring BRPC Selective Echo Example with CMake - CMake\nDESCRIPTION: This CMake script configures and builds the selective_echo_c++ example by discovering third-party dependencies (like BRPC, Protobuf, Thrift, LevelDB, GFlags, GPerfTools) and handling platform-specific flags for compilation and linking. It generates Protobuf code, sets the C++11 standard, and creates client and server executables, applying appropriate linking options for Linux and macOS. Prerequisites are CMake 2.8.10+, a C++ compiler, and pre-installed dependency libraries. The script accepts the LINK_SO option to specify dynamic linking, expects the echo.proto definition, and outputs selective_echo_client/server binaries, halting on any missing required dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/example/selective_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\ncmake_minimum_required(VERSION 2.8.10)\nproject(selective_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \".*output/include$\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(GPERFTOOLS_INCLUDE_DIR NAMES gperftools/heap-profiler.h)\nfind_library(GPERFTOOLS_LIBRARIES NAMES tcmalloc_and_profiler)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(selective_echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(selective_echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(selective_echo_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(selective_echo_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project Settings\nDESCRIPTION: Sets up basic CMake project configuration including minimum version, project name and languages.\nSOURCE: https://github.com/apache/brpc/blob/master/example/parallel_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(parallel_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Cutting Data from IOBuf in C++\nDESCRIPTION: Examples of cutting bytes from an IOBuf either to another buffer or discarding them.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/iobuf.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nsource_buf.cut(&dest_buf, 16);\n```\n\nLANGUAGE: c++\nCODE:\n```\nsource_buf.pop_front(16);\n```\n\n----------------------------------------\n\nTITLE: Running DynamicPartitionChannel Client and Interpreting Trace Logs (Bash)\nDESCRIPTION: This snippet shows how to start the echo_client, which uses the DynamicPartitionChannel to discover servers and send requests. Trace logs display the discovery of addresses from server_list, socket connections, and request statistics such as QPS (queries per second) and latency. This is used to validate correct client function and observe load distribution in real-time.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ ./echo_client            \nTRACE: 09-06 10:51:10:   * 0 src/brpc/policy/file_naming_service.cpp:83] Got 3 unique addresses from `server_list'\nTRACE: 09-06 10:51:10:   * 0 src/brpc/socket.cpp:779] Connected to 0.0.0.0:8004 via fd=3 SocketId=0 self_port=46544\nTRACE: 09-06 10:51:11:   * 0 client.cpp:226] Sending EchoRequest at qps=132472 latency=371\nTRACE: 09-06 10:51:12:   * 0 client.cpp:226] Sending EchoRequest at qps=132658 latency=370\nTRACE: 09-06 10:51:13:   * 0 client.cpp:226] Sending EchoRequest at qps=133208 latency=369\n```\n\n----------------------------------------\n\nTITLE: Counting All Exposed mbvar Variables Using bvar::MVariable::count_exposed in C++\nDESCRIPTION: This example illustrates the use of the static method count_exposed from bvar::MVariable to retrieve the total number of currently exposed (global) mbvar multi-dimensional variables. It demonstrates creation of several MultiDimension variables, followed by a call to count_exposed, comparing the result against the expected number using a check macro. Prerequisites include inclusion of bvar and multi_dimension headers and linking to the brpc infrastructure. Suitable for diagnostic or monitoring code.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/mbvar_c++.md#_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#include <bvar/bvar.h>\\n#include <bvar/multi_dimension.h>\\n\\nnamespace foo {\\nnamespace bar {\\n// \\u5b9a\\u4e49\\u4e00\\u4e2a\\u5168\\u5c40\\u7684\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\\nbvar::MultiDimension<bvar::Adder<int> > g_request_count(\"request_count\", {\"idc\", \"method\", \"status\"});\\n\\n// \\u5b9a\\u4e49\\u53e6\\u4e00\\u4e2a\\u5168\\u5c40\\u591a\\u7ef4\\u5ea6mbvar\\u53d8\\u91cf\\nbvar::MultiDimension<bvar::Adder<int> > g_psmi_count(\"psmi_count\", {\"product\", \"system\", \"module\", \"interface\"});\\n\\nsize_t count_exposed() {\\n    size_t mbvar_count_exposed = bvar::MVariable::count_exposed();\\n    CHECK_EQ(2, mbvar_count_exposed);\\n    return mbvar_count_exposed;\\n}\\n\\n} // namespace bar\\n} // namespace foo\n```\n\n----------------------------------------\n\nTITLE: Compiling brpc on MacOS Using config_brpc.sh\nDESCRIPTION: Commands for building brpc on MacOS using the config_brpc.sh script with clang compiler and specifying paths to headers and libraries installed by Homebrew.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_24\n\nLANGUAGE: shell\nCODE:\n```\n$ sh config_brpc.sh --headers=/usr/local/include --libs=/usr/local/lib --cc=clang --cxx=clang++\n$ make\n```\n\n----------------------------------------\n\nTITLE: Waiting for Multiple RPC Completions in C++\nDESCRIPTION: Demonstrates how to wait for multiple asynchronous RPC calls to complete using Join() method.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\nconst brpc::CallId cid1 = controller1->call_id();\nconst brpc::CallId cid2 = controller2->call_id();\n...\nstub.method1(controller1, request1, response1, done1);\nstub.method2(controller2, request2, response2, done2);\n...\nbrpc::Join(cid1);\nbrpc::Join(cid2);\n```\n\n----------------------------------------\n\nTITLE: Dependency Configuration and Checks\nDESCRIPTION: Sets up and validates required dependencies including Protobuf, bRPC, gflags, leveldb, and OpenSSL.\nSOURCE: https://github.com/apache/brpc/blob/master/example/baidu_proxy_and_generic_call/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Output Path Configuration and Protobuf Generation\nDESCRIPTION: Configures output path and generates C++ files from protobuf definitions. Sets up include directories for generated files.\nSOURCE: https://github.com/apache/brpc/blob/master/example/asynchronous_echo_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Flags and C++ Standard\nDESCRIPTION: Sets compiler flags for different platforms and ensures C++11 support across different CMake versions and compilers.\nSOURCE: https://github.com/apache/brpc/blob/master/example/redis_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Handling MacOS-specific Clock Functions\nDESCRIPTION: Checks for clock_gettime function availability on MacOS systems. Defines a preprocessor macro if the function is not available.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project and Basic Settings\nDESCRIPTION: Sets up the CMake project with minimum version requirement and project name. Includes option for dynamic linking.\nSOURCE: https://github.com/apache/brpc/blob/master/example/backup_request_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(backup_request_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Partial Partition Removal in Server List (text config)\nDESCRIPTION: This snippet illustrates the commented-out line in server_list to simulate removal of a partition (e.g., 2/3 for 3-partition method). Such changes are detected by the client, which adjusts traffic accordingly—capacity drops to zero for incomplete partition sets. Used for demonstrating safe and incremental deprecation of old partitions.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_16\n\nLANGUAGE: text\nCODE:\n```\n 0.0.0.0:8004  0/3\n 0.0.0.0:8004  1/3\n#0.0.0.0:8004  2/3\n \n 0.0.0.0:8005  0/4   \n 0.0.0.0:8005  1/4   \n 0.0.0.0:8005  2/4   \n 0.0.0.0:8005  3/4    \n \n 0.0.0.0:8006 0/4\n 0.0.0.0:8006 1/4\n 0.0.0.0:8006 2/4\n 0.0.0.0:8006 3/4\n```\n\n----------------------------------------\n\nTITLE: Building Client and Server Executables in CMake\nDESCRIPTION: Creates the client and server executables for the RDMA performance test. Links them with the brpc library and all the dynamic libraries defined earlier, including protocol buffer generated sources.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rdma_performance/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(server ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: Adding MacOS-specific Libraries and Linker Flags\nDESCRIPTION: Adds additional libraries and linker flags specifically for MacOS builds, including frameworks and undefined symbol references for profiling.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Flags and C++ Standard\nDESCRIPTION: Sets up compiler flags for different compilers and ensures C++11 standard is used based on CMake version.\nSOURCE: https://github.com/apache/brpc/blob/master/example/backup_request_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Libraries and Platform-Specific Settings\nDESCRIPTION: Sets up dynamic library dependencies and includes platform-specific library configurations for Darwin/MacOS systems.\nSOURCE: https://github.com/apache/brpc/blob/master/example/session_data_and_thread_local/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding and Configuring Dependencies in CMake for RPC Echo Example\nDESCRIPTION: Locates and configures various dependencies including Thrift, brpc, gflags, LevelDB, and OpenSSL. Sets up include paths and library variables.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rpcz_echo_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Listing GPG Keys - Bash\nDESCRIPTION: Lists all public keys available in the local user's GPG keyring. Use this command to verify key creation, fetch key IDs, and confirm trust status. It requires GPG to be installed.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngpg --list-keys\n```\n\n----------------------------------------\n\nTITLE: Installing brpc Dependencies on Fedora/CentOS\nDESCRIPTION: Command for installing specific dependencies needed by brpc including gflags, protobuf, and leveldb on Fedora or CentOS systems.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nsudo yum install gflags-devel protobuf-devel protobuf-compiler leveldb-devel\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Libraries and Platform-Specific Linking in CMake\nDESCRIPTION: Sets up the dynamic libraries for linking, with special handling for MacOS-specific frameworks and symbols. Includes thread libraries, protocol buffers, crypto libraries, and other dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rdma_performance/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Output Path Configuration\nDESCRIPTION: Executes bash command to find and set output path for the project build artifacts.\nSOURCE: https://github.com/apache/brpc/blob/master/example/baidu_proxy_and_generic_call/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Request Body in brpc\nDESCRIPTION: Shows how to set the HTTP request body. The body can be set directly by appending to request_attachment() or by using IOBufBuilder for more complex content.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\ncntl->request_attachment().append(\"....\");\nbutil::IOBufBuilder os;\nos << \"....\";\nos.move_to(cntl->request_attachment());\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags and C++ Standard in CMake for RPC Echo Example\nDESCRIPTION: Configures compiler flags for the project, including optimization levels and warnings. Sets the C++11 standard based on CMake version and compiler type.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rpcz_echo_c++/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing Profiler Tools for brpc Examples on Ubuntu\nDESCRIPTION: Command to install Google perftools for enabling CPU and heap profilers in brpc examples on Ubuntu-based systems.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get install -y libgoogle-perftools-dev\n```\n\n----------------------------------------\n\nTITLE: Compiler Flags and C++ Standard Configuration in CMake\nDESCRIPTION: Sets up compiler flags including RDMA support, optimization levels, and warning settings. Configures the C++11 standard requirements based on the CMake version and compiler being used.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rdma_performance/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CPP_FLAGS \"${DEFINE_CLOCK_GETTIME} -DBRPC_WITH_RDMA=1\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CPP_FLAGS} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Implementing ostream Operators for Nested Types in C++\nDESCRIPTION: Shows how to implement ostream operators for nested types B and C used in the previous example.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_log.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nstruct B {\n    int value;\n};\nstd::ostream& operator<<(std::ostream& os, const B& b) {\n    return os << \"B{value=\" << b.value << \"}\";\n}\n\nstruct C {\n    string name;\n};\nstd::ostream& operator<<(std::ostream& os, const C& c) {\n    return os << \"C{name=\" << c.name << \"}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Libraries for Linking\nDESCRIPTION: Sets up a list of dynamic libraries to be linked with the executables, including system-specific libraries for macOS.\nSOURCE: https://github.com/apache/brpc/blob/master/example/grpc_c++/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n```\n\n----------------------------------------\n\nTITLE: Building RPC View Tool with CMake and Protobuf\nDESCRIPTION: This CMake snippet configures the build process for the rpc_view tool. It generates C++ files from a Protobuf definition, creates an executable from the source files, links required libraries, and sets up installation configuration. The build depends on the FindProtobuf CMake module and the brpc static library.\nSOURCE: https://github.com/apache/brpc/blob/master/tools/rpc_view/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER view.proto)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\nadd_executable(rpc_view rpc_view.cpp ${PROTO_SRC})\ntarget_link_libraries(rpc_view brpc-static ${DYNAMIC_LIB})\ninstall(TARGETS rpc_view RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking Executables for RPC Echo Example in CMake\nDESCRIPTION: Defines the client and server executables, specifying their source files and linking them with the required libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rpcz_echo_c++/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(rpcz_echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(rpcz_echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(rpcz_echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(rpcz_echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: Custom Object Streaming Implementation in C++\nDESCRIPTION: Shows how to implement streaming operators for custom objects to enable logging of complex data structures\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/streaming_log.md#_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nstd::ostream& operator<<(std::ostream& os, const A& a);\n```\n\n----------------------------------------\n\nTITLE: Using IOBufBuilder for HTTP POST Request Body\nDESCRIPTION: Demonstrates using butil::IOBufBuilder for more efficient creation of HTTP POST request bodies. This approach is similar to std::ostringstream but can be more efficient for complex data or large outputs.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nbrpc::Controller cntl;\ncntl.http_request().uri() = \"...\";  // 设置为待访问的URL\ncntl.http_request().set_method(brpc::HTTP_METHOD_POST);\nbutil::IOBufBuilder os;\nos << \"A lot of printing\" << printable_objects << ...;\nos.move_to(cntl.request_attachment());\nchannel.CallMethod(NULL, &cntl, NULL, NULL, NULL/*done*/);\n```\n\n----------------------------------------\n\nTITLE: Checking Out Apache SVN Directory - Bash\nDESCRIPTION: Initializes and checks out the Apache distribution SVN directory for brpc to a local working copy. User must authenticate with their Apache LDAP username. Used during the artifact publication phase.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/brpc_svn/dev/\\n\\ncd ~/brpc_svn/dev/\\n\\nsvn --username=lorinlee co https://dist.apache.org/repos/dist/dev/brpc/\\n\\ncd ~/brpc_svn/dev/brpc\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing pkgconfig File in CMake for Apache brpc\nDESCRIPTION: Generates a pkgconfig file from a template and installs it to the appropriate directory. This allows other projects to easily find and link against the brpc library using pkg-config.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(cmake/brpc.pc.in ${PROJECT_BINARY_DIR}/brpc.pc @ONLY)\ninstall(FILES ${PROJECT_BINARY_DIR}/brpc.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n```\n\n----------------------------------------\n\nTITLE: Listing and Tail Viewing bvar Monitor Data Files - Shell\nDESCRIPTION: This shell snippet demonstrates how to list bvar monitoring data files and preview the last few lines of a client's monitor output using standard Unix commands. It assumes that the bvar dump feature is enabled and output files exist under the 'monitor/' directory, as produced by brpc in metric exporting mode. The 'ls' command lists available monitoring files, while the 'tail' command displays the concluding content of a bvar data file, typically formatted as variable name and value per line; paths and filenames may differ per deployment.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ ls monitor/\nbvar.echo_client.data  bvar.echo_server.data\n \n$ tail -5 monitor/bvar.echo_client.data\nprocess_swaps : 0\nprocess_time_real : 2580.157680\nprocess_time_system : 0.380942\nprocess_time_user : 0.741887\nprocess_username : \"gejun\"\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Project Settings and Dependencies\nDESCRIPTION: Sets up the basic CMake project configuration, defines dependency requirements, and configures include paths for various libraries including brpc, gflags, leveldb, and OpenSSL.\nSOURCE: https://github.com/apache/brpc/blob/master/example/redis_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(redis_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\n```\n\n----------------------------------------\n\nTITLE: Finding Thrift Library in CMake\nDESCRIPTION: Searches for libthrift library, which is optional. If not found, an empty string is set for THRIFT_LIB to avoid build errors if brpc is not compiled with thrift protocol support.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Listing Provided bvar Process/System Stats in brpc - Plaintext\nDESCRIPTION: This snippet displays sample process-level and system-level variable outputs provided by brpc via bvar, showing the variable names and their current values as presented in metric dumps or query endpoints. No dependencies are required to read this output, but the data depends on a running brpc server exporting bvar statistics. The snippet is intended to demonstrate output formatting and nomenclature for bvar-provided process and system metrics, with each line containing a counter name and an associated value.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nprocess_context_switches_involuntary_second : 14\nprocess_context_switches_voluntary_second : 15760\nprocess_cpu_usage : 0.428\nprocess_cpu_usage_system : 0.142\nprocess_cpu_usage_user : 0.286\nprocess_disk_read_bytes_second : 0\nprocess_disk_write_bytes_second : 260902\nprocess_faults_major : 256\nprocess_faults_minor_second : 14\nprocess_memory_resident : 392744960\nsystem_core_count : 12\nsystem_loadavg_15m : 0.040\nsystem_loadavg_1m : 0.000\nsystem_loadavg_5m : 0.020\n```\n\n----------------------------------------\n\nTITLE: Thrift Version Check Function\nDESCRIPTION: Function to check Thrift version and set appropriate compiler definitions if version is below 0.11.0\nSOURCE: https://github.com/apache/brpc/blob/master/src/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(check_thrift_version target_arg)\n    execute_process(\n        COMMAND thrift --version\n        OUTPUT_VARIABLE THRIFT_VERSION_OUTPUT\n        ERROR_QUIET\n        OUTPUT_STRIP_TRAILING_WHITESPACE\n    )\n\n    string(REGEX MATCH \"[0-9]+\\\\.[0-9]+\\\\.[0-9]+\" THRIFT_VERSION ${THRIFT_VERSION_OUTPUT})\n    string(REGEX REPLACE \"\\\\.\" \";\" THRIFT_VERSION_LIST ${THRIFT_VERSION})\n\n    list(GET THRIFT_VERSION_LIST 0 THRIFT_MAJOR_VERSION)\n    list(GET THRIFT_VERSION_LIST 1 THRIFT_MINOR_VERSION)\n\n    if (THRIFT_MAJOR_VERSION EQUAL 0 AND THRIFT_MINOR_VERSION LESS 11)\n        message(STATUS \"Thrift version is less than 0.11.0\")\n        target_compile_definitions($(target_arg) PRIVATE _THRIFT_VERSION_LOWER_THAN_0_11_0_)\n    else()\n        message(STATUS \"Thrift version is equal to or greater than 0.11.0\")\n    endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Using NsHead Message with brpc\nDESCRIPTION: Example of using NsHead protocol directly in brpc to access legacy servers. The code initializes a channel with PROTOCOL_NSHEAD, creates request/response objects, appends message data to the request, and processes the response.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/ub_client.md#_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <brpc/nshead_message.h>\n...\n \nbrpc::Channel;\nbrpc::ChannelOptions opt;\nopt.protocol = brpc::PROTOCOL_NSHEAD; // or \"nshead\"\nif (channel.Init(..., &opt) != 0) {\n    LOG(ERROR) << \"Fail to init channel\";\n    return -1;\n} \n...\nbrpc::NsheadMessage request;\nbrpc::NsheadMessage response;\n       \n// Append message to `request'\nrequest.body.append(\"hello world\");\n// Set fields of the request nshead struct if needed\nrequest.head.version = 99;\n \n \nbrpc::Controller cntl;\nchannel.CallMethod(NULL, &cntl, &request, &response, NULL);\n \nif (cntl.Failed()) {\n    LOG(ERROR) << \"Fail to access the server: \" << cntl.ErrorText();\n    return -1;\n}\n// response.head and response.body contains nshead_t and blob respectively.\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic Libraries for Linking\nDESCRIPTION: Sets up a variable containing all required dynamic libraries for linking, including thread support, gflags, protobuf, leveldb, OpenSSL, and thrift.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n```\n\n----------------------------------------\n\nTITLE: Checking QPS with curl in Shell\nDESCRIPTION: A shell command to query QPS-related metrics from a brpc service using curl. This helps to verify if there's an uneven distribution of requests across servers.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server_debugging.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ curl brpc.baidu.com:8765/vars/*qps*\nbthread_creation_qps : 95\nrpc_server_8765_example_echo_service_echo_qps : 57\n```\n\n----------------------------------------\n\nTITLE: Adding More Servers for 4-Partition Method (text config)\nDESCRIPTION: This server_list expands the 4-partition strategy to include two hosts (0.0.0.0:8005 and 0.0.0.0:8006), mapping each partition across both. This configuration enables round-robin intra-partition load balancing. Targeted for demonstrating how adding nodes increases partition/channel capacity dynamically and evenly splits load.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/combo_channel.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n0.0.0.0:8004  0/3\n0.0.0.0:8004  1/3   \n0.0.0.0:8004  2/3 \n \n0.0.0.0:8005  0/4   \n0.0.0.0:8005  1/4   \n0.0.0.0:8005  2/4   \n0.0.0.0:8005  3/4    \n \n0.0.0.0:8006 0/4\n0.0.0.0:8006 1/4\n0.0.0.0:8006 2/4\n0.0.0.0:8006 3/4\n```\n\n----------------------------------------\n\nTITLE: Copying SSL Certificate Files to Binary Directory\nDESCRIPTION: Copies SSL certificate and key files to the build directory for HTTPS support in the example applications.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nfile(COPY ${PROJECT_SOURCE_DIR}/key.pem\n     DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nfile(COPY ${PROJECT_SOURCE_DIR}/cert.pem\n     DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Printing IOBuf Content in C++\nDESCRIPTION: Methods to print IOBuf contents to output streams or convert to string.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/iobuf.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nstd::cout << iobuf << std::endl;\n// or\nstd::string str = iobuf.to_string();\nprintf(\"%s\\n\", str.c_str());\n```\n\n----------------------------------------\n\nTITLE: Starting a Thrift Server in C++\nDESCRIPTION: C++ code snippet showing how to set up and start a brpc server that handles Thrift requests. This includes configuring ServerOptions with a Thrift service and starting the server on a specified port.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/thrift.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\n    brpc::Server server;\n    brpc::ServerOptions options;\n    options.thrift_service = new EchoServiceImpl;\n    options.idle_timeout_sec = FLAGS_idle_timeout_s;\n    options.max_concurrency = FLAGS_max_concurrency;\n\n    // Start the server.\n    if (server.Start(FLAGS_port, &options) != 0) {\n        LOG(ERROR) << \"Fail to start EchoServer\";\n        return -1;\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Thread Stack Size in BRPC\nDESCRIPTION: Commands to modify the default stack size for bthreads and control stack caching. Increases default 1MB stack size to 10MB and adjusts cache settings.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n--stack_size_normal=10000000  # sets stacksize to roughly 10MB\n--tc_stack_normal=1           # sets number of stacks cached by each worker pthread to prevent reusing from global pool each time, default value is 8\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Libraries and Platform-Specific Settings\nDESCRIPTION: Sets up dynamic library dependencies and platform-specific settings, particularly for Darwin/MacOS systems.\nSOURCE: https://github.com/apache/brpc/blob/master/example/cancel_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n```\n\n----------------------------------------\n\nTITLE: Configuring butil Test Target\nDESCRIPTION: Creates and configures the test_butil executable with appropriate source files and dependencies. Links against the brpc-shared-debug library, Google Test, and gperftools.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# test_butil\nadd_executable(test_butil ${TEST_BUTIL_SOURCES}\n                          ${CMAKE_CURRENT_BINARY_DIR}/iobuf.pb.cc)\ntarget_link_libraries(test_butil brpc-shared-debug\n                                 gtest\n                                 ${GPERFTOOLS_LIBRARIES})\n\nadd_test(NAME test_butil COMMAND test_butil)\n```\n\n----------------------------------------\n\nTITLE: Creating a New GPG Key - Bash\nDESCRIPTION: Initializes the interactive process to create a new GPG key pair with the user's Apache email and identity. The command will prompt the user for identity details, key type, key size, expiration, and a passphrase. GPG must be installed before using this command.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngpg --full-gen-key\n```\n\n----------------------------------------\n\nTITLE: Installing GnuPG Using Homebrew - Bash\nDESCRIPTION: Installs the GnuPG cryptographic suite using Homebrew package manager on OSX. This step is required for managing signing keys and creating GPG signatures during the release process. Requires Homebrew to be installed on the system.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew install gnupg\n```\n\n----------------------------------------\n\nTITLE: Building Shared Debug Library for brpc\nDESCRIPTION: Builds the shared debug version of the brpc library by combining object files from BUTIL, SOURCES, and PROTO libraries. Sets custom output directory and links required dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(brpc-shared-debug SHARED $<TARGET_OBJECTS:BUTIL_DEBUG_LIB>\n                                     $<TARGET_OBJECTS:SOURCES_DEBUG_LIB>\n                                     $<TARGET_OBJECTS:PROTO_LIB>)\n# change the debug lib output dir to be different from the release output\nset_target_properties(brpc-shared-debug PROPERTIES\n         LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/test)\n\ntarget_link_libraries(brpc-shared-debug ${DYNAMIC_LIB})\nif(BRPC_WITH_GLOG)\n    target_link_libraries(brpc-shared-debug ${GLOG_LIB})\nendif()\n```\n\n----------------------------------------\n\nTITLE: GPG Key Generation Console Output - Plain Text\nDESCRIPTION: Sample console output of the GPG key creation process, showing prompts and responses for choices such as key type, size, and user ID. Use this to understand what to expect when running the key generation command. Inputs include key type (e.g., RSA), key size (e.g., 4096), and user information such as name, email, and comment.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\ngpg (GnuPG) 2.3.1; Copyright (C) 2021 Free Software Foundation, Inc.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\nPlease select what kind of key you want:\\n   (1) RSA and RSA\\n   (2) DSA and Elgamal\\n   (3) DSA (sign only)\\n   (4) RSA (sign only)\\n   (9) ECC (sign and encrypt) *default*\\n  (10) ECC (sign only)\\n  (14) Existing key from card\\nYour selection? 1\\nRSA keys may be between 1024 and 4096 bits long.\\nWhat keysize do you want? (3072) 4096\\nRequested keysize is 4096 bits\\nPlease specify how long the key should be valid.\\n         0 = key does not expire\\n      <n>  = key expires in n days\\n      <n>w = key expires in n weeks\\n      <n>m = key expires in n months\\n      <n>y = key expires in n years\\nKey is valid for? (0) 0\\nKey does not expire at all\\nIs this correct? (y/N) y\\n\\nGnuPG needs to construct a user ID to identify your key.\\n\\nReal name: LorinLee\\nEmail address: lorinlee@apache.org\\nComment: lorinlee's key\\nYou selected this USER-ID:\\n    \"LorinLee (lorinlee's key) <lorinlee@apache.org>\"\\n\\nChange (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O\\nYou need a Passphrase to protect your secret key. # Input password\\n\\nWe need to generate a lot of random bytes. It is a good idea to perform\\nsome other action (type on the keyboard, move the mouse, utilize the\\ndisks) during the prime generation; this gives the random number\\ngenerator a better chance to gain enough entropy.\\ngpg: key 92E18A11B6585834 marked as ultimately trusted\\ngpg: revocation certificate stored as '/Users/lilei/.gnupg/openpgp-revocs.d/C30F211F071894258497F46392E18A11B6585834.rev'\\npublic and secret key created and signed.\\n\\npub   rsa4096 2021-10-17 [SC]\\n      C30F211F071894258497F46392E18A11B6585834\\nuid                      LorinLee (lorinlee's key) <lorinlee@apache.org>\\nsub   rsa4096 2021-10-17 [E]\n```\n\n----------------------------------------\n\nTITLE: Redis Performance Benchmarking with Batch Commands (Single Thread)\nDESCRIPTION: Performance benchmark using a single bthread with batch mode (10 commands per request). Shows QPS and latency metrics for batched operations.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/redis_client.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ ./client -use_bthread -thread_num 1 -batch 10  \nTRACE: 02-13 19:46:45:   * 0 client.cpp:180] Accessing redis server at qps=15880 latency=59\nTRACE: 02-13 19:46:46:   * 0 client.cpp:180] Accessing redis server at qps=16945 latency=57\nTRACE: 02-13 19:46:47:   * 0 client.cpp:180] Accessing redis server at qps=16728 latency=57\n```\n\n----------------------------------------\n\nTITLE: Checking GPG Version - Bash\nDESCRIPTION: Checks the installed GPG version to ensure GnuPG is available and installed correctly on the system. This command outputs version and copyright information.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngpg --version\n```\n\n----------------------------------------\n\nTITLE: BRPC Library Object Compilation\nDESCRIPTION: Creates object libraries for BUTIL and SOURCES components with position independent code property\nSOURCE: https://github.com/apache/brpc/blob/master/src/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(BUTIL_LIB OBJECT ${BUTIL_SOURCES})\nadd_library(SOURCES_LIB OBJECT ${SOURCES})\nadd_dependencies(SOURCES_LIB PROTO_LIB)\n\nset_property(TARGET ${SOURCES_LIB} PROPERTY POSITION_INDEPENDENT_CODE 1)\nset_property(TARGET ${BUTIL_LIB} PROPERTY POSITION_INDEPENDENT_CODE 1)\n```\n\n----------------------------------------\n\nTITLE: Publishing Public Key to Keyserver - Bash\nDESCRIPTION: Uploads the specified GPG public key to the MIT keyserver, making it publicly available for verification during release validation. Replace the example key ID with your actual public key value as shown from gpg --list-keys. Network access is required.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngpg --keyserver hkps://pgp.mit.edu --send-key C30F211F071894258497F46392E18A11B6585834\n```\n\n----------------------------------------\n\nTITLE: Setting Release Version In File - Plain Text\nDESCRIPTION: Represents the content of the RELEASE_VERSION file, specifying the target version for the brpc release. This file must be updated and committed before tagging a release. The file must contain only the new version string.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n1.0.0\n```\n\n----------------------------------------\n\nTITLE: Debug Flag Configuration in CMake\nDESCRIPTION: Sets compiler flags to include NDEBUG definition when not in debug mode\nSOURCE: https://github.com/apache/brpc/blob/master/src/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT DEBUG)\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DNDEBUG\")\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -DNDEBUG\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Apache bRPC Release Announcement Email Template - Plain Text\nDESCRIPTION: This snippet provides a full plain text email template for announcing the final release of Apache bRPC. It includes guidelines for describing main release changes and supplying essential project resources and download information. The announcement targets mailing lists and is required to be sent from a personal Apache email account in plain text format only.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_30\n\nLANGUAGE: plaintext\nCODE:\n```\n[ANNOUNCE] Apache bRPC 1.0.0 released\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nHi all,\n\nThe Apache bRPC community is glad to announce the new release\nof Apache bRPC 1.0.0.\n\nApache bRPC is an Industrial-grade RPC framework using C++ Language,\nwhich is often used in high performance systems such as Search, Storage,\nMachine learning, Advertisement, Recommendation etc.\n\nBrief notes of this release:\n- xxx\n- yyy\n- zzz\n\nMore details regarding Apache brpc can be found at:\nhttps://brpc.apache.org/\n\nThe release is available for download at:\nhttps://brpc.apache.org/download/\n\nThe release notes can be found here:\nhttps://github.com/apache/brpc/releases/tag/1.0.0\n\nWebsite: https://brpc.apache.org/\n\nApache bRPC Resources:\n- Issue: https://github.com/apache/brpc/issues/\n- Mailing list: dev@brpc.apache.org\n- Documents: https://brpc.apache.org/docs/\n\nWe would like to thank all contributors of the Apache bRPC community\nwho made this release possible!\n\n\nBest Regards,\nApache bRPC Community\n```\n\n----------------------------------------\n\nTITLE: NGINX Proxy Configuration for BRPC Services\nDESCRIPTION: Shows how to configure NGINX to proxy specific URLs to BRPC backend services while protecting builtin services from public access.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_24\n\nLANGUAGE: nginx\nCODE:\n```\nlocation /MyAPI {\n    ...\n    proxy_pass http://<target-server>/ServiceName/MethodName$query_string\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Release Tarball and Verifying Signature Using GPG - Bash\nDESCRIPTION: Signs the release tarball with the maintainer's GPG key and verifies the created signature. The first command creates a detached ASCII-armored signature file (.asc), and the second verifies the signature against the tarball. GPG configuration and proper keyring setup are required.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ngpg -u lorinlee@apache.org --armor --output apache-brpc-1.0.0-src.tar.gz.asc --detach-sign apache-brpc-1.0.0-src.tar.gz\\n\\ngpg --verify apache-brpc-1.0.0-src.tar.gz.asc apache-brpc-1.0.0-src.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Setting Output Directories for Libraries using CMake - CMake - CMake\nDESCRIPTION: These code snippets configure where CMake places compiled shared libraries (*.so) and static libraries (*.a) after building. set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ...) defines the output directory for shared libraries, while set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ...) sets the directory for static archives. Dependencies: Requires a CMake-based project. Parameters: CMAKE_LIBRARY_OUTPUT_DIRECTORY and CMAKE_ARCHIVE_OUTPUT_DIRECTORY use the PROJECT_BINARY_DIR variable, outputting files to a 'lib' directory. Inputs: Paths are set dynamically to match the project's binary directory layout. Outputs: Shared and static library files in designated output directories.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/output/lib)\n```\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/output/lib)\n```\n\n----------------------------------------\n\nTITLE: Importing and Verifying GPG Keys - Bash\nDESCRIPTION: This snippet demonstrates how to import the public keys required to verify Apache bRPC distributions and how to verify release artifact signatures using GPG. It relies on 'curl' for downloading KEYS and 'gpg' for cryptographic operations. Required parameters include the URL to KEYS, file names for the source and signature. Successful execution ensures that the public key is locally available and the signature of the release artifact is valid.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ncurl https://dist.apache.org/repos/dist/dev/brpc/KEYS >> KEYS\n\ngpg --import KEYS\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --edit-key lorinlee\n```\n\nLANGUAGE: bash\nCODE:\n```\ngpg --verify apache-brpc-1.0.0-src.tar.gz.asc apache-brpc-1.0.0-src.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Apache bRPC Vote Email Template - Plain Text\nDESCRIPTION: This snippet provides a plain text template for initiating a community vote on releasing Apache bRPC. It includes placeholders for the version, release commit ID, and links to relevant artifacts and credentials. The email prompts the PMC and community to check release criteria before voting. It must be sent to the designated mailing list in plain text format and fulfillment of all checklist items is mandatory for a successful vote.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_28\n\nLANGUAGE: plaintext\nCODE:\n```\n[VOTE] Release Apache bRPC 1.0.0\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nHi Apache bRPC Community,\n\nThis is a call for vote to release Apache bRPC version\n1.0.0\n\n[Release Note]\n- xxx\n\nThe release candidates:\nhttps://dist.apache.org/repos/dist/dev/brpc/1.0.0/\n\nGit tag for the release:\nhttps://github.com/apache/brpc/releases/tag/1.0.0\n\nRelease Commit ID:\nhttps://github.com/apache/brpc/commit/xxx\n\nKeys to verify the Release Candidate:\nhttps://dist.apache.org/repos/dist/dev/brpc/KEYS\n\nThe vote will be open for at least 72 hours or until the necessary number of\nvotes are reached.\n\nPlease vote accordingly:\n[ ] +1 approve\n[ ] +0 no opinion\n[ ] -1 disapprove with the reason\n\nPMC vote is +1 binding, all others are +1 non-binding.\n\nChecklist for reference:\n[ ] Download links are valid.\n[ ] Checksums and PGP signatures are valid.\n[ ] Source code distributions have correct names matching the current\nrelease.\n[ ] LICENSE and NOTICE files are correct for each brpc repo.\n[ ] All files have license headers if necessary.\n[ ] No compiled archives bundled in source archive.\n\nRegards,\nLorinLee\n```\n\n----------------------------------------\n\nTITLE: Creating Release Tarball Using git archive - Bash\nDESCRIPTION: Creates a tar.gz archive from the release tag for distribution. Two command variations are provided: the first uses gzip on the output, the second uses git's --format option directly. Both output to apache-brpc-1.0.0-src.tar.gz for distribution.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ngit archive --format=tar 1.0.0 --prefix=apache-brpc-1.0.0-src/ | gzip > apache-brpc-1.0.0-src.tar.gz\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit archive --format=tar.gz 1.0.0 --prefix=apache-brpc-1.0.0-src/ --output=apache-brpc-1.0.0-src.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Sample Output of GPG Key Listing - Plain Text\nDESCRIPTION: Illustrates the output of listing GPG keys with associated key details and fingerprints. Used to confirm the existence and status of generated GPG keys, and to copy or share the key ID where required.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\ngpg: checking the trustdb\\ngpg: marginals needed: 3  completes needed: 1  trust model: pgp\\ngpg: depth: 0  valid:   2  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 2u\\n/Users/lilei/.gnupg/pubring.kbx\\n----------------------------------\\npub   rsa4096 2021-10-17 [SC]\\n      C30F211F071894258497F46392E18A11B6585834\\nuid           [ultimate] LorinLee (lorinlee's key) <lorinlee@apache.org>\\nsub   rsa4096 2021-10-17 [E]\n```\n\n----------------------------------------\n\nTITLE: Using File-based Naming Service Server List Format in brpc (C++)\nDESCRIPTION: This snippet illustrates the expected format for a machine list used by the file-based naming service in brpc. Each line should contain a server address, optional tag(s), and optional comments. Tags differentiate instances for load balancing. The file is reloaded when updated. No code execution, only input file format for proper server list management.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n# \\u6b64\\u884c\\u4f1a\\u88ab\\u5ffd\\u7565\n10.24.234.17:8080 tag1  # \\u8fd9\\u662f\\u6ce8\\u91ca\\uff0c\\u4f1a\\u88ab\\u5ffd\\u7565\n10.24.234.17:8090 tag2  # \\u6b64\\u884c\\u548c\\u4e0a\\u4e00\\u884c\\u88ab\\u8ba4\\u4e3a\\u4e0d\\u540c\\u7684\\u5b9e\\u4f8b\n10.24.234.18:8080\n10.24.234.19:8080\n```\n\n----------------------------------------\n\nTITLE: Apache bRPC Vote Result Email Template - Plain Text\nDESCRIPTION: This snippet is a plain text template for announcing the result of an Apache bRPC community vote on a release. It summarizes the voting outcome, listing binding and non-binding votes, and provides a thread link for reference. The template is to be sent to the community mailing list and must be customized with actual names and links.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_29\n\nLANGUAGE: plaintext\nCODE:\n```\n[Result] [VOTE] Release Apache bRPC 1.0.0\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nHi all,\n\nThe vote to release Apache bRPC 1.0.0 has passed.\n\nThe vote PASSED with 3 binding +1, 3 non binding +1 and no -1 votes:\n\nBinding votes:\n- xxx\n- yyy\n- zzz\n\nNon-binding votes:\n- aaa\n- bbb\n- ccc\n\nVote thread: xxx (vote email link in https://lists.apache.org/)\n\nThank you to all the above members to help us to verify and vote for\nthe 1.0.0 release. I will process to publish the release and send ANNOUNCE.\n\nRegards,\nLorinLee\n```\n\n----------------------------------------\n\nTITLE: Cloning Release Branch and Creating Git Tag - Bash\nDESCRIPTION: Clones the specific brpc release branch, creates an annotated release tag, and pushes the tags to GitHub. This reserves the release version for tracking and publication. Ensure git is configured and you have push permissions.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b release-1.0 git@github.com:apache/brpc.git ~/brpc\\n\\ncd ~/brpc\\n\\ngit tag -a 1.0.0 -m \"release 1.0.0\"\\n\\ngit push origin --tags\n```\n\n----------------------------------------\n\nTITLE: Sample Output of GPG Fingerprint - Plain Text\nDESCRIPTION: Demonstrates the expected output when querying a GPG key's fingerprint. Contains the public key's fingerprint, which should be used for secure verification on public sites like id.apache.org.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n/Users/lilei/.gnupg/pubring.kbx\\n----------------------------------\\npub   rsa4096 2021-10-17 [SC]\\n      C30F 211F 0718 9425 8497  F463 92E1 8A11 B658 5834\\nuid           [ultimate] LorinLee (lorinlee's key) <lorinlee@apache.org>\\nsub   rsa4096 2021-10-17 [E]\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP Method in brpc\nDESCRIPTION: Shows how to set the HTTP method for a request. By default, brpc uses GET, but this can be changed to POST or other HTTP methods as needed.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_7\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().set_method(brpc::HTTP_METHOD_POST);\n```\n\n----------------------------------------\n\nTITLE: Adding GPG Public Key to KEYS File by Fingerprint - Bash\nDESCRIPTION: Appends a specific GPG public key and signatures to the KEYS file by specifying the fingerprint. This removes ambiguity when multiple keys exist for the same name or email.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n(gpg --list-sigs C30F211F071894258497F46392E18A11B6585834 && gpg -a --export C30F211F071894258497F46392E18A11B6585834) >> KEYS\n```\n\n----------------------------------------\n\nTITLE: Sending HTTP/JSON Requests to brpc Service using curl - Shell\nDESCRIPTION: This shell snippet demonstrates how to send a JSON-encoded HTTP request to a brpc protobuf service using curl. The example sends a POST request with '{\"message\":\"hello\"}' as JSON data to the EchoService endpoint, and expects a JSON response. The Content-Type header is optional but can be set to 'application/json' for clarity. This can be used to test or interact with brpc services from the command line. No dependencies except curl.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n# -H 'Content-Type: application/json' is optional\n$ curl -d '{\"message\":\"hello\"}' http://brpc.baidu.com:8765/EchoService/Echo\n{\"message\":\"hello\"}\n```\n\n----------------------------------------\n\nTITLE: Error Code Usage Examples with Printf\nDESCRIPTION: Shows correct and incorrect ways to print error descriptions using various methods including strerror, berror, and printf formatting.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/error_code.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nerrno = ESTOP;\nprintf(\"Describe errno: %m\\n\");                              // [Wrong] Describe errno: Unknown error -114\nprintf(\"Describe errno: %s\\n\", strerror_r(errno, NULL, 0));  // [Wrong] Describe errno: Unknown error -114\nprintf(\"Describe errno: %s\\n\", berror());                    // [Correct] Describe errno: the thread is stopping\nprintf(\"Describe errno: %s\\n\", berror(errno));               // [Correct] Describe errno: the thread is stopping\n```\n\n----------------------------------------\n\nTITLE: Building Redis Executables\nDESCRIPTION: Defines and links the final executable targets: redis_cli, redis_press, and redis_server with their required libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/redis_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(redis_cli redis_cli.cpp)\nadd_executable(redis_press redis_press.cpp)\nadd_executable(redis_server redis_server.cpp)\n\nset(AUX_LIB readline ncurses)\n\ntarget_link_libraries(redis_cli ${BRPC_LIB} ${DYNAMIC_LIB} ${AUX_LIB})\ntarget_link_libraries(redis_press ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(redis_server ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: Adding GPG Public Key to KEYS File - Bash\nDESCRIPTION: Appends the maintainers' public key and signatures to the KEYS file for Apache release verification. This is required if you are a new release manager. If multiple keys exist, specify by email or fingerprint.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n(gpg --list-sigs lorinlee && gpg -a --export lorinlee) >> KEYS\n```\n\n----------------------------------------\n\nTITLE: Setting Application Layer Protocol Negotiation in C++\nDESCRIPTION: Shows how to set supported application layer protocols for SSL negotiation using the alpns option.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_21\n\nLANGUAGE: C++\nCODE:\n```\nServerSSLOptions ssl_options;\nssl_options.alpns = \"http, h2, baidu_std\";\n```\n\n----------------------------------------\n\nTITLE: Retrieving Memcache Operation Results in brpc C++ API\nDESCRIPTION: Presents the available methods of brpc::MemcacheResponse for receiving and parsing memcached operation replies in C++. Each method corresponds to a specific memcached operation issued within a request; return values indicate per-operation success, and out parameters capture result data such as values, flags, or CAS tokens. Users should invoke the PopXXX method matching each operation performed, and consult LastError() for diagnostics when an operation fails.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/memcache_client.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\n// Call LastError() of the response to check the error text when any following operation fails.\\nbool PopGet(IOBuf* value, uint32_t* flags, uint64_t* cas_value);\\nbool PopGet(std::string* value, uint32_t* flags, uint64_t* cas_value);\\nbool PopSet(uint64_t* cas_value);\\nbool PopAdd(uint64_t* cas_value);\\nbool PopReplace(uint64_t* cas_value);\\nbool PopAppend(uint64_t* cas_value);\\nbool PopPrepend(uint64_t* cas_value);\\nbool PopDelete();\\nbool PopFlush();\\nbool PopIncrement(uint64_t* new_value, uint64_t* cas_value);\\nbool PopDecrement(uint64_t* new_value, uint64_t* cas_value);\\nbool PopTouch();\\nbool PopVersion(std::string* version);\n```\n\n----------------------------------------\n\nTITLE: Updating Version in RPM Spec File - Plain Text\nDESCRIPTION: Updates the version field in the RPM spec file used for building brpc Linux packages. The version string must match the intended release.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\nVersion:\\t1.0.0\n```\n\n----------------------------------------\n\nTITLE: Implementing ClosureGuard RAII Utility for brpc - C++\nDESCRIPTION: Specifies the interface for the ClosureGuard class, an RAII utility ensuring safe and automatic invocation of the Closure's Run method on destruction. Supports resetting and releasing internal closure pointers. Used throughout brpc service implementations to reliably manage asynchronous and synchronous call completion, helping to avoid resource leaks and logic errors.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/server.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// RAII: Call Run() of the closure on destruction.\nclass ClosureGuard {\npublic:\n    ClosureGuard();\n    // Constructed with a closure which will be Run() inside dtor.\n    explicit ClosureGuard(google::protobuf::Closure* done);\n    \n    // Call Run() of internal closure if it's not NULL.\n    ~ClosureGuard();\n \n    // Call Run() of internal closure if it's not NULL and set it to `done'.\n    void reset(google::protobuf::Closure* done);\n \n    // Set internal closure to NULL and return the one before set.\n    google::protobuf::Closure* release();\n};\n```\n\n----------------------------------------\n\nTITLE: Listing Miscellaneous bvar Counters Used in brpc - Plaintext\nDESCRIPTION: This snippet provides example outputs of miscellaneous bvar counters that are used internally by brpc, formatted as key-value pairs. These statistics represent internal metrics such as bthread activity, iobuf statistics, collector metrics and others, and can be accessed via monitoring endpoints or exported files. There are no required dependencies for reading this output, but metrics monitoring systems may process these records for aggregation and visualization.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/bvar.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nbthread_switch_second : 20422\nbthread_timer_scheduled_second : 4\nbthread_timer_triggered_second : 4\nbthread_timer_usage : 2.64987e-05\nbthread_worker_count : 13\nbthread_worker_usage : 1.33733\nbvar_collector_dump_second : 0\nbvar_collector_dump_thread_usage : 0.000307385\nbvar_collector_grab_second : 0\nbvar_collector_grab_thread_usage : 1.9699e-05\nbvar_collector_pending_samples : 0\nbvar_dump_interval : 10\nbvar_revision : \"34975\"\nbvar_sampler_collector_usage : 0.00106495\niobuf_block_count : 89\niobuf_block_count_hit_tls_threshold : 0\niobuf_block_memory : 729088\niobuf_newbigview_second : 10\n```\n\n----------------------------------------\n\nTITLE: Comparing CHECK_XX and CHECK Macros in C++\nDESCRIPTION: This snippet compares the output of CHECK_GT and CHECK macros when used for arithmetic comparisons. It shows that CHECK_XX provides more detailed information when the check fails.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_log.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\nint x = 1;\nint y = 2;\nCHECK_GT(x, y);  // Check failed: x > y (1 vs 2).\nCHECK(x > y);    // Check failed: x > y.\n```\n\n----------------------------------------\n\nTITLE: Moving Release Packages in Apache SVN - Bash\nDESCRIPTION: This SVN command moves the release candidate directory from the development area to the official release area in the Apache distribution repository. Only PMC members should execute this operation. The snippet depends on the 'svn' client configured for Apache infrastructure and proper authentication. The command also updates the KEYS file in the release directory if there were changes. It requires specifying both source and destination SVN URLs and a commit message.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nsvn mv https://dist.apache.org/repos/dist/dev/brpc/1.0.0 https://dist.apache.org/repos/dist/release/brpc/1.0.0 -m \"release brpc 1.0.0\"\n```\n\n----------------------------------------\n\nTITLE: Installing Google Test for Running brpc Tests on Fedora/CentOS\nDESCRIPTION: Command for installing Google Test framework on Fedora/CentOS to run brpc unit tests.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\nsudo yum install gtest-devel\n```\n\n----------------------------------------\n\nTITLE: Configuring Build System and Dependencies with CMake - CMake - CMake\nDESCRIPTION: This snippet defines the CMake configuration for the streaming_batch_echo_c++ project, including detection of required libraries such as brpc, gflags, protobuf, thrift, leveldb, and OpenSSL. It sets system-specific options and compiler flags, configures include directories, and generates rules for building client and server executables. Prerequisites include a working CMake environment (minimum version 2.8.10), all dependent libraries installed, and the echo.proto for protobuf codegeneration. Key parameters handled are LINK_SO (dynamic linking toggle) and system type (to adjust for Darwin). The file expects all dependencies to be found or throws a fatal error; misconfigured paths or missing libraries result in build failure.\nSOURCE: https://github.com/apache/brpc/blob/master/example/streaming_batch_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(streaming_batch_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n        COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\\\n'\"\n        OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n            \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n    )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n        ${CMAKE_THREAD_LIBS_INIT}\n        ${GFLAGS_LIBRARY}\n        ${PROTOBUF_LIBRARIES}\n        ${LEVELDB_LIB}\n        ${OPENSSL_CRYPTO_LIBRARY}\n        ${OPENSSL_SSL_LIBRARY}\n        ${THRIFT_LIB}\n        dl\n)\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n            pthread\n            \"-framework CoreFoundation\"\n            \"-framework CoreGraphics\"\n            \"-framework CoreData\"\n            \"-framework CoreText\"\n            \"-framework Security\"\n            \"-framework Foundation\"\n            \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n            \"-Wl,-U,_ProfilerStart\"\n            \"-Wl,-U,_ProfilerStop\"\n            \"-Wl,-U,__Z13GetStackTracePPvii\")\nendif()\n\nadd_executable(streaming_batch_echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(streaming_batch_echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(streaming_batch_echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(streaming_batch_echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource-oriented FileService Default Method - C++\nDESCRIPTION: Implements the resource-style FileService default_method for brpc HTTP/h2 services. It retrieves the dynamic part of the URL (unresolved_path), appends a custom message, and writes it to the HTTP response attachment. Implements directory/file style path handling based on HTTP URL patterns. Requires brpc and protobuf for Controller and service infrastructure.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_service.md#_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nclass FileServiceImpl: public FileService {\\npublic:\\n    ...\\n    virtual void default_method(google::protobuf::RpcController* cntl_base,\\n                                const HttpRequest* /*request*/,\\n                                HttpResponse* /*response*/,\\n                                google::protobuf::Closure* done) {\\n        brpc::ClosureGuard done_guard(done);\\n        brpc::Controller* cntl = static_cast<brpc::Controller*>(cntl_base);\\n        cntl->response_attachment().append(\\\"Getting file: \\\" );\\n        cntl->response_attachment().append(cntl->http_request().unresolved_path());\\n    }\\n};\n```\n\n----------------------------------------\n\nTITLE: Installing EPEL Repository on CentOS\nDESCRIPTION: Command for installing EPEL (Extra Packages for Enterprise Linux) repository on CentOS to get access to additional packages.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nsudo yum install epel-release\n```\n\n----------------------------------------\n\nTITLE: Running brpc Unit Tests\nDESCRIPTION: Commands for building and running the unit tests for brpc to verify all functionality is working correctly.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ cd test\n$ make\n$ sh run_tests.sh\n```\n\n----------------------------------------\n\nTITLE: CMake Project Configuration for Dynamic Partition Echo\nDESCRIPTION: Core CMake configuration that sets up the project, finds dependencies, and configures build settings for a dynamic partition echo example using brpc. Includes comprehensive dependency checks for required libraries like brpc, gflags, leveldb, and OpenSSL.\nSOURCE: https://github.com/apache/brpc/blob/master/example/dynamic_partition_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(dynamic_partition_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\nfind_path(GPERFTOOLS_INCLUDE_DIR NAMES gperftools/heap-profiler.h)\nfind_library(GPERFTOOLS_LIBRARIES NAMES tcmalloc_and_profiler)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\n\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(dynamic_partition_echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(dynamic_partition_echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(dynamic_partition_echo_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(dynamic_partition_echo_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n\nfile(COPY ${PROJECT_SOURCE_DIR}/server_list\n     DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Building and Installing rpc_replay Tool with CMake (CMake)\nDESCRIPTION: This snippet defines the steps in CMake to collect all C++ source files from the tools/rpc_replay directory, create an executable named rpc_replay, link it with the brpc-static and a variable dynamic library, and specify its installation location. It depends on proper definition of PROJECT_SOURCE_DIR, brpc-static, and the DYNAMIC_LIB variable in the CMake environment. The created executable rpc_replay is designed to be installed into the runtime binary directory as defined by CMAKE_INSTALL_BINDIR. Expected input is a valid CMake configuration context, producing an rpc_replay binary as output.\nSOURCE: https://github.com/apache/brpc/blob/master/tools/rpc_replay/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SOURCES \"${PROJECT_SOURCE_DIR}/tools/rpc_replay/*.cpp\")\nadd_executable(rpc_replay ${SOURCES})\ntarget_link_libraries(rpc_replay brpc-static ${DYNAMIC_LIB})\ninstall(TARGETS rpc_replay RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags and C++ Standard\nDESCRIPTION: Configures compiler flags for optimization, warnings, and C++11 support based on compiler version and type.\nSOURCE: https://github.com/apache/brpc/blob/master/example/parallel_echo_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Unit Test Build Environment with CMake - CMake\nDESCRIPTION: This snippet sets up the CMake environment for building and running unit tests in Apache brpc. It handles locating dependencies (Gperftools), setting include directories, copying required files, defining protocol buffer sources, managing compiler flags, and organizing test source files. The script adapts certain settings for the Linux platform, configures use of various compiler features, and ensures all necessary artifacts (including test certificates and scripts) are present for the tests to execute properly. Dependencies include Gperftools, Googletest, and protocol buffer compiler support; key variables are used to manage directories and file lists.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\nfind_package(Gperftools)\ninclude_directories(${GPERFTOOLS_INCLUDE_DIR})\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\ninclude(CompileProto)\nset(TEST_PROTO_FILES addressbook1.proto\n                     addressbook_encode_decode.proto\n                     addressbook_map.proto\n                     addressbook.proto\n                     echo.proto\n                     iobuf.proto\n                     message.proto\n                     repeated.proto\n                     snappy_message.proto\n                     v1.proto\n                     v2.proto\n                     v3.proto\n                     grpc.proto\n                     health_check.proto)\nfile(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/test/hdrs)\nset(PROTOC_FLAGS ${PROTOC_FLAGS} -I${CMAKE_SOURCE_DIR}/src)\ncompile_proto(PROTO_HDRS PROTO_SRCS ${CMAKE_BINARY_DIR}/test\n                                    ${CMAKE_BINARY_DIR}/test/hdrs\n                                    ${CMAKE_SOURCE_DIR}/test\n                                    \"${TEST_PROTO_FILES}\")\nadd_library(TEST_PROTO_LIB OBJECT ${PROTO_SRCS} ${PROTO_HDRS})\n\nset(BRPC_SYSTEM_GTEST_SOURCE_DIR \"\" CACHE PATH \"System googletest source directory.\")\n\nif(DOWNLOAD_GTEST)\n    include(SetupGtest)\nelseif(BRPC_SYSTEM_GTEST_SOURCE_DIR)\n    add_subdirectory(\"${BRPC_SYSTEM_GTEST_SOURCE_DIR}\" \"${PROJECT_BINARY_DIR}/system-googletest-build\")\nelse()\n    message(FATAL_ERROR \"Googletest is not available\")\nendif()\n\nset(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} ${DEFINE_CLOCK_GETTIME} -DBRPC_WITH_GLOG=${WITH_GLOG_VAL} -DBRPC_WITH_RDMA=${WITH_RDMA_VAL}\")\nset(CMAKE_CPP_FLAGS \"${CMAKE_CPP_FLAGS} -DBTHREAD_USE_FAST_PTHREAD_MUTEX -D__const__=__unused__ -D_GNU_SOURCE -DUSE_SYMBOLIZE -DNO_TCMALLOC -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -DUNIT_TEST -Dprivate=public -Dprotected=public -DBVAR_NOT_LINK_DEFAULT_VARIABLES -D__STRICT_ANSI__ -include ${PROJECT_SOURCE_DIR}/test/sstream_workaround.h\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CPP_FLAGS} -g -O2 -pipe -Wall -W -fPIC -fstrict-aliasing -Wno-invalid-offsetof -Wno-unused-parameter -fno-omit-frame-pointer\")\nuse_cxx11()\n\nif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n    #required by butil/crc32.cc to boost performance for 10x\n    if((CMAKE_SYSTEM_PROCESSOR MATCHES \"(x86)|(X86)|(amd64)|(AMD64)\") AND NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.4))\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -msse4 -msse4.2\")\n    endif()\n    if(NOT (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0))\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wno-aligned-new\")\n    endif()\nendif()\n\nfile(COPY ${PROJECT_SOURCE_DIR}/test/cert1.key DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nfile(COPY ${PROJECT_SOURCE_DIR}/test/cert2.key DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nfile(COPY ${PROJECT_SOURCE_DIR}/test/cert1.crt DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nfile(COPY ${PROJECT_SOURCE_DIR}/test/cert2.crt DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nfile(COPY ${PROJECT_SOURCE_DIR}/test/jsonout DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nfile(COPY ${PROJECT_SOURCE_DIR}/test/run_tests.sh DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\n\nSET(TEST_BUTIL_SOURCES\n    ${PROJECT_SOURCE_DIR}/test/recordio_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/popen_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/bounded_queue_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/at_exit_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/atomicops_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/base64_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/base64url_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/big_endian_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/bits_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/hash_tables_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/linked_list_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/mru_cache_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/small_map_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/stack_container_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/mpsc_queue_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/cpu_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/crash_logging_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/leak_tracker_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/stack_trace_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/environment_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/file_util_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/dir_reader_posix_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/file_path_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/file_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/scoped_temp_dir_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/guid_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/hash_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/lazy_instance_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/aligned_memory_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/linked_ptr_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/ref_counted_memory_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/ref_counted_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/scoped_ptr_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/scoped_vector_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/singleton_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/weak_ptr_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/observer_list_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/file_descriptor_shuffle_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/rand_util_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/safe_numerics_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/scoped_clear_errno_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/scoped_generic_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/security_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/sha1_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/stl_util_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/nullable_string16_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/safe_sprintf_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/string16_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/stringprintf_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/string_number_conversions_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/string_piece_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/string_split_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/string_tokenizer_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/string_util_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/stringize_macros_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/sys_string_conversions_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/utf_offset_string_conversions_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/utf_string_conversions_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/cancellation_flag_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/condition_variable_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/lock_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/waitable_event_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/type_traits_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/non_thread_safe_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/platform_thread_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/simple_thread_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/thread_checker_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/thread_collision_warner_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/thread_id_name_manager_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/thread_local_storage_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/thread_local_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/abalist_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/watchdog_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/time_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/version_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/logging_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/cacheline_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/class_name_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/endpoint_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/unique_ptr_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/errno_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/fd_guard_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/file_watcher_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/find_cstr_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/scoped_lock_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/status_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/string_printf_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/string_splitter_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/synchronous_event_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/temp_file_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/baidu_thread_local_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/thread_key_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/baidu_time_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/flat_map_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/crc32c_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/iobuf_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/object_pool_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/test_switches.cc\n    ${PROJECT_SOURCE_DIR}/test/scoped_locale.cc\n    ${PROJECT_SOURCE_DIR}/test/scope_guard_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/optional_unittest.cpp\n    ${PROJECT_SOURCE_DIR}/test/butil_unittest_main.cpp\n\t)\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\nSET(TEST_BUTIL_SOURCES ${TEST_BUTIL_SOURCES}\n    ${PROJECT_SOURCE_DIR}/test/proc_maps_linux_unittest.cc\n    ${PROJECT_SOURCE_DIR}/test/test_file_util_linux.cc)\nendif()\n\n# bthread_* functions are used in logging.cc, and they need to be marked as\n```\n\n----------------------------------------\n\nTITLE: Basic CMake Project Configuration\nDESCRIPTION: Sets up the CMake project with minimum version requirement and project name. Defines option for dynamic linking.\nSOURCE: https://github.com/apache/brpc/blob/master/example/asynchronous_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(asynchronous_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Client-side Workflow in Apache brpc\nDESCRIPTION: This markdown snippet provides a comprehensive list of steps involved in the client-side workflow of Apache brpc. It details the process from initiating an RPC to handling the response, including error handling and performance considerations.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_22\n\nLANGUAGE: markdown\nCODE:\n```\n# PS: Workflow at Client-side\n\n![img](../images/client_side.png)\n\nSteps:\n\n1. Create a [bthread_id](https://github.com/apache/brpc/blob/master/src/bthread/id.h) as correlation_id of current RPC.\n2. According to how the Channel is initialized, choose a server from global [SocketMap](https://github.com/apache/brpc/blob/master/src/brpc/socket_map.h) or [LoadBalancer](https://github.com/apache/brpc/blob/master/src/brpc/load_balancer.h) as  destination of the request.\n3. Choose a [Socket](https://github.com/apache/brpc/blob/master/src/brpc/socket.h) according to connection type (single, pooled, short)\n4. If authentication is turned on and the Socket is not authenticated yet, first request enters authenticating branch, other requests block until the branch writes authenticating information into the Socket. Server-side only verifies the first request.\n5. According to protocol of the Channel, choose corresponding serialization callback to serialize request into [IOBuf](https://github.com/apache/brpc/blob/master/src/butil/iobuf.h).\n6. If timeout is set, setup timer. From this point on, avoid using Controller, since the timer may be triggered at anytime and calls user's callback for timeout, which may delete Controller.\n7. Sending phase is completed. If error occurs at any step, Channel::HandleSendFailed is called.\n8. Write IOBuf with serialized data into the Socket and add Channel::HandleSocketFailed into id_wait_list of the Socket. The callback will be called when the write is failed or connection is broken before completion of RPC.\n9. In synchronous call, Join correlation_id; otherwise CallMethod() returns.\n10. Send/receive messages to/from network.\n11. After receiving response, get the correlation_id inside, find out associated Controller within O(1) time. The lookup does not need to lock a global hashmap, and scales well.\n12. Parse response according to the protocol\n13. Call Controller::OnRPCReturned, which may retry errorous RPC, or complete the RPC. Call user's done in asynchronous call. Destroy correlation_id and wakeup joining threads.\n```\n\n----------------------------------------\n\nTITLE: Configuring Project and Building brpc Cascade Echo Example with CMake (CMake)\nDESCRIPTION: This snippet comprises the entire CMakeLists.txt used to configure and build the cascade_echo example for Apache brpc. It locates and configures critical dependencies, generates source/header files from a .proto Protobuffer, sets compile flags, and compiles both client and server targets. Variables like CMAKE_PREFIX_PATH and search/order of dependencies (e.g., LevelDB, GFlags, OpenSSL) are set conditionally, with additional logic for macOS. Prerequisites include CMake >= 2.8.10 and installed dependencies (brpc, gflags, protobuf, thrift, leveldb, openssl). Inputs are the source files and .proto file, and output are two executables linked with all discovered libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/cascade_echo_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n\ncmake_minimum_required(VERSION 2.8.10)\nproject(cascade_echo_c++ C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\n# include PROTO_HEADER\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n# Search for libthrift* by best effort. If it is not found and brpc is\n# compiled with thrift protocol enabled, a link error would be reported.\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\nif((NOT BRPC_INCLUDE_PATH) OR (NOT BRPC_LIB))\n    message(FATAL_ERROR \"Fail to find brpc\")\nendif()\ninclude_directories(${BRPC_INCLUDE_PATH})\n\nfind_path(GFLAGS_INCLUDE_PATH gflags/gflags.h)\nfind_library(GFLAGS_LIBRARY NAMES gflags libgflags)\nif((NOT GFLAGS_INCLUDE_PATH) OR (NOT GFLAGS_LIBRARY))\n    message(FATAL_ERROR \"Fail to find gflags\")\nendif()\ninclude_directories(${GFLAGS_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n\nadd_executable(cascade_echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(cascade_echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(cascade_echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(cascade_echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n\n```\n\n----------------------------------------\n\nTITLE: BRPC Authentication Interface Definition\nDESCRIPTION: Defines the Authenticator interface used for implementing connection-based authentication in BRPC, allowing custom credential generation\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/client.md#_snippet_20\n\nLANGUAGE: c++\nCODE:\n```\nclass Authenticator {\npublic:\n    virtual ~Authenticator() {}\n\n    // Implement this method to generate credential information\n    // into `auth_str' which will be sent to `VerifyCredential'\n    // at server side. This method will be called on client side.\n    // Returns 0 on success, error code otherwise\n    virtual int GenerateCredential(std::string* auth_str) const = 0;\n};\n```\n\n----------------------------------------\n\nTITLE: Markdown Guidelines for bRPC Contributions\nDESCRIPTION: Markdown formatted instructions for contributing to the Apache bRPC project, including pre-PR requirements like code style conformance, code organization, and testing requirements. Also includes post-PR verification steps.\nSOURCE: https://github.com/apache/brpc/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nIf you meet any problem or request a new feature, you're welcome to [create an issue](https://github.com/apache/brpc/issues/new/choose).\n\nIf you can solve any of [the issues](https://github.com/apache/brpc/issues), you're welcome to send the PR to us.\n\nBefore the PR:\n\n* Make sure your code style conforms to [google C++ coding style](https://google.github.io/styleguide/cppguide.html). Indentation is preferred to be 4 spaces.\n* The code appears where it should be. For example the code to support an extra protocol should not be put in general classes like server.cpp, channel.cpp, while a general modification would better not be hidden inside a very specific protocol.\n* Has unittests.\n\nAfter the PR:\n\n* Make sure the [GitHub Actions](https://github.com/apache/brpc/actions) passed.\n```\n\n----------------------------------------\n\nTITLE: Confirming Release Notes Template - Plain Text\nDESCRIPTION: Provides a template format for contributors to structure release notes for a new brpc release. This ensures that major changes, bugfixes, and enhancements are documented clearly for each release cycle. The template requires editing to fill in actual feature and bug descriptions; it is not used directly by commands.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n[Release Notes]\\n\\nFeature:\\n- ...\\n\\nBugfix:\\n- ...\\n\\nEnhancement:\\n- ...\\n\\nOther:\\n- ...\n```\n\n----------------------------------------\n\nTITLE: Copying Release Artifacts to SVN Directory - Bash\nDESCRIPTION: Creates the release directory and copies the release tarball, signature, and checksum files into the target subdirectory under the local SVN working copy. Ensures all release artifacts are present before submitting.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/brpc_svn/dev/brpc/1.0.0\\n\\ncd ~/brpc_svn/dev/brpc/1.0.0\\n\\ncp ~/brpc/apache-brpc-1.0.0-src.tar.gz ~/brpc_svn/dev/brpc/1.0.0\\n\\ncp ~/brpc/apache-brpc-1.0.0-src.tar.gz.asc ~/brpc_svn/dev/brpc/1.0.0\\n\\ncp ~/brpc/apache-brpc-1.0.0-src.tar.gz.sha512 ~/brpc_svn/dev/brpc/1.0.0\n```\n\n----------------------------------------\n\nTITLE: Setting up RDMA Performance Testing Project in CMake\nDESCRIPTION: Configures the CMake build environment for RDMA performance testing with Apache brpc. The script sets minimum CMake version, defines the project, configures build options, and sets up paths for dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rdma_performance/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(rdma_performance C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Flags and C++ Standard\nDESCRIPTION: Sets up compiler flags for optimization, warnings, and debugging, and ensures C++11 support across different CMake versions and compilers.\nSOURCE: https://github.com/apache/brpc/blob/master/example/session_data_and_thread_local/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Executable Output Path with CMake - CMake\nDESCRIPTION: This snippet sets the output directory for binaries generated by the build system to '${PROJECT_BINARY_DIR}/output/bin'. This ensures that all compiled executables are placed in a consistent and organized location. It requires a proper CMake environment and assumes ${PROJECT_BINARY_DIR} is set, and it affects only executables' output path.\nSOURCE: https://github.com/apache/brpc/blob/master/tools/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/output/bin)\n```\n\n----------------------------------------\n\nTITLE: Finding LevelDB, OpenSSL, and RDMA Dependencies in CMake\nDESCRIPTION: Locates required dependencies including LevelDB, OpenSSL, and RDMA libraries. Sets up include paths and library references for each dependency with error messages if not found.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rdma_performance/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n\nfind_path(RDMA_INCLUDE_PATH NAMES infiniband/verbs.h)\nfind_library(RDMA_LIB NAMES ibverbs)\nif ((NOT RDMA_INCLUDE_PATH) OR (NOT RDMA_LIB))\n    message(FATAL_ERROR \"Fail to find ibverbs\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Compiler Flags and C++ Standard Configuration\nDESCRIPTION: Sets up compiler flags and ensures C++11 standard compatibility across different CMake versions and compilers.\nSOURCE: https://github.com/apache/brpc/blob/master/example/asynchronous_echo_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Response Processing for brpc (C++)\nDESCRIPTION: Specifies the callback prototype for processing individual protocol response messages on the client side. Must be implemented for correct protocol operation, allowing transformation or validation of input messages. Resource cleanup is required via msg->Destroy(), and parallel invocations may occur.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/new_protocol.md#_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\ntypedef void (*ProcessResponse)(InputMessageBase* msg);\n```\n\n----------------------------------------\n\nTITLE: Target Configuration and Linking\nDESCRIPTION: Creates executable targets for client and server, configuring them with necessary source files and library dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/example/asynchronous_echo_c++/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(asynchronous_echo_client client.cpp ${PROTO_SRC})\nadd_executable(asynchronous_echo_server server.cpp ${PROTO_SRC})\n\ntarget_link_libraries(asynchronous_echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(asynchronous_echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: Installing Thrift Dependencies on Linux\nDESCRIPTION: Commands to download, compile, and install Thrift dependencies on a Linux system. This process includes configuring Thrift with specific options to exclude unnecessary language bindings.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/thrift.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget https://downloads.apache.org/thrift/0.18.1/thrift-0.18.1.tar.gz\ntar -xf thrift-0.18.1.tar.gz\ncd thrift-0.18.1/\n./bootstrap.sh\n./configure --prefix=/usr --with-ruby=no --with-python=no --with-java=no --with-go=no --with-perl=no --with-php=no --with-csharp=no --with-erlang=no --with-lua=no --with-nodejs=no --with-rs=no --with-py3=no CXXFLAGS='-Wno-error'\nmake CPPFLAGS=-DFORCE_BOOST_SMART_PTR -j 4 -s\nsudo make install\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dynamic Libraries and MacOS Specific Settings\nDESCRIPTION: Configures dynamic libraries and includes MacOS specific framework dependencies and linker settings.\nSOURCE: https://github.com/apache/brpc/blob/master/example/backup_request_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    dl\n    )\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: BRPC Shared Library Configuration\nDESCRIPTION: Configures and builds BRPC shared library with optional dependencies for Glog and Thrift\nSOURCE: https://github.com/apache/brpc/blob/master/src/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_SHARED_LIBS)\n    add_library(brpc-shared SHARED $<TARGET_OBJECTS:BUTIL_LIB> \n                                   $<TARGET_OBJECTS:SOURCES_LIB>\n                                   $<TARGET_OBJECTS:PROTO_LIB>)\n    target_link_libraries(brpc-shared ${DYNAMIC_LIB})\n    if(WITH_GLOG)\n        target_link_libraries(brpc-shared ${GLOG_LIB})\n    endif()\n    if(WITH_THRIFT)\n        target_link_libraries(brpc-shared ${THRIFT_LIB})\n        check_thrift_version(brpc-shared)\n    endif()\n    SET_TARGET_PROPERTIES(brpc-shared PROPERTIES OUTPUT_NAME brpc CLEAN_DIRECT_OUTPUT 1)\n\n    target_link_libraries(protoc-gen-mcpack brpc-shared ${DYNAMIC_LIB} pthread)\n\n    install(TARGETS brpc-shared\n            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n            )\nelse()\n    target_link_libraries(protoc-gen-mcpack brpc-static ${DYNAMIC_LIB} pthread)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Ensuring C++11 Support Across Compilers\nDESCRIPTION: Handles C++11 standard setting for different CMake versions and compilers (GNU and Clang). For newer CMake versions, uses native C++11 support configuration.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding LevelDB Database Library\nDESCRIPTION: Locates LevelDB headers and library which is required for the examples. Fails with an error if LevelDB cannot be found.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nfind_path(LEVELDB_INCLUDE_PATH NAMES leveldb/db.h)\nfind_library(LEVELDB_LIB NAMES leveldb)\nif ((NOT LEVELDB_INCLUDE_PATH) OR (NOT LEVELDB_LIB))\n    message(FATAL_ERROR \"Fail to find leveldb\")\nendif()\ninclude_directories(${LEVELDB_INCLUDE_PATH})\n```\n\n----------------------------------------\n\nTITLE: Building Example Applications\nDESCRIPTION: Defines and links the final executable targets for the client and server examples with their required dependencies.\nSOURCE: https://github.com/apache/brpc/blob/master/example/session_data_and_thread_local/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(session_data_and_thread_local_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(session_data_and_thread_local_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(session_data_and_thread_local_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(session_data_and_thread_local_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n```\n\n----------------------------------------\n\nTITLE: Compiler Flags Configuration\nDESCRIPTION: Sets up C++ compiler flags and ensures C++11 support across different CMake versions and compilers.\nSOURCE: https://github.com/apache/brpc/blob/master/example/baidu_proxy_and_generic_call/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\n\nif(CMAKE_VERSION VERSION_LESS \"3.1.3\")\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\n    endif()\nelse()\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Debug Object Libraries for brpc Components\nDESCRIPTION: Creates object libraries for BUTIL and SOURCES components in debug mode. Sets position-independent code property for shared library support.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(BUTIL_DEBUG_LIB OBJECT ${BUTIL_SOURCES})\nadd_library(SOURCES_DEBUG_LIB OBJECT ${SOURCES})\nadd_dependencies(SOURCES_DEBUG_LIB PROTO_LIB)\n\n# shared library needs POSITION_INDEPENDENT_CODE\nset_property(TARGET ${BUTIL_DEBUG_LIB} PROPERTY POSITION_INDEPENDENT_CODE 1)\nset_property(TARGET ${SOURCES_DEBUG_LIB} PROPERTY POSITION_INDEPENDENT_CODE 1)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Path and Dependencies\nDESCRIPTION: Configures output path, finds required dependencies including Threads, Protobuf, and generates C++ files from proto definition.\nSOURCE: https://github.com/apache/brpc/blob/master/example/cancel_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n\ninclude(FindThreads)\ninclude(FindProtobuf)\nprotobuf_generate_cpp(PROTO_SRC PROTO_HEADER echo.proto)\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Dependency Resolution for Libraries\nDESCRIPTION: Finds and configures required libraries including bRPC, gflags, leveldb, and OpenSSL. Sets up include paths and handles platform-specific configurations.\nSOURCE: https://github.com/apache/brpc/blob/master/example/asynchronous_echo_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfind_library(THRIFT_LIB NAMES thrift)\nif (NOT THRIFT_LIB)\n    set(THRIFT_LIB \"\")\nendif()\n\nfind_path(BRPC_INCLUDE_PATH NAMES brpc/server.h)\nif(LINK_SO)\n    find_library(BRPC_LIB NAMES brpc)\nelse()\n    find_library(BRPC_LIB NAMES libbrpc.a brpc)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding Output Path with Bash Command in CMake\nDESCRIPTION: Executes a bash command to find the output directory path using find and regex. This path is then used to set CMAKE_PREFIX_PATH for locating required libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n```\n\n----------------------------------------\n\nTITLE: Running brpc Echo Example After Building\nDESCRIPTION: Commands for building and running the Echo server and client example from the brpc codebase to verify successful installation.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n$ cd example/echo_c++\n$ make\n$ ./echo_server &\n$ ./echo_client\n```\n\n----------------------------------------\n\nTITLE: Updating Version in CMakeLists.txt - Plain Text\nDESCRIPTION: An instruction to set the brpc version number inside the CMakeLists.txt configuration file. This ensures the correct version is used during build and packaging. The file must be committed after modification.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\nset(BRPC_VERSION 1.0.0)\n```\n\n----------------------------------------\n\nTITLE: Adding GPG Public Key to KEYS File by Email - Bash\nDESCRIPTION: Executes the process to append a public key and associated signatures to KEYS file by specifying the email address. Useful when the username is ambiguous or multiple keys share a name.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n(gpg --list-sigs lorinlee@apache.org && gpg -a --export lorinlee@apache.org) >> KEYS\n```\n\n----------------------------------------\n\nTITLE: Configuring Darwin-Specific Weak Symbols for brpc\nDESCRIPTION: Adds special linker flags for Darwin systems to explicitly specify weak symbol references for bthread-specific functions.\nSOURCE: https://github.com/apache/brpc/blob/master/test/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n                    \"-Wl,-U,_bthread_getspecific\"\n                    \"-Wl,-U,_bthread_setspecific\"\n                    \"-Wl,-U,_bthread_key_create\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running brpc Tests with CMake\nDESCRIPTION: Commands for building and running brpc unit tests using the CMake build system with the BUILD_UNIT_TESTS option enabled.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir build && cd build && cmake -DBUILD_UNIT_TESTS=ON .. && make && make test\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenSSL for MacOS\nDESCRIPTION: Sets OpenSSL root directory specifically for MacOS systems when using Homebrew-installed OpenSSL. Finds OpenSSL package and includes its headers.\nSOURCE: https://github.com/apache/brpc/blob/master/example/http_c++/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(OPENSSL_ROOT_DIR\n        \"/usr/local/opt/openssl\"    # Homebrew installed OpenSSL\n        )\nendif()\n\nfind_package(OpenSSL)\ninclude_directories(${OPENSSL_INCLUDE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project and Basic Options\nDESCRIPTION: Sets up the CMake project with minimum version requirement and defines basic project options including dynamic linking preference.\nSOURCE: https://github.com/apache/brpc/blob/master/example/session_data_and_thread_local/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(session_data_and_thread_local C CXX)\n\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Setting gRPC with JSON Protocol for HTTP/2 in ChannelOptions\nDESCRIPTION: Shows how to set the gRPC protocol with JSON serialization for HTTP/2 requests in ChannelOptions. This may require additional configuration on the gRPC side to support JSON serialization.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_derivatives.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nh2:grpc+json\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Libraries and Platform-Specific Settings\nDESCRIPTION: Defines dynamic library dependencies and sets up platform-specific linking requirements, particularly for macOS systems.\nSOURCE: https://github.com/apache/brpc/blob/master/example/redis_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(DYNAMIC_LIB\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${GFLAGS_LIBRARY}\n    ${PROTOBUF_LIBRARIES}\n    ${LEVELDB_LIB}\n    ${OPENSSL_CRYPTO_LIBRARY}\n    ${OPENSSL_SSL_LIBRARY}\n    ${THRIFT_LIB}\n    ${GPERFTOOLS_LIBRARIES}\n    dl\n    )\n```\n\n----------------------------------------\n\nTITLE: Building Cancel Client and Server Executables\nDESCRIPTION: Creates and links the final cancel_client and cancel_server executables with all required libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/cancel_c++/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(cancel_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(cancel_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(cancel_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(cancel_server ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: LogSink Usage Example in C++\nDESCRIPTION: Demonstrates how to use StringSink for capturing log output in unit tests\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/streaming_log.md#_snippet_4\n\nLANGUAGE: c++\nCODE:\n```\nTEST_F(StreamingLogTest, log_at) {\n    ::logging::StringSink log_str;\n    ::logging::LogSink* old_sink = ::logging::SetLogSink(&log_str);\n    LOG_AT(FATAL, \"specified_file.cc\", 12345) << \"file/line is specified\";\n    ASSERT_NE(std::string::npos, log_str.find(\"specified_file.cc:12345\"));\n    ::logging::SetLogSink(old_sink);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Executables and Linking Libraries\nDESCRIPTION: Adds server and client executables and links them with the necessary libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/grpc_c++/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(server server.cpp ${PROTO_SRC} ${PROTO_HEADER} )\nadd_executable(client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n```\n\n----------------------------------------\n\nTITLE: Building Executables and Linking Libraries\nDESCRIPTION: Creates client and server executables and links them with required libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/backup_request_c++/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(backup_request_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(backup_request_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(backup_request_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(backup_request_server ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: Installing Additional Dependencies for Static LevelDB on Ubuntu\nDESCRIPTION: Command to install Snappy compression library required for statically linking leveldb on Ubuntu-based systems.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get install -y libsnappy-dev\n```\n\n----------------------------------------\n\nTITLE: Target Configuration and Linking\nDESCRIPTION: Defines build targets for echo client/server and proxy, linking them with required libraries.\nSOURCE: https://github.com/apache/brpc/blob/master/example/baidu_proxy_and_generic_call/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(proxy proxy.cpp)\nadd_executable(echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(echo_client ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(proxy ${BRPC_LIB} ${DYNAMIC_LIB})\ntarget_link_libraries(echo_server ${BRPC_LIB} ${DYNAMIC_LIB})\n```\n\n----------------------------------------\n\nTITLE: Finding Project Output Path\nDESCRIPTION: Executes a bash command to locate the project's output directory for include files.\nSOURCE: https://github.com/apache/brpc/blob/master/example/parallel_echo_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n```\n\n----------------------------------------\n\nTITLE: Setting Content-Type Header in brpc\nDESCRIPTION: Shows how to set the Content-Type header for an HTTP request. This is commonly needed when sending data formats like JSON, XML, or plain text.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/http_client.md#_snippet_9\n\nLANGUAGE: c++\nCODE:\n```\ncntl->http_request().set_content_type(\"text/plain\");\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags for C++\nDESCRIPTION: Sets compiler flags for C++, including optimization level, warnings, and C++11 standard.\nSOURCE: https://github.com/apache/brpc/blob/master/example/grpc_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_FLAGS \"${DEFINE_CLOCK_GETTIME} -DNDEBUG -O2 -D__const__=__unused__ -pipe -W -Wall -Wno-unused-parameter -fPIC -fno-omit-frame-pointer\")\nset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -DBRPC_ENABLE_CPU_PROFILER\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Channel with Recovery Parameters in C++\nDESCRIPTION: Demonstrates how to initialize a channel with min_working_instances and hold_seconds parameters for flow control during cluster recovery.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/client.md#_snippet_6\n\nLANGUAGE: c++\nCODE:\n```\nchannel.Init(\"http://...\", \"random:min_working_instances=6 hold_seconds=10\", &options);\n```\n\n----------------------------------------\n\nTITLE: Building Echo Client and Server Executables\nDESCRIPTION: Defines and links the final executable targets for the parallel echo client and server applications.\nSOURCE: https://github.com/apache/brpc/blob/master/example/parallel_echo_c++/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(parallel_echo_client client.cpp ${PROTO_SRC} ${PROTO_HEADER})\nadd_executable(parallel_echo_server server.cpp ${PROTO_SRC} ${PROTO_HEADER})\n\ntarget_link_libraries(parallel_echo_client ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\ntarget_link_libraries(parallel_echo_server ${BRPC_LIB} ${DYNAMIC_LIB} ${GPERFTOOLS_LIBRARIES})\n```\n\n----------------------------------------\n\nTITLE: Alternative Homebrew Paths for brpc on MacOS Monterey\nDESCRIPTION: Alternative command for building brpc on MacOS Monterey, which uses different paths for Homebrew-installed libraries and headers.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/getting_started.md#_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\n$ sh config_brpc.sh --headers=/opt/homebrew/include --libs=/opt/homebrew/lib --cc=clang --cxx=clang++\n$ make\n```\n\n----------------------------------------\n\nTITLE: Supporting Object Structures in C++\nDESCRIPTION: Implementation of supporting structures B and C with their streaming operators\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/streaming_log.md#_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nstruct B {\n    int value;\n};\nstd::ostream& operator<<(std::ostream& os, const B& b) {\n    return os << \"B{value=\" << b.value << \"}\";\n}\n\nstruct C {\n    string name;\n};\nstd::ostream& operator<<(std::ostream& os, const C& c) {\n    return os << \"C{name=\" << c.name << \"}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ostream Operator for Custom Types in C++\nDESCRIPTION: Demonstrates how to implement the ostream operator for custom types to enable streaming log functionality.\nSOURCE: https://github.com/apache/brpc/blob/master/docs/en/streaming_log.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nstruct A {\n    B b;\n    C c;\n};\nstd::ostream& operator<<(std::ostream& os, const A& a) {\n    return os << \"A{b=\" << a.b << \", c=\" << a.c << \"}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Object Streaming Example in C++\nDESCRIPTION: Example of implementing streaming operators for nested object structures with multiple fields\nSOURCE: https://github.com/apache/brpc/blob/master/docs/cn/streaming_log.md#_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nstruct A {\n    B b;\n    C c;\n};\nstd::ostream& operator<<(std::ostream& os, const A& a) {\n    return os << \"A{b=\" << a.b << \", c=\" << a.c << \"}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MacOS-Specific Settings\nDESCRIPTION: Sets up MacOS-specific library configurations and linker flags for system frameworks and external functions.\nSOURCE: https://github.com/apache/brpc/blob/master/example/parallel_echo_c++/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(DYNAMIC_LIB ${DYNAMIC_LIB}\n        pthread\n        \"-framework CoreFoundation\"\n        \"-framework CoreGraphics\"\n        \"-framework CoreData\"\n        \"-framework CoreText\"\n        \"-framework Security\"\n        \"-framework Foundation\"\n        \"-Wl,-U,_MallocExtension_ReleaseFreeMemory\"\n        \"-Wl,-U,_ProfilerStart\"\n        \"-Wl,-U,_ProfilerStop\"\n        \"-Wl,-U,__Z13GetStackTracePPvii\"\n        \"-Wl,-U,_mallctl\"\n        \"-Wl,-U,_malloc_stats_print\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific Configuration for MacOS in CMake\nDESCRIPTION: Checks for platform-specific features on MacOS, particularly the availability of clock_gettime. Sets a definition flag if the function is not available to ensure compatibility across platforms.\nSOURCE: https://github.com/apache/brpc/blob/master/example/rdma_performance/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    include(CheckFunctionExists)\n    CHECK_FUNCTION_EXISTS(clock_gettime HAVE_CLOCK_GETTIME)\n    if(NOT HAVE_CLOCK_GETTIME)\n        set(DEFINE_CLOCK_GETTIME \"-DNO_CLOCK_GETTIME_IN_MAC\")\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Option for Dynamic Linking\nDESCRIPTION: Defines a CMake option to determine whether examples should be linked dynamically.\nSOURCE: https://github.com/apache/brpc/blob/master/example/grpc_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\noption(LINK_SO \"Whether examples are linked dynamically\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for gRPC C++\nDESCRIPTION: Sets up the CMake project for gRPC C++ with a minimum required version and project name.\nSOURCE: https://github.com/apache/brpc/blob/master/example/grpc_c++/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 2.8.10)\nproject(grpc_c++ C CXX)\n```\n\n----------------------------------------\n\nTITLE: Finding Output Path for Include Directory\nDESCRIPTION: Executes a bash command to find the output path for include directories.\nSOURCE: https://github.com/apache/brpc/blob/master/example/grpc_c++/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n```\n\n----------------------------------------\n\nTITLE: Finding Output Path Using Execute Process\nDESCRIPTION: Executes a bash command to find the output include directory path.\nSOURCE: https://github.com/apache/brpc/blob/master/example/backup_request_c++/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n```\n\n----------------------------------------\n\nTITLE: Finding Project Output Path\nDESCRIPTION: Executes a bash command to locate the project's output directory for include files.\nSOURCE: https://github.com/apache/brpc/blob/master/example/session_data_and_thread_local/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n    COMMAND bash -c \"find ${PROJECT_SOURCE_DIR}/../.. -type d -regex \\\".*output/include$\\\" | head -n1 | xargs dirname | tr -d '\\n'\"\n    OUTPUT_VARIABLE OUTPUT_PATH\n)\n\nset(CMAKE_PREFIX_PATH ${OUTPUT_PATH})\n```\n\n----------------------------------------\n\nTITLE: Configuring Unit Tests and Fuzz Tests in CMake for Apache brpc\nDESCRIPTION: Sets up conditional compilation of unit tests and fuzz tests. Ensures that fuzz tests are only built with Clang compiler and when unit tests are enabled.\nSOURCE: https://github.com/apache/brpc/blob/master/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(src)\nif(BUILD_UNIT_TESTS)\n    enable_testing()\n    add_subdirectory(test)\nendif()\n\nif(BUILD_FUZZ_TESTS)\n    if(NOT CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n        message(FATAL_ERROR \"Fuzzing is only supported with clang\")\n    endif()\n    if(NOT BUILD_UNIT_TESTS)\n        message(FATAL_ERROR \"BUILD_UNIT_TESTS must be enabled to build fuzz tests\")\n    endif()\nendif()\n\nif(BUILD_BRPC_TOOLS)\n    add_subdirectory(tools)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Implementing Checksum Masking in C\nDESCRIPTION: Function to mask CRC-32C checksums using bit rotation and constant addition. The masking is reversible and uses the same technique as Apache Hadoop.\nSOURCE: https://github.com/apache/brpc/blob/master/src/butil/third_party/snappy/framing_format.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nuint32_t mask_checksum(uint32_t x) {\n    return ((x >> 15) | (x << 17)) + 0xa282ead8;\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Release Directory and SHA512 Checksum - Bash\nDESCRIPTION: Changes directory to the release location and checks the SHA512 checksum of the release tarball, ensuring file integrity prior to publication or announcement. The checksum must match what is provided in the .sha512 file.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/brpc_svn/dev/brpc/1.0.0\n```\n\nLANGUAGE: bash\nCODE:\n```\nsha512sum --check apache-brpc-1.0.0-src.tar.gz.sha512\n```\n\n----------------------------------------\n\nTITLE: Generating and Verifying SHA512 Checksum - Bash\nDESCRIPTION: Computes the SHA512 checksum for the release tarball and saves it to a .sha512 file, then verifies the checksum. This ensures the integrity of the distributed archive. Requires sha512sum utility.\nSOURCE: https://github.com/apache/brpc/blob/master/community/release_en.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nsha512sum apache-brpc-1.0.0-src.tar.gz > apache-brpc-1.0.0-src.tar.gz.sha512\\n\\nsha512sum --check apache-brpc-1.0.0-src.tar.gz.sha512\n```\n\n----------------------------------------\n\nTITLE: Apache bRPC PPMC Member Development Process Documentation\nDESCRIPTION: Markdown documentation outlining the process for upgrading a committer to PPMC member status, including voting procedures and administrative steps.\nSOURCE: https://github.com/apache/brpc/blob/master/community/newcommitter_en.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## 2. How to upgrade a committer into a PPMC\n\n### Process reference: Apache official website document\n\n* https://incubator.apache.org/guides/ppmc.html#voting_in_a_new_ppmc_member\n* https://community.apache.org/newcommitter.html\n* https://incubator.apache.org/guides/ppmc.html#podling_project_management_committee_ppmc\n```\n\n----------------------------------------\n\nTITLE: Base64 Encoded String\nDESCRIPTION: A base64 encoded representation of the text 'hello world'\nSOURCE: https://github.com/apache/brpc/blob/master/test/fuzzing/fuzz_butil_seed_corpus/base64_decoded.txt#_snippet_0\n\nLANGUAGE: base64\nCODE:\n```\naGVsbG8gd29ybGQ=\n```"
  }
]