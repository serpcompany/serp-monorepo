[
  {
    "owner": "erlang",
    "repo": "erlang-org",
    "content": "TITLE: Using persistent_term for Caching in a Gen Server State in Erlang\nDESCRIPTION: This code snippet shows how to use persistent_term to cache the state of a gen_server, reducing garbage collection pauses for large constant data. It periodically updates the cached state and retrieves it when needed.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-9-9-persistent_term.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nhandle_info(timeout, State) ->\n  persistent_term:put(?MODULE,State),\n  erlang:start_timer(60 * 60 * 1000, self(), timeout),\n  {noreply,persistent_term:get(?MODULE)}.\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Functions in the Erlang Shell - Erlang\nDESCRIPTION: Demonstrates direct function definition and execution in the Erlang shell, showing support for multi-line local function entry, parameter handling, and simple evaluation. Dependencies include the built-in erl_eval module, and all input is REPL-based. The user defines a factorial/1 and factorial/2 function, invokes it for 5, and receives the expected output. This method of function input does not use the compiler and as such is less performant, but much more interactive for prototyping.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n1> factorial(N) -> factorial(N, 1).\nok\n2> factorial(N, F) when N > 1 -> factorial(N - 1, F * N);\n.. factorial(_, F) -> F.\nok\n3> factorial(5).\n120\n```\n\n----------------------------------------\n\nTITLE: Optimized Global Counters using persistent_term and counters in Erlang\nDESCRIPTION: This snippet demonstrates an optimized implementation of global counters using persistent_term and the counters module. It provides significant performance improvements over the ETS-based approaches.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-9-9-persistent_term.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ncnt_pt_incr(Counter) ->\n    counters:add(persistent_term:get({?MODULE,Counter}),1,1).\n\ncnt_pt_read(Counter) ->\n    counters:get(persistent_term:get({?MODULE,Counter}),1).\n```\n\n----------------------------------------\n\nTITLE: Incrementing and Reading Global Counters using ETS in Erlang\nDESCRIPTION: This snippet demonstrates how to implement global counters using a striped ETS table for improved performance in high-concurrency scenarios. It includes functions for incrementing and reading counter values.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-9-9-persistent_term.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nincr(Counter) ->\n  ets:update_counter(?MODULE,{Counter,erlang:system_info(scheduler_id)},1).\n\nread(Counter) ->\n  lists:sum(ets:select(?MODULE,[{{{Counter,'_'},'$1'},[],['$1']}])).\n```\n\n----------------------------------------\n\nTITLE: Encoding Erlang Terms to JSON\nDESCRIPTION: Demonstrates how to encode Erlang terms to JSON using json:encode/1 function, which automatically handles maps with atom, binary, or integer keys.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_27\n\nLANGUAGE: erlang\nCODE:\n```\n4> io:format(\"~ts\\n\", [json:encode(Qs)]).\n[{\"quote\":\"The gods are best served by those who need their help the least.\",\"attribution\":\"Zeus\",\"verified\":true},{\"quote\":\"Now the voyage is over, I don't want any trouble to begin.\",\"attribution\":\"Jason\",\"verified\":true}]\nok\n```\n\n----------------------------------------\n\nTITLE: Mapping String Uppercase Function in Erlang\nDESCRIPTION: Shows how to use lists:map with string:uppercase/1 to convert a list of strings to uppercase. The example creates a list of fruits and applies the uppercase transformation to each element.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/4-lists-small.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n> Fruits = [\"banana\",\"monkey\"].\n[\"banana\",\"monkey\"]\n> lists:map(\n    fun string:uppercase/1,\n    Fruits).\n[\"BANANA\",\"MONKEY\"]\n```\n\n----------------------------------------\n\nTITLE: Documenting and Implementing Duplicate Function - Erlang/OTP 27 - Erlang\nDESCRIPTION: Shows the Erlang/OTP 27 approach using markdown documentation, -doc attributes, and triple-quoted strings embedded in the source code before the function spec and implementation. This snippet also provides the type specification and the implementation for `duplicate/2`, using pattern matching for recursion. No dependencies other than OTP/27 are required; parameters include the copy count N and element Elem, and output is a list containing N elements.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-doc \"\"\"\\nReturns a list containing `N` copies of term `Elem`.\\n\\n_Example:_\\n\\n```erlang\\n> lists:duplicate(5, xx).\\n[xx,xx,xx,xx,xx]\\n```\\n\"\"\".\\n\\n-spec duplicate(N, Elem) -> List when\\n      N :: non_neg_integer(),\\n      Elem :: T,\\n      List :: [T],\\n      T :: term().\\n\\nduplicate(N, X) when is_integer(N), N >= 0 -> duplicate(N, X, []).\\n\\nduplicate(0, _, L) -> L;\\nduplicate(N, X, L) -> duplicate(N-1, X, [X|L]).\n```\n\n----------------------------------------\n\nTITLE: Optimized Request-Response Module in Erlang\nDESCRIPTION: This Erlang module demonstrates an optimized implementation of the request-response pattern, using separate functions for initiating the request and awaiting the result. It includes compiler annotations showing optimization details.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-03-19-message-passing.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n-module(example).\n-export([t/2]).\n\nt(Pid, Request) ->\n    %% example.erl:5: OPTIMIZED: reference used to mark a \n    %%                           message queue position\n    Mref = monitor(process, Pid),\n    Pid ! {self(), Mref, Request},\n    %% example.erl:7: INFO: passing reference created by\n    %%                      monitor/2 at example.erl:5\n    await_result(Mref).\n\nawait_result(Mref) ->\n    %% example.erl:10: OPTIMIZED: all clauses match reference\n    %%                            in function parameter 1\n    receive\n        {Mref, Response} ->\n            erlang:demonitor(Mref, [flush]),\n            {ok, Response};\n        {'DOWN', Mref, _, _, Reason} ->\n            {error, Reason}\n    end.\n```\n\n----------------------------------------\n\nTITLE: Grouping Elements Using maps:groups_from_list/2,3 in Erlang\nDESCRIPTION: The maps:groups_from_list function takes a list of elements and groups them into a map, based on a provided function that determines the grouping key. The function also provides an option to transform the values before grouping them. It requires Erlang's maps module to be available.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_0\n\nLANGUAGE: Erlang\nCODE:\n```\n> maps:groups_from_list(fun(X) -> X rem 2 end, [1,2,3]).\n#{0 => [2], 1 => [1, 3]}\n```\n\nLANGUAGE: Erlang\nCODE:\n```\n> maps:groups_from_list(fun erlang:length/1, [\"ant\", \"buffalo\", \"cat\", \"dingo\"]).\n#{3 => [\"ant\", \"cat\"], 5 => [\"dingo\"], 7 => [\"buffalo\"]}\n```\n\nLANGUAGE: Erlang\nCODE:\n```\n> maps:groups_from_list(fun(X) -> X rem 2 end, fun(X) -> X*X end, [1,2,3]).\n#{0 => [4], 1 => [1, 9]}\n```\n\nLANGUAGE: Erlang\nCODE:\n```\n> maps:groups_from_list(fun erlang:length/1, fun lists:reverse/1, [\"ant\", \"buffalo\", \"cat\", \"dingo\"]).\n#{3 => [\"tna\",\"tac\"],5 => [\"ognid\"],7 => [\"olaffub\"]}\n```\n\n----------------------------------------\n\nTITLE: Implementing Factorial Function and Demonstrating Shell Interaction in Erlang\nDESCRIPTION: This snippet defines a factorial function using pattern matching and recursion. It then demonstrates how to use the function in Erlang's interactive shell, including a list comprehension to generate factorial results for numbers 1 to 10.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/1-fact-large.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nfact(0) -> 1;              %% Pattern matching for control-flow\nfact(N) -> N * fact(N-1).  %% Recursion to create loops\n\n> example:fact(10).        %% Interactive shell for fast iterations\n3628800\n> [{I, example:fact(I)} || I <- lists:seq(1,10)].\n[{1, 1}, {2, 2}, {3, 6}, {4, 24}, {5, 120}, {6, 720},\n {7, 5040}, {8, 40320}, {9, 362880}, {10, 3628800}]\n```\n\n----------------------------------------\n\nTITLE: Creating and Communicating with Lightweight Processes in Erlang\nDESCRIPTION: This code demonstrates the creation of a child process, sending a message to trigger its execution, and receiving a response. It showcases Erlang's lightweight process model and basic message passing mechanisms.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/5-processes-large.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n> Parent = self().                         %% Get own process id\n<0.376.0>\n> Child = spawn(fun() -> receive go -> Parent ! lists:seq(1,100) end end).\n<0.930.0>\n> Child ! go.                              %% Send message to child\ngo\n> receive Reply -> Reply end.              %% Receive response from child\n[1,2,3,4,5,6,7,8,9,10,11|...]\n```\n\n----------------------------------------\n\nTITLE: Implementing gen_server Call Pattern and Receive Optimization - Erlang\nDESCRIPTION: Demonstrates the canonical gen_server-style call pattern and its optimization by the Erlang compiler. Shows variations: a simple synchronous call, a slightly more complex asynchronous variant, and a multi-call. These rely on 'make_ref', message passing (!), 'receive', and list comprehensions. Prerequisites: familiarity with Erlang process/message model and basic syntax. Inputs are process ids, messages, and flags; outputs are replies or status tuples. The examples illustrate which constructs the OTP 24 compiler can optimize for receive scanning, emphasizing limitations when code spans modules or is too complex.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\ncall(To, Msg) ->\n  Ref = make_ref(),\n  To ! {call, Ref, self(), Msg},\n  receive\n    {reply, Ref, Reply} -> Reply\n  end.\n```\n\nLANGUAGE: erlang\nCODE:\n```\ncall(To, Msg, Async) ->\n  Ref = make_ref(),\n  To ! {call, Ref, self(), Msg},\n  if\n    Async ->\n      {ok, Ref};\n    not Async ->\n      receive\n        {reply, Ref, Reply} -> Reply\n      end\n  end.\n```\n\nLANGUAGE: erlang\nCODE:\n```\nmulti_call(ToList, Msg) ->\n  %% OPTIMIZED: reference used to mark a message queue position\n  Ref = make_ref(),\n  %% INFO: passing reference created by make_ref/0 at test.erl:18\n  [To ! {call, Ref, self(), Msg} || To <- ToList],\n  %% INFO: passing reference created by make_ref/0 at test.erl:18\n  %% OPTIMIZED: all clauses match reference\n  %%            in function parameter 2\n  [receive {reply, Ref, Reply} -> Reply end || _ <- ToList].\n```\n\n----------------------------------------\n\nTITLE: Implementing Factorial Function in Erlang\nDESCRIPTION: A recursive implementation of the factorial function in Erlang. It uses pattern matching to handle the base case (0) and recursive case (N). The example shows calling the function with input 10.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/2-fact-small.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n%% Return factorial for N\nfact(0) -> 1;\nfact(N) -> N * fact(N-1).\n\n> example:fact(10).\n3628800\n```\n\n----------------------------------------\n\nTITLE: Using Map and Fold Operations in Erlang\nDESCRIPTION: Shows how to use lists:map with string:uppercase and lists:foldl with a custom function to process a list of strings. Includes examples of immutable variable assignment, mapping strings to uppercase, and calculating total string length using fold.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/3-lists-large.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n> Fruits = [\"banana\",\"monkey\",\"jungle\"].     %% Immutable variables\n[\"banana\",\"monkey\",\"jungle\"]\n> lists:map(fun string:uppercase/1, Fruits). %% Map values using stdlib functions\n[\"BANANA\",\"MONKEY\",\"JUNGLE\"]\n%% Fold over lists using custom functions\n> lists:foldl(fun(Str, Cnt) -> string:length(Str) + Cnt end, 0, Fruits).\n18\n```\n\n----------------------------------------\n\nTITLE: Optimized Request-Response Pattern in Erlang\nDESCRIPTION: This snippet demonstrates an optimized version of the request-response idiom in Erlang. It uses a reference created by monitor/2 to mark a message queue position, improving performance for processes with long message queues.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-03-19-message-passing.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nMref = monitor(process, Pid),\nPid ! {self(), Mref, Request},\nreceive\n    {Mref, Response} ->\n        erlang:demonitor(Mref, [flush]),\n        {ok, Response};\n    {'DOWN', Mref, _, _, Reason} ->\n        {error, Reason}\nend\n```\n\n----------------------------------------\n\nTITLE: Simplified MWC59 PRNG Implementation in Erlang\nDESCRIPTION: The final implementation of the MWC59 PRNG in Erlang that extracts a 32-bit digit and carry from the state, then combines them with a multiplication to generate the next state.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_18\n\nLANGUAGE: erlang\nCODE:\n```\nmwc59(T) ->\n    C = T bsr 32,\n    X = T band ((1 bsl 32)-1),\n    16#7fa6502 * X + C.\n```\n\n----------------------------------------\n\nTITLE: Using Triple-Quoted String Literals for Multi-Line Output - Erlang/OTP 27 - Erlang\nDESCRIPTION: Introduces the triple-quoted string syntax available from Erlang/OTP 27, enabling direct embedding of multi-line text without escaping quotes or newlines. The snippet defines a function that prints quotations, leveraging indentation-aware block strings. It uses the io module for output and removes the need for line-by-line quoting or escaping.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\nquotes() ->\\n    S = \"\"\"\\n        \\\"I always have a quotation for everything -\\n        it saves original thinking.\\\" - Dorothy L. Sayers\\n\\n        \\\"Real stupidity beats artificial intelligence every time.\\\"\\n        - Terry Pratchett\\n        \"\"\",\\n    io:put_chars(S),\\n    io:nl().\n```\n\n----------------------------------------\n\nTITLE: New Lists Search Function - Erlang\nDESCRIPTION: Example of the new lists:search() function that returns {ok, Value} or false.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/123.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nlists:search(list,fun/1) -> {ok, Value} | false\n```\n\n----------------------------------------\n\nTITLE: Optimized Base64 Encoding in OTP 26\nDESCRIPTION: Improved Base64 encoding implementation using 6-bit segments for more natural binary matching, introduced in OTP 26.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_33\n\nLANGUAGE: erlang\nCODE:\n```\nencode_binary(<<B1:6, B2:6, B3:6, B4:6, Ls/bits>>, A) ->\n    encode_binary(Ls,\n                  <<A/bits,\n                    (b64e(B1)):8,\n                    (b64e(B2)):8,\n                    (b64e(B3)):8,\n                    (b64e(B4)):8>>);\n```\n\n----------------------------------------\n\nTITLE: Map Comprehensions over Map Iterators with Custom Order - Erlang\nDESCRIPTION: Utilizes map iterators returned by maps:iterator/2 with various modes ('ordered', 'reversed', and custom sort fun) in comprehensions to extract key-value pairs from a map. Each form demonstrates how traversing the map can honor different key orderings. Depends on maps:iterator/2 and OTP 26 map comprehension support.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_11\n\nLANGUAGE: erlang\nCODE:\n```\n4> AM = #{a => 1, b => 2, c => 1}.\n#{c => 1,a => 1,b => 2}\n5> [{K,V} || K := V <- maps:iterator(AM, ordered)].\n[{a,1},{b,2},{c,1}]\n6> [{K,V} || K := V <- maps:iterator(AM, reversed)].\n[{c,1},{b,2},{a,1}]\n7> [{K,V} || K := V <- maps:iterator(AM, fun(A, B) -> A > B end)].\n[{c,1},{b,2},{a,1}]\n\n```\n\n----------------------------------------\n\nTITLE: Using underscores in numeric literals for improved readability in Erlang\nDESCRIPTION: Examples of using underscores in numeric literals to improve readability in Erlang code, showing both decimal and hexadecimal notation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/140.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n123_456_789\n```\n\nLANGUAGE: erlang\nCODE:\n```\n16#1234_ABCD\n```\n\n----------------------------------------\n\nTITLE: Initializing TLS Client and Server with Debug Logging in Erlang\nDESCRIPTION: This Erlang module demonstrates setting up a basic TLS server and client using the `ssl` application. Both functions enable verbose debug logging by setting the `log_level` option to `debug` in the socket options and configuring the global logger level for the `ssl` application using `logger:set_application_level(ssl, debug)`. The server listens on a defined port, accepts a connection, and performs a handshake. The client connects to the server, verifying the peer certificate.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-module(ssltest).\n\n-compile(export_all).\n\n-define(PORT, 11000).\n\nserver() ->\n    application:load(ssl),\n    logger:set_application_level(ssl, debug),\n    {ok, _} = application:ensure_all_started(ssl),\n    Port = ?PORT,\n    LOpts = [{certfile, \"server.pem\"},\n             {keyfile, \"server.key\"},\n             {versions, ['tlsv1.2']},\n             {log_level, debug}\n            ],\n    {ok, LSock} = ssl:listen(Port, LOpts),\n    {ok, CSock} = ssl:transport_accept(LSock),\n    {ok, _} = ssl:handshake(CSock).\n\nclient() ->\n    application:load(ssl),\n    logger:set_application_level(ssl, debug),\n    {ok, _} = application:ensure_all_started(ssl),\n    Port = ?PORT,\n    COpts = [{verify, verify_peer},\n             {cacertfile, \"ca.pem\"},\n             {versions, ['tlsv1.2']},\n             {log_level, debug}\n            ],\n    {ok, Sock} = ssl:connect(\"localhost\", Port, COpts).\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Map-Reduce for Even Number Filtering in Erlang\nDESCRIPTION: This code implements a parallel map-reduce operation that filters even numbers from a list. It spawns a separate process for each number to evaluate the filtering function concurrently, then collects results through message passing. The even/1 function serves as the entry point, using a predicate that checks if a number is divisible by 2.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/8-parallel-mapreduce.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-spec even(list(integer())) -> list(integer()).\neven(Numbers) ->\n  mapreduce(Numbers, fun(Number) -> Number rem 2 == 0 end).\nmapreduce(Numbers, Function) ->\n  Parent = self(),\n  [spawn(fun() -> Parent ! {Number, Function(Number)} end) || Number <- Numbers],\n  lists:flatten(\n    [receive {Number, true} -> Number; _ -> [] end || Number <- Numbers]).\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang/OTP via Package Managers (Bash)\nDESCRIPTION: These commands demonstrate how to install pre-built Erlang/OTP binary packages using various common operating system package managers. Each command is specific to a package manager: `brew` for Homebrew (macOS), `port` for MacPorts (macOS), `apt-get` for Debian/Ubuntu, `dnf` for Fedora, `pacman` for ArchLinux/Manjaro, and `pkg` for FreeBSD. Using a package manager simplifies installation by handling dependencies automatically. Requires the respective package manager to be installed and configured.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/downloads.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew install erlang\n```\n\nLANGUAGE: bash\nCODE:\n```\nport install erlang\n```\n\nLANGUAGE: bash\nCODE:\n```\napt-get install erlang\n```\n\nLANGUAGE: bash\nCODE:\n```\ndnf install erlang\n```\n\nLANGUAGE: bash\nCODE:\n```\npacman -S erlang\n```\n\nLANGUAGE: bash\nCODE:\n```\npkg install erlang\n```\n\n----------------------------------------\n\nTITLE: Using Atomics for Shared Mutable Bit Vector in Erlang\nDESCRIPTION: This Erlang snippet showcases a use case for the `atomics` module (introduced in OTP 21.2) by creating and manipulating a shared mutable bit vector. It initializes an 80-bit vector using a `bit_vector` module (which likely uses `atomics` internally). It then spawns 100 concurrent processes, each continuously flipping a randomly chosen bit in the shared vector using `bit_vector:flip/2`. After 1 second, the final state of the bit vector is printed, demonstrating concurrent modification of shared state. Requires the `bit_vector` module, potentially defined as shown in the linked gist.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-5-13-OTP-22-Highlights.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nBV = bit_vector:new(80),\n[spawn(fun F() ->\n            bit_vector:flip(BV, rand:uniform(80)-1),\n            F()\n          end) || _ <- lists:seq(1,100)],\ntimer:sleep(1000),\nbit_vector:print(BV).\n```\n\n----------------------------------------\n\nTITLE: Pasting Records, Types, and Function Specs into the Shell - Erlang\nDESCRIPTION: Demonstrates the ability to enter record definitions, type specifications, and function specs directly in the Erlang shell. Shows use of -record, -type, and -spec, followed by an example function add/2 operating on records, instantiating records, and combining two coordinates. Inputs are shell commands; outputs are record construction and computation. Dependencies include built-in shell support for records and types, and assumes OTP 26 or newer.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n1> -record(coord, {x=0.0 :: float(), y=0.0 :: float()}).\nok\n2> -type coord() :: #coord{}.\nok\n3> -spec add(coord(), coord()) -> coord().\nok\n4> add(#coord{x=X1, y=Y1}, #coord{x=X2, y=Y2}) ->\n..     #coord{x=X1+X2, y=Y1+Y2}.\nok\n5> Origin = #coord{}.\n#coord{x = 0.0,y = 0.0}\n6> add(Origin, #coord{y=10.0}).\n#coord{x = 0.0,y = 10.0}\n```\n\n----------------------------------------\n\nTITLE: Committing Backup Files with Flat Error Handling Using 'maybe' Construct - Erlang\nDESCRIPTION: This snippet refactors sequential error handling into a visually flat form using the 'maybe' construct, making the flow of operations clear. It performs three operations (sync, close, and rename) on fields from the OpaqueData#backup record, each checked for success with '?='. The function returns {ok, File} if all succeed, otherwise an error is propagated. Dependencies remain the same as the previous example. This approach requires Erlang/OTP that supports the 'maybe' construct. It improves readability and maintainability, but may not protect against unexpected return values from the functions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\ncommit_write(OpaqueData) ->\n    maybe\n        ok ?= disk_log:sync(OpaqueData#backup.file_desc),\n        ok ?= disk_log:close(OpaqueData#backup.file_desc),\n        ok ?= file:rename(OpaqueData#backup.tmp_file, OpaqueData#backup.file),\n        {ok, OpaqueData#backup.file}\n    end.\n```\n\n----------------------------------------\n\nTITLE: Numeric Literal with Underscores Example - Erlang\nDESCRIPTION: Demonstration of the new feature allowing underscores in numeric literals to improve readability in Erlang code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/138.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n123_456_789\n16#1234_ABCD\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running Erlang Code with Default 'maybe' Expression (OTP 27+)\nDESCRIPTION: Demonstrates the workflow in Erlang/OTP 27 and later. It shows the content of `t.erl` using the `maybe` expression without requiring a `-feature(maybe_expr, enable).` directive. The subsequent shell commands compile (`erlc t.erl`) and run (`erl`) the code, successfully executing `t:listen_port/2`, confirming that the `maybe` expression feature is enabled by default in the compiler.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n$ cat t.erl\n-module(t).\n-export([listen_port/2]).\nlisten_port(Port, Options) ->\n    maybe\n        {ok, ListenSocket} ?= inet_tcp:listen(Port, Options),\n        {ok, Address} ?= inet:sockname(ListenSocket),\n        {ok, {ListenSocket, Address}}\n    end.\n$ erlc t.erl\n$ erl\nErlang/OTP 27 . . .\n\nEshell V15.0  (abort with ^G)\n1> t:listen_port(50000, []).\n{ok,{#Port<0.5>,{{0,0,0,0},50000}}}\n```\n\n----------------------------------------\n\nTITLE: Basic Receive Expression in Erlang\nDESCRIPTION: This snippet shows a simple receive expression in Erlang, demonstrating how to pattern match on incoming messages. It waits for a message matching {reply, Result} and returns it wrapped in an ok tuple.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-03-19-message-passing.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nreceive\n    {reply, Result} ->\n        {ok, Result}\nend\n```\n\n----------------------------------------\n\nTITLE: Defining an Exception Handling Function in Erlang\nDESCRIPTION: This Erlang code defines a function `exception/0` that demonstrates basic exception handling. It uses a `try...catch` block to call an external function (`external:call/0`). If this call throws an exception matching the pattern `throw:example`, the function returns the atom `hello`. Other exceptions are implicitly re-thrown.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\nexception() ->\n    try\n        external:call()\n    catch\n        throw:example -> hello\n    end.\n```\n\n----------------------------------------\n\nTITLE: Base64 encoding helper function\nDESCRIPTION: The b64e/1 helper function that maps integers to Base64 characters using element/2. In OTP 25, the JIT optimizes this function by removing type tests and range checks, significantly improving performance.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_38\n\nLANGUAGE: erlang\nCODE:\n```\n-compile({inline, [{b64e, 1}]}).\nb64e(X) ->\n    element(X+1,\n\t    {$A, $B, $C, $D, $E, $F, $G, $H, $I, $J, $K, $L, $M, $N,\n\t     $O, $P, $Q, $R, $S, $T, $U, $V, $W, $X, $Y, $Z,\n\t     $a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n,\n\t     $o, $p, $q, $r, $s, $t, $u, $v, $w, $x, $y, $z,\n\t     $0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $+, $/}).\n```\n\n----------------------------------------\n\nTITLE: Integer-Range Constrained Addition Function - Erlang\nDESCRIPTION: Defines an Erlang function add5/2 with guards that constrain both arguments X and Y to be integers fitting in the range 0..1023, using band for masking. This enables the compiler to infer strict integer ranges for optimization. No external dependencies. Inputs: X, Y (integers); Output: X+Y if constraints hold, otherwise clause does not match.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nadd5(X, Y) when X =:= X band 16#3FF,\n                Y =:= Y band 16#3FF ->\n    X + Y.\n\n```\n\n----------------------------------------\n\nTITLE: Converting JSON Keys to Atoms with a Decoder Callback in Erlang\nDESCRIPTION: Shows how to use a decoder callback function to safely convert JSON object keys from binaries to atoms, using binary_to_existing_atom/1 to prevent potential denial-of-service attacks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_26\n\nLANGUAGE: erlang\nCODE:\n```\n1> Push = fun(Key, Value, Acc) -> [{binary_to_existing_atom(Key), Value} | Acc] end.\n#Fun<erl_eval.40.39164016>\n2> {quote,attribution,verified}.\n{quote,attribution,verified}\n3> {Qs,_,<<>>} = json:decode(JSON, [], #{object_push => Push}), Qs.\n[#{quote =>\n       <<\"The gods are best served by those who need their help the least.\">>,\n   attribution => <<\"Zeus\">>,verified => true},\n #{quote =>\n       <<\"Now the voyage is over, I don't want any trouble to begin.\">>,\n   attribution => <<\"Jason\">>,verified => true}]\n```\n\n----------------------------------------\n\nTITLE: Using Process Labels for Debugging in Erlang\nDESCRIPTION: Demonstrates how to set labels on processes using proc_lib:set_label/1 to make them easier to identify in debugging tools like the shell's i/0 command and observer.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_29\n\nLANGUAGE: erlang\nCODE:\n```\n1> F = fun(I) ->\n   spawn_link(fun() ->\n     proc_lib:set_label({quote_handler, I}),\n     receive _ -> ok end\n   end)\n   end.\n#Fun<erl_eval.42.39164016>\n2> Ps = [F(I) || I <- lists:seq(1, 5)].\n[<0.91.0>,<0.92.0>,<0.93.0>,<0.94.0>,<0.95.0>]\n3> proc_lib:get_label(hd(Ps)).\n{quote_handler,1}\n4> i().\nPid                   Initial Call                          Heap     Reds Msgs\nRegistered            Current Function                     Stack\n<0.0.0>               erl_init:start/2                       987     5347    0\ninit                  init:loop/1                              2\n   .\n   .\n   .\n{quote_handler,1}     prim_eval:'receive'/2                    9\n<0.92.0>              erlang:apply/2                         233     4006    0\n{quote_handler,2}     prim_eval:'receive'/2                    9\n<0.93.0>              erlang:apply/2                         233     4006    0\n{quote_handler,3}     prim_eval:'receive'/2                    9\n<0.94.0>              erlang:apply/2                         233     4006    0\n{quote_handler,4}     prim_eval:'receive'/2                    9\n<0.95.0>              erlang:apply/2                         233     4006    0\n{quote_handler,5}     prim_eval:'receive'/2                    9\nTotal                                                     642876  1156835    0\n                                                             438\nok\n```\n\n----------------------------------------\n\nTITLE: Implementing MWC59 PRNG in Erlang with Type Hints\nDESCRIPTION: Erlang implementation of a Multiply With Carry (MWC) PRNG that uses a redundant bit mask to provide the compiler with type hints, enabling more efficient code generation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_14\n\nLANGUAGE: erlang\nCODE:\n```\nmwc59(CX0) ->\n    CX = CX0 band ((1 bsl 59)-1),\n    C = CX band ((1 bsl 32)-1),\n    X = CX bsr 32,\n    16#7fa6502 * X + C.\n```\n\n----------------------------------------\n\nTITLE: Optimizing Bit-Syntax Matching with Lookahead in Erlang\nDESCRIPTION: Demonstrates bit-syntax matching optimization in OTP 22, which now allows for better match context reuse and lookahead operations. This improves performance in complex pattern matching scenarios.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-11-07-retired-pitfalls-22.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ntrim_zero(<<0,Tail/binary>>) -> trim_zero(Tail);\ntrim_zero(B) when is_binary(B) -> B.\n```\n\n----------------------------------------\n\nTITLE: Analyzing BEAM Instructions for Tuple Creation\nDESCRIPTION: This snippet shows the BEAM assembly instructions for the `create_tuple/1` Erlang function. It demonstrates how tuple creation involves checking heap space using `test_heap` (with a liveness count for GC) and then constructing the tuple using an instruction like `put_tuple2`. The `put_tuple2` instruction takes the destination register (`{x,0}`) and a list specifying the elements of the tuple, which can be literals (`{atom,hello}`) or values from other registers (`{x,0}`).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_5\n\nLANGUAGE: BEAM Assembly\nCODE:\n```\n{function, create_tuple, 1, 10}.\n  {label,9}.\n    {func_info,{atom,primer},{atom,create_tuple},1}.\n  {label,10}.\n    <em>%% Allocate the three words needed for a 2-tuple, with\n    %% a liveness annotation of 1 indicating that <b>{x,0}</b>\n    %% is alive in case we need to GC.</em>\n    {test_heap,3,1}.\n\n    <em>%% Create the tuple and place the result in <b>{x,0}</b></em>\n    {put_tuple2,{x,0},{list,[{atom,hello},{x,0}]}}.\n  \n    return.\n```\n\n----------------------------------------\n\nTITLE: Defining and Sequentially Updating a Record (Erlang)\nDESCRIPTION: This Erlang code defines a record `foo` and a function `update/1`. The function initializes a `foo` record and then performs three sequential updates on it, returning the final record. This example illustrates a common pattern before Erlang/OTP 27 optimizations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n-record(foo, {a,b,c,d,e}).\n\nupdate(N) ->\n    R0 = #foo{},\n    R1 = R0#foo{a=N},\n    R2 = R1#foo{b=2},\n    R2#foo{c=3}.\n```\n\n----------------------------------------\n\nTITLE: Using the new socket module in Erlang\nDESCRIPTION: Reference to the new experimental socket module introduced in Erlang/OTP 22, which is implemented as a NIF and designed to closely mirror the OS level socket interface.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/126.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nsocket\n```\n\n----------------------------------------\n\nTITLE: Returning Triple-Quoted Source Example as String - Erlang/OTP 27 - Erlang\nDESCRIPTION: Returns a string containing visually formatted source code by using a triple-quoted string. This function shows how triple-quoted strings retain internal indentation and content verbatim, and is suitable for code generation or embedding code listings in output. The example does not require any dependencies other than OTP/27 and illustrates the code-as-text idiom.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\neffect_warning() ->\\n    \"\"\"\\n    f() ->\\n        %% Test that the compiler warns for useless tuple building.\\n        {a,b,c},\\n        ok.\\n    \"\"\".\n```\n\n----------------------------------------\n\nTITLE: Spawning Process and Message Passing in Erlang\nDESCRIPTION: This snippet demonstrates how to spawn a new light-weight process in Erlang, send a message from the spawned process to the parent, and receive the message. It uses the spawn function to create a new process that sends a list of numbers to the parent process.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/5-processes-small.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n> Me = self().\n<0.376.0>        %% Send msg using !\n> spawn(fun() -> Me!lists:seq(1,10) end).\n<0.930.0>\n> receive Reply -> Reply end.\n[1,2,3,4,5,6,7,8,9,10]\n```\n\n----------------------------------------\n\nTITLE: Enumerating Lists with lists:enumerate/1,2 in Erlang\nDESCRIPTION: The lists:enumerate functions return a new list where each element is associated with its position in the original list. The functions can adjust the starting index. Prerequisite: Erlang's lists module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_1\n\nLANGUAGE: Erlang\nCODE:\n```\n> lists:enumerate([a,b,c]).\n[{1,a},{2,b},{3,c}]\n```\n\nLANGUAGE: Erlang\nCODE:\n```\n> lists:enumerate(10, [a,b,c]).\n[{10,a},{11,b},{12,c}]\n```\n\n----------------------------------------\n\nTITLE: Erlang Function: Map Size Comparison via if Expression\nDESCRIPTION: Erlang code to compare the size of two maps, returning atoms ’smaller’ or ’larger_or_equal’. Leverages built-in map_size, and demonstrates how high-level control flow is compiled and type-inferred in BEAM/JIT. Inputs are Map1 and Map2, output is an atom indicating comparison result.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_15\n\nLANGUAGE: erlang\nCODE:\n```\nmap_size_less_than(Map1, Map2) ->\\n    if\\n        map_size(Map1) < map_size(Map2) -> smaller;\\n        true -> larger_or_equal\\n    end.\n```\n\n----------------------------------------\n\nTITLE: Shell Auto-completion: Records, Fields, and Built-in Functions - Erlang\nDESCRIPTION: Demonstrates auto-completion for record names, record fields, and built-in functions in the Erlang shell. Examples include triggering field listing upon entering a hash symbol, navigating field names, and exploring functions starting with a particular letter using TAB. No dependencies required beyond the Erlang shell in OTP 26.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n9> #coord{\n```\n\nLANGUAGE: erlang\nCODE:\n```\n9> #coord{\nfields\nx=    y=\n```\n\nLANGUAGE: erlang\nCODE:\n```\n10> l\nbifs\nlength(                   link(                     list_to_atom(\nlist_to_binary(           list_to_bitstring(        list_to_existing_atom(\nlist_to_float(            list_to_integer(          list_to_pid(\nlist_to_port(             list_to_ref(              list_to_tuple(\nPress tab to see all 37 expansions\n```\n\nLANGUAGE: erlang\nCODE:\n```\n10> l\nbifs\nlength(                   link(                     list_to_atom(\nlist_to_binary(           list_to_bitstring(        list_to_existing_atom(\nlist_to_float(            list_to_integer(          list_to_pid(\nlist_to_port(             list_to_ref(              list_to_tuple(\nload_module(\ncommands\nl(     lc(    lm(    ls(\nmodules\nlcnt:                      leex:                      lists:\nlocal_tcp:                 local_udp:                 log_mf_h:\nlogger:                    logger_backend:            logger_config:\nlogger_disk_log_h:         logger_filters:            logger_formatter:\nlogger_h_common:           logger_handler_watcher:    logger_olp:\nlogger_proxy:              logger_server:             logger_simple_h:\nlogger_std_h:              logger_sup:\n```\n\nLANGUAGE: erlang\nCODE:\n```\n10> lists:\nfunctions\nall(            any(            append(         concat(         delete(\ndroplast(       dropwhile(      duplicate(      enumerate(      filter(\nfiltermap(      flatlength(     flatmap(        flatten(        foldl(\nfoldr(          foreach(        join(           keydelete(      keyfind(\nPress tab to see all 72 expansions\n```\n\nLANGUAGE: erlang\nCODE:\n```\n10> lists:m\nfunctions\nmap(            mapfoldl(       mapfoldr(       max(            member(\nmerge(          merge3(         min(            module_info(\n```\n\n----------------------------------------\n\nTITLE: Map Comprehensions: Constructing Maps Directly - Erlang\nDESCRIPTION: Demonstrates the new OTP 26 map comprehension syntax, which creates a map directly from a generator. The example builds a map of integer squares, with keys and values drawn from a generated sequence, using minimal syntax. Relies on the updated compiler/parser and base list functions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\n1> M = #{I => I*I || I <- lists:seq(1, 5)}.\n#{1 => 1,2 => 4,3 => 9,4 => 16,5 => 25}\n```\n\n----------------------------------------\n\nTITLE: Custom Encoding with an Encoder Function in Erlang\nDESCRIPTION: Shows how to implement a custom encoder function to handle complex data structures like tuples, converting them to appropriate JSON representation using json:encode/2.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_28\n\nLANGUAGE: erlang\nCODE:\n```\n1> Q = [{~\"The gods are best served by those who need their help the least.\",\n~\"Zeus\",true},\n{~\"Now the voyage is over, I don't want any trouble to begin.\",\n~\"Jason\",true}].\n[{<<\"The gods are best served by those who need their help the least.\">>,\n  <<\"Zeus\">>,true},\n {<<\"Now the voyage is over, I don't want any trouble to begin.\">>,\n  <<\"Jason\">>,true}]\n```\n\nLANGUAGE: erlang\nCODE:\n```\nquote_encoder({Q, A, V}, Encode)\n  when is_binary(Q), is_binary(A), is_boolean(V) ->\n    json:encode_map(#{quote => Q,\n                      attribution => A,\n                      verified => V},\n                    Encode);\nquote_encoder(Other, Encode) ->\n    json:encode_value(Other, Encode).\n```\n\nLANGUAGE: erlang\nCODE:\n```\n2> io:format(\"~ts\\n\", [json:encode(Q, fun t:quote_encoder/2)]).\n[{\"quote\":\"The gods are best served by those who need their help the least.\",\"attribution\":\"Zeus\",\"verified\":true},{\"quote\":\"Now the voyage is over, I don't want any trouble to begin.\",\"attribution\":\"Jason\",\"verified\":true}]\n```\n\n----------------------------------------\n\nTITLE: Tokenizing Erlang Expression with erl_scan\nDESCRIPTION: Uses erl_scan:string/1 to tokenize an Erlang expression, demonstrating the first step in translating source code to abstract format.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n1> {ok,Tokens,_} = erl_scan:string(\"A + (B*C*(D+42)).\"), Tokens.\n[{var,1,'A'},\n {'+'1},\n {'(',1},\n {var,1,'B'},\n {'*',1},\n {var,1,'C'},\n {'*',1},\n {'(',1},\n {var,1,'D'},\n {'+',1},\n {integer,1,42},\n {')',1},\n {')',1},\n {dot,1}]\n```\n\n----------------------------------------\n\nTITLE: Filtering Even Numbers from a List in Erlang\nDESCRIPTION: This function takes a list of integers and returns only the even numbers. It uses list comprehension with a filter condition that checks if the remainder when divided by 2 equals 0. The function includes type specifications indicating it accepts and returns lists of integers.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_examples/7-even-numbers.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-spec even(In) -> Out\n  when In :: list(integer()),\n       Out :: list(integer()).\neven(Numbers) ->\n  [Number || Number <- Numbers,\n   Number rem 2 == 0].\n```\n\n----------------------------------------\n\nTITLE: Querying Allocation Information in Erlang/OTP 21\nDESCRIPTION: Demonstration of using instrument:allocations() to view detailed memory allocation statistics grouped by their origin and type. Shows memory usage patterns across different system components including drivers, NIFs, and system processes.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-02-Memory-instrumentation-in-OTP-21.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n2> instrument:allocations()\n{ok,{128,0,\n     #{udp_inet =>\n           #{driver_event_state => {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0}},\n       tty_sl =>\n           #{io_queue => {0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             drv_internal => {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0}},\n       system =>\n           #{db_segment => {0,0,0,0,0,18,0,0,1,0,0,0,0,0,0,0,0,0},\n             heap => {0,0,0,0,20,4,2,2,2,3,0,1,0,0,1,0,0,0},\n             thr_prgr_data => {38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             db_term => {271,3,1,52,80,1,0,0,0,0,0,0,0,0,0,0,0,0},\n             code => {0,0,0,5,3,6,11,22,19,20,10,2,1,0,0,0,0,0},\n             binary => {18,0,0,0,7,0,0,1,0,0,0,0,0,0,0,0,0,0},\n             atom_entry => {8681,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             message => {0,40,78,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             ... }\n       spawn_forker =>\n           #{driver_select_data_state =>\n                 {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n       ram_file_drv => #{drv_binary => {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}},\n       prim_file =>\n           #{process_specific_data => {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             nif_trap_export_entry => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             monitor_extended => {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             drv_binary => {0,0,0,0,0,0,1,0,3,5,0,0,0,1,0,0,0,0},\n             binary => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n       prim_buffer =>\n           #{nif_internal => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             binary => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}}\n```\n\n----------------------------------------\n\nTITLE: Alternative Erlang guard approach using bitwise operations\nDESCRIPTION: A more efficient way to constrain integer ranges in OTP 25 using bitwise operations. This approach helps the compiler identify specific ranges and optimize the code accordingly.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_32\n\nLANGUAGE: erlang\nCODE:\n```\nadd5(X, Y) when X =:= X band 16#3FF,\n                Y =:= Y band 16#3FF ->\n    X + Y.\n```\n\n----------------------------------------\n\nTITLE: Using ets:update_element/4 with default object\nDESCRIPTION: Example of the new ets:update_element/4 function that allows supplying a default object when there is no existing object with the given key, simplifying conditional insertion logic.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_38\n\nLANGUAGE: erlang\nCODE:\n```\nT = ets:new(example, []).\nets:update_element(T, a, {2, true}, {a, true}).\nets:lookup(T, a).\n```\n\n----------------------------------------\n\nTITLE: Implementing Request-Response Pattern in Erlang\nDESCRIPTION: This snippet demonstrates the request-response idiom in Erlang, using process monitoring and message passing. It shows how to send a request, wait for a response, and handle potential process termination.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-03-19-message-passing.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nMref = monitor(process, Pid),\nPid ! {self(), Mref, Request},\nreceive\n    {Mref, Response} ->\n        erlang:demonitor(Mref, [flush]),\n        {ok, Response};\n    {'DOWN', Mref, _, _, Reason} ->\n        {error, Reason}\nend\n```\n\n----------------------------------------\n\nTITLE: Using maybe_expr in Erlang Modules\nDESCRIPTION: The maybe_expr construct allows for concise error handling and conditional execution within a module. It requires enabling with the -feature directive and is optionally enabled at runtime. Prerequisite: Erlang OTP 25.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_3\n\nLANGUAGE: Erlang\nCODE:\n```\n-module(my_experiment).\n-export([foo/1]).\n\n%% Enable the feature maybe_expr in this module only\n-feature(maybe_expr,enable). \nfoo() ->\n  maybe\n    {ok, X} ?= f(Foo),\n    [H|T] ?= g([1,2,3]),\n    ...\n  else\n    {error, Y} ->\n        {ok, \"default\"};\n    {ok, _Term} ->\n        {error, \"unexpected wrapper\"}\n  end.\n```\n\n----------------------------------------\n\nTITLE: Map Comprehension with Map Generator: Swapping Keys and Values - Erlang\nDESCRIPTION: This snippet shows the use of a map generator inside a map comprehension to invert key-value pairs, efficiently recreating the map with swapped keys and values. Inputs are the map M; output is the inverted map. Depends on OTP 26 new syntax.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_10\n\nLANGUAGE: erlang\nCODE:\n```\n3> #{V => K || K := V <- M}.\n#{1 => 1,4 => 2,9 => 3,16 => 4,25 => 5}\n```\n\n----------------------------------------\n\nTITLE: Joining String Lists Into Multi-Line Text - Erlang/io Module - Erlang\nDESCRIPTION: Showcases constructing a multi-line string by joining a list of string fragments with `lists:join(\"\\n\", S)`, then printing the result. This idiom requires no escaping quotes or explicit newlines, and uses the lists module and io module for output. This approach is idiomatic Erlang prior to triple-quoted strings.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nquotes() ->\\n    S = [\\\"\\\\\\\"I always have a quotation for everything -\\\",\\n         \\\"it saves original thinking.\\\\\\\" - Dorothy L. Sayers\\\",\\n         \\\"\\\",\\n         \\\"\\\\\\\"Real stupidity beats artificial intelligence every time.\\\\\\\"\\\",\\n         \\\"- Terry Pratchett\\\"],\\n    io:put_chars(lists:join(\"\\\\n\", S)),\\n    io:nl().\n```\n\n----------------------------------------\n\nTITLE: Addition Function with Guarded Ranges - Erlang\nDESCRIPTION: This alternative Erlang snippet add4/2 expresses value range constraints in a more natural way using guards: is_integer and explicit range checks. However, in Erlang/OTP 25, the compiler cannot fully infer and propagate ranges in this form, leading to less optimal code. Inputs: X, Y (expected integers). Output: X + Y if all guards succeed.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\nadd4(X, Y) when is_integer(X), 0 =< X, X < 16#400,\n                is_integer(Y), 0 =< Y, Y < 16#400 ->\n    X + Y.\n\n```\n\n----------------------------------------\n\nTITLE: Pretty-printing Erlang Abstract Format with erl_pp\nDESCRIPTION: Shows how to pretty-print the abstract format of an Erlang expression back to source code using erl_pp:exprs/1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n3> lists:flatten(erl_pp:exprs(Abstract)).\n\"A + B * C * (D + 42)\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Call Optimization in Erlang\nDESCRIPTION: Example of how the Erlang compiler now automatically optimizes tuple calls by rewriting functions to reduce code size, execution time, and garbage collection pressure.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/121.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nf({ok, Val}) -> {ok, Val}\n```\n\nLANGUAGE: erlang\nCODE:\n```\nf({ok, Val} = Tuple) -> Tuple.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Try-Catch Syntax with Stacktrace in Erlang\nDESCRIPTION: Example showing the new recommended approach for capturing stacktraces in Erlang, which will replace the deprecated erlang:get_stacktrace/0 function.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/121.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ntry ... catch C:R:Stacktrace -> ...\n```\n\n----------------------------------------\n\nTITLE: Feature Handling in OTP 25 vs OTP 26 for Maybe Expressions\nDESCRIPTION: Shows how in OTP 25, the maybe feature needed to be enabled in both the compiler and runtime, whereas in OTP 26 it's sufficient to enable it only in the module. This improves developer experience when using newer language features.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_16\n\nLANGUAGE: erlang\nCODE:\n```\n$ cat t.erl\n-module(t).\n-feature(maybe_expr, enable).\n-export([listen_port/2]).\nlisten_port(Port, Options) ->\n    maybe\n        {ok, ListenSocket} ?= inet_tcp:listen(Port, Options),\n        {ok, Address} ?= inet:sockname(ListenSocket),\n        {ok, {ListenSocket, Address}}\n    end.\n$ erlc t.erl\n$ erl\nErlang/OTP 25 . . .\n\nEshell V13.1.1  (abort with ^G)\n1> t:listen_port(50000, []).\n=ERROR REPORT==== 6-Apr-2023::12:01:20.373223 ===\nLoading of . . ./t.beam failed: {features_not_allowed,\n                                 [maybe_expr]}\n\n** exception error: undefined function t:listen_port/2\n2> q().\n$ erl -enable-feature maybe_expr\nErlang/OTP 25 . . .\n\nEshell V13.1.1  (abort with ^G)\n1> t:listen_port(50000, []).\n{ok,{#Port<0.5>,{{0,0,0,0},50000}}}\n```\n\nLANGUAGE: erlang\nCODE:\n```\n$ erlc t.erl\n$ erl\nErlang/OTP 26 . . .\n\nEshell V14.0 (press Ctrl+G to abort, type help(). for help)\n1> t:listen_port(50000, []).\n{ok,{#Port<0.4>,{{0,0,0,0},50000}}}\n```\n\n----------------------------------------\n\nTITLE: Using the dynamic() Type in Dialyzer\nDESCRIPTION: Demonstrates the new built-in type dynamic() introduced in EEP 61 for improved support for gradual type checkers in Dialyzer.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\ndynamic()\n```\n\n----------------------------------------\n\nTITLE: Adding integers in Erlang with type constraints via guards\nDESCRIPTION: This code demonstrates a function that adds two integers with guard expressions that ensure both operands are integers within specific ranges. The guard expressions help the compiler establish type constraints for optimization.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_28\n\nLANGUAGE: erlang\nCODE:\n```\nadd3(X, Y) when is_integer(X), is_integer(Y) ->\n    X + Y.\n```\n\n----------------------------------------\n\nTITLE: Documentation Helper Functions - Erlang\nDESCRIPTION: New shell functions for displaying documentation for Erlang modules, functions and types.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/138.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nh/1,2,3\nht/1,2,3\n```\n\n----------------------------------------\n\nTITLE: Optimizing List Subtraction in Erlang\nDESCRIPTION: Shows an example of list subtraction (-- operator) which has been optimized in OTP 21.2 to use a red-black tree algorithm, improving worst-case complexity from O(n²) to O(n log n).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-11-07-retired-pitfalls-22.md#2025-04-22_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Using New Shell Documentation Functions in Erlang\nDESCRIPTION: Examples of new shell functions for displaying documentation for Erlang modules, functions, and types.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/23.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nh/1,2,3\n```\n\nLANGUAGE: erlang\nCODE:\n```\nht/1,2,3\n```\n\n----------------------------------------\n\nTITLE: Using min/2 and max/2 BIFs in Guards\nDESCRIPTION: Demonstrates the newly allowed usage of min/2 and max/2 BIFs in guards and match specs for more expressive pattern matching.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\nmin/2, max/2\n```\n\n----------------------------------------\n\nTITLE: Removing Duplicates with lists:uniq/1,2 in Erlang\nDESCRIPTION: The lists:uniq functions remove duplicates from a list, preserving order, and allow specifying custom equality logic. Prerequisite: Erlang's lists module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_2\n\nLANGUAGE: Erlang\nCODE:\n```\n> lists:uniq([3,3,1,2,1,2,3]).\n[3,1,2]\n```\n\nLANGUAGE: Erlang\nCODE:\n```\n> lists:uniq([a, a, 1, b, 2, a, 3]).\n[a, 1, b, 2, 3]\n```\n\nLANGUAGE: Erlang\nCODE:\n```\n> lists:uniq(fun({X, _}) -> X end, [{b, 2}, {a, 1}, {c, 3}, {a, 2}]).\n[{b, 2}, {a, 1}, {c, 3}]\n```\n\n----------------------------------------\n\nTITLE: Map Generator in List Comprehension: Filtering by Value - Erlang\nDESCRIPTION: Uses a map generator within a list comprehension to filter and select keys with specific values. The code iterates over a map and selects keys where the corresponding value is less than 10, demonstrating the concise manipulation of map content. Requires support for map comprehensions (OTP 26).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\n2> [K || K := V <- M, V < 10].\n[1,2,3]\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Tracer Process in Erlang\nDESCRIPTION: This snippet demonstrates how to create a simple process that receives and prints trace messages. This tracer will be used as the destination for trace messages in a trace session.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_43\n\nLANGUAGE: erlang\nCODE:\n```\nTracer = spawn(fun F() -> receive M -> io:format(\"== ~p ==\\n\", [M]), F() end end).\n```\n\n----------------------------------------\n\nTITLE: Zip Generator Comprehension Example in Erlang\nDESCRIPTION: Demonstrates the new zip generator feature in list comprehensions where multiple generators can run in parallel. The example shows adding corresponding elements from two lists.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/177.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n[A+B || A <- [1,2,3] && B <- [4,5,6]]\n```\n\n----------------------------------------\n\nTITLE: Using lists:search Function in Erlang\nDESCRIPTION: Demonstrates the usage of the new lists:search/2 function in Erlang, which returns {ok, Value} if a matching element is found, or false otherwise.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/122.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nlists:search(list,fun/1) -> {ok, Value} | false\n```\n\n----------------------------------------\n\nTITLE: Checking JIT-compiler Status in Erlang/OTP 24\nDESCRIPTION: Code snippet to verify if a JIT-enabled emulator is running in Erlang/OTP 24 by checking the emulator flavor using erlang:system_info/1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/148.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:system_info(emu_flavor)\n```\n\n----------------------------------------\n\nTITLE: Traversing an ETS table with first_lookup and next_lookup\nDESCRIPTION: Demonstration of the new ETS functions first_lookup/1 and next_lookup/2 that simplify and speed up traversal of an ETS table by combining lookup and iteration functionality.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_37\n\nLANGUAGE: erlang\nCODE:\n```\nT = ets:new(example, [ordered_set]).\nets:insert(T, [{I,I*I} || I <- lists:seq(1, 10)]).\n{K1,_} = ets:first_lookup(T).\n{K2,_} = ets:next_lookup(T, K1).\n{K3,_} = ets:next_lookup(T, K2).\n{K4,_} = ets:next_lookup(T, K3).\n```\n\n----------------------------------------\n\nTITLE: Using lists:enumerate Functions in Erlang\nDESCRIPTION: Shows the functionality of lists:enumerate/1, lists:enumerate/2 (introduced in OTP 25), and the new lists:enumerate/3 (introduced in OTP 26) which allows specifying an increment for the enumeration index.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_14\n\nLANGUAGE: erlang\nCODE:\n```\n1> lists:enumerate([a,b,c]).\n[{1,a},{2,b},{3,c}]\n2> lists:enumerate(0, [a,b,c]).\n[{0,a},{1,b},{2,c}]\n```\n\nLANGUAGE: erlang\nCODE:\n```\n3> lists:enumerate(0, 10, [a,b,c]).\n[{0,a},{10,b},{20,c}]\n4> lists:enumerate(0, -1, [a,b,c]).\n[{0,a},{-1,b},{-2,c}]\n```\n\n----------------------------------------\n\nTITLE: Using Crypto Module Information Function\nDESCRIPTION: Demonstrates the cipher_info/1 function that returns maps with information about hash or cipher algorithms in the Erlang Crypto module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/133.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ncipher_info/1\n```\n\n----------------------------------------\n\nTITLE: Counting Terms in a List Using Record Updates (Erlang)\nDESCRIPTION: This Erlang module `count1` defines a function `count/1` that uses a helper function `count/2` to recursively count the number of atoms and other terms in a list. It uses a record `s` to store the counts, updating it in each recursive step. This pattern is suitable for the 'in-place' update optimization in OTP 27.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n-module(count1).\n-export([count/1]).\n\n-record(s, {atoms=0,other=0}).\n\ncount(L) ->\n    count(L, #s{}).\n\ncount([X|Xs], #s{atoms=C}=S) when is_atom(X) ->\n    count(Xs, S#s{atoms=C+1});\ncount([_|Xs], #s{other=C}=S) ->\n    count(Xs, S#s{other=C+1});\ncount([], S) ->\n    S.\n```\n\n----------------------------------------\n\nTITLE: Identity Function in Erlang and Core Erlang\nDESCRIPTION: Example of a simple identity function showing variable handling in Core Erlang.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-07-core-erlang-by-example.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nid(I) -> I.\n```\n\nLANGUAGE: erlang\nCODE:\n```\n'id'/1 =\n    fun (_@c0) ->\n\t_@c0\n```\n\n----------------------------------------\n\nTITLE: Optimized Map Updates in Erlang OTP 26\nDESCRIPTION: Demonstrates how map updates using the => operator have been improved to avoid allocating new maps when values don't change, and to reuse key tuples when updating existing keys, resulting in better memory efficiency.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_13\n\nLANGUAGE: erlang\nCODE:\n```\n1> M = #{a => 42}.\n#{a => 42}\n2> M#{a => 42}.\n#{a => 42}\n```\n\nLANGUAGE: erlang\nCODE:\n```\n3> M#{a => 100}.\n#{a => 100}\n```\n\n----------------------------------------\n\nTITLE: Combining Multi-Line Strings Explicitly - Erlang/io Module - Erlang\nDESCRIPTION: Exemplifies concatenating multiple one-line strings in Erlang, allowing the compiler to merge them at compilation. Each line must start and end with its own set of quotes, and explicit `\\n` are used for newlines. This approach simplifies some escaping but still requires careful attention to newlines and quoting.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nquotes() ->\\n    S = \\\"\\\\\\\"I always have a quotation for everything -\\\\n\\\"\\n        \\\"it saves original thinking.\\\\\\\" - Dorothy L. Sayers\\\\n\\\"\\n        \\\"\\\\\\\"Real stupidity beats artificial intelligence every time.\\\\\\\"\\\\n\\\"\\n        \\\"- Terry Pratchett\\\\n\\\",\\n    io:put_chars(S).\n```\n\n----------------------------------------\n\nTITLE: Using the New maps:iterator/2 Function in Erlang\nDESCRIPTION: Demonstrates the new function for creating an iterator that returns map elements in a deterministic order, replacing the unpredictable order from maps:to_list/1 and maps:next/1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nmaps:iterator/2\n```\n\n----------------------------------------\n\nTITLE: BIF call in a guard expression in Erlang\nDESCRIPTION: This example shows how a guard expression using element/2 is translated into SSA and BEAM code. It demonstrates conditional branching based on the guard result.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nelement_guard(T) when element(2, T) =:= true ->\n    ok;\nelement_guard(_) ->\n    error.\n```\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:element_guard(_0) {\n0:\n  %% blog.erl:7\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n  br @ssa_bool, label 4, label 3\n\n4:\n  @ssa_bool:5 = bif:'=:=' _1, literal true\n  br @ssa_bool:5, label 6, label 3\n\n6:\n  ret literal ok\n\n3:\n  ret literal error\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking ETS ordered_set Performance in Erlang\nDESCRIPTION: This escript measures the time it takes for a specified number of Erlang processes to insert a given number of integers into an ordered_set ETS table. It allows comparison between the old and new implementations by toggling the write_concurrency option.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-8-19-the-new-scalable-ets-ordered_set.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{% link /blog/code/insert_disjoint_ranges.erl %}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Function Tracing in an Erlang Module\nDESCRIPTION: This code loads the array module and sets up tracing for all of its functions within the trace session. The wildcard patterns '_' match any function name and arity.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_46\n\nLANGUAGE: erlang\nCODE:\n```\nl(array).\ntrace:function(Session, {array,'_','_'}, [], [local]).\n```\n\n----------------------------------------\n\nTITLE: Defining a Selective Receive Function in Erlang\nDESCRIPTION: This Erlang code defines a function `selective_receive/1` that waits indefinitely for a message matching the pattern `{Ref, Result}` where `Ref` is the function argument. Upon receiving such a message, it extracts and returns the `Result` part. This demonstrates the selective message receiving mechanism in Erlang.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\nselective_receive(Ref) ->\n    receive\n        {Ref, Result} -> Result\n    end.\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Erlang Function\nDESCRIPTION: Defines a function 'foo' that takes two arguments, calculates their sum, and returns the result.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nfoo(C, L) ->\n    Sum = lists:sum(L),\n    C + Sum.\n```\n\n----------------------------------------\n\nTITLE: Erlang Zip Generator Example\nDESCRIPTION: Demonstrates the new zip generator feature in comprehensions that allows multiple generators to run in parallel\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/174.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n[A+B || A <- [1,2,3] && B <- [4,5,6]]\n```\n\n----------------------------------------\n\nTITLE: Simplified timer:apply_after with local fun in Erlang/OTP 27\nDESCRIPTION: New simplified syntax in Erlang/OTP 27 that allows directly passing a fun to timer:apply_after without the need for erlang:apply/2 and extra arguments.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_35\n\nLANGUAGE: erlang\nCODE:\n```\ntimer:apply_after(10, fun() -> io:put_chars(\"now!\\n\") end).\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Improved Error Messages in Erlang\nDESCRIPTION: Example of improved error messages in Erlang/OTP 24, showing column numbers and visual indicators for compilation errors.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nfoo(A, B) ->\n  #{ a => A, b := B }.\n```\n\n----------------------------------------\n\nTITLE: New Lists Search Function in Erlang\nDESCRIPTION: Example of the new lists:search/2 function that returns {ok, Value} when an element matching the predicate is found, or false otherwise.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/121.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nlists:search(list,fun/1) -> {ok, Value} | false\n```\n\n----------------------------------------\n\nTITLE: Creating Maps via List Comprehension using maps:from_list/1 - Erlang\nDESCRIPTION: Shows the pre-OTP 26 idiom for creating a map via list comprehension over a list of integers, turning the result into a map with maps:from_list/1. Each key is an integer, value is its square. Demonstrates common patterns for map creation prior to map comprehensions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\n1> M = maps:from_list([{I,I*I} || I <- lists:seq(1, 5)]).\n#{1 => 1,2 => 4,3 => 9,4 => 16,5 => 25}\n```\n\n----------------------------------------\n\nTITLE: Erlang: Monitoring Primitive Nodes\nDESCRIPTION: The function `erlang:monitor` can now create a monitor on a primitive node without raising a `badarg` exception, improving reliability in monitoring remote connections. This enhances monitoring capabilities with a dedicated supervisory mechanism to handle node connections.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/21.md#2025-04-22_snippet_0\n\nLANGUAGE: Erlang\nCODE:\n```\nerlang:monitor(NodeType, NodeName).\n```\n\n----------------------------------------\n\nTITLE: Optimizing Core Erlang with Constant Propagation\nDESCRIPTION: This Core Erlang snippet demonstrates the result of constant propagation optimization applied by `sys_core_fold`. The `let` binding for variable `A` is eliminated, and its constant value `42` is directly substituted into the return tuple, resulting in `{'ok', 42}`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n'a'/0 =\n    fun () ->\n\t{'ok',42}\n```\n\n----------------------------------------\n\nTITLE: Analyzing BEAM Instructions for a Tail-Recursive Function\nDESCRIPTION: This snippet shows the BEAM assembly instructions generated for the `sum_tail/1` and `sum_tail/2` Erlang functions. It illustrates how arguments are passed in X registers (`{x,0}`, `{x,1}`), how constants are moved (`{move,{integer,0},{x,1}}`), how tail calls are performed without a stack frame (`{call_only,2,{f,4}}`), how list types are tested (`{test,is_nonempty_list,...}`, `{test,is_nil,...}`), how lists are destructured (`{get_list,...}`), how arithmetic operations potentially trigger garbage collection (`{gc_bif,'+',...}`), and how control flow uses labels and fail labels (`{label,N}`, `{f,N}`). The comments explain the purpose of each instruction group.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_1\n\nLANGUAGE: BEAM Assembly\nCODE:\n```\n<em>%% sum_tail/1, entry label is 2</em>\n{function, sum_tail, 1, 2}.\n\n  <em>%% Marks a jump target with the label 1.</em>\n  {label,1}.\n\n    <em>%% Special instruction that raises a function_clause\n    %% exception. Unused in this function.</em>\n    {func_info,{atom,primer},{atom,sum_tail},1}.\n\n  {label,2}.\n    <em>%% The meat of the function starts here.\n    %%\n    %% Our only argument - <b>List</b> - is in <b>{x,0}</b> and\n    %% since sum_tail/2 expects it to be the first\n    %% argument we can leave it be. We'll pass the\n    %% integer 0 as the second argument in <b>{x,1}</b>.</em>\n    {move,{integer,0},{x,1}}.\n\n    <em>%% Tail call sum_tail/2, whose entry label is 4.</em>\n    {call_only,2,{f,4}}.\n\n<em>%% sum_tail/2, entry label is 4</em>\n{function, sum_tail, 2, 4}.\n  {label,3}.\n    {func_info,{atom,primer},{atom,sum_tail},2}.\n  {label,4}.\n\n    <em>%% Test whether we have a non-empty list, and jump to\n    %% the base case at label 5 if we don't.</em>\n    {test,is_nonempty_list,{f,5},[{x,0}]}.\n\n    <em>%% Unpack the list in the first argument, placing the\n    %% head in <b>{x,2}</b> and the tail in <b>{x,0}</b>.</em>\n    {get_list,{x,0},{x,2},{x,0}}.\n\n    <em>%% Add the head and our accumulator (remember that the\n    %% second function argument is in <b>{x,1}</b>), and place\n    %% the result in <b>{x,1}</b>.\n    %%\n    %% A fail label of 0 means that we want the\n    %% instruction to throw an exception on error, rather\n    %% than jump to a given label.</em>\n    {gc_bif,'+',{f,0},3,[{x,2},{x,1}],{x,1}}.\n\n    <em>%% Tail-call ourselves to handle the rest of the list,\n    %% the arguments are already in the right registers.</em>\n    {call_only,2,{f,4}}.\n\n  {label,5}.\n    <em>%% Test whether our argument was the empty list. If\n    %% not, we jump to label 3 to raise a function_clause\n    %% exception.</em>\n    {test,is_nil,{f,3},[{x,0}]}.\n\n    <em>%% Return our accumulator.</em>\n    {move,{x,1},{x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Optimized remove_even Function with Tuple Binding\nDESCRIPTION: This snippet shows an optimized version of the remove_even function that avoids rebuilding tuples by binding the entire tuple to a variable.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nremove_even([{Key,Val}=Tuple|T]) ->\n    case Val rem 2 =:= 0 of\n        true -> remove_even(T);\n        false ->  [Tuple|remove_even(T)]\n    end;\nremove_even([]) -> [].\n```\n\n----------------------------------------\n\nTITLE: Using tprof for execution time profiling\nDESCRIPTION: Demonstration of using the tprof module with call_time type to measure execution time of each function call, showing how it reports timing information per process.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_41\n\nLANGUAGE: erlang\nCODE:\n```\ntprof:profile(lists, seq, [1, 1000], #{type => call_time}).\n```\n\n----------------------------------------\n\nTITLE: Incrementing and Reading Counters using ETS and counters Module in Erlang\nDESCRIPTION: This code snippet shows how to use the counters module with ETS for implementing global counters. It includes functions for incrementing and reading counter values, but with a performance degradation compared to the ETS-only approach.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-9-9-persistent_term.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ncnt_incr(Counter) ->\n    counters:add(ets:lookup_element(?MODULE,Counter,2),1,1).\n\ncnt_read(Counter) ->\n    counters:get(ets:lookup_element(?MODULE,Counter,2),1).\n```\n\n----------------------------------------\n\nTITLE: Using Preprocessor Directives for Compilation Warnings and Errors in Erlang\nDESCRIPTION: New preprocessor directives -error(Term) and -warning(Term) are introduced to cause compilation errors or warnings respectively. These directives allow developers to add custom compile-time checks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/19.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-error(Term)\n-warning(Term)\n```\n\n----------------------------------------\n\nTITLE: Sending a Message in Erlang using Bang Operator\nDESCRIPTION: This code snippet demonstrates how to send a normal message (the most common type of signal) between processes in Erlang using the bang (!) operator.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-11-05-parallel-signal-sending-optimization.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nProcessB ! Message\n```\n\n----------------------------------------\n\nTITLE: Connecting to SSL Server in OTP 26 with CA Certificates\nDESCRIPTION: Example showing the recommended approach to SSL connections in OTP 26 by providing CA certificates using the cacerts option and public_key:cacerts_get().\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_34\n\nLANGUAGE: erlang\nCODE:\n```\n1> application:ensure_all_started(ssl).\n{ok,[crypto,asn1,public_key,ssl]}\n2> ssl:connect(\"www.erlang.org\", 443, [{cacerts, public_key:cacerts_get()}]).\n{ok,{sslsocket,{gen_tcp,#Port<0.5>,tls_connection,undefined},\n               [<0.137.0>,<0.136.0>]}}\n```\n\n----------------------------------------\n\nTITLE: Using application:get_supervisor/1 Function\nDESCRIPTION: Demonstrates the new application:get_supervisor/1 function for retrieving an application's supervisor.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\napplication:get_supervisor/1\n```\n\n----------------------------------------\n\nTITLE: 59-bit MWC59 Value Generation in Erlang\nDESCRIPTION: Final implementation of the scrambler producing 59-bit values while avoiding bignum operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_22\n\nLANGUAGE: erlang\nCODE:\n```\nmwc59_value(T) ->\n    V0 = T  band ((1 bsl (59-4))),\n    V1 = T  bxor (V0 bsl 4),\n    V2 = V1 band ((1 bsl (59-27))),\n    V1 bxor (V2 bsl 27).\n```\n\n----------------------------------------\n\nTITLE: Adding Scheduler Wall Time Statistics in Erlang\nDESCRIPTION: This snippet introduces a new statistics function for measuring scheduler utilization in Erlang. It's preferred over CPU utilization for accurately determining VM usage.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/59.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:statistics(scheduler_wall_time)\n```\n\n----------------------------------------\n\nTITLE: Checking JIT Compiler Status in Erlang\nDESCRIPTION: A code snippet showing how to verify if a JIT-enabled Erlang emulator is running by using the erlang:system_info/1 function with the emu_flavor parameter.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/144.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:system_info(emu_flavor)\n```\n\n----------------------------------------\n\nTITLE: Creating an ETS Table with Standard Write Concurrency in Erlang\nDESCRIPTION: An Erlang code snippet showing how to create an ETS table with standard write concurrency optimization using the 'true' option.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_16\n\nLANGUAGE: erlang\nCODE:\n```\nets:new(my_table, [{write_concurrency, true}]).\n```\n\n----------------------------------------\n\nTITLE: Enabling OCSP stapling in SSL client\nDESCRIPTION: Example showing how to enable OCSP stapling support in the SSL client in Erlang/OTP 27, which streamlines certificate revocation validation by using server-provided OCSP responses.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_39\n\nLANGUAGE: erlang\nCODE:\n```\nssl:start().\n{ok, Socket} = ssl:connect(\"duckduckgo.com\", 443,\n                              [{cacerts, public_key:cacerts_get()},\n                               {stapling, staple}]).\n```\n\n----------------------------------------\n\nTITLE: Decoding JSON from a File in Erlang\nDESCRIPTION: Demonstrates reading a JSON file and decoding it using the new json:decode/1 function, which converts JSON objects to Erlang maps with binary keys.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_25\n\nLANGUAGE: json\nCODE:\n```\n[\n    {\"quote\": \"The gods are best served by those who need their help the least.\",\n     \"attribution\": \"Zeus\",\n     \"verified\": true},\n    {\"quote\": \"Now the voyage is over, I don't want any trouble to begin.\",\n     \"attribution\": \"Jason\",\n     \"verified\": true}\n]\n```\n\nLANGUAGE: erlang\nCODE:\n```\n1> {ok,JSON} = file:read_file(\"quotes.json\").\n{ok,<<\"[\\n   {\\\"quote\\\": \\\"The gods are best served by those who need their help the least.\\\",\\n    \\\"attribution\\\": \\\"Zeus\\\"\"...>>}\n2> json:decode(JSON).\n[#{<<\"attribution\">> => <<\"Zeus\">>,\n   <<\"quote\">> =>\n       <<\"The gods are best served by those who need their help the least.\">>,\n   <<\"verified\">> => true},\n #{<<\"attribution\">> => <<\"Jason\">>,\n   <<\"quote\">> =>\n       <<\"Now the voyage is over, I don't want any trouble to begin.\">>,\n   <<\"verified\">> => true}]\n```\n\n----------------------------------------\n\nTITLE: Enhanced Map Matching in Erlang\nDESCRIPTION: Demonstrates new map matching syntax where key expressions can be used directly in the pattern match, enabling more concise code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nnew_example2(M, X) ->\n    #{ {tag,X} := Value} = M,\n    Value.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fragmented Distribution Latency Improvement in Erlang\nDESCRIPTION: This Erlang code snippet simulates network load to showcase the latency benefits of fragmented distribution messages introduced in OTP 22. It spawns a process to repeatedly make small RPC calls (`rpc:call`) to a `RemoteNode` every 100ms, measuring and printing the maximum observed latency. Concurrently, it sends 100 large data structures (`D`) to the same `RemoteNode`. This setup is intended to compare performance against older OTP versions where large messages could block smaller ones, leading to higher latency.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-5-13-OTP-22-Highlights.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n1> spawn(fun() ->\n           (fun F(Max) ->\n             {T, _} = timer:tc(fun() ->\n                 rpc:call(RemoteNode, erlang, length, [[]])\n               end),\n             NewMax = lists:max([Max, T]),\n             [io:format(\"Max: ~p~n\",[NewMax]) || NewMax > Max],\n             timer:sleep(100),\n             F(NewMax)\n           end)(0)\n         end).\n2> D = lists:duplicate(100000000,100000000),\n   [{kjell, RemoteNode} ! D || _ <- lists:seq(1,100)],\n   ok.\n```\n\n----------------------------------------\n\nTITLE: Defining an Addition Function - Erlang\nDESCRIPTION: This Erlang snippet declares a basic addition function add1/2, which sums its two arguments X and Y without any type restrictions or guards. No dependencies beyond the standard Erlang language. Parameters: X, Y (any types). Output: Returns the sum or type error at runtime if operands are not numbers.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nadd1(X, Y) ->\n    X + Y.\n\n```\n\n----------------------------------------\n\nTITLE: Defining Preprocessor Macros in Erlang/OTP 19.0\nDESCRIPTION: New preprocessor macros ?FUNCTION_NAME and ?FUNCTION_ARITY introduced in Erlang/OTP 19.0 for accessing the current function name and arity at compile time.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/103.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n?FUNCTION_NAME, ?FUNCTION_ARITY\n```\n\n----------------------------------------\n\nTITLE: Binary Matching with Guard Expressions in Erlang\nDESCRIPTION: Demonstrates new binary matching capability where size can be specified using guard expressions. The example shows how a variable Size is bound to first 8 bits and used in size calculation for following binary.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nexample1(<<Size:8,Payload:((Size-1)*8)/binary,Rest/binary>>) ->\n    {Payload,Rest}.\n```\n\n----------------------------------------\n\nTITLE: Using Default Sigil (~) with Triple-Quoted String for Binary (No Escapes) in Erlang\nDESCRIPTION: Defines a function `quotes/0` demonstrating the default sigil (`~\"\"\"...\"\"\"`) applied to a triple-quoted string. In this context (triple-quoted), the default sigil creates a UTF-8 binary *without* interpreting escape sequences (like `~B`). Newlines within the triple quotes are preserved literally. The resulting binary `S` is printed using `io:put_chars/1`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_18\n\nLANGUAGE: erlang\nCODE:\n```\nquotes() ->\n    S = ~\"\"\"\n         \\\"I always have a quotation for everything -\n         it saves original thinking.\\\" - Dorothy L. Sayers\n\n         \\\"Real stupidity beats artificial intelligence every time.\\\"\n         - Terry Pratchett\n         \"\"\",\n    io:put_chars(S),\n    io:nl().\n```\n\n----------------------------------------\n\nTITLE: Using Socket Module for Low-level Socket Operations in Erlang\nDESCRIPTION: References the new experimental socket module that provides a low-level API for socket operations, intended to eventually replace the inet driver. This module facilitates implementation of protocols beyond TCP, UDP, and SCTP.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/129.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nsocket\n```\n\n----------------------------------------\n\nTITLE: Using filtermap/2 with Set Modules in Erlang\nDESCRIPTION: Shows how the new filtermap/2 function can be used to simultaneously map and filter elements in a set, providing a more concise alternative to separate filter and map operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_32\n\nLANGUAGE: erlang\nCODE:\n```\n1> Mixed = [1,2,3,a,b,c].\n[1,2,3,a,b,c]\n2> F = fun(N) when is_integer(N) -> {true,N * 100};\n   (_) -> false\n   end.\n#Fun<erl_eval.42.39164016>\n3> sets:to_list(sets:filtermap(F, sets:from_list(Mixed))).\n[300,200,100]\n```\n\n----------------------------------------\n\nTITLE: Monitoring Poll Thread Performance with msacc in Erlang\nDESCRIPTION: Example showing how to use msacc to monitor poll thread performance and determine if additional polling threads are needed. The output shows thread statistics including sleep time percentages across different thread types.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-11-IO-Polling.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nEshell V9.3  (abort with ^G)\n1> msacc:start(10000),msacc:print().\nAverage thread real-time    : 10000410 us\nAccumulated system run-time :      937 us\nAverage scheduler run-time  :      897 us\n\n        Thread      aux check_io emulator       gc    other     port    sleep\n\nStats per thread:\n     async( 0)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n       aux( 1)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_cpu_( 1)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_io_s( 1)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n      poll( 0)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n scheduler( 1)    0.00%    0.00%    0.00%    0.00%    0.01%    0.00%   99.99%\n\nStats per type:\n         async    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n           aux    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_cpu_sche    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_io_sched    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n          poll    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n     scheduler    0.00%    0.00%    0.00%    0.00%    0.01%    0.00%   99.99%\n```\n\n----------------------------------------\n\nTITLE: Implementing Case Statement with Variable Assignment in Erlang\nDESCRIPTION: This code snippet shows two equivalent implementations of a case statement in Erlang where a variable Y is assigned different values in each clause.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\ncase3a(X) ->\n    case X of\n        zero ->\n            Y = 0;\n        something ->\n            Y = X;\n        _ ->\n            Y = no_idea\n    end,\n    {ok,Y}.\n```\n\nLANGUAGE: erlang\nCODE:\n```\ncase3b(X) ->\n    Y = case X of\n            zero -> 0;\n            something -> X;\n            _ -> no_idea\n        end,\n    {ok,Y}.\n```\n\n----------------------------------------\n\nTITLE: Checking JIT Compiler Status in Erlang\nDESCRIPTION: This code snippet demonstrates how to verify if a JIT-enabled emulator is running in Erlang/OTP 24. It uses the erlang:system_info/1 function to check the emulator flavor.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/146.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:system_info(emu_flavor)\n```\n\n----------------------------------------\n\nTITLE: Enabling DTLS in Erlang SSL Connection\nDESCRIPTION: Shows how to enable the experimental DTLS (Datagram Transport Layer Security) feature in Erlang's SSL module. This option is added to ssl:connect and ssl:listen functions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/109.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{protocol, dtls}\n```\n\n----------------------------------------\n\nTITLE: Erlang Less-Than Function using Guards\nDESCRIPTION: A function utilizing Erlang's `if` construct to determine and return based on the result of a less-than comparison between two variables. Targets developers needing efficient boolean logic in conditional structures.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\nmy_less_than(A, B) ->\n    if\n        A < B -> smaller;\n        true -> larger_or_equal\n    end.\n```\n\n----------------------------------------\n\nTITLE: Using Dialyzer Attribute for Warning Suppression in Erlang\nDESCRIPTION: The -dialyzer() attribute can be used to suppress warnings in a module by specifying functions or warning options. It can also be used to request warnings in a module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/18.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-dialyzer()\n```\n\n----------------------------------------\n\nTITLE: Socket Backend Configuration in gen_tcp\nDESCRIPTION: Shows how to configure gen_tcp to use the new socket backend instead of inet, using connection options.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n{ok,Socket} = gen_tcp:connect(Addr,Port,[{inet_backend,socket}|OtherOpts])\n```\n\n----------------------------------------\n\nTITLE: ETS Table Configuration with Auto Write Concurrency\nDESCRIPTION: Example of configuring an ETS table with automatic write concurrency optimization\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/153.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n{write_concurrency, auto}\n```\n\n----------------------------------------\n\nTITLE: Defining Release Configuration in Reltool (Erlang)\nDESCRIPTION: Shows the new format for specifying a release configuration in reltool, including an optional Opts element in the rel tuple.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/22.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{rel, Name, Vsn, RelApps, Opts}\n```\n\n----------------------------------------\n\nTITLE: Using Default Sigil (~) for Binary with Escapes (Inline) in Erlang Shell\nDESCRIPTION: Illustrates that the default sigil (`~\"...\"`), when used with a standard inline string (not triple-quoted), behaves like `~b\"...\"`. It creates a UTF-8 binary and interprets escape sequences like `\\t`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_17\n\nLANGUAGE: erlang\nCODE:\n```\n2> ~\"abc\\txyz\".\n<<\"abc\\txyz\">>\n```\n\n----------------------------------------\n\nTITLE: Creating an ETS Table with Adaptive Write Concurrency in Erlang\nDESCRIPTION: An Erlang code snippet demonstrating how to create an ETS table with the new adaptive write concurrency feature using the 'auto' option, which automatically adjusts the number of locks at runtime.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_17\n\nLANGUAGE: erlang\nCODE:\n```\nets:new(my_table, [{write_concurrency, auto}]).\n```\n\n----------------------------------------\n\nTITLE: Using map/2 with Set Modules in Erlang\nDESCRIPTION: Demonstrates the new map/2 function for set modules which applies a function to each element in a set and produces a new set with the results.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_31\n\nLANGUAGE: erlang\nCODE:\n```\n4> Seq = lists:seq(1, 20, 2).\n[1,3,5,7,9,11,13,15,17,19]\n#Fun<erl_eval.42.39164016>\n5> ordsets:to_list(ordsets:map(fun(N) -> N div 4 end, ordsets:from_list(Seq))).\n[0,1,2,3,4]\n```\n\n----------------------------------------\n\nTITLE: Getting Cipher Information in Crypto Module\nDESCRIPTION: Shows the usage of the new cipher_info/1 function in the crypto module that returns a map with information about a cipher algorithm.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/132.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\ncrypto:cipher_info/1\n```\n\n----------------------------------------\n\nTITLE: Enabling Asynchronous Distributed Signaling in Erlang/OTP 25.3\nDESCRIPTION: This snippet shows how to enable the new asynchronous distributed signaling feature in Erlang/OTP 25.3. This functionality allows send operations to never block and can be enabled per process using the process_flag function with the async_dist flag.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/161.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nprocess_flag(async_dist, Bool)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Cipher Information with crypto:cipher_info/1 (Erlang)\nDESCRIPTION: Demonstrates the usage of the new crypto:cipher_info/1 function to retrieve information about a cipher algorithm as a map.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/22.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\ncrypto:cipher_info(CipherAlgorithm)\n```\n\n----------------------------------------\n\nTITLE: Resolving URI References with uri_string:resolve/2 (Erlang)\nDESCRIPTION: Shows how to use the new uri_string:resolve/2 function to resolve a URI reference against a base URI.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/22.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nuri_string:resolve(URIReference, BaseURI)\n```\n\n----------------------------------------\n\nTITLE: Creating a New Trace Session in Erlang/OTP 27\nDESCRIPTION: This code creates a new trace session using the new trace:session_create/3 function. It assigns a name, connects the previously created tracer process, and provides empty options.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_44\n\nLANGUAGE: erlang\nCODE:\n```\nSession = trace:session_create(my_session, Tracer, []).\n```\n\n----------------------------------------\n\nTITLE: Handling BIF Errors with Improved Diagnostics - Erlang\nDESCRIPTION: Compares Erlang/OTP 23's cryptic errors from BIFs with the more descriptive errors introduced in OTP 24 under EEP-54. Demonstrates both the old behavior (generic 'bad argument' messages) and the new detailed error reports identifying which argument is at fault and why. Requires Erlang/OTP 23 and Erlang/OTP 24 respectively; no dependencies other than the standard shell and BIFs. Inputs are expressions invoking BIFs incorrectly; output is structured error messages, and the key constraint is demonstration within the interactive Erlang shell.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\n1> element({a,b,c}, 1).\n** exception error: bad argument\n     in function  element/2\n        called as element({a,b,c},1)\n```\n\nLANGUAGE: erlang\nCODE:\n```\n> ets:update_counter(table, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(table,k,1)\n```\n\nLANGUAGE: erlang\nCODE:\n```\n1> element({a,b,c}, 1).\n** exception error: bad argument\n     in function  element/2\n        called as element({a,b,c},1)\n        *** argument 1: not an integer\n        *** argument 2: not a tuple\n2> ets:new(table,[named_table]).\ntable\n3> ets:update_counter(table, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(table,k,1)\n        *** argument 2: not a key that exists in the table\n```\n\nLANGUAGE: erlang\nCODE:\n```\n1> proc_lib:spawn(fun() -> ets:update_counter(table, k, 1) end).\n<0.94.0>\n=CRASH REPORT==== 10-May-2021::11:20:35.367023 ===\n  crasher:\n    initial call: erl_eval:'-expr/5-fun-3-'/0\n    pid: <0.94.0>\n    registered_name: []\n    exception error: bad argument\n      in function  ets:update_counter/3\n         called as ets:update_counter(table,k,1)\n         *** argument 1: the table identifier does\n                         not refer to an existing ETS table\n    ancestors: [<0.92.0>]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Naive (Incorrect) Single-Clause Case Removal\nDESCRIPTION: This snippet illustrates a potential incorrect step when eliminating a single-clause `case`. Simply removing the `case` and keeping the body `{'tuple', A, B}` would leave variables `A` and `B` unbound, leading to an error. This highlights the need for proper variable binding.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_11\n\nLANGUAGE: erlang\nCODE:\n```\n'aa'/0 =\n    fun () ->\n       {'tuple',A,B}\n```\n\n----------------------------------------\n\nTITLE: Configuring Erlang Distribution without EPMD\nDESCRIPTION: New options for running Erlang distribution without relying on EPMD, including disabling listening and configuring a default EPMD port.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/23.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n-dist_listen false\n```\n\nLANGUAGE: erlang\nCODE:\n```\n-erl_epmd_port Port\n```\n\n----------------------------------------\n\nTITLE: Erlang Module for Tuple Matching\nDESCRIPTION: An Erlang module that exposes a tuple matching function, using pattern matching to return increment results or error. Dependencies include Erlang runtime, with input being any data type and output being either an incremented integer or the input itself.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-module(example).\n-export([tuple_matching/1]).\n\ntuple_matching(X) ->\n    case increment(X) of\n        {ok,Result} -> Result;\n        error -> X\n    end.\n\nincrement(X) when is_integer(X) -> {ok,X+1};\nincrement(_) -> error.\n```\n\n----------------------------------------\n\nTITLE: Using inet:setopts/2 with reuseaddr Option in Erlang\nDESCRIPTION: This code reference highlights a change in the reuseaddr option behavior in inet:setopts/2. As of OTP 25.2, the {reuseaddr, true} option will be ignored on Windows unless the socket is a UDP socket, returning to behavior more similar to pre-OTP 25.0.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/159.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\ninet:setopts/2 {reuseaddr, true}\n```\n\n----------------------------------------\n\nTITLE: Listing open sockets with inet:i()\nDESCRIPTION: Example using inet:i() to show all open sockets in the system. This demonstrates how socket-backed gen_tcp connections appear in the socket listing compared to traditional port-based connections.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_11\n\nLANGUAGE: erlang\nCODE:\n```\n2> inet:i().\nPort      Module         Recv Sent Owner    Local Address   Foreign Address    State Type   \nesock[19] gen_tcp_socket 0    0    <0.98.0> localhost:44082 localhost:http-alt CD:SD STREAM \n```\n\n----------------------------------------\n\nTITLE: Unix Domain Socket Example in Erlang\nDESCRIPTION: Demonstrates the experimental support for Unix Domain Sockets using gen_udp:open with local socket configuration.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/105.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\ngen_udp:open(0, [{ifaddr,{local,\"/tmp/socket\"}}])\n```\n\n----------------------------------------\n\nTITLE: Querying ETS Table Memory Usage in Erlang\nDESCRIPTION: This code snippet shows how to query the memory usage of an ETS table using the ets:info/2 function in Erlang.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-08-03-scalable-ets-counters.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nets:info(Table, memory)\n```\n\n----------------------------------------\n\nTITLE: Using proc_lib:init_fail for Error Handling in OTP\nDESCRIPTION: Demonstrates the new synchronous failure behavior in proc_lib:start* functions, which now requires failing processes to use proc_lib:init_fail/2,3 to indicate failure.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nproc_lib:init_fail/2,3\n```\n\n----------------------------------------\n\nTITLE: Using the count1 Module in Erlang Shell\nDESCRIPTION: This snippet shows how to use the `count1` module within an Erlang shell (`erl`). It first defines the record `s` in the shell environment and then calls `count1:count/1` with a sample list, demonstrating the expected output which is a record containing the counts.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\n1> -record(s, {atoms=0,other=0}).\nok\n2> count1:count([a,b,c,1,2,3,4,5]).\n#s{atoms = 3,other = 5}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hash Information with crypto:hash_info/1 (Erlang)\nDESCRIPTION: Shows how to use the new crypto:hash_info/1 function to get information about a hash algorithm as a map.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/22.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ncrypto:hash_info(HashAlgorithm)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Core Transform in Erlang\nDESCRIPTION: This code snippet shows a basic implementation of a core transform module that prints the module name and the number of nodes in the Core Erlang tree.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\n-module(my_core_transform).\n-export([core_transform/2]).\n\ncore_transform(Core, _Options) ->\n    Module = cerl:concrete(cerl:module_name(Core)),\n    io:format(\"Module name: ~p\\n\", [Module]),\n    io:format(\"Number of nodes in Core Erlang tree: ~p\\n\",\n              [cerl_trees:size(Core)]),\n    Core.\n```\n\n----------------------------------------\n\nTITLE: Enhanced zip Functions with trim and pad Options in Erlang\nDESCRIPTION: Demonstrates the new options for the zip family of functions in OTP 26 which handle lists of unequal lengths. The 'trim' option ignores superfluous elements from longer lists, while the 'pad' option extends shorter lists with default values.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_15\n\nLANGUAGE: erlang\nCODE:\n```\n1> lists:zip([a,b,c], [1,2,3]).\n[{a,1},{b,2},{c,3}]\n```\n\nLANGUAGE: erlang\nCODE:\n```\n2> lists:zip([a,b,c,d], [1,2,3]).\n** exception error: no function clause matching . . .\n```\n\nLANGUAGE: erlang\nCODE:\n```\n3> lists:zip([a,b,c,d], [1,2,3], trim).\n[{a,1},{b,2},{c,3}]\n```\n\nLANGUAGE: erlang\nCODE:\n```\n4> lists:zip([a,b,c,d], [1,2,3], {pad, {zzz, 999}}).\n[{a,1},{b,2},{c,3},{d,999}]\n5> lists:zip([a,b,c], [1,2,3,4,5], {pad, {zzz, 999}}).\n[{a,1},{b,2},{c,3},{zzz,4},{zzz,5}]\n```\n\nLANGUAGE: erlang\nCODE:\n```\n6> lists:zip3([], [a], [1,2,3], {pad, {0.0, zzz, 999}}).\n[{0.0,a,1},{0.0,zzz,2},{0.0,zzz,3}]\n```\n\n----------------------------------------\n\nTITLE: Using ETS take/2 Function in Erlang\nDESCRIPTION: The ets:take/2 function works similarly to ets:delete/2 but also returns the deleted object(s). It's a new addition to the ETS module in Erlang/OTP 18.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/18.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nets:take/2\n```\n\n----------------------------------------\n\nTITLE: Defining Preprocessor Macros in Erlang\nDESCRIPTION: New preprocessor macros ?FUNCTION_NAME and ?FUNCTION_ARITY are introduced in the compiler and stdlib modules. These macros provide easy access to the current function's name and arity.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/19.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n?FUNCTION_NAME\n?FUNCTION_ARITY\n```\n\n----------------------------------------\n\nTITLE: Hashing Unique Integers with erlang:phash2 in Erlang\nDESCRIPTION: This code demonstrates generating a pseudo-random integer by hashing a unique integer and optionally restricting it to a range. Dependencies include the 'erlang' module (built-in). The primary input is provided via the 'Range' parameter, generating values between 0 and Range-1. The function exploits 'unique_integer' for low-overhead uniqueness and 'phash2' for fast generic hashing suitable for moderate range sizes. Limitations involve statistical bias for large ranges and lower-quality randomness compared to dedicated PRNG algorithms.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:phash2(erlang:unique_integer(), Range)\n```\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:phash2(erlang:unique_integer())\n```\n\n----------------------------------------\n\nTITLE: Merging Maps with maps:merge/2 and Key Reuse Optimization - Erlang\nDESCRIPTION: Two examples of merging maps with maps:merge/2, illustrating the new memory optimization in OTP 26 that attempts to reuse the key tuple if possible. If both maps share all keys, key tuple reuse occurs; otherwise, a new key tuple may be created. The output is the merged map, with order not guaranteed.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_12\n\nLANGUAGE: erlang\nCODE:\n```\n1> maps:merge(#{x => 13, y => 99, z => 100}, #{x => 0, z => -7}).\n#{y => 99,x => 0,z => -7}\n```\n\nLANGUAGE: erlang\nCODE:\n```\n2> maps:merge(#{x => 1000}, #{y => 2000}).\n#{y => 2000,x => 1000}\n```\n\n----------------------------------------\n\nTITLE: Defining a compile attribute in Erlang\nDESCRIPTION: Example of using a -compile attribute in an Erlang module to disable warnings for missing specs. This demonstrates the new compiler option precedence in OTP 27.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/168.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-compile([nowarn_missing_spec]).\n```\n\n----------------------------------------\n\nTITLE: Type Information Simplification in Erlang JIT\nDESCRIPTION: Shows how OTP 25 adds type information to BEAM instructions to optimize type testing, allowing the JIT to generate simpler native code when variable types are inferred. Requires OTP 25 or later.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n{test,is_tuple,\n      {f,3},\n      [{tr,{x,0},\n           {t_union,{t_atom,[error]},\n                    none,none,\n                    [{{2,{t_atom,[ok]}},\n                      {t_tuple,2,true,\n                               #{1 => {t_atom,[ok]},\n                                 2 => {t_integer,any}}}}],\n                    none}}]}\n```\n\n----------------------------------------\n\nTITLE: Checking EdDSA curve support in crypto module\nDESCRIPTION: Example showing how to check for Edwards-curve Digital Signature Algorithm (EdDSA) support in the crypto module. The output shows ed25519 and ed448 curves are available when using OpenSSL 1.1.1 or later.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_12\n\nLANGUAGE: erlang\nCODE:\n```\n> crypto:supports(curves).\n[...\n  c2tnb359v1, c2tnb431r1, ed25519, ed448, ipsec3, ipsec4\n ...]                     ^        ^\n```\n\n----------------------------------------\n\nTITLE: Erlang On-Load Attribute for Functions\nDESCRIPTION: Reference to the -on_load() attribute which is now understood by the Xref analyzer for locals_not_used analysis, preventing it from reporting functions that are used via this mechanism.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/115.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n-on_load()\n```\n\n----------------------------------------\n\nTITLE: Displaying Erlang Compiler Options\nDESCRIPTION: This snippet demonstrates how to display the available compiler options, including undocumented debugging options, using the compile:options() function in the Erlang shell.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-19-compiler-time-option.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n$ erl\nErlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:10] [hipe] [kernel-poll:false]\n\nEshell V9.2  (abort with ^G)\n1> compile:options().\ndpp - Generate .pp file\n'P' - Generate .P source listing file\ndabstr - Generate .abstr file\ndebug_info - Run save_abstract_code\ndexp - Generate .expand file\n'E' - Generate .E source listing file\ndcore - Generate .core file\nclint0 - Run core_lint_module\ndoldinline - Generate .oldinline file\ndcorefold - Generate .corefold file\ndinline - Generate .inline file\ndcopt - Generate .copt file\n.\n.\n.\n```\n\n----------------------------------------\n\nTITLE: Adding a Logger Handler in Erlang\nDESCRIPTION: This Erlang code snippet demonstrates adding a new log handler named `ssl_handler` to the Erlang logger system. It uses the standard handler `logger_std_h` (which typically prints to standard I/O) and applies a specific configuration stored in the `Config` variable.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nlogger:add_handler(ssl_handler, logger_std_h, Config),\n```\n\n----------------------------------------\n\nTITLE: Documentation display commands in the Erlang shell\nDESCRIPTION: New functions in the Erlang shell for displaying documentation for modules, functions, and types, with various forms of arity specification.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/140.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nh/1,2,3\n```\n\nLANGUAGE: erlang\nCODE:\n```\nht/1,2,3\n```\n\n----------------------------------------\n\nTITLE: Adding UTF-8 Encoding Comment to Erlang Files\nDESCRIPTION: A directive to specify UTF-8 encoding for Erlang source files to ensure compatibility with both OTP 17 and previous versions that used Latin-1 as the default encoding.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/47.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n%% -*- coding: utf-8 -*-\n```\n\n----------------------------------------\n\nTITLE: Recording perf Profile for Erlang Node - Shell Command\nDESCRIPTION: This snippet shows how to start performance recording of the Erlang VM using perf, with the '+JPperf true' flag enabling JIT profiling support. The '--call-graph fp' option records stack traces using frame pointers. Prerequisites: perf installed on Linux and Erlang/OTP 25+ supporting '+JPperf'. The command produces profile data for further analysis. Limitations: Only works on environments where perf and necessary flags are supported.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nperf record --call-graph fp -- erl +JPperf true\n```\n\n----------------------------------------\n\nTITLE: Using New Socket Options in inet:setopts/2\nDESCRIPTION: Shows the three new socket options added to inet:setopts/2: reuseport, reuseport_lb, and exclusiveaddruse for enhanced network programming capabilities.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\ninet:setopts/2\n```\n\n----------------------------------------\n\nTITLE: Shell Auto-completion: Defining Variables and Inspecting Bindings - Erlang\nDESCRIPTION: Showcases variable creation and auto-completion with the Erlang shell, as well as listing available bindings. The snippet defines a new coordinate variable, demonstrates the resulting structure, and presents how starting a variable name and pressing TAB exposes the bindings. This helps users efficiently navigate auto-completed entities and shell state. No external dependencies required.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n7> Oxford = #coord{x=51.752022, y=-1.257677}.\n#coord{x = 51.752022,y = -1.257677}\n```\n\nLANGUAGE: erlang\nCODE:\n```\n8> O\nbindings\nOrigin    Oxford\n```\n\nLANGUAGE: erlang\nCODE:\n```\n8> Oxford.\n#coord{x = 51.752022,y = -1.257677}\n```\n\n----------------------------------------\n\nTITLE: Using ~s Sigil with Triple-Quoted String to Enable Escapes in Erlang Shell\nDESCRIPTION: Illustrates applying the `~s\"\"\"...\"\"\"` sigil to a triple-quoted string. Unlike the default sigil (`~`) or `~S` with triple quotes, `~s` *enables* the interpretation of escape sequences (`\\t`, `\\n`) within the triple-quoted context, resulting in a standard Erlang string (list of characters).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_20\n\nLANGUAGE: erlang\nCODE:\n```\n4> ~s\"\"\"\n    \\tabc\n    \\tdef\n    \"\"\".\n\"\\tabc\\n\\tdef\"\n```\n\n----------------------------------------\n\nTITLE: Optimizing Core Erlang to Avoid Tuple Building using Value Lists\nDESCRIPTION: This optimized Core Erlang code for `b/2` demonstrates how `sys_core_fold` eliminates unnecessary tuple creation. Instead of building the tuple `{A, B}`, it directly uses a value list `<_@c1, _@c0>` (representing the function arguments) as the expression for the `case` statement, making the matching more efficient.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_16\n\nLANGUAGE: erlang\nCODE:\n```\n'b'/2 =\n    fun (_@c1,_@c0) ->\n\tcase <_@c1,_@c0> of\n\t  <'true','false'> when 'true' ->\n\t      'ok'\n\t  <'false','true'> when 'true' ->\n\t      'not_ok'\n\t  <_@c5,_@c6> when 'true' ->\n\t      'error'\n\tend\n```\n\n----------------------------------------\n\nTITLE: Compiling and Installing Erlang/OTP from Source (Bash)\nDESCRIPTION: This command sequence compiles and installs Erlang/OTP from a downloaded source archive. It first configures the build environment based on the system using `./configure`, then compiles the source code with `make`, and finally installs the compiled binaries and libraries using `make install`. This process requires standard build tools (C compiler, make) and assumes execution within the extracted source directory. Refer to the specific release's build instructions for potential additional steps or dependencies.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/downloads.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && make install\n```\n\n----------------------------------------\n\nTITLE: Enabling Features at Runtime in Erlang Shell\nDESCRIPTION: Demonstrates how to enable the maybe_expr feature, or all features, at the start of an Erlang shell session.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_4\n\nLANGUAGE: Text\nCODE:\n```\nerl -enable-feature maybe_expr\n```\n\nLANGUAGE: Text\nCODE:\n```\nerl -enable-feature all\n```\n\n----------------------------------------\n\nTITLE: Improved Match Context Reuse in Erlang OTP 22\nDESCRIPTION: Illustrates a case where match context reuse was previously limited but is now optimized in OTP 22. This allows for better performance in functions that wrap bit-syntax matching operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-11-07-retired-pitfalls-22.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\ncalls_wrapper(<<\"hello\",Tail/binary>>) ->\n    count_ones(Tail).\n\n%% This simple wrapper prevents context reuse in the call above. :(\ncount_ones(Bin) -> count_ones_1(Bin, 0).\n\ncount_ones_1(<<1, Tail/binary>>, Acc) -> count_ones_1(Tail, Acc + 1);\ncount_ones_1(<<_, Tail/binary>>, Acc) -> count_ones_1(Tail, Acc);\ncount_ones_1(<<>>, Acc) -> Acc.\n```\n\n----------------------------------------\n\nTITLE: Using New Statistics Functions in Erlang/OTP 18.3\nDESCRIPTION: New statistics functions introduced in Erlang/OTP 18.3 for monitoring runnable and active processes and ports. These can be called with specific atoms to retrieve different metrics about the system's queues and tasks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/101.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:statistics(total_run_queue_lengths | run_queue_lengths | total_active_tasks | active_tasks)\n```\n\n----------------------------------------\n\nTITLE: Using is_equal/2 with Set Modules in Erlang\nDESCRIPTION: Shows how the new is_equal/2 function can be used to compare sets by their elements rather than their implementation details, which is more reliable than using == or =:=.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_30\n\nLANGUAGE: erlang\nCODE:\n```\n1> Seq = lists:seq(1, 20, 2).\n[1,3,5,7,9,11,13,15,17,19]\n2> gb_sets:from_list(Seq) == gb_sets:delete(10, gb_sets:from_list([10|Seq])).\nfalse\n3> gb_sets:is_equal(gb_sets:from_list(Seq), gb_sets:delete(10, gb_sets:from_list([10|Seq]))).\ntrue\n```\n\n----------------------------------------\n\nTITLE: Defining a Body-Recursive Sum Function in Erlang\nDESCRIPTION: This Erlang code defines a function `sum_body` that calculates the sum of a list using body recursion. Unlike the tail-recursive version, the addition (`Head + sum_body(Tail)`) happens *after* the recursive call returns. This pattern requires a stack frame to store intermediate values (the `Head` of the list) across the recursive call.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nsum_body([Head | Tail]) ->\n    Head + sum_body(Tail);\nsum_body([]) ->\n    0.\n```\n\n----------------------------------------\n\nTITLE: Using New NIF Interface Functions for UTF-8 Support\nDESCRIPTION: Shows the new NIF interface functions for UTF-8 atoms and strings including enif_make_new_atom, enif_make_new_atom_len, and enif_get_string_length.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nenif_make_new_atom, enif_make_new_atom_len, enif_get_string_length\n```\n\n----------------------------------------\n\nTITLE: Implementing Command-Line Parsing with argparse in Erlang\nDESCRIPTION: An escript named 'ehead' that demonstrates the argparse module's capabilities for command-line parsing. The script defines options for specifying the number of lines and file arguments in a style similar to the Unix 'head' command.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_27\n\nLANGUAGE: erlang\nCODE:\n```\n#!/usr/bin/env escript\n%% -*- erlang -*-\n\nmain(Args) ->\n    argparse:run(Args, cli(), #{progname => ehead}).\n\ncli() ->\n    #{\n      arguments =>\n          [#{name => lines, type => {integer, [{min, 1}]},\n             short => $n, long => \"-lines\", default => 10,\n             help => \"number of lines to print\"},\n           #{name => files, nargs => nonempty_list, action => extend,\n             help => \"lists of files\"}],\n      handler => fun(Args) ->\n                         io:format(\"~p\\n\", [Args])\n                 end\n     }.\n```\n\n----------------------------------------\n\nTITLE: Opening a Unix Domain Socket with gen_udp in Erlang\nDESCRIPTION: Example of using the new experimental support for Unix Domain Sockets in erts/kernel. This snippet demonstrates how to open a UDP socket using a local file path as the interface address.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/19.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ngen_udp:open(0, [{ifaddr,{local,\"/tmp/socket\"}}])\n```\n\n----------------------------------------\n\nTITLE: Creating a Logger Domain Filter in Erlang\nDESCRIPTION: This Erlang code defines a filter (`Filter`) for a logger handler. It uses the built-in `logger_filters:domain/2` filter function to allow (`log`) log events originating from the `[otp, ssl]` domain and any of its subdomains (`sub`) to pass through the filter.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\nFilter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},\n```\n\n----------------------------------------\n\nTITLE: Defining Erlang Function with Complex Case Matching\nDESCRIPTION: This Erlang function `aa/0` uses a `case` expression to match against a constant tuple `{a, tuple}`. It includes clauses for matching a single-element list, a two-element tuple, and a wildcard, demonstrating different pattern matching scenarios.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\naa() ->\n    case {a,tuple} of\n\t[List] -> List;\n\t{A,B} ->  {tuple,A,B};\n\t_ ->      something_else\n    end.\n```\n\n----------------------------------------\n\nTITLE: Optimized BEAM Code for Record Creation (OTP 27)\nDESCRIPTION: This BEAM assembly code is generated by the Erlang/OTP 27 compiler for the optimized record creation. It uses a single `put_tuple2` instruction to create the final record directly, eliminating the intermediate update steps and copies shown in the previous BEAM example.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_5\n\nLANGUAGE: beam\nCODE:\n```\n{put_tuple2,{x,0},\n            {list,[{atom,foo},\n                   {x,0},\n                   {integer,2},\n                   {integer,3},\n                   {atom,undefined},\n                   {atom,undefined}]}}.\n```\n\n----------------------------------------\n\nTITLE: Defining Reltool Release Configuration with New Options Syntax in Erlang\nDESCRIPTION: Shows the new format for reltool release configuration where an Opts element can now be included in a rel tuple, using the syntax {rel, Name, Vsn, RelApps, Opts}.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/129.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{rel, Name, Vsn, RelApps, Opts}\n```\n\n----------------------------------------\n\nTITLE: Printing Maps with Ordered Keys using io:format - Erlang\nDESCRIPTION: Demonstrates explicit specification of key ordering for map display using io:format with ~kp and ~Kp format strings. In OTP 26, ~kp sorts keys by term order, while ~Kp with a custom fun allows user-defined sorting, such as reverse. The code shows both approaches and their output, with dependency on the io module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n3> io:format(\"~kp\\n\", [AM]).\n#{a => 1,b => 2,c => 3}\nok\n```\n\nLANGUAGE: erlang\nCODE:\n```\n4> io:format(\"~Kp\\n\", [fun(A, B) -> A > B end, AM]).\n#{c => 3,b => 2,a => 1}\nok\n```\n\n----------------------------------------\n\nTITLE: Integer Conversion Benchmark in Erlang\nDESCRIPTION: Benchmark code for measuring the performance of binary_to_integer/1 conversion on large numbers.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_24\n\nLANGUAGE: erlang\nCODE:\n```\nbench() ->\n    Size = 1_262_000,\n    String = binary:copy(<<\"9\">>, Size),\n    {Time, _Val} = timer:tc(erlang, binary_to_integer, [String]),\n    io:format(\"Size: ~p, seconds: ~p\\n\", [Size, Time / 1_000_000]).\n```\n\n----------------------------------------\n\nTITLE: BEAM code generated for basic integer addition with guards\nDESCRIPTION: The BEAM code generated for the add3 function showing how type information is represented in the intermediate code. Note that operands are marked as integers but without range constraints.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_29\n\nLANGUAGE: text\nCODE:\n```\n    {test,is_integer,{f,5},[{x,0}]}.\n    {test,is_integer,{f,5},[{x,1}]}.\n    {gc_bif,'+',\n            {f,0},\n            2,\n            [{tr,{x,0},{t_integer,any}},{tr,{x,1},{t_integer,any}}],\n            {x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Connecting with socket backend in gen_tcp\nDESCRIPTION: Example of using gen_tcp:connect with the socket inet_backend option, showing the new tuple structure returned rather than a port. The socket implementation can provide up to 4x throughput improvement in certain benchmarks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_10\n\nLANGUAGE: erlang\nCODE:\n```\n1> gen_tcp:connect(localhost,8080,[{inet_backend,socket}]).\n{ok,{'$inet',gen_tcp_socket,\n             {<0.88.0>,{'$socket',#Ref<0.2959644163.2576220161.68602>}}}}\n```\n\n----------------------------------------\n\nTITLE: Using ETS update_counter/4 Function with Default Object in Erlang\nDESCRIPTION: The ets:update_counter/4 function now accepts a default object as an argument. This enhancement provides more flexibility when updating counters in ETS tables.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/18.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nets:update_counter/4\n```\n\n----------------------------------------\n\nTITLE: Defining a Function Returning a String Literal in Erlang\nDESCRIPTION: Implements the `greek_quote/0` function using a standard Erlang string literal (a list of characters). It assigns the quote to variable `S` and prints it using `io:format/2` with the `~ts` format specifier for strings. This version uses significant memory per character (e.g., 16 bytes on a 64-bit system).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\ngreek_quote() ->\n    S = \"\\\"Know thyself\\\" (Greek: Γνῶθι σαυτόν)\",\n    io:format(\"~ts\\n\", [S]).\n```\n\n----------------------------------------\n\nTITLE: Using Cover in Local-Only Mode\nDESCRIPTION: Demonstrates how to use the new Cover API for running in a faster local-only mode when doing code coverage analysis.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/132.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ncover:local_only/0\n```\n\n----------------------------------------\n\nTITLE: Translating Erlang Case Statement to SSA Code\nDESCRIPTION: This snippet shows the SSA code generated for the case3a/1 function, demonstrating how the phi instruction is used to maintain SSA properties while handling multiple variable assignments.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:case3a(_0) {\n0:\n  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]\n\n5:\n  br label 3\n\n6:\n  br label 3\n\n4:\n  br label 3\n\n3:\n  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }\n  _7 = put_tuple literal ok, Y\n  ret _7\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang Module with Time Option\nDESCRIPTION: Shows how to compile an Erlang module using the 'time' option to display information about compiler passes.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc +time trivial.erl\nCompiling \"trivial\"\n remove_file                   :      0.000 s       3.7 kB\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.002 s       5.5 kB\n expand_records                :      0.000 s       5.3 kB\n     .\n     .\n     .\n```\n\n----------------------------------------\n\nTITLE: Using Truncated Multiplication for Range Mapping in Erlang\nDESCRIPTION: Demonstrates mapping a generated random number `X` into a non-power-of-2 `Range` using truncated multiplication followed by a right bit shift (`bsr`). The rule of thumb suggests `Range` should be less than 2^(GeneratorBits/2), and the multiplication result (`X * Range`) must not exceed 59 bits to avoid bignums. This method relies on the quality of the generator's high bits.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\nV = (X * Range) bsr GeneratorBits\n```\n\n----------------------------------------\n\nTITLE: Translating Erlang Function to Basic Core Erlang\nDESCRIPTION: This snippet shows a simplified Core Erlang translation of the `a/0` Erlang function. It uses a `let` expression to bind the variable `A` to the constant 42 before constructing the return tuple `{ok, A}`. This representation illustrates the direct mapping before constant propagation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n'a'/0 =\n    fun () ->\n       let <A> = 42\n       in {'ok',A}\n```\n\n----------------------------------------\n\nTITLE: Running Dialyzer with Configuration File in Erlang\nDESCRIPTION: Command to run Dialyzer using the settings from dialyzer.config file instead of specifying them on the command line. This simplifies the command when using incremental analysis.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n$ dialyzer --incremental\ndone (passed successfully)\n```\n\n----------------------------------------\n\nTITLE: Using ~B Sigil for UTF-8 Binary Creation (No Escapes) in Erlang\nDESCRIPTION: Introduces the sigil syntax. This `greek_quote/0` implementation uses the `~B[...]` sigil as an alternative way to create a UTF-8 encoded binary. The `B` signifies a binary with UTF-8 encoding where backslash escape sequences are *not* interpreted. Delimiters (`[` and `]`) are chosen because they don't appear in the string content.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_15\n\nLANGUAGE: erlang\nCODE:\n```\ngreek_quote() ->\n    S = ~B[\"Know thyself\" (Greek: Γνῶθι σαυτόν)],\n    io:format(\"~ts\\n\", [S]).\n```\n\n----------------------------------------\n\nTITLE: Implementing update_tuple Function in Erlang\nDESCRIPTION: This snippet shows a function that updates multiple elements of a tuple using setelement/3, which will be optimized by the sys_core_dsetel pass.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\nupdate_tuple(T0) ->\n    T = setelement(3, T0, y),\n    setelement(2, T, x).\n```\n\n----------------------------------------\n\nTITLE: Creating and Tracing an Array Operation\nDESCRIPTION: This snippet demonstrates a function call that will generate trace messages based on the previously configured tracing. It shows how function calls within the array module are captured when creating a new array.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_47\n\nLANGUAGE: erlang\nCODE:\n```\narray:new(10).\n```\n\n----------------------------------------\n\nTITLE: Committing Backup Files with Nested Error Handling - Erlang\nDESCRIPTION: This snippet demonstrates a traditional approach to handling sequential operations that may fail (syncing, closing, and renaming a backup file) in Erlang by deeply nesting 'case ... end' statements. Each operation is checked for success (ok) with error values propagated immediately. Required dependencies include the disk_log and file modules, and a record or map structure supporting the #backup record syntax. The function expects an OpaqueData structure with backup fields. On success, it returns a tuple {ok, File}, otherwise {error, Reason}. Limitations include readability and maintainability, especially as nesting increases.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\ncommit_write(OpaqueData) ->\n    B = OpaqueData,\n    case disk_log:sync(B#backup.file_desc) of\n        ok ->\n            case disk_log:close(B#backup.file_desc) of\n                ok ->\n                    case file:rename(B#backup.tmp_file, B#backup.file) of\n                        ok ->\n                            {ok, B#backup.file};\n                        {error, Reason} ->\n                            {error, Reason}\n                    end;\n                {error, Reason} ->\n                    {error, Reason}\n            end;\n        {error, Reason} ->\n            {error, Reason}\n    end.\n```\n\n----------------------------------------\n\nTITLE: Optimized Record Creation Logic (Erlang)\nDESCRIPTION: This snippet represents the effective Erlang code after the compiler in Erlang/OTP 27 optimizes the sequential updates from the previous example. The compiler merges the initial creation and subsequent updates into a single record creation expression.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nupdate(N) ->\n    #foo{a=N,b=2,c=3}.\n```\n\n----------------------------------------\n\nTITLE: Interpreting the timeout Instruction for BEAM Interpreter - C++\nDESCRIPTION: Implements the logic for the BEAM 'timeout' instruction within the interpreter, using C++ macros and function calls. The function checks tracing flags, invokes tracing and call-saving routines, clears the timeout flag, and joins the process message queue. Dependencies: process flags, tracing macros and functions, and process message handling. It accepts a process pointer and manipulates its state in-place. All referenced macros and functions must be defined elsewhere in the codebase.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-11-03-a-first-look-at-the-jit.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\ntimeout() {\n    if (IS_TRACED_FL(c_p, F_TRACE_RECEIVE)) {\n        trace_receive(c_p, am_clock_service, am_timeout, NULL);\n    }\n    if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {\n        save_calls(c_p, &exp_timeout);\n    }\n    c_p->flags &= ~F_TIMO;\n    JOIN_MESSAGE(c_p);\n}\n```\n\n----------------------------------------\n\nTITLE: Reporting Benchmark Results for base64:encode and base64:decode - Shell Output\nDESCRIPTION: These snippets present real benchmarking output for base64 encoding and decoding operations in Erlang, showing the number of iterations, time in milliseconds, and operations per second, both with and without the JIT. They require a benchmark script calling base64:encode and base64:decode on 1 MB of data. Results help compare performance improvements between JIT and interpreter. No inputs or additional parameters required as these are sample outputs.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n== Testing with 1 MB ==\nfun base64:encode/1: 1000 iterations in 11846 ms: 84 it/sec\nfun base64:decode/1: 1000 iterations in 14617 ms: 68 it/sec\n```\n\nLANGUAGE: text\nCODE:\n```\n== Testing with 1 MB ==\nfun base64:encode/1: 1000 iterations in 25938 ms: 38 it/sec\nfun base64:decode/1: 1000 iterations in 20603 ms: 48 it/sec\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang with Receive Optimization Info\nDESCRIPTION: This bash command demonstrates how to compile an Erlang module with the recv_opt_info option, which provides information about receive expression optimizations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-03-19-message-passing.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc +recv_opt_info example.erl\n```\n\n----------------------------------------\n\nTITLE: Displaying EEP-48 Documentation in Erlang Shell - Bash and Erlang\nDESCRIPTION: Demonstrates the practical effect of EEP-48 support in 'edoc' by showing how to use interactive shell commands to retrieve structured documentation chunks. Uses rebar3 to launch an Erlang shell and the 'h/3' shell helper to fetch documentation, receiving not just text but type specs and comments. Prerequisite: Erlang/OTP 24, rebar3, and compatible modules. Input: shell commands; output: human-readable function documentation. Limitations: Only functions/modules with EEP-48 doc chunks will display enhanced documentation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ rebar3 as docs shell\nErlang/OTP 24 [erts-12.0] [source] [jit]\n\nEshell V11.2.1  (abort with ^G)\n1> h(recon,info,1).\n -spec info(PidTerm) ->\n   [{info_type(), [{info_key(), Value}]}, ...]\n     when PidTerm :: pid_term().\n\n  Allows to be similar to erlang:process_info/1, but excludes\n  fields such as the mailbox, which tend to grow\n  and be unsafe when called in production systems. Also includes\n  a few more fields than what is usually given (monitors,\n  monitored_by, etc.), and separates the fields in a more\n  readable format based on the type of information contained.\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang File with Time Option\nDESCRIPTION: This snippet shows the output of compiling an Erlang file using the 'time' option. It displays the execution time and memory usage for each compiler pass.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-19-compiler-time-option.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc +time NBAP-PDU-Contents.erl\nCompiling \"NBAP-PDU-Contents\"\n remove_file                   :      0.000 s       6.5 kB\n parse_module                  :      0.709 s   25146.1 kB\n transform_module              :      0.000 s   25146.1 kB\n lint_module                   :      0.426 s   25146.1 kB\n expand_records                :      0.086 s   25993.7 kB\n core                          :      0.675 s  282518.3 kB\n sys_core_fold                 :      1.566 s  237885.4 kB\n core_transforms               :      0.000 s  237885.4 kB\n sys_core_bsm                  :      0.205 s  238982.3 kB\n sys_core_dsetel               :      0.108 s  238982.3 kB\n v3_kernel                     :      0.950 s  305320.5 kB\n v3_life                       :      0.453 s  221354.8 kB\n v3_codegen                    :      0.896 s   75801.0 kB\n beam_a                        :      0.080 s   75561.2 kB\n beam_reorder                  :      0.049 s   75561.2 kB\n beam_block                    :      0.361 s   87171.9 kB\n beam_except                   :      0.041 s   81557.7 kB\n beam_bs                       :      0.097 s   79929.2 kB\n beam_type                     :      0.502 s   77270.5 kB\n beam_split                    :      0.042 s   75004.5 kB\n beam_dead                     :      0.356 s   77566.7 kB\n beam_jump                     :      0.232 s   73347.9 kB\n beam_peep                     :      0.164 s   73346.0 kB\n beam_clean                    :      0.150 s   73081.0 kB\n beam_bsm                      :      0.092 s   75473.2 kB\n beam_receive                  :      0.020 s   75473.2 kB\n beam_record                   :      0.023 s   75471.4 kB\n beam_trim                     :      0.042 s   75471.4 kB\n beam_flatten                  :      0.071 s   66745.5 kB\n beam_z                        :      0.019 s   66442.2 kB\n beam_validator                :      0.401 s   66442.2 kB\n beam_asm                      :      0.236 s       6.5 kB\n save_binary                   :      0.000 s       6.5 kB\n```\n\n----------------------------------------\n\nTITLE: Using socket backend for gen_tcp in Erlang\nDESCRIPTION: Demonstrates how to enable the experimental socket backend for gen_tcp by setting the inet_backend option to socket as the first parameter in listen() or connect() calls.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/140.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n{inet_backend, socket}\n```\n\n----------------------------------------\n\nTITLE: SSA Code for Simple Case Statement Function\nDESCRIPTION: This snippet demonstrates the SSA code generated for the bar/1 function, including phi instructions and error handling.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_10\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:bar(_0) {\n0:\n  @ssa_bool = bif:'=:=' _0, literal none\n  br @ssa_bool, label 5, label 4\n\n5:\n  br label 3\n\n4:\n  br label 3\n\n3:\n  Y = phi { _0, 4 }, { literal 0, 5 }\n\n  %% blog.erl:52\n  _6 = bif:'+' Y, literal 1\n  @ssa_bool:6 = succeeded _6\n  br @ssa_bool:6, label 7, label 1\n\n7:\n  ret _6\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Quotation Using Single String - Erlang/io Module - Erlang\nDESCRIPTION: Demonstrates defining and outputting multi-line textual content using a single quoted string with embedded newlines and escaped quote characters. This method is available in pre-OTP 27 Erlang and relies on the io module to print the result. The approach requires manual escaping of all quotes and newline delimiters.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nquotes() ->\\n    S = \\\"\\\\\\\"I always have a quotation for everything -\\nit saves original thinking.\\\\\\\" - Dorothy L. Sayers\\n\\n\\\\\\\"Real stupidity beats artificial intelligence every time.\\\\\\\"\\n- Terry Pratchett\\\\n\\\",\\n    io:put_chars(S).\n```\n\n----------------------------------------\n\nTITLE: Optimizing Tuple Pattern Matching in Erlang\nDESCRIPTION: Demonstrates how the Erlang compiler automatically optimizes tuple pattern matching to reduce code size, execution time, and garbage collection pressure.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/122.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nf({ok, Val}) -> {ok, Val}\n```\n\nLANGUAGE: erlang\nCODE:\n```\nf({ok, Val} = Tuple) -> Tuple.\n```\n\n----------------------------------------\n\nTITLE: BEAM Code for count/2 Demonstrating 'inplace' Update (OTP 27)\nDESCRIPTION: This BEAM assembly code is generated for the `count/2` function in Erlang/OTP 27. Key instructions include tests (`test`, `is_nonempty_list`, `is_atom`), element extraction (`get_list`, `get_tuple_element`), arithmetic (`gc_bif '+'`), heap check (`test_heap`), and importantly, the `update_record` instruction with the new `inplace` hint. This hint signals to the JIT that the record can potentially be updated directly in memory without copying, provided the runtime determines it's safe (i.e., no other references exist). Type information (`tr`) is also passed to aid optimization.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_8\n\nLANGUAGE: beam\nCODE:\n```\n{test,is_nonempty_list,{f,6},[{x,0}]}.\n{get_list,{x,0},{x,2},{x,0}}.\n{test,is_atom,{f,5},[{x,2}]}.\n{get_tuple_element,{x,1},1,{x,2}}.\n{gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}.\n{test_heap,4,3}.\n{update_record,{atom,inplace},\n               3,\n               {tr,{x,1},\n                   {t_tuple,3,true,\n                            #{1 => {t_atom,[s]},\n                              2 => {t_integer,{0,'+inf'}},\n                              3 => {t_integer,{0,'+inf'}}}}},               {x,1},\n               {list,[2,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}.\n{call_only,2,{f,4}}. % count/2\n{label,5}.\n{get_tuple_element,{x,1},2,{x,2}}.\n{gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}.\n{test_heap,4,3}.\n{update_record,{atom,inplace},\n               3,\n               {tr,{x,1},\n                   {t_tuple,3,true,\n                            #{1 => {t_atom,[s]},\n                              2 => {t_integer,{0,'+inf'}},\n                              3 => {t_integer,{0,'+inf'}}}}},               {x,1},\n               {list,[3,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}.\n{call_only,2,{f,4}}. % count/2\n{label,6}.\n{test,is_nil,{f,3},[{x,0}]}.\n{move,{x,1},{x,0}}.\nreturn.\n```\n\nLANGUAGE: beam\nCODE:\n```\n{test,is_nonempty_list,{f,6},[{x,0}]}.\n{get_list,{x,0},{x,2},{x,0}}.\n```\n\nLANGUAGE: beam\nCODE:\n```\n{test,is_atom,{f,5},[{x,2}]}.\n```\n\nLANGUAGE: beam\nCODE:\n```\n{get_tuple_element,{x,1},2,{x,2}}.\n{gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}.\n```\n\nLANGUAGE: beam\nCODE:\n```\n{test_heap,4,3}.\n{update_record,{atom,inplace},\n               3,\n               {tr,{x,1},\n                   {t_tuple,3,true,\n                            #{1 => {t_atom,[s]},\n                              2 => {t_integer,{0,'+inf'}},\n                              3 => {t_integer,{0,'+inf'}}}}},               {x,1},\n               {list,[3,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}.\n```\n\n----------------------------------------\n\nTITLE: Using 'maybe' Atom When 'maybe_expr' Feature is Enabled in Erlang\nDESCRIPTION: Illustrates that when the `maybe` expression feature is enabled (the default in OTP 27+), the word `maybe` is treated as a keyword introducing the maybe expression. To use `maybe` as a regular atom (e.g., as a return value), it must be enclosed in single quotes (`'maybe'`).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_22\n\nLANGUAGE: erlang\nCODE:\n```\nwill_succeed(. . .) -> yes;\nwill_succeed(. . .) -> no;\n   .\n   .\n   .\nwill_succeed(_) -> 'maybe'.\n```\n\n----------------------------------------\n\nTITLE: NIF Declaration Attribute\nDESCRIPTION: New compiler attribute for declaring which functions may be overridden as NIFs\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/153.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n-nifs()\n```\n\n----------------------------------------\n\nTITLE: SSA Code After Type Analysis in Erlang\nDESCRIPTION: This snippet shows the SSA code after the type analysis pass, which replaces variables with known values and converts some conditional branches to unconditional branches.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' literal 4, literal 4\n  br label 5\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  @ssa_bool = bif:'=:=' literal tag, literal tag\n  br label 4\n\n4:\n  _7 = get_tuple_element _0, literal 1\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n  br label 10\n\n10:\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating ETS Table Iteration with Concurrency in Erlang\nDESCRIPTION: This Erlang snippet demonstrates the initialization and manipulation of an ETS table with write concurrency. It spawns a process to insert elements into the table and explores the potential values that can be returned when iterating over the table concurrently. Required dependencies include an Erlang environment capable of executing ETS operations. The key parameters are the table name (`Tab`), the spawned process (`P1`), and the iteration keys (`K1`, `K2`). Expected outputs are values for `K1` and `K2`, which illustrate the effects of concurrent insertions. The snippet highlights a potential inconsistency in iteration order due to concurrent modifications.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-01-07-ets-oddity.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n> Tab = ets:new(test_table,\n                [set, public, {write_concurrency, true}]).\n#Ref<0.1705802953.985792516.98626>\n> P1 = spawn(fun() ->\n               ets:insert(Tab, {fir, 1}),\n               ets:insert(Tab, {sec, 2})\n             end).\n> K1 = ets:first(Tab), K2 = ets:next(Tab, K1).\n```\n\n----------------------------------------\n\nTITLE: Testing Tuples in Erlang BEAM Code\nDESCRIPTION: Demonstrates the simplification of type tests in Erlang/OTP by verifying tuple types at runtime. The snippet shows how the Erlang compiler in OTP 24 checks if a variable is a tuple using a BEAM instruction, with considerations for runtime execution on both 32-bit and 64-bit architectures.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n{test,is_tuple,{f,3},[{x,0}]}\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with UTF-8 Encoded Binary Literal in Erlang\nDESCRIPTION: Corrects the `greek_quote/0` implementation by appending the `/utf8` suffix to the binary literal (`<<.../utf8>>`). This ensures the string content is correctly encoded as UTF-8 within the binary, allowing `io:format(\"~ts\\n\", [S])` to print it correctly while achieving memory savings.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_14\n\nLANGUAGE: erlang\nCODE:\n```\ngreek_quote() ->\n    S = <<\"\\\"Know thyself\\\" (Greek: Γνῶθι σαυτόν)\"/utf8>>,\n    io:format(\"~ts\\n\", [S]).\n```\n\n----------------------------------------\n\nTITLE: Function Arity Checking in Erlang\nDESCRIPTION: Example of function arity checking in Erlang code, demonstrating the pattern matching syntax for ensuring a function has zero arity.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_22\n\nLANGUAGE: erlang\nCODE:\n```\nensure_fun_0(F) when is_function(F, 0) -> ok.\n```\n\n----------------------------------------\n\nTITLE: Defining a Record Structure and Record Update Function in Erlang\nDESCRIPTION: An Erlang code snippet defining a record named 'rec' with a 'count' field and a function that increments this count field by 1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_15\n\nLANGUAGE: erlang\nCODE:\n```\n-record(rec, {count}).\n\nrec_add(R) ->\n    R#rec{count = R#rec.count + 1}.\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Pattern Matching in Erlang BEAM Instructions\nDESCRIPTION: BEAM instruction sequence that implements the core of an Erlang receive statement. It shows how messages are retrieved from the mailbox, tested against a pattern, and either processed or skipped. The code demonstrates loop structures, pattern matching, tuple manipulation, and message queue handling.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_10\n\nLANGUAGE: beam\nCODE:\n```\n{loop_rec,{f,19},{x,0}}.\n\n<em>%% Does it match our pattern? If not, jump to label 18\n%% and try the next message.</em>\n{test,is_tuple,{f,18},[{x,0}]}.\n{test,test_arity,{f,18},[{x,0},2]}.\n{get_tuple_element,{x,0},0,{x,1}}.\n{test,is_eq_exact,{f,18},[{x,1},{y,0}]}.\n\n<em>%% We've got a match, extract the result and remove\n%% the message from the mailbox.</em>\n{get_tuple_element,{x,0},1,{x,0}}.\nremove_message.\n{deallocate,1}.\nreturn.\n\n{label,18}.\n<em>%% The message didn't match, loop back to handle our\n%% next message. Note that the current message remains\n%% in the inbox since a different receive may be\n%% interested in it.</em>\n{loop_rec_end,{f,17}}.\n\n{label,19}.\n<em>%% Wait until the next message arrives, returning to\n%% the start of the loop when it does. If there's a\n%% timeout involved, it will be handled here.</em>\n{wait,{f,17}}.\n```\n\n----------------------------------------\n\nTITLE: Optimizing Named Fun Recursion in Erlang\nDESCRIPTION: Demonstrates the use of named funs for recursion, which is now optimized in OTP 22 to avoid creating new funs on each recursive call. This improves performance for recursive named funs.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-11-07-retired-pitfalls-22.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\ndeepfoldl(F, Acc0, L) ->\n    (fun NamedFun([_|_]=Elem, Acc) -> lists:foldl(NamedFun, Acc, Elem);\n         NamedFun([], Acc) -> Acc;\n         NamedFun(Elem, Acc) -> F(Elem, Acc)\n     end)(L, Acc0).\n```\n\n----------------------------------------\n\nTITLE: Fetching Signals from Outer Signal Queue Buffer Array in Erlang\nDESCRIPTION: Pseudocode algorithm for fetching signals from the outer signal queue buffer array and deactivating the optimization when necessary. It includes locking mechanisms, signal transfer, and adaptive optimization based on performance thresholds.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-11-05-parallel-signal-sending-optimization.md#2025-04-22_snippet_3\n\nLANGUAGE: pseudocode\nCODE:\n```\n1. Acquire the OuterSignalQueueLock\n2. For each non-empty slot in the buffer array:\n   1. Lock the slot\n   2. Append the signals in the slot to the end of OuterSignalQueue\n   3. Add the value of the slot's NumberOfEnqueues field to the\n      TotNumberOfEnqueues field in the OuterSignalQueueBufferArray\n   4. Reset the slot's BufferQueue and NumberOfEnqueues fields\n   5. Unlock the slot\n3. Increase the value of the NumberOfFlushes field in the\n   OuterSignalQueueBufferArray by one\n4. If the value of the NumberOfFlushes field has reached a certain\n   threshold T:\n   * Calculate the average number of enqueues per flush\n     (EnqPerFlush) during the last T flushes\n     (TotNumberOfEnqueues / T).\n      * If EnqPerFlush is below a certain threshold Q:\n         * Deactivate the parallel signal sending optimization:\n           1. For each slot in the OuterSignalQueueBufferArray:\n              1. Acquire the SlotLock\n              2. Append the signals in the slot (if any) to the end of OuterSignalQueue\n              3. Set the slot's IsAlive field to false\n              4. Release the SlotLock\n           2. Set the OuterSignalQueueBufferArray field in the process\n              structure to NULL\n           3. Schedule deallocation of the buffer array structure\n      * Else if the average is equal to or above the threshold Q:\n        * Set the NumberOfFlushes and the TotNumberOfEnqueues\n          fields in the buffer array struct to 0\n5. Append the OuterSignalQueue to the end of the InnerSignalQueue\n6. Reset the OuterSignalQueue\n7. Release the OuterSignalQueueLock\n```\n\n----------------------------------------\n\nTITLE: Generating Unoptimized BEAM Code from SSA\nDESCRIPTION: This snippet shows the unoptimized BEAM code generated from the SSA representation, demonstrating how phi instructions are translated into concrete BEAM instructions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\n%% Block 0.\n{select_val,{x,0},\n            {f,53},\n            {list,[{atom,something},{f,55},{atom,zero},{f,57}]}}.\n\n%% Block 5.\n{label,57}.\n  {move,{integer,0},{x,0}}.\n  {jump,{f,59}}.\n\n%% Block 6.\n{label,55}.\n  %% The result is already in {x,0}.\n  {jump,{f,59}}.\n\n%% Block 4.\n{label,53}.\n  {move,{atom,no_idea},{x,0}}.\n  {jump,{f,59}}.\n\n%% Block 3.\n{label,59}.\n   {test_heap,3,1}.\n   {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n   return.\n```\n\n----------------------------------------\n\nTITLE: Core Transform Using Record Matching in Erlang\nDESCRIPTION: This snippet demonstrates a core transform that uses record matching to retrieve the module name instead of using the cerl module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_13\n\nLANGUAGE: erlang\nCODE:\n```\n-module(my_core_transform).\n-export([core_transform/2]).\n\n-include_lib(\"compiler/src/core_parse.hrl\").\n\ncore_transform(Core, _Options) ->\n    #c_module{name=#c_literal{val=Module}} = Core,\n    io:format(\"Module name: ~p\\n\", [Module]),\n    io:format(\"Number of nodes in Core Erlang tree: ~p\\n\",\n              [cerl_trees:size(Core)]),\n    Core.\n```\n\n----------------------------------------\n\nTITLE: Configuring an Erlang Node as a Temporary Client\nDESCRIPTION: This Erlang command-line invocation shows the implied distribution flags when starting a node with a dynamic name (`-name undefined` or `-sname undefined`). The node starts without listening for incoming connections (`-dist_listen false`), hidden from normal discovery, and requires manual connection initiation (`-dist_auto_connect never`). This setup is optimized for temporary client nodes introduced in OTP 23.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\nerl -dist_listen false -hidden -dist_auto_connect never\n```\n\n----------------------------------------\n\nTITLE: Implementing Right Shift Operation in BEAM Assembly\nDESCRIPTION: Assembly code for the Erlang 'bsr 32' (bit shift right) operation translated to x86 'sar rax, 32' with proper handling for both small integers and fallback for other term types.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_10\n\nLANGUAGE: nasm\nCODE:\n```\n    mov rax, rsi\n    sar rax, 32\n    or rax, 15\n    short jmp L2272\nL2271:\n    mov eax, 527\n    call 140439031217336\nL2272:\n    mov qword ptr [rbx+8], rax\n# line_I\n```\n\n----------------------------------------\n\nTITLE: Checking JIT Compiler Status in Erlang\nDESCRIPTION: This snippet demonstrates how to verify if a JIT-enabled emulator is running using the erlang:system_info/1 function. It's useful for confirming the BeamAsm JIT-compiler's activation on supported platforms.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/147.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:system_info(emu_flavor).\n```\n\n----------------------------------------\n\nTITLE: Using Compiler Flags for Receive Optimization Info - Bash\nDESCRIPTION: Shows a shell invocation of the Erlang compiler plus its diagnostic output using the '+recv_opt_info' flag. This flag, introduced in OTP 24, emits warnings/comments that inform the programmer of which code regions are optimized for mailbox scanning. Requires Erlang/OTP 24, 'erlc', and a test file. The output indicates which lines and variables were involved in receive optimization, aiding developers in understanding and leveraging these compiler advancements.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc +recv_opt_info test.erl\ntest.erl:6: Warning: OPTIMIZED: reference used to mark\n                                a message queue position\n%    6|   Ref = make_ref(),\ntest.erl:12: Warning: OPTIMIZED: all clauses match reference\n                                 created by make_ref/0\n                                 at test.erl:6\n%   12|       receive\n```\n\n----------------------------------------\n\nTITLE: Deprecating erlang:get_stacktrace/0 in Erlang\nDESCRIPTION: Shows the deprecated erlang:get_stacktrace/0 function and its recommended replacement using a try-catch block with a stacktrace variable.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/122.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:get_stacktrace/0\n```\n\nLANGUAGE: erlang\nCODE:\n```\ntry ... catch C:R:Stacktrace -> ...\n```\n\n----------------------------------------\n\nTITLE: Executing a Function Returning a String in Erlang Shell\nDESCRIPTION: Demonstrates calling the `t:greek_quote/0` function in the Erlang shell and shows its expected output, which is a string containing Greek characters. This serves as the initial state before exploring memory optimization with binaries.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\n1> t:greek_quote().\n\"Know thyself\" (Greek: Γνῶθι σαυτόν)\nok\n```\n\n----------------------------------------\n\nTITLE: Eliminating Single-Clause Case in Core Erlang Optimization\nDESCRIPTION: This Core Erlang code shows the result after simplifying a `case` expression that has only one remaining clause. The `sys_core_fold` pass eliminates the `case` structure entirely, promoting the body of the single clause. This leads back to the simple `let` expression shown earlier.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\n'a'/0 =\n    fun () ->\n       let <A> = 42\n       in {'ok',A}\n```\n\n----------------------------------------\n\nTITLE: Is_Small_Integer Type Test - x86-64 Assembly\nDESCRIPTION: Implements the type testing of two operands for the Erlang 'small integer' tag, using bitwise operations. If either operand fails the small integer test (i.e., tag bits not all set), jumps to code handling generic types. Required in most low-level BEAM arithmetic or comparison operations where the term type is ambiguous. Relies on correct values in edi and esi.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_10\n\nLANGUAGE: nasm\nCODE:\n```\n    mov eax, edi\\n    and eax, esi\\n    and al, 15\\n    cmp al, 15\\n    short jne L39\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang Code with Improved Error Output in Bash\nDESCRIPTION: Example of compiling Erlang code in OTP 24, demonstrating the new error message format with column numbers and visual indicators.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc test.erl\nt.erl:6:16: only association operators '=>' are allowed in map construction\n%    6|   #{ a => A, b := B }.\n%     |                ^\n```\n\n----------------------------------------\n\nTITLE: Configuring Kernel TLS in SSL Application\nDESCRIPTION: Demonstrates how to enable Kernel TLS (kTLS) support in the SSL application using the {ktls, true} option for TLS distribution.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\n{ktls, true}\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang to Core Format - Command Example\nDESCRIPTION: Command to translate an Erlang module to Core Erlang code with compilation timing details.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-07-core-erlang-by-example.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc +time +to_core core_example.erl\n```\n\n----------------------------------------\n\nTITLE: Enabling Process Tracing in a Trace Session\nDESCRIPTION: This snippet enables call tracing on the current process within the created trace session. It uses the trace:process/4 function to specify which process to trace and what type of tracing to enable.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_45\n\nLANGUAGE: erlang\nCODE:\n```\ntrace:process(Session, self(), true, [call]).\n```\n\n----------------------------------------\n\nTITLE: Using ~b Sigil for Binary with Escapes in Erlang Shell\nDESCRIPTION: Shows the use of the `~b\"...\"` sigil in the Erlang shell. This creates a UTF-8 encoded binary, similar to `~B`, but it *does* interpret standard backslash escape sequences like `\\t` (tab). The `\"` character acts as both the start and end delimiter.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_16\n\nLANGUAGE: erlang\nCODE:\n```\n1> ~b\"abc\\txyz\".\n<<\"abc\\txyz\">>\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang with specific warnings enabled\nDESCRIPTION: Command to compile an Erlang module with warnings for missing specs enabled. This example is used to demonstrate the new compiler option precedence in OTP 27.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/168.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n% erlc +warn_missing_spec some_module.erl\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Numeric Literal Underscores in Erlang\nDESCRIPTION: Shows examples of using underscores in numeric literals to improve readability in Erlang OTP 23.0. This feature allows developers to group digits in large numbers for better visual parsing.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/136.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n123_456_789\n```\n\nLANGUAGE: erlang\nCODE:\n```\n16#1234_ABCD\n```\n\n----------------------------------------\n\nTITLE: Using Crypto Hash and Cipher Information Functions in Erlang\nDESCRIPTION: References the new crypto:hash_info/1 and crypto:cipher_info/1 functions that return maps with information about the specified hash or cipher algorithm.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/129.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nhash_info/1\n```\n\nLANGUAGE: erlang\nCODE:\n```\ncipher_info/1\n```\n\n----------------------------------------\n\nTITLE: Implementing the mwc59 PRNG Core Logic in Erlang\nDESCRIPTION: Provides the Erlang function definition for the `mwc59` generator. It takes a 59-bit state `CX`, splits it into a 32-bit lower part `C` (using bitwise AND) and a 27-bit upper part `X` (using bit shift right), and calculates the next 59-bit state using multiplication (with constant 16#7fa6502) and addition. This implementation is designed for speed and benefits from JIT optimizations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\nmwc59(CX) ->\n    C = CX band ((1 bsl 32)-1),\n    X = CX bsr 32,\n    16#7fa6502 * X + C.\n```\n\n----------------------------------------\n\nTITLE: Connecting to SSL Server in OTP 26 Without Certificate Verification\nDESCRIPTION: Example showing how OTP 26 rejects SSL connections with empty options due to the new default of verify_peer requiring CA certificates for verification.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_33\n\nLANGUAGE: erlang\nCODE:\n```\nErlang/OTP 26 . . .\n\nEshell V14.0 (press Ctrl+G to abort, type help(). for help)\n1> application:ensure_all_started(ssl).\n{ok,[crypto,asn1,public_key,ssl]}\n2> ssl:connect(\"www.erlang.org\", 443, []).\n{error,{options,incompatible,\n                [{verify,verify_peer},{cacerts,undefined}]}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Addition in BEAM Assembly with Overflow Check\nDESCRIPTION: Assembly code for the Erlang '+' operation that checks if both operands are small integers, performs addition with overflow checking, and includes a fallback path for handling non-small integers or overflow conditions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_13\n\nLANGUAGE: nasm\nCODE:\n```\n# i_plus_ssjd\n    mov rsi, qword ptr [rbx]\n    mov rdx, qword ptr [rbx+8]\n# are both operands small?\n    mov eax, esi\n    and eax, edx\n    and al, 15\n    cmp al, 15\n    short jne L2278\n# add with overflow check\n    mov rax, rsi\n    mov rcx, rdx\n    and rcx, -16\n    add rax, rcx\n    short jno L2277\nL2278:\n    call 140439031219296\nL2277:\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Configuring Message Queue Data Setting in Erlang\nDESCRIPTION: This code snippet shows how to configure a process with the {message_queue_data, off_heap} setting, which is required for the parallel signal sending optimization to be active.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-11-05-parallel-signal-sending-optimization.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{message_queue_data, off_heap}\n```\n\n----------------------------------------\n\nTITLE: Example of Map with Repeated Keys That Will Generate Warnings\nDESCRIPTION: Example of map syntax with repeated keys that will trigger compiler warnings in Erlang/OTP 20. The compiler will warn about the repeated key 'a'.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/113.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n#{'a'=>1, 'b'=>2, 'a'=>3}\n```\n\n----------------------------------------\n\nTITLE: Optimized Fun Environment Movement in x86_64 Assembly\nDESCRIPTION: Using AVX instructions to efficiently move two items of fun environment data. This optimization reduces the number of required instructions from four to two compared to Erlang/OTP 26.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_21\n\nLANGUAGE: x86_64\nCODE:\n```\nvmovups xmm0, xmmword ptr [rbx]\\nvmovups xmmword ptr [r15+16], xmm0\n```\n\n----------------------------------------\n\nTITLE: Starting Erlang Runtime with JIT Dump Enabled - Bash\nDESCRIPTION: This bash snippet launches the Erlang runtime system with the +JDdump flag set to true, which instructs the JIT to dump native code to files with a .asm extension for all loaded modules. Requires Erlang/OTP 26 (or compatible) with JIT enabled. Input: bash shell; Output: Native assembly dumps in the module directory. Dependency: installed Erlang system.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nerl +JDdump true\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom SSL Logger Formatter Function in Erlang\nDESCRIPTION: This Erlang code shows the `format/2` function implementation within the custom `ssl_logger` module. It receives a log event map (`#{level:= _, msg:= {report, Msg}, meta:= _}`) that has passed the handler's filters. It extracts the direction, protocol type, and message content from the `Msg` map. Based on the `Protocol` ('tls_record' or 'handshake'), it calls specific helper functions (`format_tls_record/2` or `format_handshake/2`) to generate the final formatted log string. Other protocol types are ignored.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\nformat(#{level:= _Level, msg:= {report, Msg}, meta:= _Meta},\n       _Config0) ->\n     #{direction := Direction,\n       protocol := Protocol,\n       message := BinMsg0} = Msg,\n    case Protocol of\n        'tls_record' ->\n            BinMsg = lists:flatten(BinMsg0),\n            format_tls_record(Direction, BinMsg);\n        'handshake' ->\n            format_handshake(Direction, BinMsg0);\n        _Other ->\n            []\n    end.\n```\n\n----------------------------------------\n\nTITLE: Erlang Socket Backend Configuration\nDESCRIPTION: Configuration option for using the experimental socket backend with gen_tcp and inet.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/139.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n{inet_backend, socket}\n```\n\n----------------------------------------\n\nTITLE: Defining Erlang Function with Parallel Matching Pattern\nDESCRIPTION: This Erlang function `b/2` demonstrates a common pattern where function arguments `A` and `B` are combined into a tuple `{A, B}` solely for pattern matching in a `case` expression. This pattern is often optimized to avoid unnecessary tuple creation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_14\n\nLANGUAGE: erlang\nCODE:\n```\nb(A, B) ->\n    case {A,B} of\n\t{true,false} -> ok;\n\t{false,true} -> not_ok;\n\t{_,_} -> error\n    end.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Variable Assignment in Erlang Case Statement\nDESCRIPTION: Presents an example Erlang function `bar/1` using a `case` statement to assign a value to variable `Y` based on the input `X`. This example is used to introduce the challenge of translating code with multiple assignment paths for the same variable into Static Single Assignment (SSA) form, which requires variables to be assigned only once.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\nbar(X) ->\n    case X of\n        none ->\n            Y = 0;\n        _ ->\n            Y = X\n    end,\n    Y + 1.\n```\n\n----------------------------------------\n\nTITLE: Erlang Function: Addition with Multiplicative Preprocessing\nDESCRIPTION: This Erlang function first multiplies X0 and Y0 by 2 before summing their results. Demonstrates propagation of type information from arithmetic operations in BEAM compilation, exploring how numerical types are tracked through multiple BIFs. Inputs must be numbers, outputs depend on BEAM arithmetic semantics.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_26\n\nLANGUAGE: erlang\nCODE:\n```\nadd2(X0, Y0) ->\\n    X = 2 * X0,\\n    Y = 2 * Y0,\\n    X + Y.\n```\n\n----------------------------------------\n\nTITLE: Using the NIF enif_term_type Function\nDESCRIPTION: References the new NIF function for getting the type of a term, which helps avoid sequences of enif_is_xyz calls in native code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/132.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\nenif_term_type\n```\n\n----------------------------------------\n\nTITLE: Reading Native Coverage Data for a Module\nDESCRIPTION: This snippet demonstrates how to read function coverage counters for a module when using the native coverage support feature. It retrieves, sorts and formats the coverage data for the init module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_49\n\nLANGUAGE: erlang\nCODE:\n```\nlists:reverse(lists:keysort(2, code:get_coverage(function, init))).\n```\n\n----------------------------------------\n\nTITLE: Building Dialyzer Persistent Lookup Table (PLT) via Command Line - Shell Command\nDESCRIPTION: This example demonstrates the creation of a Dialyzer PLT including the erts, kernel, and stdlib applications. The command is run in a terminal environment with all dependencies (dialyzer and Erlang/OTP) installed. Key parameters: '--build_plt' to build the PLT, '--apps' to specify which applications to include. Outputs a PLT file for improved dialyzer analysis speed. Limitations: Requires sufficient permissions and the specified applications to be present.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_8\n\nLANGUAGE: text\nCODE:\n```\ndialyzer --build_plt --apps erts kernel stdlib\n```\n\n----------------------------------------\n\nTITLE: Example Erlang Record with Function Updates\nDESCRIPTION: Erlang code showing record updates with function values (funs), which can be optimized when using literal functions since they are stored in a special literal area.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_19\n\nLANGUAGE: erlang\nCODE:\n```\n-record(state, {op, data}).\n\nupdate_state(R0, Op0, Data) ->\n    R = R0#state{data=Data},\n    case Op0 of\n        add -> R#state{op=fun erlang:'+'/2};\n        sub -> R#state{op=fun erlang:'-'/2}\n    end.\n```\n\n----------------------------------------\n\nTITLE: Using ~s Sigil for String Creation with Escapes and Custom Delimiters in Erlang Shell\nDESCRIPTION: Shows the `~s{...}` sigil used to create a standard Erlang string (list of integers), not a binary. It interprets escape sequences like `\\t` and allows using delimiters (`{` and `}`) other than double quotes, avoiding the need to escape quotes within the content.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_19\n\nLANGUAGE: erlang\nCODE:\n```\n3> ~s{\"abc\\txyz\"}.\n\"\\\"abc\\txyz\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Map Key Warning Example in Erlang\nDESCRIPTION: Example showing map syntax that will trigger the new compiler warning for repeated identical map keys in Erlang/OTP 20.0-rc1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/112.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n#{'a'=>1, 'b'=>2, 'a'=>3}\n```\n\n----------------------------------------\n\nTITLE: Map Declaration with Duplicate Keys in Erlang\nDESCRIPTION: Example showing map declaration syntax that will trigger warnings for duplicate keys in Erlang/OTP 20.0.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/114.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n#{'a'=>1, 'b'=>2, 'a'=>3}\n```\n\n----------------------------------------\n\nTITLE: Example Erlang Record Update Module\nDESCRIPTION: Erlang module demonstrating record updates with boolean values, which can be optimized by the JIT since boolean values are always atoms and thus safe for in-place updates.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_18\n\nLANGUAGE: erlang\nCODE:\n```\n-module(whatever).\n-export([main/1]).\n\n-record(bar, {bool,pid}).\n\nmain(Bool) when is_boolean(Bool) ->\n    flip_state(#bar{bool=Bool,pid=self()}).\n\nflip_state(R) ->\n    R#bar{bool=not R#bar.bool}.\n```\n\n----------------------------------------\n\nTITLE: Erlang Term to Binary Encoding Example\nDESCRIPTION: Example showing how atoms are encoded using erlang:term_to_binary/1 with UTF8 tags only for atoms containing unicode characters.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/114.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:term_to_binary/1\n```\n\n----------------------------------------\n\nTITLE: Implementing is_nonempty_list instruction in BEAM DSL\nDESCRIPTION: This snippet demonstrates the implementation of the is_nonempty_list instruction using a domain-specific language that extends C. It checks if the source is a non-empty list and handles failure cases.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-27-a-closer-look-at-the-interpreter.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nis_nonempty_list(Label, Src) {\n\n    /* Check if our $Src is not a list. */\n    if (is_not_list($Src)) {\n\n        /* Invoke the $FAIL macro, jumping to our\n         * $Label. */\n        $FAIL($Label);\n    }\n\n    /* Execute the next instruction. */\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiplication in BEAM Assembly with Overflow Check\nDESCRIPTION: Assembly code for the Erlang '*' operation that includes a test for small integers, overflow checking during multiplication, and a fallback path for handling non-small integers or overflow conditions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_12\n\nLANGUAGE: nasm\nCODE:\n```\n# line_I\n# i_times_jssd\n    mov rsi, qword ptr [rbx]\n    mov edx, 2141605935\n# is the operand small?\n    mov edi, esi\n    and edi, 15\n    cmp edi, 15\n    short jne L2276\n# mul with overflow check, imm RHS\n    mov rax, rsi\n    mov rcx, 133850370\n    and rax, -16\n    imul rax, rcx\n    short jo L2276\n    or rax, 15\n    short jmp L2275\nL2276:\n    call 140439031220000\nL2275:\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Empty Map Pattern Matching in Erlang\nDESCRIPTION: Example of pattern matching against an empty map, demonstrating the optimization of the =:= operator in Erlang/OTP 27.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_25\n\nLANGUAGE: erlang\nCODE:\n```\nensure_empty_map(Map) when Map =:= #{} ->\n    ok.\n```\n\n----------------------------------------\n\nTITLE: Printing String Result of Triple-Quoted Function - Erlang/io Module - Erlang\nDESCRIPTION: Demonstrates using io:format to print the string result from a function that returns a triple-quoted string, leveraging the ~ts format specifier to preserve unicode and internal formatting. Assumes `effect_warning/0` is available in module `t`. No extra dependencies are needed.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\n1> io:format(\"~ts\\n\", [t:effect_warning()]).\\nf() ->\\n    %% Test that the compiler warns for useless tuple building.\\n    {a,b,c},\\n    ok.\n```\n\n----------------------------------------\n\nTITLE: Core Erlang Representation After sys_core_alias Optimization\nDESCRIPTION: This snippet demonstrates the Core Erlang representation of the remove_even function after the sys_core_alias optimization has been applied, reusing existing tuples.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n'remove_even'/1 =\n    fun (_0) ->\n\tcase _0 of\n\t  <[_@r0 = {Key,Val}|T]> when 'true' ->\n\t      let <_1> =\n\t\t  call 'erlang':'rem'(Val, 2)\n\t      in\n\t\t  case <> of\n\t\t    <>\n\t\t\twhen call 'erlang':'=:='(_1, 0) ->\n\t\t\t    apply 'remove_even'/1(T)\n\t\t    <> when 'true' ->\n\t\t\tlet <_2> =\n\t\t\t    apply 'remove_even'/1(T)\n\t\t\tin\n\t\t\t    [_@r0|_2]          % REUSING EXISTING TUPLE\n\t\t  end\n\t  <[]> when 'true' ->\n\t      []\n\t  <_4> when 'true' ->\n\t\tprimop 'match_fail'({'function_clause',_4})\n\tend\n```\n\n----------------------------------------\n\nTITLE: Running Dialyzer PLT Build with perf Profiling in Bash\nDESCRIPTION: Command to run Dialyzer PLT build with perf profiling enabled. This method provides low-overhead profiling for performance analysis.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ ERL_FLAGS=\"+JPperf true\" perf record dialyzer --build_plt \\\n    --apps erts\n```\n\n----------------------------------------\n\nTITLE: Erlang Function: Simple Addition\nDESCRIPTION: Defines a basic addition function in Erlang, adding two arguments X and Y. No guard clauses or type annotations, intended to show how basic arithmetic is compiled and optimized. Inputs are general terms, behavior defined by BEAM's dynamic numeric handling.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_18\n\nLANGUAGE: erlang\nCODE:\n```\nadd1(X, Y) ->\\n    X + Y.\n```\n\n----------------------------------------\n\nTITLE: Defining a Release Structure in Reltool\nDESCRIPTION: Shows the new structure for defining releases in reltool configuration, which now supports an additional Opts element in the rel tuple format.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/128.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{rel, Name, Vsn, RelApps, Opts}\n```\n\n----------------------------------------\n\nTITLE: External Function Definitions in Erlang\nDESCRIPTION: Example showing different ways to create external function references in Erlang, demonstrating both static and dynamic function references.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_23\n\nLANGUAGE: erlang\nCODE:\n```\nmy_fun() ->\n    fun ?MODULE:some_function/0.\n\nmfa(M, F, A) ->\n    fun M:F/A.\n```\n\n----------------------------------------\n\nTITLE: Setting up a Custom SSL Logger Handler in Erlang\nDESCRIPTION: This Erlang function `start_logger/0` encapsulates the setup process for a custom logger handler dedicated to SSL messages. It defines the handler configuration (level, default filter action, custom formatter `ssl_logger`), creates a domain filter to only process logs from `[otp, ssl]`, adds the handler (`ssl_handler`) using `logger_std_h`, and then applies the domain filter to this handler.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\nstart_logger() ->\n    Config = #{level => debug,\n               filter_default => stop,\n               formatter => {ssl_logger, #{}}},\n    Filter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},\n    logger:add_handler(ssl_handler, logger_std_h, Config),\n    logger:add_handler_filter(ssl_handler, filter_non_ssl, Filter).\n```\n\n----------------------------------------\n\nTITLE: Performance Measurement Results\nDESCRIPTION: Benchmark results showing execution times for different RNG implementations in nanoseconds per generated number.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_23\n\nLANGUAGE: text\nCODE:\n```\nRNG uniform integer range 10000 performance\n                   exsss:     57.5 ns (warm-up)\n                overhead:      3.9 ns      6.8%\n                   exsss:     53.7 ns    100.0%\n                    exsp:     49.2 ns     91.7%\n         {mwc59,raw_mod}:      9.8 ns     18.2%\n       {mwc59,value_mod}:     18.8 ns     35.0%\n              {exsp,mod}:     22.5 ns     41.9%\n          {mwc59,raw_tm}:      3.5 ns      6.5%\n      {mwc59,value32_tm}:      8.0 ns     15.0%\n        {mwc59,value_tm}:     11.7 ns     21.8%\n               {exsp,tm}:     18.1 ns     33.7%\n           unique_phash2:     23.6 ns     44.0%\n             system_time:     30.7 ns     57.2%\n```\n\n----------------------------------------\n\nTITLE: Running Cover in Local-only Mode in Erlang\nDESCRIPTION: References the new cover:local_only/0 function that allows running Cover in a restricted but faster local-only mode, which can significantly improve performance for certain types of code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/129.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\ncover:local_only/0\n```\n\n----------------------------------------\n\nTITLE: Installing OTP 25-rc2 Using Kerl\nDESCRIPTION: Command to install Erlang/OTP 25.0-rc2 using the kerl tool, which helps manage multiple Erlang installations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/155.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkerl build 25.0-rc2 25.0-rc2\n```\n\n----------------------------------------\n\nTITLE: Improved Error Message for Certificate Verification in OTP 26\nDESCRIPTION: Example showing the clearer error message in OTP 26 when attempting to connect with verify_peer but no CA certificates, compared to the less clear message in OTP 25.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_37\n\nLANGUAGE: erlang\nCODE:\n```\n2> ssl:connect(\"www.erlang.org\", 443, []).\n{error,{options,incompatible,\n                [{verify,verify_peer},{cacerts,undefined}]}}\n```\n\n----------------------------------------\n\nTITLE: Expanding Records in Erlang Module\nDESCRIPTION: Shows the result of the expand_records pass, which translates record operations to tuple operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc -E +time trivial.erl\nCompiling \"trivial\"\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.002 s       5.5 kB\n expand_records                :      0.000 s       5.3 kB\n listing                       :      0.001 s       5.3 kB\n```\n\nLANGUAGE: erlang\nCODE:\n```\n$ cat trivial.E\n-file(\"trivial.erl\", 1).\n\n-module(trivial).\n\n-export([example/4]).\n\n-record(rec,{mod,func,result}).\n\nexample(A, B, C, D) ->\n    {rec,trivial,example,A + B * C * (D + 42)}.\n```\n\n----------------------------------------\n\nTITLE: Implementing Level-Aware Logging Helper Functions in Erlang\nDESCRIPTION: These Erlang functions, `debug/3` and `notice/2`, act as wrappers around the standard `?LOG_DEBUG` and `?LOG_NOTICE` macros. They take an explicit log `Level` parameter (intended to be the configured level for a specific TLS session) and compare it to the target level (`debug` or `notice`) using `logger:compare_levels/2`. The actual logging macro is only invoked if the provided `Level` is less than or equal to (i.e., more or equally verbose as) the target level, allowing for dynamic, per-session log level control.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\ndebug(Level, Report, Meta) ->\n    case logger:compare_levels(Level, debug) of\n        lt ->\n            ?LOG_DEBUG(Report, Meta);\n        eq ->\n            ?LOG_DEBUG(Report, Meta);\n        _ ->\n            ok\n    end.\n\nnotice(Level, Report) ->\n    case logger:compare_levels(Level, notice) of\n        lt ->\n            ?LOG_NOTICE(Report);\n        eq ->\n            ?LOG_NOTICE(Report);\n        _ ->\n            ok\n    end.\n```\n\n----------------------------------------\n\nTITLE: Using the New 'short' Option for Float Conversion in Erlang\nDESCRIPTION: An Erlang code example showing the property guaranteed by the new 'short' option for float_to_list, which creates the shortest string representation that can be converted back to the same float.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_18\n\nLANGUAGE: erlang\nCODE:\n```\nF =:= list_to_float(float_to_list(F, [short]))\n```\n\n----------------------------------------\n\nTITLE: BEAM Code for Sequential Record Updates (Pre-OTP 27)\nDESCRIPTION: This BEAM assembly code corresponds to the sequential record updates in the previous Erlang example, as generated by compilers prior to Erlang/OTP 27. It shows three separate `update_record` instructions, each potentially involving copying the record data.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_3\n\nLANGUAGE: beam\nCODE:\n```\n{update_record,{atom,reuse},\n               6,\n               {literal,{foo,undefined,undefined,undefined,undefined,\n                             undefined}},\n               {x,0},\n               {list,[2,{x,0}]}}.\n{update_record,{atom,copy},6,{x,0},{x,0},{list,[3,{integer,2}]}}.\n{update_record,{atom,copy},6,{x,0},{x,0},{list,[4,{integer,3}]}}.\n```\n\n----------------------------------------\n\nTITLE: Introducing try...catch in Erlang\nDESCRIPTION: This snippet mentions the introduction of try...catch exception handling in Erlang OTP R10, which was a contribution from the HiPE project.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-12-01-the-road-to-the-jit.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ntry\n    % Code that may raise an exception\ncatch\n    % Exception handling code\nend\n```\n\n----------------------------------------\n\nTITLE: Erlang Function: Integer Less-Than Guarded by Type Checks\nDESCRIPTION: Defines an Erlang function with input guard clauses ensuring both operands are integers before attempting a less-than operation. Intended for safe, type-constrained comparison in Erlang source. Inputs are A and B (expected to be integers); no explicit output value in snippet as the body is omitted.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_12\n\nLANGUAGE: erlang\nCODE:\n```\nmy_less_than(A, B) when is_integer(A), is_integer(B) ->\\n    .\\n    .\\n    .\n```\n\n----------------------------------------\n\nTITLE: Dialyzer Configuration with Warning Options in Erlang\nDESCRIPTION: Further enhanced dialyzer.config that adds a warnings option to enable unmatched_returns warnings. This configuration demonstrates how to customize the warning behavior of Dialyzer.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_25\n\nLANGUAGE: erlang\nCODE:\n```\n{incremental,\n {default_apps, [erts,kernel,stdlib,compiler,crypto,tools,syntax_tools]},\n {default_warning_apps, [proper]}\n}.\n{warnings, [unmatched_returns]}.\n{add_pathsa, [\"/Users/bjorng/git/proper/_build/default/lib/proper\"]}.\n```\n\n----------------------------------------\n\nTITLE: Profiling Dialyzer PLT Build with eprof in Erlang\nDESCRIPTION: Example of using eprof to profile the building of a Dialyzer PLT for the erts application. This method increases execution time significantly but provides detailed function call statistics.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n> eprof:profile(fun() ->\n    dialyzer:run([{analysis_type,'plt_build'},{apps,[erts]}])\n  end).\n```\n\n----------------------------------------\n\nTITLE: Unoptimized Core Erlang for Tuple Return and Match\nDESCRIPTION: This unoptimized Core Erlang translation of `c/1` shows the tuple creation within each clause of the inner `case`. The result of this `case` (a tuple) is bound to `_@c2`. Then, another `case` is used to match `_@c2` against `<{A, B}>` to extract the values before calling `erlang:'+'`. This involves redundant tuple building and matching.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_18\n\nLANGUAGE: erlang\nCODE:\n```\n'c'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <X> when 'true' ->\n\t      let <_@c2> =\n\t\t  case X of\n\t\t    <'a1'> when 'true' ->\n\t\t\t{10,1}\n\t\t    <'b2'> when 'true' ->\n\t\t\t{20,2}\n\t\t    <_@c5> when 'true' ->\n\t\t\t{100,42}\n\t\t    <_@c1> when 'true' ->\n\t\t\t  primop 'match_fail'({'case_clause',_@c1})\n\t\t  end\n\t      in\n\t\t  case _@c2 of\n\t\t    <{A,B}> when 'true' ->\n\t\t\tcall 'erlang':'+'(A, B)\n\t\t    <_@c3> when 'true' ->\n\t\t\t  primop 'match_fail'({'badmatch',_@c3})\n\t\t  end\n\t  <_@c4> when 'true' ->\n\t\t  primop 'match_fail'({'function_clause',_@c4})\n\tend\n```\n\n----------------------------------------\n\nTITLE: Defining and Updating a Record in Erlang\nDESCRIPTION: This snippet defines a record and a function that updates two elements of the record, which will be translated to tuple operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_10\n\nLANGUAGE: erlang\nCODE:\n```\n-record(rec, {a,b,c,d,e,f,g,h}).\n\nupdate_record(R) ->\n    R#rec{a=x,b=y}.\n```\n\n----------------------------------------\n\nTITLE: Simplifying Core Erlang Case by Removing Non-Matching Clauses\nDESCRIPTION: This Core Erlang snippet shows the `aa/0` function after `sys_core_fold` analyzes the `case` clauses against the constant expression `{'a','tuple'}`. The first clause (list match) cannot match and is dropped. The second clause (tuple match) always matches, so subsequent clauses are dropped, leaving only the matching tuple clause.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_10\n\nLANGUAGE: erlang\nCODE:\n```\n'aa'/0 =\n    fun () ->\n      case {'a','tuple'} of\n\t<{A,B}> when 'true' ->\n\t    {'tuple',A,B}\n      end\n```\n\n----------------------------------------\n\nTITLE: Running Erlang escript binary - Shell\nDESCRIPTION: This shell command executes the 'mylib' binary generated by rebar3. Assumes the build step has been completed and the file exists at '_build/default/bin/mylib'. No additional dependencies beyond the compiled script; input is a standard shell environment. Output is determined by the escript program logic. Useful for easily testing or deploying escript binaries.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_scripts/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ _build/default/bin/mylib\n```\n\n----------------------------------------\n\nTITLE: Invoking a Custom Debug Logging Function in Erlang\nDESCRIPTION: This Erlang code snippet demonstrates how to use the custom `ssl_logger:debug/3` helper function (defined previously) to log a debug message. It passes the current session's configured log level (`Opts#ssl_options.log_level`), the log message content (`Report`), and metadata including the specific logging domain `[otp, ssl, handshake]`. This allows the helper function to decide whether to actually log the message based on the session's level.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\nssl_logger:debug(Opts#ssl_options.log_level,\n\t         Report,\n\t\t #{domain => [otp,ssl,handshake]}),\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang/OTP 28.0-rc2 using kerl\nDESCRIPTION: Command to build Erlang/OTP 28.0-rc2 using the kerl version manager. This allows installation of the release candidate for testing and evaluation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/177.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkerl build 28.0-rc2 28.0-rc2.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Underscores in Numeric Literals in Erlang\nDESCRIPTION: Example of using underscores to improve readability of numeric literals in Erlang, a new feature in OTP 23.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/23.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n123_456_789\n```\n\nLANGUAGE: erlang\nCODE:\n```\n16#1234_ABCD\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Tuple Creation Function in Erlang\nDESCRIPTION: This Erlang code defines a function `create_tuple/1` that takes one argument `Term` and returns a two-element tuple `{hello, Term}`. This serves as a basic example for demonstrating how terms are constructed in BEAM.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\ncreate_tuple(Term) ->\n    {hello, Term}.\n```\n\n----------------------------------------\n\nTITLE: Using Dialyzer's New Incremental Mode in Erlang OTP 26\nDESCRIPTION: Demonstrates the new incremental mode for Dialyzer introduced in OTP 26 which speeds up analysis when only small changes have been made to the codebase. It tracks dependencies between modules and only re-analyzes what's needed.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_17\n\nLANGUAGE: erlang\nCODE:\n```\n$ dialyzer --incremental --apps erts kernel stdlib compiler crypto --warning_apps stdlib\nProceeding with incremental analysis... done in 0m14.91s\ndone (passed successfully)\n```\n\nLANGUAGE: erlang\nCODE:\n```\n$ dialyzer --incremental --warning_apps stdlib --apps erts kernel stdlib compiler crypto\ndone (passed successfully)\n```\n\nLANGUAGE: erlang\nCODE:\n```\n$ dialyzer --incremental --warning_apps stdlib --apps erts kernel stdlib compiler crypto\nThere have been changes to analyze\n    Of the 270 files being tracked, 1 have been changed or removed,\n    resulting in 270 requiring analysis because they depend on those changes\nProceeding with incremental analysis... done in 0m14.95s\ndone (passed successfully)\n```\n\nLANGUAGE: erlang\nCODE:\n```\n$ dialyzer --incremental --warning_apps stdlib --apps erts kernel stdlib compiler crypto\nThere have been changes to analyze\n    Of the 270 files being tracked, 1 have been changed or removed,\n    resulting in 3 requiring analysis because they depend on those changes\nProceeding with incremental analysis... done in 0m1.07s\ndone (passed successfully)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Byte Representation of Non-UTF-8 Binary in Erlang Shell\nDESCRIPTION: Shows how the Erlang shell evaluates a binary literal containing Greek characters (`Γνῶθι`) without the `/utf8` flag. It results in a binary containing the raw byte values corresponding to the default (likely Latin-1) encoding of those characters, demonstrating the underlying byte sequence.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_12\n\nLANGUAGE: erlang\nCODE:\n```\n1> <<\"Γνῶθι\">>.\n<<147,189,246,184,185>>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Active N Socket Option in Erlang\nDESCRIPTION: The {active, N} socket option has been introduced for TCP, UDP, and SCTP in Erlang/OTP 17. This allows for more fine-grained control over socket message delivery.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/17.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{active, N}\n```\n\n----------------------------------------\n\nTITLE: BEAM Bytecode for Addition with Type Propagation\nDESCRIPTION: Shows BEAM bytecode where multiplication propagates numeric types to subsequent addition, showing how BIFs type-constrain following operations. Useful for illustration of type-driven optimization barriers in Erlang JIT.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_27\n\nLANGUAGE: \nCODE:\n```\n    {gc_bif,'*',{f,0},2,[{x,0},{integer,2}],{x,0}}.\n    {gc_bif,'*',{f,0},2,[{x,1},{integer,2}],{x,1}}.\n    {gc_bif,'+',{f,0},2,[{tr,{x,0},number},{tr,{x,1},number}],{x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Time Warp Improvements for Debugging in Erlang/OTP 18.3\nDESCRIPTION: New time warp improvements in Erlang/OTP 18.3 for debugging and tracing with monotonic timestamps. These functions enable more precise timing for trace events.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/101.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ndbg:p/2\n```\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:trace/3\n```\n\n----------------------------------------\n\nTITLE: JIT Optimized Range Check Implementation\nDESCRIPTION: Assembly code generated by the JIT for the combined range check (10 ≤ A < 100). Shows optimizations including register reuse and skipping unnecessary operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_18\n\nLANGUAGE: nasm\nCODE:\n```\n# is_in_range_ffScc\n# simplified fetching of BEAM register\n    mov rdi, rax\n# skipped test for small operand since it always small\n    sub rdi, 175\n    cmp rdi, 1424\n    ja label_43\n```\n\n----------------------------------------\n\nTITLE: Erlang Guard Expression Example - Binary Size Matching\nDESCRIPTION: Example demonstrating the new EEP-52 feature allowing guard expressions in binary size matching.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/139.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n123_456_789\n```\n\nLANGUAGE: erlang\nCODE:\n```\n16#1234_ABCD\n```\n\n----------------------------------------\n\nTITLE: Using tprof for memory consumption profiling\nDESCRIPTION: Example of using the tprof module with call_memory type to measure memory consumed by each function call, a feature introduced in the runtime system in OTP 26 but first exposed through tprof.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_42\n\nLANGUAGE: erlang\nCODE:\n```\ntprof:profile(lists, seq, [1, 1000], #{type => call_memory}).\n```\n\n----------------------------------------\n\nTITLE: Defining Erlang Function Returning and Matching a Tuple\nDESCRIPTION: This Erlang function `c/1` demonstrates another common pattern where a `case` expression returns a tuple, which is immediately destructured using pattern matching (`{A, B} = ...`). The components `A` and `B` are then used in a subsequent operation (`A + B`).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_17\n\nLANGUAGE: erlang\nCODE:\n```\nc(X) ->\n    {A,B} = case X of\n\t\ta1 -> {10,1};\n\t\tb2 -> {20,2};\n\t\t_ ->  {100,42}\n\t    end,\n    A+B.\n```\n\n----------------------------------------\n\nTITLE: Single Xorshift Scrambler Implementation in Erlang\nDESCRIPTION: Basic implementation of a single Xorshift scrambler using bitwise operations. Uses a shift constant of 8 that passes 4 TB in PractRand and BigCrush tests.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_19\n\nLANGUAGE: erlang\nCODE:\n```\nV = T bxor (T bsl Shift)\n```\n\n----------------------------------------\n\nTITLE: URI String Quote/Unquote Function Example\nDESCRIPTION: New URI string manipulation functions that replace deprecated http_uri functions\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/153.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nuri_string:quote/1\nuri_string:unquote/1\n```\n\n----------------------------------------\n\nTITLE: Querying Carrier Information in Erlang/OTP 21\nDESCRIPTION: Example of using instrument:carriers() to get information about memory carriers, including their size, allocation count, and fragmentation status. The output shows different allocator types (ll_alloc, binary_alloc, eheap_alloc, fix_alloc) with their respective memory statistics.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-02-Memory-instrumentation-in-OTP-21.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n1> instrument:carriers().\n{ok,{512,\n     [{ll_alloc,1048576,0,1048344,71,false,{0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n      {binary_alloc,1048576,0,324640,13,false,{3,0,0,1,0,0,0,2,0,0,0,0,0,0}},\n      {eheap_alloc,2097152,0,1037200,45,false,{2,1,1,3,4,3,2,2,0,0,0,0,0,0}},\n      {fix_alloc,32768,0,29544,82,false,{22,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n      {...}|...]}}\n```\n\n----------------------------------------\n\nTITLE: Less Clear Error Message in OTP 25 for Certificate Verification\nDESCRIPTION: Example showing the less clear error message in OTP 25 when attempting to connect with verify_peer but no CA certificates.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_38\n\nLANGUAGE: erlang\nCODE:\n```\n2> ssl:connect(\"www.erlang.org\", 443, [{verify,verify_peer}]).\n{error,{options,{cacertfile,[]}}}\n```\n\n----------------------------------------\n\nTITLE: Binary Segment Size Validation in Assembly\nDESCRIPTION: Native code implementation for ensuring exact binary segment size and reading 32-bit segments.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_27\n\nLANGUAGE: nasm\nCODE:\n```\n# i_bs_match_fS\n# ensure_exactly 32\n    mov rsi, qword ptr [rbx+8]\n    mov rax, qword ptr [rsi+30]\n    mov rcx, qword ptr [rsi+22]\n    sub rax, rcx\n    cmp rax, 32\n    jne label_3\n# read 32\n    mov rdi, qword ptr [rsi+14]\n    add qword ptr [rsi+22], 32\n    mov rax, rcx\n    shr rax, 3\n    add rdi, rax\n    and ecx, 7\n    jnz L38\n    movbe edx, dword ptr [rdi]\n    add ecx, 32\n    short jmp L40\nL38:\n    mov rdx, qword ptr [rdi-3]\n    shr rdx, 24\n    bswap rdx\nL40:\n    shl rdx, cl\n```\n\n----------------------------------------\n\nTITLE: Core Erlang Representation of update_tuple After sys_core_dsetel Optimization\nDESCRIPTION: This snippet demonstrates the Core Erlang representation of the update_tuple function after the sys_core_dsetel optimization, using the dsetelement primop.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\n'update_tuple'/1 =\n    fun (_0) ->\n\tlet <T> =\n\t    call 'erlang':'setelement'(3, _0, 'y')\n\tin  do\n\t\tprimop 'dsetelement'(2, T, 'x')\n\t\tT\n```\n\n----------------------------------------\n\nTITLE: Erlang Function for Map Size and Range Check\nDESCRIPTION: An Erlang function that checks if a map's size is between 10 and 99, and adds 6 to the size if condition is met. Used to demonstrate JIT optimization capabilities in OTP 26.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_16\n\nLANGUAGE: erlang\nCODE:\n```\nadd6(M) when is_map(M) ->\n    A = map_size(M),\n    if\n        9 < A, A < 100 ->\n            A + 6\n    end.\n```\n\n----------------------------------------\n\nTITLE: Running Dialyzer with Enhanced PropER Configuration in Erlang\nDESCRIPTION: Output from running Dialyzer with the updated PropER configuration that includes tools and syntax_tools. This run shows no more warnings as the previously unknown functions are now recognized.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n$ dialyzer --incremental\nThere have been changes to analyze\n    Of the 319 files being tracked,\n    23 have been changed or removed,\n    resulting in 38 requiring analysis because they depend on those changes\nProceeding with incremental analysis... done in 0m6.47s\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang 28.0-rc1 using kerl\nDESCRIPTION: Command to build Erlang/OTP 28.0-rc1 using the kerl version manager tool\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/174.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nkerl build 28.0-rc1 28.0-rc1.\n```\n\n----------------------------------------\n\nTITLE: Binary Swap Function in Erlang\nDESCRIPTION: This Erlang function demonstrates binary pattern matching and construction. It swaps the first 8 bits with the next 24 bits in a binary.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_23\n\nLANGUAGE: erlang\nCODE:\n```\nbin_swap(<<A:8,B:24>>) ->\n    <<B:24,A:8>>.\n```\n\n----------------------------------------\n\nTITLE: Compiler Feature Enable Flag\nDESCRIPTION: Compiler option to enable the new maybe expression feature as proposed in EEP-49\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/153.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n{enable_feature,maybe_expr}\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang to Core Erlang Listing (Shell)\nDESCRIPTION: This shell command uses the Erlang compiler (`erlc`) to compile an Erlang file (`core_fold_example.erl`) and generate a Core Erlang listing before optimizations. The `+time` option displays compilation pass times, and `+dcore` creates a `.core` file containing the initial Core Erlang code produced by the `v3_core` module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ erlc +time +dcore core_fold_example.erl\nCompiling \"core_fold_example\"\n parse_module                  :      0.000 s       9.4 kB\n transform_module              :      0.000 s       9.4 kB\n lint_module                   :      0.005 s       9.4 kB\n expand_records                :      0.000 s       9.4 kB\n core                          :      0.000 s      59.3 kB\n listing                       :      0.003 s      59.3 kB\n```\n\n----------------------------------------\n\nTITLE: Defining a Binary Construction Function in Erlang\nDESCRIPTION: An Erlang function demonstrating binary construction with the bit syntax, using various segment types (float, binary, integer) with size specifications.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_14\n\nLANGUAGE: erlang\nCODE:\n```\nbin(A, B, C, D) ->\n    <<A/float,B:4/binary,C:16,D/binary>>.\n```\n\n----------------------------------------\n\nTITLE: New NIF API I/O Queue Functions in Erlang\nDESCRIPTION: Lists the new NIF API functions for managing an I/O Queue, including creation, destruction, enqueuing, dequeuing, and inspection operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/115.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nenif_ioq_create(), enif_ioq_destroy(), enif_ioq_enq_binary(), enif_ioq_enqv(), enif_ioq_deq(), enif_ioq_peek(), enif_inspect_iovec(), enif_free_iovec()\n```\n\n----------------------------------------\n\nTITLE: Binary Construction Implementation in Assembly\nDESCRIPTION: Complete native code implementation for binary construction, including heap allocation and segment value combination.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_29\n\nLANGUAGE: nasm\nCODE:\n```\n# i_bs_create_bin_jItd\n# allocate heap binary\n    lea rdx, qword ptr [r15+56]\n    cmp rdx, rsp\n    short jbe L43\n    mov ecx, 4\n.db 0x90\n    call 4343630296\nL43:\n    lea rax, qword ptr [r15+2]\n    mov qword ptr [rbx-120], rax\n    mov qword ptr [r15], 164\n    mov qword ptr [r15+8], 4\n    add r15, 16\n    mov qword ptr [rbx-64], r15\n    mov qword ptr [rbx-56], 0\n    add r15, 8\n# accumulate value for integer segment\n    xor r8d, r8d\n    mov rdi, qword ptr [rbx+24]\n    sar rdi, 4\n    or r8, rdi\n# accumulate value for integer segment\n    shl r8, 8\n    mov rdi, qword ptr [rbx+16]\n    sar rdi, 4\n    or r8, rdi\n# construct integer segment from accumulator\n    bswap r8d\n    mov rdi, qword ptr [rbx-64]\n    mov qword ptr [rbx-56], 32\n    mov dword ptr [rdi], r8d\n```\n\n----------------------------------------\n\nTITLE: Erlang Typed Register Representation in BEAM Code\nDESCRIPTION: Explains the representation of typed registers in Erlang BEAM code, such as using union types for enhanced native JIT compilation. The focus is on Erlang's internal type manipulation through OTP 25's compiler optimizations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n'error' | {'ok', integer()}\n```\n\n----------------------------------------\n\nTITLE: Binary List Generation in Erlang\nDESCRIPTION: Function that demonstrates accumulating intermediate binary values in a list, showing why the append operation needs extra overhead for correctness.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_31\n\nLANGUAGE: erlang\nCODE:\n```\nbins(Bin) ->\n    bins(Bin, <<>>).\n\nbins(<<H,T/binary>>, Acc) ->\n    [Acc|bins(T, <<Acc/binary,H>>)];\nbins(<<>>, Acc) ->\n    [Acc].\n```\n\n----------------------------------------\n\nTITLE: Safe Heap Check for Record Updates in Erlang JIT (x86_64 Assembly)\nDESCRIPTION: Assembly code that tests whether a tuple is in the safe part of the Erlang heap for in-place updates, considering the generational garbage collector constraints.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_12\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\n    mov rdi, [r13+480]     ; Get the high water mark\n    cmp rax, r15           ; Compare tuple pointer to heap top\n    short jae L39          ; Jump and copy if above\n    cmp rax, rdi           ; Compare tuple pointer to high water\n    short jae L38          ; Jump and overwrite if above high water\n```\n\n----------------------------------------\n\nTITLE: Using Lock Counting Runtime Mask in Erlang\nDESCRIPTION: Example of using the lcnt:rt_mask/1 function to toggle lock counting profiling at runtime, which allows specific categories to be enabled or disabled with minimal runtime overhead when disabled.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/115.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nlcnt:rt_mask/1\n```\n\n----------------------------------------\n\nTITLE: Compiler Tuple Call Optimization Example - Erlang\nDESCRIPTION: Demonstrates the new compiler optimization where tuple calls are automatically rewritten to reduce code size, execution time, and garbage collection pressure.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/123.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nf({ok, Val}) -> {ok, Val}\n```\n\nLANGUAGE: erlang\nCODE:\n```\nf({ok, Val} = Tuple) -> Tuple\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Function in Erlang and Core Erlang\nDESCRIPTION: Demonstration of pattern matching with multiple clauses in Core Erlang using case expressions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-07-core-erlang-by-example.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\na(42) -> ok;\na(_) -> error.\n```\n\nLANGUAGE: erlang\nCODE:\n```\n'a'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <42> when 'true' ->\n\t      'ok'\n\t  <_@c2> when 'true' ->\n\t      'error'\n\tend\n```\n\n----------------------------------------\n\nTITLE: Shifting Bits for Power-of-2 Range in Erlang\nDESCRIPTION: Shows how to get a random number `V` within a power-of-2 range by right-shifting (`bsr`) the generated value `X`. The shift amount is calculated based on the generator's total bits (`GeneratorBits`) and the desired range bits (`RangeBits`). This method is suitable if the generator's higher bits are stronger.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nV = X bsr (GeneratorBits - RangeBits).\n```\n\n----------------------------------------\n\nTITLE: Implementing remove_even Function in Erlang\nDESCRIPTION: This code snippet demonstrates a function that removes even-valued elements from a list of key-value pairs. It's used to illustrate the sys_core_alias optimization.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nremove_even([{Key,Val}|T]) ->\n    case Val rem 2 =:= 0 of\n        true -> remove_even(T);\n        false ->  [{Key,Val}|remove_even(T)]\n    end;\nremove_even([]) -> [].\n```\n\n----------------------------------------\n\nTITLE: Example Erlang Function Closure Creation\nDESCRIPTION: Erlang code demonstrating the creation of a function closure (fun) that captures variables from its environment, which has been optimized in Erlang/OTP 27.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_20\n\nLANGUAGE: erlang\nCODE:\n```\nmadd(A, C) ->\n    fun(B) -> A * B + C end.\n```\n\n----------------------------------------\n\nTITLE: Printing Maps in OTP 25 and Earlier: Atom Key Order - Erlang\nDESCRIPTION: Examines map key ordering for maps with atom keys in Erlang/OTP 25 and earlier, showing that printed and to_list order follows the term order of keys. The map is defined and displayed, then converted to a list of key-value pairs. Demonstrates old behavior for comparison with newer OTP versions. No dependencies beyond the Erlang REPL.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n1> AM = #{a => 1, b => 2, c => 3}.\n#{a => 1,b => 2,c => 3}\n2> maps:to_list(AM).\n[{a,1},{b,2},{c,3}]\n```\n\n----------------------------------------\n\nTITLE: Simple Erlang Function Definition\nDESCRIPTION: Example function that pattern matches a tuple and returns a new tuple with some elements\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-8-24-opt-traps-and-pitfalls.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nfoo({tag,A,_,_}) ->\n    {ok,A}.\n```\n\n----------------------------------------\n\nTITLE: Final Optimized SSA Code in Erlang\nDESCRIPTION: This snippet shows the final optimized SSA code after running a pass that merges blocks. It represents the most compact form of the function after all optimization passes.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n  br @ssa_bool:6, label 5, label 3\n\n5:\n  _7 = get_tuple_element _0, literal 1\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Record Update for Safe Values in Erlang JIT (x86_64 Assembly)\nDESCRIPTION: Optimized assembly code for updating records when all new values are known to be safe (atoms, literals, etc.), eliminating the need for copy fallback logic.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_15\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\n# update_record_in_place_IsdI\n    mov rax, qword ptr [rbx]\n# skipped copy fallback because all new values are safe\n    mov rdi, qword ptr [rbx+8]\n    mov qword ptr [rax+14], rdi\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Initializing TLSv1.3 Server in Erlang OTP 22\nDESCRIPTION: This code demonstrates how to start a TLSv1.3 server using the ssl module in OTP 22, including setting up certificate options and enabling debug logging.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-5-13-OTP-22-Highlights.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nLOpts = [{certfile, \"tls_server_cert.pem\"},\n\t     {keyfile, \"tls_server_key.pem\"},\n\t     {versions, ['tlsv1.3']},\n\t     {log_level, debug}\n\t    ],\n{ok, LSock} = ssl:listen(8443, LOpts),\n{ok, CSock} = ssl:transport_accept(LSock),\n{ok, S} = ssl:handshake(CSock).\n```\n\n----------------------------------------\n\nTITLE: Attaching perf to Already Running Erlang Node by PID - Shell Command\nDESCRIPTION: This code shows how to obtain a PID from a running Erlang node (using 'erl +JPperf true'), then attach perf to profile that specific process via PID. The user must supply the correct PID (e.g., 4711), and sudo may be necessary for permissions. The output includes a profile of the attached process' performance characteristics. Prerequisites: perf installed, Erlang node running, and user permissions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n# start Erlang at get the Pid\nerl +JPperf true\n```\n\nLANGUAGE: text\nCODE:\n```\nsudo perf record --call-graph fp -p 4711\n```\n\n----------------------------------------\n\nTITLE: Complex Bit-Syntax Matching Optimization in Erlang\nDESCRIPTION: Shows a more complex example of bit-syntax matching from the 'string' module, demonstrating how OTP 22 can now optimize cases with lookahead and maintain correct binary representations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-11-07-retired-pitfalls-22.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nbin_search_inv_1(<<CP1/utf8, BinRest/binary>>=Bin0, Cont, Sep) ->\n    case BinRest of\n        %% 1\n        <<CP2/utf8, _/binary>> when ?ASCII_LIST(CP1, CP2) ->\n            case CP1 of\n                Sep ->\n                    %% 2\n                    bin_search_inv_1(BinRest, Cont, Sep);\n                _ ->\n                    %% 3\n                    [Bin0|Cont]\n            end;\n        %% ... snip ...\n```\n\n----------------------------------------\n\nTITLE: Invoking the v1 Erlang Compiler (OTP R6)\nDESCRIPTION: This shell command demonstrates how to compile an Erlang module (`some_module.erl`) using the older `v1` compiler in OTP R6. The `+v1` flag explicitly selects this compiler version, which was the battle-tested original BEAM compiler, kept as an option for migration stability when the new `v2` compiler (Robert Virding's compiler with Kernel Erlang) became the default.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-6-18-beam-compiler-history.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ erlc +v1 some_module.erl\n```\n\n----------------------------------------\n\nTITLE: Case expression with exception handling in Erlang\nDESCRIPTION: This example demonstrates a case expression that throws an exception for unmatched patterns. It shows how exception handling is implemented in SSA and BEAM code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\ncase2(X) ->\n    case X of\n        1 -> a;\n        2 -> b;\n        3 -> c\n    end.\n```\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:case2(_0) {\n0:\n  switch _0, label 3, [ { literal 3, label 6 }, { literal 2, label 5 }, { literal 1, label 4 } ]\n\n4:\n  ret literal a\n\n5:\n  ret literal b\n\n6:\n  ret literal c\n\n3:\n  _2 = put_tuple literal case_clause, _0\n\n  %% blog.erl:20\n  @ssa_ret:7 = call remote (literal erlang):(literal error)/1, _2\n  ret @ssa_ret:7\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Erlang with Lock Counter Support\nDESCRIPTION: Command for enabling lock counting support during Erlang/OTP compilation. This builds an additional emulator with lock counting capabilities that can be started with a specific flag.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/113.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --enable-lock-counter\n```\n\n----------------------------------------\n\nTITLE: Sample Erlang TLS Debug Log Output\nDESCRIPTION: This text shows an example of the verbose debug log output generated by the Erlang TLS server when `log_level` is set to `debug`. It displays the raw bytes of the received TLS Record Protocol messages in hexadecimal and ASCII, followed by the parsed Erlang representation of the Handshake Protocol messages (e.g., ClientHello), including details like client version, random bytes, session ID, cipher suites, and extensions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n1> ssltest:server().\nreading (238 bytes) TLS 1.2 Record Protocol, handshake\n0000 - 16 03 03 00 e9 01 00 00  e5 03 03 5b ab 42 7a ee    ...........[.Bz.\n0010 - 91 23 df 70 30 fb 41 b9  c5 14 79 d7 02 48 74 c9    .#.p0.A...y..Ht.\n0020 - b9 a9 8f e0 e9 04 1a f9  a8 21 49 00 00 4a 00 ff    .........!I..J..\n0030 - c0 2c c0 30 c0 24 c0 28  c0 2e c0 32 c0 26 c0 2a    .,.0.$.(...2.&.*\n0040 - 00 9f 00 a3 00 6b 00 6a  c0 2b c0 2f c0 23 c0 27    .....k.j.+./.#.'\n0050 - c0 2d c0 31 c0 25 c0 29  00 9e 00 a2 00 67 00 40    .-.1.%.).....g.@\n0060 - c0 0a c0 14 00 39 00 38  c0 05 c0 0f c0 09 c0 13    .....9.8........\n0070 - 00 33 00 32 c0 04 c0 0e  01 00 00 72 00 00 00 0e    .3.2.......r....\n0080 - 00 0c 00 00 09 6c 6f 63  61 6c 68 6f 73 74 00 0a    .....localhost..\n0090 - 00 3a 00 38 00 0e 00 0d  00 19 00 1c 00 0b 00 0c    .:.8............\n00a0 - 00 1b 00 18 00 09 00 0a  00 1a 00 16 00 17 00 08    ................\n00b0 - 00 06 00 7 00 14 00 15  00 04 00 05 00 12 00 13    ................\n00c0 - 00 01 00 02 00 03 00 0f  00 10 00 11 00 0b 00 02    ................\n00d0 - 01 00 00 0d 00 18 00 16  06 03 06 01 05 03 05 01    ................\n00e0 - 04 03 04 01 03 03 03 01  02 03 02 01 02 02          ..............\n<<< TLS 1.2 Handshake, ClientHello\n[{client_version,{3,3}},\n {random,\n     <<91,171,66,122,238,145,35,223,112,48,251,65,185,197,20,121,215,2,72,116,\n       201,185,169,143,224,233,4,26,249,168,33,73>>},\n {session_id,<<>>},\n {cipher_suites,\n     [<<0,255>>,\n      <<\"\\303\\200,\">>,<<\"\\303\\2000\">>,<<\"\\303\\200$\">>,<<\"\\303\\200(\">>,<<\"\\303\\200.\">>,<<\"\\303\\2002\">>,<<\"\\303\\200&\">>,<<\"\\303\\200*\">>,\n      <<0,159>>,\n      <<0,163>>,\n      <<0,107>>,\n      <<0,106>>,\n      <<\"\\303\\200+\">>,<<\"\\303\\200/\">>,<<\"\\303\\200#\">>,<<\"\\303\\200'\">>,<<\"\\303\\200-\">>,<<\"\\303\\2001\">>,<<\"\\303\\200%\">>,<<\"\\303\\200)\">>,\n      <<0,158>>,\n      <<0,162>>,\n      <<0,103>>,\n      <<0,64>>,\n      <<\"\\303\\200\\n\">>,\n      <<192,20>>,\n      <<0,57>>,\n      <<0,56>>,\n      <<192,5>>,\n      <<192,15>>,\n      <<\"\\303\\200\\t\">>,\n      <<192,19>>,\n      <<0,51>>,\n      <<0,50>>,\n      <<192,4>>,\n      <<192,14>>]},\n {compression_methods,[0]},\n...\n[Truncated for brevity]\n```\n\n----------------------------------------\n\nTITLE: Starting and Connecting Erlang Nodes using Bash\nDESCRIPTION: These Bash commands demonstrate starting distributed Erlang nodes. The first command starts a standard named node 'test@localhost'. The second command utilizes the OTP 23 feature allowing `-remsh` to start a temporary client node (implicitly using `-sname undefined`) that connects via a remote shell to the 'test@localhost' node without needing its own pre-defined name or relying on EPMD if the target node is OTP 23+.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# starting the E-node test\nerl -sname test@localhost \n\n# starting a temporary E-node (with dynamic name) as a remote shell to\n# the node test\nerl -remsh test@localhost \n```\n\n----------------------------------------\n\nTITLE: Resulting BEAM Code for Successful Case in Erlang\nDESCRIPTION: This snippet shows the BEAM code generated for the successful part of the function after optimization. It includes instructions for tuple testing, element extraction, and tuple construction.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\n%% Block 0.\n{test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n\n%% Block 5.\n{test_heap,3,1}.\n{get_tuple_element,{x,0},1,{x,0}}.\n{put_tuple,2,{x,1}}.\n{put,{atom,ok}}.\n{put,{x,0}}.\n{move,{x,1},{x,0}}.\nreturn.\n```\n\n----------------------------------------\n\nTITLE: JIT-compiled x86 assembly for addition with known integer ranges\nDESCRIPTION: The assembly code for addition when both operands are known to be small integers. The JIT can omit overflow checks and type tests, resulting in a simple and efficient addition operation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_36\n\nLANGUAGE: nasm\nCODE:\n```\n# i_plus_ssjd\n# add without overflow check\n    mov rax, qword ptr [rbx]\n    mov rsi, qword ptr [rbx+8]\n    and rax, -16\n    add rax, rsi\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Parsing Erlang Tokens with erl_parse\nDESCRIPTION: Demonstrates parsing tokenized Erlang code into abstract format using erl_parse:parse_exprs/1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\n2> {ok,Abstract} = erl_parse:parse_exprs(Tokens), Abstract.\n[{op,1,'+',\n     {var,1,'A'},\n     {op,1,'*',\n         {op,1,'*',{var,1,'B'},{var,1,'C'}},\n         {op,1,'+',{var,1,'D'},{integer,1,42}}}}]\n```\n\n----------------------------------------\n\nTITLE: Using New Preprocessor Directives in Erlang/OTP 19.0\nDESCRIPTION: New preprocessor directives -error(Term) and -warning(Term) to cause compilation errors or warnings with custom messages.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/103.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-error(Term) and -warning(Term)\n```\n\n----------------------------------------\n\nTITLE: Disabling 'maybe_expr' Feature via Source Code Directive in Erlang\nDESCRIPTION: Shows the Erlang source code directive `-feature(maybe_expr, disable).` which, when included at the top of a module, instructs the compiler to disable the `maybe` expression feature for that specific module. This permits the use of `maybe` as an unquoted atom within the module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_24\n\nLANGUAGE: erlang\nCODE:\n```\n-feature(maybe_expr, disable).\n```\n\n----------------------------------------\n\nTITLE: Analyzing BEAM Instructions for Exception Handling\nDESCRIPTION: This snippet presents the BEAM assembly for the `exception/0` Erlang function, illustrating the implementation of `try...catch`. It shows stack allocation (`allocate`) for the catch tag, setting up the exception handler using `{'try',{y,0},{f,13}}` which directs control flow to label 13 upon exception, calling an external function (`call_ext`), removing the handler on normal exit (`try_end`), and deallocating the frame (`deallocate`). The exception handling path (label 13) uses `try_case` to retrieve exception details (class, reason, stacktrace) into X registers, tests (`test,is_eq_exact`) to match the specific `throw:example` case, and either returns `hello` or re-throws the exception using `bif,raise`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_7\n\nLANGUAGE: BEAM Assembly\nCODE:\n```\n{function, exception, 0, 12}.\n  {label,11}.\n    {func_info,{atom,primer},{atom,exception},0}.\n  {label,12}.\n    {allocate,1,0}.\n  \n    <em>%% Place a catch tag in <b>{y,0}</b>. If an exception is\n    %% raised while this tag is the most current one,\n    %% the control flow will resume at <b>{f,13}</b> in this\n    %% stack frame.</em>\n    {'try',{y,0},{f,13}}.\n\n    {call_ext,0,{extfunc,external,call,0}}.\n\n    <em>%% Deactivate the catch tag before returning with the\n    %% result from the call.</em>\n    {try_end,{y,0}}.\n\n    {deallocate,1}.\n    return.\n\n  {label,13}.\n    <em>%% Uh oh, we've got an exception. Kill the catch tag\n    %% and place the exception class in <b>{x,0}</b>, the error\n    %% reason/thrown value in <b>{x,1}</b>, and the stack trace\n    %% in <b>{x,2}</b>.</em>\n    {try_case,{y,0}}.\n\n    <em>%% Return 'hello' if the user threw 'example'</em>\n    {test,is_eq_exact,{f,14},[{x,0},{atom,throw}]}.\n    {test,is_eq_exact,{f,14},[{x,1},{atom,example}]}.\n    {move,{atom,hello},{x,0}}.\n    {deallocate,1}.\n    return.\n\n  {label,14}.\n    <em>%% Otherwise, rethrow the exception since no catch\n    %% clause matched.</em>\n    {bif,raise,{f,0},[{x,2},{x,1}],{x,0}}.\n```\n\n----------------------------------------\n\nTITLE: Using Remainder for Arbitrary Range Mapping in Erlang\nDESCRIPTION: Illustrates using the remainder operator (`rem`) to map a generated random number `X` into a specific non-power-of-2 `Range`. This method is slower than bitwise operations and potentially introduces bias if `Range` is not significantly smaller than the square root of the generator's maximum value. It relies on the quality of the generator's low bits.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nV = X rem Range.\n```\n\n----------------------------------------\n\nTITLE: Analyzing BEAM Instructions for a Body-Recursive Function\nDESCRIPTION: This snippet displays the BEAM assembly for the body-recursive `sum_body/1` Erlang function. It demonstrates the necessity and usage of stack frames: `allocate` instruction creates a frame and reserves Y registers, `{get_list,{x,0},{y,0},{x,0}}` stores the list head in a Y register (`{y,0}`) for preservation across the function call, `call` performs a standard function call (not a tail call), `gc_bif` retrieves the value from the Y register after the call returns, and `deallocate` removes the stack frame before returning. It highlights how Y registers preserve state across calls that would invalidate X registers.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_3\n\nLANGUAGE: BEAM Assembly\nCODE:\n```\n{function, sum_body, 1, 7}.\n  {label,6}.\n    {func_info,{atom,primer},{atom,sum_body},1}.\n  {label,7}.\n    {test,is_nonempty_list,{f,8},[{x,0}]}.\n\n    <em>%% Allocate a stack frame with a single Y register.\n    %% Since this instruction may need more memory, we\n    %% tell the garbage collector that we currently have\n    %% one live X register (our list argument in <b>{x,0}</b>).</em>\n    {allocate,1,1}.\n\n    <em>%% Unpack the list, placing the head in <b>{y,0}</b> and\n    %% the tail in <b>{x,0}</b>.</em>\n    {get_list,{x,0},{y,0},{x,0}}.\n\n    <em>%% Body-call ourselves. Note that while this kills all\n    %% X registers, it leaves Y registers alone so our\n    %% head is still valid.</em>\n    {call,1,{f,7}}.\n\n    <em>%% Add the head to our return value and store the\n    %% result in <b>{x,0}</b>.</em>\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n\n    <em>%% Deallocate our stack frame and return.</em>\n    {deallocate,1}.\n    return.\n\n  {label,8}.\n    {test,is_nil,{f,6},[{x,0}]}.\n\n    <em>%% Return the integer 0.</em>\n    {move,{integer,0},{x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Starting OpenSSL Server and Sample Debug Log Output\nDESCRIPTION: This snippet shows the command line used to start an OpenSSL server (`openssl s_server`) configured to listen on port 11000, use TLS 1.2, specify certificate and key files, and enable verbose message (`-msg`) and debug (`-debug`) output. The subsequent text provides an example of the output generated by this OpenSSL server when the Erlang client connects, showing the raw TLS record and handshake message bytes for comparison with the Erlang logger output.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n$ /usr/bin/openssl s_server -accept 11000 -tls1_2 -cert server.pem -key server.key -msg -debug\nUsing default temp DH parameters\nACCEPT\nread from 0x16f0040 [0x16f56b3] (5 bytes => 5 (0x5))\n0000 - 16 03 03 00 a1                                    .....\n<<< ??? [length 0005]\n    16 03 03 00 a1\nread from 0x16f0040 [0x16f56b8] (161 bytes => 161 (0xA1))\n0000 - 01 00 00 9d 03 03 5b ac-a1 cc 20 4c 4d 52 d0 d4   ......[... LMR..\n0010 - c8 fc dd 95 b0 fa 65 97-57 9e 44 aa dd 0e 46 10   ......e.W.D...F.\n0020 - 6c 14 57 9c ce a0 00 00-04 00 ff c0 14 01 00 00   l.W.............\n0030 - 70 00 2b 00 06 00 04 03-04 03 03 00 00 00 0e 00   p.+.............\n0040 - 0c 00 00 09 6c 6f 63 61-6c 68 6f 73 74 00 0a 00   ....localhost...\n0050 - 3a 00 38 00 0e 00 0d 00-19 00 1c 00 0b 00 0c 00   :.8.............\n0060 - 1b 00 18 00 09 00 0a 00-1a 00 16 00 17 00 08 00   ................\n0070 - 06 00 07 00 14 00 15 00-04 00 05 00 12 00 13 00   ................\n0080 - 01 00 02 00 03 00 0f 00-10 00 11 00 0b 00 02 01   ................\n0090 - 00 00 32 00 04 00 02 02-03 00 0d 00 04 00 02 02   ..2.............\n00a0 - 01                                                .\n<<< TLS 1.2 Handshake [length 00a1], ClientHello\n    01 00 00 9d 03 03 5b ac a1 cc 20 4c 4d 52 d0 d4\n    c8 fc dd 95 b0 fa 65 97 57 9e 44 aa dd 0e 46 10\n    6c 14 57 9c ce a0 00 00 04 00 ff c0 14 01 00 00\n    70 00 2b 00 06 00 04 03 04 03 03 00 00 00 0e 00\n    0c 00 00 09 6c 6f 63 61 6c 68 6f 73 74 00 0a 00\n    3a 00 38 00 0e 00 0d 00 19 00 1c 00 0b 00 0c 00\n    1b 00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00\n    06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00\n    01 00 02 00 03 00 0f 00 10 00 11 00 0b 00 02 01\n    00 00 32 00 04 00 02 02 03 00 0d 00 04 00 02 02\n    01\n...\n[Truncated for brevity]\n```\n\n----------------------------------------\n\nTITLE: Committing Backup Files with Flat Error Handling and an 'else' Clause - Erlang\nDESCRIPTION: This snippet extends the previous 'maybe' construct usage by adding an 'else' clause to explicitly handle unexpected errors, such as result tuples not matching {ok, _} or {error, Reason}. It sequentially checks sync, close, and rename operations, propagating errors through the 'else' handler. This requires updated Erlang/OTP with 'maybe/else' support and the same dependencies as before. It returns {ok, File} on success, or {error, Reason} for any error case. This pattern increases robustness over relying solely on the standard 'maybe' construct.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\ncommit_write(OpaqueData) ->\n    maybe\n        ok ?= disk_log:sync(OpaqueData#backup.file_desc),\n        ok ?= disk_log:close(OpaqueData#backup.file_desc),\n        ok ?= file:rename(OpaqueData#backup.tmp_file, OpaqueData#backup.file),\n        {ok, OpaqueData#backup.file}\n    else\n        {error, Reason} -> {error, Reason}\n    end.\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning Suppression Command\nDESCRIPTION: Example of using erlc command with compiler warning option.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/169.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n% erlc +warn_missing_spec some_module.erl\n```\n\n----------------------------------------\n\nTITLE: Using New Maps:get/3 Function in Erlang Stdlib Module\nDESCRIPTION: Shows the usage of the newly added maps:get/3 function in the maps module of Erlang/OTP 17.1. This function returns a default value if the key does not exist in the map.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/9.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nDefaultValue = maps:get(Key, Map, DefaultValue)\n```\n\n----------------------------------------\n\nTITLE: Multiple Arguments Function in Erlang and Core Erlang\nDESCRIPTION: Example showing how multiple arguments and arithmetic operations are handled in Core Erlang.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-07-core-erlang-by-example.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nc(inc, Base, N) ->\n    Base+N;\nc(_, Base, _) ->\n    Base.\n```\n\nLANGUAGE: erlang\nCODE:\n```\n'c'/3 =\n    fun (_@c2,_@c1,_@c0) ->\n\tcase <_@c2,_@c1,_@c0> of\n\t  <'inc',Base,N> when 'true' ->\n\t      call 'erlang':'+'(Base, N)\n\t  <_@c6,Base,_@c7> when 'true' ->\n\t      Base\n\tend\n```\n\n----------------------------------------\n\nTITLE: Testing Small Integer Comparison - x86-64 Assembly\nDESCRIPTION: This assembly snippet implements the low-level logic for comparing two Erlang terms, specifically testing if both operands are small integers by inspecting their tag bits and performing a conditional comparison. If the test passes, it continues with a native comparison; otherwise, it calls a generic routine to handle alternative term types. Dependencies include running in an environment where BEAM register conventions are respected and special Erlang tagging rules apply. The input operands are expected to be loaded from memory, with specific register use for BEAM x registers.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_8\n\nLANGUAGE: nasm\nCODE:\n```\n    mov rsi, qword ptr [rbx+8]\\n    mov rdi, qword ptr [rbx]\\n    mov eax, edi\\n    and eax, esi\\n    and al, 15\\n    cmp al, 15\\n    short jne L39\\n    cmp rdi, rsi\\n    short jmp L40\\nL39:\\n    call 5447639136\\nL40:\\n    jge label_9\n```\n\n----------------------------------------\n\nTITLE: Using AES CFB8 Cipher in Erlang Crypto Module\nDESCRIPTION: The crypto module in Erlang/OTP 17 now supports the AES CFB8 cipher for block encryption and decryption operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/17.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ncrypto:block_encrypt(aes_cfb8, Key, IV, PlainText)\ncrypto:block_decrypt(aes_cfb8, Key, IV, CipherText)\n```\n\n----------------------------------------\n\nTITLE: Analyzing BEAM Instructions for Selective Receive (Partial)\nDESCRIPTION: This snippet shows the beginning of the BEAM assembly code for the `selective_receive/1` function. It demonstrates allocating a stack frame (`allocate`) and moving the input argument `Ref` from an X register (`{x,0}`) to a Y register (`{y,0}`) using `move`. This is necessary because the process might be scheduled out while waiting for a message, and Y registers persist across such scheduling events unlike temporary X registers. The instruction at label 17 (partially shown) is intended to start checking the process's message queue.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_9\n\nLANGUAGE: BEAM Assembly\nCODE:\n```\n{function, selective_receive, 1, 16}.\n  {label,15}.\n    {func_info,{atom,primer},{atom,selective_receive},1}.\n  {label,16}.\n    {allocate,1,1}.\n\n    <em>%% We may be scheduled out while waiting for a\n    %% message, so we'll preserve our <b>Ref</b> in <b>{y,0}</b>.</em>\n    {move,{x,0},{y,0}}.\n\n  {label,17}.\n    <em>%% Pick the next message from the process' message box\n    %% and place it in <b>{x,0}</b>, jumping to label 19 if the\n    %% message box is empty.</em>\n```\n\n----------------------------------------\n\nTITLE: Connecting to SSL Server in OTP 26 with Verification Disabled\nDESCRIPTION: Example showing how to explicitly disable certificate verification in OTP 26 using the verify_none option, which is no longer the default.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_35\n\nLANGUAGE: erlang\nCODE:\n```\n1> application:ensure_all_started(ssl).\n{ok,[crypto,asn1,public_key,ssl]}\n2> ssl:connect(\"www.erlang.org\", 443, [{verify,verify_none}]).\n{ok,{sslsocket,{gen_tcp,#Port<0.6>,tls_connection,undefined},\n               [<0.143.0>,<0.142.0>]}}\n```\n\n----------------------------------------\n\nTITLE: Adding Latin-1 Encoding Comment to Erlang Files\nDESCRIPTION: A directive to explicitly specify Latin-1 encoding for Erlang source files when maintaining the previous default encoding while using OTP 17.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/47.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n%% -*- coding: latin-1 -*-\n```\n\n----------------------------------------\n\nTITLE: Updating Contention Counter for OuterSignalQueueLock in C\nDESCRIPTION: This function locks the process message queue and updates a contention counter. If the lock is busy, the counter is incremented; otherwise, it's decremented if positive. This helps determine when to activate the parallel signal sending optimization.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-11-05-parallel-signal-sending-optimization.md#2025-04-22_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nvoid erts_proc_sig_queue_lock(Process* proc)\n{\n    if (EBUSY == erts_proc_trylock(proc, ERTS_PROC_LOCK_MSGQ)) {\n        erts_proc_lock(proc, ERTS_PROC_LOCK_MSGQ);\n        proc->sig_inq_contention_counter += 1;\n    } else if(proc->sig_inq_contention_counter > 0) {\n        proc->sig_inq_contention_counter -= 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Underscore Placement in Numeric Literals\nDESCRIPTION: Examples of invalid placements of underscores in numeric literals, showing various disallowed patterns.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\n_123  % variable name\n123_\n123__456  % only single '_'\n123_.456\n123._456\n16#_1234\n16#1234_\n```\n\n----------------------------------------\n\nTITLE: Viewing Compiled BEAM Assembly for mwc59 (No Type Opt) in Text\nDESCRIPTION: Displays the Erlang BEAM assembly code generated for the `mwc59` function when compiled with the `no_type_opt` flag (disabling type-based optimizations). It shows the sequence of BIF calls: `bsr` for bit shift right, `band` for bitwise AND, `*` for multiplication, and `+` for addition, corresponding directly to the operations in the Erlang source code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n    {gc_bif,'bsr',{f,0},1,[{x,0},{integer,32}],{x,1}}.\n    {gc_bif,'band',{f,0},2,[{x,0},{integer,4294967295}],{x,0}}.\n    {gc_bif,'*',{f,0},2,[{x,0},{integer,133850370}],{x,0}}.\n    {gc_bif,'+',{f,0},2,[{x,0},{x,1}],{x,0}}.\n```\n\n----------------------------------------\n\nTITLE: Integer Extraction and Storage in Assembly\nDESCRIPTION: Assembly code for extracting and storing 8-bit and 24-bit integer segments from binary data.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_28\n\nLANGUAGE: nasm\nCODE:\n```\n# extract integer 8\n    mov rax, rdx\n# store extracted integer as a small\n    shr rax, 52\n    or rax, 15\n    mov qword ptr [rbx+16], rax\n    shl rdx, 8\n# extract integer 24\n    shr rdx, 36\n    or rdx, 15\n    mov qword ptr [rbx+24], rdx\n```\n\n----------------------------------------\n\nTITLE: Printing Maps in OTP 26: Atom Key Order is Undefined - Erlang\nDESCRIPTION: Shows the changed behavior in OTP 26, where atom key order in small maps is no longer guaranteed and is implementation specific. After defining a map and printing it, the key order differs from previous versions. This highlights the new unordered display output in the runtime.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\n1> AM = #{a => 1, b => 2, c => 3}.\n#{c => 3,a => 1,b => 2}\n2> maps:to_list(AM).\n[{c,3},{a,1},{b,2}]\n```\n\n----------------------------------------\n\nTITLE: Using tprof for call counting profiling\nDESCRIPTION: Example of using the new tprof module with call_count type to count function calls when running lists:seq/2, demonstrating how it identifies recursive call patterns.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_40\n\nLANGUAGE: erlang\nCODE:\n```\ntprof:profile(lists, seq, [1, 1000], #{type => call_count}).\n```\n\n----------------------------------------\n\nTITLE: Defining a Tail-Recursive Sum Function in Erlang\nDESCRIPTION: This Erlang code defines a function `sum_tail` in two clauses. The first clause (`sum_tail/1`) serves as an entry point, initializing an accumulator to 0 and calling the second clause. The second clause (`sum_tail/2`) recursively processes the list: if the list is not empty, it adds the head to the accumulator and recurses on the tail; if the list is empty, it returns the accumulator. This demonstrates a common tail-recursive pattern in Erlang.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-20-a-brief-BEAM-primer.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nsum_tail(List) ->\n    sum_tail(List, 0).\n\nsum_tail([Head | Tail], Acc) ->\n    sum_tail(Tail, Head + Acc);\nsum_tail([], Acc) ->\n    Acc.\n```\n\n----------------------------------------\n\nTITLE: Base64 encoding function in Erlang\nDESCRIPTION: The central function from the base64 module that performs binary encoding to Base64 format. This function benefited significantly from type-based optimizations in OTP 25 without any changes to the source code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_37\n\nLANGUAGE: erlang\nCODE:\n```\nencode_binary(<<B1:8, B2:8, B3:8, Ls/bits>>, A) ->\n    BB = (B1 bsl 16) bor (B2 bsl 8) bor B3,\n    encode_binary(Ls,\n                  <<A/bits,(b64e(BB bsr 18)):8,\n                    (b64e((BB bsr 12) band 63)):8,\n                    (b64e((BB bsr 6) band 63)):8,\n                    (b64e(BB band 63)):8>>).\n```\n\n----------------------------------------\n\nTITLE: Correctly Eliminating Single-Clause Case with Let Binding\nDESCRIPTION: This Core Erlang snippet demonstrates the correct way to eliminate the single-clause `case` from the previous step. A `let` expression is introduced to bind the variables `A` and `B` by matching them against the original `case` expression value `{'a', 'tuple'}` before they are used in the body `{'tuple', A, B}`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_12\n\nLANGUAGE: erlang\nCODE:\n```\n'aa'/0 =\n    fun () ->\n      let <A,B> = <'a','tuple'>\n      in {'tuple',A,B}\n```\n\n----------------------------------------\n\nTITLE: Rejecting Server-Only Options in OTP 26 Client Connection\nDESCRIPTION: Example showing how OTP 26 rejects server-only options like fail_if_no_peer_cert when used in a client connection, which were silently ignored in OTP 25.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_36\n\nLANGUAGE: erlang\nCODE:\n```\n1> application:ensure_all_started(ssl).\n{ok,[crypto,asn1,public_key,ssl]}\n2> ssl:connect(\"www.erlang.org\", 443, [{fail_if_no_peer_cert, true}, {verify, verify_peer}, {cacerts, public_key:cacerts_get()}]).\n{error,{option,server_only,fail_if_no_peer_cert}}\n```\n\n----------------------------------------\n\nTITLE: Referencing EEP-45 (Function_Name and Function_Arity macros) in Markdown\nDESCRIPTION: Markdown link to EEP-45 documenting the Function_Name and Function_Arity macros feature that was approved and implemented in OTP 19.0-rc1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/104.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[EEP-45](https://github.com/erlang/eep/blob/master/eeps/eep-0045.md) Function_Name and Function_Arity as macros\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation Command Line Arguments in Erlang\nDESCRIPTION: Command line arguments for configuring the new super carrier memory allocation feature in Erlang/OTP R16B03. Arguments include +MMscs for size specification, +MMsco, +MMscrfsd, +MMscrpm, +MMusac, and +Mlpm for various memory allocation controls.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/46.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n+MMscs\n```\n\n----------------------------------------\n\nTITLE: Demonstrating timer:apply_after with incorrect usage in Erlang/OTP 26\nDESCRIPTION: Example showing how using timer:apply_after with a fun in Erlang/OTP 26 can lead to errors if the argument list for the fun is forgotten. This demonstrates the problem that is fixed in OTP 27.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_33\n\nLANGUAGE: erlang\nCODE:\n```\ntimer:apply_after(10, erlang, apply, [fun() -> io:put_chars(\"now!\\n\") end]).\n```\n\n----------------------------------------\n\nTITLE: Binary Pattern Matching bs_match Instruction Example\nDESCRIPTION: Demonstrates the BEAM bs_match instruction format used for matching binary segments with known sizes at compile time.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_26\n\nLANGUAGE: erlang\nCODE:\n```\n{test,bs_start_match3,{f,1},1,[{x,0}],{x,1}}.\n{bs_get_position,{x,1},{x,0},2}.\n{bs_match,{f,2},\n          {x,1},\n          {commands,[{ensure_exactly,32},\n                     {integer,2,{literal,[]},8,1,{x,2}},\n                     {integer,3,{literal,[]},24,1,{x,3}}]}}.\n```\n\n----------------------------------------\n\nTITLE: Representing Erlang Function with Outer Case in Core Erlang\nDESCRIPTION: This is the actual, less optimized Core Erlang code generated for the `a/0` function before `sys_core_fold`. It includes an outer `case` expression that matches on an empty value list (`<>`) with a `true` guard. This structure is common in Core Erlang generation but can often be simplified.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\n'a'/0 =\n    fun () ->\n        case <> of\n\t  <> when 'true' ->\n\t      let <A> = 42\n\t      in {'ok',A}\n\t  <> when 'true' ->\n\t\tprimop 'match_fail'({'function_clause'})\n\tend\n```\n\n----------------------------------------\n\nTITLE: Integer Range Comparison in BEAM JIT\nDESCRIPTION: Assembly code that completes the range check by comparing a value against the upper bound. Uses unsigned comparison to check both bounds at once through two's complement representation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_15\n\nLANGUAGE: nasm\nCODE:\n```\ncmp rax, 16368\nshort ja label_19\n```\n\n----------------------------------------\n\nTITLE: Locating Dialyzer Configuration File in Erlang\nDESCRIPTION: Command to display help information for Dialyzer, including the location of its configuration file. This shows where Dialyzer looks for the dialyzer.config file which stores default options.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n$ dialyzer --help\n```\n\n----------------------------------------\n\nTITLE: Improved Erlang function with range constraints\nDESCRIPTION: An enhanced version of the addition function that attempts to constrain the integers to a specific range (0 to 0x400) to help the compiler produce more optimized code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_30\n\nLANGUAGE: erlang\nCODE:\n```\nadd4(X, Y) when is_integer(X), 0 =< X, X < 16#400,\n                is_integer(Y), 0 =< Y, Y < 16#400 ->\n    X + Y.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Bug with Erlang Receive and Off-Heap Messages\nDESCRIPTION: This Erlang code snippet shows a simple selective `receive` statement. It's used to explain a bug scenario where the new compiler passes could incorrectly leave references to unmatched off-heap messages on the process stack. If a garbage collection occurs before the message is processed later, the GC might corrupt the original message in the external message queue, leading to crashes.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\nreceive\n    {tagged_message,Message} -> Message\nend.\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang File with No Post-optimization\nDESCRIPTION: This snippet shows the compilation process with the 'no_postopt' option, which turns off all optimizations run on the BEAM code after v3_codegen.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-19-compiler-time-option.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc +no_postopt +time NBAP-PDU-Contents.erl\nCompiling \"NBAP-PDU-Contents\"\n remove_file                   :      0.000 s       6.5 kB\n parse_module                  :      0.706 s   25146.1 kB\n transform_module              :      0.000 s   25146.1 kB\n lint_module                   :      0.421 s   25146.1 kB\n expand_records                :      0.090 s   25993.8 kB\n core                          :      0.684 s  282518.3 kB\n sys_core_fold                 :      1.614 s  237885.4 kB\n core_transforms               :      0.000 s  237885.4 kB\n sys_core_bsm                  :      0.210 s  238982.3 kB\n sys_core_dsetel               :      0.105 s  238982.3 kB\n v3_kernel                     :      0.967 s  305320.5 kB\n v3_life                       :      0.353 s  221354.8 kB\n v3_codegen                    :      1.028 s   75801.0 kB\n beam_a                        :      0.091 s   75561.3 kB\n beam_clean                    :      0.201 s   73513.2 kB\n beam_z                        :      0.023 s   72897.9 kB\n beam_validator                :      0.467 s   72897.9 kB\n beam_asm                      :      0.396 s       6.6 kB\n save_binary                   :      0.001 s       6.5 kB\n```\n\n----------------------------------------\n\nTITLE: Running ehead Script Without Arguments in Erlang\nDESCRIPTION: Output when running the ehead script without any arguments, showing how argparse provides helpful error messages. The output explains that the required 'files' argument is missing.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\n$ ehead\nerror: ehead: required argument missing: files\nUsage:\n  ehead [-n <lines>] [--lines <lines>] <files>...\n\nArguments:\n  files       lists of files\n\nOptional arguments:\n  -n, --lines number of lines to print (int >= 1, 10)\n```\n\n----------------------------------------\n\nTITLE: Erlang: Optimized Tuple Pattern Matching\nDESCRIPTION: This change involves rewriting tuple pattern matches for efficiency, reducing code size and execution time while minimizing garbage collection. This automatic rewriting alleviates runtime pressure by reusing tuples in pattern matching scenarios.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/21.md#2025-04-22_snippet_1\n\nLANGUAGE: Erlang\nCODE:\n```\nf({ok, Val}) -> {ok, Val}. \nf({ok, Val} = Tuple) -> Tuple.\n```\n\n----------------------------------------\n\nTITLE: Representing Parallel Match with Tuple Creation in Core Erlang\nDESCRIPTION: This unoptimized Core Erlang code for `b/2` shows how the function arguments (`_@c1`, `_@c0`) are first bound, then explicitly combined into a tuple `{A, B}` within a nested `case`. This intermediate tuple creation is inefficient and targeted by optimization.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_15\n\nLANGUAGE: erlang\nCODE:\n```\n'b'/2 =\n    fun (_@c1,_@c0) ->\n\tcase <_@c1,_@c0> of\n\t  <A,B> when 'true' ->\n\t      case {A,B} of\n\t\t<{'true','false'}> when 'true' ->\n\t\t    'ok'\n\t\t<{'false','true'}> when 'true' ->\n\t\t    'not_ok'\n\t\t<{_@c5,_@c6}> when 'true' ->\n\t\t    'error'\n\t\t<_@c2> when 'true' ->\n\t\t      primop 'match_fail'({'case_clause',_@c2})\n\t      end\n\tend\n```\n\n----------------------------------------\n\nTITLE: Dialyzer Configuration for PropER Analysis in Erlang\nDESCRIPTION: Modified dialyzer.config that changes the default_warnings_apps to proper and adds the path to the proper application. This configuration is used to analyze the PropER testing library.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_21\n\nLANGUAGE: erlang\nCODE:\n```\n{incremental,\n {default_apps, [erts,kernel,stdlib,compiler,crypto]},\n {default_warning_apps, [proper]}\n}.\n{add_pathsa, [\"/Users/bjorng/git/proper/_build/default/lib/proper\"]}.\n```\n\n----------------------------------------\n\nTITLE: Masking Lower Bits for Power-of-2 Range in Erlang\nDESCRIPTION: Demonstrates how to obtain a random number `V` within a power-of-2 range by masking the lower `RangeBits` of a generated value `X` using the bitwise AND operator (`band`). This is efficient when the generator's lower bits are known to be strong and the range size is 2^RangeBits.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nV = X band ((1 bsl RangeBits) - 1).\n```\n\n----------------------------------------\n\nTITLE: Relational Operator in Erlang Guards\nDESCRIPTION: BEAM representation showcasing how relational operators like `<` in guards are transformed into BEAM's `is_lt` instruction. Critical for Erlang developers leveraging OTP for optimized code patterns in conditional checks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n{test,is_lt,{f,9},[{x,0},{x,1}]}\n```\n\n----------------------------------------\n\nTITLE: Generating Unoptimized Erlang SSA Listing using erlc\nDESCRIPTION: Demonstrates the `erlc` command with the `+dssa` flag to compile an Erlang module (`blog.erl`) and generate its unoptimized Static Single Assignment (SSA) code representation. The output is saved by default to a file named `blog.ssa`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nerlc +dssa blog.erl\n```\n\n----------------------------------------\n\nTITLE: Attempting Binary Literal Optimization (Incorrect UTF-8) in Erlang\nDESCRIPTION: Modifies `greek_quote/0` to use a binary literal (`<<...>>`) instead of a string to reduce memory usage. However, without specifying UTF-8 encoding via `/utf8`, non-ASCII characters (like the Greek letters) will be misinterpreted when printed using `~ts`, as binaries default to byte sequences.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_10\n\nLANGUAGE: erlang\nCODE:\n```\ngreek_quote() ->\n    S = <<\"\\\"Know thyself\\\" (Greek: Γνῶθι σαυτόν)\">>,\n    io:format(\"~ts\\n\", [S]).\n```\n\n----------------------------------------\n\nTITLE: Installing OTP 25-rc1 with Kerl\nDESCRIPTION: Command to install the OTP 25 release candidate using the kerl tool\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/153.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nkerl build 25.0-rc1 25.0-rc1\n```\n\n----------------------------------------\n\nTITLE: Connecting to SSL Server in OTP 25 Without Certificate Verification\nDESCRIPTION: Example showing how OTP 25 allowed SSL connections without certificate verification when using default options, only generating a warning message.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_32\n\nLANGUAGE: erlang\nCODE:\n```\nErlang/OTP 25 . . .\n\nEshell V13.1.1  (abort with ^G)\n1> application:ensure_all_started(ssl).\n{ok,[crypto,asn1,public_key,ssl]}\n2> ssl:connect(\"www.erlang.org\", 443, []).\n=WARNING REPORT==== 6-Apr-2023::12:29:20.824457 ===\nDescription: \"Authenticity is not established by certificate path validation\"\n     Reason: \"Option {verify, verify_peer} and cacertfile/cacerts is missing\"\n\n{ok,{sslsocket,{gen_tcp,#Port<0.6>,tls_connection,undefined},\n               [<0.122.0>,<0.121.0>]}}\n```\n\n----------------------------------------\n\nTITLE: Basic HTML Layout Structure for Erlang.org Pages\nDESCRIPTION: Core HTML template structure showing the main layout components including header, body container, sidebar, main content area and footer. Uses Bootstrap container classes combined with CSS Grid for responsive layouts.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<body>\n    <header class=\"container header\">\n        <nav></nav>\n    </header>\n    <div class=\"container body\">\n      <aside class=\"sidebar\"></aside>\n      <main class=\"main\">\n          <div class=\"top\"></div>\n          <div class=\"content\"></div>\n      </main>\n    </div>\n    <footer class=\"container footer\"></footer>\n</body>\n```\n\n----------------------------------------\n\nTITLE: Map Matching Old Style in Erlang\nDESCRIPTION: Shows the previous approach to matching complex keys in maps, where the key expression had to be bound to a variable first.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nexample2(M, X) ->\n    Key = {tag,X},\n    #{Key := Value} = M,\n    Value.\n```\n\n----------------------------------------\n\nTITLE: Final Optimized Core Erlang Eliminating Tuple Building and Matching\nDESCRIPTION: This final optimized Core Erlang code for `c/1` demonstrates the complete elimination of tuple building and matching. The inner `case` returns a value list directly bound by the outer `let` to `_@f4` and `_@f5`. These variables are then used directly in the `call 'erlang':'+'(_@f4, _@f5)`, avoiding the intermediate tuple creation and the second `case` statement entirely.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_20\n\nLANGUAGE: erlang\nCODE:\n```\n'c'/1 =\n    fun (_@c0) ->\n\tlet <_@f4,_@f5> =\n\t    case _@c0 of\n\t      <'a1'> when 'true' ->\n\t\t  <10,1>\n\t      <'b2'> when 'true' ->\n\t\t  <20,2>\n\t      <_@c5> when 'true' ->\n\t\t  <100,42>\n\t    end\n\tin\n\t    call 'erlang':'+'(_@f4, _@f5)\n```\n\n----------------------------------------\n\nTITLE: Enhanced Dialyzer Configuration for PropER in Erlang\nDESCRIPTION: Updated dialyzer.config that adds tools and syntax_tools to the applications to be analyzed, which eliminates the unknown function warnings when analyzing PropER.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_23\n\nLANGUAGE: erlang\nCODE:\n```\n{incremental,\n {default_apps, [erts,kernel,stdlib,compiler,crypto,tools,syntax_tools]},\n {default_warning_apps, [proper]}\n}.\n{add_pathsa, [\"/Users/bjorng/git/proper/_build/default/lib/proper\"]}.\n```\n\n----------------------------------------\n\nTITLE: Viewing perf Profile Reports - Shell Command\nDESCRIPTION: This snippet illustrates how to view perf profile data, producing a report of annotated call graphs and CPU time spent per function. Requires previously recorded perf.data files and the perf tool installed. Outputs an interactive or textual summary of profiling results. No direct limitations, although readability depends on available symbols and data.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_11\n\nLANGUAGE: text\nCODE:\n```\nperf report\n```\n\n----------------------------------------\n\nTITLE: Configuring a Logger Handler with Custom Formatter in Erlang\nDESCRIPTION: This Erlang code defines a configuration map (`Config`) for a logger handler. It sets the handler's primary log level to `debug`, specifies that log events not matching any filter should be stopped (`filter_default => stop`), and assigns a custom formatter implemented in the `ssl_logger` module.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-10-05-ssl-logging-in-otp-22.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nConfig = #{level => debug,\n           filter_default => stop,\n           formatter => {ssl_logger, #{}}},\n```\n\n----------------------------------------\n\nTITLE: Applying Constant Propagation after Case Elimination\nDESCRIPTION: This is the final optimized Core Erlang code for `aa/0`. After the `case` elimination and introduction of the `let` binding, constant propagation is applied. The variables `A` and `B` are replaced with their bound constant values `'a'` and `'tuple'`, resulting in the final expression `{'tuple', 'a', 'tuple'}`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_13\n\nLANGUAGE: erlang\nCODE:\n```\n'aa'/0 =\n    fun () ->\n\t{'tuple','a','tuple'}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Slots for Decentralized Counters in Erlang\nDESCRIPTION: This snippet shows how to configure the maximum number of slots in the array of counters for decentralized counters in Erlang using the '+dcg' option.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-08-03-scalable-ets-counters.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n\"+dcg\"\n```\n\n----------------------------------------\n\nTITLE: Process Code Check Function Reference\nDESCRIPTION: Reference to the function used for checking process code in the new purge strategy.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/114.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:check_process_code/3\n```\n\n----------------------------------------\n\nTITLE: SSH Algorithm Modification in Erlang\nDESCRIPTION: Reference to the new SSH modify_algorithms option that enables specifying changes to the default algorithms list. This allows customization of SSH encryption and authentication algorithms.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/115.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nmodify_algorithms\n```\n\n----------------------------------------\n\nTITLE: Using CA Certificates with SSL Connection in Erlang\nDESCRIPTION: Example demonstrating how to fetch and use CA certificates from the OS certificate store for establishing SSL connections. The certificates are cached efficiently using persistent_term and can be used with ssl and httpc modules.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_19\n\nLANGUAGE: erlang\nCODE:\n```\n%% makes the certificates available without copying\nCaCerts = public_key:cacerts_get(), \n% use the certificates when establishing a connection\n{ok,Socket} = ssl:connect(\"erlang.org\",443,[{cacerts,CaCerts}, {verify,verify_peer}]), \n...\n```\n\n----------------------------------------\n\nTITLE: Core Erlang Representation Before sys_core_alias Optimization\nDESCRIPTION: This snippet shows the Core Erlang representation of the remove_even function before the sys_core_alias optimization is applied.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n'remove_even'/1 =\n    fun (_0) ->\n\tcase _0 of\n\t  <[{Key,Val}|T]> when 'true' ->\n\t      let <_1> =\n\t\t  call\n\t\t       'erlang':'rem'(Val, 2)\n\t      in\n\t\t  case <> of\n\t\t    <>\n\t\t\twhen call 'erlang':'=:='(_1, 0) ->\n\t\t\t    apply 'remove_even'/1(T)\n\t\t    <> when 'true' ->\n\t\t\tlet <_2> =\n\t\t\t    apply 'remove_even'/1(T)\n\t\t\tin\n                            [{Key,Val}|_2]      % BUILDING TUPLE\n\t\t  end\n\t  <[]> when 'true' ->\n\t      []\n\t  <_4> when 'true' ->\n\t\tprimop 'match_fail'({'function_clause',_4})\n\tend\n```\n\n----------------------------------------\n\nTITLE: Running Dialyzer on PropER in Erlang\nDESCRIPTION: Output from running Dialyzer with the PropER configuration, showing the analysis process and resulting warnings about unknown functions. This demonstrates incremental analysis on a real-world application.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n$ dialyzer --incremental\nThere have been changes to analyze\n    Of the 296 files being tracked,\n    26 have been changed or removed,\n    resulting in 26 requiring analysis because they depend on those changes\nProceeding with incremental analysis...\nproper.erl:2417:13: Unknown function cover:start/1\nproper.erl:2426:13: Unknown function cover:stop/1\nproper_symb.erl:249:9: Unknown function erl_syntax:atom/1\nproper_symb.erl:250:5: Unknown function erl_syntax:revert/1\nproper_symb.erl:250:23: Unknown function erl_syntax:application/3\nproper_symb.erl:257:51: Unknown function erl_syntax:nil/0\nproper_symb.erl:259:49: Unknown function erl_syntax:cons/2\nproper_symb.erl:262:5: Unknown function erl_syntax:revert/1\nproper_symb.erl:262:23: Unknown function erl_syntax:tuple/1\n done in 0m2.36s\ndone (warnings were emitted)\n```\n\n----------------------------------------\n\nTITLE: Distribution Options - Erlang\nDESCRIPTION: New distribution options for running Erlang without EPMD, including dist_listen and erl_epmd_port configurations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/138.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n-dist_listen false\n-erl_epmd_port Port\n```\n\n----------------------------------------\n\nTITLE: Simple Erlang Record Matching Function\nDESCRIPTION: Example Erlang function that performs tuple matching typically used with records. The function matches a tuple with tag and returns an ok tuple with the second element.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nfoo({tag,A,_,_}) ->\n    {ok,A}.\n```\n\n----------------------------------------\n\nTITLE: Sample Erlang Module for Compilation\nDESCRIPTION: Defines a simple Erlang module 'trivial' with a record and a function to demonstrate compiler front end behavior.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-module(trivial).\n-export([example/4]).\n-record(rec, {mod,func,result}).\n\n%% Example to help explore the compiler front end.\nexample(A, B, C, D) ->\n    #rec{mod=?MODULE,func=?FUNCTION_NAME,result=A + (B*C*(D+42))}.\n```\n\n----------------------------------------\n\nTITLE: Generating Optimized Erlang SSA Listing using erlc\nDESCRIPTION: Shows how to use the `erlc` command with the `+dssaopt` flag to compile an Erlang module (`blog.erl`) and generate its optimized Static Single Assignment (SSA) code. The optimized SSA code is written by default to the file `blog.ssaopt`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nerlc +dssaopt blog.erl\n```\n\n----------------------------------------\n\nTITLE: Disabling 'maybe_expr' Feature via Compiler Flag (erlc) in Shell\nDESCRIPTION: Provides the command-line instruction using `erlc` to compile Erlang source files (`*.erl`) while explicitly disabling the `maybe_expr` feature using the `-disable-feature maybe_expr` flag. This allows the unquoted word `maybe` to be used as an atom within the compiled code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\nerlc -disable-feature maybe_expr *.erl\n```\n\n----------------------------------------\n\nTITLE: 32-bit MWC59 Value Generation in Erlang\nDESCRIPTION: Implementation of the final scrambler for 32-bit values, avoiding bignum operations and applying appropriate bit masks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_20\n\nLANGUAGE: erlang\nCODE:\n```\nmwc59_value32(T) ->\n    V0 = T  band ((1 bsl 32)-1),\n    V1 = V0 band ((1 bsl (32-8))-1),\n    V0 bxor (V1 bsl 8).\n```\n\n----------------------------------------\n\nTITLE: Getting Hash Information in Crypto Module\nDESCRIPTION: Shows the usage of the new hash_info/1 function in the crypto module that returns a map with information about a hash algorithm.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/132.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ncrypto:hash_info/1\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang/OTP 27.0-rc1 Using Kerl\nDESCRIPTION: Command to install Erlang/OTP 27.0-rc1 using the kerl tool, which helps manage multiple Erlang/OTP installations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/167.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkerl build 27.0-rc1 27.0-rc1.\n```\n\n----------------------------------------\n\nTITLE: Testing Code Placement for Pointer Packing Optimization in C\nDESCRIPTION: A simple C program that determines if code is placed in the lower 4GB of memory space, which enables the pointer packing optimization in the BEAM interpreter. It checks if the address of the main function is less than 2^32, exiting with 0 (success) if it is, and 1 (failure) if not.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-6-11-Interpreter-Optimizations.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include <stdlib.h>\nint main() {\n  if ((unsigned long long)&main < (1ull << 32)) {\n    exit(0);\n  }\n  exit(1);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Dialyzer Configuration for Incremental Analysis in Erlang\nDESCRIPTION: Configuration for Dialyzer to analyze erts, kernel, stdlib, compiler, and crypto applications while producing warnings only for stdlib. This configuration is stored in the dialyzer.config file.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_19\n\nLANGUAGE: erlang\nCODE:\n```\n{incremental,\n {default_apps, [erts,kernel,stdlib,compiler,crypto]},\n {default_warning_apps, [stdlib]}\n}.\n```\n\n----------------------------------------\n\nTITLE: Running Erlang with JIT Native Code Dumping Enabled (Bash)\nDESCRIPTION: This command starts the Erlang runtime system (`erl`) with the `+JDdump true` flag. This flag instructs the JIT (Just-In-Time) compiler to dump the generated native assembly code for all loaded modules into files with the `.asm` extension for inspection.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nerl +JDdump true\n```\n\n----------------------------------------\n\nTITLE: Running ETS ordered_set Benchmark Script\nDESCRIPTION: Bash commands demonstrating how to run the benchmark escript with different parameters to compare the performance of the old and new ETS ordered_set implementations on a two-core machine.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-8-19-the-new-scalable-ets-ordered_set.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ escript insert_disjoint_ranges.erl old 1 10000000\nTime: 3.352332 seconds\n$ escript insert_disjoint_ranges.erl old 2 10000000\nTime: 3.961732 seconds\n$ escript insert_disjoint_ranges.erl old 4 10000000\nTime: 6.382199 seconds\n$ escript insert_disjoint_ranges.erl new 1 10000000\nTime: 3.832119 seconds\n$ escript insert_disjoint_ranges.erl new 2 10000000\nTime: 2.109476 seconds\n$ escript insert_disjoint_ranges.erl new 4 10000000\nTime: 1.66509 seconds\n```\n\n----------------------------------------\n\nTITLE: OTP-21 Optimized BEAM Instruction Implementation\nDESCRIPTION: Improved implementation using relative jump labels introduced in OTP-21. Demonstrates how the instruction uses 32-bit offset values for jumps instead of full pointers, resulting in reduced memory usage.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-6-11-Interpreter-Optimizations.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nif (reg[0] != I[1]) {\n  I += I[0] >> 32;\n  goto *(void**)(Uint64)(Uint32)I;\n}\nI+=2;\ngoto *(void**)(Uint64)(Uint32)I;\n```\n\n----------------------------------------\n\nTITLE: Double Xorshift Scrambler Implementation in Erlang\nDESCRIPTION: Implementation of a double Xorshift scrambler using shifts of 4 and 27 for improved randomness distribution.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_21\n\nLANGUAGE: erlang\nCODE:\n```\nV1 = T bxor (T bsl 4),\nV  = V1 bxor (V1 bsl 27).\n```\n\n----------------------------------------\n\nTITLE: Optimized Test Heap Implementation with Global Fragment\nDESCRIPTION: Improved version of test_heap implementation that reduces code bloat by separating the functionality into module-specific and global shared parts.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-11-10-jit-part-2.md#2025-04-22_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nvoid BeamModuleAssembler::emit_test_heap(const ArgVal &Needed,\n                                         const ArgVal &Live) {\n    const int words_needed = (Needed.getValue() + S_RESERVED);\n    Label after_gc_check = a.newLabel();\n\n    a.lea(ARG2, x86::qword_ptr(HTOP, words_needed * sizeof(Eterm)));\n    a.cmp(ARG2, E);\n    a.jbe(after_gc_check);\n\n    a.mov(ARG4, imm(Live.getValue()));\n\n    /* Call the global \"garbage collect\" fragment. */\n    fragment_call(ga->get_garbage_collect());\n\n    a.bind(after_gc_check);\n}\n\n/* This is the global part of the instruction. Since we\n * know it will only be called from the module code above,\n * we're free to assume that ARG4 is the number of live\n * registers and that ARG2 is (HTOP + bytes needed). */\nvoid BeamGlobalAssembler::emit_garbage_collect() {\n    /* Convert ARG2 to \"words needed\" by subtracting\n     * HTOP and dividing it by 8.\n     *\n     * This saves us from having to explicitly pass\n     * \"words needed\" in the module code above. */\n    a.sub(ARG2, HTOP);\n    a.shr(ARG2, imm(3));\n\n    emit_enter_runtime<Update::eStack | Update::eHeap>();\n\n    /* ARG2 and ARG4 have already been set earlier. */\n    a.mov(ARG1, c_p);\n    load_x_reg_array(ARG3);\n    a.mov(ARG5, FCALLS);\n    runtime_call<5>(erts_garbage_collect_nobump);\n    a.sub(FCALLS, RET);\n\n    emit_leave_runtime<Update::eStack | Update::eHeap>();\n\n    a.ret();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Lock Counting Collection Functions in Erlang\nDESCRIPTION: Reference to lcnt:collect and lcnt:clear functions which now operate without blocking other threads in the runtime system, allowing lock counting to be used under heavier load conditions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/115.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nlcnt:collect\n```\n\nLANGUAGE: erlang\nCODE:\n```\nlcnt:clear\n```\n\n----------------------------------------\n\nTITLE: Pre-OTP-21 BEAM Instruction Implementation\nDESCRIPTION: Original implementation of is_eq_exact_immed_frc instruction before OTP-21. Shows how the instruction handles equality comparison and branching using absolute pointers for jump addresses.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-6-11-Interpreter-Optimizations.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nif (reg[0] != I[2]) {\n  I = I[1];\n  goto *(void**)I;\n}\nI+=3;\ngoto *(void**)I;\n```\n\n----------------------------------------\n\nTITLE: Running ehead Script with Invalid Option Value in Erlang\nDESCRIPTION: Output when running the ehead script with an invalid value for the lines option, demonstrating how argparse validates input according to specified constraints. In this case, the minimum value constraint is violated.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\n$ ehead -n 0 foobar\nerror: ehead: invalid argument for lines: 0 is less than accepted minimum\nUsage:\n  ehead [-n <lines>] [--lines <lines>] <files>...\n\nArguments:\n  files       lists of files\n\nOptional arguments:\n  -n, --lines number of lines to print (int >= 1, 10)\n```\n\n----------------------------------------\n\nTITLE: Base64 Encoding Implementation in OTP 25\nDESCRIPTION: Traditional Base64 encoding implementation using 8-bit segments for binary matching, as used in OTP 25.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_32\n\nLANGUAGE: erlang\nCODE:\n```\nencode_binary(<<B1:8, B2:8, B3:8, Ls/bits>>, A) ->\n    BB = (B1 bsl 16) bor (B2 bsl 8) bor B3,\n    encode_binary(Ls,\n                  <<A/bits,(b64e(BB bsr 18)):8,\n                    (b64e((BB bsr 12) band 63)):8,\n                    (b64e((BB bsr 6) band 63)):8,\n                    (b64e(BB band 63)):8>>).\n```\n\n----------------------------------------\n\nTITLE: Simple case expression in Erlang\nDESCRIPTION: This snippet shows how a basic case expression is translated into SSA and BEAM code. It introduces the switch instruction for multi-way branching.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ncase1(X) ->\n    case X of\n        1 -> a;\n        2 -> b;\n        _ -> c\n    end.\n```\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:case1(_0) {\n0:\n  switch _0, label 3, [ { literal 2, label 5 }, { literal 1, label 4 } ]\n\n4:\n  ret literal a\n\n5:\n  ret literal b\n\n3:\n  ret literal c\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang/OTP 26.0-rc1 with kerl\nDESCRIPTION: Command showing how to install the release candidate using kerl, a tool for managing Erlang installations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/160.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkerl build 26.0-rc1 26.0-rc1\n```\n\n----------------------------------------\n\nTITLE: Generating Partially Optimized Erlang SSA Listing using erlc\nDESCRIPTION: Provides an example `erlc` command that generates optimized SSA code (`+dssaopt`) while disabling specific optimization passes (`+no_ssa_opt_type`, `+no_ssa_opt_live`, `+no_ssa_opt_merge_blocks`) for `blog.erl`. This technique is primarily intended for debugging or understanding the impact of individual optimization passes, as disabling mandatory passes can crash the compiler.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nerlc +dssaopt +no_ssa_opt_type +no_ssa_opt_live +no_ssa_opt_merge_blocks blog.erl\n```\n\n----------------------------------------\n\nTITLE: Translating Complex Case to Unoptimized Core Erlang\nDESCRIPTION: This snippet shows the unoptimized Core Erlang representation of the `aa/0` function. It translates the Erlang `case` into a Core Erlang `case` operating on the constant tuple `{'a', 'tuple'}`, including clauses for list matching, tuple matching, wildcard matching, and a final `match_fail` primop.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\n'aa'/0 =\n    fun () ->\n      case {'a','tuple'} of\n\t<[List|[]]> when 'true' ->\n\t    List\n\t<{A,B}> when 'true' ->\n\t    {'tuple',A,B}\n\t<_@c1> when 'true' ->\n\t    'something_else'\n\t<_@c0> when 'true' ->\n\t    primop 'match_fail'({'case_clause',_@c0})\n      end\n```\n\n----------------------------------------\n\nTITLE: BEAM Bytecode for Map Size Comparison\nDESCRIPTION: Shows BEAM code for map_size operations and type-propagated less-than test, including range-constrained integer types for both operands. Outputs result atoms as in Erlang semantic. Depends on VM and BEAM conventions for register and type tracking.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_16\n\nLANGUAGE: \nCODE:\n```\n    {gc_bif,map_size,{f,12},2,[{x,0}],{x,0}}.\n    {gc_bif,map_size,{f,12},2,[{x,1}],{x,1}}.\n    {test,is_lt,\n          {f,12},\n          [{tr,{x,0},{t_integer,{0,288230376151711743}}},\n           {tr,{x,1},{t_integer,{0,288230376151711743}}}]}.\n    {move,{atom,smaller},{x,0}}.\n    return.\n  {label,12}.\n    {move,{atom,larger_or_equal},{x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Managing Replies and Timeouts with Process Aliases - Erlang\nDESCRIPTION: Contrasts classic monitor-based call handling with the new alias-based solution from EEP-53. The first snippet shows using 'erlang:monitor' and message pattern-matching for replies and timeouts, which leads to leftover messages when timeouts occur. The updated snippet replaces the MonRef with a MonAlias and passes alias-specific options; late or irrelevant replies are dropped, preventing mailbox clutter. Dependencies: standard Erlang/OTP and understanding of process monitoring. Key parameters include the recipient process ('To'), message, and timeout. Inputs are process identifiers and messages; outputs are tuples or errors. Constraint: Only available in Erlang/OTP 24 and later.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\ncall(To, Msg, Tmo) ->\n  MonRef = erlang:monitor(process, To),\n  To ! {call, MonRef, self(), Msg},\n  receive\n    {'DOWN',MonRef,_,_,Reason} ->\n      {error, Reason};\n    {reply, MonRef, Reply}\n      erlang:demonitor(MonRef,[flush]),\n      {ok, Reply}\n    after Tmo ->\n      erlang:demonitor(MonRef,[flush]),\n      {error, timeout}\n  end.\n```\n\nLANGUAGE: erlang\nCODE:\n```\ncall(To, Msg, Tmo) ->\n  MonAlias = erlang:monitor(process, To, [{alias, demonitor}]),\n  To ! {call, MonAlias, MonAlias, Msg},\n  receive\n    {'DOWN', MonAlias, _ , _, Reason} ->\n      {error, Reason};\n    {reply, MonAlias, Reply}\n      erlang:demonitor(MonAlias,[flush]),\n      {ok, Reply}\n    after Tmo ->\n      erlang:demonitor(MonAlias,[flush]),\n      {error, timeout}\n  end.\n```\n\n----------------------------------------\n\nTITLE: Using NIF Function for Term Type Checking in Erlang\nDESCRIPTION: References the new NIF function enif_term_type which returns the type of a given term, helping to avoid long sequences of enif_is_xyz checks. This is especially useful for NIFs that serialize terms.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/129.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nenif_term_type\n```\n\n----------------------------------------\n\nTITLE: Emitting BEAM timeout Using a C++ Escape Hatch - C++\nDESCRIPTION: Defines a static C++ function implementing the 'timeout' behavior, then emits a function call to it within a BEAMModuleAssembler method. This escape hatch allows invoking complex interpreter logic from JIT-generated code without reimplementing everything in assembly. Dependencies: the static 'timeout' function, asmjit emitter, and conventions for setting arguments (here, the process pointer). Accepts no explicit inputs in the assembler method (uses the current process), and outputs machine code to call the C++ function from JIT-compiled code. This approach simplifies JIT development but introduces a dependency on C linkage and calling conventions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-11-03-a-first-look-at-the-jit.md#2025-04-22_snippet_2\n\nLANGUAGE: c++\nCODE:\n```\nstatic void timeout(Process *c_p) {\n    if (IS_TRACED_FL(c_p, F_TRACE_RECEIVE)) {\n        trace_receive(c_p, am_clock_service, am_timeout, NULL);\n    }\n    if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {\n        save_calls(c_p, &exp_timeout);\n    }\n    c_p->flags &= ~F_TIMO;\n    JOIN_MESSAGE(c_p);\n}\n\nvoid BeamModuleAssembler::emit_timeout() {\n    /* Set the first C argument to our currently executing\n     * process, c_p, and then call the above C function. */\n    a.mov(ARG1, c_p);\n    a.call(imm(timeout));\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Function with Incorrect Binary Encoding in Erlang Shell\nDESCRIPTION: Shows the incorrect output when calling the `t:greek_quote/0` function that uses a binary literal without the `/utf8` specifier. The Greek characters are garbled because the binary's bytes are interpreted incorrectly by `io:format(\"~ts\", ...)`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_11\n\nLANGUAGE: erlang\nCODE:\n```\n2> t:greek_quote().\n\"Know thyself\" (Greek: “½ö¸¹ Ã±ÅÄÌ½)\n```\n\n----------------------------------------\n\nTITLE: Profiling Dialyzer PLT Build with perf and ERL_FLAGS - Shell Command\nDESCRIPTION: This advanced example demonstrates running dialyzer with Java JIT profiling enabled and single scheduler ('+S 1') for easier analysis, while recording a perf profile. The command uses ERL_FLAGS, specific dialyzer options, and records call graphs for detailed function-level performance analysis. Requires bash shell, perf, Erlang/OTP 25+, and dialyzer. Inputs and outputs depend on the dialyzer run. Limitations include the potentially long duration and large volume of trace data produced during analysis.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-18-My-OTP-25-highlights.md#2025-04-22_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n ERL_FLAGS=\"+JPperf true +S 1\" perf record --call-graph=fp \\\n   dialyzer --build_plt -Wunknown --apps compiler crypto erts kernel stdlib \\\n   syntax_tools asn1 edoc et ftp inets mnesia observer public_key \\\n   sasl runtime_tools snmp ssl tftp wx xmerl tools\n```\n\n----------------------------------------\n\nTITLE: Referencing Dirty Scheduler Allocator Instance Command Option in Erlang\nDESCRIPTION: The +Mdai command line argument enables dirty scheduler specific allocator instances which are disabled by default in the Erlang Runtime System (ERTS).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/152.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n+Mdai\n```\n\n----------------------------------------\n\nTITLE: Intermediate Core Erlang Optimization Step for Tuple Avoidance\nDESCRIPTION: This snippet shows an intermediate optimization step for `c/1` by `sys_core_fold`. The inner `case` is modified to return a value list (`<10, 1>`, `<20, 2>`, etc.) instead of a tuple. This value list is then bound to temporary variables (`_@f4`, `_@f5`) using a `let`. However, a tuple is still constructed from these variables (`{_@f4, _@f5}`) and matched in the subsequent `case`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_19\n\nLANGUAGE: erlang\nCODE:\n```\n'c'/1 =\n    fun (_@c0) ->\n\tlet <_@f4,_@f5> =\n\t    case _@c0 of\n\t      <'a1'> when 'true' ->\n\t\t  <10,1>\n\t      <'b2'> when 'true' ->\n\t\t  <20,2>\n\t      <_@c5> when 'true' ->\n\t\t  <100,42>\n\t    end\n\tin\n            let <_@c2> = {_@f4,_@f5}\n            in\n\t          case _@c2 of\n\t\t    <{A,B}> when 'true' ->\n\t\t\tcall 'erlang':'+'(A, B)\n\t\t    <_@c3> when 'true' ->\n\t\t\t  primop 'match_fail'({'badmatch',_@c3})\n\t\t  end\n\tend\n```\n\n----------------------------------------\n\nTITLE: Fun Creation in Erlang/OTP 26 (x86_64 Assembly)\nDESCRIPTION: Assembly code for creating function closures (funs) in Erlang/OTP 26, which requires calling a helper function in the runtime system to set up the fun object.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_17\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\n# i_make_fun3_FStt\nL38:\n    long mov rsi, 9223372036854775807 ; Placeholder for dispatch table\n    mov edx, 1\n    mov ecx, 2\n    mov qword ptr [r13+80], r15\n    mov rbp, rsp\n    lea rsp, qword ptr [rbx-128]\n    vzeroupper\n    mov rdi, r13\n    call 4337160320       ; Call helper function in runtime system\n    mov rsp, rbp\n    mov r15, qword ptr [r13+80]\n# Move fun environment\n    mov rdi, qword ptr [rbx]\n    mov qword ptr [rax+40], rdi\n    mov rdi, qword ptr [rbx+8]\n    mov qword ptr [rax+48], rdi\n# Create boxed ptr\n    or al, 2\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Using timer:apply_after with remote fun in Erlang/OTP 27\nDESCRIPTION: Example showing how to use timer:apply_after with a remote fun and its arguments in Erlang/OTP 27, which is useful for hot code updating scenarios.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_36\n\nLANGUAGE: erlang\nCODE:\n```\ntimer:apply_after(10, fun io:put_chars/1, [\"now\\n\"]).\n```\n\n----------------------------------------\n\nTITLE: Generated C++ code for is_nonempty_list instruction\nDESCRIPTION: This snippet shows the C++ code generated by the beam_makeops script for the is_nonempty_list instruction. It includes argument handling, register access, and control flow logic.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-27-a-closer-look-at-the-interpreter.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n/* (This has been modified slightly for readability) */\ncase is_nonempty_list_fx:\n{\n    Eterm arg_word, term;\n\n    /* Read the argument word from the instruction\n     * stream. */\n    arg_word = I[1];\n\n    /* Unpack the offset of our source register (upper\n     * 32 bits) and then read its contents.\n     *\n     * Note that we address the X registers directly;\n     * had this instruction not been specialized, we\n     * would first need to determine whether the\n     * argument was an X or a Y register. */\n    term = x_registers[arg_word >> 32];\n\n    /* is_not_list(term) */\n    if (term & (_TAG_PRIMARY_MASK - TAG_PRIMARY_LIST)) {\n\n        /* Unpack our fail label (lower 32 bits) and add\n         * it to our current instruction pointer. This\n         * is an offset and may be negative for backward\n         * jumps. */\n        I += (Sint32)arg_word;\n\n        /* Jump to the instruction at the fail label using\n         * the \"labels as values\" GCC extension. */\n        goto *I;\n    }\n\n    /* Skip the current label address and argument word,\n     * then jump to the next instruction. This was\n     * automatically generated by beam_makeops. */\n    I += 2;\n    goto *I;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing External Calls in BEAM/C using GCC Label Extensions\nDESCRIPTION: This snippet demonstrates how BEAM/C implemented external function calls using GCC's label address extension. It involves pushing the return address to the stack and jumping to a label in another C function.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-12-01-the-road-to-the-jit.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ngoto *label_address;\n```\n\n----------------------------------------\n\nTITLE: BEAM Bytecode for Guarded Range Addition - BEAM\nDESCRIPTION: The BEAM bytecode for add4/2 with natural guards is shown here. It emits separate test instructions for type and range, but does not combine them, so {tr,{x,N},{t_integer,any}} does not get a specific range. Consequently, the + instruction operates with generic integer types, which limits per-guard optimization. Used by JIT in earlier OTP versions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_9\n\nLANGUAGE: BEAM (Erlang VM bytecode)\nCODE:\n```\n    {test,is_integer,{f,22},[{x,0}]}.\n    {test,is_ge,{f,22},[{tr,{x,0},{t_integer,any}},{integer,0}]}.\n    {test,is_lt,{f,22},[{tr,{x,0},{t_integer,any}},{integer,1024}]}.\n    {test,is_integer,{f,22},[{x,1}]}.\n    {test,is_ge,{f,22},[{tr,{x,1},{t_integer,any}},{integer,0}]}.\n    {test,is_lt,{f,22},[{tr,{x,1},{t_integer,any}},{integer,1024}]}.\n    {gc_bif,'+',\n            {f,0},\n            2,\n            [{tr,{x,0},{t_integer,any}},{tr,{x,1},{t_integer,any}}],\n            {x,0}}.\n    return.\n\n```\n\n----------------------------------------\n\nTITLE: Erlang Function with Simple Case Statement\nDESCRIPTION: This snippet shows a simple Erlang function with a case statement that assigns different values to Y based on the input X.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_9\n\nLANGUAGE: erlang\nCODE:\n```\nbar(X) ->\n    case X of\n        none ->\n            Y = 0;\n        _ ->\n            Y = X\n    end,\n    Y + 1.\n```\n\n----------------------------------------\n\nTITLE: SSA Code After Record Optimization in Erlang\nDESCRIPTION: This snippet demonstrates the result of the record optimization pass, which replaces tuple matching instructions with an 'is_tagged_tuple' instruction.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n  br @ssa_bool:8, label 5, label 3\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n\n4:\n  _7 = get_tuple_element _0, literal 1\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n  br label 10\n\n10:\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Erlang BEAM Assembly Listing using erlc\nDESCRIPTION: Demonstrates using the `erlc` command with the `-S` flag to compile an Erlang module (`blog.erl`) and generate its corresponding BEAM assembly code. The output is saved by default to a file named `blog.S`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nerlc -S blog.erl\n```\n\n----------------------------------------\n\nTITLE: Optimized Core Erlang for update_record Function\nDESCRIPTION: This snippet shows the optimized Core Erlang representation of the update_record function after the sys_core_dsetel optimization.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_12\n\nLANGUAGE: erlang\nCODE:\n```\n'update_record'/1 =\n    fun (_0) ->\n\tcase _0 of\n\t  <{'rec',_5,_6,_7,_8,_9,_10,_11,_12}> when 'true' ->\n\t      let <_2> =\n\t\t  call 'erlang':'setelement'(3, _0, 'y')\n\t      in  do  primop 'dsetelement'(2, _2, 'x')\n\t\t      _2\n\t  <_13> when 'true' ->\n\t\tcall 'erlang':'error'({'badrecord','rec'})\n\tend\n```\n\n----------------------------------------\n\nTITLE: SSA Intermediate Representation Code\nDESCRIPTION: The SSA (Static Single Assignment) representation of the foo/1 function showing block structure, variable assignments, and control flow. Demonstrates how tuple matching and construction are handled in the intermediate format.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = bif:is_tuple _0\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n  br @ssa_bool:8, label 5, label 3\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n\n4:\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n\n%% Unreachable blocks\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\n----------------------------------------\n\nTITLE: Creating News Item Template in Markdown for Erlang.org\nDESCRIPTION: This snippet provides a template for creating news items on the Erlang.org website. It includes front matter with metadata such as ID, layout, title, lead, date, and author, followed by the main content in markdown format.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nid: 140\nlayout: post\ntitle: \"My new news item\"\nlead: \"The lead shown on index.html\"\ndate: \"2020-05-13\"\nauthor: \"John Doe\"\n---\nSome markdown\n\n## Sub title\n\nSome more markdown\n```\n\n----------------------------------------\n\nTITLE: Using Format Modifiers for Ordered Map Printing\nDESCRIPTION: Shows the new k and K modifiers for io:format() that support printing map elements in a deterministic order.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nio:format()\n```\n\n----------------------------------------\n\nTITLE: Generic Fallback Routine Invocation for Addition - x86-64 Assembly\nDESCRIPTION: When either operand is not a small integer or addition overflows, execution jumps to a routine that can handle all BEAM term types, including bignums and floats, and will raise exceptions when necessary. Represents slow path in BEAM JIT arithmetic.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_24\n\nLANGUAGE: nasm\nCODE:\n```\nL15:\\n    call 4328985696\n```\n\n----------------------------------------\n\nTITLE: Compiling an Erlang Module to View BEAM Code - Bash\nDESCRIPTION: This bash command compiles an Erlang source file (e.g., base64.erl) with the -S flag, which emits readable BEAM assembly code. It is used to inspect BEAM bytecode internals before native JIT compilation. Requires the erlc compiler from an installed Erlang/OTP distribution. Input: Erlang source file; Output: .S file with BEAM assembly.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nerlc -S base64.erl\n\n```\n\n----------------------------------------\n\nTITLE: Erlang Distribution Configuration Options\nDESCRIPTION: New configuration options for running Erlang distribution without EPMD dependency.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/139.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-dist_listen false\n```\n\nLANGUAGE: erlang\nCODE:\n```\n-erl_epmd_port Port\n```\n\n----------------------------------------\n\nTITLE: JIT Small Integer Type Test for Addition - x86-64 Assembly\nDESCRIPTION: Evaluates whether both operands are small integers via mask and compares, branching on first failed type match. Used by BEAM JIT to avoid costly generic arithmetic when possible. Relies on correct small integer representation for Erlang terms, using low four bits as tag.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_22\n\nLANGUAGE: nasm\nCODE:\n```\n# are both operands small?\\n    mov eax, esi\\n    and eax, edx\\n    and al, 15\\n    cmp al, 15\\n    short jne L15\n```\n\n----------------------------------------\n\nTITLE: Generated Erlang Module Listing\nDESCRIPTION: Shows the content of the generated 'trivial.P' file, which is the result of pretty-printing the abstract format back to Erlang source code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n-file(\"trivial.erl\", 1).\n\n-module(trivial).\n\n-export([example/4]).\n\n-record(rec,{mod,func,result}).\n\nexample(A, B, C, D) ->\n    #rec{mod = trivial,func = example,result = A + B * C * (D + 42)}.\n```\n\n----------------------------------------\n\nTITLE: Comparison and Type Dispatch Logic - x86-64 Assembly\nDESCRIPTION: Performs actual integer comparison (cmp) and manages control flow, jumping to generic routines if types aren't compatible, or to the failure label if comparison fails. Highlights how conditional jumps are chained with generic Erlang type support routines, and integrates both fast type-specific and slow generic logic.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_11\n\nLANGUAGE: nasm\nCODE:\n```\n    cmp rdi, rsi\\n    short jmp L40\\nL39:\\n    call 5447639136\\nL40:\\n    jge label_9\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Faster Runtime Termination in Erlang/OTP 24.1\nDESCRIPTION: Shows the init:stop() function that no longer unloads loaded code before terminating the runtime system, which improves termination speed especially on systems with slow CPUs like Raspberry PI Zero.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/149.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ninit:stop()\n```\n\n----------------------------------------\n\nTITLE: JIT Addition, Fallback, and Overflow Detection - x86-64 Assembly\nDESCRIPTION: Actual execution of BEAM '+', calling out to generic handler if operands are not small or if addition overflows. Integrates BEAM's boxed and unboxed number handling with optimal native addition for the common small integer path. Assumes prior small integer test passed before addition logic.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_23\n\nLANGUAGE: nasm\nCODE:\n```\n# add with overflow check\\n    mov rax, rsi\\n    mov rcx, rdx\\n    and rcx, -16\\n    add rax, rcx\\n    short jno L14\n```\n\n----------------------------------------\n\nTITLE: BEAM code for bitwise range constraint approach\nDESCRIPTION: The BEAM code for the add5 function showing how the bitwise approach successfully constrains operand ranges to 0-1023, allowing for more efficient code generation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_33\n\nLANGUAGE: text\nCODE:\n```\n    {gc_bif,'band',{f,21},2,[{x,0},{integer,1023}],{x,2}}.\n    {test,is_eq_exact,\n          {f,21},\n          [{tr,{x,0},{t_integer,any}},{tr,{x,2},{t_integer,{0,1023}}}}]}.\n    {gc_bif,'band',{f,21},2,[{x,1},{integer,1023}],{x,2}}.\n    {test,is_eq_exact,\n          {f,21},\n          [{tr,{x,1},{t_integer,any}},{tr,{x,2},{t_integer,{0,1023}}}}]}.\n    {gc_bif,'+',\n            {f,0},\n            2,\n            [{tr,{x,0},{t_integer,{0,1023}}},{tr,{x,1},{t_integer,{0,1023}}}],\n            {x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Viewing JIT-Compiled x86 Machine Code for mwc59 (bsr) in NASM\nDESCRIPTION: Presents the beginning of the x86 assembly (NASM syntax) code produced by the Erlang JIT compiler for the `mwc59` function, specifically showing the start of the implementation for the bit shift right (`bsr`) operation, identified by the label `# i_bsr_ssjd`. It shows the `mov` instruction loading data into the `rsi` register from memory pointed to by `rbx`.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_8\n\nLANGUAGE: nasm\nCODE:\n```\n# i_bsr_ssjd\n    mov rsi, qword ptr [rbx]\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang to Optimized Core Erlang Listing (Shell)\nDESCRIPTION: This shell command uses the Erlang compiler (`erlc`) to compile an Erlang file (`core_fold_example.erl`) and generate a Core Erlang listing after optimizations by the `sys_core_fold` pass. The `+time` option displays compilation pass times, and `+dcopt` creates a `.copt` file showing the Core Erlang code after the `sys_core_fold` pass has run.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ erlc +time +dcopt core_fold_example.erl\nCompiling \"core_fold_example\"\n parse_module                  :      0.000 s       9.4 kB\n transform_module              :      0.000 s       9.4 kB\n lint_module                   :      0.002 s       9.4 kB\n expand_records                :      0.000 s       9.4 kB\n core                          :      0.000 s      59.3 kB\n sys_core_fold                 :      0.000 s      25.3 kB\n core_transforms               :      0.000 s      25.3 kB\n listing                       :      0.002 s      25.3 kB\n```\n\n----------------------------------------\n\nTITLE: Calling a BIF that may fail in Erlang\nDESCRIPTION: This snippet demonstrates how a function calling the element/2 BIF, which may fail, is represented in SSA and BEAM code. It shows error handling and control flow in SSA.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nelement_body(T) ->\n    element(2, T).\n```\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:element_body(_0) {\n0:\n  %% blog.erl:5\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n  br @ssa_bool, label 3, label 1\n\n3:\n  ret _1\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\n----------------------------------------\n\nTITLE: Improved BEAM Code for Tuple Construction in Erlang\nDESCRIPTION: This snippet demonstrates a proposed improvement to tuple construction in BEAM code, introducing a new 'put_tuple2' instruction to eliminate the need for a 'move' instruction.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\n{test_heap,3,1}.\n{put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\nreturn.\n```\n\n----------------------------------------\n\nTITLE: BEAM Code for Simple Erlang Function\nDESCRIPTION: Shows the BEAM assembly code generated for the 'foo' function, including stack allocation, register operations, and function calls.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\n{allocate,1,2}.\n{move,{x,0},{y,0}}.\n{move,{x,1},{x,0}}.\n{line,[{location,\"blog.erl\",5}]}.\n{call_ext,1,{extfunc,lists,sum,1}}.\n{line,[{location,\"blog.erl\",6}]}.\n{gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n{deallocate,1}.\nreturn.\n```\n\n----------------------------------------\n\nTITLE: BEAM Assembly Representation of MWC59 with Type Information\nDESCRIPTION: The BEAM assembly code generated for the MWC59 PRNG implementation showing how type information is propagated through the operations after the initial input band operation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n    {gc_bif,'band',{f,0},1,[{x,0},{integer,576460752303423487}],{x,0}}.\n    {gc_bif,'bsr',{f,0},1,[{tr,{x,0},{t_integer,{0,576460752303423487}}},\n             {integer,32}],{x,1}}.\n    {gc_bif,'band',{f,0},2,[{tr,{x,0},{t_integer,{0,576460752303423487}}},\n             {integer,4294967295}],{x,0}}.\n    {gc_bif,'*',{f,0},2,[{tr,{x,0},{t_integer,{0,4294967295}}},\n             {integer,133850370}],{x,0}}.\n    {gc_bif,'+',{f,0},2,[{tr,{x,0},{t_integer,{0,572367635452168875}}},\n             {tr,{x,1},{t_integer,{0,134217727}}}],{x,0}}.\n```\n\n----------------------------------------\n\nTITLE: Updating Record Fields in Assembly (x86-64)\nDESCRIPTION: This assembly code snippet demonstrates how the Erlang JIT compiler optimizes record field updates. It includes conditional copying based on the 'reuse' hint and uses AVX instructions for efficient memory operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_21\n\nLANGUAGE: nasm\nCODE:\n```\n# update_record_aIsdI\n    mov rax, qword ptr [rbx]\n    mov rdi, rax\n    cmp qword ptr [rdi+14], 687\n    je L130\n    vmovups xmm0, [rax-2]\n    vmovups [r15], xmm0\n    mov qword ptr [r15+16], 687\n    vmovups ymm0, [rax+22]\n    vmovups [r15+24], ymm0\n    lea rax, qword ptr [r15+2]\n    add r15, 56\nL130:\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Emitting Timeout Function in BEAM JIT\nDESCRIPTION: Implementation of the timeout instruction emission in the BEAM JIT compiler. Shows how to properly handle stack switching between C and Erlang execution contexts.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-11-10-jit-part-2.md#2025-04-22_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nvoid BeamModuleAssembler::emit_timeout() {\n    /* Swap to the C stack. */\n    emit_enter_runtime();\n\n    /* Call the `timeout` C function.\n     *\n     * runtime_call compiles down to a single `call`\n     * instruction in optimized builds, and has a few\n     * assertions in debug builds to prevent mistakes\n     * like forgetting to switch stacks. */\n    a.mov(ARG1, c_p);\n    runtime_call<1>(timeout);\n\n    /* Swap back to the Erlang stack. */\n    emit_leave_runtime();\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized JIT Code for Bitwise AND with Type Information\nDESCRIPTION: JIT-compiled assembly code for the bitwise AND operation that still includes operand testing and fallback code since it operates on the input with unknown characteristics.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_16\n\nLANGUAGE: nasm\nCODE:\n```\n# i_band_ssjd\n    mov rsi, qword ptr [rbx]\n    mov rax, 9223372036854775807\n# is the operand small?\n    mov edi, esi\n    and edi, 15\n    cmp edi, 15\n    short jne L1816\n    and rax, rsi\n    short jmp L1817\nL1816:\n    call 139812177115776\nL1817:\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang Module to BEAM Assembly (Bash)\nDESCRIPTION: This command uses the Erlang compiler (`erlc`) with the `-S` option to compile the `base64.erl` module. Instead of generating a `.beam` file, the `-S` flag outputs the intermediate BEAM assembly code to a file (typically `base64.S`), allowing developers to examine the instructions generated by the compiler before JIT compilation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nerlc -S base64.erl\n```\n\n----------------------------------------\n\nTITLE: Eliminating Phi Instructions in BEAM Code Generation\nDESCRIPTION: This snippet illustrates how phi instructions are eliminated when generating BEAM code, showing a non-SSA representation that gives an idea of the process.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n%% Not SSA code!\nfunction blog:case3a(_0) {\n0:\n  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]\n\n5:\n  Y := literal 0\n  br label 3\n\n6:\n  Y := _0\n  br label 3\n\n4:\n  Y := no_idea\n  br label 3\n\n3:\n  _7 = put_tuple literal ok, Y\n  ret _7\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bitwise AND Operation in BEAM Assembly\nDESCRIPTION: Assembly code for the Erlang 'band' (bitwise AND) operation with small integer test and fallback path for non-small integer values.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_11\n\nLANGUAGE: nasm\nCODE:\n```\n# i_band_ssjd\n    mov rsi, qword ptr [rbx]\n    mov rax, 68719476735\n# is the operand small?\n    mov edi, esi\n    and edi, 15\n    cmp edi, 15\n    short jne L2273\n    and rax, rsi\n    short jmp L2274\nL2273:\n    call 140439031216768\nL2274:\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Tag Testing for Small Integers\nDESCRIPTION: Assembly code that tests if a value is a properly tagged small integer by checking if the 4 least significant bits are zero after tag value subtraction.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_14\n\nLANGUAGE: nasm\nCODE:\n```\ntest al, 15\nshort jne label_19\n```\n\n----------------------------------------\n\nTITLE: Numeric Literals with Underscore in Erlang\nDESCRIPTION: Examples of valid numeric literals using underscores for improved readability, showing different number formats and bases.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\n305441741123_456\n1_2_3_4_5\n123_456.789_123\n1.0e1_23\n16#DEAD_BEEF\n2#1100_1010_0011\n```\n\n----------------------------------------\n\nTITLE: Optimized JIT Code for MWC59 Operations\nDESCRIPTION: The optimized assembly code for the remaining MWC59 operations where type information has enabled the elimination of small integer tests and fallback code, resulting in straight-line machine code execution.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_17\n\nLANGUAGE: nasm\nCODE:\n```\n# line_I\n# i_bsr_ssjd\n    mov rsi, qword ptr [rbx]\n# skipped test for small left operand because it is always small\n    mov rax, rsi\n    sar rax, 32\n    or rax, 15\nL1818:\nL1819:\n    mov qword ptr [rbx+8], rax\n# line_I\n# i_band_ssjd\n    mov rsi, qword ptr [rbx]\n    mov rax, 68719476735\n# skipped test for small operands since they are always small\n    and rax, rsi\n    mov qword ptr [rbx], rax\n# line_I\n# i_times_jssd\n# multiplication without overflow check\n    mov rax, qword ptr [rbx]\n    mov esi, 2141605935\n    and rax, -16\n    sar rsi, 4\n    imul rax, rsi\n    or rax, 15\n    mov qword ptr [rbx], rax\n# i_plus_ssjd\n# add without overflow check\n    mov rax, qword ptr [rbx]\n    mov rsi, qword ptr [rbx+8]\n    and rax, -16\n    add rax, rsi\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Enhanced BEAM Bytecode with Propagated Ranges (OTP 26) - BEAM\nDESCRIPTION: This BEAM bytecode reflects the improvements in OTP 26, where range analysis allows the compiler to propagate integer ranges in guard branches and thus into the gc_bif '+'. The third line's {tr,{x,0},{t_integer,{0,'+inf'}}} enables subsequent instructions to deduce type narrowing and perform more efficient codegen. Inputs: register values; Output: Integer sum or guard failure.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_10\n\nLANGUAGE: BEAM (Erlang VM bytecode)\nCODE:\n```\n    {test,is_integer,{f,19},[{x,0}]}.\n    {test,is_ge,{f,19},[{tr,{x,0},{t_integer,any}},{integer,0}]}.\n    {test,is_ge,{f,19},[{integer,1023},{tr,{x,0},{t_integer,{0,'+inf'}}}]}.\n    {test,is_integer,{f,19},[{x,1}]}.\n    {test,is_ge,{f,19},[{tr,{x,1},{t_integer,any}},{integer,0}]}.\n    {test,is_ge,{f,19},[{integer,1023},{tr,{x,1},{t_integer,{0,'+inf'}}}]}.\n    {gc_bif,'+',\n            {f,0},\n            2,\n            [{tr,{x,0},{t_integer,{0,1023}}},{tr,{x,1},{t_integer,{0,1023}}}],\n            {x,0}}.\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Expansion Functions in Erlang\nDESCRIPTION: Module demonstrating two approaches to expand binary data - using recursive appending and binary comprehension. Each function doubles the size of input binary by expanding each byte to two bytes.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_30\n\nLANGUAGE: erlang\nCODE:\n```\n-module(append).\n-export([expand/1, expand_bc/1]).\n\nexpand(Bin) when is_binary(Bin) ->\n    expand(Bin, <<>>).\n\nexpand(<<B:8,T/binary>>, Acc) ->\n    expand(T, <<Acc/binary,B:16>>);\nexpand(<<>>, Acc) ->\n    Acc.\n\nexpand_bc(Bin) when is_binary(Bin) ->\n    << <<B:16>> || <<B:8>> <= Bin >>.\n```\n\n----------------------------------------\n\nTITLE: Fetching BEAM Registers for Operand Comparison - x86-64 Assembly\nDESCRIPTION: These instructions load values from the BEAM virtual machine's registers into x86-64 CPU registers to prepare for later operations, such as comparison or arithmetic. Used frequently as a prelude to type or value operations in the BEAM JIT output, these lines highlight the interface between VM state and native CPU execution. No direct input/output, but prerequisites include correct mapping of Erlang VM register set to real hardware registers.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_9\n\nLANGUAGE: nasm\nCODE:\n```\n    mov rsi, qword ptr [rbx+8]\\n    mov rdi, qword ptr [rbx]\n```\n\n----------------------------------------\n\nTITLE: Initial SSA Code for Erlang Function\nDESCRIPTION: Displays the initial SSA (Static Single Assignment) code generated for the 'foo' function before optimization.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(_0, _1) {\n0:\n  %% blog.erl:5\n  _2 = call remote (literal lists):(literal sum)/1, _1\n\n  %% blog.erl:5\n  _3 = bif:'+' _0, _2\n  @ssa_bool = succeeded _3\n  br @ssa_bool, label 3, label 1\n\n3:\n  ret _3\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized BEAM Code for Case Statement\nDESCRIPTION: This snippet presents the final optimized BEAM code generated from the original case statement, showing how the compiler further refines the instructions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\n{label,18}.\n  {select_val,{x,0},\n              {f,20},\n              {list,[{atom,something},{f,21},{atom,zero},{f,19}]}}.\n{label,19}.\n  {move,{integer,0},{x,0}}.\n  {jump,{f,21}}.\n{label,20}.\n  {move,{atom,no_idea},{x,0}}.\n{label,21}.\n  {test_heap,3,1}.\n  {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n  return.\n```\n\n----------------------------------------\n\nTITLE: Efficient Native Addition in JIT-Generated x86_64 Assembly - NASM\nDESCRIPTION: This NASM/x86_64 snippet is the native code generated by the Erlang JIT for an addition operation where operands are small integers. It efficiently removes type tags, adds values, and stores the result. Dependencies: Output from BEAM JIT. Input: rbx points to BEAM register storage. Output: Fast integer sum stored in memory.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_7\n\nLANGUAGE: nasm\nCODE:\n```\n# i_plus_ssjd\n# add without overflow check\n    mov rax, qword ptr [rbx]\n    mov rsi, qword ptr [rbx+8]\n    and rax, -16               ; Zero the tag bits\n    add rax, rsi\n    mov qword ptr [rbx], rax\n\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Core Transform in Erlang\nDESCRIPTION: This shell snippet demonstrates how to compile a core transform module and use it when compiling another Erlang file.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ erlc my_core_transform\n$ erlc -pa . '+{core_transform,my_core_transform}' core_wrapup.erl\nModule name: core_wrapup\nNumber of nodes in Core Erlang tree: 220\n$\n```\n\n----------------------------------------\n\nTITLE: JIT Implementation of map_size/1\nDESCRIPTION: Native assembly code generated by the JIT for implementing the map_size/1 BIF call. Shows how map size is extracted and properly tagged as a small integer.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_17\n\nLANGUAGE: nasm\nCODE:\n```\n# bif_map_size_jsd\n    mov rax, qword ptr [rbx]      ; Fetch map from {x,0}\n# skipped type check because the argument is always a map\n    mov rax, qword ptr [rax+6]    ; Fetch size of map\n    shl rax, 4\n    or al, 15                     ; Tag as small integer\n    mov qword ptr [rbx], rax      ; Store size in {x,0}\n```\n\n----------------------------------------\n\nTITLE: SSA Code After Liveness Analysis in Erlang\nDESCRIPTION: This snippet demonstrates the result of the liveness analysis pass, which identifies and removes unused expressions that have no observable side effects.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  br label 5\n\n5:\n  br label 4\n\n4:\n  _7 = get_tuple_element _0, literal 1\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n  br label 10\n\n10:\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\n----------------------------------------\n\nTITLE: Result Storage of JIT Addition in BEAM Register - x86-64 Assembly\nDESCRIPTION: Stores the result of an addition in the appropriate BEAM register (simulated in rbx-relative memory). Marks successful execution of the optimized arithmetic operation. Used after fast path addition completes, assuming no overflow or fallback occurred.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_25\n\nLANGUAGE: nasm\nCODE:\n```\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: JIT-compiled x86 assembly for 'band' operation\nDESCRIPTION: The assembly code generated by the JIT compiler for the bitwise AND operation used in the range constraint. It shows the necessary checks and operations for handling Erlang terms.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_34\n\nLANGUAGE: nasm\nCODE:\n```\n# i_band_ssjd\n    mov rsi, qword ptr [rbx]\n    mov eax, 16383\n# is the operand small?\n    mov edi, esi\n    and edi, 15\n    cmp edi, 15\n    short jne L97\n    and rax, rsi\n    short jmp L98\nL97:\n    call 4456532680\n    short je label_25\nL98:\n    mov qword ptr [rbx+16], rax\n```\n\n----------------------------------------\n\nTITLE: Unconditional Record Update in Assembly (x86-64)\nDESCRIPTION: This assembly code shows an unconditional record update, ignoring the 'reuse' hint. It's optimized for cases where multiple fields are being updated, making reuse checks less beneficial.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_22\n\nLANGUAGE: nasm\nCODE:\n```\n# update_record_aIsdI\n    mov rax, qword ptr [rbx]\n    vmovups ymm0, [rax-2]\n    vmovups [r15], ymm0\n    mov qword ptr [r15+32], 1599\n    mov rdi, [rax+38]\n    mov [r15+40], rdi\n    mov qword ptr [r15+48], 12447\n    lea rax, qword ptr [r15+2]\n    add r15, 56\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Using cover:local_only() for Faster Cover Compilation (Erlang)\nDESCRIPTION: Demonstrates the usage of the new cover:local_only/0 function, which allows running Cover in a faster local-only mode for improved performance in cover-compiled code.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/22.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\ncover:local_only()\n```\n\n----------------------------------------\n\nTITLE: Testing for Small Integer in Erlang JIT (x86_64 Assembly)\nDESCRIPTION: Assembly code that tests whether a value is a small integer by checking its tag bit. This determines if direct updates are safe without needing additional heap safety checks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_11\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\n    test cl, 1\n    short je L38           ; Update directly if small integer.\n```\n\n----------------------------------------\n\nTITLE: BEAM Bytecode for Unconstrained Addition - BEAM\nDESCRIPTION: This BEAM assembly fragment corresponds to the simple Erlang addition function without operand type constraints. It uses a garbage-collected builtin function '+', moves results, and returns. Dependencies: Erlang compiler emits sequence like this for generic numeric addition. Inputs: None (context from actual function).\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_3\n\nLANGUAGE: BEAM (Erlang VM bytecode)\nCODE:\n```\n    {gc_bif,'+',{f,0},2,[{x,0},{x,1}],{x,0}}.\n    return.\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Reltool Configuration Format in Erlang\nDESCRIPTION: Shows the new configuration format for reltool where an additional Opts element can now be included in a rel tuple in the release-specific configuration.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/126.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{rel, Name, Vsn, RelApps, Opts}\n```\n\n----------------------------------------\n\nTITLE: Test Heap Implementation in BEAM JIT\nDESCRIPTION: Original implementation of the test_heap instruction that handles heap memory allocation and garbage collection in the BEAM JIT compiler.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-11-10-jit-part-2.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nvoid BeamModuleAssembler::emit_test_heap(const ArgVal &Needed,\n                                         const ArgVal &Live) {\n    const int words_needed = (Needed.getValue() + S_RESERVED);\n    Label after_gc_check = a.newLabel();\n\n    /* Do we have enough free space already? */\n    a.lea(ARG2, x86::qword_ptr(HTOP, words_needed * sizeof(Eterm)));\n    a.cmp(ARG2, E);\n    a.jbe(after_gc_check);\n\n    /* No, we need to GC.\n     *\n     * Switch to the C stack, and update the process\n     * structure with our current stack (E) and heap\n     * (HTOP) pointers so the C code can use them. */\n    emit_enter_runtime<Update::eStack | Update::eHeap>();\n\n    /* Call the GC, passing how many words we need and\n     * how many X registers we use. */\n    a.mov(ARG2, imm(words_needed));\n    a.mov(ARG4, imm(Live.getValue()));\n\n    a.mov(ARG1, c_p);\n    load_x_reg_array(ARG3);\n    a.mov(ARG5, FCALLS);\n    runtime_call<5>(erts_garbage_collect_nobump);\n    a.sub(FCALLS, RET);\n\n    /* Swap back to the Erlang stack, reading the new\n     * values for E and HTOP from the process structure. */\n    emit_leave_runtime<Update::eStack | Update::eHeap>();\n\n    a.bind(after_gc_check);\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Unsafe BEAM Code\nDESCRIPTION: Demonstrates an example of unsafe BEAM code that could potentially crash the runtime system, used to illustrate the importance of the beam_validator pass.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_5\n\nLANGUAGE: erlang\nCODE:\n```\n  {label,4}.\n    {test_heap,2,3}.\n    {put_list,{x,0},{x,1},{x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: JIT-compiled x86 assembly for optimized element function\nDESCRIPTION: The highly optimized assembly code for element/2 when used in the base64 module. The JIT eliminates all type tests and bounds checks, resulting in just 7 instructions with no conditional branches.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_39\n\nLANGUAGE: nasm\nCODE:\n```\n# bif_element_jssd\n# skipped tuple test since source is always a literal tuple\nL302:\n    long mov rsi, 9223372036854775807\n    mov rdi, qword ptr [rbx+24]\n    lea rcx, qword ptr [rsi-2]\n# skipped test for small position since it is always small\n    mov rax, rdi\n    sar rax, 4\n# skipped check for position =:= 0 since it is always >= 1\n# skipped check for negative position and position beyond tuple\n    mov rax, qword ptr [rcx+rax*8]\nL300:\nL301:\n    mov qword ptr [rbx+24], rax\n```\n\n----------------------------------------\n\nTITLE: Tag Value Subtraction for Small Integers\nDESCRIPTION: Assembly instruction that subtracts the tag value (15) from a register to prepare for tag testing and range checking. This is part of the integer range check implementation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_13\n\nLANGUAGE: nasm\nCODE:\n```\nsub rax, 15\n```\n\n----------------------------------------\n\nTITLE: Record Copying in Erlang JIT using AVX Instructions (x86_64 Assembly)\nDESCRIPTION: Assembly code that copies a record using AVX vector instructions when the tuple cannot be updated in place due to heap safety constraints in Erlang's generational garbage collector.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_13\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\nL39:                       ; Copy the current record\n    vmovups ymm0, [rax-2]\n    vmovups [r15], ymm0\n    lea rax, qword ptr [r15+2] ; Set up tagged pointer to copy\n    add r15, 32            ; Advance heap top past the copy\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang File with Time and S Options\nDESCRIPTION: This snippet demonstrates compiling an Erlang file with both the 'time' and '-S' options, which produces a listing of the BEAM assembly code in a .S file.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-19-compiler-time-option.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc -S +time NBAP-PDU-Contents.erl\nCompiling \"NBAP-PDU-Contents\"\n parse_module                  :      0.718 s   25146.1 kB\n transform_module              :      0.000 s   25146.1 kB\n lint_module                   :      0.420 s   25146.1 kB\n expand_records                :      0.088 s   25993.8 kB\n core                          :      0.671 s  282518.3 kB\n sys_core_fold                 :      1.564 s  237885.4 kB\n core_transforms               :      0.000 s  237885.4 kB\n sys_core_bsm                  :      0.203 s  238982.3 kB\n sys_core_dsetel               :      0.104 s  238982.3 kB\n v3_kernel                     :      0.964 s  305320.5 kB\n v3_life                       :      0.375 s  221354.8 kB\n v3_codegen                    :      1.044 s   75801.0 kB\n beam_a                        :      0.091 s   75561.3 kB\n beam_reorder                  :      0.044 s   75561.3 kB\n beam_block                    :      0.276 s   87171.9 kB\n beam_except                   :      0.028 s   81557.8 kB\n beam_bs                       :      0.103 s   79929.3 kB\n beam_type                     :      0.518 s   77270.5 kB\n beam_split                    :      0.049 s   75004.6 kB\n beam_dead                     :      0.379 s   77566.8 kB\n beam_jump                     :      0.195 s   73347.9 kB\n beam_peep                     :      0.156 s   73346.0 kB\n beam_clean                    :      0.168 s   73081.0 kB\n beam_bsm                      :      0.070 s   75473.2 kB\n beam_receive                  :      0.044 s   75473.2 kB\n beam_record                   :      0.021 s   75471.5 kB\n beam_trim                     :      0.041 s   75471.5 kB\n beam_flatten                  :      0.045 s   66745.5 kB\n beam_z                        :      0.016 s   66442.2 kB\n listing                       :      1.503 s   66442.2 kB\n```\n\n----------------------------------------\n\nTITLE: SCSS Responsive Grid Layout Implementation\nDESCRIPTION: SCSS code demonstrating responsive grid layout implementation using Bootstrap breakpoints. Handles different layouts for large and small screen sizes, including sidebar visibility.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: scss\nCODE:\n```\n@include media-breakpoint-up(lg) {\n    .body {\n        display: grid;\n        /* 2 columns on > lg screens */\n        grid-template-columns: 1fr auto;\n    }\n    .main {\n        display: grid;\n    }\n}\n@include media-breakpoint-down(lg) {\n    .body {\n        display: grid;\n        /* Hide the sidebar on small screens */\n        .sidebar {\n            display: none;\n        }\n    }\n    .main {\n        display: grid;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Range Checking Assembly in BEAM JIT\nDESCRIPTION: Assembly code for implementing integer range checking in the BEAM JIT compiler. The code checks if a value is a small integer within a specific range using tag checking and two's complement arithmetic trick for range comparison.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_11\n\nLANGUAGE: nasm\nCODE:\n```\nmov rax, qword ptr [rbx]\nsub rax, 15\ntest al, 15\nshort jne label_19\ncmp rax, 16368\nshort ja label_19\n```\n\n----------------------------------------\n\nTITLE: Core BEAM Assembly Instructions\nDESCRIPTION: Essential working part of the BEAM assembly code without error handling\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-8-24-opt-traps-and-pitfalls.md#2025-04-22_snippet_2\n\nLANGUAGE: beam\nCODE:\n```\n    {test,is_tuple,{f,3},[{x,0}]}.\n    {test,test_arity,{f,3},[{x,0},4]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n  {label,3}.\n    %% Cause a function_clause exception.\n```\n\n----------------------------------------\n\nTITLE: Record Update with Literal Fun in Erlang JIT (x86_64 Assembly)\nDESCRIPTION: Assembly code for updating a record with a literal fun value, which is considered safe and allows for simplified update logic without the copy fallback mechanism.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_16\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\n# update_record_in_place_IsdI\n    mov rax, qword ptr [rbx]\n# skipped copy fallback because all new values are safe\n    long mov rdi, 9223372036854775807  ; Placeholder for address to fun\n    mov qword ptr [rax+14], rdi\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Listing IO Module Functions with Enhanced Error Reporting in Erlang/OTP 24.1\nDESCRIPTION: Lists the io module functions that now provide improved error information when given invalid arguments in the OTP 24.1 release. This includes format, fwrite, put_chars, nl, and write functions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/149.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nio:format, io:fwrite, io:put_chars, io:nl, io:write\n```\n\n----------------------------------------\n\nTITLE: BEAM Bytecode with Register Type Information - BEAM\nDESCRIPTION: This BEAM assembly shows bytecode for the add5/2 function, with several band and test instructions and register operands ({tr,Register,Type}) carrying type and range information. It demonstrates how explicit masking allows the compiler to supply strict integer range constraints in the bytecode, facilitating JIT optimization. Input: values for {x,0} and {x,1}. Output: result of + if checks match.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_5\n\nLANGUAGE: BEAM (Erlang VM bytecode)\nCODE:\n```\n    {gc_bif,'band',{f,24},2,[{x,0},{integer,1023}],{x,2}}.\n    {test,is_eq_exact,\n          {f,24},\n          [{tr,{x,0},{t_integer,any}},{tr,{x,2},{t_integer,{0,1023}}}]}.\n    {gc_bif,'band',{f,24},2,[{x,1},{integer,1023}],{x,2}}.\n    {test,is_eq_exact,\n          {f,24},\n          [{tr,{x,1},{t_integer,any}},{tr,{x,2},{t_integer,{0,1023}}}]}.\n    {gc_bif,'+',\n            {f,0},\n            2,\n            [{tr,{x,0},{t_integer,{0,1023}}},{tr,{x,1},{t_integer,{0,1023}}}],\n            {x,0}}.\n    return.\n\n```\n\n----------------------------------------\n\nTITLE: Emitting BEAM is_nonempty_list Using x86_64 with asmjit - C++\nDESCRIPTION: Implements the emission of the BEAM 'is_nonempty_list' instruction for the x86_64 architecture using asmjit in C++. Arguments are passed as 'ArgVal' objects. The method calculates the memory address of the source register, emits a 'test' instruction against BEAM-specific tag values, and jumps to a failure label if the test fails. No explicit jump is required for success because instructions are laid out sequentially. Dependencies include 'ArgVal', asmjit, and architecture-specific labeling. Input parameters are the failure label and the source register; it emits machine code directly for JIT compilation. Constraints: tailored for x86_64 and relies on a specific register/tagging scheme.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-11-03-a-first-look-at-the-jit.md#2025-04-22_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n/* Arguments are passed as `ArgVal` objects which hold a\n * type and a value, for example saying \"X register 4\",\n * \"the atom 'hello'\", \"label 57\" and so on. */\nvoid BeamModuleAssembler::emit_is_nonempty_list(const ArgVal &Fail,\n                                                const ArgVal &Src) {\n    /* Figure out which memory address `Src` lives in. */\n    x86:Mem list_ptr = getArgRef(Src);\n\n    /* Emit a `test` instruction, which does a non-\n     * destructive AND on the memory pointed at by\n     * list_ptr, clearing the zero flag if the list is\n     * empty. */\n    a.test(list_ptr, imm(_TAG_PRIMARY_MASK - TAG_PRIMARY_LIST));\n\n    /* Emit a `jnz` instruction, jumping to the fail label\n     * if the zero flag is clear (the list is empty). */\n    a.jnz(labels[Fail.getValue()]);\n\n    /* Unlike the interpreter there's no need to jump to\n     * the next instruction on success as it immediately\n     * follows this one. */\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating BEAM Code Validation Challenge with Maps\nDESCRIPTION: This BEAM assembly-like snippet shows a sequence where a value is moved from register x0 to stack slot y0, x0 is tested to be a map, and then the map in y0 is updated. This illustrates a case where `beam_validator` initially failed to recognize that y0 must be a map (because it's a copy of x0, which passed the map test), requiring an enhancement to the validator.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n{move,{x,0},{y,0}}.\n{test,is_map,{f,777},[{x,0}]}.\n{put_map_assoc,{f,0},{y,0},...}.\n```\n\n----------------------------------------\n\nTITLE: Binary Construction in Assembly (x86-64)\nDESCRIPTION: This assembly code snippet demonstrates how the Erlang JIT compiler constructs a binary segment. It calls a helper routine to build the segment efficiently.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_25\n\nLANGUAGE: nasm\nCODE:\n```\n# construct integer segment\n    mov edx, 24\n    mov rsi, qword ptr [rbx+24]\n    xor ecx, ecx\n    lea rdi, qword ptr [rbx-80]\n    call 4387496416\n```\n\n----------------------------------------\n\nTITLE: Unoptimized BEAM Assembly Code\nDESCRIPTION: Complete BEAM assembly representation of the example function including function info and error handling\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-8-24-opt-traps-and-pitfalls.md#2025-04-22_snippet_1\n\nLANGUAGE: beam\nCODE:\n```\n{function, foo, 1, 2}.\n  {label,1}.\n    {line,[{location,\"ex1.erl\",4}]}.\n    {func_info,{atom,ex1},{atom,foo},1}.\n  {label,2}.\n    {test,is_tuple,{f,3},[{x,0}]}.\n    {test,test_arity,{f,3},[{x,0},4]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n  {label,3}.\n    {test_heap,2,1}.\n    {put_list,{x,0},nil,{x,1}}.\n    {move,{atom,function_clause},{x,0}}.\n    {line,[{location,\"ex1.erl\",4}]}.\n    {call_ext_only,2,{extfunc,erlang,error,2}}.\n```\n\n----------------------------------------\n\nTITLE: Defining Function Documentation via XML - Erlang/OTP Docgen - XML\nDESCRIPTION: Illustrates the legacy XML-based documentation format used prior to Erlang/OTP 27, specifically for documenting the `lists:duplicate/2` function. This snippet provides the structure for function name, summary, description, and inline examples for automatic doc generation. The XML code is usually placed in external documentation files and depends on Erl_Docgen for transforming into user-facing docs.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<func>\\n  <name name=\\\"duplicate\\\" arity=\\\"2\\\" since=\\\"\\\"/>\\n  <fsummary>Make <c>N</c> copies of element.</fsummary>\\n  <desc>\\n    <p>Returns a list containing <c><anno>N</anno></c> copies of term\\n      <c><anno>Elem</anno></c>.</p>\\n    <p><em>Example:</em></p>\\n    <pre>\\n> <input>lists:duplicate(5, xx).</input>\\n[xx,xx,xx,xx,xx]</pre>\\n  </desc>\\n</func>\n```\n\n----------------------------------------\n\nTITLE: Setting Message Queue Data Off Heap for Code Server\nDESCRIPTION: Process flag setting for the code_server to store message queue data off heap, improving performance during code upgrades that generate large amounts of messages.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/113.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nprocess_flag(message_queue_data, off_heap)\n```\n\n----------------------------------------\n\nTITLE: Starting Erlang with Lock Counter Support\nDESCRIPTION: Command to start the Erlang VM with lock counting enabled, using the specialized emulator built with the lock-counter option.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/113.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nerl -emu_type lcnt\n```\n\n----------------------------------------\n\nTITLE: Explicit Byte Construction of Non-UTF-8 Binary in Erlang Shell\nDESCRIPTION: Demonstrates that `<<\"Γνῶθι\">>` is syntactic sugar for explicitly defining each character as an 8-bit integer segment (`Char:8`) in the binary construction. This clarifies why non-ASCII characters require explicit UTF-8 encoding to be represented correctly in binaries.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_13\n\nLANGUAGE: erlang\nCODE:\n```\n2> <<$Γ:8, $ν:8, $ῶ:8, $θ:8, $ι:8>>.\n<<147,189,246,184,185>>\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Options to Suppress Deprecated Function Warnings in Erlang\nDESCRIPTION: This environment variable setting suppresses warnings for deprecated functions when building Erlang code with OTP 18.0-rc1. This is particularly useful for code using erlang:now/0, which has been deprecated in this release.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/51.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport ERL_COMPILER_OPTIONS=nowarn_deprecated_function\n```\n\n----------------------------------------\n\nTITLE: Binary Matching Instruction in Assembly (x86-64)\nDESCRIPTION: This assembly code snippet shows how the Erlang JIT compiler optimizes matching of an 8-bit segment in a binary. It includes alignment checks and efficient byte extraction.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_24\n\nLANGUAGE: nasm\nCODE:\n```\n# i_bs_get_integer_8_Stfd\n    mov rcx, qword ptr [rbx+8]\n    mov rsi, qword ptr [rcx+22]\n    lea rdx, qword ptr [rsi+8]\n    cmp rdx, qword ptr [rcx+30]\n    ja label_25\n    rex test sil, 7\n    short je L91\n    mov edx, 64\n    call L92\n    short jmp L90\nL91:\n    mov rdi, qword ptr [rcx+14]\n    shr rsi, 3\n    mov qword ptr [rcx+22], rdx\n    movzx rax, byte ptr [rdi+rsi]\n    shl rax, 4\n    or rax, 15\nL90:\n    mov qword ptr [rbx+16], rax\n```\n\n----------------------------------------\n\nTITLE: Destroying a Trace Session\nDESCRIPTION: This code shows how to properly clean up a trace session when it's no longer needed. The trace:session_destroy/1 function removes the session and its associated resources.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_48\n\nLANGUAGE: erlang\nCODE:\n```\ntrace:session_destroy(Session).\n```\n\n----------------------------------------\n\nTITLE: Defining YAML Frontmatter for OTP 23.3 Release Post in Markdown\nDESCRIPTION: YAML frontmatter for a blog post announcing the OTP 23.3 release. It includes metadata such as layout, id, title, lead, tags, date, author, and visibility settings.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/145.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: post\nid: 145\ntitle: \"OTP 23.3 Release\"\nlead: \"The third and final maintenance patch release for OTP 23\"\ntags: \"release, OTP, 23\"\ndate: \"2021-03-24\"\ncreated_at: \"2021-03-24T09:09:53Z\"\nupdated_at: \"2021-03-29T06:43:18Z\"\nauthor: \"Henrik Nord\"\nvisible: \"true\"\narticle_type_id: \"3\"\n---\n```\n\n----------------------------------------\n\nTITLE: Using sys:log for Message Logging\nDESCRIPTION: Shows the sys:log/2,3 function which is now used to include the last N messages in terminate reports for gen_* behaviors.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/132.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nsys:log/2,3\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang Module with Parse and Listing Options\nDESCRIPTION: Demonstrates compiling an Erlang module with the '-P' option to run the parse_module pass and produce a listing of the result.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc -P +time trivial.erl\nCompiling \"trivial\"\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.003 s       5.5 kB\n listing                       :      0.001 s       5.5 kB\n```\n\n----------------------------------------\n\nTITLE: Analyzing perf Profile with Hotspot in Bash\nDESCRIPTION: Command to analyze the perf profiling data using the Hotspot visualization tool.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-5-12-My-OTP-24-Highlights.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ hotspot perf.data\n```\n\n----------------------------------------\n\nTITLE: Using Experimental Socket Backend in Erlang\nDESCRIPTION: Example of enabling the experimental socket backend for gen_tcp and inet in Erlang OTP 23.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/23.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\n{inet_backend, socket}\n```\n\n----------------------------------------\n\nTITLE: Building Erlang escript with rebar3 - Shell\nDESCRIPTION: This shell command invokes 'rebar3 escriptize' to build the Erlang project into an escript binary. Requires rebar3 to be installed and configured for the Erlang project. The main parameter is 'escriptize', which compiles and packages the project as an executable script that can run without OTP release. Input: none. Output: an executable present as '_build/default/bin/mylib'. Useful for quick creation of distributable Erlang scripts.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_scripts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ rebar3 escriptize\n```\n\n----------------------------------------\n\nTITLE: Optimized Map Size Comparison with Known Small Operands - x86-64 Assembly\nDESCRIPTION: Because both input map sizes are statically known to be small integers, this code omits type tests entirely for maximum JIT efficiency. It loads operands, compares, and conditionally jumps on failure. Requires statically proven constraints on input types, as provided by BEAM type analysis.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_17\n\nLANGUAGE: nasm\nCODE:\n```\n# is_lt_fss\\n    mov rsi, qword ptr [rbx+8]\\n    mov rdi, qword ptr [rbx]\\n# skipped test for small operands since they are always small\\n    cmp rdi, rsi\\nL42:\\nL43:\\n    jge label_12\n```\n\n----------------------------------------\n\nTITLE: Compiling Erlang Module with Errors\nDESCRIPTION: Demonstrates compiling an Erlang module with semantic errors to show the lint_module pass in action.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-4-26-compiler-lost-in-translation.md#2025-04-22_snippet_7\n\nLANGUAGE: erlang\nCODE:\n```\n$ cat bug.erl\n-module(bug).\n-export([main/0]).\n\nmain() ->\n    A+B.\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ erlc +time bug.erl\nCompiling \"bug\"\n remove_file                   :      0.000 s       2.1 kB\n parse_module                  :      0.000 s       2.7 kB\n transform_module              :      0.000 s       2.7 kB\n lint_module                   :      0.004 s       2.4 kB\nbug.erl:5: variable 'A' is unbound\nbug.erl:5: variable 'B' is unbound\n$\n```\n\n----------------------------------------\n\nTITLE: BEAM Bytecode for Type and Comparison Checks in Less-Than\nDESCRIPTION: Lists BEAM bytecode for a type-guarded less-than comparison. Demonstrates use of is_integer tests to branch to failure, followed by the typed is_lt test. Outputs atoms 'smaller' or 'larger_or_equal' via x registers, supporting Erlang's match semantics. Requires BEAM or equivalent bytecode VM to interpret.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_13\n\nLANGUAGE: \nCODE:\n```\n    {test,is_integer,{f,7},[{x,0}]}.\n    {test,is_integer,{f,7},[{x,1}]}.\n    {test,is_lt,{f,9},[{tr,{x,0},{t_integer,any}},{tr,{x,1},{t_integer,any}}]}.\n    {move,{atom,smaller},{x,0}}.\n    return.\n  {label,9}.\n    {move,{atom,larger_or_equal},{x,0}}.\n    return.\n\n```\n\n----------------------------------------\n\nTITLE: Erlang Core Representation Example\nDESCRIPTION: This snippet references Core Erlang, an intermediate representation used in the Erlang compiler. While no actual code is shown, it's mentioned as a key contribution from the HiPE project.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-12-01-the-road-to-the-jit.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n% Core Erlang representation (no actual code shown)\n```\n\n----------------------------------------\n\nTITLE: ASDF Tool Installation Shell Commands\nDESCRIPTION: Shell commands for installing and configuring ASDF version manager with plugins for Erlang, NodeJS and Ruby dependencies.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.15.0\necho \". $HOME/.asdf/asdf.sh\" >> ~/.bashrc\necho \". $HOME/.asdf/completions/asdf.bash\" >> ~/.bashrc\n. ~/.bashrc\nasdf plugin add erlang\nasdf plugin add nodejs\nasdf plugin add ruby\n```\n\n----------------------------------------\n\nTITLE: LDAP TLS Function Call in Erlang\nDESCRIPTION: Function reference for upgrading LDAP connections to TLS encryption in the eldap application.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/46.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\neldap:start_tls/2\n```\n\nLANGUAGE: erlang\nCODE:\n```\neldap:start_tls/3\n```\n\n----------------------------------------\n\nTITLE: Creating a Blog Post Template in Markdown for Erlang.org\nDESCRIPTION: This snippet demonstrates the structure and formatting for a blog post on Erlang.org. It includes YAML front matter for metadata, guidelines for the first paragraph, and examples of markdown and HTML usage.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nlayout: post\ntitle: \"My new blog item\"\nauthor: \"John Doe\"\n---\nThe first paragraph will be shown on the index page. So make sure\nthat it makes sense in its own and is not too long.\n\n## Sub title\n\nWrite any internal links (i.e. links to erlang.org) using the {% link blog/images/config.png %}\nsyntax so that jekyll will do a check that it links to something that exists.\n\nAlso remember that if markdown does not support doing something, <sup>you can always use html</sup>.\n```\n\n----------------------------------------\n\nTITLE: Using System Time for Randomness in Erlang\nDESCRIPTION: This snippet suggests creating a number using the system's microsecond clock as a source of pseudo-randomness. It calls the 'os:system_time/1' function with 'microseconds' as the unit. Dependencies: 'os' module (built-in). Key parameter is the time unit, influencing the numerical domain. This approach is limited in statistical quality due to repeated values, system-dependent resolution, and possible non-monotonic behavior, making it unsuitable for most PRNG use cases requiring unpredictability.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nos:system_time(microseconds)\n```\n\n----------------------------------------\n\nTITLE: Simplified Small Integer Type Test with Static Types - x86-64 Assembly\nDESCRIPTION: Because operand types are statically known to be small integers, this JIT-optimized fragment reduces the type test to a simple tag check and skips boxed value handling, improving efficiency. Assumes previous type propagation already excluded non-small-integer types. Used in advanced type-driven JIT compilation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_14\n\nLANGUAGE: nasm\nCODE:\n```\n# simplified small test since all other types are boxed\\n    mov eax, edi\\n    and eax, esi\\n    test al, 1\\n    short je L39\n```\n\n----------------------------------------\n\nTITLE: BEAM Bytecode for Addition (No Type Guards)\nDESCRIPTION: Bytecode generated for a plain addition, showing use of general BIF invocation and result storage. No explicit type constraints, result is stored in x register. Illustrates baseline bytecode path for addition without static typing.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_19\n\nLANGUAGE: \nCODE:\n```\n    {gc_bif,'+',{f,0},2,[{x,0},{x,1}],{x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Structuring Release Posts Using GitHub Flavored Markdown in Markdown\nDESCRIPTION: This snippet illustrates the recommended structure for a release post markdown file, including YAML front matter to specify layout and the release version, followed by headers and section content. Dependencies include a static site generator like Jekyll, as the front matter (delimited by ---) is necessary for metadata processing. Key parameters are the 'layout' and 'release' fields in the front matter, used to render the release correctly. The expected input is a markdown file following this template, and the output is a formatted release note rendered on the website. Limitations: requires a compatible site generator and specific directory placement under /downloads.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_releases/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\\nlayout: release\\nrelease: 24\\n---\\nSome markdown\\n\\n## Sub title\\n\\nSome more markdown\n```\n\n----------------------------------------\n\nTITLE: Erlang Record Definition and Update Functions\nDESCRIPTION: Erlang code defining a record and three functions that update different fields in the record. Used to demonstrate how record updates are handled in OTP 25 versus OTP 26.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_20\n\nLANGUAGE: erlang\nCODE:\n```\n-record(r, {a,b,c,d,e}).\n\nupdate_a(R) ->\n    R#r{a=42}.\n\nupdate_ce(R) ->\n    R#r{c=99,e=777}.\n\nupdate_bcde(R) ->\n    R#r{b=2,c=3,d=4,e=5}.\n```\n\n----------------------------------------\n\nTITLE: Configuring Erlang Build with DTrace Probes\nDESCRIPTION: This command-line option enables DTrace probes in the Erlang build. It's useful for debugging but not recommended for production use.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/59.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n--with-dynamic-trace=dtrace\n```\n\n----------------------------------------\n\nTITLE: OTP 24 JIT Instruction Translation to x86_64\nDESCRIPTION: Translates BEAM tuple tests into native x86_64 instructions, showing how OTP 24 handles tuple test cases with five native instructions to identify heap object pointers. Primarily for developers targeting x86_64 systems with OTP 24 and above.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_2\n\nLANGUAGE: nasm\nCODE:\n```\n# i_is_tuple_fs\n    mov rsi, qword ptr [rbx]\n    rex test sil, 1\n    jne L2\n    test byte ptr [rsi-2], 63\n    jne L2\n```\n\n----------------------------------------\n\nTITLE: JIT Loading BEAM Addition Operands - x86-64 Assembly\nDESCRIPTION: Loads two BEAM operand values from VM registers into real CPU registers before addition or other arithmetic operation. Prerequisite step for BEAM JIT arithmetic. Operands are indirectly referenced via pointers relative to rbx.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_21\n\nLANGUAGE: nasm\nCODE:\n```\n    mov rsi, qword ptr [rbx]\\n    mov rdx, qword ptr [rbx+8]\n```\n\n----------------------------------------\n\nTITLE: Updating Records In-Place in Erlang JIT (x86_64 Assembly)\nDESCRIPTION: Assembly code generated by the Erlang JIT to optimize record updates. It checks whether updates can be done in-place based on integer size and heap safety rules related to Erlang's generational garbage collection.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_9\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\n    mov rax, qword ptr [rbx+8]\n    mov rcx, qword ptr [rbx+16]\n    test cl, 1\n    short je L38           ; Update directly if small integer.\n\n    ; The new value is a bignum.\n    ; Test whether the tuple is in the safe part of the heap.\n\n    mov rdi, [r13+480]     ; Get the high water mark\n    cmp rax, r15           ; Compare tuple pointer to heap top\n    short jae L39          ; Jump and copy if above\n    cmp rax, rdi           ; Compare tuple pointer to high water\n    short jae L38          ; Jump and overwrite if above high water\n\n    ; The tuple is not in the safe part of the heap.\n    ; Fall through to the copy code.\n\nL39:                       ; Copy the current record\n    vmovups ymm0, [rax-2]\n    vmovups [r15], ymm0\n    lea rax, qword ptr [r15+2] ; Set up tagged pointer to copy\n    add r15, 32            ; Advance heap top past the copy\n\nL38:\n    mov rdi, rcx           ; Get new value for atoms field\n    mov qword ptr [rax+22], rdi\n    mov qword ptr [rbx+8], rax\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Erlang Function for Optimization Example\nDESCRIPTION: This Erlang code defines a function `a/0` that binds the constant value 42 to variable `A` and returns a tagged tuple `{ok, A}`. This function serves as the basis for demonstrating constant propagation optimization in Core Erlang.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\na() ->\n    A = 42,\n    {ok,A}.\n```\n\n----------------------------------------\n\nTITLE: JIT Implementation of Integer Addition\nDESCRIPTION: Assembly code generated for adding a constant to a small integer. Shows optimization that avoids overflow checking since the result is known to fit in a small integer.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_19\n\nLANGUAGE: nasm\nCODE:\n```\n# i_plus_ssjd\n# add without overflow check\n    mov rax, qword ptr [rbx]\n    add rax, 96      ; 16 * 6 + 0\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: BEAM code for addition with explicit range constraints\nDESCRIPTION: The BEAM code for the add4 function, showing that despite explicit range constraints, the compiler still treats operands as integers with no specific range due to limitations in value range analysis.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_31\n\nLANGUAGE: text\nCODE:\n```\n    {test,is_integer,{f,19},[{x,0}]}.\n    {test,is_ge,{f,19},[{tr,{x,0},{t_integer,any}},{integer,0}]}.\n    {test,is_lt,{f,19},[{tr,{x,0},{t_integer,any}},{integer,1024}]}.\n    {test,is_integer,{f,19},[{x,1}]}.\n    {test,is_ge,{f,19},[{tr,{x,1},{t_integer,any}},{integer,0}]}.\n    {test,is_lt,{f,19},[{tr,{x,1},{t_integer,any}},{integer,1024}]}.\n    {gc_bif,'+',\n            {f,0},\n            2,\n            [{tr,{x,0},{t_integer,any}},{tr,{x,1},{t_integer,any}}],\n            {x,0}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Erlang Code After Record Translation\nDESCRIPTION: This snippet shows the Erlang code for the update_record function after records have been translated to tuple operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_11\n\nLANGUAGE: erlang\nCODE:\n```\nupdate_record(R) ->\n    begin\n        rec0 = R,\n        case rec0 of\n            {rec,_,_,_,_,_,_,_,_} ->\n                setelement(2, setelement(3, rec0, y), x);\n            _ ->\n                error({badrecord,rec})\n        end\n    end.\n```\n\n----------------------------------------\n\nTITLE: Displaying Core Erlang Passes in Erlang Compiler\nDESCRIPTION: This snippet shows how to compile an Erlang file with the +time option to display the Core Erlang passes executed by the compiler.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ erlc +time core_wrapup.erl\nCompiling \"core_wrapup\"\n     .\n     .\n     .\n core                          :      0.000 s      15.7 kB\n sys_core_fold                 :      0.000 s       9.0 kB\n sys_core_alias                :      0.000 s       9.0 kB\n core_transforms               :      0.000 s       9.0 kB\n sys_core_bsm                  :      0.000 s       9.0 kB\n sys_core_dsetel               :      0.000 s       9.0 kB\n     .\n     .\n     .\n```\n\n----------------------------------------\n\nTITLE: Simplified Native Code Emission\nDESCRIPTION: Illustrates simplified native code emitted by the JIT when an operand is inferred to be a tuple, reducing instructions used for checks when type information confirms it. Effective in systems using OTP 25 or later.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_5\n\nLANGUAGE: nasm\nCODE:\n```\n# i_is_tuple_fs\n    mov rsi, qword ptr [rbx]\n# simplified tuple test since the source is always a tuple when boxed\n    rex test sil, 1\n    jne label_3\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang/OTP 26.0-rc3 Using Kerl\nDESCRIPTION: Command for installing the release candidate using kerl, a tool for managing Erlang/OTP installations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/163.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkerl build 26.0-rc3 26.0-rc3\n```\n\n----------------------------------------\n\nTITLE: YAML Front Matter Configuration for Blog Post\nDESCRIPTION: YAML configuration block defining metadata for a blog post about the LINC switch announcement, including title, date, author and visibility settings.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/58.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: post\nid: 58\ntitle: \"LINC switch opensourced\"\nlead: \"FlowForwarding.org announces LINC, the free, Erlang based industry supported, OpenFlow soft-switch supporting OpenFlow 1.2! \"\nattachment: \"/upload/news/Flowforwarding.org.50.png\"\ndate: \"2012-04-19\"\ncreated_at: \"2012-04-19T14:28:10Z\"\nupdated_at: \"2015-09-30T16:29:06Z\"\nauthor: \"Henrik Nord\"\nvisible: \"true\"\narticle_type_id: \"3\"\n---\n```\n\n----------------------------------------\n\nTITLE: Generating BEAM Assembly Listing Without SSA Optimizations using erlc\nDESCRIPTION: Illustrates how to compile `blog.erl` and generate its BEAM assembly listing (`-S`) while completely disabling all SSA optimization passes using the `+no_ssa_opt` flag. This allows inspection of the BEAM code generated before SSA optimizations are applied.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\nerlc +no_ssa_opt -S blog.erl\n```\n\n----------------------------------------\n\nTITLE: Updating Tuple Element in Erlang JIT (x86_64 Assembly)\nDESCRIPTION: Assembly code that performs the actual update of a tuple element, writing the new value into the tuple and updating the pointer in the original register.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_14\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\nL38:\n    mov rdi, rcx           ; Get new value for atoms field\n    mov qword ptr [rax+22], rdi\n    mov qword ptr [rbx+8], rax\n```\n\n----------------------------------------\n\nTITLE: Register Operand and Type Annotation - Erlang\nDESCRIPTION: Shows the structure of a typed register operand in the BEAM assembly as a three-tuple, where tr denotes typed register, followed by the register identifier and its type. This convention is an internal Erlang compiler construct and is crucial for JIT optimizations based on type information.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n{tr,Register,Type}\n\n```\n\n----------------------------------------\n\nTITLE: Optimized SSA Code after beam_ssa_pre_codegen\nDESCRIPTION: Shows the SSA code after running the beam_ssa_pre_codegen pass, including register allocation and live intervals.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_4\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(x0/_0, x1/_1) {\n  %% _0: 0..1\n  %% _1: 0..1 0..3\n%% #{frame_size => 1,yregs => [0]}\n0:\n  %% _0:4: 1..5\n  [1] y0/_0:4 = copy x0/_0\n\n  %% blog.erl:5\n  %% _2: 3..5\n  [3] x0/_2 = call remote (literal lists):(literal sum)/1, x1/_1\n\n  %% blog.erl:5\n  %% _3: 5..11\n  [5] x0/_3 = bif:'+' y0/_0:4, x0/_2\n\n  %% @ssa_bool: 7..9\n  [7] z0/@ssa_bool = succeeded x0/_3\n  [9] br z0/@ssa_bool, label 3, label 1\n\n3:\n  [11] ret x0/_3\n\n1:\n  %% @ssa_ret: 13..15\n  [13] x0/@ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  [15] ret x0/@ssa_ret\n}\n```\n\n----------------------------------------\n\nTITLE: JIT-Compiled Addition with Type and Overflow Checks - x86-64 Assembly\nDESCRIPTION: nasm code for addition of two BEAM values, optimized when both operands are small integers. Involves loading operands, type tests via tag bits, calling generic fallback if types mismatch, performing native addition with overflow detection, and storing the result. Used by BEAM JIT in arithmetic operations, relying on register and memory layout conventions.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_20\n\nLANGUAGE: nasm\nCODE:\n```\n# i_plus_ssjd\\n    mov rsi, qword ptr [rbx]\\n    mov rdx, qword ptr [rbx+8]\\n# are both operands small?\\n    mov eax, esi\\n    and eax, edx\\n    and al, 15\\n    cmp al, 15\\n    short jne L15\\n# add with overflow check\\n    mov rax, rsi\\n    mov rcx, rdx\\n    and rcx, -16\\n    add rax, rcx\\n    short jno L14\\nL15:\\n    call 4328985696\\nL14:\\n    mov qword ptr [rbx], rax\n```\n\n----------------------------------------\n\nTITLE: Running Dialyzer with Warning Options in Erlang\nDESCRIPTION: Output from running Dialyzer after changing warning options, which forces a complete re-analysis. This demonstrates how changes to warning configuration affects Dialyzer's behavior.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\n$ dialyzer --incremental\nPLT was built for a different set of enabled warnings,\nso an analysis must be run for 319 modules to rebuild it\nProceeding with incremental analysis... done in 0m19.43s\ndone (passed successfully)\n```\n\n----------------------------------------\n\nTITLE: Tuple Pattern Matching Optimization in Erlang\nDESCRIPTION: Demonstrates the compiler optimization that eliminates redundant tuple creation by reusing matched tuples instead of recreating them. This change was contributed by José Valim and improves performance for common Erlang patterns.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-02-My-OTP-21-Highlights.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\nexample({ok, Val}) -> {ok, Val}.\n```\n\nLANGUAGE: erlang\nCODE:\n```\nexample({ok, Val} = Tuple) -> Tuple.\n```\n\n----------------------------------------\n\nTITLE: Register Value Fetching in BEAM JIT\nDESCRIPTION: Assembly instruction that fetches the value of a BEAM register (x,0) into a CPU register. This is the first step in many BEAM JIT compiled operations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-04-19-more-optimizations.md#2025-04-22_snippet_12\n\nLANGUAGE: nasm\nCODE:\n```\nmov rax, qword ptr [rbx]\n```\n\n----------------------------------------\n\nTITLE: Loading Tuple and Value in Erlang JIT (x86_64 Assembly)\nDESCRIPTION: Assembly code that loads the tuple to be updated into register rax and the new counter value into rcx, as part of the record update optimization process.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-04-23-optimizations.md#2025-04-22_snippet_10\n\nLANGUAGE: x86_64 assembly\nCODE:\n```\n    mov rax, qword ptr [rbx+8]\n    mov rcx, qword ptr [rbx+16]\n```\n\n----------------------------------------\n\nTITLE: Generating Pretty-Printed SSA Code with Erlang Compiler Option\nDESCRIPTION: Command for using the dprecg compiler option to generate a pretty-printed listing of the SSA code that will be saved to a file named blog.precodegen. This is useful for debugging and understanding the SSA intermediate representation.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-28-ssa-history.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nerlc +dprecg blog.erl\n```\n\n----------------------------------------\n\nTITLE: Running ehead Script with Valid Arguments in Erlang\nDESCRIPTION: Output when running the ehead script with valid file arguments, showing how argparse collects the arguments into a map. This demonstrates successful command-line parsing.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\n$ ehead foo bar baz\n#{lines => 10,files => [\"foo\",\"bar\",\"baz\"]}\n```\n\n----------------------------------------\n\nTITLE: Simplifying Core Erlang Case by Removing Unreachable Clause\nDESCRIPTION: This snippet shows the first step in optimizing the `case` expression in the Core Erlang representation of `a/0`. Since the first clause (`<> when 'true'`) always matches, the second clause is identified as unreachable by `sys_core_fold` and removed.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-18-core-erlang-optimizations.md#2025-04-22_snippet_6\n\nLANGUAGE: erlang\nCODE:\n```\n'a'/0 =\n    fun () ->\n        case <> of\n\t  <> when 'true' ->\n\t      let <A> = 42\n\t      in {'ok',A}\n\tend\n```\n\n----------------------------------------\n\nTITLE: Setting up distribution without EPMD in Erlang\nDESCRIPTION: Configuration options for running Erlang distribution without relying on EPMD, including options to disable listening for incoming connections and configuring a default port for the built-in EPMD client.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/140.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-dist_listen false\n```\n\nLANGUAGE: erlang\nCODE:\n```\n-erl_epmd_port Port\n```\n\n----------------------------------------\n\nTITLE: Running ehead Script with Various Option Formats in Erlang\nDESCRIPTION: Multiple examples of running the ehead script with different ways of specifying the number of lines option, demonstrating the flexibility of argparse in handling command-line options.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2023-05-16-otp-26-highlights.md#2025-04-22_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n$ ehead -n 42 foo bar baz\n#{lines => 42,files => [\"foo\",\"bar\",\"baz\"]}\n$ ehead foo --lines=42 bar baz\n#{lines => 42,files => [\"foo\",\"bar\",\"baz\"]}\n$ ehead --lines 42 foo bar baz\n#{lines => 42,files => [\"foo\",\"bar\",\"baz\"]}\n$ ehead foo bar --lines 42 baz\n#{lines => 42,files => [\"foo\",\"bar\",\"baz\"]}\n```\n\n----------------------------------------\n\nTITLE: Assembly code for is_nonempty_list instruction\nDESCRIPTION: This snippet presents the assembly code generated for the is_nonempty_list instruction, highlighting the core functionality and the overhead from dispatch and argument handling.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-10-27-a-closer-look-at-the-interpreter.md#2025-04-22_snippet_2\n\nLANGUAGE: Assembly\nCODE:\n```\n    ; Read the argument word from the instruction\n    ; stream.\n    mov    rdx, [rbx + 8]\n\n    ; Unpack the offset of our source register (upper 32\n    ; 32 bits).\n    mov    rcx, rdx\n    shr    rcx, 32\n\n    ; X registers live in machine register r15, and we\n    ; placed our offset in rcx, so we can find our term at\n    ; [r15 + rcx].\n    ;\n    ; Perform a non-destructive bitwise AND on the term\n    ; using the `test` instruction, and jump to the fail\n    ; label if the result is non-zero.\n    test   byte [r15 + rcx], (_TAG_PRIMARY_MASK - TAG_PRIMARY_LIST)\n    jne    jump_to_fail_label\n\n    ; Skip the current label address and argument word,\n    ; then jump to the next instruction.\n    add    rbx, 16\n    jmp    [rbx]\n\njump_to_fail_label:\n    ; Unpack our fail label (lower 32 bits) and add\n    ; it to our current instruction pointer.\n    movsxd rdx, edx\n    lea    rbx, [rbx + rdx * 8]\n\n    ; Jump to the instruction at the fail label.\n    jmp    [rbx]\n```\n\n----------------------------------------\n\nTITLE: Socket Backend Configuration - Erlang\nDESCRIPTION: Example showing how to configure the experimental socket backend for gen_tcp and inet using the inet_backend option.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/138.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n{inet_backend, socket}\n```\n\n----------------------------------------\n\nTITLE: JIT-compiled x86 assembly for 'is_eq_exact' operation\nDESCRIPTION: The assembly code for equality comparison that benefits from type information. Since one operand is known to be a small integer, a simple comparison is sufficient without complex type checking.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-04-26-type-based-optimizations-in-the-jit.md#2025-04-22_snippet_35\n\nLANGUAGE: nasm\nCODE:\n```\n# is_eq_exact_fss\n# simplified check since one argument is an immediate\n    mov rdi, qword ptr [rbx+16]\n    cmp qword ptr [rbx], rdi\n    short jne label_25\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang/OTP 28.0-rc3 using kerl\nDESCRIPTION: Command to build and install the Erlang/OTP 28.0-rc3 release candidate using kerl, a tool for managing Erlang installations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/178.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkerl build 28.0-rc3 28.0-rc3.\n```\n\n----------------------------------------\n\nTITLE: Final BEAM Code for Simple Case Statement Function\nDESCRIPTION: This snippet shows the final BEAM code generated for the bar/1 function, including optimizations and error handling.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-20-digging-deeper-in-ssa.md#2025-04-22_snippet_11\n\nLANGUAGE: erlang\nCODE:\n```\n{label,28}.\n  {test,is_eq_exact,{f,29},[{x,0},{atom,none}]}.\n  {move,{integer,0},{x,0}}.\n{label,29}.\n  {line,[{location,\"blog.erl\",52}]}.\n  {gc_bif,'+',{f,0},1,[{x,0},{integer,1}],{x,0}}.\n  return.\n```\n\n----------------------------------------\n\nTITLE: Referencing Generic Erlang Release Configuration Format\nDESCRIPTION: Shows the format for specifying an Erlang release configuration with Name, Version, Release Applications, and Options parameters.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/133.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{rel, Name, Vsn, RelApps, Opts}\n```\n\n----------------------------------------\n\nTITLE: Defining Release Configuration in Reltool\nDESCRIPTION: Shows the new format for defining a release in the reltool configuration, which now includes an Opts element in the rel tuple.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/132.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{rel, Name, Vsn, RelApps, Opts}\n```\n\n----------------------------------------\n\nTITLE: Configuring Erlang Build with SystemTap Probes\nDESCRIPTION: This command-line option enables SystemTap probes in the Erlang build, providing an alternative to DTrace for dynamic tracing.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/59.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n--with-dynamic-trace=systemtap\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable in CDV Script\nDESCRIPTION: Shows how the Crashdump Viewer script sets the ERL_CRASH_DUMP_SECONDS environment variable to prevent generating a new crash dump from the node running the viewer.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/115.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nERL_CRASH_DUMP_SECONDS=0\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang 27.0-rc3 using Kerl\nDESCRIPTION: Command to build Erlang/OTP 27.0-rc3 using the Kerl version manager.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/169.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nkerl build 27.0-rc3 27.0-rc3.\n```\n\n----------------------------------------\n\nTITLE: Using Cover in Local-Only Mode in Erlang\nDESCRIPTION: References the new cover:local_only/0 function that allows running Cover in a restricted but faster local-only mode for improved performance.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/126.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\ncover:local_only/0\n```\n\n----------------------------------------\n\nTITLE: Invalid Map Matching Example in Erlang\nDESCRIPTION: Shows an illegal map matching pattern where an unbound variable is used in the key expression, which is not allowed.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2020-5-13-OTP-23-Highlights.md#2025-04-22_snippet_3\n\nLANGUAGE: erlang\nCODE:\n```\nillegal_example(Key, #{Key := Value}) -> Value.\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning Suppression Example\nDESCRIPTION: Example of using compile attribute to override compiler options for warning suppression.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/169.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\n-compile([nowarn_missing_spec]).\n```\n\n----------------------------------------\n\nTITLE: Converting IOList to IOVector in Erlang\nDESCRIPTION: Shows the new erlang:iolist_to_iovec/1 function that converts an iolist() to an erlang:iovec(), suitable for use with enif_inspect_iovec().\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/115.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:iolist_to_iovec/1\n```\n\n----------------------------------------\n\nTITLE: Installing Erlang/OTP 27.0-rc2 using kerl\nDESCRIPTION: Command to build and install Erlang/OTP 27.0-rc2 using the kerl tool, which manages Erlang/OTP installations.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/168.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nkerl build 27.0-rc2 27.0-rc2.\n```\n\n----------------------------------------\n\nTITLE: Referencing EEP-44 (Additional preprocessor directives) in Markdown\nDESCRIPTION: Markdown link to EEP-44 documenting the Additional preprocessor directives proposal that was partially approved with only the -warning and -error directives implemented.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/104.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[EEP-44](https://github.com/erlang/eep/blob/master/eeps/eep-0044.md) Additional preprocessor directives\n```\n\n----------------------------------------\n\nTITLE: Using zip:zip_get_crc32/2 for ZIP Archive Checksum\nDESCRIPTION: Shows how to use the new zip:zip_get_crc32/2 function to retrieve the CRC32 checksum from an opened ZIP archive.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/164.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\nzip:zip_get_crc32/2\n```\n\n----------------------------------------\n\nTITLE: Analyzing Small Integer Test in BEAM Assembly\nDESCRIPTION: Assembly code snippet that tests if a value is a small integer using bit masking (checking if {x,0} is a small integer), with fallback to a handler for any term type.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2022-05-12-faster-rand.md#2025-04-22_snippet_9\n\nLANGUAGE: nasm\nCODE:\n```\n# is the operand small?\n    mov edi, esi\n    and edi, 15\n    cmp edi, 15\n    short jne L2271\n```\n\n----------------------------------------\n\nTITLE: Download Links for Erlang/OTP 23.2\nDESCRIPTION: URLs for accessing Erlang/OTP 23.2 documentation and downloading pre-built Windows versions. Also includes a link to the official Erlang repository on GitHub where the source code can be found.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/143.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<https://erlang.org/documentation/doc-11.1.4/doc>\n\n<https://erlang.org/download/otp_win32_23.2.exe>\n<https://erlang.org/download/otp_win64_23.2.exe>\n\n<https://github.com/erlang/otp>\n```\n\n----------------------------------------\n\nTITLE: Querying ETS Table Size in Erlang\nDESCRIPTION: This code snippet demonstrates how to query the size of an ETS table using the ets:info/2 function in Erlang.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-08-03-scalable-ets-counters.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nets:info(Table, size)\n```\n\n----------------------------------------\n\nTITLE: Erlang Module Function Reference\nDESCRIPTION: Reference to new and modified Erlang module functions introduced in OTP 20.0-rc1, including garbage collection, system info, and pattern matching improvements.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/112.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nerlang:check_process_code/3\nerlang:garbage_collect/2\nerlang:system_info/1\nrand:jump/0-1\nmath:fmod/2\n```\n\n----------------------------------------\n\nTITLE: Initial SSA Code for foo Function in Erlang\nDESCRIPTION: This snippet shows the SSA code for the 'foo' function after preliminary optimization passes. It includes tuple matching and error handling logic.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-9-05-introducing-ssa.md#2025-04-22_snippet_2\n\nLANGUAGE: erlang\nCODE:\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = bif:is_tuple _0\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n  br @ssa_bool:8, label 5, label 3\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n\n4:\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n  br label 10\n\n10:\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\n----------------------------------------\n\nTITLE: Using New AES-CFB8 Cipher in Erlang Crypto Module\nDESCRIPTION: Demonstrates the addition of the aes_cfb8 cipher to the crypto:block_encrypt and block_decrypt functions in the crypto module of Erlang/OTP 17.1.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_news/9.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\ncrypto:block_encrypt(aes_cfb8, Key, IV, PlainText)\n```\n\n----------------------------------------\n\nTITLE: Optimized BEAM Assembly Using is_tagged_tuple\nDESCRIPTION: Optimized version of the code using the specialized is_tagged_tuple instruction\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-8-24-opt-traps-and-pitfalls.md#2025-04-22_snippet_3\n\nLANGUAGE: beam\nCODE:\n```\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Record Optimization in Erlang OTP 22\nDESCRIPTION: This snippet shows how the OTP 22 compiler optimizes record handling across functions within the same module, eliminating unnecessary record checks.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2019-5-13-OTP-22-Highlights.md#2025-04-22_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-record(myrecord, {value}).\n\nh(#myrecord{value=Val}) ->\n    #myrecord{value=Val+1}.\n\ni(A) ->\n    #myrecord{value=V} = h(#myrecord{value=A}),\n    V.\n```\n\n----------------------------------------\n\nTITLE: Core Erlang Representation of update_tuple Before Optimization\nDESCRIPTION: This snippet shows the Core Erlang representation of the update_tuple function before the sys_core_dsetel optimization is applied.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-30-core-erlang-wrapup.md#2025-04-22_snippet_8\n\nLANGUAGE: erlang\nCODE:\n```\n'update_tuple'/1 =\n    fun (_0) ->\n\tlet <T> =\n\t    call 'erlang':'setelement'(3, _0, 'y')\n\tin\n\t    call 'erlang':'setelement'(2, T, 'x')\n```\n\n----------------------------------------\n\nTITLE: Corrected usage of timer:apply_after with funs in Erlang/OTP 26\nDESCRIPTION: The correct way to use timer:apply_after with a fun in Erlang/OTP 26, showing the empty list of arguments that must be provided to avoid errors.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2024-05-20-highlights-otp-27.md#2025-04-22_snippet_34\n\nLANGUAGE: erlang\nCODE:\n```\ntimer:apply_after(10, erlang, apply, [fun() -> io:put_chars(\"now!\\n\") end, []]).\n```\n\n----------------------------------------\n\nTITLE: Simple Function Definition in Erlang and Core Erlang\nDESCRIPTION: Comparison of a basic function with no arguments returning an atom in both Erlang and Core Erlang formats.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2018-5-07-core-erlang-by-example.md#2025-04-22_snippet_1\n\nLANGUAGE: erlang\nCODE:\n```\nsimplest() -> 'ok'.\n```\n\nLANGUAGE: erlang\nCODE:\n```\n'simplest'/0 =\n    fun () ->\n\t'ok'\n```\n\n----------------------------------------\n\nTITLE: Configuring ETS Write Concurrency Locks in Erlang\nDESCRIPTION: Configure option for setting the number of locks for hash-based ETS tables. This example shows setting the maximum value of 256 locks instead of the default 64.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/_posts/2021-08-03-scalable-ets-counters.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./configure --with-ets-write-concurrency-locks=256\n```\n\n----------------------------------------\n\nTITLE: Listing Project Ideas in Markdown\nDESCRIPTION: A markdown list of potential improvements and features for the Erlang.org website project, including analytics integration, visual testing, community page redesign, and documentation enhancements.\nSOURCE: https://github.com/erlang/erlang-org/blob/master/README.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n## Ideas\n\n* Add plausable.io tracking\n* Add <https://search.google.com/search-console/> support?\n* Add visual testing\n  * Use [BackstopJS](https://css-tricks.com/automating-css-regression-testing/) for regression testing \n  * <https://applitools.com/>\n* Rework /community to not just be a bunch of links. Maybe the rust page can give some inspiration? <https://www.rust-lang.org/community>\n* Add markdownlint? <https://www.npmjs.com/package/markdownlint>\n* Add paginated docsearch results. See <https://discourse.algolia.com/t/dedicated-search-page/583> and <https://jsfiddle.net/maxiloc/oemnhuv4/>\n* `/docs`\n  * Other sections? Learning/Developing/References\n* `/community`\n  * Beam Languages\n  * Other projects\n```"
  }
]