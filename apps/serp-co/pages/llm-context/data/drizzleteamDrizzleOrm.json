[
  {
    "owner": "drizzle-team",
    "repo": "drizzle-orm",
    "content": "TITLE: Implementing Transactions in SQLite\nDESCRIPTION: This code demonstrates how to implement transactions using Drizzle ORM. It uses the `db.transaction` method to execute a series of database operations (insert, update, delete) within a single transaction block.  If any operation fails, the entire transaction is rolled back.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ndb.transaction((tx) => {\n  tx.insert(users).values(newUser).run();\n  tx.update(users).set({ name: 'Mr. Dan' }).where(eq(users.name, 'Dan')).run();\n  tx.delete(users).where(eq(users.name, 'Dan')).run();\n});\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for UPDATE ... FROM with returning\nDESCRIPTION: The generated SQL includes a `RETURNING` clause that specifies the columns to be returned after the update operation. The result set contains the `id` from the `users` table and the `name` from the `cities` table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nupdate \"users\" set \"city_id\" = \"cities\".\"id\" \nfrom \"cities\" \nreturning \"users\".\"id\", \"cities\".\"name\"\n```\n\n----------------------------------------\n\nTITLE: Updating JSONB column to JSONB\nDESCRIPTION: This SQL query updates a JSONB column in a PostgreSQL table by converting its string representation to a JSONB object.  It extracts the string value using `#>> '{}'` and then casts it back to JSONB.  This is intended to correct cases where JSON data was inadvertently stored as a string.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.33.0.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nupdate table_name\nset jsonb_column = (jsonb_column #>> '{}')::jsonb;\n```\n\n----------------------------------------\n\nTITLE: Generating Zod Schemas from Drizzle ORM Schema - TypeScript\nDESCRIPTION: This example demonstrates how to generate Zod schemas (insert, select) from a Drizzle ORM table schema using `createInsertSchema` and `createSelectSchema` from the `drizzle-zod` plugin.  It defines a `users` table with columns for `id`, `name`, `email`, `role`, and `createdAt` and then generates schemas for inserting and selecting data from this table. Dependencies include `drizzle-orm/pg-core`, `drizzle-zod`, and `zod`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-zod/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';\nimport { createInsertSchema, createSelectSchema } from 'drizzle-zod';\nimport { z } from 'zod';\n\nconst users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  email: text('email').notNull(),\n  role: text('role', { enum: ['admin', 'user'] }).notNull(),\n  createdAt: timestamp('created_at').notNull().defaultNow(),\n});\n\n// Schema for inserting a user - can be used to validate API requests\nconst insertUserSchema = createInsertSchema(users);\n\n// Schema for updating a user - can be used to validate API requests\nconst updateUserSchema = createUpdateSchema(users);\n\n// Schema for selecting a user - can be used to validate API responses\nconst selectUserSchema = createSelectSchema(users);\n```\n\n----------------------------------------\n\nTITLE: MySQL $returningId() with autoincrement PK - TypeScript\nDESCRIPTION: Demonstrates using the `$returningId()` function in Drizzle ORM with MySQL to automatically retrieve inserted IDs for tables with autoincrement primary keys. It uses the `mysqlTable` function to define the table schema with an autoincrement integer primary key. The `$returningId()` function retrieves the generated ID after inserting new rows.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { boolean, int, text, mysqlTable } from 'drizzle-orm/mysql-core';\n\nconst usersTable = mysqlTable('users', {\n  id: int('id').primaryKey(),\n  name: text('name').notNull(),\n  verified: boolean('verified').notNull().default(false),\n});\n\n\nconst result = await db.insert(usersTable).values([{ name: 'John' }, { name: 'John1' }]).$returningId();\n//    ^? { id: number }[]\n```\n\n----------------------------------------\n\nTITLE: pg_vector Distance Helpers - TypeScript\nDESCRIPTION: This snippet demonstrates the use of helper functions for calculating various distances with the `pg_vector` extension, including L2 distance, L1 distance, inner product, cosine distance, Hamming distance, and Jaccard distance. These functions provide a convenient way to integrate vector operations into Drizzle queries. Requires the `drizzle-orm` package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { l2Distance, l1Distance, innerProduct, \n          cosineDistance, hammingDistance, jaccardDistance } from 'drizzle-orm'\n\nl2Distance(table.column, [3, 1, 2]) // table.column <-> '[3, 1, 2]'\nl1Distance(table.column, [3, 1, 2]) // table.column <+> '[3, 1, 2]'\n\ninnerProduct(table.column, [3, 1, 2]) // table.column <#> '[3, 1, 2]'\ncosineDistance(table.column, [3, 1, 2]) // table.column <=> '[3, 1, 2]'\n\nhammingDistance(table.column, '101') // table.column <~> '101'\njaccardDistance(table.column, '101') // table.column <%> '101'\n```\n\n----------------------------------------\n\nTITLE: Defining Drizzle ORM Table and Generating Typebox Schemas (TS)\nDESCRIPTION: This code snippet demonstrates how to define a Drizzle ORM table and generate Typebox schemas for insert, update, and select operations using the `drizzle-typebox` plugin. It uses `createInsertSchema`, `createUpdateSchema`, and `createSelectSchema` functions from the plugin. The Drizzle ORM schema for the `users` table is defined using `pgTable` and `pgEnum` from `drizzle-orm/pg-core`. The `Type` object comes from `@sinclair/typebox`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-typebox/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';\nimport { createInsertSchema, createSelectSchema } from 'drizzle-typebox';\nimport { Type } from '@sinclair/typebox';\nimport { Value } from '@sinclair/typebox/value';\n\nconst users = pgTable('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\temail: text('email').notNull(),\n\trole: text('role', { enum: ['admin', 'user'] }).notNull(),\n\tcreatedAt: timestamp('created_at').notNull().defaultNow(),\n});\n\n// Schema for inserting a user - can be used to validate API requests\nconst insertUserSchema = createInsertSchema(users);\n\n// Schema for updating a user - can be used to validate API requests\nconst updateUserSchema = createUpdateSchema(users);\n\n// Schema for selecting a user - can be used to validate API responses\nconst selectUserSchema = createSelectSchema(users);\n\n// Overriding the fields\nconst insertUserSchema = createInsertSchema(users, {\n\trole: Type.String(),\n});\n\n// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema\nconst insertUserSchema = createInsertSchema(users, {\n\tid: (schema) => Type.Number({ ...schema, minimum: 0 }),\n\trole: Type.String(),\n});\n\n// Usage\n\nconst isUserValid: boolean = Value.Check(insertUserSchema, {\n\tname: 'John Doe',\n\temail: 'johndoe@test.com',\n\trole: 'admin',\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to libSQL or Turso - TypeScript\nDESCRIPTION: This example demonstrates how to connect to a libSQL or Turso database with Drizzle ORM. It covers both remote and local database connections.  Note that the queries are asynchronous.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// libSQL or Turso\nimport { drizzle, LibSQLDatabase } from 'drizzle-orm/libsql';\nimport { Database } from '@libsql/sqlite3';\n\nconst sqlite = new Database('libsql://...'); // Remote server\n// or\nconst sqlite = new Database('sqlite.db'); // Local file\n\nconst db/*: LibSQLDatabase*/ = drizzle(sqlite);\nconst result = await db.select().from(users).all(); // pay attention this one is async\n```\n\n----------------------------------------\n\nTITLE: Generated SQL Migration Script in SQLite\nDESCRIPTION: This is an example of a SQL migration script generated by Drizzle Kit based on the table schemas defined earlier. It creates the tables `auth_otp` and `users`, defines a foreign key constraint between `auth_otp` and `users`, and creates an index on the `users` table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_40\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE IF NOT EXISTS auth_otp (\n  'id' INTEGER PRIMARY KEY,\n  'phone' TEXT,\n  'user_id' INTEGER\n);\n\nCREATE TABLE IF NOT EXISTS users (\n  'id' INTEGER PRIMARY KEY,\n  'full_name' TEXT\n);\n\nDO $$ BEGIN\n ALTER TABLE auth_otp ADD CONSTRAINT auth_otp_user_id_fkey FOREIGN KEY ('user_id') REFERENCES users(id);\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$\n\nCREATE INDEX IF NOT EXISTS users_full_name_index ON users (full_name);\n```\n\n----------------------------------------\n\nTITLE: Creating a Table with Foreign Key to Supabase Auth Table\nDESCRIPTION: This snippet showcases creating a table with a foreign key relationship to the `auth.users` table in Supabase. It includes a policy enabling `authenticatedRole` to view all profiles.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { foreignKey, pgPolicy, pgTable, text, uuid } from \"drizzle-orm/pg-core\";\nimport { sql } from \"drizzle-orm/sql\";\nimport { authenticatedRole, authUsers } from \"drizzle-orm/supabase\";\n\nexport const profiles = pgTable(\n  \"profiles\",\n  {\n    id: uuid().primaryKey().notNull(),\n    email: text().notNull(),\n  },\n  (table) => [\n    foreignKey({\n      columns: [table.id],\n\t  // reference to the auth table from Supabase\n      foreignColumns: [authUsers.id],\n      name: \"profiles_id_fk\",\n    }).onDelete(\"cascade\"),\n    pgPolicy(\"authenticated can view all profiles\", {\n      for: \"select\",\n\t  // using predefined role from Supabase\n      to: authenticatedRole,\n      using: sql`true`,\n    }),\n  ]\n);\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Identity Columns - TypeScript\nDESCRIPTION: Illustrates defining identity columns in PostgreSQL using Drizzle ORM. The example shows how to use `generatedAlwaysAsIdentity` to define a column that automatically generates values using a sequence. You can specify the sequence properties directly within the `generatedAlwaysAsIdentity` function.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, integer, text } from 'drizzle-orm/pg-core' \n\nexport const ingredients = pgTable(\"ingredients\", {\n  id: integer(\"id\").primaryKey().generatedAlwaysAsIdentity({ startWith: 1000 }),\n  name: text(\"name\").notNull(),\n  description: text(\"description\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Foreign Key (Now)\nDESCRIPTION: Defines a foreign key constraint using the updated `foreignKey()` API, which now accepts a direct object specifying the columns and foreign columns. The callback function is no longer required, simplifying the syntax.  This is the recommended approach in version 0.15.0 and later.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-pg/0.15.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const usersTable = pgTable(\n\t'users_table',\n\t{\n\t\tid: serial('id').primaryKey(),\n\t\tuuid: uuid('uuid').defaultRandom().notNull(),\n\t\thomeCity: integer('home_city').notNull()\n\t},\n\t(users) => ({\n\t\t// foreignKey doesn't have a callback as param\n\t\tusersCityFK: foreignKey({ columns: [users.homeCity], foreignColumns: [cities.id] }),\n\t}),\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with node-postgres (new API)\nDESCRIPTION: Demonstrates the updated API for initializing a Drizzle database instance with node-postgres. It covers using a connection string, a connection object with individual parameters, and the inclusion of logger and schema options. This API creates driver clients under the hood.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from \"drizzle-orm/node-postgres\";\n\nconst db = drizzle(process.env.DATABASE_URL);\n// or\nconst db = drizzle({\n  connection: process.env.DATABASE_URL\n});\nconst db = drizzle({\n  connection: {\n    user: \"...\",\n    password: \"...\",\n    host: \"...\",\n    port: 4321,\n    db: \"...\",\n  },\n});\n\n// if you need to pass logger or schema\nconst db = drizzle({\n  connection: process.env.DATABASE_URL,\n  logger: true,\n  schema: schema,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining UNIQUE Constraints in MySQL with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define UNIQUE constraints in MySQL using Drizzle ORM. It shows both single-column and multi-column constraints, including the use of custom constraint names. Note that MySQL does not support the `NULLS NOT DISTINCT` option. The code requires the `mysqlTable`, `serial`, and `text` functions from the Drizzle ORM package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.2.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// single column\nconst table = mysqlTable('table', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull().unique(),\n    state: text('state').unique('custom'),\n    field: text('field').unique('custom_field'),\n});\n// multiple columns\nconst table = mysqlTable('cities1', {\n    id: serial('id').primaryKey(),\n    name: text('name').notNull(),\n    state: text('state'),\n}, (t) => ({\n    first: unique().on(t.name, t.state),\n    second: unique('custom_name1').on(t.name, t.state),\n}));\n```\n\n----------------------------------------\n\nTITLE: Create Insert/Update/Select Schemas - TypeScript\nDESCRIPTION: Demonstrates creating insert, update, and select schemas using `createInsertSchema`, `createUpdateSchema`, and `createSelectSchema` from `drizzle-valibot`. These schemas are generated from the Drizzle ORM `users` table schema. The generated schemas can be used to validate API requests and responses.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-valibot/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Schema for inserting a user - can be used to validate API requests\nconst insertUserSchema = createInsertSchema(users);\n\n// Schema for updating a user - can be used to validate API requests\nconst updateUserSchema = createUpdateSchema(users);\n\n// Schema for selecting a user - can be used to validate API responses\nconst selectUserSchema = createSelectSchema(users);\n```\n\n----------------------------------------\n\nTITLE: Conditional WHERE Clause with .if() in Drizzle ORM (TypeScript)\nDESCRIPTION: This code snippet demonstrates the use of the `.if()` function in Drizzle ORM to conditionally apply a `gt` (greater than) condition to a WHERE clause. The function `getUsersAfter` selects users from the `users` table where the `id` is greater than the provided `cursor` value, but only if a `cursor` value is provided. If `cursor` is undefined, the `gt` condition is not applied.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.10.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction getUsersAfter(cursor?: number) {\n    return db.select().from(users).where(\n        gt(users.id, cursor).if(cursor)\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Drizzle Query with Relations\nDESCRIPTION: This code snippet shows a Drizzle ORM query that retrieves comments along with their associated user and post data. It specifies which columns to include from the related tables using the `columns` option and includes nested relations (post's user). This example demonstrates the structure of a relational query in Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst items = await db.query.comments.findMany({\n  limit,\n  orderBy: comments.id,\n  with: {\n    user: {\n      columns: { name: true },\n    },\n    post: {\n      columns: { title: true },\n      with: {\n        user: {\n          columns: { name: true },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Insert, Select and Update Schemas - TypeScript\nDESCRIPTION: Demonstrates how to use `createInsertSchema`, `createSelectSchema`, and `createUpdateSchema` from the `drizzle-arktype` plugin to generate ArkType schemas for the `users` table. These schemas are intended for validating data during insert, select, and update operations.  The schemas can be used to validate API requests and responses.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-arktype/0.1.2.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Schema for inserting a user - can be used to validate API requests\nconst insertUserSchema = createInsertSchema(users);\n\n// Schema for updating a user - can be used to validate API requests\nconst updateUserSchema = createUpdateSchema(users);\n\n// Schema for selecting a user - can be used to validate API responses\nconst selectUserSchema = createSelectSchema(users);\n```\n\n----------------------------------------\n\nTITLE: Creating Update Schema for Tables - Typescript\nDESCRIPTION: Illustrates the usage of `createUpdateSchema` with a Drizzle ORM table for generating update schemas. It defines a `users` table with `id`, `name`, and `age` columns. It then creates an update schema and demonstrates how to parse user data for updating purposes, highlighting that generated columns like `id` cannot be updated.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-valibot/0.3.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, text, integer } from 'drizzle-orm/pg-core';\nimport { createUpdateSchema } from 'drizzle-valibot';\nimport { parse } from 'valibot';\n\nconst users = pgTable('users', {\n  id: integer().generatedAlwaysAsIdentity().primaryKey(),\n  name: text().notNull(),\n  age: integer().notNull()\n});\n\nconst userUpdateSchema = createUpdateSchema(users);\n\nconst user = { id: 5, name: 'John' };\nconst parsed: { name?: string | undefined, age?: number | undefined } = parse(userUpdateSchema, user); // Error: `id` is a generated column, it can't be updated\n\nconst user = { age: 35 };\nconst parsed: { name?: string | undefined, age?: number | undefined } = parse(userUpdateSchema, user); // Will parse successfully\nawait db.update(users).set(parsed).where(eq(users.name, 'Jane'));\n```\n\n----------------------------------------\n\nTITLE: Using the Insert Schema for Validation - TypeScript\nDESCRIPTION: Demonstrates how to use the generated `insertUserSchema` with a validation function (`parse`) to validate a user object. It checks if the provided data matches the defined schema. Requires a `parse` function, presumably from ArkType or a similar validation library. This validates that the input data conforms to the insert user schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-arktype/0.1.2.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Usage\n\nconst isUserValid = parse(insertUserSchema, {\n\tname: 'John Doe',\n\temail: 'johndoe@test.com',\n\trole: 'admin',\n});\n```\n\n----------------------------------------\n\nTITLE: Defining SQLite Table Schema - TypeScript\nDESCRIPTION: This snippet demonstrates how to declare a SQLite table schema using Drizzle ORM. It defines 'countries' and 'cities' tables with columns, primary keys, unique indexes and foreign key constraints. The `export` keyword is crucial for use with drizzle-kit.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sqliteTable, text, integer, uniqueIndex } from 'drizzle-orm/sqlite-core';\n\nexport const countries = sqliteTable('countries', {\n    id: integer('id').primaryKey(),\n    name: text('name'),\n  }, (countries) => ({\n    nameIdx: uniqueIndex('nameIdx').on(countries.name),\n  })\n);\n\nexport const cities = sqliteTable('cities', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n  countryId: integer('country_id').references(() => countries.id),\n})\n```\n\n----------------------------------------\n\nTITLE: Connecting to Cloudflare D1 - TypeScript\nDESCRIPTION: This snippet shows how to connect to a Cloudflare D1 database using Drizzle ORM. It imports the DrizzleD1Database type and drizzle function, connects to the database using the environment variable, and queries the 'users' table asynchronously.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Cloudflare D1 connector\nimport { drizzle, DrizzleD1Database } from 'drizzle-orm/d1';\n\n// env.DB from cloudflare worker environment\nconst db/*: DrizzleD1Database*/ = drizzle(env.DB);\nconst result = await db.select().from(users).all(); // pay attention this one is async\n```\n\n----------------------------------------\n\nTITLE: Selecting Fields from Schema - TypeScript\nDESCRIPTION: This example shows how to pick specific fields from generated Zod schema using the `pick` method. It selects the `name` and `email` fields from `insertUserSchema` to create a new schema. Dependencies include `drizzle-orm/pg-core`, `drizzle-zod`, and `zod`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-zod/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Zod schema type is also inferred from the table schema, so you have full type safety\nconst requestSchema = insertUserSchema.pick({ name: true, email: true });\n```\n\n----------------------------------------\n\nTITLE: MySQL $returningId() with custom primary keys - TypeScript\nDESCRIPTION: Illustrates using `$returningId()` in Drizzle ORM with MySQL to retrieve custom generated primary keys. The example uses `mysqlTable` and `$defaultFn` to define a table with a custom primary key generated at runtime. The `$returningId()` call returns these generated keys after insertion.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { varchar, text, mysqlTable } from 'drizzle-orm/mysql-core';\nimport { createId } from '@paralleldrive/cuid2';\n\nconst usersTableDefFn = mysqlTable('users_default_fn', {\n  customId: varchar('id', { length: 256 }).primaryKey().$defaultFn(createId),\n  name: text('name').notNull(),\n});\n\n\nconst result = await db.insert(usersTableDefFn).values([{ name: 'John' }, { name: 'John1' }]).$returningId();\n//  ^? { customId: string }[]\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL SSL with Drizzle Kit (Typescript)\nDESCRIPTION: This snippet configures SSL settings for a PostgreSQL database connection using Drizzle Kit. It demonstrates how to set the 'ssl' property within the 'dbCredentials' object to 'true', which represents SSL connection options from node:tls.  This configures the Drizzle Kit to use SSL for connecting to the PostgreSQL database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'drizzle-kit'\n\nexport default defaultConfig({\n  dialect: \"postgresql\",\n  dbCredentials: {\n    ssl: true, //\"require\" | \"allow\" | \"prefer\" | \"verify-full\" | options from node:tls\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Drizzle ORM schema\nDESCRIPTION: Defines a database schema using Drizzle ORM's TypeScript API, including table definitions for 'users' and 'auth_otp'. It uses `pgTable` to define tables with columns like `id`, `fullName`, `phone`, and `userId`, specifying primary keys, data types, and foreign key relationships. Indexes can also be defined on the tables.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-kit/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// src/db/schema.ts\n\nimport { integer, pgTable, serial, text, varchar } from \"drizzle-orm/pg-core\";\n\nconst users = pgTable(\"users\", {\n    id: serial(\"id\").primaryKey(),\n    fullName: varchar(\"full_name\", { length: 256 }),\n  }, (table) => ({\n    nameIdx: index(\"name_idx\", table.fullName),\n  })\n);\n\nexport const authOtp = pgTable(\"auth_otp\", {\n  id: serial(\"id\").primaryKey(),\n  phone: varchar(\"phone\", { length: 256 }),\n  userId: integer(\"user_id\").references(() => users.id),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining UNIQUE Constraints in PostgreSQL with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define UNIQUE constraints in PostgreSQL using Drizzle ORM. It shows both single-column and multi-column constraints, including the use of custom constraint names and the `nullsNotDistinct` option. The code requires the `pgTable`, `serial`, `text`, and `char` functions from the Drizzle ORM package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.2.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// single column\nconst table = pgTable('table', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull().unique(),\n  state: char('state', { length: 2 }).unique('custom'),\n  field: char('field', { length: 2 }).unique('custom_field', { nulls: 'not distinct' }),\n});\n// multiple columns\nconst table = pgTable('table', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  state: char('state', { length: 2 }),\n}, (t) => ({\n  first: unique('custom_name').on(t.name, t.state).nullsNotDistinct(),\n  second: unique('custom_name1').on(t.name, t.state),\n}));\n```\n\n----------------------------------------\n\nTITLE: D1 Batch API Usage Example in Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to use the Batch API in Drizzle ORM with Cloudflare D1. It showcases inserting, updating, querying, and selecting data in a single batch operation using `db.batch`. The example uses the `usersTable` and performs operations like inserting a new user, updating an existing user's name, and fetching multiple users.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst batchResponse = await db.batch([\n  db.insert(usersTable).values({ id: 1, name: 'John' }).returning({\n    id: usersTable.id,\n  }),\n  db.update(usersTable).set({ name: 'Dan' }).where(eq(usersTable.id, 1)),\n  db.query.usersTable.findMany({}),\n  db.select().from(usersTable).where(eq(usersTable.id, 1)),\n  db.select({ id: usersTable.id, invitedBy: usersTable.invitedBy }).from(\n    usersTable,\n  ),\n]);\n```\n\n----------------------------------------\n\nTITLE: Using Transactions with Drizzle ORM and node-postgres (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use transactions in Drizzle ORM with the node-postgres driver. It showcases inserting, updating, and deleting data within a single transaction. The transaction ensures atomicity and consistency of the database operations.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.23.9.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.transaction(async (tx) => {\n  await tx.insert(users).values(newUser);\n  await tx.update(users).set({ name: 'Mr. Dan' }).where(eq(users.name, 'Dan'));\n  await tx.delete(users).where(eq(users.name, 'Dan'));\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Views in Drizzle ORM (TypeScript)\nDESCRIPTION: This code snippet illustrates how to define views (both regular and materialized) in Drizzle ORM using TypeScript. It imports necessary modules from 'drizzle-orm' and 'drizzle-orm/pg-core'. The 'simpleView' is a regular view, while 'materializedView' is a materialized view. Both views select all columns from the 'users' table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.26.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sql } from \"drizzle-orm\";\nimport {\n  check,\n  pgMaterializedView,\n  pgTable,\n  pgView,\n} from \"drizzle-orm/pg-core\";\n\nexport const users = pgTable(\n  \"users\",\n  (c) => ({\n    id: c.uuid().defaultRandom().primaryKey(),\n    username: c.text().notNull(),\n    age: c.integer(),\n  }),\n  (table) => ({\n    checkConstraint: check(\"age_check\", sql`${table.age} > 21`),\n  })\n);\n\nexport const simpleView = pgView(\"simple_users_view\").as((qb) =>\n  qb.select().from(users)\n);\n\nexport const materializedView = pgMaterializedView(\n  \"materialized_users_view\"\n).as((qb) => qb.select().from(users));\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Table with Supabase Role-Based Policy\nDESCRIPTION: This example demonstrates how to create a table and define a policy that restricts insert access to the `serviceRole`.  It showcases the integration of Supabase roles within Drizzle ORM for fine-grained access control.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sql } from 'drizzle-orm';\nimport { serviceRole } from 'drizzle-orm/supabase';\nimport { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';\n\nexport const admin = pgRole('admin');\n\nexport const users = pgTable('users', {\n\tid: integer(),\n}, (t) => [\n\tpgPolicy(`policy-insert`, {\n\t\tfor: 'insert',\n\t\tto: serviceRole,\n\t\twithCheck: sql`false`,\n\t}),\n]);\n```\n\n----------------------------------------\n\nTITLE: Defining Composite Primary Keys in PostgreSQL with Drizzle ORM\nDESCRIPTION: This code shows how to define a composite primary key in a PostgreSQL table using Drizzle ORM's `primaryKey` function. The function takes the table object and the columns that should form the primary key as arguments.  The `pgTable` function is used to define the table schema and columns.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { primaryKey } from 'drizzle-orm/pg-core';\n\nexport const cpkTable = pgTable('table', {\n  column1: integer('column1').default(10).notNull(),\n  column2: integer('column2'),\n  column3: integer('column3'),\n}, (table) => ({\n  cpk: primaryKey(table.column1, table.column2),\n}));\n```\n\n----------------------------------------\n\nTITLE: Drizzle Table Definition (New Style)\nDESCRIPTION: This TypeScript code snippet shows the newer, more concise way to define a Drizzle table schema using a callback function that provides all column types. This eliminates the need to repeat column names if they are the same as the TypeScript property names.  `pgTable` is imported from `drizzle-orm/pg-core`\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable } from \"drizzle-orm/pg-core\";\n\nexport const ingredients = pgTable(\"ingredients\", (t) => ({\n  id: t.uuid().defaultRandom().primaryKey(),\n  name: t.text().notNull(),\n  description: t.text(),\n  inStock: t.boolean(\"in_stock\").default(true),\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining Column Types - TypeScript\nDESCRIPTION: This example lists several column types available in Drizzle ORM, including integer, real, text, blob, and column modifiers like primaryKey, notNull, and default. It also shows how to define enums and custom blob types.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ninteger('...');\ninteger('...', { mode: 'number' | 'timestamp' | 'timestamp_ms' })\nreal('...');\ntext('...');\ntext('role', { enum: ['admin', 'user'] });\n\nblob('...');\nblob('...', { mode: 'json' | 'buffer' });\nblob('...').$type<{ foo: string }>();\n\ncolumn.primaryKey();\ncolumn.notNull();\ncolumn.default(...);\n```\n\n----------------------------------------\n\nTITLE: pg_vector Query Examples with Drizzle ORM\nDESCRIPTION: This snippet provides several examples of how to translate pg_vector queries from PostgreSQL syntax to Drizzle ORM syntax.  It demonstrates using the predefined `l2Distance` function, creating subqueries, and utilizing SQL template literals for more complex operations. These examples cover ordering, selecting, and performing calculations with vector data.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0-beta.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { l2Distance } from 'drizzle-orm';\n\n// SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;\ndb.select().from(items).orderBy(l2Distance(items.embedding, [3,1,2]))\n\n// SELECT embedding <-> '[3,1,2]' AS distance FROM items;\ndb.select({ distance: l2Distance(items.embedding, [3,1,2]) })\n\n// SELECT * FROM items ORDER BY embedding <-> (SELECT embedding FROM items WHERE id = 1) LIMIT 5;\nconst subquery = db.select({ embedding: items.embedding }).from(items).where(eq(items.id, 1));\ndb.select().from(items).orderBy(l2Distance(items.embedding, subquery)).limit(5)\n\n// SELECT (embedding <#> '[3,1,2]') * -1 AS inner_product FROM items;\ndb.select({ innerProduct: sql`(${maxInnerProduct(items.embedding, [3,1,2])}) * -1` }).from(items)\n\n// and more!\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with Bun SQL Driver\nDESCRIPTION: This snippet demonstrates how to initialize Drizzle ORM using the new Bun SQL driver. It imports the `drizzle` function and creates a database instance using the environment variable `PG_DB_URL`. The code then executes a simple select query.  The database connection string is accessed through `process.env.PG_DB_URL!`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/bun-sql';\n\nconst db = drizzle(process.env.PG_DB_URL!);\n\nconst result = await db.select().from(...);\n```\n\n----------------------------------------\n\nTITLE: Defining Relations with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define one-to-many relations in Drizzle ORM using TypeScript. It defines `users` and `posts` tables, and establishes a relationship between them. The `relations` function is used to specify the relationships without affecting migrations or Core API logic.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\n \nexport const users = pgTable('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n});\n \nexport const usersConfig = relations(users, ({ many }) => ({\n\tposts: many(posts),\n}));\n \nexport const posts = pgTable('posts', {\n\tid: serial('id').primaryKey(),\n\tcontent: text('content').notNull(),\n\tauthorId: integer('author_id').notNull(),\n});\n \nexport const postsConfig = relations(posts, ({ one }) => ({\n\tauthor: one(users, { fields: [posts.authorId], references: [users.id] }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Upsert (Insert with On Conflict) - SQLite\nDESCRIPTION: Demonstrates how to perform upsert operations (insert with on conflict) using Drizzle ORM with SQLite, including updating or doing nothing on conflict.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\ndb.insert(users)\n  .values({ id: 1, name: 'Dan' })\n  .onConflictDoUpdate({ target: users.id, set: { name: 'John' } })\n  .run();\n\ndb.insert(users)\n  .values({ id: 1, name: 'John' })\n  .onConflictDoNothing()\n  .run();\n\ndb.insert(users)\n  .values({ id: 1, name: 'John' })\n  .onConflictDoNothing({ target: users.id })\n  .run();\n```\n\n----------------------------------------\n\nTITLE: Defining Composite Primary Keys in MySQL with Drizzle ORM\nDESCRIPTION: This code snippet illustrates how to define a composite primary key in a MySQL table using Drizzle ORM. The `mysqlTable` function defines the table schema. The `primaryKey` function is used to define the primary key constraint across multiple columns. The table object is passed as the argument in the callback function to the table definition.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { primaryKey } from 'drizzle-orm/mysql-core';\n\nexport const cpkTable = mysqlTable('table', {\n  simple: int('simple'),\n  columnNotNull: int('column_not_null').notNull(),\n  columnDefault: int('column_default').default(100),\n}, (table) => ({\n  cpk: primaryKey(table.simple, table.columnDefault),\n}));\n```\n\n----------------------------------------\n\nTITLE: Define Drizzle ORM Table Schema - TypeScript\nDESCRIPTION: Defines a Drizzle ORM table schema for 'users' with columns for id, name, email, role, and createdAt.  Uses `pgTable` from 'drizzle-orm/pg-core' to define the schema. This schema serves as the foundation for generating valibot schemas using `drizzle-valibot`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-valibot/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';\nimport { createInsertSchema, createSelectSchema } from 'drizzle-valibot';\nimport { string, parse, number, pipe } from 'valibot';\n\nconst users = pgTable('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\temail: text('email').notNull(),\n\trole: text('role', { enum: ['admin', 'user'] }).notNull(),\n\tcreatedAt: timestamp('created_at').notNull().defaultNow(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining UNIQUE Constraints in SQLite with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define UNIQUE constraints in SQLite using Drizzle ORM. It shows both single-column and multi-column constraints, including the use of custom constraint names. In SQLite, unique constraints are treated as unique indexes. The code requires the `sqliteTable`, `int`, and `text` functions from the Drizzle ORM package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.2.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// single column\nconst table = sqliteTable('table', {\n    id: int('id').primaryKey(),\n    name: text('name').notNull().unique(),\n    state: text('state').unique('custom'),\n    field: text('field').unique(),\n});\n// multiple columns\nconst table = sqliteTable('table', {\n    id: int('id').primaryKey(),\n    name: text('name').notNull(),\n    state: text('state'),\n}, (t) => ({\n    first: unique().on(t.name, t.state),\n    second: unique('custom').on(t.name, t.state),\n}));\n```\n\n----------------------------------------\n\nTITLE: Drizzle ORM Join with All Fields Selection\nDESCRIPTION: This code snippet demonstrates how to select all the fields from all the tables involved in the join without explicitly listing them. This is achieved by omitting the argument of the `select` method. The result type will have nested objects for each table, with the table/column names used as keys in the result object. The joined table will be nullable.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst rows = await db.select().from(cities).leftJoin(users, eq(users.cityId, cities.id));\n```\n\n----------------------------------------\n\nTITLE: Defining Database and Table Entity Types - TypeScript\nDESCRIPTION: This snippet showcases how to define TypeScript types for database tables using Drizzle ORM's `InferModel`. It also demonstrates how to use these types when querying and inserting data into the database using better-sqlite3.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { text, integer, sqliteTable } from 'drizzle-orm/sqlite-core';\nimport { InferModel } from 'drizzle-orm';\n\nconst users = sqliteTable('users', {\n  id: integer('id').primaryKey(),\n  fullName: text('full_name'),\n  phone: text('phone'),\n})\n\nexport type User = InferModel<typeof users> // return type when queried\nexport type InsertUser = InferModel<typeof users, 'insert'> // insert type\n...\nimport { drizzle, BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';\nimport Database from 'better-sqlite3';\n\nconst sqlite = new Database('sqlite.db');\nconst db: BetterSQLite3Database = drizzle(sqlite);\n\nconst result: User[] = await db.select().from(users).all();\n\nconst insertUser = (user: InsertUser) => {\n  return db.insert(users).values(user).run()\n}\n```\n\n----------------------------------------\n\nTITLE: MySQL Generated Columns - TypeScript\nDESCRIPTION: Demonstrates defining generated columns in MySQL using Drizzle ORM. The example shows how to create generated columns that are either `stored` or `virtual`, and how to reference other columns in the generated expression.  It utilizes `generatedAlwaysAs` with the mode option to specify the type of generated column.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = mysqlTable(\"users\", {\n  id: int(\"id\"),\n  id2: int(\"id2\"),\n  name: text(\"name\"),\n  generatedName: text(\"gen_name\").generatedAlwaysAs(\n    (): SQL => sql`${schema2.users.name} || 'hello'`,\n    { mode: \"stored\" }\n  ),\n  generatedName1: text(\"gen_name1\").generatedAlwaysAs(\n    (): SQL => sql`${schema2.users.name} || 'hello'`,\n    { mode: \"virtual\" }\n  ),\n}),\n```\n\n----------------------------------------\n\nTITLE: Parsing Data with Generated Schema - TypeScript\nDESCRIPTION: This example demonstrates how to use the generated `insertUserSchema` to parse and validate data. It creates a sample user object and validates it using `insertUserSchema.parse()`. This helps ensure data consistency and type safety.  Dependencies include `drizzle-orm/pg-core`, `drizzle-zod`, and `zod`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-zod/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Usage\n\nconst user = insertUserSchema.parse({\n  name: 'John Doe',\n  email: 'johndoe@test.com',\n  role: 'admin',\n});\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (Cloudflare D1)\nDESCRIPTION: This TypeScript code shows initializing Drizzle with Cloudflare D1.  It requires Cloudflare Worker types for the connection, typically retrieved from environment variables.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ndrizzle(\"d1\", {\n  connection: env.DB // CloudFlare Worker Types\n})\n```\n\n----------------------------------------\n\nTITLE: Using Prepared Statements with Placeholders in SQLite\nDESCRIPTION: This snippet demonstrates the usage of prepared statements with placeholders to optimize query performance.  It prepares a query with a placeholder for the `id` column and then executes the prepared statement with different values for the placeholder.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport { placeholder } from 'drizzle-orm';\n\nconst db = drizzle(...);\n\nconst q = db.select().from(customers).prepare();\nq.all() // SELECT * FROM customers\n\nconst q = db.select().from(customers).where(eq(customers.id, placeholder('id'))).prepare()\n\nq.get({ id: 10 }) // SELECT * FROM customers WHERE id = 10\nq.get({ id: 12 }) // SELECT * FROM customers WHERE id = 12\n\nconst q = db\n  .select()\n  .from(customers)\n  .where(sql`lower(${customers.name}) like ${placeholder('name')}`)\n  .prepare();\n\nq.all({ name: '%an%' }) // SELECT * FROM customers WHERE name ilike '%an%'\n```\n\n----------------------------------------\n\nTITLE: Creating a View in SQLite\nDESCRIPTION: This snippet demonstrates how to create a view using Drizzle ORM.  It uses `sqliteView` to define a view named `newYorkers` that selects users from the `users` table where `cityId` is 1. The `as` method is used to define the query for the view using a callback function.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sqliteView } from 'drizzle-orm/sqlite-core';\n\nconst newYorkers = sqliteView('new_yorkers').as((qb) => qb.select().from(users).where(eq(users.cityId, 1)));\n```\n\n----------------------------------------\n\nTITLE: Drizzle ORM Join with Nested Object Grouping\nDESCRIPTION: This code snippet demonstrates how to group the fields of the `users` table into a nested object within the `select` method. This allows for a single check to verify that the user was joined, making the code more convenient to use. The result type will have a nullable `user` property, which contains the user data if the join was successful or null otherwise.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst rows = await db\n  .select({\n    cityId: cities.id,\n    cityName: cities.name,\n    user: {\n      id: users.id,\n      firstName: users.firstName,\n      lastName: users.lastName,\n    },\n  })\n  .from(cities)\n  .leftJoin(users, eq(users.cityId, cities.id));\n```\n\n----------------------------------------\n\nTITLE: Defining Check Constraint in Drizzle ORM (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to define a check constraint within a Drizzle ORM schema definition using TypeScript. It imports necessary modules from 'drizzle-orm' and 'drizzle-orm/pg-core'. The 'users' table is defined with a check constraint named 'age_check' that ensures the 'age' column is greater than 21.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.26.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sql } from \"drizzle-orm\";\nimport { check, pgTable } from \"drizzle-orm/pg-core\";\n\nexport const users = pgTable(\n  \"users\",\n  (c) => ({\n    id: c.uuid().defaultRandom().primaryKey(),\n    username: c.text().notNull(),\n    age: c.integer(),\n  }),\n  (table) => ({\n    checkConstraint: check(\"age_check\", sql`${table.age} > 21`),\n  })\n);\n\n```\n\n----------------------------------------\n\nTITLE: Installing Drizzle ORM and Better SQLite3 - Bash\nDESCRIPTION: These commands install the Drizzle ORM core library and the better-sqlite3 driver. The second command installs drizzle-kit as a development dependency, enabling automatic migration generation.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install drizzle-orm better-sqlite3\n## opt-in automatic migrations generator\nnpm install -D drizzle-kit \n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with Bun SQL Instance\nDESCRIPTION: This snippet showcases how to initialize Drizzle ORM using an existing Bun SQL instance. It imports `drizzle` and `SQL` from `'bun'` and creates a new `SQL` client using the connection string from environment variables. Then, it initializes Drizzle with this client.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/bun-sqlite';\nimport { SQL } from 'bun';\n\nconst client = new SQL(process.env.PG_DB_URL!);\nconst db = drizzle({ client });\n\nconst result = await db.select().from(...);\n```\n\n----------------------------------------\n\nTITLE: Defining Table Schemas for Migrations in SQLite\nDESCRIPTION: This snippet defines the schema for two tables, `users` and `authOtps`, using Drizzle ORM's `sqliteTable` function. It also defines an index on the `fullName` column of the `users` table. These table definitions are used for generating SQL migrations.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nimport { index, integer, sqliteTable, text } from 'drizzle-orm/sqlite-core';\n\nexport const users = sqliteTable('users', {\n  id: integer('id').primaryKey(),\n  fullName: text('full_name'),\n}, (users) => ({\n  nameIdx: index('name_idx', users.fullName),\n}));\n\nexport const authOtps = sqliteTable('auth_otp', {\n  id: integer('id').primaryKey(),\n  phone: text('phone'),\n  userId: integer('user_id').references(() => users.id),\n});\n```\n\n----------------------------------------\n\nTITLE: UPDATE ... FROM example in PostgreSQL/SQLite - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `UPDATE ... FROM` feature in Drizzle ORM to update the `users` table based on data from the `cities` table. It updates the `cityId` column of the `users` table where the city name is 'Seattle' and the user name is 'John'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait db\n  .update(users)\n  .set({ cityId: cities.id })\n  .from(cities)\n  .where(and(eq(cities.name, 'Seattle'), eq(users.name, 'John')))\n```\n\n----------------------------------------\n\nTITLE: Type Inference with $inferSelect and $inferInsert - TypeScript\nDESCRIPTION: This snippet shows how to use `$inferSelect` and `$inferInsert` (and the deprecated `InferSelectModel` and `InferInsertModel`) to infer TypeScript types for select and insert operations on a Drizzle ORM table. These types are automatically derived from the table schema, providing type safety when working with data. It requires importing `InferSelectModel` and `InferInsertModel` from `drizzle-orm`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.3.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InferSelectModel, InferInsertModel } from 'drizzle-orm'\n\nconst usersTable = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  verified: boolean('verified').notNull().default(false),\n  jsonb: jsonb('jsonb').$type<string[]>(),\n  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n});\n\ntype SelectUser = typeof usersTable.$inferSelect;\ntype InsertUser = typeof usersTable.$inferInsert;\n\ntype SelectUser2 = InferSelectModel<typeof usersTable>;\ntype InsertUser2 = InferInsertModel<typeof usersTable>;\n```\n\n----------------------------------------\n\nTITLE: Define a PostgreSQL Table Schema in Drizzle ORM (TypeScript)\nDESCRIPTION: This code defines a PostgreSQL table schema named 'users' using Drizzle ORM's `pgTable` function. It includes columns for 'id' (serial, primary key), 'email' (text, not null), and 'name' (text). This schema is then used by `drizzle-kit export` to generate SQL DDL.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.30.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// schema.ts\nimport { pgTable, serial, text } from 'drizzle-orm/pg-core'\n\nexport const users = pgTable('users', {\n\tid: serial('id').primaryKey(),\n\temail: text('email').notNull(),\n\tname: text('name')\n});\n```\n\n----------------------------------------\n\nTITLE: pg_vector Queries - TypeScript\nDESCRIPTION: This snippet demonstrates various query examples utilizing the `pg_vector` extension and the `l2Distance` helper function within Drizzle ORM. It includes examples of ordering results by distance, selecting the distance as a field, and using a subquery for distance calculations.  Requires the `drizzle-orm` package and the `pg_vector` extension in PostgreSQL.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { l2Distance } from 'drizzle-orm';\n\n// SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;\ndb.select().from(items).orderBy(l2Distance(items.embedding, [3,1,2]))\n\n// SELECT embedding <-> '[3,1,2]' AS distance FROM items;\ndb.select({ distance: l2Distance(items.embedding, [3,1,2]) })\n\n// SELECT * FROM items ORDER BY embedding <-> (SELECT embedding FROM items WHERE id = 1) LIMIT 5;\nconst subquery = db.select({ embedding: items.embedding }).from(items).where(eq(items.id, 1));\ndb.select().from(items).orderBy(l2Distance(items.embedding, subquery)).limit(5)\n\n// SELECT (embedding <#> '[3,1,2]') * -1 AS inner_product FROM items;\ndb.select({ innerProduct: sql`(${maxInnerProduct(items.embedding, [3,1,2])}) * -1` }).from(items)\n```\n\n----------------------------------------\n\nTITLE: Current PostgreSQL Index API Definition\nDESCRIPTION: This snippet demonstrates the corrected way of defining PostgreSQL indexes in Drizzle ORM. It provides examples using both `.on()` and `.using()`.  With `.on()`, sorting and null ordering is defined on each column. `.using()` allows specifying the index type and includes columns or SQL expressions.  `.where()` and `.with()` can be used to add conditions and index parameters.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0-beta.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// First example, with `.on()`\nindex('name')\n  .on(table.column1.asc(), table.column2.nullsFirst(), ...) or .onOnly(table.column1.desc().nullsLast(), table.column2, ...)\n  .concurrently()\n  .where(sql``)\n  .with({ fillfactor: '70' })\n\n// Second Example, with `.using()`\nindex('name')\n  .using('btree', table.column1.asc(), sql`lower(${table.column2})`, table.column1.op('text_ops'))\n  .where(sql``) // sql expression\n  .with({ fillfactor: '70' })\n```\n\n----------------------------------------\n\nTITLE: Using Kysely with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to use Kysely as a query builder with a Drizzle ORM schema. It defines a table schema using Drizzle's `pgTable` and `serial` and `text` functions. Then, it uses Kysely to create a database connection and execute a simple select query. The `Kyselify` type is used to ensure type safety between Drizzle and Kysely.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/kysely/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Kysely, PostgresDialect } from 'kysely';\nimport { Pool } from 'pg';\nimport { Kyselify } from 'drizzle-orm/kysely';\nimport { pgTable, serial, text } from 'drizzle-orm/pg-core';\n\nconst test = pgTable('test', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\ninterface Database {\n  test: Kyselify<typeof test>;\n}\n\nconst db = new Kysely<Database>({\n  dialect: new PostgresDialect({\n    pool: new Pool(),\n  }),\n});\n\nconst result/*: { id: number, name: string }[] */ = db.selectFrom('test').selectAll().execute();\n```\n\n----------------------------------------\n\nTITLE: Performing Aggregations - SQLite\nDESCRIPTION: Shows how to perform aggregations (count, sum) with type safety using Drizzle ORM with SQLite, including joins and group by clauses.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst orders = sqliteTable('order', {\n  id: integer('id').primaryKey(),\n  orderDate: integer('order_date', { mode: 'timestamp' }).notNull(),\n  requiredDate: integer('required_date', { mode: 'timestamp' }).notNull(),\n  shippedDate: integer('shipped_date', { mode: 'timestamp' }),\n  shipVia: integer('ship_via').notNull(),\n  freight: numeric('freight').notNull(),\n  shipName: text('ship_name').notNull(),\n  shipCity: text('ship_city').notNull(),\n  shipRegion: text('ship_region'),\n  shipPostalCode: text('ship_postal_code'),\n  shipCountry: text('ship_country').notNull(),\n  customerId: text('customer_id').notNull(),\n  employeeId: integer('employee_id').notNull(),\n});\n\nconst details = sqliteTable('order_detail', {\n  unitPrice: numeric('unit_price').notNull(),\n  quantity: integer('quantity').notNull(),\n  discount: numeric('discount').notNull(),\n  orderId: integer('order_id').notNull(),\n  productId: integer('product_id').notNull(),\n});\n\n\ndb\n  .select({\n    id: orders.id,\n    shippedDate: orders.shippedDate,\n    shipName: orders.shipName,\n    shipCity: orders.shipCity,\n    shipCountry: orders.shipCountry,\n    productsCount: sql<number>`count(${details.productId})`,\n    quantitySum: sql<number>`sum(${details.quantity})`,\n    totalPrice: sql<number>`sum(${details.quantity} * ${details.unitPrice})`,\n  })\n  .from(orders)\n  .leftJoin(details, eq(orders.id, details.orderId))\n  .groupBy(orders.id)\n  .orderBy(asc(orders.id))\n  .all();\n```\n\n----------------------------------------\n\nTITLE: Aggregating Join Results with Array.reduce()\nDESCRIPTION: This code snippet demonstrates how to aggregate the results of a join using `Array.reduce()`. It transforms the array of `city-user?` combinations into a `Record` where the keys are city IDs and the values are objects containing the city and a list of users for that city. The `InferModel` type is used to infer the TypeScript types for the `User` and `City` objects from the table definitions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InferModel } from 'drizzle-orm';\n\ntype User = InferModel<typeof users>;\ntype City = InferModel<typeof cities>;\n\nconst rows = await db\n  .select({\n    city: cities,\n    user: users,\n  })\n  .from(cities)\n  .leftJoin(users, eq(users.cityId, cities.id));\n\nconst result = rows.reduce<Record<number, { city: City; users: User[] }>>(\n  (acc, row) => {\n    const city = row.city;\n    const user = row.user;\n\n    if (!acc[city.id]) {\n      acc[city.id] = { city, users: [] };\n    }\n\n    if (user) {\n      acc[city.id].users.push(user);\n    }\n\n    return acc;\n  },\n  {},\n);\n```\n\n----------------------------------------\n\nTITLE: LibSQL Foreign Key Reference Example\nDESCRIPTION: This SQL code illustrates the creation of tables with foreign key references. Note that creating a reference is possible on any column type, but inserting values requires the referenced column to have a unique index or primary key.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE parent(a PRIMARY KEY, b UNIQUE, c, d, e, f);\nCREATE UNIQUE INDEX i1 ON parent(c, d);\nCREATE INDEX i2 ON parent(e);\nCREATE UNIQUE INDEX i3 ON parent(f COLLATE nocase);\n\nCREATE TABLE child1(f, g REFERENCES parent(a));                        -- Ok\nCREATE TABLE child2(h, i REFERENCES parent(b));                        -- Ok\nCREATE TABLE child3(j, k, FOREIGN KEY(j, k) REFERENCES parent(c, d));  -- Ok\nCREATE TABLE child4(l, m REFERENCES parent(e));                        -- Error!\nCREATE TABLE child5(n, o REFERENCES parent(f));                        -- Error!\nCREATE TABLE child6(p, q, FOREIGN KEY(p, q) REFERENCES parent(b, c));  -- Error!\nCREATE TABLE child7(r REFERENCES parent(c));                           -- Error!\n```\n\n----------------------------------------\n\nTITLE: Updating and Deleting Data - SQLite\nDESCRIPTION: Illustrates how to update and delete data from a table using Drizzle ORM with SQLite, using a where clause for filtering.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ndb.update(users)\n  .set({ name: 'Mr. Dan' })\n  .where(eq(usersTable.name, 'Dan'))\n  .run();\n  \ndb.delete(users)\n  .where(eq(usersTable.name, 'Dan'))\n  .run();\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with Better SQLite3 - TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize Drizzle ORM with better-sqlite3. It imports necessary modules, defines a table schema, creates a database connection, and queries all users from the defined table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport Database from 'better-sqlite3';\n\nconst users = sqliteTable('users', {\n  id: integer('id').primaryKey(),  // 'id' is the column name\n  fullName: text('full_name'),\n})\n\nconst sqlite = new Database('sqlite.db');\nconst db = drizzle(sqlite);\n\nconst allUsers = db.select().from(users).all();\n```\n\n----------------------------------------\n\nTITLE: Handling dynamic queries with dynamic mode\nDESCRIPTION: This code snippet illustrates the use of the `.$dynamic()` method in Drizzle ORM to enable dynamic query building. This allows methods like `.where()` to be invoked multiple times on the same query builder instance, which is useful for building queries conditionally. It requires familiarity with Drizzle query builders.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction withPagination<T extends PgSelect>(\n  qb: T,\n  page: number,\n  pageSize: number = 10,\n) {\n  return qb.limit(pageSize).offset(page * pageSize);\n}\n\nconst query = db.select().from(users).where(eq(users.id, 1));\nwithPagination(query, 1); //  Type error - the query builder is not in dynamic mode\n\nconst dynamicQuery = query.$dynamic();\nwithPagination(dynamicQuery, 1); //  OK\n```\n\nLANGUAGE: typescript\nCODE:\n```\nfunction withFriends<T extends PgSelect>(qb: T) {\n  return qb.leftJoin(friends, eq(friends.userId, users.id));\n}\n\nlet query = db.select().from(users).where(eq(users.id, 1)).$dynamic();\nquery = withFriends(query);\n```\n\n----------------------------------------\n\nTITLE: Implementing a MySQL Proxy Driver with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to implement a custom MySQL proxy driver using Drizzle ORM. It involves creating an HTTP driver that communicates with a MySQL database through a remote server. The driver handles queries and migrations by sending requests to the server. It requires `axios`, `drizzle-orm/expressions`, `drizzle-orm/mysql-proxy`, and `drizzle-orm/mysql-proxy/migrator`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Driver\nimport axios from 'axios';\nimport { eq } from 'drizzle-orm/expressions';\nimport { drizzle } from 'drizzle-orm/mysql-proxy';\nimport { migrate } from 'drizzle-orm/mysql-proxy/migrator';\nimport { cities, users } from './schema';\n\nasync function main() {\n  const db = drizzle(async (sql, params, method) => {\n    try {\n      const rows = await axios.post(`${process.env.REMOTE_DRIVER}/query`, {\n        sql,\n        params,\n        method,\n      });\n\n      return { rows: rows.data };\n    } catch (e: any) {\n      console.error('Error from pg proxy server:', e.response.data);\n      return { rows: [] };\n    }\n  });\n\n  await migrate(db, async (queries) => {\n    try {\n      await axios.post(`${process.env.REMOTE_DRIVER}/migrate`, { queries });\n    } catch (e) {\n      console.log(e);\n      throw new Error('Proxy server cannot run migrations');\n    }\n  }, { migrationsFolder: 'drizzle' });\n\n  await db.insert(cities).values({ id: 1, name: 'name' });\n\n  await db.insert(users).values({\n    id: 1,\n    name: 'name',\n    email: 'email',\n    cityId: 1,\n  });\n\n  const usersToCityResponse = await db.select().from(users).leftJoin(\n    cities,\n    eq(users.cityId, cities.id),\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Read Replicas with withReplicas function\nDESCRIPTION: This code demonstrates how to configure read replicas in Drizzle ORM using the `withReplicas` function. It shows how to specify different database connections for read operations and the main instance for write operations. It also shows an example of implementing custom logic for selecting read replicas.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst primaryDb = drizzle(client);\nconst read1 = drizzle(client);\nconst read2 = drizzle(client);\n\nconst db = withReplicas(primaryDb, [read1, read2]);\n\n// read from primary\ndb.$primary.select().from(usersTable);\n\n// read from either read1 connection or read2 connection\ndb.select().from(usersTable)\n\n// use primary database for delete operation\ndb.delete(usersTable).where(eq(usersTable.id, 1))\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = withReplicas(primaryDb, [read1, read2], (replicas) => {\n    const weight = [0.7, 0.3];\n    let cumulativeProbability = 0;\n    const rand = Math.random();\n\n    for (const [i, replica] of replicas.entries()) {\n      cumulativeProbability += weight[i]!;\n      if (rand < cumulativeProbability) return replica;\n    }\n    return replicas[0]!\n});\n```\n\n----------------------------------------\n\nTITLE: Joining Tables with Partial Field Selection in SQLite\nDESCRIPTION: This snippet shows how to select only specific fields from joined tables in Drizzle ORM. It selects `id` and `cityName` from the `cities` table and `userId` from the `users` table.  It performs a left join between `cities` and `users` based on the `cityId` field.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ndb\n  .select({\n    id: cities.id,\n    cityName: cities.name,\n    userId: users.id\n  })\n  .from(cities)\n  .leftJoin(users, eq(users.cityId, cities.id))\n  .all();\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Introspection for MySQL\nDESCRIPTION: This bash command utilizes Drizzle Kit to introspect a MySQL database and generate migration files. It requires specifying the MySQL connection string and the output directory for the migrations.  The command connects to the specified MySQL database and generates schema definitions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndrizzle-kit introspect:mysql --out ./migrations --connectionString mysql://user:password@127.0.0.1:3306/database\n```\n\n----------------------------------------\n\nTITLE: Declaring Indexes, Foreign Keys, and Primary Keys - SQLite\nDESCRIPTION: Shows how to declare indexes, foreign keys (both inline and explicit), and composite primary keys using Drizzle ORM with SQLite. It covers self-referencing foreign keys and indexes with single or multiple columns.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sqliteTable, foreignKey, primaryKey, text, integer, index, uniqueIndex, AnySQLiteColumn } from \"drizzle-orm/sqlite-core\";\n\nexport const countries = sqliteTable('countries', {\n    id: integer('id').primaryKey(),\n    name: text('name'),\n    population: integer('population'),\n    capital: integer('capital').references(() => cities.id, { onUpdate: 'cascade', onDelete: 'cascade' })\n  }, (countries) => ({\n    nameIdx: index('name_idx').on(countries.name), // one column\n    namePopulationIdx: index('name_population_idx').on(countries.name, countries.population), // multiple columns\n    uniqueIdx: uniqueIndex('unique_idx').on(countries.name), // unique index\n  })\n);\n\nexport const cities = sqliteTable('cities', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n  countryId: integer('country_id').references(() => countries.id), // inline foreign key\n  countryName: text('country_id'),\n  sisterCityId: integer('sister_city_id').references((): AnySQLiteColumn => cities.id), // self-referencing foreign key\n}, (cities) => ({\n  // explicit foreign key with 1 column\n  countryFk: foreignKey(() => ({\n    columns: [cities.countryId],\n    foreignColumns: [countries.id],\n  })),\n  // explicit foreign key with multiple columns\n  countryIdNameFk: foreignKey(() => ({\n    columns: [cities.countryId, cities.countryName],\n    foreignColumns: [countries.id, countries.name],\n  })),\n}));\n\nconst pkExample = sqliteTable('pk_example', {\n  id: integer('id'),\n  name: text('name').notNull(),\n  email: text('email').notNull(),\n}, (pkExample) => ({\n  // composite primary key on multiple columns\n  compositePk: primaryKey(pkExample.id, pkExample.name)\n}));\n\n// you can have .where() on indexes\nindex('name_idx').on(table.column).where(sql``)\n```\n\n----------------------------------------\n\nTITLE: Custom pg_vector Function - TypeScript\nDESCRIPTION: This snippet illustrates how to create a custom function for use with the `pg_vector` extension within Drizzle ORM. This example replicates the implementation of an existing function (l2Distance) to show how to create functions with custom operators for specific vector operations. It enables you to extend Drizzle's capabilities with the specific functions offered by the pg_vector extension.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport function l2Distance(\n  column: SQLWrapper | AnyColumn,\n  value: number[] | string[] | TypedQueryBuilder<any> | string,\n): SQL {\n  if (is(value, TypedQueryBuilder<any>) || typeof value === 'string') {\n    return sql`${column} <-> ${value}`;\n  }\n  return sql`${column} <-> ${JSON.stringify(value)}`;\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to TiDB Cloud Serverless with Drizzle ORM\nDESCRIPTION: This snippet demonstrates how to establish a connection to a TiDB Cloud Serverless database using the `@tidbcloud/serverless` driver and integrate it with Drizzle ORM. It initializes a connection to the database using a connection string (represented by `'...'`) and then creates a Drizzle database instance using that connection.  Finally, it shows a basic database query using Drizzle.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.2.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { connect } from '@tidbcloud/serverless';\nimport { drizzle } from 'drizzle-orm/tidb-serverless';\n\nconst client = connect({ url: '...' });\nconst db = drizzle(client);\nawait db.select().from(...);\n```\n\n----------------------------------------\n\nTITLE: Defining Foreign Keys (Now)\nDESCRIPTION: This code shows the new way to define foreign keys in Drizzle ORM. The foreignKey function now takes an object with columns and foreignColumns properties directly. This is the updated and preferred approach.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-mysql/0.15.1.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const usersTable = mysqlTable('userstest', {\n\tid: serial('id').primaryKey(),\n\thomeCity: text('name').notNull(),\n\tcreatedAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),\n}, (users) => ({\n\t// foreignKey has a callback as param\n\tusersCityFK: foreignKey({ columns: [users.homeCity], foreignColumns: [cities.id] }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (Vercel Postgres)\nDESCRIPTION: This TypeScript code demonstrates how to initialize Drizzle with Vercel Postgres. Because Vercel automatically retrieves the `POSTGRES_URL` from the `.env` file, no additional configuration is needed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ndrizzle(\"vercel-postgres\")\n```\n\n----------------------------------------\n\nTITLE: Creating Drizzle ORM Table Schema with Enums - TypeScript\nDESCRIPTION: Defines a Drizzle ORM table schema named `users` using `pgTable`. Includes columns for `id`, `name`, `email`, `role` (using `pgEnum` for a specific set of roles), and `createdAt`. This schema serves as the base for generating ArkType schemas. The `role` field uses an enum, limiting the possible values to 'admin' or 'user'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-arktype/0.1.2.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';\nimport { createInsertSchema, createSelectSchema } from 'drizzle-arktype';\nimport { type } from 'arktype';\n\nconst users = pgTable('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\temail: text('email').notNull(),\n\trole: text('role', { enum: ['admin', 'user'] }).notNull(),\n\tcreatedAt: timestamp('created_at').notNull().defaultNow(),\n});\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (New - URL)\nDESCRIPTION: This TypeScript code showcases the new simplified API for initializing Drizzle.  It takes the client name (e.g., \"node-postgres\") and a connection URL directly.  This initializes the database connection directly.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Finally, one import for all available clients and dialects!\nimport { drizzle } from 'drizzle-orm'\n\n// Choose a client and use a connection URL  nothing else is needed!\nconst db1 = await drizzle(\"node-postgres\", process.env.POSTGRES_URL);\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for WITH DELETE Statement\nDESCRIPTION: This SQL snippet represents the generated SQL for the TypeScript code showing the WITH DELETE statement. It shows the equivalent raw SQL for the Drizzle ORM WITH DELETE example.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.5.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nwith \"average_amount\" as (select avg(\"amount\") as \"value\" from \"orders\") \ndelete from \"orders\" \nwhere \"orders\".\"amount\" > (select * from \"average_amount\") \nreturning \"id\"\n```\n\n----------------------------------------\n\nTITLE: Create Select Schema for Enums and Views - Typescript\nDESCRIPTION: This code snippet demonstrates how to use `createSelectSchema` to create schemas for PostgreSQL enums and views using `drizzle-typebox`. It imports necessary modules from `drizzle-orm`, `drizzle-typebox`, and `@sinclair/typebox/value`. The schema is then used with `Value.Parse` to parse data.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-typebox/0.2.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum } from 'drizzle-orm/pg-core';\nimport { createSelectSchema } from 'drizzle-typebox';\nimport { Value } from '@sinclair/typebox/value';\n\nconst roles = pgEnum('roles', ['admin', 'basic']);\nconst rolesSchema = createSelectSchema(roles);\nconst parsed: 'admin' | 'basic' = Value.Parse(rolesSchema, ...);\n\nconst usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));\nconst usersViewSchema = createSelectSchema(usersView);\nconst parsed: { id: number; name: string; age: number } = Value.Parse(usersViewSchema, ...);\n```\n\n----------------------------------------\n\nTITLE: Defining Table with Drizzle ORM using pgTable in TypeScript\nDESCRIPTION: This code snippet defines a table named `ingredients` using the `pgTable` function from the `drizzle-orm/pg-core` library. The table includes columns such as `id` (UUID, primary key), `name` (text, not null), `description` (text), and `inStock` (boolean, defaults to true). This demonstrates how to define a table schema with Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable } from \"drizzle-orm/pg-core\";\n\nexport const ingredients = pgTable(\"ingredients\", (t) => ({\n  id: t.uuid().defaultRandom().primaryKey(),\n  name: t.text().notNull(),\n  description: t.text(),\n  inStock: t.boolean().default(true),\n}));\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Index Declaration (New API) - TypeScript\nDESCRIPTION: This snippet demonstrates the corrected Drizzle+PostgreSQL indexes API. It showcases two different approaches to defining indexes: using `.on()` with column modifiers and using `.using()` with specific index types and column expressions. This new API offers full support for PostgreSQL indexes.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// First example, with `.on()`\nindex('name')\n  .on(table.column1.asc(), table.column2.nullsFirst(), ...) or .onOnly(table.column1.desc().nullsLast(), table.column2, ...)\n  .concurrently()\n  .where(sql``)\n  .with({ fillfactor: '70' })\n\n// Second Example, with `.using()`\nindex('name')\n  .using('btree', table.column1.asc(), sql`lower(${table.column2})`, table.column1.op('text_ops'))\n  .where(sql``) // sql expression\n  .with({ fillfactor: '70' })\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Generated Columns with tsvector - TypeScript\nDESCRIPTION: Demonstrates defining a generated column of type `tsvector` in PostgreSQL using Drizzle ORM. It shows how to create a custom type for `tsvector` and then define a generated column that automatically updates based on another column's content. It also creates a GIN index on the generated column for efficient searching.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SQL, sql } from \"drizzle-orm\";\nimport { customType, index, integer, pgTable, text } from \"drizzle-orm/pg-core\";\n\nconst tsVector = customType<{ data: string }>({ \n  dataType() {\n    return \"tsvector\";\n  },\n});\n\nexport const test = pgTable(\n  \"test\",\n  {\n    id: integer(\"id\").primaryKey().generatedAlwaysAsIdentity(),\n    content: text(\"content\"),\n    contentSearch: tsVector(\"content_search\", {\n      dimensions: 3,\n    }).generatedAlwaysAs(\n      (): SQL => sql`to_tsvector('english', ${test.content})`\n    ),\n  },\n  (t) => ({\n    idx: index(\"idx_content_search\").using(\"gin\", t.contentSearch),\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Refining Fields in Insert Schema\nDESCRIPTION: Shows how to refine existing fields in the generated insert schema using the second argument of `createInsertSchema`.  The `id` field is refined using the `atLeast(1)` method (assumed to be available on the schema object based on the context) to set a minimum value.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-arktype/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema\nconst insertUserSchema = createInsertSchema(users, {\n\tid: (schema) => schema.atLeast(1),\n\trole: type('string'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Migrations Table (TypeScript)\nDESCRIPTION: This snippet shows how to configure a custom table name for storing migration information using the `migrationsTable` option in the `migrate` function.  It requires the `db` instance and the path to the migrations folder.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.5.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait migrate(db, {\n\tmigrationsFolder: './drizzle',\n\tmigrationsTable: 'my_migrations',\n});\n```\n\n----------------------------------------\n\nTITLE: Selecting from Raw SQL - SQLite\nDESCRIPTION: Demonstrates how to select from raw SQL queries using Drizzle ORM with SQLite, including joins with raw SQL.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ndb.select({ x: sql<number>`x` }).from(sql`generate_series(2, 4) as g(x)`).all();\n\ndb\n  .select({\n    x1: sql<number>`g1.x`,\n    x2: sql<number>`g2.x`\n  })\n  .from(sql`generate_series(2, 4) as g1(x)`)\n  .leftJoin(sql`generate_series(2, 4) as g2(x)`)\n  .all();\n```\n\n----------------------------------------\n\nTITLE: INSERT INTO ... SELECT with SQL template tag - TypeScript\nDESCRIPTION: This snippet uses an SQL template tag to provide a raw SQL query for the `SELECT` part of the `INSERT` statement. This allows for maximum flexibility and control over the SQL generated by Drizzle, selecting the name of users with role 'employee'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.insert(employees).select(\n    sql`select \"users\".\"name\" as \"name\" from \"users\" where \"users\".\"role\" = 'employee'`\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.insert(employees).select(\n    () => sql`select \"users\".\"name\" as \"name\" from \"users\" where \"users\".\"role\" = 'employee'`\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with @libsql/client/node\nDESCRIPTION: This snippet demonstrates initializing Drizzle ORM with the `@libsql/client/node` driver. It imports the drizzle function from `drizzle-orm/libsql/node` and establishes a database connection using environment variables for the URL and authentication token. This module supports :memory:, file, wss, http and turso connection protocols.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.3.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/libsql/node';\n\nconst db = drizzle({ connection: {\n  url: process.env.DATABASE_URL, \n  authToken: process.env.DATABASE_AUTH_TOKEN \n}});\n```\n\n----------------------------------------\n\nTITLE: Updating and Deleting with Limit and Order By\nDESCRIPTION: Illustrates the use of `.limit()` and `.orderBy()` functions in `update` and `delete` statements within Drizzle ORM for SQLite and MySQL. It requires the `usersTable` to be defined and imported and assumes the presence of `eq` and `asc` functions from the Drizzle ORM library.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.update(usersTable).set({ verified: true }).limit(2).orderBy(asc(usersTable.name));\n\nawait db.delete(usersTable).where(eq(usersTable.verified, false)).limit(1).orderBy(asc(usersTable.name));\n```\n\n----------------------------------------\n\nTITLE: Creating a Unique Index with Expression (Typescript)\nDESCRIPTION: This code defines a SQLite table named 'users' with 'id' and 'email' columns. It creates a unique index named 'emailUniqueIndex' on the lowercase version of the 'email' column using a SQL expression. The `sqliteTable` function from Drizzle ORM is used to define the table schema and index.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = sqliteTable(\n  'users',\n  {\n    id: integer('id').primaryKey(),\n    email: text('email').notNull(),\n  },\n  (table) => ({\n    emailUniqueIndex: uniqueIndex('emailUniqueIndex').on(sql`lower(${table.email})`),\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Table with Index & Using USE INDEX in Drizzle ORM\nDESCRIPTION: This code defines a `users` table with an index on the `name` column and uses the `USE INDEX` hint in a select query. The `USE INDEX` hint suggests to the MySQL query optimizer to prioritize the specified index (`usersTableNameIndex`) when processing the query. This can improve performance when the optimizer's default choice is not optimal.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.38.2.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = mysqlTable('users', {\n  id: int('id').primaryKey(),\n  name: varchar('name', { length: 100 }).notNull(),\n}, () => [usersTableNameIndex]);\n\nconst usersTableNameIndex = index('users_name_index').on(users.name);\n\nawait db.select()\n  .from(users, { useIndex: usersTableNameIndex })\n  .where(eq(users.name, 'David'));\n```\n\n----------------------------------------\n\nTITLE: Override Schema Fields - TypeScript\nDESCRIPTION: Shows how to override schema fields when creating insert schemas. In this example, the `role` field is overridden with a `string()` type.  This allows for custom validation or type transformations using valibot's features.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-valibot/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Overriding the fields\nconst insertUserSchema = createInsertSchema(users, {\n\trole: string(),\n});\n```\n\n----------------------------------------\n\nTITLE: UPDATE ... FROM with returning - TypeScript\nDESCRIPTION: This snippet demonstrates the use of the `returning` function with `UPDATE ... FROM` in PostgreSQL to retrieve columns from both the updated `users` table and the joined `cities` table after the update operation. This allows fetching updated values and related data in a single query.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst updatedUsers = await db\n  .update(users)\n  .set({ cityId: cities.id })\n  .from(cities)\n  .returning({ id: users.id, cityName: cities.name });\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with node-postgres (deprecated API)\nDESCRIPTION: Shows the deprecated (but still supported until V1) API for initializing a Drizzle database instance using a pg Pool client. Also shows the new version that uses the `client` option. It helps understand the transition and potential degradation of autocomplete performance due to type collisions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { Pool } from \"pg\";\n\nconst client = new Pool({ connectionString: process.env.DATABASE_URL });\nconst db = drizzle(client); // deprecated but available\n\n// new version\nconst db = drizzle({\n  client: client,\n});\n```\n\n----------------------------------------\n\nTITLE: Seeding with Version 2 after Interval Change - Typescript\nDESCRIPTION: This code snippet seeds the database schema.  It is suggested to use this method with version '2', after upgrading.  No specific dependencies are required beyond the Drizzle ORM seeding functionality.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema);\n// or explicit\nawait seed(db, schema, { version: '2' });\n```\n\n----------------------------------------\n\nTITLE: INSERT INTO ... SELECT with Query Builder instance - TypeScript\nDESCRIPTION: This snippet shows how to use an existing instance of `QueryBuilder` within an `INSERT INTO ... SELECT` statement. This approach allows for more complex query construction where the query builder is used elsewhere in the application. The query selects names from users table where the role is 'employee'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst qb = new QueryBuilder();\nawait db.insert(employees).select(\n    qb.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))\n);\n```\n\n----------------------------------------\n\nTITLE: INSERT INTO ... SELECT with Query Builder - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use a query builder within an `INSERT INTO ... SELECT` statement in Drizzle ORM to insert data into the `employees` table by selecting data from the `users` table.  It filters users with the role 'employee'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst insertedEmployees = await db\n  .insert(employees)\n  .select(\n    db.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))\n  )\n  .returning({\n    id: employees.id,\n    name: employees.name\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating a View with Raw SQL in SQLite\nDESCRIPTION: This code snippet demonstrates how to create a view using raw SQL within Drizzle ORM. It uses the `sql` template literal to define the view's query.  The schema of the view must also be defined.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst newYorkers = sqliteView('new_yorkers', {\n  id: integer('id').primaryKey(),\n  name: text('name').notNull(),\n  cityId: integer('city_id').notNull(),\n}).as(sql`select * from ${users} where ${eq(users.cityId, 1)}`);\n```\n\n----------------------------------------\n\nTITLE: Drizzle Config After Turso Dialect Introduction\nDESCRIPTION: This code block shows the updated `drizzle.config` file, specifying the \"turso\" dialect for Turso databases.  This change separates Turso migration strategies from SQLite. This configuration uses turso dialect and needs url to connect to DB, schema to define DB and output directory.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"turso\",\n  schema: \"./schema.ts\",\n  out: \"./drizzle\",\n  dbCredentials: {\n    url: \"database.db\",\n  },\n  breakpoints: true,\n  verbose: true,\n  strict: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Querying with HAVING, WHERE, groupBy and orderBy in Drizzle ORM (TS)\nDESCRIPTION: This code snippet demonstrates how to use the `HAVING` clause, along with `where()`, `groupBy()` and `orderBy()` with field referencing in Drizzle ORM. It selects fields, joins tables, filters results based on conditions in `WHERE` and `HAVING` clauses, groups data, and orders the result set. The snippet uses table definitions `citiesTable` and `users2Table` and SQL functions like `upper()` and `count()`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.1.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait db\n  .select({\n    id: citiesTable.id,\n    name: sql<string>`upper(${citiesTable.name})`.as('upper_name'),\n    usersCount: sql<number>`count(${users2Table.id})::int`.as('users_count'),\n  })\n  .from(citiesTable)\n  .leftJoin(users2Table, eq(users2Table.cityId, citiesTable.id))\n  .where(({ name }) => sql`length(${name}) >= 3`)\n  .groupBy(citiesTable.id)\n  .having(({ usersCount }) => sql`${usersCount} > 0`)\n  .orderBy(({ name }) => name);\n```\n\n----------------------------------------\n\nTITLE: Drizzle ORM Join with Explicit Column Selection\nDESCRIPTION: This code snippet demonstrates how to perform a left join using Drizzle ORM's `select`, `from`, and `leftJoin` methods. It explicitly selects columns from both the `cities` and `users` tables and aliases them. The `eq` function is used to define the join condition, ensuring type safety. The result type will have nullable fields for columns from the joined table (`users`).\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst rows = await db\n  .select({\n      cityId: cities.id,\n      cityName: cities.name,\n      userId: users.id,\n      firstName: users.firstName,\n      lastName: users.lastName,\n    })\n  .from(cities)\n  .leftJoin(users, eq(users.cityId, cities.id));\n```\n\n----------------------------------------\n\nTITLE: INSERT INTO ... SELECT with Callback - TypeScript\nDESCRIPTION: This snippet showcases how to use a callback function to define the `SELECT` query within the `INSERT` statement. The callback provides either the db instance or a query builder instance, allowing for a dynamic query construction based on the current context, which selects the name from users.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.insert(employees).select(\n    () => db.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.insert(employees).select(\n    (qb) => qb.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Default Column Values with .$defaultFn() - TypeScript\nDESCRIPTION: This snippet demonstrates how to use the .$defaultFn() method in Drizzle ORM to define a default value for a column using a custom function, in this case using the `createId()` function from the `@paralleldrive/cuid2` package.  This allows for runtime-generated defaults when inserting new rows. The specified function will only be executed at runtime, not during schema definition by `drizzle-kit`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { varchar, mysqlTable } from \"drizzle-orm/mysql-core\";\nimport { createId } from '@paralleldrive/cuid2';\n\nconst table = mysqlTable('table', {\n\tid: varchar('id', { length: 128 }).$defaultFn(() => createId()),\n});\n```\n\n----------------------------------------\n\nTITLE: Drizzle ORM Join with Partial Field Selection\nDESCRIPTION: This code snippet shows how to select all fields from one table (`cities`) and specific fields from another table (`users`). It uses the table name as a shorthand to select all fields from that table.  In this case, it selects all fields from `cities` and only the `firstName` field from `users`. The result type reflects this partial selection.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n.select({\n  cities, // shorthand for \"cities: cities\", the key can be anything\n  user: {\n    firstName: users.firstName,\n  },\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  cities: {\n    id: number;\n    name: string;\n  };\n  user: {\n    firstName: string;\n  } | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations with Drizzle and Postgres.js\nDESCRIPTION: Configures and executes database migrations using Drizzle ORM and Postgres.js.  It requires setting `max: 1` in the postgres.js connection options. It creates a separate connection for migrations, initializes Drizzle with it, and runs the migrations from a specified folder.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/postgres-js/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport postgres from 'postgres';\nimport { migrate } from 'drizzle-orm/postgres-js/migrator';\n\nconst migrationsClient = postgres(connectionString, {\n  max: 1,\n});\nconst db = drizzle(migrationsClient);\nawait migrate(db, { migrationsFolder: '...' });\n```\n\n----------------------------------------\n\nTITLE: Using WITH Clause with DELETE in Drizzle ORM (TypeScript)\nDESCRIPTION: This snippet demonstrates using the WITH clause with a DELETE statement in Drizzle ORM. It defines a common table expression (CTE) named 'average_amount' to calculate the average order amount, then uses this CTE in a DELETE statement to remove orders where the amount exceeds the average.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.5.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst averageAmount = db.$with('average_amount').as(\n\tdb.select({ value: sql`avg(${orders.amount})`.as('value') }).from(orders),\n);\nconst result = await db\n\t.with(averageAmount)\n\t.delete(orders)\n\t.where(gt(orders.amount, sql`(select * from ${averageAmount})`))\n\t.returning({\n\t\tid: orders.id,\n\t});\n```\n\n----------------------------------------\n\nTITLE: Generated SQL migration from Drizzle Kit\nDESCRIPTION: Shows the SQL migration generated by Drizzle Kit based on the schema. It creates tables 'auth_otp' and 'users' if they don't exist, defines columns with their respective data types and constraints (primary key, foreign key), and creates an index on the 'users' table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-kit/README.md#_snippet_1\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE IF NOT EXISTS auth_otp (\n \"id\" SERIAL PRIMARY KEY,\n \"phone\" character varying(256),\n \"user_id\" INT\n);\n\nCREATE TABLE IF NOT EXISTS users (\n \"id\" SERIAL PRIMARY KEY,\n \"full_name\" character varying(256)\n);\n\nDO $$ BEGIN\n ALTER TABLE auth_otp ADD CONSTRAINT auth_otp_user_id_fkey FOREIGN KEY (\"user_id\") REFERENCES users(id);\nEXCEPTION\n WHEN duplicate_object THEN null;\nEND $$;\n\nCREATE INDEX IF NOT EXISTS users_full_name_index ON users (full_name);\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Push Config (TypeScript)\nDESCRIPTION: This code snippet shows an example of a Drizzle Kit configuration file in TypeScript for using the `drizzle-kit push:mysql` feature. It specifies the schema file and the database connection string, allowing Drizzle Kit to directly push schema changes to the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Config } from \"src\";\n\nexport default {\n  schema: \"./schema.ts\",\n  connectionString: process.env.DB_URL,\n} satisfies Config;\n```\n\n----------------------------------------\n\nTITLE: Defining Table with Index & Using FORCE INDEX in Drizzle ORM\nDESCRIPTION: This code defines a `users` table with an index on the `name` column and uses the `FORCE INDEX` hint in a select query.  The `FORCE INDEX` hint forces the MySQL query optimizer to use the specified index (`usersTableNameIndex`) for the query. If the specified index cannot be used, MySQL will not fall back to other indexes and might resort to a full table scan.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.38.2.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = mysqlTable('users', {\n  id: int('id').primaryKey(),\n  name: varchar('name', { length: 100 }).notNull(),\n}, () => [usersTableNameIndex]);\n\nconst usersTableNameIndex = index('users_name_index').on(users.name);\n\nawait db.select()\n  .from(users, { forceIndex: usersTableNameIndex })\n  .where(eq(users.name, 'David'));\n```\n\n----------------------------------------\n\nTITLE: Selecting first users with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to select the first user from a database using Drizzle ORM. It showcases usage of the `findFirst` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst user = await db.query.users.findFirst();\n```\n\n----------------------------------------\n\nTITLE: Using WITH clause with INSERT statement in Drizzle ORM\nDESCRIPTION: This code demonstrates using the `WITH` clause with an `INSERT` statement in Drizzle ORM.  It defines a `users` table, creates a common table expression (CTE) named `sq` that inserts a new user, and then selects from the CTE. The result of the insertion is returned.  The `pgTable`, `serial`, `text`, `insert`, `values`, and `returning` functions are used from Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\nconst sq = db.$with('sq').as(\n    db.insert(users).values({ name: 'John' }).returning(),\n);\n\nconst result = await db.with(sq).select().from(sq);\n```\n\n----------------------------------------\n\nTITLE: Initializing Vercel Postgres with Drizzle ORM (TypeScript)\nDESCRIPTION: This snippet demonstrates how to initialize a connection to a Vercel Postgres database using Drizzle ORM. It imports the `drizzle` function from `drizzle-orm/vercel-postgres` and the `sql` object from `@vercel/postgres`. The `drizzle(sql)` call creates a database instance connected to the Vercel Postgres database. You can then use `db.select(...)` to perform queries.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.25.4.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/vercel-postgres';\nimport { sql } from \"@vercel/postgres\";\n\nconst db = drizzle(sql);\n\ndb.select(...)\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: Max Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `max` aggregate function in Drizzle ORM. It showcases both the direct usage of the `max()` helper and its equivalent using the `sql` template literal, highlighting the `.mapWith` call to match the type of users.id.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: max(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`max(${expression})`.mapWith(users.id) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: Using SQLite Durable Objects driver with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to use the SQLite Durable Objects driver with Drizzle ORM in a Cloudflare Worker. It shows how to define a Durable Object, interact with the database using Drizzle, and handle requests. The example includes database migration, inserting data, and selecting data.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.37.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/// <reference types=\"@cloudflare/workers-types\" />\nimport { drizzle, DrizzleSqliteDODatabase } from 'drizzle-orm/durable-sqlite';\nimport { DurableObject } from 'cloudflare:workers'\nimport { migrate } from 'drizzle-orm/durable-sqlite/migrator';\nimport migrations from '../drizzle/migrations';\nimport { usersTable } from './db/schema';\n\nexport class MyDurableObject1 extends DurableObject {\n  storage: DurableObjectStorage;\n  db: DrizzleSqliteDODatabase<any>;\n\n  constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n    this.storage = ctx.storage;\n    this.db = drizzle(this.storage, { logger: false });\n  }\n\n    async migrate() {\n        migrate(this.db, migrations);\n    }\n\n  async insert(user: typeof usersTable.$inferInsert) {\n        await this.db.insert(usersTable).values(user);\n    }\n\n  async select() {\n        return this.db.select().from(usersTable);\n    }\n}\n\nexport default {\n  /**\n   * This is the standard fetch handler for a Cloudflare Worker\n   *\n   * @param request - The request submitted to the Worker from the client\n   * @param env - The interface to reference bindings declared in wrangler.toml\n   * @param ctx - The execution context of the Worker\n   * @returns The response to be sent back to the client\n   */\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const id: DurableObjectId = env.MY_DURABLE_OBJECT1.idFromName('durable-object');\n    const stub = env.MY_DURABLE_OBJECT1.get(id);\n    await stub.migrate();\n\n    await stub.insert({\n      name: 'John',\n      age: 30,\n      email: 'john@example.com',\n      })\n    console.log('New user created!')\n  \n    const users = await stub.select();\n    console.log('Getting all users from the database: ', users)\n\n        return new Response();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Point Type Definition - TypeScript\nDESCRIPTION: This snippet defines a PostgreSQL table with a `point` column using the Drizzle ORM. It demonstrates the two supported modes for mapping the `point` type: `tuple` (default) and `xy`. The `xy` mode maps the database Point(1,2) to an object `{ x: 1, y: 2 }`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst items = pgTable('items', {\n point: point('point'),\n pointObj: point('point_xy', { mode: 'xy' }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Identity Columns\nDESCRIPTION: This code snippet demonstrates how to define an identity column in a PostgreSQL table using `generatedAlwaysAsIdentity`.  It specifies that the `id` column is generated as an identity with a starting value of 1000.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, integer, text } from 'drizzle-orm/pg-core' \n\nexport const ingredients = pgTable(\"ingredients\", {\n  id: integer(\"id\").primaryKey().generatedAlwaysAsIdentity({ startWith: 1000 }),\n  name: text(\"name\").notNull(),\n  description: text(\"description\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Text-Based Enum Columns in Drizzle ORM (TypeScript)\nDESCRIPTION: Shows the updated syntax for defining text-based enum columns in Drizzle ORM.  The enum values are now defined within an `enum` property in the column definition. Requires Drizzle ORM setup with a MySQL table defined.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.23.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Before\nconst test = mysqlTable('test', {\n  role: text<'admin' | 'user'>('role'),\n});\n\n// After\nconst test = mysqlTable('test', {\n  role: text('role', { enum: ['admin', 'user'] }),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing PlanetScale Client - TypeScript\nDESCRIPTION: This TypeScript code shows how to initialize a PlanetScale client using the Client class from the @planetscale/database package. It creates a database connection instance using environment variables for host, username, and password, and then passes the client to the drizzle function.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.4.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from '@planetscale/database';\nimport { drizzle } from 'drizzle-orm/planetscale-serverless';\n\n// create the connection\nconst client = new Client({\n\thost: process.env['DATABASE_HOST'],\n\tusername: process.env['DATABASE_USERNAME'],\n\tpassword: process.env['DATABASE_PASSWORD'],\n});\n\nconst db = drizzle(client);\n```\n\n----------------------------------------\n\nTITLE: Overriding Postgres.js Date Parsers in Drizzle\nDESCRIPTION: This code snippet overrides the default date parsers in the postgres.js driver to ensure that dates are returned as strings. This is done by setting the parsers and serializers for specific PostgreSQL data types to a transparent parser function that simply returns the original value. The purpose is to align the behavior of the postgres.js driver with other Drizzle ORM drivers and address inconsistencies in timestamp handling.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst transparentParser = (val: any) => val;\n\n// Override postgres.js default date parsers: https://github.com/porsager/postgres/discussions/761\nfor (const type of ['1184', '1082', '1083', '1114']) {\n\tclient.options.parsers[type as any] = transparentParser;\n\tclient.options.serializers[type as any] = transparentParser;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing MySQL Enums (Now)\nDESCRIPTION: This code demonstrates the correct way to initialize MySQL enums in Drizzle. It showcases the `mysqlEnum` function, specifying the enum name and possible values. The `.notNull()` and `.default()` methods can be chained to configure the column.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-mysql/0.15.1.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nmysqlEnum('popularity', ['unknown', 'known', 'popular']).notNull().default('known')\n```\n\n----------------------------------------\n\nTITLE: Overriding Fields in Insert Schema - TypeScript\nDESCRIPTION: This example demonstrates how to override fields within the generated insert schema using the `createInsertSchema` function. It overrides the `role` field to be a `z.string()` type. The original table schema is used as the base, and the overridden fields are defined within the second argument of `createInsertSchema`. Dependencies include `drizzle-orm/pg-core`, `drizzle-zod`, and `zod`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-zod/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Overriding the fields\nconst insertUserSchema = createInsertSchema(users, {\n  role: z.string(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Many-to-Many Relationships in SQLite\nDESCRIPTION: This snippet demonstrates how to define a many-to-many relationship using Drizzle ORM's `sqliteTable` function.  It defines three tables: `users`, `chatGroups`, and `usersToChatGroups`, with the latter acting as a junction table. It also shows how to query related data using `leftJoin` and `eq`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = sqliteTable('users', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n});\n\nconst chatGroups = sqliteTable('chat_groups', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n});\n\nconst usersToChatGroups = sqliteTable('usersToChatGroups', {\n  userId: integer('user_id').notNull().references(() => users.id),\n  groupId: integer('group_id').notNull().references(() => chatGroups.id),\n});\n\n...\nconst db = drizzle(...);\n\n// querying user group with id 1 and all the participants(users)\ndb\n  .select()\n  .from(usersToChatGroups)\n  .leftJoin(users, eq(usersToChatGroups.userId, users.id))\n  .leftJoin(chatGroups, eq(usersToChatGroups.groupId, chatGroups.id))\n  .where(eq(chatGroups.id, 1))\n  .all();\n```\n\n----------------------------------------\n\nTITLE: Implementing Live Queries with useLiveQuery in React\nDESCRIPTION: This code snippet demonstrates how to use the `useLiveQuery` React Hook provided by Drizzle ORM to create live queries in an Expo SQLite environment. It initializes the database connection, defines a query using Drizzle ORM, and then uses `useLiveQuery` to automatically re-run the query whenever relevant data changes. The results are then displayed in a React Native Text component. The `openDatabaseSync` function from `expo-sqlite/next` is used to open the SQLite database synchronously. The `drizzle` function from `drizzle-orm/expo-sqlite` is used to create a Drizzle database instance. The `users` table is imported from a schema file. Dependencies: `drizzle-orm/expo-sqlite`, `expo-sqlite/next`, `react-native`\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.1.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useLiveQuery, drizzle } from 'drizzle-orm/expo-sqlite';\nimport { openDatabaseSync } from 'expo-sqlite/next';\nimport { users } from './schema';\nimport { Text } from 'react-native';\n\nconst expo = openDatabaseSync('db.db');\nconst db = drizzle(expo);\n\nconst App = () => {\n  // Re-renders automatically when data changes\n  const { data } = useLiveQuery(db.select().from(users));\n\n  // const { data, error, updatedAt } = useLiveQuery(db.query.users.findFirst());\n  // const { data, error, updatedAt } = useLiveQuery(db.query.users.findMany());\n\n\n  return <Text>{JSON.stringify(data)}</Text>;\n};\n\nexport default App;\n```\n\n----------------------------------------\n\nTITLE: Using drizzle.mock() for testing\nDESCRIPTION: Demonstrates the usage of `drizzle.mock()` for creating a mock Drizzle database instance, primarily for testing or type-checking purposes without requiring a real database connection or driver. It should replace previous workarounds that used type assertions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = drizzle.mock()\n```\n\n----------------------------------------\n\nTITLE: Updating JSONB column, handling primitives\nDESCRIPTION: This SQL query updates a JSONB column in a PostgreSQL table. It uses a CASE statement to conditionally convert the column's value to JSONB only if the value is a JSON object or array (determined by checking if the string representation starts with '{' or '['). Otherwise, it leaves the original value unchanged. This avoids errors when the column contains primitive stringified values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.33.0.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE table_name\nSET jsonb_column = CASE\n    -- Convert to JSONB if it is a valid JSON object or array\n    WHEN jsonb_column #>> '{}' LIKE '{%' OR jsonb_column #>> '{}' LIKE '[%' THEN\n        (jsonb_column #>> '{}')::jsonb\n    ELSE\n        jsonb_column\nEND\nWHERE\n    jsonb_column IS NOT NULL;\n```\n\n----------------------------------------\n\nTITLE: Defining schema and querying using Knex.js with Drizzle ORM (TypeScript)\nDESCRIPTION: This snippet defines a PostgreSQL table 'test' using Drizzle ORM and then queries it using Knex.js. It imports necessary modules from 'knex' and 'drizzle-orm'. The 'Knexify' type is used to integrate Drizzle schema types with Knex.  A type augmentation is required to make Knex aware of the drizzle schema. It demonstrates how to leverage Drizzle for schema definition and Knex for query building.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/knex/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport Knex from 'knex';\nimport { pgTable, serial, text } from 'drizzle-orm/pg-core';\n// This line is important - it allows you to use the Knexify type\nimport 'drizzle-orm/knex';\n\nconst test = pgTable('test', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\ndeclare module 'knex/types/tables' {\n  interface Tables {\n    test: Knexify<typeof test>;\n  }\n}\n\nconst db = Knex({});\n\nconst result/*: { id: number, name: string }[] */ = db('test').select();\n```\n\n----------------------------------------\n\nTITLE: Running Migrations Programmatically in SQLite\nDESCRIPTION: This snippet demonstrates how to run migrations programmatically using Drizzle ORM's `migrate` function. It initializes a Drizzle ORM database instance and then calls the `migrate` function to apply any pending migrations from a specified folder.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport { migrate } from 'drizzle-orm/better-sqlite3/migrator';\nimport Database from 'better-sqlite3';\n\nconst sqlite = new Database('sqlite.db');\nconst db = drizzle(sqlite);\n\n// this will automatically run needed migrations on the database\nmigrate(db, { migrationsFolder: './drizzle' });\n```\n\n----------------------------------------\n\nTITLE: Integrating Drizzle ORM with Prisma\nDESCRIPTION: This code snippet demonstrates how to integrate Drizzle ORM with Prisma using the new Prisma extension. It initializes a Prisma client with the Drizzle extension, allowing you to use Drizzle models and query them within Prisma.  It depends on `@prisma/client` and `drizzle-orm/prisma/pg`. The `User` import represents a Drizzle schema definition.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.3.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { PrismaClient } from '@prisma/client';\nimport { drizzle } from 'drizzle-orm/prisma/pg';\nimport { User } from './drizzle';\n\nconst prisma = new PrismaClient().$extends(drizzle());\nconst users = await prisma.$drizzle.select().from(User);\n```\n\n----------------------------------------\n\nTITLE: Refine Schema Fields - TypeScript\nDESCRIPTION: Demonstrates refining schema fields, allowing modifications before they become nullable/optional. The `id` field is refined using `pipe` and `minValue` from 'valibot'. This is useful for adding custom validation logic to individual fields.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-valibot/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema\nconst insertUserSchema = createInsertSchema(users, {\n\tid: (schema) => pipe([schema, minValue(0)]),\n\trole: string(),\n});\n```\n\n----------------------------------------\n\nTITLE: Counting Entities with $count API in Drizzle ORM in TypeScript\nDESCRIPTION: This snippet showcases the new `$count` API in Drizzle ORM for counting entities.  It demonstrates counting all users in the database and counting users with a specific name by providing an additional `eq` condition. Requires the `eq` operator, and the `users` table definition to be available.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n// how many users are in the database\nconst count: number = await db.$count(users);\n\n// how many users with the name \"Dan\" are in the database\nconst count: number = await db.$count(users, eq(name, \"Dan\"));\n```\n\n----------------------------------------\n\nTITLE: Defining pg_vector Indexes with HNSW\nDESCRIPTION: This snippet showcases how to define indexes for the `pg_vector` extension in Drizzle ORM using the HNSW index.  It defines a table with a vector column and then creates three indexes using different vector operations (L2 distance, inner product, cosine distance).  It assumes the `pg_vector` extension is already installed in the PostgreSQL database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0-beta.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// CREATE INDEX ON items USING hnsw (embedding vector_l2_ops);\n// CREATE INDEX ON items USING hnsw (embedding vector_ip_ops);\n// CREATE INDEX ON items USING hnsw (embedding vector_cosine_ops);\n\nconst table = pgTable('items', {\n    embedding: vector('embedding', { dimensions: 3 })\n}, (table) => ({\n    l2: index('l2_index').using('hnsw', table.embedding.op('vector_l2_ops'))\n    ip: index('ip_index').using('hnsw', table.embedding.op('vector_ip_ops'))\n    cosine: index('cosine_index').using('hnsw', table.embedding.op('vector_cosine_ops'))\n}))\n```\n\n----------------------------------------\n\nTITLE: Using the 'count' option in drizzle-seed\nDESCRIPTION: This code demonstrates how to use the `count` option in the `seed` function to create a specific number of entities (in this case, 1000). It requires the `db` (database connection) and `schema` to be defined elsewhere. The `count` option allows users to generate more data for testing purposes.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.4.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { count: 1000 });\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Tables with Array Types using Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define PostgreSQL tables with array types using Drizzle ORM. It showcases the use of the `.array()` method to define array columns with specific dimensions for both integer and text data types. This allows mapping of PostgreSQL array columns to Drizzle ORM schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nexport const salEmp = pgTable('sal_emp', {\n  name: text('name').notNull(),\n  payByQuarter: integer('pay_by_quarter').array(),\n  schedule: text('schedule').array().array(),\n});\n\nexport const tictactoe = pgTable('tictactoe', {\n  squares: integer('squares').array(3).array(3),\n});\n```\n\n----------------------------------------\n\nTITLE: Using WITH clause with DELETE statement in Drizzle ORM\nDESCRIPTION: This code demonstrates using the `WITH` clause with a `DELETE` statement in Drizzle ORM. It defines a `users` table, creates a CTE named `sq` that deletes a user named 'John', and then selects from the CTE.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\nconst sq = db.$with('sq').as(\n  db.delete(users).where(eq(users.name, 'John')).returning(),\n);\n\nconst result = await db.with(sq).select().from(sq);\n```\n\n----------------------------------------\n\nTITLE: Generating Drizzle migration files\nDESCRIPTION: These commands install Drizzle Kit and configure npm scripts for generating and applying migrations.  The `generate` script creates migration SQL files based on changes to the schema, and the `up` script applies those migrations to the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/cloudflare-d1/README.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install drizzle-kit\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL SELECT Locking Clauses with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to use locking clauses like 'FOR UPDATE', 'FOR NO KEY UPDATE', and 'FOR SHARE' in Drizzle ORM with PostgreSQL. It includes options for specifying the table ('of') and handling locked rows ('skipLocked', 'noWait'). Requires the 'users' table defined elsewhere in the Drizzle ORM schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.20.3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait db\n  .select()\n  .from(users)\n  .for('update')\n  .for('no key update', { of: users })\n  .for('no key update', { of: users, skipLocked: true })\n  .for('share', { of: users, noWait: true });\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Sequences - TypeScript\nDESCRIPTION: Demonstrates defining sequences in PostgreSQL using Drizzle ORM. The code shows examples of creating sequences with and without parameters like `startWith`, `maxValue`, `minValue`, `cycle`, `cache`, and `increment`. It also illustrates defining a sequence within a custom schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgSchema, pgSequence } from \"drizzle-orm/pg-core\";\n\n// No params specified\nexport const customSequence = pgSequence(\"name\");\n\n// Sequence with params\nexport const customSequence = pgSequence(\"name\", {\n      startWith: 100,\n      maxValue: 10000,\n      minValue: 100,\n      cycle: true,\n      cache: 10,\n      increment: 2\n});\n\n// Sequence in custom schema\nexport const customSchema = pgSchema('custom_schema');\n\nexport const customSequence = customSchema.sequence(\"name\");\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Generated Columns with SQL template - TypeScript\nDESCRIPTION: Illustrates defining a generated column in PostgreSQL using Drizzle ORM with a simple SQL template or string.  The example shows how to define generated columns using `sql` templates or plain strings to create generated values.  These columns are automatically updated when related columns change.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = pgTable(\"users\", {\n  id: integer(\"id\"),\n  name: text(\"name\"),\n  generatedName: text(\"gen_name\").generatedAlwaysAs(sql`hello world!`),\n  generatedName1: text(\"gen_name1\").generatedAlwaysAs(\"hello world!\"),\n}),\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with Neon HTTP Driver (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to initialize Drizzle ORM with the Neon HTTP driver. It imports necessary modules from `@neondatabase/serverless` and `drizzle-orm/neon-http`, configures connection caching, establishes a connection to the Neon database using the environment variable `DRIZZLE_DATABASE_URL`, and creates a Drizzle database instance.  It uses `neonConfig.fetchConnectionCache = true;` to enable connection caching for improved performance.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { neon, neonConfig } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-http';\n\nneonConfig.fetchConnectionCache = true;\n\nconst sql = neon(process.env.DRIZZLE_DATABASE_URL!);\nconst db = drizzle(sql);\n\ndb.select(...)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Serial Type for MySQL\nDESCRIPTION: This snippet defines a custom Serial data type for MySQL using the `customType` function from Drizzle ORM. It specifies the data type as 'serial' and configures the type to be non-nullable and have a default value.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst customSerial = customType<{ data: number; notNull: true; default: true }>(  {\n    dataType() {\n      return 'serial';\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using Raw SQL Queries in SQLite\nDESCRIPTION: This snippet shows how to execute raw SQL queries using Drizzle ORM's `db.run` method. It's important to use template literals and parameterized queries to prevent SQL injection vulnerabilities.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\n// it will automatically run a parametrized query!\nconst res: QueryResult<any> = db.run(sql`SELECT * FROM users WHERE user.id = ${userId}`);\n```\n\n----------------------------------------\n\nTITLE: Custom pg_vector Function Implementation\nDESCRIPTION: This snippet demonstrates how to create a custom function for `pg_vector` using the SQL template operator. It provides an example implementation of the `l2Distance` function, showcasing how to handle different input types (number arrays, string arrays, strings, or even select queries). This enables users to extend the functionality with custom operators as needed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0-beta.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport function l2Distance(\n  column: SQLWrapper | AnyColumn,\n  value: number[] | string[] | TypedQueryBuilder<any> | string,\n): SQL {\n  if (is(value, TypedQueryBuilder<any>) || typeof value === 'string') {\n    return sql`${column} <-> ${value}`;\n  }\n  return sql`${column} <-> ${JSON.stringify(value)}`;\n}\n```\n\n----------------------------------------\n\nTITLE: Using PG Arrays with Schemas - Typescript\nDESCRIPTION: Shows how to define and use PostgreSQL arrays within Drizzle ORM schemas. It outlines the syntax for defining an array column and provides the corresponding Valibot schema representation with z.array and optional length validation. It showcases the basic structure for defining arrays and their types in a Drizzle-Valibot setup.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-valibot/0.3.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\npg.dataType().array(...);\n\n// Schema\nz.array(baseDataTypeSchema).length(size);\n```\n\n----------------------------------------\n\nTITLE: Defining Tables in Default and Custom MySQL Schemas\nDESCRIPTION: This code demonstrates how to define tables within the default MySQL schema and a custom schema using Drizzle ORM. It showcases the use of `mysqlTable` and `mysqlSchema` to create table definitions with various column types, including serial, text, boolean, JSON, and timestamp.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-mysql/0.15.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Table in default schema\nconst publicUsersTable = mysqlTable('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\tverified: boolean('verified').notNull().default(false),\n\tjsonb: json<string[]>('jsonb'),\n\tcreatedAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),\n});\n\n\n// Table in custom schema\nconst mySchema = mysqlSchema('mySchema');\n\nconst mySchemaUsersTable = mySchema('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\tverified: boolean('verified').notNull().default(false),\n\tjsonb: json<string[]>('jsonb'),\n\tcreatedAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle Kit in package.json\nDESCRIPTION: Configures Drizzle Kit as an npm script to generate migrations.  It specifies the output directory for migrations and the path to the schema file.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-kit/README.md#_snippet_3\n\nLANGUAGE: jsonc\nCODE:\n```\n// package.json\n{\n \"scripts\": {\n  \"generate\": \"drizzle-kit generate --out migrations-folder --schema src/db/schema.ts\"\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with @libsql/client/http\nDESCRIPTION: This snippet demonstrates initializing Drizzle ORM with the `@libsql/client/http` driver. It imports the drizzle function from `drizzle-orm/libsql/http` and establishes a database connection using environment variables for the URL and authentication token. This module supports http and https connection protocols.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.3.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/libsql/http';\n\nconst db = drizzle({ connection: {\n  url: process.env.DATABASE_URL, \n  authToken: process.env.DATABASE_AUTH_TOKEN \n}});\n```\n\n----------------------------------------\n\nTITLE: PostGIS Geometry Type Definition - TypeScript\nDESCRIPTION: This snippet demonstrates how to define a PostgreSQL table with a `geometry` column using the PostGIS extension in Drizzle ORM. It shows how to specify the geometry type, mode (tuple or xy), and SRID (Spatial Reference Identifier). Requires the `postgis` extension to be installed in the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst items = pgTable('items', {\n  geo: geometry('geo', { type: 'point' }),\n  geoObj: geometry('geo_obj', { type: 'point', mode: 'xy' }),\n  geoSrid: geometry('geo_options', { type: 'point', mode: 'xy', srid: 4000 }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining custom names for primary and foreign keys\nDESCRIPTION: This snippet shows how to define custom names for primary key and foreign key constraints in Drizzle ORM. This is useful for avoiding constraint name truncation issues in databases with character limits. It depends on the `pgTable` function and column types from `drizzle-orm/pg-core`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = pgTable('table', {\n  id: integer('id'),\n  name: text('name'),\n}, (table) => ({\n  cpk: primaryKey({ name: 'composite_key', columns: [table.id, table.name] }),\n  cfk: foreignKey({\n    name: 'fkName',\n    columns: [table.id],\n    foreignColumns: [table.name],\n  }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Defining Neon Identity Table Schema in Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define the schema for the `users_sync` table from the `neon_identity` schema using Drizzle ORM. It imports the `pgSchema`, `jsonb`, `text`, and `timestamp` functions from the `/neon` import of Drizzle ORM. It then defines the `usersSync` table schema with columns like `rawJson`, `id`, `name`, `email`, `createdAt`, and `deletedAt`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// \"drizzle-orm/neon\"\nconst neonIdentitySchema = pgSchema('neon_identity');\n\n/**\n * Table schema of the `users_sync` table used by Neon Identity.\n * This table automatically synchronizes and stores user data from external authentication providers.\n *\n * @schema neon_identity\n * @table users_sync\n */\nexport const usersSync = neonIdentitySchema.table('users_sync', {\n  rawJson: jsonb('raw_json').notNull(),\n  id: text().primaryKey().notNull(),\n  name: text(),\n  email: text(),\n  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }),\n  deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting the Entity Count in Drizzle Seed with TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `count` option within `drizzle-seed` to control the number of entities created.  By default, `seed` creates 10 entities, but this can be overridden by specifying the `count` option in the seed options object. Requires `drizzle-orm` and `drizzle-seed` to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-seed/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait seed(db, schema, { count: 1000 });\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL Queries in drizzle-orm-sqlite\nDESCRIPTION: Introduces the `.exec()` method for session, allowing execution of raw SQL queries without prepared statements. This provides a way to execute SQL statements directly.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-sqlite/0.14.3.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Creating select schema for enums and views with Drizzle and Zod\nDESCRIPTION: This code snippet demonstrates how to use `createSelectSchema` to generate Zod schemas for Postgres enums and views defined using Drizzle ORM. It requires Drizzle ORM and drizzle-zod to be installed. It showcases how to define a schema for a view and how to parse data against it. The expected output is a parsed object matching the structure of the enum or view.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-zod/0.6.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum } from 'drizzle-orm/pg-core';\nimport { createSelectSchema } from 'drizzle-zod';\n\nconst roles = pgEnum('roles', ['admin', 'basic']);\nconst rolesSchema = createSelectSchema(roles);\nconst parsed: 'admin' | 'basic' = rolesSchema.parse(...);\n\nconst usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));\nconst usersViewSchema = createSelectSchema(usersView);\nconst parsed: { id: number; name: string; age: number } = usersViewSchema.parse(...);\n```\n\n----------------------------------------\n\nTITLE: Selecting Distinct Values in Drizzle ORM (TypeScript)\nDESCRIPTION: Illustrates the usage of the `selectDistinct()` method to retrieve distinct rows from a table. It also shows how to order the results based on specific columns using `orderBy()`. Requires the `usersDistinctTable` to be defined elsewhere.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.selectDistinct().from(usersDistinctTable).orderBy(\n  usersDistinctTable.id,\n  usersDistinctTable.name,\n);\n```\n\n----------------------------------------\n\nTITLE: Mapping a JSONB Value to Driver Value (PostgreSQL)\nDESCRIPTION: This code snippet shows an example of overriding the `mapToDriverValue` function to serialize a JSONB value before sending it to the database. It uses `JSON.stringify` to convert the input value to a JSON string.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\noverride mapToDriverValue(value: TData): string {\n  return JSON.stringify(value);\n}\n```\n\n----------------------------------------\n\nTITLE: pg_vector Extension Indexes (v0.7.0+) - TypeScript\nDESCRIPTION: This snippet defines PostgreSQL table indexes for `pg_vector` version 0.7.0 and later. It showcases how to create indexes for L1 distance, Hamming distance, and Jaccard distance using the `vector_l1_ops`, `bit_hamming_ops`, and `bit_jaccard_ops` operators.  Requires the `pg_vector` extension to be installed in the database and be version 0.7.0 or greater.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = pgTable('table', {\n    embedding: vector('embedding', { dimensions: 3 })\n}, (table) => ({\n    l1: index('l1_index').using('hnsw', table.embedding.op('vector_l1_ops'))\n    hamming: index('hamming_index').using('hnsw', table.embedding.op('bit_hamming_ops'))\n    bit: index('bit_jaccard_index').using('hnsw', table.embedding.op('bit_jaccard_ops'))\n}))\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Migrations Schema (TypeScript)\nDESCRIPTION: This snippet demonstrates configuring a custom schema name for storing migration information in PostgreSQL using the `migrationsSchema` option in the `migrate` function. It requires the `db` instance and the path to the migrations folder. This only works with PostgreSQL databases.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.5.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait migrate(db, {\n\tmigrationsFolder: './drizzle',\n\tmigrationsSchema: 'custom',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating update schema for Drizzle tables with Zod\nDESCRIPTION: This code snippet demonstrates how to use `createUpdateSchema` to generate a Zod schema for updating rows in a Drizzle table.  It utilizes `pgTable`, `text`, and `integer` from `drizzle-orm/pg-core`, and `createUpdateSchema` from `drizzle-zod`. The schema defines the table structure and uses `createUpdateSchema` to generate a Zod schema suitable for validating update operations. Generated columns like `id` will not be included in the update schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-zod/0.6.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, text, integer } from 'drizzle-orm/pg-core';\nimport { createUpdateSchema } from 'drizzle-zod';\n\nconst users = pgTable('users', {\n  id: integer().generatedAlwaysAsIdentity().primaryKey(),\n  name: text().notNull(),\n  age: integer().notNull()\n});\n\nconst userUpdateSchema = createUpdateSchema(users);\n\nconst user = { id: 5, name: 'John' };\nconst parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema.parse(user); // Error: `id` is a generated column, it can't be updated\n\nconst user = { age: 35 };\nconst parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema.parse(user); // Will parse successfully\nawait db.update(users).set(parsed).where(eq(users.name, 'Jane'));\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Serial Type for Postgres\nDESCRIPTION: This snippet defines a custom Serial data type for PostgreSQL using the `customType` function from Drizzle ORM. It specifies the data type as 'serial' and configures the type to be non-nullable and have a default value.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst customSerial = customType<{ data: number; notNull: true; default: true }>(  {\n    dataType() {\n      return 'serial';\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Using WITH clause with raw SQL template in Drizzle ORM\nDESCRIPTION: This snippet demonstrates using the `WITH` clause with a raw SQL template in Drizzle ORM.  It defines a `users` table, creates a CTE named `sq` using `db.$with`, and assigns a raw SQL query to it using `sql`. The `sql` template literal is used to embed the `users` table and the `users.name` column into the SQL query.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\nconst sq = db.$with('sq', {\n  userId: users.id,\n  data: {\n    name: users.name,\n  },\n}).as(sql`select * from ${users} where ${users.name} = 'John'`);\n\nconst result = await db.with(sq).select().from(sq);\n```\n\n----------------------------------------\n\nTITLE: Using WITH Clause - SQLite\nDESCRIPTION: Demonstrates the usage of the WITH clause for defining common table expressions (CTEs) in Drizzle ORM with SQLite.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nconst sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\nconst result = db.with(sq).select().from(sq).all();\n```\n\n----------------------------------------\n\nTITLE: Linking Policy to Existing Supabase Table\nDESCRIPTION: This example demonstrates how to link a policy to an existing table in Supabase (realtimeMessages). It grants the authenticated role insert access.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sql } from \"drizzle-orm\";\nimport { pgPolicy } from \"drizzle-orm/pg-core\";\nimport { authenticatedRole, realtimeMessages } from \"drizzle-orm/supabase\";\n\nexport const policy = pgPolicy(\"authenticated role insert policy\", {\n  for: \"insert\",\n  to: authenticatedRole,\n  using: sql``,\n}).link(realtimeMessages);\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for UPDATE ... FROM example\nDESCRIPTION: This SQL code is generated by the Drizzle ORM from the TypeScript code above. It updates the `users` table by setting the `city_id` column based on the `cities` table, using a `WHERE` clause to filter the rows to be updated.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nupdate \"users\" set \"city_id\" = \"cities\".\"id\" \nfrom \"cities\" \nwhere (\"cities\".\"name\" = $1 and \"users\".\"name\" = $2)\n\n-- params: [ 'Seattle', 'John' ]\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with Planetscale Serverless - TypeScript\nDESCRIPTION: This code snippet demonstrates how to connect to a Planetscale database using the `@planetscale/database` package and then initialize Drizzle ORM with the established connection.  It imports the necessary modules, creates a connection object using environment variables for database credentials, and then initializes Drizzle with the connection.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.17.5.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/planetscale-serverless';\nimport { connect } from '@planetscale/database';\n\n// create the connection\nconst connection = connect({\n  host: process.env['DATABASE_HOST'],\n  username: process.env['DATABASE_USERNAME'],\n  password: process.env['DATABASE_PASSWORD'],\n});\n\nconst db = drizzle(connection);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Gel using Drizzle\nDESCRIPTION: This snippet demonstrates how to connect to a Gel database using Drizzle ORM. It imports the `drizzle` function from `drizzle-orm/gel` and `createClient` from `gel`. It then creates a Gel client and uses it to instantiate a Drizzle database object. The code executes a simple query to demonstrate the connection.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.40.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Make sure to install the 'gel' package \nimport { drizzle } from \"drizzle-orm/gel\";\nimport { createClient } from \"gel\";\n\nconst gelClient = createClient();\nconst db = drizzle({ client: gelClient });\n\nconst result = await db.execute('select 1');\n```\n\n----------------------------------------\n\nTITLE: SQL Output from drizzle-kit export (SQL)\nDESCRIPTION: This is the SQL DDL output generated by the `drizzle-kit export` command based on the Drizzle schema. It creates a table named 'users' with the specified columns and constraints. This SQL can then be used by other migration tools.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.30.1.md#_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE \"users\" (\n        \"id\" serial PRIMARY KEY NOT NULL,\n        \"email\" text NOT NULL,\n        \"name\" text\n);\n```\n\n----------------------------------------\n\nTITLE: Configure casing in Drizzle connection\nDESCRIPTION: This TypeScript code snippet shows how to configure the `casing` parameter in the Drizzle connection options to automatically map camelCase column names to snake_case in the database queries.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = await drizzle('node-postgres', { connection: '', casing: 'snake_case' })\n```\n\n----------------------------------------\n\nTITLE: Drizzle ORM Limit/Offset with Placeholders (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to create a Drizzle ORM query with placeholders for the `limit` and `offset` clauses. It uses the `placeholder` function to define named placeholders that are later replaced with actual values during query execution. The `prepare` method creates a prepared statement for efficient and secure execution of the query with different parameter values. The `execute` method then executes the prepared statement with the specified limit and offset values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.24.5.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst stmt = db\n  .select({\n    id: usersTable.id,\n    name: usersTable.name,\n  })\n  .from(usersTable)\n  .limit(placeholder('limit'))\n  .offset(placeholder('offset'))\n  .prepare('stmt');\n\nconst result = await stmt.execute({ limit: 1, offset: 1 });\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Cyclic Table Definition and Seeding - TypeScript\nDESCRIPTION: This code snippet defines two tables, `modelTable` and `modelImageTable`, with a cyclic foreign key relationship. The `modelTable` references `modelImageTable` through `defaultImageId`, and `modelImageTable` references `modelTable` through `modelId`. The snippet also demonstrates how to seed both tables using `drizzle-seed`. Requires `drizzle` for database connection.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.3.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AnyPgColumn } from \"drizzle-orm/pg-core\";\nimport {\n  foreignKey,\n  integer,\n  pgTable,\n  serial,\n  varchar,\n} from \"drizzle-orm/pg-core\";\n\nexport const modelTable = pgTable(\n  \"model\",\n  {\n    id: serial().primaryKey(),\n    name: varchar().notNull(),\n    defaultImageId: integer(),\n  },\n  (t) => [\n    foreignKey({\n      columns: [t.defaultImageId],\n      foreignColumns: [modelImageTable.id],\n    }),\n  ]\n);\n\nexport const modelImageTable = pgTable(\"model_image\", {\n  id: serial().primaryKey(),\n  url: varchar().notNull(),\n  caption: varchar(),\n  modelId: integer()\n    .notNull()\n    .references((): AnyPgColumn => modelTable.id),\n});\n\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await seed(db, { modelTable, modelImageTable });\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: UPDATE ... FROM with alias - TypeScript\nDESCRIPTION: This code snippet demonstrates the usage of table aliases with `UPDATE ... FROM`. An alias `c` is created for the `cities` table, and the `cityId` column of the `users` table is updated using the aliased table. This helps avoid ambiguity and improves readability when dealing with complex queries involving multiple tables.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst c = alias(cities, 'c');\nawait db\n  .update(users)\n  .set({ cityId: c.id })\n  .from(c);\n```\n\n----------------------------------------\n\nTITLE: Configuring Transaction Settings in SQLite\nDESCRIPTION: This example demonstrates how to configure transaction settings like `behavior` (deferred, immediate, exclusive) when using Drizzle ORM. These settings control the locking behavior of the transaction.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SQLiteTransactionConfig {\n  behavior?: 'deferred' | 'immediate' | 'exclusive';\n}\n\ndb.transaction((tx) => { ... }, {\n  behavior: 'immediate',\n});\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Config (JavaScript)\nDESCRIPTION: This code snippet shows an example of a Drizzle Kit configuration file in JavaScript. It demonstrates how to define the schema location, connection string, output directory, and breakpoints settings using JSDoc for type hinting.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n/** @type { import(\"drizzle-kit\").Config } */\nexport default {\n    schema: \"\",\n  connectionString: \"\",\n  out: \"\",\n  breakpoints: true\n};\n```\n\n----------------------------------------\n\nTITLE: Using WITH clause with UPDATE statement in Drizzle ORM\nDESCRIPTION: This code demonstrates using the `WITH` clause with an `UPDATE` statement in Drizzle ORM. It defines a `users` table, creates a CTE named `sq` that updates the age of a user with the name 'John', and then selects from the CTE. The `eq` function from Drizzle ORM is required.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\nconst sq = db.$with('sq').as(\n    db.update(users).set({ age: 25 }).where(eq(users.name, 'John')).returning(),\n);\nconst result = await db.with(sq).select().from(sq);\n```\n\n----------------------------------------\n\nTITLE: Full PostgreSQL Text Data Type Example\nDESCRIPTION: This code provides a complete example of defining a custom `text` data type for PostgreSQL using Drizzle ORM. It includes the `PgTextBuilder` and `PgText` classes, as well as a helper function to create instances of the builder.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ColumnConfig, ColumnBuilderConfig } from 'drizzle-orm';\nimport { AnyPgTable } from 'drizzle-orm/pg-core';\n\nimport { PgColumn, PgColumnBuilder } from './common';\n\nexport class PgTextBuilder<TData extends string = string>\n  extends PgColumnBuilder<\n    ColumnBuilderConfig<{ data: TData; driverParam: string }>\n  >\n{\n  \n\n  build<TTableName extends string>(\n    table: AnyPgTable<{ name: TTableName }>,\n  ): PgText<TTableName, TData> {\n    return new PgText(table, this.config);\n  }\n}\n\nexport class PgText<TTableName extends string, TData extends string>\n  extends PgColumn<\n    ColumnConfig<{ tableName: TTableName; data: TData; driverParam: string }>\n  >\n{\n  \n\n  constructor(\n    table: AnyPgTable<{ name: TTableName }>,\n    builder: PgTextBuilder<TData>['config'],\n  ) {\n    super(table, builder);\n  }\n\n  getSQLType(): string {\n    return 'text';\n  }\n}\n\nexport function text<T extends string = string>(\n  name: string,\n): PgTextBuilder<T> {\n  return new PgTextBuilder(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Multiple Items - SQLite\nDESCRIPTION: Shows how to insert multiple items into a table at once using Drizzle ORM with SQLite, both with individual values and an array of values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ndb.insert(users)\n  .values(\n    {\n      name: 'Andrew',\n      createdAt: new Date(),\n    },\n    {\n      name: 'Dan',\n      createdAt: new Date(),\n    },\n  )\n  .run();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst newUsers: NewUser[] = [\n  {\n      name: 'Andrew',\n      createdAt: new Date(),\n  },\n  {\n    name: 'Dan',\n    createdAt: new Date(),\n  },\n];\n\ndb.insert(users).values(newUsers).run();\n```\n\n----------------------------------------\n\nTITLE: Executing Neon HTTP Batch Query - TypeScript\nDESCRIPTION: This code demonstrates how to execute a batch of queries using the Neon HTTP Batch feature in Drizzle ORM. It inserts data into the usersTable and then retrieves data using findMany and findFirst. The result is stored in the batchResponse variable.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.4.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst batchResponse: BatchType = await db.batch([\n\tdb.insert(usersTable).values({ id: 1, name: 'John' }).returning({\n\t\tid: usersTable.id,\n\t}),\n\tdb.insert(usersTable).values({ id: 2, name: 'Dan' }),\n\tdb.query.usersTable.findMany({}),\n\tdb.query.usersTable.findFirst({}),\n]);\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle Kit for SQLite Durable Objects\nDESCRIPTION: This code snippet configures Drizzle Kit to use the SQLite Durable Objects driver. It specifies the output directory for generated files, the schema file, the dialect as SQLite and the driver as 'durable-sqlite'. This setup prepares Drizzle Kit to interact with SQLite databases within a Durable Objects environment.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.29.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'dotenv/config';\nimport { defineConfig } from 'drizzle-kit';\nexport default defineConfig({\n  out: './drizzle',\n  schema: './src/db/schema.ts',\n  dialect: 'sqlite',\n  driver: 'durable-sqlite',\n});\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: Sum Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `sum` aggregate function in Drizzle ORM. It shows the direct usage of the `sum()` helper and its equivalent using the `sql` template literal, emphasizing the `.mapWith(String)` call to properly handle the returned value as a string.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: sum(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`sum(${users.id})`.mapWith(String) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with AWS Data API for PostgreSQL (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to establish a database connection using Drizzle ORM with the AWS Data API for PostgreSQL. It imports necessary modules from 'drizzle-orm/aws-data-api/pg', initializes an RDSDataClient, and creates a Drizzle database instance. It also includes a migration step, pointing to a migrations folder.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.17.3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle, migrate } from 'drizzle-orm/aws-data-api/pg';\n\nconst rdsClient = new RDSDataClient({});\n\nconst db = drizzle(rdsClient, {\n  database: '',\n  secretArn: '',\n  resourceArn: '',\n});\n\nawait migrate(db, { migrationsFolder: '' });\n```\n\n----------------------------------------\n\nTITLE: PG Array Support - Typescript\nDESCRIPTION: This code shows how to declare and define a PostgreSQL array using drizzle-orm and drizzle-typebox. It covers both the drizzle-orm declaration and the corresponding Typebox schema representation including defining the array size.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-typebox/0.2.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\npg.dataType().array(...);\n\n// Schema\nType.Array(baseDataTypeSchema, { minItems: size, maxItems: size });\n```\n\n----------------------------------------\n\nTITLE: Updating JSON column to JSON\nDESCRIPTION: This SQL query updates a JSON column in a PostgreSQL table by converting its string representation to a JSON object. It extracts the string value using `#>> '{}'` and then casts it back to JSON. This is intended to correct cases where JSON data was inadvertently stored as a string.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.33.0.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nupdate table_name\nset json_column = (json_column #>> '{}')::json;\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Text Column Builder\nDESCRIPTION: This code defines a custom `PgTextBuilder` class that extends `PgColumnBuilder`. It is responsible for generating the fields needed for column creation. The `build` function returns a `PgText` column, which will be used in the table schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class PgTextBuilder<TData extends string = string>\n  extends PgColumnBuilder<\n    ColumnBuilderConfig<{ data: TData; driverParam: string }>\n  >\n{\n  \n\n  build<TTableName extends string>(\n    table: AnyPgTable<{ name: TTableName }>,\n  ): PgText<TTableName, TData> {\n    return new PgText(table, this.config);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with @libsql/client/ws\nDESCRIPTION: This snippet demonstrates initializing Drizzle ORM with the `@libsql/client/ws` driver. It imports the drizzle function from `drizzle-orm/libsql/ws` and establishes a database connection using environment variables for the URL and authentication token. This module supports ws and wss connection protocols.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.3.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/libsql/ws';\n\nconst db = drizzle({ connection: {\n  url: process.env.DATABASE_URL, \n  authToken: process.env.DATABASE_AUTH_TOKEN \n}});\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Configuration with extensionsFilters - TypeScript\nDESCRIPTION: This snippet shows how to configure Drizzle Kit to filter out extension-related tables when using `push` or `introspect`. By specifying `extensionsFilters: [\"postgis\"]`, Drizzle Kit will skip the `geography_columns`, `geometry_columns`, and `spatial_ref_sys` tables created by the PostGIS extension.  Requires the `drizzle-kit` package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'drizzle-kit'\n\nexport default defaultConfig({\n  dialect: \"postgresql\",\n  extensionsFilters: [\"postgis\"],\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding Fields in Insert Schema - TypeScript\nDESCRIPTION: Shows how to override the type of a specific field (in this case, `role`) within the insert schema generated by `createInsertSchema`. This allows for custom validation using ArkType's type definitions.  It uses the `type` function from ArkType to define a new type for the `role` field.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-arktype/0.1.2.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Overriding the fields\nconst insertUserSchema = createInsertSchema(users, {\n\trole: type('string'),\n});\n```\n\n----------------------------------------\n\nTITLE: Overriding Fields in Insert Schema\nDESCRIPTION: Demonstrates how to override specific fields in the generated insert schema using the second argument of `createInsertSchema`.  In this case, the `role` field is explicitly defined as a string type using `arktype`'s `type` function, allowing custom type definitions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-arktype/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Overriding the fields\nconst insertUserSchema = createInsertSchema(users, {\n\trole: type('string'),\n});\n```\n\n----------------------------------------\n\nTITLE: Querying, Sorting, and Filtering - SQLite\nDESCRIPTION: Illustrates how to perform basic select queries, filtering with 'and' and 'or', partial selects, and using limit, offset, and order by clauses in Drizzle ORM with SQLite.  It requires Drizzle ORM and better-sqlite3.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n...\nimport { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';\nimport { and, asc, desc, eq, or } from 'drizzle-orm'\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport Database from 'better-sqlite3';\n\nconst users = sqliteTable('users', {\n  id: integer('id').primaryKey(),\n  name: text('full_name'),\n});\n\nconst sqlite = new Database('sqlite.db');\nconst db = drizzle(sqlite);\n\ndb.select().from(users).all();\ndb.select().from(users).where(eq(users.id, 42)).get();\n\n// you can combine filters with and(...) or or(...)\ndb.select().from(users).where(and(eq(users.id, 42), eq(users.name, 'Dan'))).all();\n\ndb.select().from(users).where(or(eq(users.id, 42), eq(users.id, 1))).all();\n\n// partial select\nconst result = db\n  .select({\n    field1: users.id,\n    field2: users.name,\n  })\n  .from(users)\n  .all();\nconst { field1, field2 } = result[0];\n\n// limit offset & order by\ndb.select().from(users).limit(10).offset(10).all();\ndb.select().from(users).orderBy(users.name).all();\ndb.select().from(users).orderBy(desc(users.name)).all();\n// you can pass multiple order args\ndb.select().from(users).orderBy(asc(users.name), desc(users.name)).all();\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (New - Config Object)\nDESCRIPTION: This TypeScript code illustrates an alternative initialization with a config object, allowing additional options like `logger` and a `connection` property containing the connection URL. This provides flexibility in configuring the Drizzle client.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// If you need to pass a logger, schema, or other configurations, you can use an object and specify the client-specific URL in the connection\nconst db2 = await drizzle(\"node-postgres\", {\n  connection: process.env.POSTGRES_URL,\n  logger: true\n});\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: Avg Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `avg` aggregate function in Drizzle ORM. It showcases both the direct usage of the `avg()` helper and its equivalent using the `sql` template literal. Note the usage of `.mapWith(String)` for the `sql` template version, ensuring the returned value is correctly handled as a string.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: avg(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`avg(${users.id})`.mapWith(String) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: LibSQL Batch API Usage\nDESCRIPTION: Demonstrates how to use the batch API with LibSQL in Drizzle ORM. It executes multiple database operations (insert, update, select) in a single batch.  Requires a Drizzle database instance and relevant table definitions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.6.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst batchResponse = await db.batch([\n\tdb.insert(usersTable).values({ id: 1, name: 'John' }).returning({\n\t\tid: usersTable.id,\n\t}),\n\tdb.update(usersTable).set({ name: 'Dan' }).where(eq(usersTable.id, 1)),\n\tdb.query.usersTable.findMany({}),\n\tdb.select().from(usersTable).where(eq(usersTable.id, 1)),\n\tdb.select({ id: usersTable.id, invitedBy: usersTable.invitedBy }).from(\n\t\tusersTable,\n\t),\n]);\n```\n\n----------------------------------------\n\nTITLE: Using the Query Builder in SQLite\nDESCRIPTION: This snippet demonstrates the usage of the standalone query builder provided by Drizzle ORM. It allows building SQL queries without needing a direct database instance. The generated SQL query and parameters can be accessed using `toSQL()` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\nimport { queryBuilder as qb } from 'drizzle-orm/sqlite-core';\n\nconst query = qb.select().from(users).where(eq(users.name, 'Dan'));\nconst { sql, params } = query.toSQL();\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Sequences (With Params)\nDESCRIPTION: This code snippet shows how to define a PostgreSQL sequence with various parameters such as `startWith`, `maxValue`, `minValue`, `cycle`, `cache`, and `increment`. These parameters control the behavior of the sequence.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Sequence with params\nexport const customSequence = pgSequence(\"name\", {\n      startWith: 100,\n      maxValue: 10000,\n      minValue: 100,\n      cycle: true,\n      cache: 10,\n      increment: 2\n});\n```\n\n----------------------------------------\n\nTITLE: Type Coercion with drizzle-zod in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use `drizzle-zod` to create a schema with type coercion. It imports necessary modules from `drizzle-orm/pg-core`, `drizzle-zod`, and `zod`. It defines a PostgreSQL table `users` with a `createdAt` timestamp column. The `createSchemaFactory` is used with the `coerce` option set to `{ date: true }` to coerce date types during schema creation.  Finally, it shows the equivalent `zod` schema created manually using `z.coerce.date()`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-zod/0.7.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, timestamp } from 'drizzle-orm/pg-core';\nimport { createSchemaFactory } from 'drizzle-zod';\nimport { z } from 'zod';\n\nconst users = pgTable('users', {\n  ...,\n  createdAt: timestamp().notNull()\n});\n\nconst { createInsertSchema } = createSchemaFactory({\n  // This configuration will only coerce dates. Set `coerce` to `true` to coerce all data types or specify others\n  coerce: {\n    date: true\n  }\n});\n\nconst userInsertSchema = createInsertSchema(users);\n// The above is the same as this:\nconst userInsertSchema = z.object({\n  ...,\n  createdAt: z.coerce.date()\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating with Drizzle MySQL Proxy - TypeScript\nDESCRIPTION: This snippet demonstrates how to perform database migrations using the Drizzle ORM MySQL Proxy. It utilizes the `migrate` function from `drizzle-orm/mysql-proxy/migrator` and defines an asynchronous function to send an array of SQL queries to the proxy server via an HTTP POST request. It includes basic error handling to catch proxy server errors and re-throw an error to halt the migration process.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/mysql-proxy/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { migrate } from 'drizzle-orm/mysql-proxy/migrator';\n\nawait migrate(db, async (queries) => {\n  try {\n    await axios.post('http://localhost:3000/migrate', { queries });\n  } catch (e) {\n    console.log(e);\n    throw Error('Proxy server cannot run migrations');\n  }\n}, { migrationsFolder: 'drizzle' });\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with @libsql/client/web\nDESCRIPTION: This snippet demonstrates initializing Drizzle ORM with the `@libsql/client/web` driver. It imports the drizzle function from `drizzle-orm/libsql/web` and establishes a database connection using environment variables for the URL and authentication token. This module is designed for fullstack web frameworks.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.3.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/libsql/web';\n\nconst db = drizzle({ connection: {\n  url: process.env.DATABASE_URL, \n  authToken: process.env.DATABASE_AUTH_TOKEN \n}});\n```\n\n----------------------------------------\n\nTITLE: Defining Supabase Roles in Drizzle ORM (TypeScript)\nDESCRIPTION: This snippet shows how to define Supabase roles using `pgRole` and mark them as existing roles in Drizzle ORM. It exports these roles for use in other parts of the schema definition.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.27.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// drizzle-orm/supabase\nexport const anonRole = pgRole('anon').existing();\nexport const authenticatedRole = pgRole('authenticated').existing();\nexport const serviceRole = pgRole('service_role').existing();\nexport const postgresRole = pgRole('postgres_role').existing();\nexport const supabaseAuthAdminRole = pgRole('supabase_auth_admin').existing();\n```\n\n----------------------------------------\n\nTITLE: Selecting Distinct Values with `DISTINCT ON` in PostgreSQL (TypeScript)\nDESCRIPTION: Shows how to use `selectDistinctOn()` with PostgreSQL to select distinct values based on specified columns, effectively utilizing the `DISTINCT ON` clause.  Requires `usersDistinctTable` to be defined elsewhere. First example uses just the column, second uses the column and a named property to enforce ordering.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.selectDistinctOn([usersDistinctTable.id]).from(usersDistinctTable).orderBy(\n  usersDistinctTable.id,\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.selectDistinctOn([usersDistinctTable.name], { name: usersDistinctTable.name }).from(\n  usersDistinctTable,\n).orderBy(usersDistinctTable.name);\n```\n\n----------------------------------------\n\nTITLE: Using set operators with import approach\nDESCRIPTION: This code demonstrates how to use set operators (UNION) in Drizzle ORM using the import approach.  It shows combining the results of two select queries into a single result set.  It depends on the `union` function from `drizzle-orm/pg-core`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { union } from 'drizzle-orm/pg-core'\n\nconst allUsersQuery = db.select().from(users);\nconst allCustomersQuery = db.select().from(customers);\n\nconst result = await union(allUsersQuery, allCustomersQuery)\n```\n\n----------------------------------------\n\nTITLE: Defining npm scripts for Drizzle Kit\nDESCRIPTION: This JSON snippet defines npm scripts for Drizzle Kit to automate database schema generation and updates. The `generate` script automatically creates migration files based on schema changes, while the `up` script applies those migrations to the database. The `--schema` flag specifies the location of the schema file.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/cloudflare-d1/README.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  ...\n  scripts: {\n    \"generate\": \"drizzle-kit generate:sqlite --schema=src/schema.ts\",\n    \"up\": \"drizzle-kit up:sqlite --schema=src/schema.ts\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Database with Drizzle Seed in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `reset` function in `drizzle-seed` to reset the database and seed it with new values. It imports the schema and the `reset` function, initializes the database connection, and then calls `reset` to clear and re-seed the database.  The `schema` import should point to a file containing the database schema definition. Requires `drizzle-orm` and `drizzle-seed` to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-seed/README.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// path to a file with schema you want to reset\nimport * as schema from \"./schema.ts\";\nimport { reset } from \"drizzle-seed\";\n\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await reset(db, schema);\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Configuring MySQL SSL with Drizzle Kit (Typescript)\nDESCRIPTION: This snippet configures SSL settings for a MySQL database connection using Drizzle Kit.  It shows how to set the 'ssl' property within the 'dbCredentials' object to an empty string.  It can also be set to an SslOptions object from the mysql2 package. This configuration enables SSL connection to the MySQL database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'drizzle-kit'\n\nexport default defaultConfig({\n  dialect: \"mysql\",\n  dbCredentials: {\n    ssl: \"\", // string | SslOptions (ssl options from mysql2 package)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Seeding with Version Parameter - Typescript\nDESCRIPTION: This snippet demonstrates how to use the `version` parameter with the `seed` function to control the generator version. It explicitly specifies version '2' for the seeding process. This is crucial for maintaining consistency across regenerations when deterministic generators are updated.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { version: '2' });\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (AWS Data API)\nDESCRIPTION: This TypeScript code snippet demonstrates the initialization of Drizzle ORM with AWS Data API for PostgreSQL. It requires `resourceArn`, `database`, and `secretArn` configurations for the connection.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ndrizzle(\"aws-data-api-pg\", {\n  connection: {\n    resourceArn: \"\",\n    database: \"\",\n    secretArn: \"\",\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Drizzle ORM Table Definition and Schema Generation\nDESCRIPTION: Defines a PostgreSQL table named `users` using Drizzle ORM and generates corresponding schemas for inserting, updating, and selecting users using `createInsertSchema`, `createUpdateSchema`, and `createSelectSchema` from `drizzle-arktype`.  This example demonstrates the basic usage of the plugin with default schemas.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-arktype/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';\nimport { createInsertSchema, createSelectSchema } from 'drizzle-arktype';\nimport { type } from 'arktype';\n\nconst users = pgTable('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\temail: text('email').notNull(),\n\trole: text('role', { enum: ['admin', 'user'] }).notNull(),\n\tcreatedAt: timestamp('created_at').notNull().defaultNow(),\n});\n\n// Schema for inserting a user - can be used to validate API requests\nconst insertUserSchema = createInsertSchema(users);\n\n// Schema for updating a user - can be used to validate API requests\nconst updateUserSchema = createUpdateSchema(users);\n\n// Schema for selecting a user - can be used to validate API responses\nconst selectUserSchema = createSelectSchema(users);\n```\n\n----------------------------------------\n\nTITLE: Relational Queries Where Filter Improvement\nDESCRIPTION: Illustrates the updated syntax for using SQL operators within the `where` filter function in Relational Queries. Simplifies importing and usage of operators like `inArray`.  Requires a Drizzle database instance and relevant table definitions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.6.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.users.findFirst({\n  where: (table, { inArray }) => inArray(table.id, [ ... ])\n})\n```\n\n----------------------------------------\n\nTITLE: WITH Clause with Aliased Raw SQL - SQLite\nDESCRIPTION: Demonstrates the usage of the WITH clause with raw SQL and aliasing for a subquery using Drizzle ORM with SQLite. An alias is required to use the raw sql field in other queries. Without it, you get `DrizzleTypeError` at compile time and runtime errors.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst sq = db.$with('sq').as(db.select({ name: sql<string>`upper(${users.name})`.as('name') }).from(users));\nconst result = db.with(sq).select({ name: sq.name }).from(sq).all();\n```\n\n----------------------------------------\n\nTITLE: Using PG arrays with Drizzle and Zod\nDESCRIPTION: This code snippet shows how to define and validate Postgres arrays using Drizzle ORM and Zod. It assumes that `pg.dataType().array(...)` is used to define the array column in the Drizzle schema. The Zod schema uses `z.array(baseDataTypeSchema).length(size)` to validate the array's contents and length.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-zod/0.6.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\npg.dataType().array(...);\n\n// Schema\nz.array(baseDataTypeSchema).length(size);\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Seeding Usage - Typescript\nDESCRIPTION: This snippet seeds database using the PostgreSQL table. The result of the seeding process will be affected by new changes.  The developer needs to specify the version that needs to be used if the application is not ready to upgrade to latest version\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// index.ts\n...\n// this will be affected with new changes\nawait seed(db, { table });\n```\n\n----------------------------------------\n\nTITLE: D1 Batch API Supported Builders\nDESCRIPTION: This code snippet lists the possible builders that can be used inside the `db.batch` function when working with the D1 Batch API in Drizzle ORM.  These builders allow for executing various database operations like selecting, updating, deleting, and inserting data within a single batch.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n`db.all()`,\n`db.get()`,\n`db.values()`,\n`db.run()`,\n`db.query.<table>.findMany()`,\n`db.query.<table>.findFirst()`,\n`db.select()...`,\n`db.update()...`,\n`db.delete()...`,\n`db.insert()...`,\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Configuration with Glob Patterns for Schema Path\nDESCRIPTION: This JSON configuration demonstrates how to use glob patterns for specifying the schema path in the `drizzle.config` file. It allows Drizzle Kit to find multiple schema files using glob patterns. The `out` key specifies the output directory for generated migrations.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n{\n  \"out: \": \"./migrations\", \n  \"schema\": [\"./core/**/*.ts\", \"./database/schema.ts\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle Kit for Gel Dialect (TypeScript)\nDESCRIPTION: This code snippet shows how to configure Drizzle Kit to use the Gel dialect in `drizzle.config.ts`. Setting the `dialect` property to `'gel'` instructs Drizzle Kit to interact with a Gel database. This configuration is crucial for pulling the Gel database schema into a Drizzle schema using drizzle-kit.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.30.5.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// drizzle.config.ts\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  dialect: 'gel',\n});\n```\n\n----------------------------------------\n\nTITLE: SQLite Migration Statement Example\nDESCRIPTION: This SQL code demonstrates the generated migration statements for SQLite. It recreates the table `worker` with the new schema and migrates the existing data to the new table. Then, it drops the old table and renames the new table to the original table name. It also handles enabling/disabling foreign key checks.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nPRAGMA foreign_keys=OFF;\n--> statement-breakpoint\nCREATE TABLE `__new_worker` (\n  `id` integer PRIMARY KEY NOT NULL,\n  `name` text NOT NULL,\n  `salary` text NOT NULL,\n  `job_id` integer,\n  FOREIGN KEY (`job_id`) REFERENCES `job`(`id`) ON UPDATE no action ON DELETE no action\n);\n--> statement-breakpoint\nINSERT INTO `__new_worker`(\"id\", \"name\", \"salary\", \"job_id\") SELECT \"id\", \"name\", \"salary\", \"job_id\" FROM `worker`;\n--> statement-breakpoint\nDROP TABLE `worker`;\n--> statement-breakpoint\nALTER TABLE `__new_worker` RENAME TO `worker`;\n--> statement-breakpoint\nPRAGMA foreign_keys=ON;\n```\n\n----------------------------------------\n\nTITLE: Generated SQLite migration statements\nDESCRIPTION: This SQL snippet shows an example of the generated statements for SQLite migrations. It includes creating a new table, inserting data from the old table, dropping the old table, and renaming the new table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nPRAGMA foreign_keys=OFF;\n--> statement-breakpoint\nCREATE TABLE `__new_worker` (\n  `id` integer PRIMARY KEY NOT NULL,\n  `name` text NOT NULL,\n  `salary` text NOT NULL,\n  `job_id` integer,\n  FOREIGN KEY (`job_id`) REFERENCES `job`(`id`) ON UPDATE no action ON DELETE no action\n);\n--> statement-breakpoint\nINSERT INTO `__new_worker`(\"id\", \"name\", \"salary\", \"job_id\") SELECT \"id\", \"name\", \"salary\", \"job_id\" FROM `worker`;\n--> statement-breakpoint\nDROP TABLE `worker`;\n--> statement-breakpoint\nALTER TABLE `__new_worker` RENAME TO `worker`;\n--> statement-breakpoint\nPRAGMA foreign_keys=ON;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Jsonb Type for Postgres\nDESCRIPTION: This snippet defines a custom Jsonb data type for PostgreSQL using the `customType` function from Drizzle ORM. It specifies the data type as 'jsonb' and includes a `toDriver` method to stringify the JSON data before writing it to the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst customJsonb = <TData>(name: string) =>  customType<{ data: TData; driverData: string }>({    dataType() {\n      return 'jsonb';\n    },\n    toDriver(value: TData): string {\n      return JSON.stringify(value);\n    },\n  })(name);\n```\n\n----------------------------------------\n\nTITLE: Defining Table in Default Schema - PostgreSQL Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define a table named 'users' within the default PostgreSQL schema using Drizzle ORM. It includes fields like 'id', 'name', 'verified', 'jsonb', and 'createdAt'. The 'id' field is set as the primary key.  The 'createdAt' field defaults to the current timestamp.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-pg/0.15.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst publicUsersTable = pgTable('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\tverified: boolean('verified').notNull().default(false),\n\tjsonb: jsonb<string[]>('jsonb'),\n\tcreatedAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Drizzle ORM and Postgres.js\nDESCRIPTION: Installs Drizzle ORM, Postgres.js driver, and Drizzle Kit using npm, yarn, or pnpm.  Drizzle Kit is installed as a dev dependency.  The snippet demonstrates three different package managers and their respective commands for adding the required packages.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/postgres-js/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# npm\nnpm i drizzle-orm postgres\nnpm i -D drizzle-kit\n\n# yarn\nyarn add drizzle-orm postgres\nyarn add -D drizzle-kit\n\n# pnpm\npnpm add drizzle-orm postgres\npnpm add -D drizzle-kit\n```\n\n----------------------------------------\n\nTITLE: Defining and Using TS Enums with mysqlEnum\nDESCRIPTION: This code snippet demonstrates how to define a TypeScript enum and use it with the `mysqlEnum` function in Drizzle ORM. It showcases how the enum values are inferred as types, enabling direct insertion and retrieval of enum values. The example defines a `Test` enum, creates a table `tableWithTsEnums` using `mysqlEnum`, inserts data, and then selects data to verify the enum values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.42.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nenum Test {\n  a = 'a',\n  b = 'b',\n  c = 'c',\n}\n\nconst tableWithTsEnums = mysqlTable('enums_test_case', {\n  id: serial().primaryKey(),\n  enum1: mysqlEnum(Test).notNull(),\n  enum2: mysqlEnum(Test).default(Test.a),\n});\n\nawait db.insert(tableWithTsEnums).values([\n  { id: 1, enum1: Test.a, enum2: Test.b, enum3: Test.c },\n  { id: 2, enum1: Test.a, enum3: Test.c },\n  { id: 3, enum1: Test.a },\n]);\n\nconst res = await db.select().from(tableWithTsEnums);\n\nexpect(res).toEqual([\n  { id: 1, enum1: 'a', enum2: 'b', enum3: 'c' },\n  { id: 2, enum1: 'a', enum2: 'a', enum3: 'c' },\n  { id: 3, enum1: 'a', enum2: 'a', enum3: 'b' },\n]);\n```\n\n----------------------------------------\n\nTITLE: Multiple Schema Files Example - Plaintext\nDESCRIPTION: Illustrates a project structure where the database schema is split across multiple files within a schema directory.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n <project root>\n   src\n      db\n         schema\n           users.ts\n           countries.ts\n           cities.ts\n           products.ts\n           clients.ts\n           enums.ts\n           etc.ts\n```\n\n----------------------------------------\n\nTITLE: Basic ESLint Configuration\nDESCRIPTION: This YAML configuration file shows how to set up ESLint to use the eslint-plugin-drizzle.  It specifies the TypeScript parser, configures parserOptions to point to the tsconfig.json file, adds 'drizzle' to the plugins array, and enables the 'enforce-delete-with-where' and 'enforce-update-with-where' rules.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nroot: true\nparser: '@typescript-eslint/parser'\nparserOptions:\n  project: './tsconfig.json'\nplugins:\n  - drizzle\nrules:\n  'drizzle/enforce-delete-with-where': \"error\"\n  'drizzle/enforce-update-with-where': \"error\"\n```\n\n----------------------------------------\n\nTITLE: Drizzle config - After Turso dialect change\nDESCRIPTION: This is an example of the `drizzle.config` file after the introduction of the turso dialect.  It uses the `turso` dialect to configure Drizzle Kit specifically for Turso databases.  `schema`, `out`, and `dbCredentials` remain similarly configured.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"turso\",\n  schema: \"./schema.ts\",\n  out: \"./drizzle\",\n  dbCredentials: {\n    url: \"database.db\",\n  },\n  breakpoints: true,\n  verbose: true,\n  strict: true,\n});\n```\n\n----------------------------------------\n\nTITLE: SQLite Schema Definition - Typescript\nDESCRIPTION: This snippet defines an SQLite table schema using `drizzle-orm/sqlite-core`. It includes columns of types `text`, `numeric`, `blob`, and `blobbuffer`. The default generators for these types will output different values with the same seed number from previous version.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// schema.ts\nimport * as p from 'drizzle-orm/sqlite-core'\n\nexport const table = p.sqliteTable('table', {\n  column1: p.text(),\n  column2: p.numeric(),\n  column3: p.blob({ mode:'buffer' }),\n  column4: p.blob(),\n});\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: SumDistinct Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `sumDistinct` aggregate function in Drizzle ORM. It illustrates the usage of the `sumDistinct()` helper and its equivalent using the `sql` template literal. The use of `.mapWith(String)` ensures correct string handling of the resulting value.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: sumDistinct(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`sum(distinct ${users.id})`.mapWith(String) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Timestamp Type for Postgres\nDESCRIPTION: This snippet defines a custom Timestamp data type for PostgreSQL using the `customType` function from Drizzle ORM. It configures the data type based on whether timezone is enabled and includes a `fromDriver` method to parse the string value from the database into a JavaScript Date object.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst customTimestamp = customType<\n  {\n    data: Date;\n    driverData: string;\n    config: { withTimezone: boolean; precision?: number };\n  }\n>({  dataType(config) {\n    const precision = typeof config.precision !== 'undefined'\n      ? ` (${config.precision})`\n      : '';\n    return `timestamp${precision}${      config.withTimezone ? ' with time zone' : ''\n    }`;\n  },\n  fromDriver(value: string): Date {\n    return new Date(value);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Table Schema with Foreign Key & Relations in Drizzle ORM (TS)\nDESCRIPTION: This TypeScript code defines a schema for two tables, 'users' and 'posts', using Drizzle ORM's PostgreSQL dialect. It includes a foreign key constraint on the 'posts' table referencing the 'users' table, as well as a one-to-many relation between the two tables. This setup previously caused issues with the seeder, leading to duplicated relations and an infinite loop.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.3.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// schema.ts\nimport { integer, pgTable, text } from \"drizzle-orm/pg-core\";\nimport { relations } from \"drizzle-orm/relations\";\n\nexport const users = pgTable(\"users\", {\n  id: integer().primaryKey(),\n  name: text(),\n  email: text(),\n});\n\nexport const posts = pgTable(\"posts\", {\n  id: integer().primaryKey(),\n  content: text(),\n  userId: integer().references(() => users.id),\n});\n\nexport const postsRelation = relations(posts, ({ one }) => ({\n  user: one(users, {\n    fields: [posts.userId],\n    references: [users.id],\n  }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Validate Data with Schema - TypeScript\nDESCRIPTION: Illustrates using the generated `insertUserSchema` to validate data.  The `parse` function from `valibot` is used to validate an object against the schema. If the data does not conform to the schema, an error will be thrown.  Dependencies: valibot.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-valibot/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Usage\n\nconst isUserValid = parse(insertUserSchema, {\n\tname: 'John Doe',\n\temail: 'johndoe@test.com',\n\trole: 'admin',\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Batch Response Type - TypeScript\nDESCRIPTION: This TypeScript code defines the structure of the BatchType, which represents the expected response from the db.batch function when using Neon HTTP Batch. It specifies the types for inserted users and query results.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.4.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype BatchType = [\n\t{\n\t\tid: number;\n\t}[],\n\tNeonHttpQueryResult<never>,\n\t{\n\t\tid: number;\n\t\tname: string;\n\t\tverified: number;\n\t\tinvitedBy: number | null;\n\t}[],\n\t{\n\t\tid: number;\n\t\tname: string;\n\t\tverified: number;\n\t\tinvitedBy: number | null;\n\t} | undefined,\n];\n```\n\n----------------------------------------\n\nTITLE: Generated SQL Query (Previous)\nDESCRIPTION: This SQL query is the previous implementation generated by Drizzle ORM for the same relational query.  It uses a more complex structure with subqueries and aggregations, resulting in potentially slower performance. This is provided for comparison to the optimized query.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.0.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nSELECT \"id\",\n       \"user_id\",\n       \"post_id\",\n       \"content\",\n       \"user\"::JSON,\n       \"post\"::JSON\nFROM\n  (SELECT \"comments\".*,\n          CASE\n              WHEN count(\"comments_post\".\"id\") = 0 THEN '[]'\n              ELSE json_agg(json_build_array(\"comments_post\".\"title\", \"comments_post\".\"user\"::JSON))::text\n          END AS \"post\"\n   FROM\n     (SELECT \"comments\".*,\n             CASE\n                 WHEN count(\"comments_user\".\"id\") = 0 THEN '[]'\n                 ELSE json_agg(json_build_array(\"comments_user\".\"name\"))::text\n             END AS \"user\"\n      FROM \"comments\"\n      LEFT JOIN\n        (SELECT \"comments_user\".*\n         FROM \"users\" \"comments_user\") \"comments_user\" ON \"comments\".\"user_id\" = \"comments_user\".\"id\"\n      GROUP BY \"comments\".\"id\",\n               \"comments\".\"user_id\",\n               \"comments\".\"post_id\",\n               \"comments\".\"content\") \"comments\"\n   LEFT JOIN\n     (SELECT \"comments_post\".*\n      FROM\n        (SELECT \"comments_post\".*,\n                CASE\n                    WHEN count(\"comments_post_user\".\"id\") = 0 THEN '[]'\n                    ELSE json_agg(json_build_array(\"comments_post_user\".\"name\"))\n                END AS \"user\"\n         FROM \"posts\" \"comments_post\"\n         LEFT JOIN\n           (SELECT \"comments_post_user\".*\n            FROM \"users\" \"comments_post_user\") \"comments_post_user\" ON \"comments_post\".\"user_id\" = \"comments_post_user\".\"id\"\n         GROUP BY \"comments_post\".\"id\") \"comments_post\") \"comments_post\" ON \"comments\".\"post_id\" = \"comments_post\".\"id\"\n   GROUP BY \"comments\".\"id\",\n            \"comments\".\"user_id\",\n            \"comments\".\"post_id\",\n            \"comments\".\"content\",\n            \"comments\".\"user\") \"comments\"\nLIMIT 1\n```\n\n----------------------------------------\n\nTITLE: Get Table Information - Drizzle ORM (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `getTableConfig` function from `drizzle-orm/pg-core` to retrieve table metadata. It imports `pgTable` and `getTableConfig`, defines a table using `pgTable`, and then uses `getTableConfig` to extract information such as columns, indexes, foreign keys, checks, primary keys, name, and schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/table-introspect-api.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, getTableConfig } from 'drizzle-orm/pg-core';\n\nconst table = pgTable(...);\n\nconst {\n  columns,\n  indexes,\n  foreignKeys,\n  checks,\n  primaryKeys,\n  name,\n  schema,\n} = getTableConfig(table);\n```\n\n----------------------------------------\n\nTITLE: Cloudflare Worker Configuration\nDESCRIPTION: This TOML configuration file (wrangler.toml) defines the settings for a Cloudflare Worker project. It specifies the project name, entry point (main), compatibility date, usage model, and enables Node.js compatibility. This is crucial for deploying the application to Cloudflare Workers.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/neon-cloudflare/readme.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n## wrangler.toml\n\nname = \"neon-cf-demo\"\nmain = \"src/index.ts\"\ncompatibility_date = \"2022-12-09\"\nusage_model = \"unbound\"\nnode_compat = true\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle Kit with Casing Option in TypeScript\nDESCRIPTION: This snippet shows how to configure Drizzle Kit with the `casing` option.  This ensures that migrations generated by Drizzle Kit also adhere to the specified casing strategy (`snake_case` in this example), maintaining consistency between the database schema and the application code.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"postgresql\",\n  schema: \"./schema.ts\",\n  dbCredentials: {\n    url: \"postgresql://postgres:password@localhost:5432/db\",\n  },\n  casing: \"snake_case\",\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with Custom Schema in Postgres using Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define an enum with a custom schema in Postgres using Drizzle ORM.  It imports `pgSchema` from `drizzle-orm/pg-core`, defines a schema named 'mySchema', and creates an enum named 'colors' within that schema with the specified values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.8.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgSchema } from 'drizzle-orm/pg-core';\n\nconst mySchema = pgSchema('mySchema');\nconst colors = mySchema.enum('colors', ['red', 'green', 'blue']);\n```\n\n----------------------------------------\n\nTITLE: Querying Database Using Drizzle ORM with multiple schemas\nDESCRIPTION: This code snippet demonstrates how to query the database using Drizzle ORM with multiple schemas. It shows how to initialize the database connection with multiple schema files and then uses `db.query.users.findMany()` to retrieve data.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as schema1 from './schema1';\nimport * as schema2 from './schema2';\nimport { drizzle } from 'drizzle-orm/...';\n \nconst db = drizzle(client, { schema: { ...schema1, ...schema2 } });\n \nawait db.query.users.findMany(...);\n```\n\n----------------------------------------\n\nTITLE: Drizzle Config Before Turso Dialect Introduction\nDESCRIPTION: This code block represents the `drizzle.config` file before the introduction of the dedicated \"turso\" dialect.  It uses the \"sqlite\" dialect for both SQLite and Turso, which is now deprecated for Turso. This configuration uses sqlite dialect and needs url to connect to DB, schema to define DB and output directory.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"sqlite\",\n  schema: \"./schema.ts\",\n  out: \"./drizzle\",\n  dbCredentials: {\n    url: \"database.db\",\n  },\n  breakpoints: true,\n  verbose: true,\n  strict: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Seeding with Specific Version 1 - Typescript\nDESCRIPTION: This snippet shows how to explicitly specify version '1' for the seeding process.  It allows users to revert to older versions of the generators if needed, maintaining consistency if upgrading causes issues.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { version: '1' });\n```\n\n----------------------------------------\n\nTITLE: Refining Fields in Insert Schema - TypeScript\nDESCRIPTION: This snippet shows how to refine fields in the insert schema.  This allows for transformation or specific validation of the field before it becomes optional/nullable in the generated schema.  It uses `createInsertSchema` and modifies the `id`, `email`, and `role` fields using Zod methods like `positive()` and `email()`. Dependencies include `drizzle-orm/pg-core`, `drizzle-zod`, and `zod`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-zod/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema\nconst insertUserSchema = createInsertSchema(users, {\n  id: (schema) => schema.positive(),\n  email: (schema) => schema.email(),\n  role: z.string(),\n});\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-delete-with-where - Example Code 2\nDESCRIPTION: Example Typescript code showing the effect of `enforce-delete-with-where` ESLint rule when `drizzleObjectName` is defined.  The ESLint rule will only be triggered on Drizzle's `delete` method, and not on the custom class's `delete` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public delete() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will NOT be triggered by ESLint Rule\nmyClassObj.delete()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.delete()\n```\n\n----------------------------------------\n\nTITLE: Defining Supabase Schemas and Tables\nDESCRIPTION: This code defines schemas and tables that are part of the Supabase ecosystem, like `auth.users` and `realtime.messages`. It illustrates how to represent existing Supabase database structures within Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// drizzle-orm/supabase\n\nconst auth = pgSchema('auth');\nexport const authUsers = auth.table('users', {\n\tid: uuid().primaryKey().notNull(),\n});\n\nconst realtime = pgSchema('realtime');\nexport const realtimeMessages = realtime.table(\n\t'messages',\n\t{\n\t\tid: bigserial({ mode: 'bigint' }).primaryKey(),\n\t\ttopic: text().notNull(),\n\t\textension: text({\n\t\t\tenum: ['presence', 'broadcast', 'postgres_changes'],\n\t\t}).notNull(),\n\t},\n);\n\nexport const authUid = sql`(select auth.uid())`;\nexport const realtimeTopic = sql`realtime.topic()`;\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Transactions in SQLite\nDESCRIPTION: This snippet shows how to nest transactions within each other using Drizzle ORM. This allows for more complex transactional logic where inner operations can be grouped separately but still fall under a larger transactional scope.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ndb.transaction((tx) => {\n  tx.insert(users).values(newUser).run();\n  tx.transaction((tx2) => {\n    tx2.update(users).set({ name: 'Mr. Dan' }).where(eq(users.name, 'Dan')).run();\n    tx2.delete(users).where(eq(users.name, 'Dan')).run();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Run drizzle-kit export command (Bash)\nDESCRIPTION: This command executes the `drizzle-kit export` command using `npx`.  It translates the Drizzle schema defined in the project into SQL DDL statements and outputs them to the console. The `--sql` flag explicitly specifies SQL output, though it's the default.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.30.1.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx drizzle-kit export\n```\n\n----------------------------------------\n\nTITLE: MySQL Seeding Usage - Typescript\nDESCRIPTION: This snippet demonstrates how to seed the MySQL table. The result of the seeding will be affected by the generator changes.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// index.ts\n...\n// this will be affected with new changes\nawait seed(db, {table})\n```\n\n----------------------------------------\n\nTITLE: Updating JSON column, handling primitives\nDESCRIPTION: This SQL query updates a JSON column in a PostgreSQL table. It uses a CASE statement to conditionally convert the column's value to JSON only if the value is a JSON object or array (determined by checking if the string representation starts with '{' or '['). Otherwise, it leaves the original value unchanged. This avoids errors when the column contains primitive stringified values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.33.0.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nUPDATE table_name\nSET json_column = CASE\n    -- Convert to JSON if it is a valid JSON object or array\n    WHEN json_column #>> '{}' LIKE '{%' OR json_column #>> '{}' LIKE '[%' THEN\n        (json_column #>> '{}')::json\n    ELSE\n        json_column\nEND\nWHERE json_column IS NOT NULL;\n```\n\n----------------------------------------\n\nTITLE: Defining SingleStore Table and Schema with Drizzle ORM\nDESCRIPTION: This code defines a SingleStore table named 'users' with columns id, name, and age using Drizzle ORM's `singlestoreTable` function. It then creates a Zod schema for selecting data from the 'users' table using `createSelectSchema`. The code demonstrates a scenario where selecting only specific columns leads to parsing errors if the schema expects all columns.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-zod/0.6.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { singlestoreTable, text, int } from 'drizzle-orm/singlestore-core';\nimport { createSelectSchema } from 'drizzle-zod';\n\nconst users = singlestoreTable('users', {\n  id: int().primaryKey(),\n  name: text().notNull(),\n  age: int().notNull()\n});\n\nconst userSelectSchema = createSelectSchema(users);\nconst rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);\nconst parsed: { id: number; name: string; age: number } = userSelectSchema.parse(rows[0]); // Error: `age` is not returned in the above query\n\nconst rows = await db.select().from(users).limit(1);\nconst parsed: { id: number; name: string; age: number } = userSelectSchema.parse(rows[0]); // Will parse successfully\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Generate with Glob Patterns for Schema Path (CLI)\nDESCRIPTION: This bash command uses Drizzle Kit to generate migrations from a schema defined using glob patterns for the schema path. It specifies the output directory for migrations and the schema files using glob patterns to include multiple files. This simplifies the process of generating migrations for large projects with multiple schema files.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndrizzle-kit generate:pg --out ./migrations --schema ./core/**/*.ts ./database/schema.ts\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: Count Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `count` aggregate function in Drizzle ORM. It showcases both the direct usage of the `count()` helper and its equivalent using the `sql` template literal, emphasizing the need for `.mapWith(Number)` for type safety when using the `sql` template.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: count() }).from(users);\nawait db.select({ value: count(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`count('*'))`.mapWith(Number) \n}).from(users);\nawait db.select({ \n  value: sql`count(${users.id})`.mapWith(Number) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: Running Drizzle migration generation\nDESCRIPTION: This command executes the npm script `generate` which utilizes Drizzle Kit to create migration files based on the schema. It's essential to run this whenever the schema is modified to keep the database in sync.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/cloudflare-d1/README.md#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\nnpm run generate\n```\n\n----------------------------------------\n\nTITLE: Defining a PostgreSQL CITEXT Data Type\nDESCRIPTION: This code defines a custom `citext` data type for PostgreSQL, which is case-insensitive text. It includes the `PgCITextBuilder` and `PgCIText` classes and a helper function.  The example highlights the structure needed to add custom data types utilizing extensions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport class PgCITextBuilder<TData extends string = string> extends PgColumnBuilder<\n  PgColumnBuilderHKT,\n  ColumnBuilderConfig<{ data: TData; driverParam: string }>\n> {\n  protected $pgColumnBuilderBrand: string = 'PgCITextBuilder';\n  \n  build<TTableName extends string>(table: AnyPgTable<{ name: TTableName }>): PgCIText<TTableName, TData> {\n    return new PgCIText(table, this.config);\n  }\n}\n\nexport class PgCIText<TTableName extends string, TData extends string>\n  extends PgColumn<PgColumnHKT, ColumnConfig<{ tableName: TTableName; data: TData; driverParam: string }>>\n{\n  \n\n  constructor(table: AnyPgTable<{ name: TTableName }>, builder: PgCITextBuilder<TData>['config']) {\n    super(table, builder);\n  }\n\n  getSQLType(): string {\n    return 'citext';\n  }\n}\n\nexport function citext<T extends string = string>(name: string): PgCITextBuilder<T> {\n  return new PgCITextBuilder(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting Raw SQL Expressions with Drizzle ORM (TypeScript)\nDESCRIPTION: Shows how to select raw SQL expressions using the `sql` template literal in Drizzle ORM. This allows incorporating custom SQL logic into queries. Requires Drizzle ORM setup and a database connection.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.23.0.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// select current_date + s.a as dates from generate_series(0,14,7) as s(a);\nconst result = await db\n  .select({\n    dates: sql`current_date + s.a`,\n  })\n  .from(sql`generate_series(0,14,7) as s(a)`);\n```\n\n----------------------------------------\n\nTITLE: Using the CITEXT Data Type in a Table\nDESCRIPTION: This code shows how to use the custom `citext` data type in a table definition. It uses the `pgTable` function to define a table named 'table' with an `id` column and a `ciname` column of type `citext`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = pgTable('table', {\n  id: integer('id').primaryKey(),\n  ciname: citext('ciname')\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a table with SingleStore and Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define a table using SingleStore with Drizzle ORM. It imports necessary modules and defines a `usersTable` schema with various columns and constraints. It also shows how to instantiate the Drizzle database object.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.37.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { int, singlestoreTable, varchar } from 'drizzle-orm/singlestore-core';\nimport { drizzle } from 'drizzle-orm/singlestore';\n\nexport const usersTable = singlestoreTable('users_table', {\n  id: int().primaryKey(),\n  name: varchar({ length: 255 }).notNull(),\n  age: int().notNull(),\n  email: varchar({ length: 255 }).notNull().unique(),\n});\n\n...\n\nconst db = drizzle(process.env.DATABASE_URL!);\n\ndb.select()...\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for UPDATE ... FROM with alias\nDESCRIPTION: This SQL code is generated from the TypeScript code which uses alias. It shows how the alias is applied in the `FROM` clause of the `UPDATE` statement, and is used in the `SET` clause as well.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.3.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nupdate \"users\" set \"city_id\" = \"c\".\"id\" \nfrom \"cities\" \"c\"\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Generated Columns (tsvector)\nDESCRIPTION: This code snippet shows how to define a generated column of type `tsvector` in a PostgreSQL table. It utilizes a custom type definition for `tsvector` and generates the column based on the `content` column using the `to_tsvector` function.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SQL, sql } from \"drizzle-orm\";\nimport { customType, index, integer, pgTable, text } from \"drizzle-orm/pg-core\";\n\nconst tsVector = customType<{ data: string }>({{\n  dataType() {{\n    return \"tsvector\";\n  }},\n}});\n\nexport const test = pgTable(\n  \"test\",\n  {{\n    id: integer(\"id\").primaryKey().generatedAlwaysAsIdentity(),\n    content: text(\"content\"),\n    contentSearch: tsVector(\"content_search\", {{\n      dimensions: 3,\n    }}).generatedAlwaysAs(\n      (): SQL => sql`to_tsvector('english', ${{test.content}})`\n    ),\n  }},\n  (t) => ({{\n    idx: index(\"idx_content_search\").using(\"gin\", t.contentSearch),\n  }})\n);\n\n```\n\n----------------------------------------\n\nTITLE: Project Setup and Management Commands\nDESCRIPTION: These bash commands install project dependencies, run the application locally, generate SQL migrations, and apply migrations to the remote database. `npm i` installs the dependencies, `npm start` runs the application locally, `npm run generate` generates SQL migrations based on the schema, and `npm run migrate` applies these migrations to the remote Neon database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/neon-cloudflare/readme.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm i\n\n## run locally\nnpm start\n\n## generate SQL migrations for schema.ts\nnpm run generate\n\n## apply migrations to remote database\nnpm run migrate\n```\n\n----------------------------------------\n\nTITLE: Printing SQL Query in SQLite\nDESCRIPTION: This example shows how to print the generated SQL query and parameters of a Drizzle ORM query. This can be useful for debugging and understanding the SQL that Drizzle ORM is generating.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst query = db\n  .select({ id: users.id, name: users.name })\n  .from(users)\n  .groupBy(users.id)\n  .toSQL();\n// query:\n{\n  sql: 'select \\'id\\', \\'name\\' from \\'users\\' group by \\'users\\'.\\'id\\'',\n  params: [],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Database Schema with Drizzle Relations (PostgreSQL)\nDESCRIPTION: This code snippet defines a PostgreSQL database schema using Drizzle ORM, including table definitions and relations. It establishes a one-to-many relationship between `users` and `posts` tables. The schema includes `users` and `posts` tables with primary keys and foreign key constraints using the `relations` function to define the relationship between the two tables.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.3.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// schema.ts\nimport { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';\nimport { relations } from 'drizzle-orm';\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\nexport const usersRelations = relations(users, ({ many }) => ({\n  posts: many(posts),\n}));\nexport const posts = pgTable('posts', {\n  id: serial('id').primaryKey(),\n  content: text('content').notNull(),\n  authorId: integer('author_id').notNull(),\n});\nexport const postsRelations = relations(posts, ({ one }) => ({\n  author: one(users, { fields: [posts.authorId], references: [users.id] }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Using $count API as a Subquery in Drizzle ORM in TypeScript\nDESCRIPTION: This code demonstrates how to use the `$count` API as a subquery within a Drizzle ORM select statement. It calculates the `postsCount` for each user by counting the number of posts associated with that user based on `authorId`. Requires the `users` and `posts` table definitions and the `eq` operator to be available.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = await db.select({\n    ...users,\n    postsCount: db.$count(posts, eq(posts.authorId, users.id))\n});\n\nconst users = await db.query.users.findMany({\n    extras: {\n        postsCount: db.$count(posts, eq(posts.authorId, users.id))\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Array Operators Usage\nDESCRIPTION: Demonstrates how to use the new PostgreSQL array operators (`arrayContains`, `arrayContained`, `arrayOverlaps`) in Drizzle ORM. These operators allow filtering based on array relationships in PostgreSQL.  Requires a Drizzle database instance, relevant table definitions, and the array operator functions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.6.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst contains = await db.select({ id: posts.id }).from(posts)\n\t.where(arrayContains(posts.tags, ['Typescript', 'ORM']));\n\nconst contained = await db.select({ id: posts.id }).from(posts)\n\t.where(arrayContained(posts.tags, ['Typescript', 'ORM']));\n\nconst overlaps = await db.select({ id: posts.id }).from(posts)\n\t.where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']));\n\nconst withSubQuery = await db.select({ id: posts.id }).from(posts)\n\t.where(arrayContains(\n\t\tposts.tags,\n\t\tdb.select({ tags: posts.tags }).from(posts).where(eq(posts.id, 1)),\n\t));\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle Kit with Supabase Migration Prefix\nDESCRIPTION: This snippet demonstrates how to configure Drizzle Kit to use the 'supabase' migration file prefix. This results in migration file names in the format `20240627123900_name.sql`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {{ defineConfig }} from \"drizzle-kit\";\n\nexport default defineConfig({{\n  dialect: \"postgresql\",\n  migrations: {{\n    prefix: 'supabase'\n  }}\n}});\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Query Logging Destination in SQLite\nDESCRIPTION: This snippet shows how to customize the destination of Drizzle ORM's query logs by creating a `DefaultLogger` instance and providing a custom `writer` to it. This allows you to log queries to a file, console, or other destination.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DefaultLogger, LogWriter } from 'drizzle-orm/logger';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\n\nclass MyLogWriter implements LogWriter {\n  write(message: string) {\n    // Write to file, console, etc.\n  }\n}\n\nconst logger = new DefaultLogger({ writer: new MyLogWriter() });\n\nconst db = drizzle(sqlite, { logger });\n```\n\n----------------------------------------\n\nTITLE: Install ESLint Drizzle Plugin\nDESCRIPTION: This command installs version 0.2.3 of the ESLint plugin for Drizzle. This plugin helps enforce Drizzle ORM best practices in your code.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nnpm i eslint-plugin-drizzle@0.2.3\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle Kit with pglite Driver (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to configure Drizzle Kit to use the pglite driver. It defines the dialect as 'postgresql' and specifies 'pglite' as the driver. The database credentials include the URL for the local pglite database file. This configuration enables using all drizzle-kit commands, including Drizzle Studio, with pglite.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.24.2.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"postgresql\",\n  driver: \"pglite\",\n  schema: \"./schema.ts\",\n  dbCredentials: {\n    url: \"local-pg.db\",\n  },\n  verbose: true,\n  strict: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Inserting Data - SQLite\nDESCRIPTION: Demonstrates how to insert data into a table using Drizzle ORM with SQLite, including defining types for new records and returning inserted data.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';\nimport { InferModel } from 'drizzle-orm';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\nimport Database from 'better-sqlite3';\n\nconst sqlite = new Database('sqlite.db');\nconst db = drizzle(sqlite);\n\nconst users = sqliteTable('users', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n  createdAt: integer('created_at', { mode: 'timestamp' }),\n});\n\ntype NewUser = InferModel<typeof users, \"insert\">;\n\nconst newUser: NewUser = {\n  name: 'Andrew',\n  createdAt: new Date(),\n};\n\ndb.insert(users).values(newUser).run();\n\nconst insertedUsers/*: NewUser[]*/ = db.insert(users).values(newUser).returning().all();\n\nconst insertedUsersIds/*: { insertedId: number }[]*/ = db.insert(users)\n  .values(newUser)\n  .returning({ insertedId: users.id })\n  .all();\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL with Strings in Drizzle ORM in TypeScript\nDESCRIPTION: This snippet demonstrates the new ability to execute raw SQL queries in Drizzle ORM using a plain string instead of a template literal. It provides a simplified way to execute raw SQL, making the code more concise.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\ndb.execute('select * from users')\n```\n\n----------------------------------------\n\nTITLE: Using overridingSystemValue() in insert\nDESCRIPTION: This code shows how to force your own values for `GENERATED ALWAYS AS IDENTITY` columns using `overridingSystemValue()` in an insert statement.  This can be useful when you want to manually specify values for identity columns.  Requires `db` and `identityColumnsTable` to be defined elsewhere.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.4.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.insert(identityColumnsTable).overridingSystemValue().values([\n  { alwaysAsIdentity: 2 },\n]);\n```\n\n----------------------------------------\n\nTITLE: Drizzle Configuration (drizzle.config.ts)\nDESCRIPTION: This TypeScript snippet shows the contents of a `drizzle.config.ts` file.  This configuration file tells Drizzle Kit where to find your schema and where to output the migration files, and what driver to use.  It configures Drizzle Kit for Expo SQLite.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Config } from 'drizzle-kit';\n\nexport default {\n\tschema: './db/schema.ts',\n\tout: './drizzle',\n\tdriver: 'expo',\n} satisfies Config;\n```\n\n----------------------------------------\n\nTITLE: Creating Table with Supabase Role Policy (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a table and define a policy that uses the `serviceRole` from the `drizzle-orm/supabase` import.  The policy is defined on the `users` table and restricts insert operations.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.27.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sql } from 'drizzle-orm';\nimport { serviceRole } from 'drizzle-orm/supabase';\nimport { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';\n\nexport const admin = pgRole('admin');\n\nexport const users = pgTable('users', {\n\tid: integer(),\n}, (t) => [\n\tpgPolicy(`policy-insert`, {\n\t\tfor: 'insert',\n\t\tto: serviceRole,\n\t\twithCheck: sql`false`,\n\t}),\n]);\n```\n\n----------------------------------------\n\nTITLE: Using Standalone Query Builder in Drizzle ORM (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the standalone query builder in Drizzle ORM. It initializes the query builder, constructs a SELECT query with a WHERE clause, and extracts the SQL query and parameters. This feature allows building SQL queries without a database connection.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.22.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { queryBuilder as qb } from 'drizzle-orm/pg-core';\n\nconst query = qb.select().from(users).where(eq(users.name, 'Dan'));\nconst { sql, params } = query.toSQL();\n```\n\n----------------------------------------\n\nTITLE: MySQL Proxy Server Implementation - TypeScript\nDESCRIPTION: This snippet presents an example of a MySQL proxy server implementation using Express.js and the `mysql2/promise` library. It defines endpoints for handling database queries (`/query`) and migrations (`/migrate`), forwarding requests to a MySQL database, and managing transactions for migrations. It also includes type casting for TIMESTAMP, DATETIME and DATE data.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/mysql-proxy/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as mysql from 'mysql2/promise';\nimport express from 'express';\n\nconst app = express();\napp.use(express.json());\nconst port = 3000;\n\nconst main = async () => {\nconst connection = await mysql.createConnection('mysql://root:mysql@127.0.0.1:5432/drizzle');\n\napp.post('/query', async (req, res) => {\n\tconst { sql: sqlBody, params, method } = req.body;\n\n\tif (method === 'all') {\n\t\ttry {\n            const result = await connection.query({\n                sql: sqlBody,\n                values: params,\n                rowsAsArray: true,\n                typeCast: function(field: any, next: any) {\n                    if (field.type === 'TIMESTAMP' || field.type === 'DATETIME' || field.type === 'DATE') {\n                        return field.string();\n                    }\n                    return next();\n                },\n            });\n\t\t\tres.send(result[0]);\n\t\t} catch (e: any) {\n\t\t\tres.status(500).json({ error: e });\n\t\t}\n\t} else if (method === 'execute') {\n\t\ttry {\n            const result = await connection.query({\n                sql: sqlBody,\n                values: params,\n                typeCast: function(field: any, next: any) {\n                    if (field.type === 'TIMESTAMP' || field.type === 'DATETIME' || field.type === 'DATE') {\n                        return field.string();\n                    }\n                    return next();\n                },\n            });\n\n\t\t\tres.send(result);\n\t\t} catch (e: any) {\n\t\t\tres.status(500).json({ error: e });\n\t\t}\n\t} else {\n\t\tres.status(500).json({ error: 'Unknown method value' });\n\t}\n});\n\napp.post('/migrate', async (req, res) => {\n\tconst { queries } = req.body;\n\n    await connection.query('BEGIN');\n    try {\n        for (const query of queries) {\n            await connection.query(query);\n        }\n        await connection.query('COMMIT');\n    } catch {\n        await connection.query('ROLLBACK');\n    }\n\n\tres.send({});\n});\n\napp.listen(port, () => {\n\tconsole.log(`Example app listening on port ${port}`);\n});\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Using .$withAuth() API for Neon HTTP driver\nDESCRIPTION: This code shows how to use the `.$withAuth()` API to send an authentication token with a query. It demonstrates its usage with both `select` and `update` queries.  Requires `db` and `usersTable` to be defined elsewhere. `eq` also needs to be imported from drizzle.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.4.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst token = 'HdncFj1Nm'\n\nawait db.$withAuth(token).select().from(usersTable);\nawait db.$withAuth(token).update(usersTable).set({ name: 'CHANGED' }).where(eq(usersTable.name, 'TARGET'))\n```\n\n----------------------------------------\n\nTITLE: Seeding with Version 1 after Interval Change - Typescript\nDESCRIPTION: This snippet seeds the database schema while setting `version` to '1'.  It switches to the old version of the generator that can cause errors on the seeding process if the interval data is not handled properly.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { version: '1' });\n```\n\n----------------------------------------\n\nTITLE: Seeding Database with Users Table (Drizzle ORM)\nDESCRIPTION: This code snippet demonstrates how to define a `users` table using `drizzle-orm` and then seed it with data using the `drizzle-seed` package.  It imports necessary modules from `drizzle-orm` and `drizzle-seed`, defines the table schema, initializes the database connection, and calls the `seed` function. The `DATABASE_URL` environment variable is required.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, integer, text } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { seed } from \"drizzle-seed\";\n\nconst users = pgTable(\"users\", {\n  id: integer().primaryKey(),\n  name: text().notNull(),\n});\n\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await seed(db, { users });\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: Min Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `min` aggregate function in Drizzle ORM. It shows the direct usage of the `min()` helper and its equivalent using the `sql` template literal, emphasizing the `.mapWith` call to match the type of users.id.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: min(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`min(${users.id})`.mapWith(users.id) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: ESLint Plugin: Recommended Config\nDESCRIPTION: Shows how to extend the ESLint configuration with the `recommended` config provided by the `eslint-plugin-drizzle`.  Currently, this is equivalent to the `all` config.  It also requires configuring the parser and plugins.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nroot: true\nextends:\n  - \"plugin:drizzle/recommended\"\nparser: '@typescript-eslint/parser'\nparserOptions:\n  project: './tsconfig.json'\nplugins:\n  - drizzle\n```\n\n----------------------------------------\n\nTITLE: Create Update Schema for Tables - Typescript\nDESCRIPTION: This example illustrates the usage of `createUpdateSchema` with `drizzle-typebox` for defining schemas for updating PostgreSQL tables. It imports necessary modules from `drizzle-orm`, `drizzle-typebox` and `@sinclair/typebox/value`. The code shows how to handle generated columns and successfully parse update objects.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-typebox/0.2.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, text, integer } from 'drizzle-orm/pg-core';\nimport { createUpdateSchema } from 'drizzle-typebox';\nimport { Value } from '@sinclair/typebox/value';\n\nconst users = pgTable('users', {\n  id: integer().generatedAlwaysAsIdentity().primaryKey(),\n  name: text().notNull(),\n  age: integer().notNull()\n});\n\nconst userUpdateSchema = createUpdateSchema(users);\n\nconst user = { id: 5, name: 'John' };\nconst parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user); // Error: `id` is a generated column, it can't be updated\n\nconst user = { age: 35 };\nconst parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user); // Will parse successfully\nawait db.update(users).set(parsed).where(eq(users.name, 'Jane'));\n```\n\n----------------------------------------\n\nTITLE: Using Custom Types in a Postgres Table\nDESCRIPTION: This snippet demonstrates how to use the custom data types defined previously in a PostgreSQL table schema using `pgTable` from Drizzle ORM. It creates a 'users' table with columns using the custom Serial, Text, Boolean, Jsonb, and Timestamp types.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst usersTable = pgTable('users', {\n  id: customSerial('id').primaryKey(),\n  name: customText('name').notNull(),\n  verified: customBoolean('verified').notNull().default(false),\n  jsonb: customJsonb<string[]>('jsonb'),\n  createdAt: customTimestamp('created_at', { withTimezone: true }).notNull()\n    .default(sql`now()`),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Subqueries Before Improvement (TypeScript)\nDESCRIPTION: This snippet showcases the old syntax for creating subqueries using the `WITH ... SELECT` statement in Drizzle ORM. It demonstrates how to define a subquery, prepare it with a name, and then use it in a main query. The `prepareWithSubquery` method is used to associate the subquery with a name.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.22.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst regionalSales = db\n  .select({\n    region: orders.region,\n    totalSales: sql`sum(${orders.amount})`.as<number>('total_sales'),\n})\n.from(orders)\n.groupBy(orders.region)\n.prepareWithSubquery('regional_sales');\n\nawait db.with(regionalSales).select(...).from(...);\n```\n\n----------------------------------------\n\nTITLE: Running Drizzle Studio\nDESCRIPTION: This command starts the Drizzle Studio web UI, which provides a visual interface for interacting with the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/better-sqlite3/readme.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run studio\n```\n\n----------------------------------------\n\nTITLE: Selecting all posts excluding column content\nDESCRIPTION: This code snippet demonstrates how to select all posts excluding `content` column using Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst posts = await db.query.posts.findMany({\n\tcolumns: {\n\t\tcontent: false,\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: Inserting Rows with Default Values\nDESCRIPTION: This code snippet shows how to insert rows with default values for all columns in Drizzle ORM. By providing an empty object or an array of empty objects to the `values()` method, Drizzle will automatically insert the default values defined in the schema for each column.  This is useful for creating new records with predefined initial values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.0.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Insert 1 row with all defaults\nawait db.insert(usersTable).values({});\n\n// Insert 2 rows with all defaults\nawait db.insert(usersTable).values([{}, {}]);\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for Check Constraint (PostgreSQL)\nDESCRIPTION: This SQL code snippet shows the generated SQL for the 'users' table with the 'age_check' constraint as defined in the previous TypeScript code. It demonstrates how Drizzle Kit translates the TypeScript definition into a PostgreSQL table with a check constraint.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.26.0.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE IF NOT EXISTS \"users\" (\n  \"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n  \"username\" text NOT NULL,\n  \"age\" integer,\n  CONSTRAINT \"age_check\" CHECK (\"users\".\"age\" > 21)\n);\n\n```\n\n----------------------------------------\n\nTITLE: Deprecated SQLite migration comments\nDESCRIPTION: This SQL snippet demonstrates the comments that were previously generated in SQLite migrations, which are now replaced with actual SQL statements.  These comments indicated manual intervention was necessary for tasks such as altering column types.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\n      '/*\\n SQLite does not support \"Changing existing column type\" out of the box, we do not generate automatic migration for that, so it has to be done manually'\n      + '\\n Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php'\n      + '\\n                  https://www.sqlite.org/lang_altertable.html'\n      + '\\n                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3'\n      + \"\\n\\n Due to that we don't generate migration automatically and it has to be done manually\"\n      + '\\n*/'\n```\n\n----------------------------------------\n\nTITLE: Connecting to SQLite with Bun SQLite - TypeScript\nDESCRIPTION: This code demonstrates connecting to a SQLite database using the Bun SQLite connector with Drizzle ORM. It imports necessary modules, initializes the database connection, and then queries all users from the 'users' table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// bun js embedded sqlite connector\nimport { drizzle, BunSQLiteDatabase } from 'drizzle-orm/bun-sqlite';\nimport { Database } from 'bun:sqlite';\n\nconst sqlite = new Database('nw.sqlite');\nconst db/*: BunSQLiteDatabase*/ = drizzle(sqlite);\nconst result = db.select().from(users).all()\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL with Templates (Old Method) in Drizzle ORM in TypeScript\nDESCRIPTION: This snippet shows the previous approach to executing raw SQL queries in Drizzle ORM using SQL template literals.  It requires importing `sql` from `drizzle-orm` and constructing the query using template strings.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sql } from 'drizzle-orm'\n\ndb.execute(sql`select * from ${users}`);\n// or\ndb.execute(sql.raw(`select * from ${users}`));\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle Kit for SingleStore\nDESCRIPTION: This code snippet configures Drizzle Kit to use the SingleStore dialect. It specifies the output directory for generated files, the schema file, and the database connection URL, which is read from the environment variables. This configuration allows Drizzle Kit to generate database schema and migrations compatible with SingleStore.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.29.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport 'dotenv/config';\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  dialect: 'singlestore',\n  out: './drizzle',\n  schema: './src/db/schema.ts',\n  dbCredentials: {\n    url: process.env.DATABASE_URL!,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining MySQL Generated Columns\nDESCRIPTION: This code snippet shows how to define generated columns in a MySQL table, specifying the `mode` as either `stored` or `virtual`. The `generatedName` and `generatedName1` columns are generated based on the `name` column of another table in the `schema2` schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = mysqlTable(\"users\", {{\n  id: int(\"id\"),\n  id2: int(\"id2\"),\n  name: text(\"name\"),\n  generatedName: text(\"gen_name\").generatedAlwaysAs(\n    (): SQL => sql`${{schema2.users.name}} || 'hello'`,\n    {{ mode: \"stored\" }}\n  ),\n  generatedName1: text(\"gen_name1\").generatedAlwaysAs(\n    (): SQL => sql`${{schema2.users.name}} || 'hello'`,\n    {{ mode: \"virtual\" }}\n  ),\n}}),\n```\n\n----------------------------------------\n\nTITLE: Using MySQL Enums in Table Schema\nDESCRIPTION: This example demonstrates how to incorporate the new MySQL enum initialization within a table schema definition using Drizzle ORM. It shows creating enum columns with varying configurations such as not null and default values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-mysql/0.15.1.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst tableWithEnums = mysqlTable('enums_test_case', {\n\tid: serial('id').primaryKey(),\n\tenum1: mysqlEnum('enum1', ['a', 'b', 'c']).notNull(),\n\tenum2: mysqlEnum('enum2', ['a', 'b', 'c']).default('a'),\n\tenum3: mysqlEnum('enum3', ['a', 'b', 'c']).notNull().default('b'),\n});\n```\n\n----------------------------------------\n\nTITLE: Using Migrations with Expo SQLite\nDESCRIPTION: This TypeScript/JSX snippet demonstrates how to use migrations with Expo SQLite.  It imports the migration files, and then uses the `useMigrations` hook from `drizzle-orm/expo-sqlite/migrator` to run the migrations when the application starts. A basic UI is rendered based on the migration state.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { drizzle } from \"drizzle-orm/expo-sqlite\";\nimport { openDatabaseSync } from \"expo-sqlite/next\";\nimport { useMigrations } from 'drizzle-orm/expo-sqlite/migrator';\nimport migrations from './drizzle/migrations';\n\nconst expoDb = openDatabaseSync(\"db.db\");\n\nconst db = drizzle(expoDb);\n\nexport default function App() {\n    const { success, error } = useMigrations(db, migrations);\n\n    if (error) {\n        return (\n            <View>\n                <Text>Migration error: {error.message}</Text>\n            </View>\n        );\n    }\n\n    if (!success) {\n        return (\n            <View>\n                <Text>Migration is in progress...</Text>\n            </View>\n        );\n    }\n\n    return ...your application component;\n}\n```\n\n----------------------------------------\n\nTITLE: Install Expo SQLite Driver\nDESCRIPTION: This command installs the necessary packages for using the Expo SQLite driver with Drizzle ORM. It installs both `drizzle-orm` and the `expo-sqlite` package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install drizzle-orm expo-sqlite@next\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Sequences in Custom Schema\nDESCRIPTION: This code snippet illustrates how to define a PostgreSQL sequence within a custom schema using `pgSchema`. The `customSchema.sequence()` function is used to create the sequence within the specified schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Sequence in custom schema\nexport const customSchema = pgSchema('custom_schema');\n\nexport const customSequence = customSchema.sequence(\"name\");\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: AvgDistinct Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `avgDistinct` aggregate function in Drizzle ORM. It presents the direct usage of the `avgDistinct()` helper and its equivalent using the `sql` template literal, highlighting the use of `.mapWith(String)` to ensure proper string handling of the returned value.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: avgDistinct(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`avg(distinct ${users.id})`.mapWith(String) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: Setting the Seed Value in Drizzle Seed with TypeScript\nDESCRIPTION: This code snippet shows how to use the `seed` option in `drizzle-seed` to generate a specific set of values for all subsequent runs. Specifying a number in the `seed` option allows for the generation of a unique and reproducible set of values. Requires `drizzle-orm` and `drizzle-seed` to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-seed/README.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait seed(db, schema, { seed: 12345 });\n```\n\n----------------------------------------\n\nTITLE: Running Migrations with SQLite Proxy Driver\nDESCRIPTION: This snippet demonstrates how to run database migrations using the Drizzle ORM SQLite Proxy driver. It sends an array of SQL queries to a specified HTTP endpoint for execution. It handles potential errors by throwing an error, indicating that the proxy server cannot run migrations. It requires the axios library for making HTTP requests and the migrate function from drizzle-orm/sqlite-proxy/migrator.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/sqlite-proxy/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { migrate } from 'drizzle-orm/sqlite-proxy/migrator';\n\nawait migrate(db, async (queries) => {\n  try {\n    await axios.post('http://localhost:3000/migrate', { queries });\n  } catch (e) {\n    console.log(e);\n    throw Error('Proxy server cannot run migrations');\n  }\n}, { migrationsFolder: 'drizzle' });\n```\n\n----------------------------------------\n\nTITLE: Using Expo SQLite with Drizzle ORM\nDESCRIPTION: This TypeScript snippet demonstrates how to initialize and use the Expo SQLite driver with Drizzle ORM. It shows how to open a database using `expo-sqlite` and then pass it to the `drizzle` function to create a Drizzle database instance.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { drizzle } from \"drizzle-orm/expo-sqlite\";\nimport { openDatabaseSync } from \"expo-sqlite/next\";\n\nconst expoDb = openDatabaseSync(\"db.db\");\n\nconst db = drizzle(expoDb);\n\nawait db.select().from(...)...\n\n// or\n\ndb.select().from(...).then(...);\n\n// or\n\ndb.select().from(...).all();\n```\n\n----------------------------------------\n\nTITLE: Creating Subqueries After Improvement (TypeScript)\nDESCRIPTION: This snippet showcases the improved syntax for creating subqueries using the `WITH ... SELECT` statement in Drizzle ORM. It demonstrates a more SQL-like approach by using `$with` and `as` methods to define and name the subquery. This provides a cleaner and more intuitive way to create subqueries.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.22.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst regionalSales = db\n  .$with('regional_sales')\n  .as(\n    db\n      .select({\n        region: orders.region,\n        totalSales: sql<number>`sum(${orders.amount})`.as('total_sales'),\n      })\n      .from(orders)\n      .groupBy(orders.region),\n  );\n\nawait db.with(regionalSales).select(...).from(...);\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Array Column Definition - TypeScript\nDESCRIPTION: This code snippet demonstrates how to define a table with an array column in PostgreSQL using Drizzle ORM. It utilizes the `pgTable`, `integer`, `text`, and `varchar` functions from `drizzle-orm/pg-core` along with the `array()` method to create the `phone_numbers` column as an array of varchar values. The `drizzle` and `seed` imports prepare the code for database interaction and data seeding.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.3.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, integer, text, varchar } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { seed } from \"drizzle-seed\";\n\nconst users = pgTable(\"users\", {\n  id: integer().primaryKey(),\n  name: text().notNull(),\n  phone_numbers: varchar({ length: 256 }).array(),\n});\n```\n\n----------------------------------------\n\nTITLE: SQL Generation with Statement Breakpoints in Drizzle Kit\nDESCRIPTION: This SQL code shows how Drizzle Kit can generate SQL statements separated by `--> statement-breakpoint`. This is achieved using the `--breakpoints` option during SQL generation. This allows executing the SQL statements individually, which is useful for database drivers that don't support running multiple queries in one execution.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE `users` (\n  `id` int PRIMARY KEY NOT NULL,\n  `full_name` text NOT NULL\n);\n--> statement-breakpoint\nCREATE TABLE `table` (\n  `id` int PRIMARY KEY NOT NULL,\n  `phone` int\n);\n```\n\n----------------------------------------\n\nTITLE: Running Drizzle Kit from npm scripts\nDESCRIPTION: Executes the Drizzle Kit migration generation script defined in package.json using npm run. This command triggers the generation of SQL migrations based on the configured schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-kit/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpm run generate\n```\n\n----------------------------------------\n\nTITLE: SQL Aggregation: CountDistinct Example (Drizzle ORM)\nDESCRIPTION: Demonstrates how to use the `countDistinct` aggregate function in Drizzle ORM. It shows both the direct usage of the `countDistinct()` helper and its equivalent using the `sql` template literal.  The `.mapWith(Number)` call ensures the returned value is correctly typed as a number.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select({ value: countDistinct(users.id) }).from(users);\n\n// It's equivalent to writing\nawait db.select({ \n  value: sql`count(${users.id})`.mapWith(Number) \n}).from(users);\n```\n\n----------------------------------------\n\nTITLE: Enforce Delete with Where - Example 1\nDESCRIPTION: This TypeScript code demonstrates how the 'enforce-delete-with-where' rule is triggered when no `.where()` clause is used in a `.delete()` statement.  It shows an example of a custom class with a `delete` method and the Drizzle ORM's `delete` method, both of which would trigger the ESLint rule.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public delete() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will be triggered by ESLint Rule\nmyClassObj.delete()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.delete()\n```\n\n----------------------------------------\n\nTITLE: Get Table Columns Map - Drizzle ORM (TypeScript)\nDESCRIPTION: This code snippet shows how to use the `getTableColumns` function from `drizzle-orm/pg-core` to get a map of table columns. It imports `pgTable` and `getTableColumns`, defines a table with `id` and `name` columns, and then uses `getTableColumns` to retrieve the column map, which is type-annotated to show the expected structure.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/table-introspect-api.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, getTableColumns } from 'drizzle-orm/pg-core';\n\nconst table = pgTable('table', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n});\n\nconst columns/*: { id: ..., name: ... } */ = getTableColumns(table);\n```\n\n----------------------------------------\n\nTITLE: Defining Table with Index & Using IGNORE INDEX in Drizzle ORM\nDESCRIPTION: This code defines a `users` table with an index on the `name` column and uses the `IGNORE INDEX` hint in a select query. The `IGNORE INDEX` hint instructs the MySQL query optimizer to avoid using the specified index (`usersTableNameIndex`) for the query. This forces the optimizer to consider other indexes or perform a full table scan.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.38.2.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = mysqlTable('users', {\n  id: int('id').primaryKey(),\n  name: varchar('name', { length: 100 }).notNull(),\n}, () => [usersTableNameIndex]);\n\nconst usersTableNameIndex = index('users_name_index').on(users.name);\n\nawait db.select()\n  .from(users, { ignoreIndex: usersTableNameIndex })\n  .where(eq(users.name, 'David'));\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit `up` Command Usage\nDESCRIPTION: This bash command upgrades the Drizzle Kit migration folder structure. It supports specifying the dialect (`pg`, `mysql`, or `sqlite`) to ensure proper migration formatting. This is used when upgrading to Drizzle Kit 0.17.0 or later to migrate the existing migration folder structure.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndrizzle-kit up:<dialect> # dialects: `pg`, `mysql`, `sqlite`\n\n# example for pg\ndrizzle-kit up:pg\n```\n\n----------------------------------------\n\nTITLE: SQLite JSON Mode for Text\nDESCRIPTION: Illustrates how to define a table column with JSON mode for text in SQLite using Drizzle ORM. It allows storing and retrieving JSON data directly in a text column.  Requires the `sqliteTable` and `text` functions from Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.6.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst test = sqliteTable('test', {\n\tdataTyped: text('data_typed', { mode: 'json' }).$type<{ a: 1 }>().notNull(),\n});\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-update-with-where - Example Code 1\nDESCRIPTION: Example Typescript code showing the effect of `enforce-update-with-where` ESLint rule when `drizzleObjectName` is not defined. The ESLint rule will be triggered on both the custom class's `update` method and Drizzle's `update` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public update() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will be triggered by ESLint Rule\nmyClassObj.update()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.update()\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Array Column Seeding - TypeScript\nDESCRIPTION: This code snippet demonstrates basic data seeding for a table with an array column. It uses `drizzle-seed` to automatically generate data for the `users` table, including the array column. This will handle arrays of any dimension automatically.  It requires a database connection using `drizzle`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.3.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await seed(db, { users });\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Neon Serverless Environment Variables\nDESCRIPTION: These environment variables are required to connect to the Neon Serverless database. DATABASE_URL specifies the connection string, including the user, password, host, port, and database name. PROJECT_NAME is necessary for the postgres.js driver to run migrations and interact with the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/neon-cloudflare/readme.md#_snippet_1\n\nLANGUAGE: env\nCODE:\n```\nDATABASE_URL=postgres://user:password@localhost:5432/dbname\nPROJECT_NAME=shiny-fire-338756\n```\n\n----------------------------------------\n\nTITLE: MySQL SELECT Locking Clauses with Drizzle ORM\nDESCRIPTION: This code snippet showcases the usage of locking clauses such as 'FOR UPDATE' and 'FOR SHARE' with options in Drizzle ORM for MySQL. It includes options to skip locked rows ('skipLocked') and to not wait for locked rows ('noWait'). Requires the 'users' table defined elsewhere in the Drizzle ORM schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.20.3.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.select().from(users).for('update');\nawait db.select().from(users).for('share', { skipLocked: true });\nawait db.select().from(users).for('update', { noWait: true });\n```\n\n----------------------------------------\n\nTITLE: Refining Table with Interval Generator - Typescript\nDESCRIPTION: This snippet demonstrates using the `interval` generator within the `refine` method to define a table schema. It sets the `isUnique` option, highlighting the potential for issues with older versions of the generator, where different string representations of the same time interval could violate uniqueness constraints. The column is defined as column1.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, { table }).refine((f) => ({\n  table: {\n    columns: {\n      // this function usage will output different values with the same `seed` number from previous version\n      column1: f.interval({ isUnique: true }),\n    }\n  }\n}))\n```\n\n----------------------------------------\n\nTITLE: Connecting Drizzle ORM to Postgres.js\nDESCRIPTION: Establishes a connection to a Postgres database using the postgres.js driver and Drizzle ORM. It imports the necessary modules, creates a Postgres client, and then initializes Drizzle with the client.  The connection string is expected to be pre-defined.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/postgres-js/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/postgres-js';\nimport postgres from 'postgres';\n\nconst client = postgres(connectionString);\nconst db = drizzle(client);\n```\n\n----------------------------------------\n\nTITLE: Counting Entities with SQL in Drizzle ORM (Old Method) in TypeScript\nDESCRIPTION: This code demonstrates the previous method of counting entities in a table using a raw SQL query with Drizzle ORM. It uses `db.select` with an SQL template literal to count all rows from the `users` table. The result is then extracted from the returned array.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await db.select({ count: sql`count(*)` }).from(users);\nconst count = res[0].count;\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-update-with-where - Example Config 2\nDESCRIPTION: Example configuration for the `enforce-update-with-where` ESLint rule specifying `drizzleObjectName`. This limits the rule to only trigger on `update` calls originating from the specified object.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-update-with-where\": [\"error\", { \"drizzleObjectName\": [\"db\"] }],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Seeding without Version Parameter - Typescript\nDESCRIPTION: This code demonstrates how to seed the database without specifying a version. In this case, Drizzle ORM will use the latest generator versions by default.  No specific dependencies are required beyond the Drizzle ORM seeding functionality.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema);\n```\n\n----------------------------------------\n\nTITLE: Overriding Column Data Types using .$type() in Drizzle ORM (TypeScript)\nDESCRIPTION: Illustrates the new `$type()` method for column builders in Drizzle ORM. This allows overriding the data type of a column, replacing the optional generics on columns. Requires Drizzle ORM setup with a MySQL table defined.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.23.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Before\nconst test = mysqlTable('test', {\n  jsonField: json<Data>('json_field'),\n});\n\n// After\nconst test = mysqlTable('test', {\n  jsonField: json('json_field').$type<Data>(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Supabase Schema and Tables (TypeScript)\nDESCRIPTION: This snippet showcases how to define schemas and tables that exist in Supabase using Drizzle ORM. It uses `pgSchema` to define the `auth` and `realtime` schemas, and then defines tables within those schemas, such as `authUsers` and `realtimeMessages`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.27.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// drizzle-orm/supabase\n\nconst auth = pgSchema('auth');\nexport const authUsers = auth.table('users', {\n\tid: uuid().primaryKey().notNull(),\n});\n\nconst realtime = pgSchema('realtime');\nexport const realtimeMessages = realtime.table(\n\t'messages',\n\t{\n\t\tid: bigserial({ mode: 'bigint' }).primaryKey(),\n\t\ttopic: text().notNull(),\n\t\textension: text({\n\t\t\tenum: ['presence', 'broadcast', 'postgres_changes'],\n\t\t}).notNull(),\n\t},\n);\n\nexport const authUid = sql`(select auth.uid())`;\nexport const realtimeTopic = sql`realtime.topic()`;\n```\n\n----------------------------------------\n\nTITLE: SQLite Seeding Usage - Typescript\nDESCRIPTION: This snippet shows how to use the generated table schema to seed the database. Seeding will output a different result from older versions, because the generators have been upgraded.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// index.ts\n...\n// this will be affected with new changes\nawait seed(db, { table })\n```\n\n----------------------------------------\n\nTITLE: Performing Many-to-one Joins - SQLite\nDESCRIPTION: Illustrates how to perform a many-to-one join using Drizzle ORM with SQLite.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\n\nconst cities = sqliteTable('cities', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n});\n\nconst users = sqliteTable('users', {\n  id: integer('id').primaryKey(),\n  name: text('name'),\n  cityId: integer('city_id').references(() => cities.id)\n});\n\nconst db = drizzle(sqlite);\n\nconst result = db.select().from(cities).leftJoin(users, eq(cities.id, users.cityId)).all();\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with OP-SQLite driver in TypeScript\nDESCRIPTION: This code snippet demonstrates how to initialize Drizzle ORM with the OP-SQLite driver in a TypeScript environment. It imports the necessary modules from `@op-engineering/op-sqlite` and `drizzle-orm/op-sqlite`, opens an OP-SQLite database, and creates a Drizzle database instance using the opened database. Finally, it shows a simple database query.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { open } from '@op-engineering/op-sqlite';\nimport { drizzle } from 'drizzle-orm/op-sqlite';\n\nconst opsqlite = open({\n\tname: 'myDB',\n});\nconst db = drizzle(opsqlite);\n\nawait db.select().from(users);\n```\n\n----------------------------------------\n\nTITLE: SQLite Proxy Server Implementation (Express)\nDESCRIPTION: This snippet provides an example of implementing a SQLite proxy server using Express.js and better-sqlite3. It defines an HTTP endpoint that receives SQL queries and parameters, executes them against a SQLite database, and returns the results. It also includes a migration endpoint that executes a series of SQL queries within a transaction. The server listens on port 3000.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/sqlite-proxy/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport Database from 'better-sqlite3';\nimport express from 'express';\n\nconst app = express();\napp.use(express.json());\nconst port = 3000;\n\nconst db = new Database('./test.db');\n\napp.post('/query', (req, res) => {\n  const { sql: sqlBody, params, method } = req.body;\n\n  if (method === 'run') {\n    try {\n      const result = db.prepare(sqlBody).run(params);\n      res.send(result);\n    } catch (e: any) {\n      res.status(500).json({ error: e.message });\n    }\n  } else if (method === 'all' || method === 'values') {\n    try {\n      const rows = db.prepare(sqlBody).raw().all(params);\n      res.send(rows);\n    } catch (e: any) {\n      res.status(500).json({ error: e.message });\n    }\n  } else if (method === 'get') {\n    try {\n      const row = db.prepare(sqlBody).raw().get(params);\n      res.send(row);\n    } catch (e: any) {\n      res.status(500).json({ error: e.message });\n    }\n  } else {\n    res.status(500).json({ error: 'Unkown method value' });\n  }\n});\n\napp.post('/migrate', (req, res) => {\n  const { queries } = req.body;\n\n  db.exec('BEGIN');\n  try {\n    for (const query of queries) {\n      db.exec(query);\n    }\n\n    db.exec('COMMIT');\n  } catch (e: any) {\n    db.exec('ROLLBACK');\n  }\n\n  res.send({});\n});\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Config (TypeScript)\nDESCRIPTION: This code snippet shows an example of a Drizzle Kit configuration file in TypeScript.  It demonstrates how to define the schema location, connection string, output directory, and breakpoints settings.  The `satisfies Config` ensures type safety.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Config } from \"drizzle-kit\";\n\nexport default {\n  schema: \"\",\n  connectionString: process.env.DB_URL,\n  out: \"\",\n  breakpoints: true\n} satisfies Config;\n```\n\n----------------------------------------\n\nTITLE: Define Table with `inStock` column\nDESCRIPTION: This TypeScript code snippet defines a table `ingredients` using `drizzle-orm` with a column `inStock` using camelCase convention.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable } from \"drizzle-orm/pg-core\";\n\nexport const ingredients = pgTable(\"ingredients\", (t) => ({\n  id: t.uuid().defaultRandom().primaryKey(),\n  name: t.text().notNull(),\n  description: t.text(),\n  inStock: t.boolean().default(true),\n}));\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Logger in SQLite\nDESCRIPTION: This example demonstrates how to create a completely custom logger for Drizzle ORM by implementing the `Logger` interface. This allows you to have full control over how queries are logged, including the format of the logs and the information that is included.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Logger } from 'drizzle-orm/logger';\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\n\nclass MyLogger implements Logger {\n  logQuery(query: string, params: unknown[]): void {\n    console.log({ query, params });\n  }\n}\n\nconst db = drizzle(sqlite, { logger: new MyLogger() });\n```\n\n----------------------------------------\n\nTITLE: Defining Type Maps for Entities with Drizzle ORM (TypeScript)\nDESCRIPTION: Demonstrates how to access type maps for entities in Drizzle ORM using the special `_` property to infer column and model types. This allows developers to strongly type their database interactions. Requires Drizzle ORM setup with a MySQL table defined.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.23.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = mysqlTable('users', {\n  id: int('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\ntype UserFields = typeof users['_']['columns'];\ntype InsertUser = typeof users['_']['model']['insert'];\n```\n\n----------------------------------------\n\nTITLE: Conditionally Selecting Fields - SQLite\nDESCRIPTION: Shows how to conditionally select fields in a query based on a boolean parameter using Drizzle ORM with SQLite.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nfunction selectUsers(withName: boolean) {\n  return db\n    .select({\n      id: users.id,\n      ...(withName ? { name: users.name } : {}),\n    })\n    .from(users)\n    .all();\n}\n\nconst users = selectUsers(true);\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit `drop` Command Usage\nDESCRIPTION: This bash command allows rolling back migrations generated by Drizzle Kit. It provides an interactive selection to choose which migration to drop, simplifying the process of undoing unwanted migrations. Use with caution, only to drop migrations that haven't been applied to the production database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndrizzle-kit drop\n```\n\n----------------------------------------\n\nTITLE: Creating a Subquery with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to create a subquery in Drizzle ORM using the `select`, `from`, `groupBy`, and `subquery` methods. The subquery calculates the total count for each course category. The result is aliased as 'sq' and can be used as a table in subsequent queries.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.19.0.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst sq = db\n  .select({\n    categoryId: courseCategoriesTable.id,\n    category: courseCategoriesTable.name,\n    total: sql`count(${courseCategoriesTable.id})`.as<number>(),\n  })\n  .from(courseCategoriesTable)\n  .groupBy(courseCategoriesTable.id, courseCategoriesTable.name)\n  .subquery('sq');\n```\n\n----------------------------------------\n\nTITLE: Running Migrations with Postgres Proxy Driver\nDESCRIPTION: This snippet demonstrates how to run database migrations using the Drizzle ORM Postgres Proxy driver. It uses the `migrate` function and sends an array of SQL queries to a proxy server via an HTTP POST request. Error handling is implemented to catch exceptions during the migration process.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/pg-proxy/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { migrate } from 'drizzle-orm/pg-proxy/migrator';\n\nawait migrate(db, async (queries) => {\n  try {\n    await axios.post('http://localhost:3000/migrate', { queries });\n  } catch (e) {\n    console.log(e);\n    throw Error('Proxy server cannot run migrations');\n  }\n}, { migrationsFolder: 'drizzle' });\n```\n\n----------------------------------------\n\nTITLE: PGlite Driver Usage Example - TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the PGlite driver with Drizzle ORM. It initializes a PGlite client, connects it to Drizzle, and then executes a simple select query. PGlite is imported from '@electric-sql/pglite' and drizzle from 'drizzle-orm/pglite'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.6.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PGlite } from '@electric-sql/pglite';\nimport { drizzle } from 'drizzle-orm/pglite';\n\n// In-memory Postgres\nconst client = new PGlite();\nconst db = drizzle(client);\n\nawait db.select().from(users);\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (Old)\nDESCRIPTION: This TypeScript code demonstrates the original method of initializing a Drizzle client, which requires defining the client (e.g., `Pool` from `node-postgres`) and passing it to the `drizzle` function with optional configuration, such as a logger.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Pool({ url: '' });\ndrizzle(client, { logger: true });\n```\n\n----------------------------------------\n\nTITLE: Defining Table with $onUpdate Functionality in Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to use the `$onUpdateFn` and `$onUpdate` functions in Drizzle ORM to define dynamic update values for columns in a PostgreSQL table. When a row is updated, the provided function is called, and its returned value becomes the new column value. If no default value is provided, the function is also called during insertion.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.5.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst usersOnUpdate = pgTable('users_on_update', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n  updateCounter: integer('update_counter').default(sql`1`).$onUpdateFn(() => sql`update_counter + 1`),\n  updatedAt: timestamp('updated_at', { mode: 'date', precision: 3 }).$onUpdate(() => new Date()),\n  alwaysNull: text('always_null').$type<string | null>().$onUpdate(() => null),\n});\n```\n\n----------------------------------------\n\nTITLE: Running project commands\nDESCRIPTION: These commands are used to generate code, run database migrations, and start the development server for a Drizzle project using better-sqlite3.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/better-sqlite3/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run generate\nnpm run migrate\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript ESLint Support\nDESCRIPTION: This shell command shows how to install the necessary TypeScript ESLint packages for IDE support.  These packages enable ESLint to parse and lint TypeScript code, allowing for type-aware linting rules and error detection during development.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n[ npm | yarn | pnpm | bun ] install @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n----------------------------------------\n\nTITLE: Creating a View with an Existing Query Builder Instance in SQLite\nDESCRIPTION: This snippet shows creating a view using an existing query builder instance. This allows for reusing already defined queries when creating database views.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nimport { queryBuilder as qb } from 'drizzle-orm/sqlite-core';\n\nconst newYorkers = sqliteView('new_yorkers').as(qb.select().from(users2Table).where(eq(users2Table.cityId, 1)));\n```\n\n----------------------------------------\n\nTITLE: Drizzle config - Before Turso dialect change\nDESCRIPTION: This is an example of the `drizzle.config` file before the introduction of the turso dialect. It uses the sqlite dialect for both SQLite and Turso databases.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"sqlite\",\n  schema: \"./schema.ts\",\n  out: \"./drizzle\",\n  dbCredentials: {\n    url: \"database.db\",\n  },\n  breakpoints: true,\n  verbose: true,\n  strict: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Cloning Drizzle ORM repository - Bash\nDESCRIPTION: This snippet clones the Drizzle ORM repository from GitHub and navigates into the cloned directory. Requires Git to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/drizzle-team/drizzle-orm.git\ncd drizzle-orm\n```\n\n----------------------------------------\n\nTITLE: Implementing a PostgreSQL Proxy Driver with Drizzle ORM\nDESCRIPTION: This code demonstrates implementing a custom PostgreSQL proxy driver with Drizzle ORM.  It involves creating an HTTP driver to communicate with a PostgreSQL database through a remote server, handling queries and migrations. It requires `axios`, `drizzle-orm/expressions`, `drizzle-orm/pg-proxy`, and `drizzle-orm/pg-proxy/migrator`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { eq } from 'drizzle-orm/expressions';\nimport { drizzle } from 'drizzle-orm/pg-proxy';\nimport { migrate } from 'drizzle-orm/pg-proxy/migrator';\nimport { cities, users } from './schema';\n\nasync function main() {\n  const db = drizzle(async (sql, params, method) => {\n    try {\n      const rows = await axios.post(`${process.env.REMOTE_DRIVER}/query`, { sql, params, method });\n\n      return { rows: rows.data };\n    } catch (e: any) {\n      console.error('Error from pg proxy server:', e.response.data);\n      return { rows: [] };\n    }\n  });\n\n  await migrate(db, async (queries) => {\n    try {\n      await axios.post(`${process.env.REMOTE_DRIVER}/query`, { queries });\n    } catch (e) {\n      console.log(e);\n      throw new Error('Proxy server cannot run migrations');\n    }\n  }, { migrationsFolder: 'drizzle' });\n\n  const insertedCity = await db.insert(cities).values({ id: 1, name: 'name' }).returning();\n  const insertedUser = await db.insert(users).values({ id: 1, name: 'name', email: 'email', cityId: 1 });\n  const usersToCityResponse = await db.select().from(users).leftJoin(cities, eq(users.cityId, cities.id));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining `bigint` and `boolean` Columns in SQLite (TypeScript)\nDESCRIPTION: Demonstrates how to define `bigint` and `boolean` columns in an SQLite table using Drizzle ORM.  The `blob` and `integer` column types are used with the `mode` option to specify the data type. Requires the `sqliteTable` function from Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = sqliteTable('users', {\n  bigintCol: blob('bigint', { mode: 'bigint' }).notNull(),\n  boolCol: integer('bool', { mode: 'boolean' }).notNull(),\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Database Using Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to query the database using Drizzle ORM.  It shows how to initialize the database connection with the schema, and then uses `db.query.users.findMany()` to retrieve data.  Different ways of importing the schema are showcased.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as schema from './schema';\nimport { drizzle } from 'drizzle-orm/...';\n \nconst db = drizzle(client, { schema });\n \nawait db.query.users.findMany(...);\n```\n\n----------------------------------------\n\nTITLE: Configuring Relational Queries `mode` for `mysql2`\nDESCRIPTION: This code snippet demonstrates how to configure the `mode` option for relational queries when using the `mysql2` driver in Drizzle ORM. It shows how to specify either 'default' for regular MySQL databases or 'planetscale' when using PlanetScale.  The `mode` configuration is essential for ensuring compatibility with different MySQL environments.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/mysql2';\nimport mysql from 'mysql2/promise';\nimport * as schema from './schema';\n\nconst connection = await mysql.createConnection({\n  uri: process.env.PLANETSCALE_DATABASE_URL,\n});\n\nconst db = drizzle(connection, { schema, mode: 'planetscale' });\n```\n\n----------------------------------------\n\nTITLE: D1 Batch API Response Type Example\nDESCRIPTION: This code snippet shows the expected type definition for the `batchResponse` obtained from the D1 Batch API usage example.  It describes the structure of the array returned by the `db.batch` function, with each element corresponding to the result of each operation within the batch. The types shown include array of objects with ID, D1Result, and array of objects with user details.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ntype BatchResponse = [\n  {\n    id: number;\n  }[],\n  D1Result,\n  {\n    id: number;\n    name: string;\n    verified: number;\n    invitedBy: number | null;\n  }[],\n  {\n    id: number;\n    name: string;\n    verified: number;\n    invitedBy: number | null;\n  }[],\n  {\n    id: number;\n    invitedBy: number | null;\n  }[],\n];\n```\n\n----------------------------------------\n\nTITLE: ESLint Plugin: Basic Configuration\nDESCRIPTION: Shows a basic `.eslintrc.yml` configuration file for the Drizzle ESLint plugin.  It includes the parser, parserOptions, plugins, and rules sections necessary to enable the plugin and enforce specific rules.  In this case, it enforces that `delete` and `update` statements are used with a `.where()` clause.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nroot: true\nparser: '@typescript-eslint/parser'\nparserOptions:\n  project: './tsconfig.json'\nplugins:\n  - drizzle\nrules:\n  'drizzle/enforce-delete-with-where': \"error\"\n  'drizzle/enforce-update-with-where': \"error\"\n```\n\n----------------------------------------\n\nTITLE: Express Proxy Server Implementation for Drizzle ORM\nDESCRIPTION: This snippet provides an example of an Express server that acts as a proxy between Drizzle ORM and a PostgreSQL database. It handles SQL queries and migrations by forwarding requests to the database using the `pg` library. The server listens for incoming requests on port 3000.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/pg-proxy/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from 'pg';\nimport express from 'express';\n\nconst app = express();\napp.use(express.json());\nconst port = 3000;\n\nconst client = new Client('postgres://postgres:postgres@localhost:5432/postgres');\n\napp.post('/query', async (req, res) => {\n\tconst { sql: sqlBody, params, method } = req.body;\n\n\tif (method === 'all') {\n\t\ttry {\n            const result = await client.query({\n                text: sqlBody,\n                values: params,\n                rowMode: 'array',\n            });\n\t\t\tres.send(result.rows);\n\t\t} catch (e: any) {\n\t\t\tres.status(500).json({ error: e });\n\t\t}\n\t} else if (method === 'execute') {\n\t\ttry {\n            const result = await client.query({\n                text: sqlBody,\n                values: params,\n            });\n\n\t\t\tres.send(result.rows);\n\t\t} catch (e: any) {\n\t\t\tres.status(500).json({ error: e });\n\t\t}\n\t} else {\n\t\tres.status(500).json({ error: 'Unknown method value' });\n\t}\n});\n\napp.post('/migrate', async (req, res) => {\n\tconst { queries } = req.body;\n\n    await client.query('BEGIN');\n    try {\n        for (const query of queries) {\n            await client.query(query);\n        }\n        await client.query('COMMIT');\n    } catch {\n        await client.query('ROLLBACK');\n    }\n\n\tres.send({});\n});\n\napp.listen(port, () => {\n\tconsole.log(`Example app listening on port ${port}`);\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Xata with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to connect to a Xata database using Drizzle ORM's xata-http driver. It imports the drizzle function from 'drizzle-orm/xata-http' and the generated Xata client. The example initializes the database connection and executes a select query.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.4.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/xata-http';\nimport { getXataClient } from './xata'; // Generated client\n\nconst xata = getXataClient();\nconst db = drizzle(xata);\n\nconst result = await db.select().from(...);\n```\n\n----------------------------------------\n\nTITLE: Selecting from Subquery - SQLite\nDESCRIPTION: Demonstrates selecting from subqueries and using subqueries in joins using Drizzle ORM with SQLite.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst sq = db.select().from(users).where(eq(users.id, 42)).as('sq');\nconst result = db.select().from(sq).all();\n\nconst result = db.select().from(users).leftJoin(sq, eq(users.id, sq.id)).all();\n```\n\n----------------------------------------\n\nTITLE: Enforce Update with Where - Config 1\nDESCRIPTION: This JSON snippet shows an example configuration for the 'enforce-update-with-where' rule without the `drizzleObjectName` option.  This will cause the ESLint rule to trigger on any object with an `update` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-update-with-where\": [\"error\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating schema factory with extended Zod instance for Drizzle\nDESCRIPTION: This snippet demonstrates the usage of `createSchemaFactory` to create insert schemas with extended Zod instances, like `@hono/zod-openapi`. It allows for more advanced schema options, such as adding OpenAPI metadata to fields.  It requires importing `createSchemaFactory` from `drizzle-zod`, `pgTable`, `text`, and `integer` from `drizzle-orm/pg-core` and an extended Zod instance (e.g., `@hono/zod-openapi`).\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-zod/0.6.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, text, integer } from 'drizzle-orm/pg-core';\nimport { createSchemaFactory } from 'drizzle-zod';\nimport { z } from '@hono/zod-openapi'; // Extended Zod instance\n\nconst users = pgTable('users', {\n  id: integer().generatedAlwaysAsIdentity().primaryKey(),\n  name: text().notNull(),\n  age: integer().notNull()\n});\n\nconst { createInsertSchema } = createSchemaFactory({ zodInstance: z });\n\nconst userInsertSchema = createInsertSchema(users, {\n  // We can now use the extended instance\n  name: (schema) => schema.openapi({ example: 'John' })\n});\n```\n\n----------------------------------------\n\nTITLE: Installing eslint-plugin-drizzle\nDESCRIPTION: This shell command demonstrates how to install the eslint-plugin-drizzle package along with its eslint peer dependency using common package managers like npm, yarn, pnpm, or bun. It prepares the environment for using the Drizzle-specific ESLint rules.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n[ npm | yarn | pnpm | bun ] install eslint eslint-plugin-drizzle\n```\n\n----------------------------------------\n\nTITLE: SQLite Proxy with Batch Requests (TypeScript)\nDESCRIPTION: This snippet illustrates how to use Drizzle ORM with the SQLite Proxy driver, including setting up a batch callback function to handle multiple queries.  It includes the necessary imports and type definitions, and shows how to use `axios` to send the batch queries to a proxy server.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.5.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/sqlite-proxy';\n\ntype ResponseType = { rows: any[][] | any[] }[];\n\nconst db = drizzle(\n\tasync (sql, params, method) => {\n\t\t// single query logic\n\t},\n\t// new batch callback\n\tasync (\n\t\tqueries: {\n\t\t\tsql: string;\n\t\t\tparams: any[];\n\t\t\tmethod: 'all' | 'run' | 'get' | 'values';\n\t\t}[],\n\t) => {\n\t\ttry {\n\t\t\tconst result: ResponseType = await axios.post(\n\t\t\t\t'http://localhost:3000/batch',\n\t\t\t\t{ queries },\n\t\t\t);\n\n\t\t\treturn result;\n\t\t} catch (e: any) {\n\t\t\tconsole.error('Error from sqlite proxy server:', e);\n\t\t\tthrow e;\n\t\t}\n\t},\n);\n```\n\n----------------------------------------\n\nTITLE: ESLint Plugin: Installation Command\nDESCRIPTION: Commands to install the `eslint-plugin-drizzle` package along with its dependencies using `npm`, `yarn`, `pnpm` or `bun`. Includes commands for installing TypeScript support in the IDE.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n[ npm | yarn | pnpm | bun ] install eslint eslint-plugin-drizzle\n```\n\nLANGUAGE: shell\nCODE:\n```\n[ npm | yarn | pnpm | bun ] install @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with Postgres Proxy Driver (HTTP)\nDESCRIPTION: This snippet initializes a Drizzle ORM database instance using the Postgres Proxy driver. It defines an asynchronous function that makes HTTP POST requests to a proxy server to execute SQL queries. Error handling ensures that an empty array is returned in case of HTTP call failures.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/pg-proxy/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { drizzle } from 'drizzle-orm/pg-proxy';\n\nconst db = drizzle(async (sql, params, method) => {\n  try {\n    const rows = await axios.post('http://localhost:3000/query', {\n      sql,\n      params,\n      method,\n    });\n\n    return { rows: rows.data };\n  } catch (e: any) {\n    console.error('Error from pg proxy server: ', e.response.data);\n    return { rows: [] };\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Installing latest @libsql/client package\nDESCRIPTION: This command installs the latest version of the `@libsql/client` package, which is required for using the `migrate` function with Drizzle ORM. It is recommended to upgrade for other use cases as well.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @libsql/client@latest\n```\n\n----------------------------------------\n\nTITLE: Custom SQLite Proxy Driver with Axios and Drizzle ORM\nDESCRIPTION: This code snippet demonstrates a custom SQLite proxy driver implemented using Axios and Drizzle ORM. It intercepts SQL queries, sends them to a proxy server via HTTP POST, and returns the result rows.  It uses `axios` for making HTTP requests to the proxy server. The `drizzle` function from `drizzle-orm` is used to initialize the database connection with the custom driver.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.17.4.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Custom Proxy HTTP driver\n  const db = drizzle(async (sql, params, method) => {\n    try {\n      const rows = await axios.post('http://localhost:3000/query', { sql, params, method });\n\n      return { rows: rows.data };\n    } catch (e: any) {\n      console.error('Error from sqlite proxy server: ', e.response.data)\n      return { rows: [] };\n    }\n  });\n```\n\n----------------------------------------\n\nTITLE: Update Metro Configuration (metro.config.js)\nDESCRIPTION: This JavaScript snippet shows the changes needed to the `metro.config.js` file to support SQL files as source extensions. This allows Metro to recognize and bundle SQL files used in Drizzle Migrations.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst { getDefaultConfig } = require('expo/metro-config');\n\n/** @type {import('expo/metro-config').MetroConfig} */\nconst config = getDefaultConfig(__dirname);\n\n+config.resolver.sourceExts.push('sql');\n\nmodule.exports = config;\n```\n\n----------------------------------------\n\nTITLE: Previous PostgreSQL Index API Definition (Breaking Change)\nDESCRIPTION: This snippet showcases the old and incorrect way of defining PostgreSQL indexes in Drizzle ORM. The API lacked the ability to define SQL expressions inside `.on`, and `.using` and `.on` were treated similarly, causing confusion. The `.asc()`, `.desc()`, `.nullsFirst()`, and `.nullsLast()` methods were incorrectly applied to the index itself instead of individual columns.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0-beta.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nindex('name')\n  .on(table.column1, table.column2, ...) or .onOnly(table.column1, table.column2, ...)\n  .concurrently()\n  .using(sql``) // sql expression\n  .asc() or .desc()\n  .nullsFirst() or .nullsLast()\n  .where(sql``) // sql expression\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Predefined pg_vector Functions\nDESCRIPTION: This snippet showcases how to import and use predefined functions (l2Distance, l1Distance, innerProduct, cosineDistance, hammingDistance, jaccardDistance) provided by Drizzle ORM for `pg_vector`. These functions allow you to perform distance calculations on vector columns in your queries.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0-beta.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { l2Distance, l1Distance, innerProduct, \n          cosineDistance, hammingDistance, jaccardDistance } from 'drizzle-orm'\n\nl2Distance(table.column, [3, 1, 2]) // table.column <-> '[3, 1, 2]'\nl1Distance(table.column, [3, 1, 2]) // table.column <+> '[3, 1, 2]'\n\ninnerProduct(table.column, [3, 1, 2]) // table.column <#> '[3, 1, 2]'\ncosineDistance(table.column, [3, 1, 2]) // table.column <=> '[3, 1, 2]'\n\nhammingDistance(table.column, '101') // table.column <~> '101'\njaccardDistance(table.column, '101') // table.column <%> '101'\n```\n\n----------------------------------------\n\nTITLE: SingleStore Table Definition and Schema Creation\nDESCRIPTION: This code snippet demonstrates how to define a table in SingleStore using `drizzle-orm/singlestore-core`. It uses `singlestoreTable`, `text`, and `int` to define the schema of the `users` table, including primary key and not-null constraints. It also showcases creating a select schema using `createSelectSchema` from `drizzle-valibot`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-valibot/0.3.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { singlestoreTable, text, int } from 'drizzle-orm/singlestore-core';\nimport { createSelectSchema } from 'drizzle-valibot';\nimport { parse } from 'valibot';\n\nconst users = singlestoreTable('users', {\n  id: int().primaryKey(),\n  name: text().notNull(),\n  age: int().notNull()\n});\n\nconst userSelectSchema = createSelectSchema(users);\nconst rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);\nconst parsed: { id: number; name: string; age: number } = parse(userSelectSchema, rows[0]); // Error: `age` is not returned in the above query\nconst rows = await db.select().from(users).limit(1);\nconst parsed: { id: number; name: string; age: number } = parse(userSelectSchema, rows[0]); // Will parse successfully\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with MySQL Proxy - TypeScript\nDESCRIPTION: This snippet initializes a Drizzle ORM database instance using the MySQL Proxy driver. It defines an asynchronous function that makes an HTTP POST request to a proxy server with the SQL query, parameters, and method (all/execute). It handles potential errors by logging them and returning an empty array to ensure Drizzle receives the expected data structure.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/mysql-proxy/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { drizzle } from 'drizzle-orm/mysql-proxy';\n\nconst db = drizzle(async (sql, params, method) => {\n  try {\n    const rows = await axios.post('http://localhost:3000/query', {\n      sql,\n      params,\n      method,\n    });\n\n    return { rows: rows.data };\n  } catch (e: any) {\n    console.error('Error from mysql proxy server: ', e.response.data);\n    return { rows: [] };\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Generate Drizzle Migrations\nDESCRIPTION: This command generates SQLite migrations using Drizzle Kit, based on the schema defined in your `drizzle.config.ts` file.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\nnpx drizzle-kit generate:sqlite\n```\n\n----------------------------------------\n\nTITLE: Seeding Database with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to seed a database using Drizzle ORM and the defined schema. It imports the `seed` function from the `drizzle-seed` package and the schema definition from './schema.ts'. It initializes the database connection using the `DATABASE_URL` environment variable and then calls the `seed` function to populate the database according to the schema.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.3.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// index.ts\nimport { seed } from \"drizzle-seed\";\nimport * as schema from './schema.ts'\n\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await seed(db, schema);\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Importing Migrate Function from drizzle-orm-pg\nDESCRIPTION: This snippet demonstrates how to import the `migrate` function in Drizzle ORM PG version 0.14.0. The migrations functionality has been separated into a separate import. You will need to install drizzle-orm-pg to use this import.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-pg/0.14.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { migrate } from 'drizzle-orm-pg/node/migrate';\n```\n\n----------------------------------------\n\nTITLE: Install Babel Plugin Inline Import\nDESCRIPTION: This command installs the `babel-plugin-inline-import` package, which is required for using Drizzle Migrations with Expo. This plugin allows you to import SQL files directly into your JavaScript/TypeScript code.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install babel-plugin-inline-import\n```\n\n----------------------------------------\n\nTITLE: Creating a PostgreSQL Text Column Class\nDESCRIPTION: This code defines a custom `PgText` class that extends `PgColumn`. It represents the column itself and includes functions to define the SQL type and map values between the driver and the application. The `getSQLType()` function returns the data type name, and `mapFromDriverValue` and `mapToDriverValue` handle data transformations.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport class PgText<TTableName extends string, TData extends string>\n  extends PgColumn<ColumnConfig<{ tableName: TTableName; data: TData; driverParam: string }>> {\n  \n\n  constructor(table: AnyPgTable<{ name: TTableName }>, builder: PgTextBuilder<TData>['config']) {\n    super(table, builder);\n  }\n\n  getSQLType(): string {\n    return 'text';\n  }\n\n  override mapFromDriverValue(value: string): TData {\n    return value as TData\n  }\n\n  override mapToDriverValue(value: TData): string {\n    return value\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Install latest @libsql/client\nDESCRIPTION: This command installs the latest version of the `@libsql/client` package, which is required for using the `migrate` function with drizzle-orm.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @libsql/client@latest\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-delete-with-where - Example Code 1\nDESCRIPTION: Example Typescript code showing the effect of `enforce-delete-with-where` ESLint rule when `drizzleObjectName` is not defined. The ESLint rule will be triggered on both the custom class's `delete` method and Drizzle's `delete` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public delete() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will be triggered by ESLint Rule\nmyClassObj.delete()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.delete()\n```\n\n----------------------------------------\n\nTITLE: MySQL Switching to Old Version - Typescript\nDESCRIPTION: This snippet demonstrates how to switch to the old version for the MySQL schema by specifying `version: '1'`. This ensures consistency with the previous generator behavior.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { version: '1' });\n```\n\n----------------------------------------\n\nTITLE: Enforce Delete with Where - Config 2\nDESCRIPTION: This JSON snippet demonstrates configuring the 'enforce-delete-with-where' rule with the `drizzleObjectName` option. The `drizzleObjectName` option is set to `['db']`, which means the rule only triggers if the `delete` method is called on an object named `db`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-delete-with-where\": [\"error\", { \"drizzleObjectName\": [\"db\"] }],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing D1 database locally\nDESCRIPTION: These commands initialize the D1 database locally and start the development server.  The first command executes the SQL script to create the database schema, and the second command starts the Wrangler development server with local persistence.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/cloudflare-d1/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\nwrangler d1 execute <DATABASE_NAME> --local --file=./drizzle/0000_short_lockheed.sql\nwrangler dev --local --persist\n```\n\n----------------------------------------\n\nTITLE: Creating Select Schema for Enums and Views - Typescript\nDESCRIPTION: Demonstrates how to use `createSelectSchema` with enums and views using Drizzle ORM and Valibot. It imports necessary modules, defines a PostgreSQL enum and view, and then creates schemas for them. It showcases the expected output after parsing with valibot's parse function, reflecting the data types in the enum and view.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-valibot/0.3.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgEnum } from 'drizzle-orm/pg-core';\nimport { createSelectSchema } from 'drizzle-valibot';\nimport { parse } from 'valibot';\n\nconst roles = pgEnum('roles', ['admin', 'basic']);\nconst rolesSchema = createSelectSchema(roles);\nconst parsed: 'admin' | 'basic' = parse(rolesSchema, ...);\n\nconst usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));\nconst usersViewSchema = createSelectSchema(usersView);\nconst parsed: { id: number; name: string; age: number } = parse(usersViewSchema, ...);\n```\n\n----------------------------------------\n\nTITLE: Drizzle Table Definition (Old Style)\nDESCRIPTION: This TypeScript code demonstrates the original method for defining a Drizzle table schema, requiring the explicit naming of database columns when TypeScript keys essentially replicate them. The `uuid`, `text`, and `boolean` types are imported from `drizzle-orm/pg-core`\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { boolean, pgTable, text, uuid } from \"drizzle-orm/pg-core\";\n  \nexport const ingredients = pgTable(\"ingredients\", {\n  id: uuid(\"id\").defaultRandom().primaryKey(),\n  name: text(\"name\").notNull(),\n  description: text(\"description\"),\n  inStock: boolean(\"in_stock\").default(true),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Text Type for MySQL\nDESCRIPTION: This snippet defines a custom Text data type for MySQL using the `customType` function from Drizzle ORM. It specifies the data type as 'text'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst customText = customType<{ data: string }>({  dataType() {\n    return 'text';\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Relational Query API toSQL() Method\nDESCRIPTION: Shows how to use the `toSQL()` method on Relational Query API calls in Drizzle ORM. It retrieves the raw SQL query generated by the API call.  Requires a Drizzle database instance and a query builder object.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.6.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst query = db.query.usersTable.findFirst().toSQL();\n```\n\n----------------------------------------\n\nTITLE: Validating Data with Insert Schema\nDESCRIPTION: Illustrates how to use the generated insert schema to validate data. The `parse` function (assumed to be from the `arktype` library based on the project context) is used to validate a user object against the `insertUserSchema`.  The `isUserValid` variable would then hold validation results.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-arktype/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Usage\n\nconst isUserValid = parse(insertUserSchema, {\n\tname: 'John Doe',\n\temail: 'johndoe@test.com',\n\trole: 'admin',\n});\n```\n\n----------------------------------------\n\nTITLE: Seeder Warning for Conflicting Relations in Drizzle ORM (TS)\nDESCRIPTION: This code block shows the warning message triggered when seeding the schema defined above. It indicates a conflict between the one-to-many relation and the existing foreign key constraint. The seeder now prioritizes the foreign key constraint.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.3.1.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nYou are providing a one-to-many relation between the 'users' and 'posts' tables,\nwhile the 'posts' table object already has foreign key constraint in the schema referencing 'users' table.\nIn this case, the foreign key constraint will be used.\n```\n\n----------------------------------------\n\nTITLE: Basic Usage with Drizzle Seed in TypeScript\nDESCRIPTION: This code snippet demonstrates the basic usage of `drizzle-seed` to create 10 users with random names and IDs in a PostgreSQL database using Drizzle ORM. It imports necessary modules from `drizzle-orm` and `drizzle-seed`, defines a `users` table schema, initializes the database connection, and then calls the `seed` function to populate the table with fake data. Requires `drizzle-orm` and `drizzle-seed` to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-seed/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { pgTable, integer, text } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { seed } from \"drizzle-seed\";\n\nconst users = pgTable(\"users\", {\n  id: integer().primaryKey(),\n  name: text().notNull(),\n});\n\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await seed(db, { users });\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Installing Drizzle ORM and Mitata\nDESCRIPTION: This command installs the necessary dependencies: mitata (likely a testing library) and drizzle-orm, which provides the ORM functionality.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/bun-sqlite/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbun install mitata drizzle-orm\n```\n\n----------------------------------------\n\nTITLE: Enforce Update with Where - Example 1\nDESCRIPTION: This TypeScript code demonstrates how the 'enforce-update-with-where' rule is triggered when no `.where()` clause is used in an `.update()` statement.  It shows an example of a custom class with an `update` method and the Drizzle ORM's `update` method, both of which would trigger the ESLint rule.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public update() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will be triggered by ESLint Rule\nmyClassObj.update()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.update()\n```\n\n----------------------------------------\n\nTITLE: Exposing Lambda function with API Gateway in serverless.yml\nDESCRIPTION: This snippet demonstrates how to expose an AWS Lambda function through API Gateway using the serverless framework. It defines an HTTP event trigger for the `getUsers` function, mapping the `/users` path to the GET method. Additionally, it configures CORS (Cross-Origin Resource Sharing) by defining `GatewayResponse` resources to allow requests from any origin.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/aws-lambda/README.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nfunctions:\n  getUsers:\n    handler: ./src/api/user.getAll\n    events:\n      - http:\n          path: \"users\"\n          method: GET\n\nresources:\n  Resources:\n    GatewayResponse:\n      Type: \"AWS::ApiGateway::GatewayResponse\"\n      Properties:\n        ResponseParameters:\n          gatewayresponse.header.Access-Control-Allow-Origin: \"'*'\"\n          gatewayresponse.header.Access-Control-Allow-Headers: \"'*'\"\n          gatewayresponse.header.Access-Control-Allow-Methods: \"'*'\"\n        ResponseType: DEFAULT_4XX\n        RestApiId:\n          Ref: \"ApiGatewayRestApi\"\n    GatewayResponse5xx:\n      Type: \"AWS::ApiGateway::GatewayResponse\"\n      Properties:\n        ResponseParameters:\n          gatewayresponse.header.Access-Control-Allow-Origin: \"'*'\"\n          gatewayresponse.header.Access-Control-Allow-Headers: \"'*'\"\n          gatewayresponse.header.Access-Control-Allow-Methods: \"'*'\"\n        ResponseType: DEFAULT_5XX\n        RestApiId:\n          Ref: \"ApiGatewayRestApi\"\n```\n\n----------------------------------------\n\nTITLE: SQL: Index Creation Before Update (SQL)\nDESCRIPTION: This SQL statement demonstrates the previous format of index creation on a table's email column before the update.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_14\n\nLANGUAGE: sql\nCODE:\n```\n-- before\nCREATE UNIQUE INDEX `emailUniqueIndex` ON `users` (`lower(\"users\".\"email\")`);\n```\n\n----------------------------------------\n\nTITLE: Installing pnpm globally - Bash\nDESCRIPTION: This command installs the pnpm package manager globally using npm. pnpm is used to manage dependencies in the Drizzle ORM project. Requires npm to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g pnpm\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle ORM with SQLite Proxy Driver (HTTP)\nDESCRIPTION: This snippet shows how to initialize a Drizzle ORM database instance using the SQLite Proxy driver. It defines a function that makes HTTP POST requests to a specified endpoint to execute SQL queries. It handles potential errors by returning an empty array, ensuring that Drizzle ORM receives the expected data format. It relies on the axios library for making HTTP requests.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/sqlite-proxy/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { drizzle } from 'drizzle-orm/sqlite-proxy';\n\nconst db = drizzle(async (sql, params, method) => {\n  try {\n    const rows = await axios.post('http://localhost:3000/query', {\n      sql,\n      params,\n      method,\n    });\n\n    return { rows: rows.data };\n  } catch (e: any) {\n    console.error('Error from sqlite proxy server: ', e.response.data);\n    return { rows: [] };\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Table in Custom Schema - PostgreSQL Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to define a table named 'users' within a custom PostgreSQL schema named 'mySchema' using Drizzle ORM. It first defines the schema and then defines the table within that schema. It includes the same fields as the previous example: 'id', 'name', 'verified', 'jsonb', and 'createdAt', with 'id' as the primary key and 'createdAt' defaulting to the current timestamp.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-pg/0.15.1.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst mySchema = pgSchema('mySchema');\n\nconst usersTable = mySchema('users', {\n\tid: serial('id').primaryKey(),\n\tname: text('name').notNull(),\n\tverified: boolean('verified').notNull().default(false),\n\tjsonb: jsonb<string[]>('jsonb'),\n\tcreatedAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining pg_vector Indexes (L1, Hamming, Jaccard)\nDESCRIPTION: This snippet demonstrates how to define `pg_vector` indexes for L1 distance, Hamming distance, and Jaccard distance, available from pg_vector version 0.7.0. It creates a table with a vector embedding column and defines indexes using `vector_l1_ops`, `bit_hamming_ops`, and `bit_jaccard_ops`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0-beta.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// CREATE INDEX ON items USING hnsw (embedding vector_l1_ops);\n// CREATE INDEX ON items USING hnsw (embedding bit_hamming_ops);\n// CREATE INDEX ON items USING hnsw (embedding bit_jaccard_ops);\n\nconst table = pgTable('table', {\n    embedding: vector('embedding', { dimensions: 3 })\n}, (table) => ({\n    l1: index('l1_index').using('hnsw', table.embedding.op('vector_l1_ops'))\n    hamming: index('hamming_index').using('hnsw', table.embedding.op('bit_hamming_ops'))\n    bit: index('bit_jaccard_index').using('hnsw', table.embedding.op('bit_jaccard_ops'))\n}))\n```\n\n----------------------------------------\n\nTITLE: Defining Tables with Drizzle ORM\nDESCRIPTION: This code snippet defines two tables, `users` and `cities`, using Drizzle ORM's `pgTable` function. It establishes a one-to-many relationship between users and cities using the `cityId` field in the `users` table, which references the `id` field in the `cities` table. The `serial`, `text`, and `int` functions are used to define the data types of the columns.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  firstName: text('first_name').notNull(),\n  lastName: text('last_name'),\n  cityId: int('city_id').references(() => cities.id),\n});\n\nconst cities = pgTable('cities', {\n  id: serial('id').primaryKey(),\n  name: text('name').notNull(),\n});\n```\n\n----------------------------------------\n\nTITLE: Enforce Update with Where - Example 2\nDESCRIPTION: This TypeScript code demonstrates how the 'enforce-update-with-where' rule is triggered when a `.where()` clause is missing and the `drizzleObjectName` is configured. It shows a custom class with an `update` method that will NOT trigger the rule because it's not named `db`. The Drizzle ORM's `update` method, called on an object named `db`, will trigger the rule.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public update() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will NOT be triggered by ESLint Rule\nmyClassObj.update()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.update()\n```\n\n----------------------------------------\n\nTITLE: Generated SQL Query (Optimized)\nDESCRIPTION: This SQL query is generated by Drizzle ORM for the relational query. It uses lateral joins to efficiently retrieve data from related tables (users and posts).  It retrieves only the necessary columns. The improved query is designed to optimize performance and reduce read usage.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.0.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nselect \"comments\".\"id\",\n       \"comments\".\"user_id\",\n       \"comments\".\"post_id\",\n       \"comments\".\"content\",\n       \"comments_user\".\"data\" as \"user\",\n       \"comments_post\".\"data\" as \"post\"\nfrom \"comments\"\n         left join lateral (select json_build_array(\"comments_user\".\"name\") as \"data\"\n                            from (select *\n                                  from \"users\" \"comments_user\"\n                                  where \"comments_user\".\"id\" = \"comments\".\"user_id\"\n                                  limit 1) \"comments_user\") \"comments_user\" on true\n         left join lateral (select json_build_array(\"comments_post\".\"title\", \"comments_post_user\".\"data\") as \"data\"\n                            from (select *\n                                  from \"posts\" \"comments_post\"\n                                  where \"comments_post\".\"id\" = \"comments\".\"post_id\"\n                                  limit 1) \"comments_post\"\n                                     left join lateral (select json_build_array(\"comments_post_user\".\"name\") as \"data\"\n                                                        from (select *\n                                                              from \"users\" \"comments_post_user\"\n                                                              where \"comments_post_user\".\"id\" = \"comments_post\".\"user_id\"\n                                                              limit 1) \"comments_post_user\") \"comments_post_user\"\n                                               on true) \"comments_post\" on true\norder by \"comments\".\"id\"\nlimit 1\n```\n\n----------------------------------------\n\nTITLE: SQL: Index Creation After Update (SQL)\nDESCRIPTION: This SQL statement demonstrates the updated format of index creation after the update. The expression is properly mapped to the SQL query.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_15\n\nLANGUAGE: sql\nCODE:\n```\n-- now\nCREATE UNIQUE INDEX `emailUniqueIndex` ON `users` (lower(\"email\"));\n```\n\n----------------------------------------\n\nTITLE: Configuring drizzle-kit for Gel dialect\nDESCRIPTION: This snippet shows how to configure `drizzle-kit` to use the Gel dialect. It imports the `defineConfig` function from `drizzle-kit` and sets the `dialect` property to `'gel'` in the configuration object. This allows drizzle-kit to interact with the Gel database during schema pulling.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.40.0.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// drizzle.config.ts\nimport { defineConfig } from 'drizzle-kit';\n\nexport default defineConfig({\n  dialect: 'gel',\n});\n```\n\n----------------------------------------\n\nTITLE: Building the Drizzle ORM project - Bash\nDESCRIPTION: This script installs the project dependencies and builds the Drizzle ORM project.  It should be run from the root directory of the repository. Requires pnpm to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm install && pnpm build\n```\n\n----------------------------------------\n\nTITLE: Using set operators with builder approach\nDESCRIPTION: This code demonstrates how to use set operators (UNION) in Drizzle ORM using the builder approach.  It shows combining the results of two select queries into a single result set.  It depends on the Drizzle ORM database instance.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await db.select().from(users).union(db.select().from(customers));\n```\n\n----------------------------------------\n\nTITLE: Running the Drizzle ORM Example\nDESCRIPTION: This command executes the main TypeScript file (`src/index.ts`) that demonstrates the Drizzle ORM usage with Bun and SQLite.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/bun-sqlite/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbun run src/index.ts\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Boolean Type for Postgres\nDESCRIPTION: This snippet defines a custom Boolean data type for PostgreSQL using the `customType` function from Drizzle ORM. It specifies the data type as 'boolean'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst customBoolean = customType<{ data: boolean }>({  dataType() {\n    return 'boolean';\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Custom Types in a MySQL Table\nDESCRIPTION: This snippet demonstrates how to use the custom data types defined previously in a MySQL table schema using `mysqlTable` from Drizzle ORM. It creates a 'userstest' table with columns using the custom Serial, Text, Boolean, Json, and Timestamp types.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst usersTable = mysqlTable('userstest', {\n  id: customSerial('id').primaryKey(),\n  name: customText('name').notNull(),\n  verified: customBoolean('verified').notNull().default(false),\n  jsonb: customJson<string[]>('jsonb'),\n  createdAt: customTimestamp('created_at', { fsp: 2 }).notNull().default(\n    sql`now()`,\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Drizzle ORM Xata Driver\nDESCRIPTION: This command installs the drizzle-orm and @xata.io/client packages using pnpm.  These packages are necessary to use Drizzle ORM with the Xata database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.4.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add drizzle-orm @xata.io/client\n```\n\n----------------------------------------\n\nTITLE: Create Schema Factory with Typebox Instance - Typescript\nDESCRIPTION: This code snippet showcases the use of `createSchemaFactory` to create schema generation functions with a custom Typebox instance (`elysia/t`). It imports modules from `drizzle-orm`, `drizzle-typebox` and `elysia`. The example demonstrates extending Typebox's functionality to provide custom validation error messages.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-typebox/0.2.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, text, integer } from 'drizzle-orm/pg-core';\nimport { createSchemaFactory } from 'drizzle-typebox';\nimport { t } from 'elysia'; // Extended Typebox instance\n\nconst users = pgTable('users', {\n  id: integer().generatedAlwaysAsIdentity().primaryKey(),\n  name: text().notNull(),\n  age: integer().notNull()\n});\n\nconst { createInsertSchema } = createSchemaFactory({ typeboxInstance: t });\n\nconst userInsertSchema = createInsertSchema(users, {\n  // We can now use the extended instance\n  name: (schema) => t.Number({ ...schema }, { error: '`name` must be a string' })\n});\n```\n\n----------------------------------------\n\nTITLE: MySQL Import Path Update - Drizzle ORM\nDESCRIPTION: This snippet demonstrates the updated import path for MySQL-related functionalities in Drizzle ORM after merging dialect-specific packages. It shows how to import from `drizzle-orm/mysql-core` and `drizzle-orm/mysql2` instead of the legacy `drizzle-orm-mysql` package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.17.0.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/mysql-core'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/mysql2'\n```\n\n----------------------------------------\n\nTITLE: Connecting to SQLite via Custom Proxy - TypeScript\nDESCRIPTION: This code shows how to connect to SQLite database via a custom HTTP proxy using Drizzle ORM. It defines a function that sends SQL queries to a proxy server using Axios and returns the results. Error handling is included.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n  const db = drizzle(async (sql, params, method) => {\n    try {\n      const rows = await axios.post('http://localhost:3000/query', { sql, params, method });\n\n      return { rows: rows.data };\n    } catch (e: any) {\n      console.error('Error from sqlite proxy server: ', e.response.data)\n      return { rows: [] };\n    }\n  });\n```\n\n----------------------------------------\n\nTITLE: Update Babel Configuration (babel.config.js)\nDESCRIPTION: This JavaScript snippet shows the changes needed to the `babel.config.js` file to enable the `babel-plugin-inline-import` plugin. This plugin allows you to import SQL files directly into your JavaScript/TypeScript code.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.2.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = function(api) {\n  api.cache(true);\n\n  return {\n    presets: ['babel-preset-expo'],\n+   plugins: [[\"inline-import\", { \"extensions\": [\".sql\"] }]]\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Array Column Seeding with Refinement - TypeScript\nDESCRIPTION: This code snippet shows how to seed a table containing an array column and customize the generated data using the `refine` method in `drizzle-seed`. It configures the `phoneNumber` generator with the `arraySize` parameter to create 1D arrays of phone numbers. The snippet relies on `drizzle` to connect to the database and `seed` to manage data generation.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.3.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await seed(db, { users }, { count: 1000 }).refine((funcs) => ({\n    users: {\n      columns: {\n        phone_numbers: funcs.phoneNumber({ arraySize: 3 }),\n      },\n    },\n  }));\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: SQLite Import Path Update - Drizzle ORM\nDESCRIPTION: This snippet demonstrates the updated import path for SQLite-related functionalities in Drizzle ORM after merging dialect-specific packages. It shows how to import from `drizzle-orm/sqlite-core`, `drizzle-orm/better-sqlite3`, `drizzle-orm/d1`, `drizzle-orm/bun-sqlite`, and `drizzle-orm/sql.js` instead of the legacy `drizzle-orm-sqlite` package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.17.0.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/sqlite-core'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/better-sqlite3'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/d1'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/bun-sqlite'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/sql.js'\n```\n\n----------------------------------------\n\nTITLE: Enforce Delete with Where - Example 2\nDESCRIPTION: This TypeScript code demonstrates how the 'enforce-delete-with-where' rule is triggered when a `.where()` clause is missing and the `drizzleObjectName` is configured. It shows a custom class with a `delete` method that will NOT trigger the rule because it's not named `db`. The Drizzle ORM's `delete` method, called on an object named `db`, will trigger the rule.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public delete() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will NOT be triggered by ESLint Rule\nmyClassObj.delete()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.delete()\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with @libsql/client\nDESCRIPTION: This snippet demonstrates initializing Drizzle ORM with the default `@libsql/client` driver.  It imports the drizzle function from `drizzle-orm/libsql` and establishes a database connection using environment variables for the URL and authentication token.  The driver automatically selects the appropriate node or web version based on the bundler target.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/libsql';\n\nconst db = drizzle({ connection: {\n  url: process.env.DATABASE_URL, \n  authToken: process.env.DATABASE_AUTH_TOKEN \n}});\n```\n\n----------------------------------------\n\nTITLE: Creating Table with Foreign Key to Supabase (TypeScript)\nDESCRIPTION: This snippet illustrates how to create a table (`profiles`) with a foreign key that references a table (`authUsers`) defined within the Supabase schema. It also shows how to define a policy using the `authenticatedRole` from `drizzle-orm/supabase`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.27.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { foreignKey, pgPolicy, pgTable, text, uuid } from \"drizzle-orm/pg-core\";\nimport { sql } from \"drizzle-orm/sql\";\nimport { authenticatedRole, authUsers } from \"drizzle-orm/supabase\";\n\nexport const profiles = pgTable(\n  \"profiles\",\n  {\n    id: uuid().primaryKey().notNull(),\n    email: text().notNull(),\n  },\n  (table) => [\n    foreignKey({\n      columns: [table.id],\n\t  // reference to the auth table from Supabase\n      foreignColumns: [authUsers.id],\n      name: \"profiles_id_fk\",\n    }).onDelete(\"cascade\"),\n    pgPolicy(\"authenticated can view all profiles\", {\n      for: \"select\",\n\t  // using predefined role from Supabase\n      to: authenticatedRole,\n      using: sql`true`,\n    }),\n  ]\n);\n```\n\n----------------------------------------\n\nTITLE: Invalid Foreign Key Creation\nDESCRIPTION: This SQL snippet demonstrates examples of valid and invalid foreign key creations, highlighting that referenced columns must have a unique index or primary key with the same collating sequence.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_5\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE parent(a PRIMARY KEY, b UNIQUE, c, d, e, f);\nCREATE UNIQUE INDEX i1 ON parent(c, d);\nCREATE INDEX i2 ON parent(e);\nCREATE UNIQUE INDEX i3 ON parent(f COLLATE nocase);\n\nCREATE TABLE child1(f, g REFERENCES parent(a));                        -- Ok\nCREATE TABLE child2(h, i REFERENCES parent(b));                        -- Ok\nCREATE TABLE child3(j, k, FOREIGN KEY(j, k) REFERENCES parent(c, d));  -- Ok\nCREATE TABLE child4(l, m REFERENCES parent(e));                        -- Error!\nCREATE TABLE child5(n, o REFERENCES parent(f));                        -- Error!\nCREATE TABLE child6(p, q, FOREIGN KEY(p, q) REFERENCES parent(b, c));  -- Error!\nCREATE TABLE child7(r REFERENCES parent(c));                           -- Error!\n```\n\n----------------------------------------\n\nTITLE: Enforce Delete with Where - Config 1\nDESCRIPTION: This JSON snippet shows an example configuration for the 'enforce-delete-with-where' rule without the `drizzleObjectName` option.  This will cause the ESLint rule to trigger on any object with a `delete` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-delete-with-where\": [\"error\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Switching to Old Version - Typescript\nDESCRIPTION: This snippet seeds using the old version.  It allows reverting to older versions of the generators if needed, to maintain consistency if upgrading causes any issues. Version is set to empty string.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { version: '' });\n```\n\n----------------------------------------\n\nTITLE: Inserting Multiple Values Directly with Drizzle ORM (TypeScript)\nDESCRIPTION: Demonstrates how to insert an array of values directly into a table using Drizzle ORM. This eliminates the need for spreading the array. Requires Drizzle ORM setup with a MySQL table defined.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.23.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = mysqlTable('users', {\n  id: int('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\nawait users.insert().values([\n  { name: 'John' },\n  { name: 'Jane' },\n]);\n```\n\n----------------------------------------\n\nTITLE: Mapping an Integer Value from Driver Value (PostgreSQL)\nDESCRIPTION: This code snippet shows an example of overriding the `mapFromDriverValue` function to parse an integer value received from the database. It handles cases where the value is a string by using `parseInt` to convert it to a number.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\noverride mapFromDriverValue(value: number | string): number {\n  if (typeof value === 'string') {\n    return parseInt(value);\n  }\n  return value;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting View Name using getViewName util in Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to use the `getViewName` utility function from Drizzle ORM to retrieve the name of a view.  It defines a table `user` and a view `userView` based on that table.  It then uses `getViewName` to get the name of the view.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.39.0.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getViewName } from 'drizzle-orm/sql'\n\nexport const user = pgTable(\"user\", {\n  id: serial(),\n  name: text(),\n  email: text(),\n});\n\nexport const userView = pgView(\"user_view\").as((qb) => qb.select().from(user));\n\nconst viewName = getViewName(userView)\n```\n\n----------------------------------------\n\nTITLE: Defining Composite Primary Key with drizzle-orm-sqlite\nDESCRIPTION: This code snippet demonstrates how to define a SQLite table with a composite primary key using the `drizzle-orm-sqlite` library. It defines a table named 'pk_example' with columns 'id', 'name', and 'email', and then defines a composite primary key consisting of the 'id' and 'name' columns. The code requires the `sqliteTable`, `integer`, `text`, and `primaryKey` functions from the `drizzle-orm-sqlite` library.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-sqlite/0.15.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst pkExample = sqliteTable('pk_example', {\n\tid: integer('id'),\n\tname: text('name').notNull(),\n\temail: text('email').notNull(),\n}, (table) => ({\n\tcompositePk: primaryKey(table.id, table.name)\n}));\n```\n\n----------------------------------------\n\nTITLE: Running integration tests for Drizzle ORM - Bash\nDESCRIPTION: This command navigates to the integration-tests directory and runs the test suite using pnpm. Assumes you are in the root directory of the repository. Requires pnpm to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd integration-tests && pnpm test\n```\n\n----------------------------------------\n\nTITLE: Using Join Aliases and Self-Joins in SQLite\nDESCRIPTION: This snippet demonstrates how to use aliases for tables when performing joins, particularly for self-joins. It imports the `alias` function and defines a `files` table. The code then creates an alias `nestedFiles` for the `files` table and performs a left join, filtering results based on the `parent` field.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ..., alias } from 'drizzle-orm/sqlite-core';\n\nexport const files = sqliteTable('folders', {\n  name: text('name').notNull(),\n  parent: text('parent_folder')\n})\n\n...\nconst db = drizzle(...);\n\nconst nestedFiles = alias(files, 'nested_files');\ndb.select().from(files)\n  .leftJoin(nestedFiles, eq(files.name, nestedFiles.name))\n  .where(eq(files.parent, '/'))\n  .all();\n// will return files and folders and nested files for each folder at root dir\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-update-with-where - Example Config 1\nDESCRIPTION: Example configuration for the `enforce-update-with-where` ESLint rule without specifying `drizzleObjectName`.  This will trigger the rule on any `.update()` method call, regardless of the object it's called on.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-update-with-where\": [\"error\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ESLint 'recommended' Config\nDESCRIPTION: This YAML configuration file shows how to use the 'recommended' config from the eslint-plugin-drizzle.  It extends the plugin:drizzle/recommended configuration, specifies the TypeScript parser, and configures parserOptions to point to the tsconfig.json file. It is currently equivalent to the 'all' config.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nroot: true\nextends:\n  - \"plugin:drizzle/recommended\"\nparser: '@typescript-eslint/parser'\nparserOptions:\n  project: './tsconfig.json'\nplugins:\n  - drizzle\n```\n\n----------------------------------------\n\nTITLE: Defining Foreign Key (Before)\nDESCRIPTION: Defines a foreign key constraint using the older `foreignKey()` API, which required a callback function. The callback function was used to specify the columns and foreign columns involved in the constraint. This approach is deprecated in version 0.15.0.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-pg/0.15.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const usersTable = pgTable(\n\t'users_table',\n\t{\n\t\tid: serial('id').primaryKey(),\n\t\tuuid: uuid('uuid').defaultRandom().notNull(),\n\t\thomeCity: integer('home_city').notNull()\n\t},\n\t(users) => ({\n\t\t// foreignKey had a callback as param\n\t\tusersCityFK: foreignKey(() => ({ columns: [users.homeCity], foreignColumns: [cities.id] })),\n\t}),\n);\n```\n\n----------------------------------------\n\nTITLE: pg_vector Extension Indexes - TypeScript\nDESCRIPTION: This snippet defines PostgreSQL table indexes leveraging the `pg_vector` extension. It demonstrates how to create indexes for L2 distance, Inner product, and Cosine distance using the `vector_l2_ops`, `vector_ip_ops`, and `vector_cosine_ops` operators, respectively. Requires the `pg_vector` extension to be installed in the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = pgTable('items', {\n    embedding: vector('embedding', { dimensions: 3 })\n}, (table) => ({\n    l2: index('l2_index').using('hnsw', table.embedding.op('vector_l2_ops'))\n    ip: index('ip_index').using('hnsw', table.embedding.op('vector_ip_ops'))\n    cosine: index('cosine_index').using('hnsw', table.embedding.op('vector_cosine_ops'))\n}))\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Generated Columns (Simple)\nDESCRIPTION: This snippet demonstrates defining simple generated columns in PostgreSQL using either `sql` templates or plain strings. The `generatedName` and `generatedName1` columns are generated with the value 'hello world!'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport const users = pgTable(\"users\", {{\n  id: integer(\"id\"),\n  name: text(\"name\"),\n  generatedName: text(\"gen_name\").generatedAlwaysAs(sql`hello world!`),\n  generatedName1: text(\"gen_name1\").generatedAlwaysAs(\"hello world!\"),\n}}),\n```\n\n----------------------------------------\n\nTITLE: ESLint 'all' Config\nDESCRIPTION: This YAML configuration file shows how to use the 'all' config, which enables all rules (except deprecated ones) from the eslint-plugin-drizzle.  It extends the plugin:drizzle/all configuration, specifies the TypeScript parser, and configures parserOptions to point to the tsconfig.json file.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nroot: true\nextends:\n  - \"plugin:drizzle/all\"\nparser: '@typescript-eslint/parser'\nparserOptions:\n  project: './tsconfig.json'\nplugins:\n  - drizzle\n```\n\n----------------------------------------\n\nTITLE: PlanetScale Client Usage Warning - MDX\nDESCRIPTION: This MDX code provides a warning message to users about the upcoming deprecation of connect() and the requirement to use the Client instance for PlanetScale connections in Drizzle ORM version 0.30.0 and later. It also includes an example code snippet for initializing the Client.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.4.md#_snippet_3\n\nLANGUAGE: mdx\nCODE:\n```\nWarning: You need to pass an instance of Client:\n\nimport { Client } from \"@planetscale/database\";\n\nconst client = new Client({\n  host: process.env[\"DATABASE_HOST\"],\n  username: process.env[\"DATABASE_USERNAME\"],\n  password: process.env[\"DATABASE_PASSWORD\"],\n});\n\nconst db = drizzle(client);\n\nStarting from version 0.30.0, you will encounter an error if you attempt to use anything other than a Client instance.\n\nPlease make the necessary changes now to prevent any runtime errors in the future\n```\n\n----------------------------------------\n\nTITLE: Raw SQL Join Example\nDESCRIPTION: This SQL query demonstrates how to select data from the `cities` and `users` tables using a left join. It selects specific columns from both tables and aliases them for clarity. The join condition is based on the `city_id` column in the `users` table matching the `id` column in the `cities` table. This shows the equivalent SQL query for the Drizzle ORM examples.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nselect\n  cities.id as city_id,\n  cities.name as city_name,\n  users.id as user_id,\n  users.first_name,\n  users.last_name\nfrom cities\nleft join users on users.city_id = cities.id\n```\n\n----------------------------------------\n\nTITLE: Selecting all posts with columns and with relation\nDESCRIPTION: This code snippet demonstrates how to select all posts with specific columns and a relation using Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst posts = await db.query.posts.findMany({\n\tcolumns: {\n\t\tid: true,\n\t\tcontent: true,\n\t},\n\twith: {\n\t\tcomments: true,\n\t}\n});\n```\n\n----------------------------------------\n\nTITLE: Querying Users with Posts (Deprecated)\nDESCRIPTION: This code snippet demonstrates a deprecated way of filtering by nested relations in Drizzle ORM.  It attempts to find users with posts by checking the length of the `posts` array within the `where` clause. This approach no longer works in version 0.28.0 and later.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst usersWithPosts = await db.query.users.findMany({\n  where: (table, { sql }) => (sql`json_array_length(${table.posts}) > 0`),\n  with: {\n    posts: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring VPC in serverless.yml for AWS Lambda\nDESCRIPTION: This snippet demonstrates how to configure the VPC settings for an AWS Lambda function using the serverless framework. It specifies the security group IDs and subnet IDs necessary for the Lambda function to access resources within the VPC, such as an Aurora RDS instance. The `vpc_config` section defines the network configuration, which is then applied to the `getUsers` function using the `<<: *vpc_config` directive.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/aws-lambda/README.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\ncustom:\n  vpc_config: &vpc_config\n    vpc:\n      securityGroupIds:\n        - sg-samplegroupId\n      subnetIds:\n        - subnet-sample1\n        - subnet-sample2\n        - subnet-sample3\n\nfunctions:\n  getUsers:\n    handler: ./src/api/user.getAll\n    <<: *vpc_config\n```\n\n----------------------------------------\n\nTITLE: Seeding with Explicit Versioning - Typescript\nDESCRIPTION: This snippet shows how to seed using the version parameter to explicitly specify the version of the generators used.  This example utilizes version '2', ensuring that specific generator versions are used during the seeding process. This guarantees that even when the 'firstName' generator is set to V3, the generator will use V2\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { version: '2' });\n```\n\n----------------------------------------\n\nTITLE: Seeding with Custom Seed Value (Drizzle ORM)\nDESCRIPTION: This snippet shows how to use the `seed` option to provide a seed value for the random number generator. Using a specific seed ensures that the same data is generated on each run. It requires the `db` and `schema` variables to be defined elsewhere and passes an options object with the `seed` property set to `12345`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.1.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { seed: 12345 });\n```\n\n----------------------------------------\n\nTITLE: Using the 'seed' option in drizzle-seed\nDESCRIPTION: This code demonstrates the usage of the `seed` option in the `seed` function.  It uses the `db` (database connection) and `schema` variables, which need to be initialized outside the scope. By setting the `seed` option, you can generate a different set of values for each subsequent run, making data generation predictable and reproducible.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.4.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { seed: 12345 });\n```\n\n----------------------------------------\n\nTITLE: SingleStore Table Definition and Schema Creation (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define a table using the `singlestoreTable` function from `drizzle-orm/singlestore-core`, including specifying column types and constraints. It also shows how to create a select schema using `createSelectSchema` from `drizzle-typebox` based on the table definition. Dependencies include `drizzle-orm/singlestore-core` and `drizzle-typebox`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-typebox/0.2.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { singlestoreTable, text, int } from 'drizzle-orm/singlestore-core';\nimport { createSelectSchema } from 'drizzle-typebox';\nimport { Value } from '@sinclair/typebox/value';\n\nconst users = singlestoreTable('users', {\n  id: int().primaryKey(),\n  name: text().notNull(),\n  age: int().notNull()\n});\n\nconst userSelectSchema = createSelectSchema(users);\n```\n\n----------------------------------------\n\nTITLE: Connecting to SQLite with better-sqlite3 - TypeScript\nDESCRIPTION: This code snippet illustrates how to connect to a SQLite database using better-sqlite3 and Drizzle ORM. It imports the required modules, instantiates a new Database object, and then initializes Drizzle with it. Finally, it queries all users from the 'users' table.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// better-sqlite3 or fly.io LiteFS\nimport { drizzle, BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';\nimport Database from 'better-sqlite3';\n\nconst sqlite = new Database('sqlite.db');\nconst db/*: BetterSQLite3Database*/ = drizzle(sqlite);\nconst result = db.select().from(users).all()\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Timestamp Type for MySQL\nDESCRIPTION: This snippet defines a custom Timestamp data type for MySQL using the `customType` function from Drizzle ORM. It configures the data type with fractional seconds precision and includes a `fromDriver` method to parse the string value from the database into a JavaScript Date object.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst customTimestamp = customType<\n  { data: Date; driverData: string; config: { fsp: number } }\n>({  dataType(config) {\n    const precision = typeof config.fsp !== 'undefined'\n      ? ` (${config.fsp})`\n      : '';\n    return `timestamp${precision}`;\n  },\n  fromDriver(value: string): Date {\n    return new Date(value);\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Seeding with Custom Count (Drizzle ORM)\nDESCRIPTION: This snippet demonstrates how to use the `count` option in the `seed` function to specify the number of entities to create. It requires the `db` and `schema` variables to be defined elsewhere in the project and passes an object with the `count` property set to `1000` to the `seed` function.  This will generate 1000 entries.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.1.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, schema, { count: 1000 });\n```\n\n----------------------------------------\n\nTITLE: Configuring Drizzle with Casing Option in TypeScript\nDESCRIPTION: This snippet shows how to configure Drizzle ORM with the `casing` option set to `snake_case`. This configuration automatically maps column names between TypeScript's camelCase and the database's snake_case. It initializes a database connection named `db` with the specified connection string and casing strategy.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst db = await drizzle('node-postgres', { connection: '', casing: 'snake_case' })\n```\n\n----------------------------------------\n\nTITLE: Defining Enum with Custom Schema in Postgres (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to define an enum with a custom schema in Postgres using Drizzle ORM.  It imports the `pgSchema` function and then defines a new schema named 'mySchema'. Finally, it creates an enum named 'colors' within that schema with the specified values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.30.7-preview.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { pgSchema } from 'drizzle-orm/pg-core';\n\nconst mySchema = pgSchema('mySchema');\nconst colors = mySchema.enum('colors', ['red', 'green', 'blue']);\n```\n\n----------------------------------------\n\nTITLE: Drizzle ORM Join with Mixed Nested Object Grouping\nDESCRIPTION: This snippet illustrates grouping columns from multiple tables into a single nested object. Note that the nullability of each column remains independent, reflecting the join's behavior. This demonstrates that simply grouping doesn't apply the TypeScript magic for unified nullability checks.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/joins.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n.select({\n  id: cities.id,\n  cityAndUser: {\n    cityName: cities.name,\n    userId: users.id,\n    firstName: users.firstName,\n    lastName: users.lastName,\n  }\n})\n```\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  id: number;\n  cityAndUser: {\n    cityName: string;\n    userId: number | null;\n    firstName: string | null;\n    lastName: string | null;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Line Type Definition - TypeScript\nDESCRIPTION: This snippet defines a PostgreSQL table with a `line` column using Drizzle ORM. It shows the two modes for mapping the `line` type: `tuple` (default) and `abc`. The `abc` mode maps the database Line{1,2,3} to an object `{ a: 1, b: 2, c: 3 }`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst items = pgTable('items', {\n line: line('line'),\n lineObj: point('line_abc', { mode: 'abc' }),\n});\n```\n\n----------------------------------------\n\nTITLE: Linking Policy to Existing Supabase Table (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a policy and link it to an existing Supabase table (`realtimeMessages`) using the `link` method.  The policy is defined for the `authenticatedRole` and applies to insert operations.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.27.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sql } from \"drizzle-orm\";\nimport { pgPolicy } from \"drizzle-orm/pg-core\";\nimport { authenticatedRole, realtimeMessages } from \"drizzle-orm/supabase\";\n\nexport const policy = pgPolicy(\"authenticated role insert policy\", {\n  for: \"insert\",\n  to: authenticatedRole,\n  using: sql``,\n}).link(realtimeMessages);\n```\n\n----------------------------------------\n\nTITLE: LibSQL Unsupported Index Alteration Example\nDESCRIPTION: This SQL code presents an example of a table creation that includes an index that, if altered or dropped, will cause the entire table to be recreated in LibSQL/Turso due to limitations in their ALTER statements.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE `users` (\n  `id` integer NOT NULL,\n  `name` integer,\n  `age` integer PRIMARY KEY NOT NULL\n  FOREIGN KEY (`name`) REFERENCES `users1`(\"id\") ON UPDATE no action ON DELETE no action\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Supabase Roles with Drizzle ORM\nDESCRIPTION: This code defines several roles commonly used in Supabase, marking them as existing within the database.  These roles can be utilized when constructing database schemas and policies to define access control rules.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// drizzle-orm/supabase\nexport const anonRole = pgRole('anon').existing();\nexport const authenticatedRole = pgRole('authenticated').existing();\nexport const serviceRole = pgRole('service_role').existing();\nexport const postgresRole = pgRole('postgres_role').existing();\nexport const supabaseAuthAdminRole = pgRole('supabase_auth_admin').existing();\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (New - Connection Object)\nDESCRIPTION: This TypeScript code shows initializing Drizzle with a connection object using client-specific types (inferred from the underlying client connection types). This allows specifying connection details such as `connectionString`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// And finally, if you need to use full client/driver-specific types in connections, you can use a URL or host/port/etc. as an object inferred from the underlying client connection types\nconst db3 = await drizzle(\"node-postgres\", {\n  connection: {\n    connectionString: process.env.POSTGRES_URL,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with @libsql/client/sqlite3\nDESCRIPTION: This snippet demonstrates initializing Drizzle ORM with the `@libsql/client/sqlite3` driver. It imports the drizzle function from `drizzle-orm/libsql/wasm` and establishes a database connection using environment variables for the URL and authentication token. This module supports :memory: and file connection protocols.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.3.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/libsql/wasm';\n\nconst db = drizzle({ connection: {\n  url: process.env.DATABASE_URL, \n  authToken: process.env.DATABASE_AUTH_TOKEN \n}});\n```\n\n----------------------------------------\n\nTITLE: Defining Foreign Keys (Before)\nDESCRIPTION: This code shows the old way to define foreign keys in Drizzle ORM. The foreignKey function took a callback to define columns and foreignColumns. This approach is deprecated and should be updated.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-mysql/0.15.1.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const usersTable = mysqlTable('userstest', {\n\tid: serial('id').primaryKey(),\n\thomeCity: text('name').notNull(),\n\tcreatedAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),\n}, (users) => ({\n\t// foreignKey has a callback as param\n\tusersCityFK: foreignKey(() => { columns: [users.homeCity], foreignColumns: [cities.id] }),\n}));\n```\n\n----------------------------------------\n\nTITLE: Drizzle Client Initialization (New - Detailed Config)\nDESCRIPTION: This TypeScript code provides an example of initializing the Drizzle client with a detailed connection configuration, including user, password, host, port, database name, and SSL settings.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.34.0.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst db4 = await drizzle(\"node-postgres\", {\n  connection: {\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    host: process.env.DB_HOST,\n    port: process.env.DB_PORT,\n    database: process.env.DB_NAME,\n    ssl: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Drizzle with @libsql/client-wasm\nDESCRIPTION: This snippet demonstrates initializing Drizzle ORM with the `@libsql/client-wasm` driver. It imports the drizzle function from `drizzle-orm/libsql` and establishes a database connection using environment variables for the URL and authentication token. This is a separate experimental package for WASM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.35.3.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/libsql';\n\nconst db = drizzle({ connection: {\n  url: process.env.DATABASE_URL, \n  authToken: process.env.DATABASE_AUTH_TOKEN \n}});\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Text Type for Postgres\nDESCRIPTION: This snippet defines a custom Text data type for PostgreSQL using the `customType` function from Drizzle ORM. It specifies the data type as 'text'.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst customText = customType<{ data: string }>({  dataType() {\n    return 'text';\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL UUID Column Definition and Seeding - TypeScript\nDESCRIPTION: This code snippet demonstrates how to define a table with a UUID column in PostgreSQL using Drizzle ORM. It utilizes the `pgTable` and `uuid` functions from `drizzle-orm/pg-core`. The snippet also shows how to use `drizzle-seed` to seed the table, either automatically or with custom refinement for the UUID values.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.1.3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, uuid } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { seed } from \"drizzle-seed\";\n\nconst users = pgTable(\"users\", {\n  uuid: uuid(\"uuid\"),\n});\n\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  //  You can let it seed automatically\n  //  await seed(db, { users });\n\n  // Alternatively, you can manually specify the generator in refine.\n  await seed(db, { users }, { count: 1000 }).refine((funcs) => ({\n    users: {\n      columns: {\n        uuid: funcs.uuid(),\n      },\n    },\n  }));\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Defining MySQL bigint with unsigned option in Drizzle\nDESCRIPTION: This code snippet shows how to define a MySQL bigint column with the `unsigned` option using Drizzle ORM. This allows specifying that the bigint should only hold non-negative values. Requires `drizzle-orm` package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst table = mysqlTable('table', {\n  id: bigint('id', { mode: 'number', unsigned: true }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using `is()` for Type Checking in Drizzle ORM (TypeScript)\nDESCRIPTION: Demonstrates using the `is()` function instead of `instanceof` for checking if an object is an instance of a Drizzle type, such as `Column`. This is crucial for monorepo setups with multiple Drizzle instances to avoid issues.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.27.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { is, Column } from 'drizzle-orm'\n\nif (is(value, Column)) {\n  // value's type is narrowed to Column\n}\n```\n\n----------------------------------------\n\nTITLE: Drizzle Kit Configuration for Supabase migrations - TypeScript\nDESCRIPTION: Illustrates how to configure Drizzle Kit to use the Supabase migration file format by setting the `prefix` option to `'supabase'` within the `drizzle-kit.config.ts` file. This allows customizing migration file names.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"postgresql\",\n  migrations: {\n    prefix: 'supabase'\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Json Type for MySQL\nDESCRIPTION: This snippet defines a custom Json data type for MySQL using the `customType` function from Drizzle ORM. It specifies the data type as 'json' and includes a `toDriver` method to stringify the JSON data before writing it to the database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst customJson = <TData>(name: string) =>  customType<{ data: TData; driverData: string }>({    dataType() {\n      return 'json';\n    },\n    toDriver(value: TData): string {\n      return JSON.stringify(value);\n    },\n  })(name);\n```\n\n----------------------------------------\n\nTITLE: Importing Migrate Function from Drizzle ORM SQLite\nDESCRIPTION: This snippet demonstrates how to import the `migrate` function from the `drizzle-orm-sqlite` package. The migration functionality has been separated into a distinct import for better modularity and organization.  It depends on `drizzle-orm-sqlite/better-sqlite3/migrate`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-sqlite/0.14.1.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { migrate } from 'drizzle-orm-sqlite/better-sqlite3/migrate';\n```\n\n----------------------------------------\n\nTITLE: SQLite Generated Columns - TypeScript\nDESCRIPTION: Demonstrates defining generated columns in SQLite using Drizzle ORM. The example shows the usage of `generatedAlwaysAs` to define a generated column that is either `stored` or `virtual`. It highlights the similarities in syntax to MySQL's generated columns.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nIn case you don't need to reference any columns from your table, you can use just `sql` template or a `string` in `.generatedAlwaysAs()`\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for Views (PostgreSQL)\nDESCRIPTION: This SQL code snippet shows the generated SQL for the 'simpleView' and 'materializedView' as defined in the previous TypeScript code. It showcases how Drizzle Kit translates the TypeScript definitions into corresponding SQL view and materialized view creation statements for PostgreSQL.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.26.0.md#_snippet_3\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE IF NOT EXISTS \"users\" (\n  \"id\" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,\n  \"username\" text NOT NULL,\n  \"age\" integer,\n  CONSTRAINT \"age_check\" CHECK (\"users\".\"age\" > 21)\n);\n\nCREATE VIEW \"public\".\"simple_users_view\" AS (select \"id\", \"username\", \"age\" from \"users\");\n\nCREATE MATERIALIZED VIEW \"public\".\"materialized_users_view\" AS (select \"id\", \"username\", \"age\" from \"users\");\n\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Boolean Type for MySQL\nDESCRIPTION: This snippet defines a custom Boolean data type for MySQL using the `customType` function from Drizzle ORM. It specifies the data type as 'boolean' and includes a `fromDriver` method to handle boolean conversion from the driver.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/docs/custom-types.lite.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst customBoolean = customType<{ data: boolean }>({  dataType() {\n    return 'boolean';\n  },\n  fromDriver(value) {\n    if (typeof value === 'boolean') {\n      return value;\n    }\n    return value === 1;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining PostgreSQL Sequences (No Params)\nDESCRIPTION: This code snippet demonstrates how to define a PostgreSQL sequence using `pgSequence` without specifying any parameters. The `customSequence` variable represents the sequence definition.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.32.0-beta.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgSchema, pgSequence } from \"drizzle-orm/pg-core\";\n\n// No params specified\nexport const customSequence = pgSequence(\"name\");\n```\n\n----------------------------------------\n\nTITLE: Enforce Update with Where - Config 2\nDESCRIPTION: This JSON snippet demonstrates configuring the 'enforce-update-with-where' rule with the `drizzleObjectName` option. The `drizzleObjectName` option is set to `['db']`, which means the rule only triggers if the `update` method is called on an object named `db`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/eslint-plugin-drizzle/readme.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-update-with-where\": [\"error\", { \"drizzleObjectName\": [\"db\"] }],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MySQL Schema Definition - Typescript\nDESCRIPTION: This snippet defines a MySQL table schema using `drizzle-orm/mysql-core`. It includes columns of types `text`, `char`, `varchar`, `binary`, and `varbinary`. The default generators for these types will output different values with the same seed number after the upgrade to v2.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// schema.ts\nimport * as p from 'drizzle-orm/mysql-core'\n\nexport const table = p.mysqlTable('table', {\n  column1: p.text(),\n  column2: p.char(),\n  column3: p.varchar({ length: 256 }),\n  column4: p.binary(),\n  column5: p.varbinary({ length: 256 }),\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling Default Query Logging in SQLite\nDESCRIPTION: This example demonstrates how to enable default query logging in Drizzle ORM by passing `{ logger: true }` to the `drizzle` function. This will log all SQL queries executed by Drizzle ORM.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nimport { drizzle } from 'drizzle-orm/better-sqlite3';\n\nconst db = drizzle(sqlite, { logger: true });\n```\n\n----------------------------------------\n\nTITLE: ESLint Plugin: All Config\nDESCRIPTION: Shows how to extend the ESLint configuration with the `all` config provided by the `eslint-plugin-drizzle`. This includes all rules (except deprecated ones) and requires configuring the parser and plugins.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nroot: true\nextends:\n  - \"plugin:drizzle/all\"\nparser: '@typescript-eslint/parser'\nparserOptions:\n  project: './tsconfig.json'\nplugins:\n  - drizzle\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-delete-with-where - Example Config 2\nDESCRIPTION: Example configuration for the `enforce-delete-with-where` ESLint rule specifying `drizzleObjectName`. This limits the rule to only trigger on `delete` calls originating from the specified object.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-delete-with-where\": [\"error\", { \"drizzleObjectName\": [\"db\"] }],\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Table Names - TypeScript\nDESCRIPTION: This snippet demonstrates how to customize table names in Drizzle ORM using `sqliteTableCreator` by adding a prefix. This allows for different environments or applications to share a database.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sqliteTableCreator } from 'drizzle-orm/sqlite-core';\n\nconst sqliteTable = sqliteTableCreator((name) => `myprefix_${name}`);\n\nconst users = sqliteTable('users', {\n  id: int('id').primaryKey(),\n  name: text('name').notNull(),\n});\n```\n\n----------------------------------------\n\nTITLE: LibSQL Batch API Response Type\nDESCRIPTION: Defines the expected structure of the response from the LibSQL batch API. It is an array of result sets, where each element corresponds to the result of a specific operation in the batch.  Dependencies include the Drizzle ORM types.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.28.6.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype BatchResponse = [\n\t{\n\t\tid: number;\n\t}[],\n\tResultSet,\n\t{\n\t\tid: number;\n\t\tname: string;\n\t\tverified: number;\n\t\tinvitedBy: number | null;\n\t}[],\n\t{\n\t\tid: number;\n\t\tname: string;\n\t\tverified: number;\n\t\tinvitedBy: number | null;\n\t}[],\n\t{\n\t\tid: number;\n\t\tinvitedBy: number | null;\n\t}[],\n];\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Import Path Update - Drizzle ORM\nDESCRIPTION: This snippet demonstrates the updated import path for PostgreSQL-related functionalities in Drizzle ORM after merging dialect-specific packages. It shows how to import from `drizzle-orm/pg-core`, `drizzle-orm/node-postgres`, `drizzle-orm/neon`, and `drizzle-orm/postgres.js` instead of the legacy `drizzle-orm-pg` package.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.17.0.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/pg-core'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/node-postgres'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/neon'\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { ... } from 'drizzle-orm/postgres.js'\n```\n\n----------------------------------------\n\nTITLE: Defining MySQL Enums (Before)\nDESCRIPTION: This code shows the old, incorrect way of defining MySQL enums in Drizzle.  This method will not work and should be replaced with the updated approach.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-mysql/0.15.1.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport const popularityEnum = mysqlEnum('popularity', ['unknown', 'known', 'popular']);\npopularityEnum('column_name');\n```\n\n----------------------------------------\n\nTITLE: Customizing Column Data Type - SQLite\nDESCRIPTION: Demonstrates how to customize the data type of a column using the .$type() method in Drizzle ORM with SQLite. This is useful for scenarios involving branded types.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = sqliteTable('users', {\n  id: integer('id').$type<UserId>().primaryKey(),\n  jsonField: blob('json_field').$type<Data>(),\n});\n```\n\n----------------------------------------\n\nTITLE: Fixing defaultNow() method query generation in drizzle-orm-sqlite\nDESCRIPTION: Corrects the SQL generated by the `defaultNow()` method by adding missing parentheses. The fix ensures that the default value is correctly formatted as a cast expression.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm-sqlite/0.14.3.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncast((julianday('now') - 2440587.5)*86400000 as integer)\n```\n\nLANGUAGE: sql\nCODE:\n```\n(cast((julianday('now') - 2440587.5)*86400000 as integer))\n```\n\n----------------------------------------\n\nTITLE: Installing Drizzle Kit using npm\nDESCRIPTION: Installs Drizzle Kit as a development dependency using npm. This allows developers to use the Drizzle Kit CLI for generating and managing database migrations in their projects.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-kit/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install -D drizzle-kit\n```\n\n----------------------------------------\n\nTITLE: Querying and Parsing Data with TypeBox (TypeScript)\nDESCRIPTION: This snippet showcases querying data from a SingleStore table using Drizzle ORM and parsing the result using TypeBox schema validation. It highlights a potential error where the query does not return all fields defined in the schema, leading to parsing failures. The second part demonstrates a successful parse when all fields are present in the query result.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-typebox/0.2.1.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);\nconst parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]);  // Error: `age` is not returned in the above query\n\nconst rows = await db.select().from(users).limit(1);\nconst parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]);  // Will parse successfully\n```\n\n----------------------------------------\n\nTITLE: Describing Existing Views in SQLite\nDESCRIPTION: This example shows how to describe existing views without defining the query itself.  This is useful when you have read-only access to a view and only need to define its schema for type safety.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nconst newYorkers = sqliteView('new_yorkers', {\n  userId: integer('user_id').notNull(),\n  cityId: integer('city_id'),\n}).existing();\n```\n\n----------------------------------------\n\nTITLE: Configure casing in Drizzle Kit\nDESCRIPTION: This TypeScript code snippet demonstrates how to configure the `casing` parameter in `drizzle-kit` configuration file to ensure the naming strategy is applied during migrations generation.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.25.0.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from \"drizzle-kit\";\n\nexport default defineConfig({\n  dialect: \"postgresql\",\n  schema: \"./schema.ts\",\n  dbCredentials: {\n    url: \"postgresql://postgres:password@localhost:5432/db\",\n  },\n  casing: \"snake_case\",\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Table Names with Table Creators in Drizzle ORM (TypeScript)\nDESCRIPTION: Illustrates the use of 'table creators' to customize table names in Drizzle ORM. This allows adding prefixes or other modifications to table names. Requires importing `mysqlTableCreator` from `drizzle-orm/mysql-core`.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.23.0.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mysqlTableCreator } from 'drizzle-orm/mysql-core';\n\nconst mysqlTable = mysqlTableCreator((name) => `myprefix_${name}`);\n\nconst users = mysqlTable('users', {\n  id: int('id').primaryKey(),\n  name: text('name').notNull(),\n});\n\n// Users table is a normal table, but its name is `myprefix_users` in runtime\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of drizzle-seed\nDESCRIPTION: This code demonstrates the basic usage of the `drizzle-seed` function to create 10 users with random names and IDs. It imports necessary modules from `drizzle-orm` and `drizzle-seed`, defines a `users` table schema, and calls the `seed` function with the database connection and the schema. The code assumes that `process.env.DATABASE_URL` is set.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.36.4.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { pgTable, integer, text } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\nimport { seed } from \"drizzle-seed\";\n\nconst users = pgTable(\"users\", {\n  id: integer().primaryKey(),\n  name: text().notNull(),\n});\n\nasync function main() {\n  const db = drizzle(process.env.DATABASE_URL!);\n  await seed(db, { users });\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Schema Definition - Typescript\nDESCRIPTION: This snippet defines a PostgreSQL table schema using `drizzle-orm/pg-core`. It includes columns of types `text`, `varchar`, and `char`.  The default generators for these types will be affected by the string generator changes in version 2.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// schema.ts\nimport * as p from 'drizzle-orm/pg-core'\n\nexport const table = p.pgTable('table', {\n  column1: p.text(),\n  column2: p.varchar(),\n  column3: p.char()\n});\n```\n\n----------------------------------------\n\nTITLE: Refining Fields in Insert Schema - TypeScript\nDESCRIPTION: Illustrates how to refine a field's schema properties within the insert schema. In this example, it modifies the `id` field to be `atLeast(1)` and overrides the `role` field type to `'string'`. Refining fields before they are made nullable/optional ensures validation logic is applied.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-arktype/0.1.2.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema\nconst insertUserSchema = createInsertSchema(users, {\n\tid: (schema) => schema.atLeast(1),\n\trole: type('string'),\n});\n```\n\n----------------------------------------\n\nTITLE: PostgreSQL Index Declaration (Old API) - TypeScript\nDESCRIPTION: This snippet shows the previous (incorrect) Drizzle+PostgreSQL indexes API.  It illustrates how indexes were declared before the API was updated to better align with PostgreSQL documentation.  This old API had limitations in defining SQL expressions and handling column-specific modifiers.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.31.0.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Index declaration reference\nindex('name')\n  .on(table.column1, table.column2, ...) or .onOnly(table.column1, table.column2, ...)\n  .concurrently()\n  .using(sql``) // sql expression\n  .asc() or .desc()\n  .nullsFirst() or .nullsLast()\n  .where(sql``) // sql expression\n```\n\n----------------------------------------\n\nTITLE: Run drizzle-kit export with SQL flag (Bash)\nDESCRIPTION: This command executes the `drizzle-kit export` command with the `--sql` flag.  Although `--sql` is the only supported option currently, it explicitly defines the output format as SQL.  This is the same output as running `npx drizzle-kit export` without the flag.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-kit/0.30.1.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx drizzle-kit export --sql\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-update-with-where - Example Code 2\nDESCRIPTION: Example Typescript code showing the effect of `enforce-update-with-where` ESLint rule when `drizzleObjectName` is defined.  The ESLint rule will only be triggered on Drizzle's `update` method, and not on the custom class's `update` method.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyClass {\n  public update() {\n    return {}\n  }\n}\n\nconst myClassObj = new MyClass();\n\n// ---> Will NOT be triggered by ESLint Rule\nmyClassObj.update()\n\nconst db = drizzle(...)\n// ---> Will be triggered by ESLint Rule\ndb.update()\n```\n\n----------------------------------------\n\nTITLE: Refining Table with String Generator - Typescript\nDESCRIPTION: This snippet shows how to use the `string` generator within the `refine` method to define a table schema.  The output of this function will be different with the same seed number from previous versions. It is recommended to upgrade to v2.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-seed/0.2.1.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nawait seed(db, { table }).refine((f) => ({\n  table: {\n    columns: {\n      // this function will output different values with the same `seed` number from previous version\n      column1: f.string(),\n    }\n  }\n}))\n```\n\n----------------------------------------\n\nTITLE: ESLint Rule: enforce-delete-with-where - Example Config 1\nDESCRIPTION: Example configuration for the `enforce-delete-with-where` ESLint rule without specifying `drizzleObjectName`.  This will trigger the rule on any `.delete()` method call, regardless of the object it's called on.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.29.1.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"rules\": {\n    \"drizzle/enforce-delete-with-where\": [\"error\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Drizzle Kit tests - Bash\nDESCRIPTION: This command navigates to the drizzle-kit directory and runs the test suite using pnpm. Assumes you are in the root directory of the repository. Requires pnpm to be installed.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd drizzle-kit && pnpm test\n```\n\n----------------------------------------\n\nTITLE: Selecting all users with Drizzle ORM\nDESCRIPTION: This code snippet demonstrates how to select all users from a database using Drizzle ORM. It shows the basic `findMany` function call.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.26.0.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst users = await db.query.users.findMany();\n```\n\n----------------------------------------\n\nTITLE: Installing Node using nvm - Bash\nDESCRIPTION: This snippet installs Node.js using the Node Version Manager (nvm). It downloads the nvm install script, installs nvm, and then installs and uses Node.js version 18.13.0. Requires curl to be installed.  Ensure nvm is properly installed in your environment before running.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash\nnvm install 18.13.0\nnvm use 18.13.0\n```\n\n----------------------------------------\n\nTITLE: Configuring wrangler.toml for D1\nDESCRIPTION: This snippet configures the wrangler.toml file for Cloudflare D1 integration. It specifies the project name, main entry point, compatibility date, Node.js compatibility, and the D1 database binding, name, and ID.  The `database_id` and `database_name` must match the actual database created in Cloudflare.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/cloudflare-d1/README.md#_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n## your wrangler.toml will look something like this\n\nname = \"YOUR PROJECT NAME\"\nmain = \"src/index.ts\"\ncompatibility_date = \"2022-11-07\"\nnode_compat = true\n\n[[ d1_databases ]]\nbinding = \"DB\"\ndatabase_name = \"YOUR DB NAME\"\ndatabase_id = \"YOUR DB ID\"\n```\n\n----------------------------------------\n\nTITLE: Installing Drizzle ORM via npm\nDESCRIPTION: This command installs the Drizzle ORM package using npm. Drizzle ORM is required to interact with the database in a type-safe manner.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/examples/cloudflare-d1/README.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install drizzle-orm\n```\n\n----------------------------------------\n\nTITLE: Generated SQL for PostgreSQL Array Types\nDESCRIPTION: This SQL code is generated by Drizzle Kit based on the TypeScript code defining PostgreSQL tables with array types. It demonstrates how Drizzle Kit translates the Drizzle ORM schema into SQL `CREATE TABLE` statements, correctly defining the array columns with appropriate dimensions.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/changelogs/drizzle-orm/0.21.0.md#_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE sal_emp (\n  name            text,\n  pay_by_quarter  integer[],\n  schedule        text[][]\n);\n\nCREATE TABLE tictactoe (\n  squares   integer[3][3]\n);\n```\n\n----------------------------------------\n\nTITLE: Single Schema File Example - Plaintext\nDESCRIPTION: Illustrates a project structure where the database schema is defined in a single file.\nSOURCE: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/sqlite-core/README.md#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n <project root>\n   src\n      db\n        schema.ts\n```"
  }
]