[
  {
    "owner": "roboflow",
    "repo": "trackers",
    "content": "TITLE: Implementing Object Tracking with SORT Tracker\nDESCRIPTION: Example code demonstrating how to combine an object detector (RFDETR) with SORT tracker for video processing. Uses supervision library for visualization and annotation of tracked objects.\nSOURCE: https://github.com/roboflow/trackers/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport supervision as sv\nfrom rfdetr import RFDETRBase\nfrom trackers import SORTTracker\n\nmodel = RFDETRBase()\ntracker = SORTTracker()\nannotator = sv.LabelAnnotator(text_position=sv.Position.CENTER)\n\ndef callback(frame, _):\n    detections = model.predict(frame)\n    detections = tracker.update(detections)\n    return annotator.annotate(frame, detections, detections.tracker_id)\n\nsv.process_video(\n    source_path=<SOURCE_VIDEO_PATH>,\n    target_path=<TARGET_VIDEO_PATH>,\n    callback=callback,\n)\n```\n\n----------------------------------------\n\nTITLE: Computing IoU (Intersection over Union) for Bounding Boxes in Python\nDESCRIPTION: Calculates the Intersection over Union between two sets of bounding boxes. Takes arrays of bounding boxes and returns a matrix of IoU values. This is a core function for associating detections with tracked objects.\nSOURCE: https://github.com/roboflow/trackers/blob/main/docs/trackers/utils/sort_utils.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef iou_batch(bb_test, bb_gt):\n    \"\"\"\n    From SORT: Computes IOU between two bboxes in the form [x1,y1,x2,y2]\n    \"\"\"\n    bb_gt = np.expand_dims(bb_gt, 0)\n    bb_test = np.expand_dims(bb_test, 1)\n    \n    xx1 = np.maximum(bb_test[..., 0], bb_gt[..., 0])\n    yy1 = np.maximum(bb_test[..., 1], bb_gt[..., 1])\n    xx2 = np.minimum(bb_test[..., 2], bb_gt[..., 2])\n    yy2 = np.minimum(bb_test[..., 3], bb_gt[..., 3])\n    w = np.maximum(0., xx2 - xx1)\n    h = np.maximum(0., yy2 - yy1)\n    wh = w * h\n    o = wh / ((bb_test[..., 2] - bb_test[..., 0]) * (bb_test[..., 3] - bb_test[..., 1])\n              + (bb_gt[..., 2] - bb_gt[..., 0]) * (bb_gt[..., 3] - bb_gt[..., 1]) - wh)\n```\n\n----------------------------------------\n\nTITLE: Implementing Linear Assignment for Data Association in Python\nDESCRIPTION: A linear assignment implementation used for associating detections with tracked objects. Uses the Hungarian algorithm to solve the assignment problem by maximizing the IoU between detections and trackers.\nSOURCE: https://github.com/roboflow/trackers/blob/main/docs/trackers/utils/sort_utils.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef linear_assignment(cost_matrix):\n    try:\n        import lap\n        _, x, y = lap.lapjv(cost_matrix, extend_cost=True)\n        return np.array([[y[i],i] for i in range(len(y)) if y[i]>=0])\n    except ImportError:\n        from scipy.optimize import linear_sum_assignment\n        x, y = linear_sum_assignment(cost_matrix)\n        return np.array(list(zip(x, y)))\n```\n\n----------------------------------------\n\nTITLE: Computing Mahalanobis Distance for Detection-Tracker Association in Python\nDESCRIPTION: Calculates the Mahalanobis distance between detections and trackers. This function provides an alternative association metric that considers both position and velocity information in the Kalman filter state.\nSOURCE: https://github.com/roboflow/trackers/blob/main/docs/trackers/utils/sort_utils.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef md_cost(detections, trackers, measured_parameters=4, threshold=0.3):\n    \"\"\"\n    detections: Nx4 np.array of detections - [x1, y1, x2, y2]\n    trackers: Trackers class with states (x) and covariances (P)\n    \"\"\"\n    if len(trackers) == 0:\n        return np.empty((0, 3)), np.arange(len(detections)), np.empty((0, 5))\n    \n    Y = np.array([convert_bbox_to_z(det).flatten()[:measured_parameters] for det in detections])\n    Ys = np.array([np.diag(np.ones(measured_parameters)) for _ in range(len(detections))])\n\n    # Use x from KalmanBoxTracker instances\n    X = np.array([trk.x[:measured_parameters].flatten() for trk in trackers])\n    # Fetch P from KalmanBoxTracker instances\n    P = np.array([trk.P[:measured_parameters, :measured_parameters] for trk in trackers])\n\n    # Compute Mahalanobis distance\n    md_matrix = np.zeros((len(detections), len(trackers)))\n    for d, (dy, ds) in enumerate(zip(Y, Ys)):\n        for t, (tx, tP) in enumerate(zip(X, P)):\n            try:\n                # Mahalanobis distance computation\n                md_matrix[d, t] = spatial.distance.mahalanobis(dy, tx, np.linalg.inv(tP + ds))\n            except:\n                md_matrix[d, t] = float('inf')\n\n    # Hungarian algorithm to solve the assignment problem\n    if min(md_matrix.shape) > 0:\n        a = (md_matrix < threshold).astype(np.int32)\n        if a.sum(1).max() == 1 and a.sum(0).max() == 1:\n            matched_indices = np.stack(np.where(a), axis=1)\n        else:\n            matched_indices = linear_assignment(md_matrix)\n    else:\n        matched_indices = np.empty(shape=(0, 2))\n\n    unmatched_detections = []\n    for d, det in enumerate(detections):\n        if d not in matched_indices[:, 0]:\n            unmatched_detections.append(d)\n            \n    unmatched_trackers = []\n    for t, trk in enumerate(trackers):\n        if t not in matched_indices[:, 1]:\n            unmatched_trackers.append(t)\n\n    # Filter out matched with high Mahalanobis distance\n    matches = []\n    for m in matched_indices:\n        if md_matrix[m[0], m[1]] > threshold:\n            unmatched_detections.append(m[0])\n            unmatched_trackers.append(m[1])\n        else:\n            matches.append(m.reshape(1, 2))\n            \n    if len(matches) == 0:\n        matches = np.empty((0, 2), dtype=int)\n    else:\n        matches = np.vstack(matches)\n        \n    return matches, np.array(unmatched_detections), np.array(unmatched_trackers)\n```\n\n----------------------------------------\n\nTITLE: Computing IoU Distance for Detection-Tracker Association in Python\nDESCRIPTION: Calculates the IoU-based distance (cost) matrix between detections and trackers. This function is used in the assignment process to determine which detection corresponds to which tracked object.\nSOURCE: https://github.com/roboflow/trackers/blob/main/docs/trackers/utils/sort_utils.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef iou_cost(detections, trackers, iou_threshold=0.3):\n    \"\"\"\n    detections: Nx4 np.array of detections - [x1, y1, x2, y2]\n    trackers: Mx4 np.array of trackers - [x1, y1, x2, y2]\n    \"\"\"\n    if len(trackers) == 0:\n        return np.empty((0, 3)), np.arange(len(detections)), np.empty((0, 5))\n    \n    iou_matrix = iou_batch(detections, trackers)\n\n    if min(iou_matrix.shape) > 0:\n        a = (iou_matrix > iou_threshold).astype(np.int32)\n        if a.sum(1).max() == 1 and a.sum(0).max() == 1:\n            matched_indices = np.stack(np.where(a), axis=1)\n        else:\n            matched_indices = linear_assignment(-iou_matrix)\n    else:\n        matched_indices = np.empty(shape=(0, 2))\n\n    unmatched_detections = []\n    for d, det in enumerate(detections):\n        if d not in matched_indices[:, 0]:\n            unmatched_detections.append(d)\n            \n    unmatched_trackers = []\n    for t, trk in enumerate(trackers):\n        if t not in matched_indices[:, 1]:\n            unmatched_trackers.append(t)\n\n    # Filter out matched with low IOU\n    matches = []\n    for m in matched_indices:\n        if iou_matrix[m[0], m[1]] < iou_threshold:\n            unmatched_detections.append(m[0])\n            unmatched_trackers.append(m[1])\n        else:\n            matches.append(m.reshape(1, 2))\n            \n    if len(matches) == 0:\n        matches = np.empty((0, 2), dtype=int)\n    else:\n        matches = np.vstack(matches)\n        \n    return matches, np.array(unmatched_detections), np.array(unmatched_trackers)\n```\n\n----------------------------------------\n\nTITLE: Converting Between Bounding Box Formats in Python\nDESCRIPTION: Utility functions for converting between different bounding box formats. Includes conversion to center coordinates with width and height, and conversion from this format back to corner coordinates.\nSOURCE: https://github.com/roboflow/trackers/blob/main/docs/trackers/utils/sort_utils.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef convert_bbox_to_z(bbox):\n    \"\"\"\n    Takes a bounding box in the form [x1,y1,x2,y2] and returns z in the form\n    [x,y,s,r] where x,y is the centre of the box and s is the scale/area and r is\n    the aspect ratio\n    \"\"\"\n    w = bbox[2] - bbox[0]\n    h = bbox[3] - bbox[1]\n    x = bbox[0] + w/2.\n    y = bbox[1] + h/2.\n    s = w * h    #scale is just area\n    r = w / float(h)\n    return np.array([x, y, s, r]).reshape((4, 1))\n\n\ndef convert_x_to_bbox(x, score=None):\n    \"\"\"\n    Takes a bounding box in the centre form [x,y,s,r] and returns it in the form\n    [x1,y1,x2,y2] where x1,y1 is the top left and x2,y2 is the bottom right\n    \"\"\"\n    w = np.sqrt(x[2] * x[3])\n    h = x[2] / w\n    if(score==None):\n        return np.array([x[0]-w/2.,x[1]-h/2.,x[0]+w/2.,x[1]+h/2.]).reshape((1,4))\n    else:\n        return np.array([x[0]-w/2.,x[1]-h/2.,x[0]+w/2.,x[1]+h/2.,score]).reshape((1,5))\n```\n\n----------------------------------------\n\nTITLE: Google-Style Docstring Example with Type Hints\nDESCRIPTION: Example function showing proper Python type hints and Google-style docstring format with parameter descriptions, return type explanation, and usage example.\nSOURCE: https://github.com/roboflow/trackers/blob/main/CONTRIBUTING.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef sample_function(param1: int, param2: int = 10) -> bool:\n    \"\"\"\n    Provides a brief description of function behavior.\n\n    Args:\n        param1 (int): Explanation of the first parameter.\n        param2 (int): Explanation of the second parameter, defaulting to 10.\n\n    Returns:\n        bool: True if the operation succeeds, otherwise False.\n\n    Examples:\n        >>> sample_function(5, 10)\n        True\n    \"\"\"\n    return param1 == param2\n```\n\n----------------------------------------\n\nTITLE: Installing Trackers Package via pip\nDESCRIPTION: Command to install the trackers package using pip package manager. Requires Python 3.9 or higher.\nSOURCE: https://github.com/roboflow/trackers/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install trackers\n```\n\n----------------------------------------\n\nTITLE: Installing Trackers from Source\nDESCRIPTION: Command to install the latest development version of trackers directly from GitHub repository.\nSOURCE: https://github.com/roboflow/trackers/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install git+https://github.com/roboflow/trackers.git\n```\n\n----------------------------------------\n\nTITLE: Committing and Pushing Changes to Git\nDESCRIPTION: Commands for adding, committing with a descriptive message, and pushing changes to the remote repository.\nSOURCE: https://github.com/roboflow/trackers/blob/main/CONTRIBUTING.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit add .\ngit commit -m \"A brief description of your changes\"\ngit push -u origin your-descriptive-name\n```\n\n----------------------------------------\n\nTITLE: Creating a Feature Branch in Git\nDESCRIPTION: Command for creating and checking out a new feature branch with a descriptive name in Git.\nSOURCE: https://github.com/roboflow/trackers/blob/main/CONTRIBUTING.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b feature/your-descriptive-name\n```\n\n----------------------------------------\n\nTITLE: CLA Signing Comment Format\nDESCRIPTION: The exact comment text to add to pull requests to sign the Contributor License Agreement.\nSOURCE: https://github.com/roboflow/trackers/blob/main/CONTRIBUTING.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nI have read the CLA Document and I sign the CLA.\n```"
  }
]