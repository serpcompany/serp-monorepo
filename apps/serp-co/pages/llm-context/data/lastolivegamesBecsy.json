[
  {
    "owner": "lastolivegames",
    "repo": "becsy",
    "content": "TITLE: Creating ECS Entities and Adding Components (JavaScript)\nDESCRIPTION: Demonstrates creating new entities within the world and attaching instances of defined components. Entities are created with default component values or initialized with specific data provided during creation.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nworld.createEntity(Position);\nfor (let i = 0; i < 10; i++) {\n  world.createEntity(\n    Acceleration,\n    Position, {x: Math.random() * 10, y: Math.random() * 10, z: 0}\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Components on Entities in Becsy with TypeScript\nDESCRIPTION: Demonstrates reading from components for safe, read-only usage, and writing to components to modify data on an entity. It features component classes declared with decorators and field types. The read method returns a component instance for inspection without mutation unless performance mode is enabled, while write allows modification. The snippet assumes an entity instance and component classes. Important constraints include not retaining component handles beyond immediate usage and understanding that writes mark components as changed, influencing reactive queries.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n@component class ComponentA {\n  @field.int32 declare value: number;\n}\n@component class ComponentB {\n  @field.int32 declare value: number;\n}\n\n// in a system, given an entity:\nentity.write(ComponentA).value += entity.read(ComponentB).value;\n```\n\n----------------------------------------\n\nTITLE: Defining Components and Systems with Becsy (JavaScript)\nDESCRIPTION: This JavaScript snippet defines two components, `Acceleration` and `Position`, using static schema properties to specify their structure and data types. It also defines two systems: `PositionLogSystem`, which reads and logs the `Position` of entities, and `MovableSystem`, which reads `Acceleration`, writes `Position`, and updates position based on acceleration and delta time. The code sets up an ECS world, creates entities, and runs the simulation using `requestAnimationFrame`.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\n```js\nimport {System, Type, World} from '@lastolivegames/becsy';\n\nclass Acceleration {\n  static schema = {\n    value: {type: Type.float64, default: 0.1}\n  };\n}\n\nclass Position {\n  static schema = {\n    x: {type: Type.float64},\n    y: {type: Type.float64},\n    z: {type: Type.float64}\n  };\n}\n\nclass PositionLogSystem extends System {\n  entities = this.query(q => q.current.with(Position));\n\n  execute() {\n    for (const entity of this.entities.current) {\n      const pos = entity.read(Position);\n      console.log(\n        `Entity with ordinal ${entity.ordinal} has component ` +\n        `Position={x: ${pos.x}, y: ${pos.y}, z: ${pos.z}}`\n      );\n    }\n  }\n}\n\nclass MovableSystem extends System {\n  entities = this.query(\n    q => q.current.with(Acceleration).read.and.with(Position).write);\n\n  execute() {\n    for (const entity of this.entities.current) {\n      const acceleration = entity.read(Acceleration).value;\n      const position = entity.write(Position);\n      position.x += acceleration * this.delta;\n      position.y += acceleration * this.delta;\n      position.z += acceleration * this.delta;\n    }\n  }\n}\n\nconst world = await World.create({\n  defs: [Acceleration, Position, PositionLogSystem, MovableSystem]\n});\n\n\nworld.createEntity(Position);\nfor (let i = 0; i < 10; i++) {\n  world.createEntity(\n    Acceleration,\n    Position, {x: Math.random() * 10, y: Math.random() * 10, z: 0}\n  );\n}\n\nasync function run() {\n  await world.execute();\n  requestAnimationFrame(run);\n}\n\nrun();\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Becsy System (TypeScript/JavaScript)\nDESCRIPTION: Demonstrates defining a simple Becsy system by extending the `System` class and implementing the `execute` method. The TypeScript version shows the optional `@system` decorator for automatic world registration, while both require manual registration via `world.defs` if the decorator is omitted or in JavaScript.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@system class MySystem extends System {\n  execute(): void {\n    // do some work here\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass MySystem extends System {\n  execute(): void {\n    // do some work here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Components to Entities in Becsy with TypeScript and JavaScript\nDESCRIPTION: Illustrates how to add one or multiple components to an existing entity after creation. The snippet includes component class definitions with fields declared using decorators in TypeScript or a schema in JavaScript. The add methods accept component types and optional field initial values, matching the createEntity pattern. Attempting to add the same component twice triggers an error. Required dependencies include the component classes and an entity instance. The example inputs are the component classes and field data; the output is the mutation of the entity's components.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@component class ComponentA {\n  @field.int32 declare value: number;\n}\n@component class ComponentB {\n  @field.dynamicString(20) declare message: string;\n}\n\n// in a system, given an entity:\nentity.add(ComponentA, {value: 10});\n// or add multiple components at once:\nentity.addAll(ComponentA, {value: 10}, ComponentB, {message: 'hello'});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Entity Query in Becsy System (JavaScript)\nDESCRIPTION: Shows how to define an entity query in a JavaScript system class, selecting entities that have an Enemy component and lack a Dead component, using Becsy's query syntax. Requires the Becsy library and assumes Enemy and Dead components are registered. The resulting query is used in the execute method to iterate the matching entities.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass SystemA extends System {\n  constructor() {\n    // Query for all entities with an Enemy component but no Dead component.\n    this.activeEnemies = this.query(\n      q => q.current.with(Enemy).and.withAny(stateEnum).but.without(Dead));\n  }\n\n  execute() {\n    for (const entity of this.activeEnemies.current) {\n      const enemy = entity.read(Enemy);  // guaranteed to have an Enemy component\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Entities in Becsy using TypeScript and JavaScript\nDESCRIPTION: Shows how to create entities on a world object with specified initial components and optional field values. It demonstrates that entities can be created with or without components as placeholders. The snippet uses both TypeScript and JavaScript syntaxes to initialize entities with components. Dependencies include a properly configured Becsy world and component definitions. Inputs include component types and optional initial field values; the output is an entity instance with assigned components.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nworld.createEntity(ComponentFoo, {foo: 'bar', baz: 42}, ComponentBar);\n```\n\n----------------------------------------\n\nTITLE: Creating Becsy ECS World with Component and System Definitions (JavaScript)\nDESCRIPTION: Initializes the ECS world, explicitly registering both the defined component types (`Acceleration`, `Position`) and the system classes (`PositionLogSystem`, `MovableSystem`) by passing them in the `defs` array to the `World.create` method. This allows the world to instantiate and manage both components and systems.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_14\n\nLANGUAGE: js\nCODE:\n```\nconst world = await World.create({\n  defs: [Acceleration, Position, PositionLogSystem, MovableSystem]\n});\n```\n\n----------------------------------------\n\nTITLE: Creating ECS Entities and Adding Components (TypeScript)\nDESCRIPTION: Demonstrates creating new entities within the world and attaching instances of defined components. Entities are created with default component values or initialized with specific data provided during creation.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nworld.createEntity(Position);\nfor (let i = 0; i < 10; i++) {\n  world.createEntity(\n    Acceleration,\n    Position, {x: Math.random() * 10, y: Math.random() * 10, z: 0}\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Running Becsy ECS World Execution Loop (TypeScript)\nDESCRIPTION: Sets up a continuous execution loop using `requestAnimationFrame`. In each frame, `world.execute()` is called asynchronously, triggering all registered systems to run and process entities based on their defined queries.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_16\n\nLANGUAGE: ts\nCODE:\n```\nasync function run() {\n  // Run all the systems\n  await world.execute();\n  requestAnimationFrame(run);\n}\n\nrun();\n```\n\n----------------------------------------\n\nTITLE: Implementing Movement System - TypeScript\nDESCRIPTION: This TypeScript snippet implements the movement system which updates entity positions based on their velocity and delta time, using the `becsy` ECS library. It defines a `Movement` system that queries for entities with both `Position` and `Velocity` components. The `execute` method calculates and applies the position change using `this.delta`.  This code reads velocity from Velocity and writes to Position.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {component, field, system, System, Type} from '@lastolivegames/becsy';\n\n@component class Position {/* ... */}\n@component class Velocity {/* ... */}\n@component class DOMRenderable {/* ... */}\n\n@system export class VelocityInputController extends System {/* ... */}\n\n@system export class Movement extends System {\n  // In this query we're looking for every entity with both a `Position` and a `Velocity` component,\n  // but while we declare that we'll be writing to `Position` we'll only be reading from `Velocity`.\n  // Reading from `Velocity` will automatically make this system run after `VelocityInputController`\n  // which writes it, and writing to `Position` will put it before the `Renderer` which reads it.\n  // The order that systems are declared in doesn't matter.\n  private readonly movables =\n    this.query(q => q.current.with(Velocity).and.with(Position).write);\n\n  execute(): void {\n    for (const movable of this.movables.current) {\n      // We retrive both velocity (to read) and position (to write) from our entities.\n      const velocity = movable.read(Velocity);\n      const position = movable.write(Position);\n      // In the execute method, a system has access to `this.delta`, which is the delta time between\n      // the current frame and the previous one.  This allows us to calculate a stable movement\n      // regardless of the intervals between our frames.  For more on that see\n      // https://drewcampbell92.medium.com/understanding-delta-time-b53bf4781a03.\n      position.x += this.delta * velocity.vx;\n      position.y += this.delta * velocity.vy;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Entity Query in Becsy System (TypeScript)\nDESCRIPTION: Demonstrates how to define a query within a TypeScript @system class to select entities containing specific components (e.g., Enemy but not Dead) using Becsy's query DSL. This snippet requires the Becsy ECS library and depends on systemized entity/component definitions. The query automatically updates before each system execution and exposes an iterable array of matching entities.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n@system class SystemA extends System {\n  // Query for all entities with an Enemy component but no Dead component.\n  private activeEnemies = this.query(\n    q => q.current.with(Enemy).and.withAny(stateEnum).but.without(Dead));\n\n  execute(): void {\n    for (const entity of this.activeEnemies.current) {\n      const enemy = entity.read(Enemy);  // guaranteed to have an Enemy component\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Movement System - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates a movement system, updating entities' positions by integrating velocity and delta time using the becsy framework. It defines a `Movement` class that queries entities with both `Position` and `Velocity` components. The `execute` method reads the velocity, and updates the position using delta time.  The order of system execution is implicitly managed by `becsy` through component writes and reads.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {System, Type} from '@lastolivegames/becsy';\n\nclass Position {/* ... */}\nclass Velocity {/* ... */}\nclass DOMRenderable {/* ... */}\n\nclass VelocityInputController extends System {/* ... */}\n\nclass Movement extends System {\n  // In this query we're looking for every entity with both a `Position` and a `Velocity` component,\n  // but while we declare that we'll be writing to `Position` we'll only be reading from `Velocity`.\n  // Reading from `Velocity` will automatically make this system run after `VelocityInputController`\n  // which writes it, and writing to `Position` will put it before the `Renderer` which reads it.\n  // The order that systems are declared in doesn't matter.\n  movables = this.query(q => q.current.with(Velocity).and.with(Position).write);\n\n  execute() {\n    for (const movable of this.movables.current) {\n      // We retrive both velocity (to read) and position (to write) from our entities.\n      const velocity = movable.read(Velocity);\n      const position = movable.write(Position);\n      // In the execute method, a system has access to `this.delta`, which is the delta time between\n      // the current frame and the previous one.  This allows us to calculate a stable movement\n      // regardless of the intervals between our frames.  For more on that see\n      // https://drewcampbell92.medium.com/understanding-delta-time-b53bf4781a03.\n      position.x += this.delta * velocity.vx;\n      position.y += this.delta * velocity.vy;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Components and Systems with Becsy (TypeScript)\nDESCRIPTION: This TypeScript snippet defines components and systems using decorators (`@component`, `@system`, `@field`). It mirrors the JavaScript example, but uses TypeScript features for type safety and enhanced readability. `Acceleration` and `Position` components are defined with type annotations. The `PositionLogSystem` and `MovableSystem` function similarly to their JavaScript counterparts. The world is created and populated with entities, and the simulation is initiated.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\n```ts\nimport {component, field, system, System, Type, World} from '@lastolivegames/becsy';\n\n@component class Acceleration {\n  @field({type: Type.float64, default: 0.1}) declare value: number;\n}\n\n@component class Position {\n  @field.float64 declare x: number;\n  @field.float64 declare y: number;\n  @field.float64 declare z: number;\n}\n\n@system class PositionLogSystem extends System {\n  entities = this.query(q => q.current.with(Position));\n\n  execute() {\n    for (const entity of this.entities.current) {\n      const pos = entity.read(Position);\n      console.log(\n        `Entity with ordinal ${entity.ordinal} has component ` +\n        `Position={x: ${pos.x}, y: ${pos.y}, z: ${pos.z}}`\n      );\n    }\n  }\n}\n\n@system class MovableSystem extends System {\n  entities = this.query(\n    q => q.current.with(Acceleration).read.and.with(Position).write);\n\n  execute() {\n    for (const entity of this.entities.current) {\n      const acceleration = entity.read(Acceleration).value;\n      const position = entity.write(Position);\n      position.x += acceleration * this.delta;\n      position.y += acceleration * this.delta;\n      position.z += acceleration * this.delta;\n    }\n  }\n}\n\nconst world = await World.create();\n\nworld.createEntity(Position);\nfor (let i = 0; i < 10; i++) {\n  world.createEntity(\n    Acceleration,\n    Position, {x: Math.random() * 10, y: Math.random() * 10, z: 0}\n  );\n}\n\nasync function run() {\n  await world.execute();\n  requestAnimationFrame(run);\n}\n\nrun();\n```\n```\n\n----------------------------------------\n\nTITLE: Defining ECS System for Movement (JavaScript)\nDESCRIPTION: Defines a system extending `System` that queries entities with `Acceleration` (read) and `Position` (write) components. The `execute` method updates the position based on acceleration and delta time, demonstrating `entity.read()` and `entity.write()` for component access.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nclass MovableSystem extends System {\n  // Define a query of entities that have \"Acceleration\" and \"Position\" components,\n  // specifying that while we only need to read \"Acceleration\", we'll need to both\n  // read and write \"Position\".\n  entities = this.query(\n    q => q.current.with(Acceleration).read.and.with(Position).write);\n\n  // This method will get called on every frame by default.\n  execute() {\n    // Iterate through all the entities on the query.\n    for (const entity of this.entities.current) {\n      // Get the `Acceleration` component as read-only and extract its value.\n      const acceleration = entity.read(Acceleration).value;\n\n      // Get the `Position` component as read-write.\n      const position = entity.write(Position);\n      position.x += acceleration * this.delta;\n      position.y += acceleration * this.delta;\n      position.z += acceleration * this.delta;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ECS Component Types with Becsy in TypeScript\nDESCRIPTION: Implements three Entity-Component-System (ECS) component classes using Becsy in TypeScript: Position, Velocity, and DOMRenderable. Uses class decorators for auto-registration and typed fields, with raw array buffer backing for performance. Dependencies include @lastolivegames/becsy and TypeScript decorators support. Each component is typed for inter-thread compatibility and declares float or object fields; inputs are assigned by system logic while outputs facilitate movement and DOM updates.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {component, field, Type} from '@lastolivegames/becsy';\n\n// Component types are declared as classes and don't need to inherit from anything in particular.\n// We use the `@component` decorator to automatically register the component type with the world\n// (created below).\n@component class Position {\n  // Each property needs a low level backing field type, as Becsy uses raw array buffers to share\n  // data between workers (threads) rather than using objects to represent components.  To keep\n  // TypeScript happy, we also use `declare` to expose the high level JavaScript type of each\n  // property, whose implementation will be provided by Becsy.\n  @field.float64 declare x: number;\n  @field.float64 declare y: number;\n}\n\n@component class Velocity {\n  // Velocity is also a two floats vector just like Position, but we nonetheless define it as a\n  // separate component type.  Since an entity can have at most one instance of any given component\n  // type this will allow an entity to have both a Velocity and a Position.  We could reuse property\n  // names but prefer not to, as it will make code clearer later on.\n  @field.float64 declare vx: number;\n  @field.float64 declare vy: number;\n}\n\n@component class DOMRenderable {\n  // We'll need a reference to the DOM node we set up in the HTML file in order to manipulate it\n  // later on.\n  @field.object declare node: HTMLElement;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Numeric Vectors by Index (JavaScript)\nDESCRIPTION: This snippet shows the JavaScript equivalent for defining a component field as a fixed-size numeric vector using the static `schema` property and `Type.vector(baseType, length)`. It illustrates initializing entities and accessing or modifying vector elements using array-like indexed access.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nclass MovingEntity {\n  static schema = {\n    position: Type.vector(Type.float64, 3),\n    velocity: Type.vector(Type.float64, 3)\n  };\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(\n    MovingEntity, {position: [10, 0, 10], velocity: [1.5, 0.2, 0.1]}\n  );\n  const mover = player.write(MovingEntity);\n  for (let i = 0; i < mover.position.length; i++) {\n    move.position[i] += mover.velocity[i];\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Singleton Components in Becsy (TypeScript)\nDESCRIPTION: This snippet shows how to use singleton components in TypeScript. It declares a component as a singleton using `@component` and accesses it within a system using `this.singleton.write`.  Dependencies: `becsy` library. Input: Component definition. Output: A singleton component accessible within the system.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n@component class Global {\n  @field.uint8 declare state: number;\n}\n\n@system class SystemA extends System {\n  private global = this.singleton.write(Global);\n  execute(): void {\n    this.global.state = 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Numeric Vectors by Name (TypeScript)\nDESCRIPTION: This TypeScript example demonstrates how to define numeric vector fields with named elements using `@field.float64.vector(['name1', 'name2', ...])`. It shows initializing components using either arrays or objects and accessing elements interchangeably via index or their assigned names.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n@component class MovingEntity {\n  @field.float64.vector(['x', 'y', 'z'])\n  declare position: [number, number, number] & {x: number, y: number, z: number};\n  @field.float64.vector(['x', 'y', 'z'])\n  declare velocity: [number, number, number] & {x: number, y: number, z: number};\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(\n    MovingEntity, {position: [10, 0, 10], velocity: {x: 1.5, y: 0.2, z: 0.1}}\n  );\n  const mover = player.write(MovingEntity);\n  mover.position[0] += mover.velocity.x;\n  mover.position.x += mover.velocity[1];\n  mover.position.z += mover.velocity.z;\n});\n```\n\n----------------------------------------\n\nTITLE: Singleton Components in Becsy (JavaScript)\nDESCRIPTION: This snippet demonstrates the use of singleton components in a JavaScript environment.  It defines a component and accesses it within a system using `this.singleton.write`. Dependencies: `becsy` library. Input: Component definition. Output: Access to a singleton component within a system.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass Global {\n  static schema = {\n    state: Type.uint8\n  };\n}\n\nclass SystemA extends System {\n  constructor() {\n    this.global = this.singleton.write(Global);\n  }\n\n  execute() {\n    this.global.state = 1;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Added and Removed Entities in Reactive Queries (TypeScript)\nDESCRIPTION: Shows how to use Becsy's reactive query syntax in TypeScript to detect entities added to or removed from a query set since the previous system execution. Requires Box and Transform components and the use of the and, added, and removed DSL operators. Both added and removed entity lists can be processed in the execute method to handle entity lifecycle changes.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n@system class SystemA extends System {\n  // Query for entities that either became a Box with a Transform, or stopped being one.\n  private boxes = this.query(q => q.added.and.removed.with(Box, Transform));\n\n  execute(): void {\n    for (const addedBox of this.boxes.added) { /* ... */ }\n    for (const removedbox of this.boxes.removed) { /* ... */ }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Becsy World Instance (JS/TS)\nDESCRIPTION: Demonstrates the basic asynchronous creation of a Becsy World using `World.create()`. This is typically the first step in setting up a Becsy application.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/world.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst world = await World.create();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst world = await World.create();\n```\n\n----------------------------------------\n\nTITLE: Tracking Added and Removed Entities in Reactive Queries (JavaScript)\nDESCRIPTION: Uses Becsy's reactive query DSL in JavaScript to monitor entities added to or removed from matching a set of components (e.g., Box and Transform) between system executions. Dependencies are defined component types and Becsy ECS. Added and removed entities can be handled independently in the execute method.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass SystemA extends System {\n  constructor() {\n    // Query for entities that either became a Box with a Transform, or stopped being one.\n    this.boxes = this.query(q => q.added.and.removed.with(Box, Transform));\n  }\n\n  execute() {\n    for (const addedBox of this.boxes.added) { /* ... */ }\n    for (const removedbox of this.boxes.removed) { /* ... */ }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Write Entitlements in Queries (TypeScript)\nDESCRIPTION: Illustrates how to use entitlement suffixes in a TypeScript Becsy system query to declare intent to write to specific components (e.g., Name). Requires Becsy and at least Player and Name components. The execute method safely mutates matching entities, and entities with updated components are removed from the current query.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n@system class Namer extends System {\n  // Select all Players that don't have a Name component yet.\n  private uninitializedPlayers =\n    this.query(q => q.current.with(Player).but.without(Name).write);\n\n  execute(): void {\n    for (const player of this.uninitializedPlayers.current) {\n      // Add a name to each player, which will also remove it from the query.\n      player.add(Name, {value: getRandomName()});\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Holding and Managing Entity References Safely in Becsy using JavaScript\nDESCRIPTION: Explains how to hold persistent references to entities returned from createEntity or queries beyond the current system execution. Using the hold method returns a held entity handle that remains valid until the underlying entity is deleted. The example defines a system method initializing a held entity to maintain access between executions. It warns that held handles become invalid shortly after entity deletion and suggests checking the alive property each frame to avoid invalid access errors.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass MySystem extends System {\n  initialize(): void {\n    const newEntity = this.createEntity(Foo, Bar);\n    this.myImportantEntity = newEntity.hold();\n  }\n\n  execute(): void {\n    this.myImportantEntity.read(Foo);  // OK!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Components on Entities in Becsy with JavaScript\nDESCRIPTION: Demonstrates reading from components for safe, read-only usage, and writing to components to modify data on an entity. It features component classes declared with static schemas. The read method returns a component instance for inspection without mutation unless performance mode is enabled, while write allows modification. The snippet assumes an entity instance and component classes. Important constraints include not retaining component handles beyond immediate usage and understanding that writes mark components as changed, influencing reactive queries.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass ComponentA {\n  static schema = {\n    value: Type.int32\n  };\n}\nclass ComponentB {\n  static schema = {\n    value: Type.int32\n  };\n}\n\n// in a system, given an entity:\nentity.write(ComponentA).value += entity.read(ComponentB).value;\n```\n\n----------------------------------------\n\nTITLE: Tracking Component Field Changes in Reactive Queries (TypeScript & JavaScript)\nDESCRIPTION: Creates a reactive query in JavaScript to detect state changes in Box and Transform components since the last system execution, using Becsy's trackWrites. The changed list exposes entities with updated values. Dependencies include Becsy and the specified component types.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Get entities with Box and Transform, where Transform fields changed since last time.\nthis.query(q => q.changed.with(Box).and.with(Transform).trackWrites);\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Schema in TypeScript\nDESCRIPTION: This code snippet demonstrates how to define a component in TypeScript using Becsy, including specifying the schema with field types, default values, and decorators. It imports `component`, `field`, and `Type` from the `@lastolivegames/becsy` library. The `@component` decorator is used to automatically add the class to every world's `defs` list. The `@field` decorator is used to define the component's fields, specifying their types and default values. The `stringValue` field uses `@field.dynamicString` to allow for variable-length strings with a maximum UTF-8 length of 32. The `declare` keyword allows Becsy to take control of property definitions.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {component, field, Type} from '@lastolivegames/becsy';\n\n@component class ComponentA {\n  @field.boolean declare booleanValue: boolean;\n  @field({type: Type.uint32, default: 10}) declare integerValue: number;\n  @field.dynamicString(32) declare stringValue: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Recently Deleted Component Data in Becsy with JavaScript\nDESCRIPTION: Explains how to access components that have been removed from an entity during the current or previous frame using the system method accessRecentlyDeletedData. This allows reading fields on recently removed components but does not allow writing. The example creates an entity with a component, reads it, removes the component, shows that reading immediately after removal causes error, calls accessRecentlyDeletedData, and then reads the component again successfully. The snippet demonstrates safer handling of component removal in reactive systems.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nworld.build(sys => {\n  const entity = sys.createEntity(ComponentA, {value: 10});\n  entity.read(ComponentA).value;  // 10\n  entity.remove(ComponentA);\n  // entity.read(ComponentA).value;  // error!\n  sys.accessRecentlyDeletedData();\n  entity.read(ComponentA).value;  // 10\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Numeric Vectors with Custom Class (JavaScript)\nDESCRIPTION: This JavaScript example demonstrates associating a custom class with a numeric vector type via `Type.vector(baseType, names, CustomClass)`. It defines a `Vector3` class, creates a reusable `v3Type`, and declares component fields in the static `schema` using this type. This enables calling methods from the custom class directly on the component data.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nclass Vector3 {\n  x: number;\n  y: number;\n  z: number;\n\n  add(that: Vector3): void {\n    this.x += that.x;\n    this.y += that.y;\n    this.z += that.z;\n  }\n}\n\nconst v3Type = Type.vector(Type.float64, ['x', 'y', 'z'], Vector3);\n\nclass MovingEntity {\n  static schema = {\n    position: v3Type,\n    velocity: v3Type\n  };\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(\n    MovingEntity, {position: [10, 0, 10], velocity: [1.5, 0.2, 0.1]}\n  );\n  const mover = player.write(MovingEntity);\n  mover.position.add(mover.velocity);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Becsy ECS World with Component Definitions (JavaScript)\nDESCRIPTION: Initializes the ECS world, explicitly registering the defined component types (`Acceleration`, `Position`) by passing them in the `defs` array to the `World.create` method. This step is necessary in pure JavaScript for the world to recognize and manage these components.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst world = await World.create({defs: [Acceleration, Position]});\n```\n\n----------------------------------------\n\nTITLE: Adding Components to Entities in Becsy with JavaScript\nDESCRIPTION: Illustrates how to add one or multiple components to an existing entity after creation. The snippet includes component class definitions with static schemas in JavaScript. The add methods accept component types and optional field initial values, matching the createEntity pattern. Attempting to add the same component twice triggers an error. Required dependencies include the component classes and an entity instance. The example inputs are the component classes and field data; the output is the mutation of the entity's components.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass ComponentA {\n  static schema = {\n    value: Type.int32\n  };\n}\nclass ComponentB {\n  static schema = {\n    message: Type.dynamicString(20)\n  };\n}\n\n// in a system, given an entity:\nentity.add(ComponentA, {value: 10});\n// or add multiple components at once:\nentity.addAll(ComponentA, {value: 10}, ComponentB, {message: 'hello'});\n```\n\n----------------------------------------\n\nTITLE: Implementing the Game Loop in TypeScript with Becsy\nDESCRIPTION: Sets up a basic game loop using `requestAnimationFrame` for frame-based execution. An asynchronous `run` function is defined, which calls `world.execute()` to trigger the execution of all registered Becsy systems for the current frame. The `await` keyword is crucial for proper error handling. The loop is initiated and perpetuated by calling `requestAnimationFrame(run)`. This snippet assumes an initialized `world` instance from `@lastolivegames/becsy`.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport {component, field, system, System, Type, World} from '@lastolivegames/becsy';\n\n@component class Position {/* ... */}\n@component class Velocity {/* ... */}\n@component class DOMRenderable {/* ... */}\n\n@system export class VelocityInputController extends System {/* ... */}\n@system export class Movement extends System {/* ... */}\n@system export class Renderer extends System {/* ... */}\n\nconst world = await World.create();\n/* ... */\n\n// Finally, we set up our game loop.  The `run` function will be executed once per frame.\nasync function run() {\n  // Execute the world, which will call the `execute` method of all systems in sequence.  The call\n  // is asynchronous and we _must_ await its result, otherwise errors won't be reported properly.\n  await world.execute();\n  // Continue the loop on the next animation frame.\n  requestAnimationFrame(run);\n}\n// Kick things off with our first frame!\nrequestAnimationFrame(run);\n```\n\n----------------------------------------\n\nTITLE: Setting Up the Becsy World in TypeScript\nDESCRIPTION: Demonstrates creating a Becsy `World` instance using `World.create()`. In TypeScript, components and systems decorated with `@component` and `@system` are automatically registered with the world. An entity is then created and populated with `Position`, `Velocity`, and `DOMRenderable` components, initializing the `DOMRenderable`'s `node` property with a reference to an HTML element retrieved by its ID ('object'). Requires `@lastolivegames/becsy`, defined components/systems, and a corresponding DOM element.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport {component, field, system, System, Type, World} from '@lastolivegames/becsy';\n\n@component class Position {/* ... */}\n@component class Velocity {/* ... */}\n@component class DOMRenderable {/* ... */}\n\n@system export class VelocityInputController extends System {/* ... */}\n@system export class Movement extends System {/* ... */}\n@system export class Renderer extends System {/* ... */}\n\n// We can now create the world that all our entities and their components will live in.  All system\n// and component classes tagged with `@system` and `@component` will be automatically added to the\n// world's `defs`, and in this case we don't need to add any other types manually.\nconst world = await World.create();\n\n// Now we create the entity that will represent our object and add the components it will need.\n// Each component type can be optionally followed by an object with initial field values.\nworld.createEntity(Position, Velocity, DOMRenderable, {node: document.getElementById('object')});\n```\n\n----------------------------------------\n\nTITLE: Declaring Becsy System Execution Order (TypeScript/JavaScript)\nDESCRIPTION: Demonstrates how to specify system execution order using the schedule builder. The TypeScript version uses the `@system` decorator with a function argument, while the JavaScript version calls `this.schedule` within the constructor. Constraints like `before`, `afterWritesTo`, and `inAnyOrderWith` define the partial order.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@system(\n  s => s.before(SystemB).afterWritesTo(ComponentFoo).inAnyOrderWith(physicsSystems)\n) class SystemA extends System {}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass SystemA extends System {\n  constructor() {\n    this.schedule(\n      s => s.before(SystemB).afterWritesTo(ComponentFoo).inAnyOrderWith(physicsSystems)\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up the Becsy World in JavaScript\nDESCRIPTION: Illustrates creating a Becsy `World` using `World.create()` in JavaScript. Component and system classes (`Position`, `Velocity`, `DOMRenderable`, `VelocityInputController`, `Movement`, `Renderer`) must be explicitly provided in the `defs` array option during world creation. It then creates an entity with `Position`, `Velocity`, and `DOMRenderable` components, providing initial values for `DOMRenderable` including a reference to a DOM element ('object'). Requires `@lastolivegames/becsy`, defined component/system classes, and a DOM element with id 'object'.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport {System, Type, World} from '@lastolivegames/becsy';\n\nclass Position {/* ... */}\nclass Velocity {/* ... */}\nclass DOMRenderable {/* ... */}\n\nclass VelocityInputController extends System {/* ... */}\nclass Movement extends System {/* ... */}\nclass Renderer extends System {/* ... */}\n\n// We can now create the world that all our entities and their components will live in.  We list\n// every component and system class in the `defs` option, in any order.\nconst world = await World.create({\n  defs: [Position, Velocity, DOMRenderable, VelocityInputController, Movement, Renderer]\n});\n\n// Now we create the entity that will represent our object and add the components it will need.\n// Each component type can be optionally followed by an object with initial field values.\nworld.createEntity(Position, Velocity, DOMRenderable, {node: document.getElementById('object')});\n```\n\n----------------------------------------\n\nTITLE: Defining and Starting a Simple Coroutine in Becsy (TS/JS)\nDESCRIPTION: Demonstrates defining a basic coroutine using a generator function (`*runSlideshow`) within a Becsy system. In TypeScript, the `@co` decorator is used, and the coroutine is called directly from a lifecycle method like `initialize`. In JavaScript, `this.start` is used to initiate the coroutine. Both examples use `yield` with `co.waitForSeconds` and `co.waitForFrames` to suspend execution for a specific duration or number of frames, respectively, allowing sequential logic across multiple frames.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@system class IntroSlideshow extends System {\n  private slide = this.singleton.write(Slide);\n\n  initialize(): void {\n    this.runSlideshow(1.5);  // start a coroutine\n  }\n\n  @co *runSlideshow(delay: number) {\n    this.slide.value = 1;\n    yield co.waitForSeconds(delay);  // suspend execution for delay seconds\n    this.slide.value = 2;\n    yield co.waitForFrames(2);       // subliminal slide! suspend for 2 frames\n    this.slide.value = 3;\n    yield co.waitForSeconds(delay);  // suspend execution for delay seconds\n    this.slide.value = 0;  // all done\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass IntroSlideshow extends System {\n  private slide = this.singleton.write(Slide);\n\n  initialize(): void {\n    this.start(this.runSlideshow, 1.5);  // start a coroutine\n  }\n\n  *runSlideshow(delay: number) {\n    this.slide.value = 1;\n    yield co.waitForSeconds(delay);  // suspend execution for delay seconds\n    this.slide.value = 2;\n    yield co.waitForFrames(2);       // subliminal slide! suspend for 2 frames\n    this.slide.value = 3;\n    yield co.waitForSeconds(delay);  // suspend execution for delay seconds\n    this.slide.value = 0;  // all done\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Component Presence on Entities in Becsy using TypeScript and JavaScript\nDESCRIPTION: Describes methods used to verify the existence of components on an entity, including has, hasSomeOf, hasAllOf, hasAnyOtherThan, countHas, and hasWhich for enum components. These methods accept component types (including enums where applicable). All checks respect access to recently deleted data. They help in validation and conditional logic within systems. Dependencies include the entity instance and component or enum definitions. Methods return booleans or the active component type for enum queries.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nentity.has(ComponentA);\nentity.hasSomeOf(ComponentA, ComponentB);\nentity.hasAllOf(ComponentA, ComponentB);\nentity.hasAnyOtherThan(ComponentA, ComponentB);\nentity.countHas(ComponentA, ComponentB, ComponentC);\nentity.hasWhich(enumA);  // returns a component type or undefined\n```\n\n----------------------------------------\n\nTITLE: Becsy System Scheduling Constraints Example (TypeScript/JavaScript)\nDESCRIPTION: Provides a comprehensive example showcasing various scheduling constraints (`after`, `afterReadersOf`, `inAnyOrderWith`) and component read/write entitlements declared via `query`. These declarations combine to define the execution precedence between systems A, B, C, D, and E.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@system(s => s.after(C))\nclass A extends System {\n  entities = this.query(q => q.using(Foo).read);\n}\n\n@system\nclass B extends System {\n  entities = this.query(q => q.using(Foo).write);\n}\n\n@system\nclass C extends System {\n  entities = this.query(q => q.using(Bar).write.using(Foo).read);\n}\n\n@system(s => s.afterReadersOf(Foo))\nclass D extends System {\n}\n\n@system(s => s.inAnyOrderWith(B))\nclass E extends System {\n  entities = this.query(q => q.using(Foo).write);\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass A extends System {\n  constructor() {\n    this.schedule(s => s.after(C));\n    this.entities = this.query(q => q.using(Foo).read);\n}\n\nclass B extends System {\n  constructor() {\n    this.entities = this.query(q => q.using(Foo).write);\n  }\n}\n\nclass C extends System {\n  constructor() {\n    this.entities = this.query(q => q.using(Bar).write.using(Foo).read);\n  }\n}\n\nclass D extends System {\n  constructor() {\n    this.schedule(s => s.beforeReadersOf(Foo));\n  }\n}\n\nclass E extends System {\n  constructor() {\n    this.schedule(s => s.inAnyOrderWith(B));\n    this.entities = this.query(q => q.using(Foo).write);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing N-N Relationships (Friendship) in Becsy (JavaScript)\nDESCRIPTION: Models a many-to-many relationship using JavaScript classes. A `Friendship` component holds `Type.ref` fields for two `Person` entities. The `Person` component uses `Type.backrefs` to track `Friendship` entities. Demonstrates creation and querying within a `world.build` system.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nclass Friendship {\n  static schema = {\n    a: Type.ref,\n    b: Type.ref\n  };\n}\n\nclass Person {\n  static schema = {\n    friendships: Type.backrefs(Friendship)\n  };\n}\n\n\nworld.build(sys => {\n  const p1 = sys.createEntity(Person);\n  const p2 = sys.createEntity(Person);\n  const p3 = sys.createEntity(Person);\n\n  // Set up some friendships\n  const f1 = sys.createEntity(Friendship, {a: p1, b: p2});\n  const f2 = sys.createEntity(Friendship, {a: p1, b: p3});\n  p1.read(Person).friendships;  // [f1, f2] in any order\n  p1.read(Person).friendships.map(f => f.a === p1 ? f.b : f.a);  // [p2, p3] in any order\n})\n```\n\n----------------------------------------\n\nTITLE: Holding and Managing Entity References Safely in Becsy using TypeScript and JavaScript\nDESCRIPTION: Explains how to hold persistent references to entities returned from createEntity or queries beyond the current system execution. Using the hold method returns a held entity handle that remains valid until the underlying entity is deleted. The example defines a system with a private field storing a held entity to maintain access between executions. It warns that held handles become invalid shortly after entity deletion and suggests checking the alive property each frame to avoid invalid access errors.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n@system class MySystem extends System {\n  private myImportantEntity: Entity;\n\n  initialize(): void {\n    const newEntity = this.createEntity(Foo, Bar);\n    this.myImportantEntity = newEntity.hold();\n  }\n\n  execute(): void {\n    this.myImportantEntity.read(Foo);  // OK!\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing N-N Relationships (Friendship) in Becsy (TypeScript)\nDESCRIPTION: Models a many-to-many relationship by creating a `Friendship` entity component with references (`@field.ref`) to two `Person` entities using TypeScript decorators. The `Person` component uses `@field.backrefs` to track associated `Friendship` entities. Shows creation and querying within a `world.build` system.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@component class Friendship {\n  @field.ref declare a: Entity;\n  @field.ref declare b: Entity;\n}\n\n@component class Person {\n  @field.backrefs(Friendship) declare friendships: Entity[];\n}\n\nworld.build(sys => {\n  const p1 = sys.createEntity(Person);\n  const p2 = sys.createEntity(Person);\n  const p3 = sys.createEntity(Person);\n\n  // Set up some friendships\n  const f1 = sys.createEntity(Friendship, {a: p1, b: p2});\n  const f2 = sys.createEntity(Friendship, {a: p1, b: p3});\n  p1.read(Person).friendships;  // [f1, f2] in any order\n  p1.read(Person).friendships.map(f => f.a === p1 ? f.b : f.a);  // [p2, p3] in any order\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Component with Schema in JavaScript\nDESCRIPTION: This code snippet demonstrates how to define a component in JavaScript using Becsy, including specifying the schema with field types and default values. It imports the `Type` class from the `@lastolivegames/becsy` library and defines a component class `ComponentA` with a static `schema` property. The schema defines the types and default values for the component's fields, such as `booleanValue`, `integerValue`, and `stringValue`. The `stringValue` field uses `Type.dynamicString` to allow for variable-length strings with a maximum UTF-8 length of 32.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Type} from '@lastolivegames/becsy';\n\nclass ComponentA {\n  static schema = {\n    booleanValue: Type.boolean,\n    integerValue: {type: Type.uint32, default: 10},\n    stringValue: {type: Type.dynamicString(32)}\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Rendering System in TypeScript using Becsy\nDESCRIPTION: Defines a `Renderer` system using Becsy decorators (`@system`). It queries for entities with `Position` and `DOMRenderable` components that have been added or changed since the last frame. The `execute` method iterates through these entities, reads their position, and updates the corresponding DOM node's style properties (`left`, `top`) to reflect the entity's position. This system depends on the `@lastolivegames/becsy` library and pre-defined components like `Position` and `DOMRenderable`.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport {component, field, system, System, Type} from '@lastolivegames/becsy';\n\n@component class Position {/* ... */}\n@component class Velocity {/* ... */}\n@component class DOMRenderable {/* ... */}\n\n@system export class VelocityInputController extends System {/* ... */}\n@system export class Movement extends System {/* ... */}\n\n@system export class Renderer extends System {\n  // This system will render any entity that has both a Position and a DOMRenderable component, and\n  // that is new or whose position changed since the last frame. Note that we don't need to declare\n  // DOMRenderable as writable since we'll be modifying the DOM element's properties rather than\n  // updating the component's fields, and Becsy doesn't track that.\n  private readonly renderables =\n    this.query(q => q.addedOrChanged.with(DOMRenderable).and.with(Position).track);\n\n  execute(): void {\n    for (const renderable of this.renderables.addedOrChanged) {\n      const {x, y} = renderable.read(Position);\n      const {node} = renderable.read(DOMRenderable);\n      // Sync the node's position from the entity by setting its style.\n      node.style.left = `${x}px`;\n      node.style.top = `${y}px`;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying and Ordering Sprites by zIndex in becsy System (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a Renderer system in becsy, querying for entities with the Sprite component and sorting them in ascending order by the zIndex property. The system iterates through the sorted entities and invokes the render function on each one. Dependencies include the Sprite component, the render function, and the becsy framework. The sprites query is set up in a field, and its .current iterable is consumed during each execute cycle. Input: none (component state used internally). Output: entities are rendered in zIndex order. The query assumes that all queried entities have the Sprite component and a numeric zIndex field.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\n@system class Renderer extends System {\n  // Query for all Sprites and order by ascending zIndex.\n  private sprites = this.query(\n    q => q.current.with(Sprite).orderBy(entity => entity.read(Sprite).zIndex)\n  );\n\n  execute(): void {\n    // Iterate over all sprites in order of zIndex.\n    for (const entity of this.sprites.current) {\n      render(entity.read(Sprite));\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Becsy ECS World Execution Loop (JavaScript)\nDESCRIPTION: Sets up a continuous execution loop using `requestAnimationFrame`. In each frame, `world.execute()` is called asynchronously, triggering all registered systems to run and process entities based on their defined queries.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_15\n\nLANGUAGE: js\nCODE:\n```\nasync function run() {\n  // Run all the systems\n  await world.execute();\n  requestAnimationFrame(run);\n}\n\nrun();\n```\n\n----------------------------------------\n\nTITLE: Defining Component Enums in Becsy (TypeScript)\nDESCRIPTION: Shows how to define a component enum in TypeScript. It first defines the enum name using `World.defineEnum` and then associates component classes (`A`, `B`, `C`) with the enum using the `@component(myEnum)` decorator. This enforces mutual exclusivity among the enum members.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst myEnum = World.defineEnum('myEnum');\n@component(myEnum) class A {}\n@component(myEnum) class B {}\n@component(myEnum) class C {}\n```\n\n----------------------------------------\n\nTITLE: Accessing Time and Delta in Becsy System Execute (TypeScript/JavaScript)\nDESCRIPTION: Example of using `this.delta` (time since last frame) and `this.time` (current frame time) within the `execute` method for time-dependent logic, such as updating a position based on speed. These values are automatically provided by the world.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n@system class MySystem extends System {\n  execute(): void {\n    const speed = this.player.read(Speed);\n    const position = this.player.write(Position);\n    position.value += speed.value * this.delta;\n    position.lastUpdated = this.time;\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass MySystem extends System {\n  execute(): void {\n    const speed = this.player.read(Speed);\n    const position = this.player.write(Position);\n    position.value += speed.value * this.delta;\n    position.lastUpdated = this.time;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Systems in a Becsy World (JS/TS)\nDESCRIPTION: Illustrates how to run all systems within a Becsy world using `world.execute()`. It shows both using the internal clock and providing explicit time and delta values for manual clock control, typically within a game loop.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/world.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nawait world.execute();  // use Becsy's built-in clock\nawait world.execute(time, delta);  // or control the clock yourself\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait world.execute();  // use Becsy's built-in clock\nawait world.execute(time, delta);  // or control the clock yourself\n```\n\n----------------------------------------\n\nTITLE: Creating Entities with Components (JS/TS)\nDESCRIPTION: Shows how to create an entity directly using `world.createEntity()`, attaching specified component types (e.g., `ComponentFoo`, `ComponentBar`) and optionally providing initial values for their fields. This method does not return a handle to the created entity.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/world.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nworld.createEntity(ComponentFoo, {foo: 'bar', baz: 42}, ComponentBar);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nworld.createEntity(ComponentFoo, {foo: 'bar', baz: 42}, ComponentBar);\n```\n\n----------------------------------------\n\nTITLE: Declaring Write Entitlements in Queries (JavaScript)\nDESCRIPTION: Demonstrates how to declare write entitlements in a JavaScript Becsy system, allowing entities to be updated safely within the system execution. This pattern is used to assign new values or components (e.g., Name) to newly matched entities and removes them from the query list afterwards. The snippet requires Becsy and assumes getRandomName is defined.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass Namer extends System {\n  constructor() {\n    // Select all Players that don't have a Name component yet.\n    this.uninitializedPlayers =\n      this.query(q => q.current.with(Player).but.without(Name).write);\n  }\n\n  execute() {\n    for (const player of this.uninitializedPlayers.current) {\n      // Add a name to each player, which will also remove it from the query.\n      // This is a typical \"factory\" pattern in ECS.\n      player.add(Name, {value: getRandomName()});\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Added and Changed Entity Tracking in Queries (TypeScript & JavaScript)\nDESCRIPTION: Shows how to construct a query that exposes entities that were newly added or had tracked component fields changed (e.g., Box with Transform) since last execution, using Becsy ECS. The addedOrChanged operator aggregates both lists, supporting per-frame detection and handling of new or modified entities. Requires Becsy and appropriate component definitions.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Get entities that became a Box with Transform, or whose Transform was changed.\nthis.query(q => q.addedOrChanged.with(Box).and.with(Transform).trackWrites);\n```\n\n----------------------------------------\n\nTITLE: Deleting Entities in Becsy with JavaScript\nDESCRIPTION: Shows how to explicitly delete an entity, which removes all components and triggers reactive queries accordingly. It highlights the requirement that the system performing deletion holds write entitlements on all components of the entity. To simplify handling unknown components, it illustrates a pattern for tagging entities for later deletion by another system with full write access. Includes component and system class definitions with queries and execute methods. Attempting to delete an already deleted entity raises an error.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass ToBeDeleted {}\n\nclass SystemA extends System {\n  execute() {\n    // Instead of entity.delete(), just tag it:\n    entity.add(ToBeDeleted);\n  }\n}\n\nclass Deleter extends System {\n  constructor() {\n    // Note the usingAll.write below, which grants write entitlements on all component types.\n    this.entities = this.query(q => q.current.with(ToBeDeleted).usingAll.write);\n  }\n\n  execute() {\n    for (const entity of this.entities.current) entity.delete();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ECS Component Types with Becsy in JavaScript\nDESCRIPTION: Implements equivalent Position, Velocity, and DOMRenderable ECS components for Becsy using plain JavaScript class syntax. Each class statically registers field types via a schema property, ensuring interoperability with Becsy's internal array buffer model. Requires the @lastolivegames/becsy package; property types (float64, object) are referenced from the imported Type helper. Input and output usage mirrors the TypeScript version, enabling DOM manipulation and entity movement.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport {Type} from '@lastolivegames/becsy';\n\n// Component types are declared as classes and don't need to inherit from anything in particular.\nclass Position {\n  // Each property needs a low level backing field type, as Becsy uses raw array buffers to share\n  // data between workers (threads) rather than using objects to represent components.  You declare\n  // these in a static schema property.\n  static schema = {\n    x: Type.float64,\n    y: Type.float64\n  };\n}\n\nclass Velocity {\n  // Velocity is also a two floats vector just like Position, but we nonetheless define it as a\n  // separate component type.  Since an entity can have at most one instance of any given component\n  // type this will allow an entity to have both a Velocity and a Position.  We could reuse property\n  // names but prefer not to, as it will make code clearer later on.\n  static schema = {\n    vx: Type.float64,\n    vy: Type.float64\n  };\n}\n\nclass DOMRenderable {\n  // We'll need a reference to the DOM node we set up in the HTML file in order to manipulate it\n  // later on.\n  static schema = {\n    node: Type.object\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Systems in Becsy (TypeScript)\nDESCRIPTION: This snippet demonstrates how to group systems using the `System.group` method and then schedule them.  Dependencies: `becsy` library. Input: System types. Output: Systems executing in a specific order.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst myGroup = System.group(SystemA, SystemB);\n// --- or ---\nconst myGroup = System.group();\n@system(myGroup) class SystemA extends System {}\n@system(myGroup) class SystemB extends System {}\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@system(s => s.before(physicsGroup)) class InputManager extends System {} physicsGroup.schedule(s => s.before(renderGroup));\n```\n\n----------------------------------------\n\nTITLE: Tracking Component Field Changes in Reactive Queries (TypeScript & JavaScript)\nDESCRIPTION: Demonstrates how to create a query that tracks entities whose components (Box and Transform) had field changes since the last system execution. Requires Becsy and these components. Uses the trackWrites operator to monitor write operations and updates, with changed entities accessible from the query result. Inputs are component changes; output is a changed entity list; newly added entities are excluded.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Get entities with Box and Transform, where Transform fields changed since last time.\nthis.query(q => q.changed.with(Box).and.with(Transform).trackWrites);\n```\n\n----------------------------------------\n\nTITLE: Grouping Systems in Becsy (JavaScript)\nDESCRIPTION: This snippet shows how to group systems using `System.group` and schedule them within a JavaScript context.  Dependencies: `becsy` library.  Input: System types. Output: Systems scheduled for execution.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst myGroup = System.group(SystemA, SystemB);\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass InputManager extends System {\n  constructor() {\n    this.schedule(s => s.before(physicsGroup));\n  }\n}\nphysicsGroup.schedule(s => s.before(renderGroup));\n```\n\n----------------------------------------\n\nTITLE: Combining Added and Changed Entity Tracking in Queries (TypeScript & JavaScript)\nDESCRIPTION: Constructs a combined reactive query in JavaScript to receive entities that were either added (matched for the first time) or whose tracked fields changed within the last frame. Uses addedOrChanged along with with/trackWrites for both new and modified entities. Depends on Box, Transform components and Becsy ECS library.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Get entities that became a Box with Transform, or whose Transform was changed.\nthis.query(q => q.addedOrChanged.with(Box).and.with(Transform).trackWrites);\n```\n\n----------------------------------------\n\nTITLE: Attaching Systems in Becsy (TypeScript)\nDESCRIPTION: This snippet illustrates how to attach one system to another in TypeScript.  It involves using the `attach` method to get an instance of the attached system.  Dependencies: `becsy` library. Input:  System instances. Output: Access to another system's internal data.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n@system class SystemA extends System {\n  internalMap: Map<string, Entity>;\n}\n\n@system class SystemB extends System {\n  private systemA = this.attach(SystemA);\n  execute(): void {\n    this.systemA.internalMap.get('foo');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ECS System with Multiple Queries (JavaScript)\nDESCRIPTION: Illustrates how a single system can define and utilize multiple distinct queries (`boxes`, `balls`) to select and process different subsets of entities based on their component composition within the `execute` method.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\nclass SystemDemo extends System {\n  boxes = this.query(q => q.current.with(Box));\n  balls = this.query(q => q.current.with(Ball));\n\n  execute() {\n    for (const entity of this.boxes.current) { /* do things with box-like entity */ }\n    for (const entity of this.balls.current) { /* do things with ball-like entity */ }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Systems in Becsy (JavaScript)\nDESCRIPTION: This snippet demonstrates attaching one system to another within a JavaScript context.  It utilizes the `attach` method to obtain a reference to another system.  Dependencies: `becsy` library. Input: System instances. Output: Access to another system's internal data.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass SystemA extends System {\n  constructor() {\n    this.internalMap = new Map();\n  }\n}\n\nclass SystemB extends System {\n  constructor() {\n    this.systemA = this.attach(SystemA);\n  }\n\n  execute() {\n    this.systemA.internalMap.get('foo');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Game Loop in JavaScript with Becsy\nDESCRIPTION: Implements a standard game loop using `requestAnimationFrame`. An async `run` function calls `world.execute()` to process one tick of the Becsy world, executing all systems. It's important to `await` this call for correct error propagation. `requestAnimationFrame(run)` is used both to start the loop and to schedule the next iteration within the `run` function itself. Depends on an initialized `world` instance from `@lastolivegames/becsy`.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport {System, Type, World} from '@lastolivegames/becsy';\n\nclass Position {/* ... */}\nclass Velocity {/* ... */}\nclass DOMRenderable {/* ... */}\n\nclass VelocityInputController extends System {/* ... */}\nclass Movement extends System {/* ... */}\nclass Renderer extends System {/* ... */}\n\nconst world = await World.create({/* ... */});\n/* ... */\n\n// Finally, we set up our game loop.  The `run` function will be executed once per frame.\nasync function run() {\n  // Execute the world, which will call the `execute` method of all systems in sequence.  The call\n  // is asynchronous and we _must_ await its result, otherwise errors won't be reported properly.\n  await world.execute();\n  // Continue the loop on the next animation frame.\n  requestAnimationFrame(run);\n}\n// Kick things off with our first frame!\nrequestAnimationFrame(run);\n```\n\n----------------------------------------\n\nTITLE: Initializing Input System - JavaScript\nDESCRIPTION: This JavaScript snippet initializes an input system. It defines a `VelocityInputController` class extending `System` which utilizes the DOM `keydown` and `keyup` events to monitor pressed keys. It adds and removes keys to a `Set` respectively.  The key functionality lies in setting entity velocity based on the pressed arrow keys.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport {System, Type} from '@lastolivegames/becsy';\n\nclass Position {/* ... */}\nclass Velocity {/* ... */}\nclass DOMRenderable {/* ... */}\n\n\n// Systems are declared as classes that extend `System`.\nclass VelocityInputController extends System {\n  // Every system can define any number of queries whose results will be available in the `execute`\n  // method.  In this case, we're asking for all entities that currently have a Velocity component,\n  // and declare that we'll be writing to those components.\n  movables = this.query(q => q.current.with(Velocity).write);\n\n  // Here we'll store all keys that are currently pressed.  This is not specific to ECS but it's a\n  // common pattern to glue together event-driven (DOM) and timing-driven (ECS) processes.\n  keysPressed = new Set();\n\n  // Every system can provide an `initialize` method that will be called once as the world is being\n  // set up.  We'll use it to register our DOM event handlers.\n  initialize() {\n    document.addEventListener('keydown', event => {\n      this.keysPressed.add(event.key);  // add the pressed key to our set\n    });\n\n    document.addEventListener('keyup', event => {\n      this.keysPressed.delete(event.key);  // remove the released key from our set\n    });\n  }\n\n  // Every system can (and probably should) provide an `execute` method that implements its logic.\n  // It will be invoked once per frame in our demo, so at 60fps it's called 60 times per second.\n  execute() {\n    // We loop through the query results of the movables query we defined above.\n    for (const movable of this.movables.current) {\n      // This is how we access the data stored in the Velocity component of our movable entity.\n      // We must specify whether we intend to only `read` the data or also to `write` it.  We'll\n      // only be allowed to `write` to component types that we reserved as such in our queries.\n      const velocity = movable.write(Velocity);\n\n      if (this.keysPressed.has('ArrowUp')) velocity.vy = -100;  // in pixels per second\n      else if (this.keysPressed.has('ArrowDown')) velocity.vy = 100;\n      else velocity.vy = 0;\n\n      if (this.keysPressed.has('ArrowLeft')) velocity.vx = -100;\n      else if (this.keysPressed.has('ArrowRight')) velocity.vx = 100;\n      else velocity.vx = 0;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Recently Deleted Component Data in Becsy with TypeScript and JavaScript\nDESCRIPTION: Explains how to access components that have been removed from an entity during the current or previous frame using the system method accessRecentlyDeletedData. This allows reading fields on recently removed components but does not allow writing. The example creates an entity with a component, reads it, removes the component, shows that reading immediately after removal causes error, calls accessRecentlyDeletedData, and then reads the component again successfully. The snippet demonstrates safer handling of component removal in reactive systems.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nworld.build(sys => {\n  const entity = sys.createEntity(ComponentA, {value: 10});\n  entity.read(ComponentA).value;  // 10\n  entity.remove(ComponentA);\n  // entity.read(ComponentA).value;  // error!\n  sys.accessRecentlyDeletedData();\n  entity.read(ComponentA).value;  // 10\n})\n```\n\n----------------------------------------\n\nTITLE: Tracking withAny Clause State Changes in Reactive Queries (TypeScript & JavaScript)\nDESCRIPTION: Uses the trackMatches operator in a JavaScript reactive query to monitor entities whose set of Open/Closed components on a Menu entity changes. Applicable for scenarios where implicit state transitions are encoded by component presence. Depends on existence of Menu, Open, and Closed components.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Get entities with Menu, where their open/closed state changed since last time.\nthis.query(q => q.changed.with(Menu).and.withAny(Open, Closed).trackMatches);\n```\n\n----------------------------------------\n\nTITLE: Tracking withAny Clause State Changes in Reactive Queries (TypeScript & JavaScript)\nDESCRIPTION: Illustrates how to use the trackMatches operator in a reactive query to track when a set of components matching withAny (e.g., Open or Closed on Menu) changes state. This snippet applies in both TypeScript and JavaScript, using Becsy ECS, and marks entities as changed when their component match set transitions. Used for cases where state is implied by the presence of component(s).\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Get entities with Menu, where their open/closed state changed since last time.\nthis.query(q => q.changed.with(Menu).and.withAny(Open, Closed).trackMatches);\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Becsy Coroutine (TS/JS)\nDESCRIPTION: Illustrates two ways to cancel a Becsy coroutine. The `cancelIf()` method, called on the handle returned when starting a coroutine, allows setting a condition (evaluated every frame) for external cancellation (e.g., based on query results). Inside the coroutine itself, `co.cancel()` can be called for immediate self-cancellation based on internal logic.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@system class IdleStart extends System {\n  // Query for activity components that will signal us to end the initial idle behavior.\n  private activity = this.query(q => q.current.with(Activity));\n\n  initialize(): void {\n    // Start the idle behavior coroutine, and cancel once Activity entities appear.\n    this.doIdle().cancelIf(() => this.activity.current.length);\n  }\n\n  @co *doIdle() {\n    // ... do stuff ...\n    if (someSpecialCondition) co.cancel();\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass IdleStart extends System {\n  constructor() {\n    // Query for activity components that will signal us to end the initial idle behavior.\n    this.activity = this.query(q => q.current.with(Activity));\n  }\n\n  initialize(): void {\n    // Start the idle behavior coroutine, and cancel once Activity entities appear.\n    this.start(this.doIdle).cancelIf(() => this.activity.current.length);\n  }\n\n  *doIdle() {\n    // ... do stuff ...\n    if (someSpecialCondition) co.cancel();  // cancel immediately\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Numeric Vectors by Name (JavaScript)\nDESCRIPTION: This JavaScript example shows how to define numeric vector fields with named elements using the static `schema` and `Type.vector(baseType, ['name1', 'name2', ...])`. It demonstrates component initialization with arrays or objects and accessing elements using both indexed and named properties.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nclass MovingEntity {\n  static schema = {\n    position: Type.vector(Type.float64, ['x', 'y', 'z']),\n    velocity: Type.vector(Type.float64, ['x', 'y', 'z'])\n  };\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(\n    MovingEntity, {position: [10, 0, 10], velocity: {x: 1.5, y: 0.2, z: 0.1}}\n  );\n  const mover = player.write(MovingEntity);\n  mover.position[0] += mover.velocity.x;\n  mover.position.x += mover.velocity[1];\n  mover.position.z += mover.velocity.z;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining ECS System with Multiple Queries (TypeScript)\nDESCRIPTION: Illustrates how a single system using the `@system` decorator can define and utilize multiple distinct queries (`boxes`, `balls`) to select and process different subsets of entities based on their component composition within the `execute` method.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\n@system class SystemDemo extends System {\n  boxes = this.query(q => q.current.with(Box));\n  balls = this.query(q => q.current.with(Ball));\n\n  execute() {\n    for (const entity of this.boxes.current) { /* do things with box-like entity */ }\n    for (const entity of this.balls.current) { /* do things with ball-like entity */ }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Input System - TypeScript\nDESCRIPTION: This TypeScript snippet initializes an input system using the becsy ECS framework. It defines a `VelocityInputController` system that listens for keydown and keyup events on the document.  It stores the currently pressed keys in a `Set`. Dependencies include the `becsy` library for ECS functionality.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {component, field, system, System, Type} from '@lastolivegames/becsy';\n\n@component class Position {/* ... */}\n@component class Velocity {/* ... */}\n@component class DOMRenderable {/* ... */}\n\n\n// Systems are declared as classes that extend `System`.  We use the `@system` decorator to\n// automatically register the system type with the world, and `export` them so the linter won't\n// complain about \"unused\" classes.\n@system export class VelocityInputController extends System {\n  // Every system can define any number of queries whose results will be available in the `execute`\n  // method.  In this case, we're asking for all entities that currently have a Velocity component,\n  // and declare that we'll be writing to those components.\n  private readonly movables = this.query(q => q.current.with(Velocity).write);\n\n  // Here we'll store all keys that are currently pressed.  This is not specific to ECS but it's a\n  // common pattern to glue together event-driven (DOM) and timing-driven (ECS) processes.\n  private readonly keysPressed = new Set<string>();\n\n  // Every system can provide an `initialize` method that will be called once as the world is being\n  // set up.  We'll use it to register our DOM event handlers.\n  initialize(): void {\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n      this.keysPressed.add(event.key);  // add the pressed key to our set\n    });\n\n    document.addEventListener('keyup', (event: KeyboardEvent) => {\n      this.keysPressed.delete(event.key);  // remove the released key from our set\n    });\n  }\n\n  // Every system can (and probably should) provide an `execute` method that implements its logic.\n  // It will be invoked once per frame in our demo, so at 60fps it's called 60 times per second.\n  execute(): void {\n    // We loop through the query results of the movables query we defined above.\n    for (const movable of this.movables.current) {\n      // This is how we access the data stored in the Velocity component of our movable entity.\n      // We must specify whether we intend to only `read` the data or also to `write` it.  We'll\n      // only be allowed to `write` to component types that we reserved as such in our queries.\n      const velocity = movable.write(Velocity);\n\n      if (this.keysPressed.has('ArrowUp')) velocity.vy = -100;  // in pixels per second\n      else if (this.keysPressed.has('ArrowDown')) velocity.vy = 100;\n      else velocity.vy = 0;\n\n      if (this.keysPressed.has('ArrowLeft')) velocity.vx = -100;\n      else if (this.keysPressed.has('ArrowRight')) velocity.vx = 100;\n      else velocity.vx = 0;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 1-N Relationships (Inventory) in Becsy (TypeScript)\nDESCRIPTION: Defines `Packed` and `Inventory` components using TypeScript decorators (`@component`, `@field.ref`, `@field.backrefs`) to model a one-to-many relationship. Demonstrates adding/removing components and deleting entities to show automatic updates of the `backrefs` list within a `world.build` system context.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n@component class Packed {\n  @field.ref declare holder: Entity;\n}\n\n@component class Inventory {\n  @field.backrefs(Packed, 'holder') declare contents: Entity[];\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(Inventory, Health, /* etc */);\n  const potion = sys.createEntity(Potion, {healing: 200});\n  const sword = sys.createEntity(Sword, {damage: 50});\n\n  // Put both items in the player's inventory\n  potion.add(Packed, {holder: player});\n  sword.add(Packed, {holder: player});\n  player.read(Inventory).contents;  // [potion, sword] in any order\n\n  // Remove the sword from the inventory\n  sword.remove(Packed);\n  player.read(Inventory).contents;  // [potion]\n\n  // Destroy the potion\n  potion.delete();\n  player.read(Inventory).contents;  // []\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Becsy System Lifecycle Hooks (TypeScript/JavaScript)\nDESCRIPTION: Shows the structure for overriding Becsy system lifecycle methods: `prepare` (async setup), `initialize` (synchronous initialization), `execute` (per-frame logic), and `finalize` (cleanup on world termination). These hooks allow controlling system behavior at different stages.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@system class MySystem extends System {\n  async prepare(): Promise<void> {}\n  initialize(): void {}\n  execute(): void {}\n  finalize(): void {}\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass MySystem extends System {\n  prepare() {}  // returns a promise\n  initialize() {}\n  execute() {}\n  finalize() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 1-N Relationships (Inventory) in Becsy (JavaScript)\nDESCRIPTION: Defines `Packed` and `Inventory` components using JavaScript classes with static `schema` properties (`Type.ref`, `Type.backrefs`) to model a one-to-many relationship. Demonstrates adding/removing components and deleting entities to show automatic updates of the `backrefs` list within a `world.build` system context.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nclass Packed {\n  static schema = {\n    holder: Type.ref\n  };\n}\n\nclass Inventory {\n  static schema = {\n    contents: Type.backrefs(Packed, 'holder')\n  };\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(Inventory, Health, /* etc */);\n  const potion = sys.createEntity(Potion, {healing: 200});\n  const sword = sys.createEntity(Sword, {damage: 50});\n\n  // Put both items in the player's inventory\n  potion.add(Packed, {holder: player});\n  sword.add(Packed, {holder: player});\n  player.read(Inventory).contents;  // [potion, sword] in any order\n\n  // Remove the sword from the inventory\n  sword.remove(Packed);\n  player.read(Inventory).contents;  // [potion]\n\n  // Destroy the potion\n  potion.delete();\n  player.read(Inventory).contents;  // []\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Component Enums in Becsy (JavaScript)\nDESCRIPTION: Shows how to define a component enum in JavaScript using `World.defineEnum`. It groups existing component classes (`A`, `B`, `C`) under a named enum (`myEnum`) to enforce mutual exclusivity among them on any single entity.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nclass A {}\nclass B {}\nclass C {}\n// Define an enum of component types A, B, and C.\nconst myEnum = World.defineEnum('myEnum', A, B, C);\n```\n\n----------------------------------------\n\nTITLE: Removing Components from Entities in Becsy using TypeScript and JavaScript\nDESCRIPTION: Shows how to remove one or multiple components from an entity. It notes that enum components removal affects the related member components and removing nonexistent components raises an error. Components remain accessible until the end of the next frame allowing systems to react to removals. Dependencies include the entity instance and component classes. The snippet covers removal methods remove and removeAll invoked with component types, with consideration for recently deleted data access via system calls.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nentity.remove(ComponentA);\nentity.removeAll(ComponentA, ComponentB);\n```\n\n----------------------------------------\n\nTITLE: Querying and Ordering Sprites by zIndex in becsy System (JavaScript)\nDESCRIPTION: This JavaScript snippet defines a Renderer system for becsy, using the constructor to set up a query for entities with the Sprite component, ordered by the zIndex property. The execute method loops through the sorted entities and calls the render function. This requires the Sprite component, render function, and the becsy System framework to be available. The query uses the .orderBy method for sorting. Inputs: none external, acts over entity sets in the world. Outputs: each matching Sprite is rendered in ascending zIndex order.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass Renderer extends System {\n  constructor() {\n    // Query for all Sprites and order by ascending zIndex.\n    this.sprites = this.query(\n      q => q.current.with(Sprite).orderBy(entity => entity.read(Sprite).zIndex)\n    );\n  }\n\n  execute() {\n    // Iterate over all sprites in order of zIndex.\n    for (const entity of this.sprites.current) {\n      render(entity.read(Sprite));\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ECS System for Logging Position (TypeScript)\nDESCRIPTION: Defines a system using the `@system` decorator that extends `System`. It queries entities possessing the `Position` component and iterates through them in its `execute` method to read and log their position data using `entity.read()`. The query specifies read access.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\n@system class PositionLogSystem extends System {\n  // Define a query of entities that have the \"Position\" component.\n  entities = this.query(q => q.current.with(Position));\n\n  // This method will get called on every frame.\n  execute() {\n    // Iterate through all the entities on the query.\n    for (const entity of this.entities.current) {\n      // Access the component `Position` on the current entity.\n      const pos = entity.read(Position);\n      console.log(\n        `Entity with ordinal ${entity.ordinal} has component ` +\n        `Position={x: ${pos.x}, y: ${pos.y}, z: ${pos.z}}`\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Component Storage Options in Becsy - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to specify storage options for a component class in Becsy using decorators. It sets the storage strategy to 'packed' and defines a fixed capacity of 1000 for the component's data buffers. Dependencies include the Becsy ECS framework with support for the @component decorator. The snippet configures how fields of the component are stored internally, affecting memory layout and performance.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\n@component class A {\n  static options = {\n    storage: 'packed',\n    capacity: 1000\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Becsy ECS World (TypeScript)\nDESCRIPTION: Initializes the main container object for the ECS world. This asynchronous call sets up the environment where entities, components, and systems will reside and interact.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst world = await World.create();\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Numeric Vectors by Index (TypeScript)\nDESCRIPTION: This snippet demonstrates how to declare a component field as a fixed-size numeric vector using the `@field.float64.vector(length)` decorator syntax in TypeScript. It shows how to initialize entities with array literals and access or modify the vector elements individually using array-like indexed access.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n@component class MovingEntity {\n  @field.float64.vector(3)\n  declare position: [number, number, number] & {asTypedArray(): Float64Array};\n  @field.float64.vector(3)\n  declare velocity: [number, number, number] & {asTypedArray(): Float64Array};\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(\n    MovingEntity, {position: [10, 0, 10], velocity: [1.5, 0.2, 0.1]}\n  );\n  const mover = player.write(MovingEntity);\n  for (let i = 0; i < move.position.length; i++) {\n    move.position[i] += mover.velocity[i];\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Ordering Commands by Creation Order in becsy Query (TypeScript)\nDESCRIPTION: This TypeScript query snippet orders entities with the Command component by their ordinal property, which typically represents creation order. It can be used to execute commands sequentially as they were created. This requires the Command component to be available and a writable query context. Input: query context. Output: entities ordered by their ordinal field. Suitable for use in systems where the execution order of commands is critical.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nthis.query(q => q.current.with(Command).write.orderBy(entity => entity.ordinal))\n```\n\n----------------------------------------\n\nTITLE: Scoping Becsy Coroutines to Entities (TS/JS)\nDESCRIPTION: Shows how to scope a coroutine to a specific entity using `co.scope(entity)`. This associates the coroutine's lifecycle with the entity, enabling automatic cancellation if the entity is deleted. It also allows using entity-specific cancellation conditions like `co.cancelIfComponentMissing(ComponentType)` or `co.cancelIfCoroutineStarted()`, which cancels the current coroutine if another coroutine is started for the same entity within the same system.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n@component class Zombie {\n  @field.boolean declare dancing: boolean;\n}\n\n@system class DanceOrWalk extends System {\n  private zombies = this.query(q => q.current.with(Zombie).write);\n\n  execute(): void {\n    for (const zombie of this.zombies.current) {\n      const beDancing = Math.random() < 0.5;\n      if (beDancing === zombie.dancing) continue;\n      zombie.dancing = beDancing;\n      if (beDancing) this.dance(zombie.hold()); else this.walk(zombie.hold());\n    }\n  }\n\n  @co *dance(zombie: Entity) {\n    co.scope(zombie);  // scope ourselves to our very own zombie\n    co.cancelIfComponentMissing(Zombie);  // cancel if our zombie gets better\n    co.cancelIfCoroutineStarted();  // cancel if our zombie starts another coroutine in this system\n    while (true) {\n      // ... dance zombie, dance!\n      yield;\n    }\n  }\n\n  @co *walk(zombie: Entity) {\n    // ... as above\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass Zombie {\n  static schema = {\n    dancing: Type.boolean\n  };\n}\n\nclass DanceOrWalk extends System {\n  private zombies = this.query(q => q.current.with(Zombie).write);\n\n  execute() {\n    for (const zombie of this.zombies.current) {\n      const beDancing = Math.random() < 0.5;\n      if (beDancing === zombie.dancing) continue;\n      zombie.dancing = beDancing;\n      if (beDancing) {\n        this.start(this.dance, zombie.hold());\n      } else {\n        this.start(this.walk, zombie.hold());\n      }\n    }\n  }\n\n  *dance(zombie) {\n    co.scope(zombie);  // scope ourselves to our very own zombie\n    co.cancelIfComponentMissing(Zombie);  // cancel if our zombie gets better\n    co.cancelIfCoroutineStarted();  // cancel if our zombie starts another coroutine in this system\n    while (true) {\n      // ... dance zombie, dance!\n      yield;\n    }\n  }\n\n  *walk(zombie) {\n    // ... as above\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting and Stopping Systems Dynamically (JS/TS)\nDESCRIPTION: Illustrates using `world.control()` to dynamically enable or disable specific systems (e.g., `SystemA`, `SystemC`) or system groups (e.g., `systemGroupB`, `systemGroupD`) during runtime. Systems listed in `stop` will cease execution, while those in `restart` will begin execution, effective at the end of the current frame if called mid-frame.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/world.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nworld.control({\n  stop: [SystemA, systemGroupB],    // these systems will be stopped\n  restart: [SystemC, systemGroupD]  // these systems will be started\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nworld.control({\n  stop: [SystemA, systemGroupB],    // these systems will be stopped\n  restart: [SystemC, systemGroupD]  // these systems will be started\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom System Execution Flow (JS/TS)\nDESCRIPTION: Shows how to set up and use a custom executor via `world.createCustomExecutor()` for frame-by-frame control over system execution. Define the executor with relevant groups (`physicsGroup`, `renderGroup`), then use `frame.begin()`, `frame.execute(group, [time], [delta])`, and `frame.end()` within a loop to run specific groups as needed.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/world.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// First, create a new frame with all the groups you may want to execute\nconst frame = world.createCustomExecutor(physicsGroup, renderGroup);\n\nasync run() {\n  // then later, in your game loop, you begin a new frame:\n  await frame.begin();\n  // execute any groups from the list above, any number of times:\n  await frame.execute(physicsGroup);\n  await frame.execute(physicsGroup, time, delta);  // optionally assume control of the clock\n  await frame.execute(renderGroup);\n  // and close out the frame:\n  await frame.end();\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// First, create a new frame with all the groups you may want to execute\nconst frame = world.createCustomExecutor(physicsGroup, renderGroup);\n\nasync run() {\n  // then later, in your game loop, you begin a new frame:\n  await frame.begin();\n  // execute any groups from the list above, any number of times:\n  await frame.execute(physicsGroup);\n  await frame.execute(physicsGroup, time, delta);  // optionally assume control of the clock\n  await frame.execute(renderGroup);\n  // and close out the frame:\n  await frame.end();\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Components from Entities in Becsy using JavaScript\nDESCRIPTION: Shows how to remove one or multiple components from an entity. It notes that enum components removal affects the related member components and removing nonexistent components raises an error. Components remain accessible until the end of the next frame allowing systems to react to removals. Dependencies include the entity instance and component classes. The snippet covers removal methods remove and removeAll invoked with component types, with consideration for recently deleted data access via system calls.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nentity.remove(ComponentA);\nentity.removeAll(ComponentA, ComponentB);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Numeric Vectors with Custom Class (TypeScript)\nDESCRIPTION: This TypeScript example shows how to associate a custom class with a numeric vector type using `Type.vector(baseType, names, CustomClass)`. It defines a `Vector3` class with an `add` method, creates a reusable `v3Type`, and declares component fields using `@field(type)`. This allows direct use of the custom class methods on the component data.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nclass Vector3 {\n  x: number;\n  y: number;\n  z: number;\n\n  add(that: Vector3): void {\n    this.x += that.x;\n    this.y += that.y;\n    this.z += that.z;\n  }\n}\n\nconst v3Type = Type.vector(Type.float64, ['x', 'y', 'z'], Vector3);\n\n@component class MovingEntity {\n  @field(v3Type) declare position: Vector3;\n  @field(v3Type) declare velocity: Vector3;\n}\n\nworld.build(sys => {\n  const player = sys.createEntity(\n    MovingEntity, {position: [10, 0, 10], velocity: [1.5, 0.2, 0.1]}\n  );\n  const mover = player.write(MovingEntity);\n  mover.position.add(mover.velocity);\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Movable Box Layout in HTML with TypeScript Entry (HTML)\nDESCRIPTION: Defines the HTML structure and styling for a fixed-size, movable blue box element on the page. Integrates with the ECS logic via a TypeScript entrypoint (src/main.ts) referenced as a module script. Requires a build tool like Vite for TypeScript compilation; dependencies include a supported web browser and a compiled TypeScript output. The input is user keyboard actions; the output is a visual DOM element ready for manipulation.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Simple Becsy Demo</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n    <style>\n      body {\n        position: relative;\n        padding: 0;\n        margin: 0;\n      }\n\n      #object {\n        position: absolute;\n        width: 60px;\n        height: 60px;\n        background-color: slateblue;\n      }\n    </style>\n    <script type=\"module\" src=\"./src/main.ts\"></script>\n  </head>\n  <body>\n    <!-- This is the object that our demo will move around the page. -->\n    <div id=\"object\"></div>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Defining ECS Components (TypeScript)\nDESCRIPTION: Defines TypeScript classes as component types using the `@component` and `@field` decorators. Decorators simplify the schema definition process, automatically registering properties with the world.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n@component class Acceleration {\n  @field({type: Type.float64, default: 0.1}) declare value: number;\n}\n\n@component class Position {\n  @field.float64 declare x: number;\n  @field.float64 declare y: number;\n  @field.float64 declare z: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Movable Box Layout in HTML with JavaScript Entry (HTML)\nDESCRIPTION: Defines the same HTML structure and box styling as the TypeScript version but references src/main.js as the script entrypoint instead. Suitable for projects using plain JavaScript without TypeScript compilation; requires a module-supporting browser and optionally a build process. Inputs remain user keyboard actions, while output is the dynamic visual representation of the movable object.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Simple Becsy Demo</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n    <style>\n      body {\n        position: relative;\n        padding: 0;\n        margin: 0;\n      }\n\n      #object {\n        position: absolute;\n        width: 60px;\n        height: 60px;\n        background-color: slateblue;\n      }\n    </style>\n    <script type=\"module\" src=\"./src/main.js\"></script>\n  </head>\n  <body>\n    <!-- This is the object that our demo will move around the page. -->\n    <div id=\"object\"></div>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Defining the Rendering System in JavaScript using Becsy\nDESCRIPTION: Defines a `Renderer` system by extending `System` from the Becsy library. It queries for entities possessing both `Position` and `DOMRenderable` components which are either new or have had their position changed. The `execute` method updates the `left` and `top` CSS style properties of the associated DOM node based on the entity's position. This implementation requires the `@lastolivegames/becsy` library and defined `Position` and `DOMRenderable` component classes.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/examples/simple.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport {System, Type} from '@lastolivegames/becsy';\n\nclass Position {/* ... */}\nclass Velocity {/* ... */}\nclass DOMRenderable {/* ... */}\n\nclass VelocityInputController extends System {/* ... */}\nclass Movement extends System {/* ... */}\n\nclass Renderer extends System {\n  // This system will render any entity that has both a Position and a DOMRenderable component, and\n  // that is new or whose position changed since the last frame. Note that we don't need to declare\n  // DOMRenderable as writable since we'll be modifying the DOM element's properties rather than\n  // updating the component's fields, and Becsy doesn't track that.\n  renderables = this.query(q => q.addedOrChanged.with(DOMRenderable).and.with(Position).track);\n\n  execute() {\n    for (const renderable of this.renderables.addedOrChanged) {\n      const {x, y} = renderable.read(Position);\n      const {node} = renderable.read(DOMRenderable);\n      // Sync the node's position from the entity by setting its style.\n      node.style.left = `${x}px`;\n      node.style.top = `${y}px`;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ECS Components (JavaScript)\nDESCRIPTION: Defines JavaScript classes that serve as component types, holding data for entities. The static `schema` property, using the `Type` enum, describes the structure and data types of the component's properties.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nclass Acceleration {\n  static schema = {\n    value: {type: Type.float64, default: 0.1}\n  };\n}\n\nclass Position {\n  static schema = {\n    x: {type: Type.float64},\n    y: {type: Type.float64},\n    z: {type: Type.float64}\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for Component Presence on Entities in Becsy using JavaScript\nDESCRIPTION: Describes methods used to verify the existence of components on an entity, including has, hasSomeOf, hasAllOf, hasAnyOtherThan, countHas, and hasWhich for enum components. These methods accept component types (including enums where applicable). All checks respect access to recently deleted data. They help in validation and conditional logic within systems. Dependencies include the entity instance and component or enum definitions. Methods return booleans or the active component type for enum queries.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nentity.has(ComponentA);\nentity.hasSomeOf(ComponentA, ComponentB);\nentity.hasAllOf(ComponentA, ComponentB);\nentity.hasAnyOtherThan(ComponentA, ComponentB);\nentity.countHas(ComponentA, ComponentB, ComponentC);\nentity.hasWhich(enumA);  // returns a component type or undefined\n```\n\n----------------------------------------\n\nTITLE: Defining ECS System for Logging Position (JavaScript)\nDESCRIPTION: Defines a system that extends `System`. It queries entities possessing the `Position` component and iterates through them in its `execute` method to read and log their position data using `entity.read()`. The query specifies read access.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nclass PositionLogSystem extends System {\n  // Define a query of entities that have the \"Position\" component.\n  entities = this.query(q => q.current.with(Position));\n\n  // This method will get called on every frame.\n  execute() {\n    // Iterate through all the entities on the query.\n    for (const entity of this.entities.current) {\n      // Access the component `Position` on the current entity.\n      const pos = entity.read(Position);\n      console.log(\n        `Entity with ordinal ${entity.ordinal} has component ` +\n        `Position={x: ${pos.x}, y: ${pos.y}, z: ${pos.z}}`\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Entities in Becsy with TypeScript and JavaScript\nDESCRIPTION: Shows how to explicitly delete an entity, which removes all components and triggers reactive queries accordingly. It highlights the requirement that the system performing deletion holds write entitlements on all components of the entity. To simplify handling unknown components, it illustrates a pattern for tagging entities for later deletion by another system with full write access. Includes component and system class definitions with queries and execute methods. Attempting to delete an already deleted entity raises an error.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/entities.md#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n@component class ToBeDeleted {}\n\n@system class SystemA extends System {\n  execute() {\n    // Instead of entity.delete(), just tag it:\n    entity.add(ToBeDeleted);\n  }\n}\n\n@system class Deleter extends System {\n  // Note the usingAll.write below, which grants write entitlements on all component types.\n  entities = this.query(q => q.current.with(ToBeDeleted).usingAll.write);\n  execute() {\n    for (const entity of this.entities.current) entity.delete();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Component Combinations in Becsy (TypeScript)\nDESCRIPTION: Demonstrates defining a static `validate` method on component `A` using TypeScript. This method checks if an entity simultaneously has components `A`, `B`, and `C`, throwing an error if the combination is invalid after the system execution finishes. Validation methods run for all entities modified by a system.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@component class A {\n  static validate(entity: Entity): void {\n    if (entity.has(A) && entity.hasAllOf(B, C)) {\n      throw new Error('cannot combine both B and C with A');\n    }\n  }\n}\n\n@component class B {}\n@component class C {}\n\nworld.build(sys => {\n  const entity = sys.createEntity(A, B, C);\n  // not an error yet -- we could still fix things by removing A, B or C\n});\n// but once the system finishes an error is thrown\n```\n\n----------------------------------------\n\nTITLE: Initializing Becsy Systems with Custom Properties (TypeScript/JavaScript)\nDESCRIPTION: Illustrates how to initialize custom properties on system instances when creating the world using the `defs` option in `World.create`. This allows passing configuration like `defaultSpeed` or `message` without using constructor arguments.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/systems.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst world = World.create({defs: [\n  AnotherSystem,\n  MySystem, {defaultSpeed: 100, message: 'too fast!'},\n]});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst world = World.create({defs: [\n  AnotherSystem,\n  MySystem, {defaultSpeed: 100, message: 'too fast!'}\n]});\n```\n\n----------------------------------------\n\nTITLE: Validating Component Combinations in Becsy (JavaScript)\nDESCRIPTION: Demonstrates defining a static `validate` method on component `A` using JavaScript classes. This method checks if an entity simultaneously has components `A`, `B`, and `C`, throwing an error if the combination is invalid after the system execution finishes. Validation methods run for all entities modified by a system.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nclass A {\n  static validate(entity: Entity): void {\n    if (entity.has(A) && entity.hasAllOf(B, C)) {\n      throw new Error('cannot combine both B and C with A');\n    }\n  }\n}\n\nclass B {}\nclass C {}\n\nworld.build(sys => {\n  const entity = sys.createEntity(A, B, C);\n  // not an error yet -- we could still fix things by removing A, B or C\n});\n// but once the system finishes an error is thrown\n```\n\n----------------------------------------\n\nTITLE: Defining Component Storage Options in Becsy - JavaScript\nDESCRIPTION: This JavaScript snippet shows how to assign storage options to a component class by setting a static 'options' property. It specifies the 'packed' storage strategy and a fixed capacity of 1000, controlling how components of this type store their field values in contiguous buffers. No decorators are used here, allowing plain JavaScript use. The approach impacts memory usage and performance characteristics for the component data.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/components.md#_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass A {\n  static options = {\n    storage: 'packed',\n    capacity: 1000\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Becsy ECS Library (Bash)\nDESCRIPTION: Provides the command line instruction to install the Becsy library using the npm package manager. This is the first step to integrate Becsy into your project.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @lastolivegames/becsy\n```\n\n----------------------------------------\n\nTITLE: Defining ECS System for Movement (TypeScript)\nDESCRIPTION: Defines a system using the `@system` decorator that extends `System`. It queries entities with `Acceleration` (read) and `Position` (write) components. The `execute` method updates the position based on acceleration and delta time, demonstrating `entity.read()` and `entity.write()` for component access.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\n@system class MovableSystem extends System {\n  // Define a query of entities that have \"Acceleration\" and \"Position\" components,\n  // specifying that while we only need to read \"Acceleration\", we'll need to both\n  // read and write \"Position\".\n  entities = this.query(\n    q => q.current.with(Acceleration).read.and.with(Position).write);\n\n  // This method will get called on every frame by default.\n  execute() {\n    // Iterate through all the entities on the query.\n    for (const entity of this.entities.current) {\n      // Get the `Acceleration` component as read-only and extract its value.\n      const acceleration = entity.read(Acceleration).value;\n\n      // Get the `Position` component as read-write.\n      const position = entity.write(Position);\n      position.x += acceleration * this.delta;\n      position.y += acceleration * this.delta;\n      position.z += acceleration * this.delta;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Becsy ECS World (JavaScript)\nDESCRIPTION: Initializes the main container object for the ECS world. This asynchronous call sets up the environment where entities, components, and systems will reside and interact.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/getting-started.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst world = await World.create();\n```\n\n----------------------------------------\n\nTITLE: Ordering Commands by Creation Order in becsy Query (JavaScript)\nDESCRIPTION: This JavaScript query snippet requests all entities with the Command component, writing access, and orders them by their ordinal property to ensure they are processed in creation order. Requires the Command component and is used within a System context in becsy. Key parameter: 'entity.ordinal' decides the ordering criterion. Outputs a sorted query result usable for sequential command processing systems.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/queries.md#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\nthis.query(q => q.current.with(Command).write.orderBy(entity => entity.ordinal))\n```\n\n----------------------------------------\n\nTITLE: Creating Entities via World Build Context (JS/TS)\nDESCRIPTION: Demonstrates using `world.build()` to create entities within a temporary system context (`sys`). This provides access to entity handles (like `entity1`) needed for initializing relationships or references between entities, such as setting `ref` fields (e.g., `fooRef`). Remember to `hold()` handles if they escape this block.\nSOURCE: https://github.com/lastolivegames/becsy/blob/main/docs/guide/architecture/world.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nworld.build(sys => {\n  const entity1 = sys.createEntity(ComponentFoo);\n  sys.createEntity(ComponentBar, {fooRef: entity1});\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nworld.build(sys => {\n  const entity1 = sys.createEntity(ComponentFoo);\n  sys.createEntity(ComponentBar, {fooRef: entity1});\n});\n```"
  }
]