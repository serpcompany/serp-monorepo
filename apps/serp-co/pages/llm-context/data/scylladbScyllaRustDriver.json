[
  {
    "owner": "scylladb",
    "repo": "scylla-rust-driver",
    "content": "TITLE: Querying ScyllaDB using Rust Driver\nDESCRIPTION: This snippet demonstrates how to establish a connection to a ScyllaDB node, execute a query, and iterate over the results using the Rust driver. It showcases the async nature of the driver and the use of streams for efficient data retrieval.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\nlet uri = \"127.0.0.1:9042\";\n\nlet session: Session = SessionBuilder::new().known_node(uri).build().await?;\n\nlet query_pager = session.query_iter(\"SELECT a, b, c FROM ks.t\", &[]).await?;\nlet mut stream = query_pager.rows_stream::<(i32, i32, String)>()?;\nwhile let Some((a, b, c)) = stream.try_next().await? {\n    println!(\"a, b, c: {}, {}, {}\", a, b, c);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Scylla Rust Program\nDESCRIPTION: Sets up a minimal async Rust program with Scylla driver integration using Tokio runtime.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/create-project.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\nuse scylla::client::session::Session;\n\n#[tokio::main]\nasync fn main() {\n    println!(\"Hello scylla!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Dependencies in Cargo.toml\nDESCRIPTION: Specifies required dependencies including Scylla driver, Tokio async runtime, and utility crates for UUID and decimal handling, along with tracing support.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/create-project.md#2025-04-17_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nscylla = \"1.1\"\ntokio = { version = \"1.12\", features = [\"full\"] }\nfutures = \"0.3.6\"\nuuid = \"1.0\"\nbigdecimal = \"0.4\"\nnum-bigint = \"0.3\"\ntracing = \"0.1.36\"\ntracing-subscriber = { version = \"0.3.14\", features = [\"env-filter\"] }\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Scylla Cluster with Multiple Nodes in Rust\nDESCRIPTION: This snippet demonstrates how to create a Session object that connects to a Scylla cluster by specifying multiple known nodes. It includes options for setting connection timeout and metadata refresh intervals.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/connecting.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse std::error::Error;\nuse std::time::Duration;\nuse std::net::{IpAddr, Ipv4Addr, SocketAddr};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let uri = std::env::var(\"SCYLLA_URI\")\n        .unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n\n    let session: Session = SessionBuilder::new()\n        .known_node(uri)\n        .known_node(\"127.0.0.72:4321\")\n        .known_node(\"localhost:8000\")\n        .connection_timeout(Duration::from_secs(3))\n        .cluster_metadata_refresh_interval(Duration::from_secs(10))\n        .known_node_addr(SocketAddr::new(\n            IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)),\n            9000,\n        ))\n        .build()\n        .await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Establishing Connection and Performing Basic ScyllaDB Operations in Rust\nDESCRIPTION: This code snippet demonstrates the complete workflow of connecting to a ScyllaDB node, creating a keyspace and table, inserting data, and querying it back. It uses environment variable SCYLLA_URI or defaults to 127.0.0.1:9042 for connection. The example showcases prepared statements with parameter binding.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/example.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\n# extern crate futures;\nuse futures::TryStreamExt;\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    // Create a new Session which connects to node at 127.0.0.1:9042\n    // (or SCYLLA_URI if specified)\n    let uri = std::env::var(\"SCYLLA_URI\")\n        .unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n\n    let session: Session = SessionBuilder::new()\n        .known_node(uri)\n        .build()\n        .await?;\n\n    // Create an example keyspace and table\n    session\n        .query_unpaged(\n            \"CREATE KEYSPACE IF NOT EXISTS ks WITH REPLICATION = \\\n            {'class' : 'NetworkTopologyStrategy', 'replication_factor' : 1}\",\n            &[],\n        )\n        .await?;\n\n    session\n        .query_unpaged(\n            \"CREATE TABLE IF NOT EXISTS ks.extab (a int primary key)\",\n            &[],\n        )\n        .await?;\n\n    // Insert a value into the table\n    let to_insert: i32 = 12345;\n    session\n        .query_unpaged(\"INSERT INTO ks.extab (a) VALUES(?)\", (to_insert,))\n        .await?;\n\n    // Query rows from the table and print them\n    let mut iter = session.query_iter(\"SELECT a FROM ks.extab\", &[])\n        .await?\n        .rows_stream::<(i32,)>()?;\n    while let Some(read_row) = iter.try_next().await? {\n        println!(\"Read a value from row: {}\", read_row.0);\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Preparing and Executing a Basic Statement in Rust\nDESCRIPTION: Demonstrates how to prepare a CQL statement and execute it with bound values. The example first prepares an INSERT statement and then executes it with an integer value.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/prepared.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::prepared::PreparedStatement;\n\n// Prepare the statement for later execution\nlet prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.tab (a) VALUES(?)\")\n    .await?;\n\n// Execute the prepared statement with some values, just like an unprepared statement.\nlet to_insert: i32 = 12345;\nsession.execute_unpaged(&prepared, (to_insert,)).await?;\n# Ok(())\n# }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Paging with PreparedStatement\nDESCRIPTION: Example of manual paging implementation using prepared statements with explicit paging state management.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/paged.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\nuse scylla::response::{PagingState, PagingStateResponse};\nuse std::ops::ControlFlow;\n\nlet paged_prepared = session\n    .prepare(Statement::new(\"SELECT a, b, c FROM ks.t\").with_page_size(7))\n    .await?;\n\nlet mut paging_state = PagingState::start();\nloop {\n    let (res, paging_state_response) = session\n        .execute_single_page(&paged_prepared, &[], paging_state)\n        .await?;\n\n    let rows_res = res.into_rows_result()?;\n\n    println!(\n        \"Paging state response from the prepared statement execution: {:#?} ({} rows)\",\n        paging_state_response,\n        rows_res.rows_num(),\n    );\n\n    match paging_state_response.into_paging_control_flow() {\n        ControlFlow::Break(()) => {\n            break;\n        }\n        ControlFlow::Continue(new_paging_state) => {\n            paging_state = new_paging_state\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Batch Values in Rust with Scylla Driver\nDESCRIPTION: This snippet illustrates how to specify values for a batch statement in the Scylla Rust Driver. It shows how to handle different types of statements within a batch, including those with bound values and those without.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/batch.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::batch::Batch;\n\nlet mut batch: Batch = Default::default();\n\n// A statement with two bound values\nbatch.append_statement(\"INSERT INTO ks.tab(a, b) VALUES(?, ?)\");\n\n// A statement with one bound value\nbatch.append_statement(\"INSERT INTO ks.tab(a, b) VALUES(3, ?)\");\n\n// A statement with no bound values\nbatch.append_statement(\"INSERT INTO ks.tab(a, b) VALUES(5, 6)\");\n\n// Batch values is a tuple of 3 tuples containing values for each statement\nlet batch_values = ((1_i32, 2_i32), // Tuple with two values for the first statement\n                    (4_i32,),       // Tuple with one value for the second statement\n                    ());            // Empty tuple/unit for the third statement\n\n// Run the batch\n// Note that the driver will prepare the first two statements, due to them\n// not being prepared and having a non-empty list of values.\nsession.batch(&batch, batch_values).await?\n```\n\n----------------------------------------\n\nTITLE: Working with List Collections using Vec<T> in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates inserting and retrieving a list of integers using Vec<T> with the ScyllaDB Rust driver. The example shows how to insert a list into a table and then query and iterate through the results using the rows_stream method.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/collections.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\n\n// Insert a list of ints into the table\nlet my_list: Vec<i32> = vec![1, 2, 3, 4, 5];\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (&my_list,))\n    .await?;\n\n// Read a list of ints from the table\nlet mut stream = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(Vec<i32>,)>()?;\nwhile let Some((list_value,)) = stream.try_next().await? {\n    println!(\"{:?}\", list_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating and Setting Default ExecutionProfile for a Session in Rust\nDESCRIPTION: This example demonstrates how to create an ExecutionProfile with custom settings and set it as the default profile for a Scylla Session. The profile configures LocalOne consistency and disables request timeout.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/execution-profiles/create-and-use.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn Error>> {\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::statement::Consistency;\nuse scylla::client::execution_profile::ExecutionProfile;\n\nlet profile = ExecutionProfile::builder()\n    .consistency(Consistency::LocalOne)\n    .request_timeout(None) // no request timeout\n    .build();\n\nlet handle = profile.into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(handle)\n    .build()\n    .await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Proper vs. Improper Parameter Binding for Performance\nDESCRIPTION: Demonstrates correct and incorrect ways to use prepared statements with partition keys. Shows why binding partition key values as parameters is crucial for optimal performance.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/prepared.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::prepared::PreparedStatement;\n\n// WRONG - partition key value is passed in statement string\n// Load balancing will compute the wrong partition key\nlet wrong_prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.prepare_table (a, b, c) VALUES(12345, ?, 16)\")\n    .await?;\n\nsession.execute_unpaged(&wrong_prepared, (54321,)).await?;\n\n// GOOD - partition key values are sent as bound values\n// Other values can be sent any way you like, it doesn't matter\nlet good_prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.prepare_table (a, b, c) VALUES(?, ?, 16)\")\n    .await?;\n\nsession.execute_unpaged(&good_prepared, (12345, 54321)).await?;\n\n# Ok(())\n# }\n\n```\n\n----------------------------------------\n\nTITLE: Updating and Reading Counter Values with ScyllaDB Rust Driver\nDESCRIPTION: This code snippet demonstrates how to add to a Counter value and read Counter values from a table using the ScyllaDB Rust driver. It includes examples of executing CQL queries for both operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/counter.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse scylla::value::Counter;\n\n// Add to counter value\nlet to_add: Counter = Counter(100);\nsession\n    .query_unpaged(\"UPDATE keyspace.table SET c = c + ? WHERE pk = 15\", (to_add,))\n    .await?;\n\n// Read counter from the table\nlet mut stream = session.query_iter(\"SELECT c FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(Counter,)>()?;\nwhile let Some((counter_value,)) = stream.try_next().await? {\n    let counter_int_value: i64 = counter_value.0;\n    println!(\"{}\", counter_int_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring ExecutionProfile with All Available Options in ScyllaDB Rust Driver\nDESCRIPTION: This snippet demonstrates how to create a fully customized ExecutionProfile for ScyllaDB queries. It shows setting consistency levels, timeouts, retry policies, load balancing policies, and speculative execution policies. The created profile is then applied to a query statement using set_execution_profile_handle.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/execution-profiles/maximal-example.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn Error>> {\nuse scylla::statement::unprepared::Statement;\nuse scylla::policies::speculative_execution::SimpleSpeculativeExecutionPolicy;\nuse scylla::statement::{Consistency, SerialConsistency};\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::load_balancing::DefaultPolicy;\nuse scylla::policies::retry::FallthroughRetryPolicy;\nuse std::{sync::Arc, time::Duration};\n\nlet profile = ExecutionProfile::builder()\n    .consistency(Consistency::All)\n    .serial_consistency(Some(SerialConsistency::Serial))\n    .request_timeout(Some(Duration::from_secs(30)))\n    .retry_policy(Arc::new(FallthroughRetryPolicy::new()))\n    .load_balancing_policy(Arc::new(DefaultPolicy::default()))\n    .speculative_execution_policy(\n        Some(\n            Arc::new(\n                SimpleSpeculativeExecutionPolicy {\n                    max_retry_count: 3,\n                    retry_interval: Duration::from_millis(100),\n                }\n            )\n        )\n    )\n    .build();\n\nlet mut query = Statement::from(\"SELECT * FROM ks.table\");\nquery.set_execution_profile_handle(Some(profile.into_handle()));\n\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring Request Timeouts for Scylla Rust Driver\nDESCRIPTION: This code snippet demonstrates how to create a Scylla session with custom timeout settings using ExecutionProfiles. It shows setting up a profile with no timeout, creating a session with this profile, and then creating another profile with a 3-second timeout for use with specific statements.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/timeouts.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn timeouts() -> Result<(), Box<dyn Error>> {\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::statement::unprepared::Statement;\nuse std::time::Duration;\n\nlet uri = std::env::var(\"SCYLLA_URI\")\n    .unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n\nlet no_timeout_profile_handle = ExecutionProfile::builder()\n    .request_timeout(None) // no timeout\n    .build()\n    .into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(uri)\n    .default_execution_profile_handle(no_timeout_profile_handle) // no per-session timeout\n    .build()\n    .await?;\n\n// This statement, having no timeout, could block indefinitely if a queried node hangs.\nsession\n    .query_unpaged(\"TRUNCATE keyspace.table\", ())\n    .await?;\n\nlet three_sec_timeout_profile_handle = ExecutionProfile::builder()\n    .request_timeout(Some(Duration::from_secs(3))) // no timeout\n    .build()\n    .into_handle();\n\n// The below statement execution will last for no more than 3 seconds, yielding a RequestTimeout error\n// if no response arrives until then.\nlet mut statement: Statement = \"TRUNCATE keyspace.table\".into();\nstatement.set_execution_profile_handle(Some(three_sec_timeout_profile_handle));\nsession\n    .query_unpaged(statement, ())\n    .await?;\n\n#    Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Attaching ExecutionProfile to Specific Statements in Rust\nDESCRIPTION: This example shows how to create an ExecutionProfile and attach it to individual query statements. The profile sets All consistency level and a 30-second request timeout, which is then applied to two different queries.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/execution-profiles/create-and-use.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn Error>> {\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::Consistency;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse std::time::Duration;\n\nlet profile = ExecutionProfile::builder()\n    .consistency(Consistency::All)\n    .request_timeout(Some(Duration::from_secs(30)))\n    .build();\n\nlet handle = profile.into_handle();\n\nlet mut query1 = Statement::from(\"SELECT * FROM ks.table\");\nquery1.set_execution_profile_handle(Some(handle.clone()));\n\nlet mut query2 = Statement::from(\"SELECT pk FROM ks.table WHERE pk = ?\");\nquery2.set_execution_profile_handle(Some(handle));\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Inserting and Reading Blob Data in ScyllaDB using Rust\nDESCRIPTION: This code demonstrates how to insert and query Blob data in ScyllaDB using the Rust driver. Blob values are represented as Vec<u8> in Rust. The example shows inserting a Blob by reference and then reading Blob values using a rows stream.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/blob.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\n\n// Insert some blob into the table as a Vec<u8>\n// We can insert it by reference to not move the whole blob\nlet to_insert: Vec<u8> = vec![1, 2, 3, 4, 5];\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (&to_insert,))\n    .await?;\n\n// Read blobs from the table\nlet mut stream = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(Vec<u8>,)>()?;\nwhile let Some((blob_value,)) = stream.try_next().await? {\n    println!(\"{:?}\", blob_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring SSL Context for ScyllaDB Peer Verification in Rust\nDESCRIPTION: Steps to create and configure an SSL context for peer verification when connecting to ScyllaDB. Includes creating the context builder, setting up certificate paths, and configuring verification mode.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/test/tls/README.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet mut context_builder = SslContextBuilder::new(SslMethod::tls())?\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet ca_dir = fs::canonicalize(PathBuf::from(\"./test/certz/ca.crt\"))?\n```\n\nLANGUAGE: rust\nCODE:\n```\ncontext_builder.set_ca_file(ca_dir.as_path;\n```\n\nLANGUAGE: rust\nCODE:\n```\ncontext_builder.set_verify(SslVerifyMode::PEER);\n```\n\n----------------------------------------\n\nTITLE: Using UDT in Database Operations\nDESCRIPTION: Example showing how to insert and query UDT values using the Scylla Rust Driver. Demonstrates creating a UDT instance, inserting it into a table, and reading it back using async stream operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/udt.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse scylla::{DeserializeValue, SerializeValue};\n\n#[derive(Debug, DeserializeValue, SerializeValue)]\nstruct MyType {\n    int_val: i32,\n    text_val: Option<String>,\n}\n\n// Insert my_type into the table\nlet to_insert = MyType {\n    int_val: 17,\n    text_val: Some(\"Some string\".to_string()),\n};\n\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read MyType from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(MyType,)>()?;\nwhile let Some((my_type_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", my_type_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Parsing Query Results with Convenience Methods in Rust\nDESCRIPTION: Demonstrates how to use QueryResult convenience methods to parse rows from ScyllaDB queries. Shows examples of parsing single columns, first rows, and ensuring non-row results.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/result.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\n// Parse row as a single column containing an int value\nlet result = session\n    .query_unpaged(\"SELECT a from ks.tab\", &[])\n    .await?\n    .into_rows_result()?;\n\nfor row in result.rows::<(i32,)>()? {\n    let (int_value,): (i32,) = row?;\n}\n\n// first_row gets the first row and parses it as the given type\nlet first_int_val: (i32,) = session\n    .query_unpaged(\"SELECT a from ks.tab\", &[])\n    .await?\n    .into_rows_result()?\n    .first_row::<(i32,)>()?;\n\n// result_not_rows fails when the response is rows\nsession.query_unpaged(\"INSERT INTO ks.tab (a) VALUES (0)\", &[]).await?.result_not_rows()?\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Custom Struct Deserialization for Query Results\nDESCRIPTION: Demonstrates how to parse query results into custom structs by implementing the DeserializeRow trait. Shows struct definition and row parsing example.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/result.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::DeserializeRow;\nuse scylla::deserialize::row::DeserializeRow;\n\n#[derive(DeserializeRow)]\nstruct MyRow {\n    age: i32,\n    name: Option<String>,\n}\n\n// Parse row as two columns containing an int and text which might be null\nlet result_rows = session\n    .query_unpaged(\"SELECT a, b from ks.tab\", &[])\n    .await?\n    .into_rows_result()?;\n\nfor row in result_rows.rows::<MyRow>()? {\n    let my_row: MyRow = row?;\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Inserting and Reading Varint Values with Scylla Rust Driver\nDESCRIPTION: Example demonstrating how to insert and read Varint values using num_bigint::BigInt with the Scylla Rust Driver. The code shows how to convert a string to BigInt, insert it into a table, and then query and iterate over the results using an asynchronous rows stream.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/varint.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate num_bigint;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse num_bigint::BigInt;\nuse std::str::FromStr;\n\n// Insert a varint into the table\nlet to_insert: BigInt = BigInt::from_str(\"12345\")?;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a varint from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(BigInt,)>()?;\nwhile let Some((varint_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", varint_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Custom Statement Configuration in Rust\nDESCRIPTION: Shows how to create and configure a custom Statement object with specific consistency levels before execution. Demonstrates manual statement creation and parameter binding.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/unprepared.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::Consistency;\n\n// Create a Statement manually to change the Consistency to ONE\nlet mut my_statement: Statement = Statement::new(\"INSERT INTO ks.tab (a) VALUES(?)\");\nmy_statement.set_consistency(Consistency::One);\n\n// Insert a value into the table\nlet to_insert: i32 = 12345;\nsession.query_unpaged(my_statement, (to_insert,)).await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Connecting to Scylla Cloud Serverless Using a Secure Connection Bundle in Rust\nDESCRIPTION: This example shows how to connect to Scylla Cloud Serverless by providing a secure connection bundle file. It uses CloudSessionBuilder to create a connection with the specified TLS provider.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/connecting.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\n# fn check_only_compiles() {\nuse std::path::Path;\nuse std::error::Error;\nuse scylla::client::session_builder::CloudSessionBuilder;\nuse scylla::cloud::CloudTlsProvider;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let session =\n        CloudSessionBuilder::new(Path::new(\"config_data.yaml\"), CloudTlsProvider::OpenSsl010)\n            .unwrap()\n            .build()\n            .await\n            .unwrap();\n\n    Ok(())\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Manually Awaiting Schema Agreement in Scylla Rust Driver\nDESCRIPTION: This code snippet shows how to manually await schema agreement using the Session::await_schema_agreement method. It returns a Future that resolves when schema agreement is reached or times out based on the SessionConfig.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/schema-agreement.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nsession.await_schema_agreement().await?;\n```\n\n----------------------------------------\n\nTITLE: Loading a Secure Connection Bundle from a File for Scylla Cloud Serverless in Rust\nDESCRIPTION: This snippet demonstrates how to connect to Scylla Cloud Serverless by loading a secure connection bundle from a file. It shows how to manually open a configuration file and create a CloudConfig object.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/connecting.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\n# fn check_only_compiles() {\nuse std::path::Path;\nuse std::error::Error;\nuse std::fs::File;\nuse scylla::client::session_builder::CloudSessionBuilder;\nuse scylla::cloud::{CloudConfig, CloudTlsProvider};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let mut file = File::open(\"config_data.yaml\").unwrap();\n    let config = CloudConfig::from_reader(&mut file, CloudTlsProvider::OpenSsl010).unwrap();\n    let session = CloudSessionBuilder::from_config(config)\n        .build()\n        .await\n        .unwrap();\n\n    Ok(())\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Tracing Unprepared Paged Queries with Session::query_iter\nDESCRIPTION: Demonstrates how to enable tracing for unprepared statements using query_iter, stream the results, and retrieve tracing information for each query execution. Uses Statement to create an unprepared query with tracing enabled.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/paged.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\nuse scylla::observability::tracing::TracingInfo;\nuse futures::StreamExt;\nuse uuid::Uuid;\n\n// Create a Statement manually and enable tracing\nlet mut query: Statement = Statement::new(\"SELECT * FROM ks.tab\");\nquery.set_tracing(true);\n\n// Create a paged query iterator and fetch pages\nlet mut row_stream = session\n    .query_iter(query, &[])\n    .await?\n    .rows_stream::<(i32,)>()?;\nwhile let Some(_row) = row_stream.next().await {\n    // Receive rows\n}\n\n// Now there are tracing ids for each performed query\nlet tracing_ids: &[Uuid] = row_stream.tracing_ids();\n\nfor id in tracing_ids {\n    // Query tracing info from system_traces.sessions and system_traces.events\n    let tracing_info: TracingInfo = session.get_tracing_info(id).await?;\n    println!(\"tracing_info: {:#?}\", tracing_info);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing ScyllaDB Driver Metrics in Rust\nDESCRIPTION: Demonstrates how to access and display various metrics collected by the ScyllaDB driver including query counts, latencies, error rates, and connection statistics. Uses the Session::get_metrics() method to retrieve metrics and shows different ways to access specific metric values.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/metrics/metrics.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nlet metrics = session.get_metrics();\n\nprintln!(\"Queries requested: {}\", metrics.get_queries_num());\nprintln!(\"Iter queries requested: {}\", metrics.get_queries_iter_num());\nprintln!(\"Errors occurred: {}\", metrics.get_errors_num());\nprintln!(\"Iter errors occurred: {}\", metrics.get_errors_iter_num());\nprintln!(\"Average latency: {}\", metrics.get_latency_avg_ms()?);\nprintln!(\n    \"99.9 latency percentile: {}\",\n    metrics.get_latency_percentile_ms(99.9)?\n);\n\nlet snapshot = metrics.get_snapshot()?;\nprintln!(\"Min: {}\", snapshot.min);\nprintln!(\"Max: {}\", snapshot.max);\nprintln!(\"Mean: {}\", snapshot.mean);\nprintln!(\"Standard deviation: {}\", snapshot.stddev);\nprintln!(\"Median: {}\", snapshot.median);\nprintln!(\"75th percentile: {}\", snapshot.percentile_75);\nprintln!(\"95th percentile: {}\", snapshot.percentile_95);\nprintln!(\"98th percentile: {}\", snapshot.percentile_98);\nprintln!(\"99th percentile: {}\", snapshot.percentile_99);\nprintln!(\"99.9th percentile: {}\", snapshot.percentile_99_9);\n\nprintln!(\"Mean rate: {}\", metrics.get_mean_rate());\nprintln!(\"One minute rate: {}\", metrics.get_one_minute_rate());\nprintln!(\"Five minute rate: {}\", metrics.get_five_minute_rate());\nprintln!(\"Fifteen minute rate: {}\", metrics.get_fifteen_minute_rate());\n\nprintln!(\"Total connections: {}\", metrics.get_total_connections());\nprintln!(\"Connection timeouts: {}\", metrics.get_connection_timeouts());\nprintln!(\"Requests timeouts: {}\", metrics.get_request_timeouts());\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using chrono::NaiveDate in Scylla Rust Driver\nDESCRIPTION: Shows how to use chrono::NaiveDate for date operations when the chrono-04 feature is enabled. Supports dates from -262145-01-01 to 262143-12-31.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/date.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse chrono::NaiveDate;\nuse futures::TryStreamExt;\n\n// 2021-03-24\nlet to_insert = NaiveDate::from_ymd_opt(2021, 3, 24).unwrap();\n\n// Insert date into the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read NaiveDate from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(NaiveDate,)>()?;\nwhile let Some((date_value,)) = iter.try_next().await? {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Statement Options for Prepared Statements\nDESCRIPTION: Shows how to customize prepared statement options before execution, specifically setting the consistency level to ONE.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/prepared.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::prepared::PreparedStatement;\nuse scylla::statement::Consistency;\n\n// Prepare the statement for later execution\nlet mut prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.tab (a) VALUES(?)\")\n    .await?;\n\n// Set prepared statement consistency to One\n// This is the consistency with which this statement will be executed\nprepared.set_consistency(Consistency::One);\n\n// Execute the prepared statement with some values, just like an unprepared statement.\nlet to_insert: i32 = 12345;\nsession.execute_unpaged(&prepared, (to_insert,)).await?;\n# Ok(())\n# }\n\n```\n\n----------------------------------------\n\nTITLE: Tracing an Unprepared Statement in Scylla Rust Driver\nDESCRIPTION: Demonstrates how to enable tracing for an unprepared statement and retrieve the tracing information after execution. The code creates a statement, enables tracing with set_tracing(true), executes the query, and then uses the session's get_tracing_info method to fetch detailed tracing data.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/basic.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\nuse scylla::response::query_result::QueryResult;\nuse scylla::observability::tracing::TracingInfo;\nuse uuid::Uuid;\n\n// Create a Statement manually and enable tracing\nlet mut statement: Statement = Statement::new(\"INSERT INTO ks.tab (a) VALUES(4)\");\nstatement.set_tracing(true);\n\nlet res: QueryResult = session.query_unpaged(statement, &[]).await?;\nlet tracing_id: Option<Uuid> = res.tracing_id();\n\nif let Some(id) = tracing_id {\n    // Query tracing info from system_traces.sessions and system_traces.events\n    let tracing_info: TracingInfo = session.get_tracing_info(&id).await?;\n    println!(\"tracing_info: {:#?}\", tracing_info);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tracing Subscriber for Scylla Rust Driver Logging\nDESCRIPTION: This snippet demonstrates how to set up logging in a Scylla Rust Driver application using the tracing subscriber approach. It initializes the tracing subscriber, connects to Scylla, creates a keyspace, and executes a query that generates a warning message.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/logging/logging.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\n# extern crate tracing;\n# extern crate tracing_subscriber;\n# use std::error::Error;\n# use scylla::client::session::Session;\n# use scylla::client::session_builder::SessionBuilder;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    // Install global collector configured based on RUST_LOG env var\n    // This collector will receive logs from the driver\n    tracing_subscriber::fmt::init();\n\n    let uri = std::env::var(\"SCYLLA_URI\")\n        .unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n\n    info!(\"Connecting to {}\", uri);\n\n    let session: Session = SessionBuilder::new().known_node(uri).build().await?;\n    session\n        .query_unpaged(\n            \"CREATE KEYSPACE IF NOT EXISTS ks WITH REPLICATION = \\\n            {'class' : 'NetworkTopologyStrategy', 'replication_factor' : 1}\",\n            &[],\n        )\n        .await?;\n\n    // This query should generate a warning message\n    session.query_unpaged(\"USE ks\", &[]).await?;\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Working with CqlDuration Type in Scylla Rust Driver\nDESCRIPTION: This code demonstrates how to create a CqlDuration instance, insert it into a Scylla database table, and then read duration values from the table. The example uses the futures crate for asynchronous operations and query_iter with rows_stream for efficient query processing.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/duration.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse scylla::value::CqlDuration;\n\n// Insert some duration into the table\nlet to_insert: CqlDuration = CqlDuration { months: 1, days: 2, nanoseconds: 3 };\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read duration from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(CqlDuration,)>()?;\nwhile let Some((duration_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", duration_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Basic Unprepared Query Execution in Rust\nDESCRIPTION: Demonstrates how to execute a basic unprepared CQL insert statement using the Session interface. Shows passing a single integer value as a parameter.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/unprepared.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn unprepared_statement_example(session: &Session) -> Result<(), Box<dyn Error>> {\n// Insert a value into the table\nlet to_insert: i32 = 12345;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Working with Text Types in ScyllaDB Rust Driver\nDESCRIPTION: Example showing how to insert and query text data using both &str and String types. Demonstrates inserting string literals and String objects, as well as reading text values from the database into String types. Uses async/await syntax for database operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/text.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\n\n// Insert some text into the table as a &str\nlet to_insert_str: &str = \"abcdef\";\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert_str,))\n    .await?;\n\n// Insert some text into the table as a String\nlet to_insert_string: String = \"abcdef\".to_string();\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert_string,))\n    .await?;\n\n// Read ascii/text/varchar from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(String,)>()?;\nwhile let Some((text_value,)) = iter.try_next().await? {\n    println!(\"{}\", text_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Basic Statement Value Binding in Rust\nDESCRIPTION: Demonstrates different methods for binding values to ScyllaDB statements using slices, tuples, and custom structs. Shows how to use empty values, multiple parameters, and named fields.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/values.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::SerializeRow;\n# use scylla::client::session::Session;\n# use scylla::value::CqlValue;\n# use std::error::Error;\n# use std::collections::HashMap;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\n// Empty slice means that there are no values to send\nsession.query_unpaged(\"INSERT INTO ks.tab (a) VALUES(1)\", &[]).await?;\n\n// Empty tuple/unit also means that there are no values to send\nsession.query_unpaged(\"INSERT INTO ks.tab (a) VALUES(1)\", ()).await?;\n\n// Sending three integers using a slice:\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a, b, c) VALUES(?, ?, ?)\", [1_i32, 2, 3].as_ref())\n    .await?;\n\n// Sending an integer and a string using a tuple\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a, b) VALUES(?, ?)\", (2_i32, \"Some text\"))\n    .await?;\n\n// Sending an integer and a string using a named struct.\n// Names of fields must match names of columns in request,\n// but having them in the same order is not required.\n// If the fields are in the same order, you can use attribute:\n// `#[scylla(flavor = \"enforce_order\")]`\n// in order to skip sorting the fields and just check if they\n// are in the same order. See documentation of this macro\n// for more information.\n#[derive(SerializeRow)]\nstruct IntString {\n    a: i32,\n    b: String,\n}\n\nlet int_string = IntString {\n    a: 42_i32,\n    b: \"hello\".to_owned(),\n};\n\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a, b) VALUES(?, ?)\", int_string)\n    .await?;\n\n// You can use named bind markers in statement if you want\n// your names in struct to be different than column names.\n#[derive(SerializeRow)]\nstruct IntStringCustom {\n    first_value: i32,\n    second_value: String,\n}\n\nlet int_string_custom = IntStringCustom {\n    first_value: 42_i32,\n    second_value: \"hello\".to_owned(),\n};\n\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a, b) VALUES(:first_value, :second_value)\", int_string_custom)\n    .await?;\n\n// Sending a single value as a tuple requires a trailing coma (Rust syntax):\nsession.query_unpaged(\"INSERT INTO ks.tab (a) VALUES(?)\", (2_i32,)).await?;\n\n// Each value can also be sent using a reference:\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a, b) VALUES(?, ?)\", &(&2_i32, &\"Some text\"))\n    .await?;\n\n// A map of named values can also be provided:\nlet mut vals: HashMap<&str, CqlValue> = HashMap::new();\nvals.insert(\"avalue\", CqlValue::Text(\"hello\".to_string()));\nvals.insert(\"bvalue\", CqlValue::Int(17));\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a, b) VALUES(:avalue, :bvalue)\", &vals)\n    .await?;\n\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling NULL Values in Query Results\nDESCRIPTION: Shows how to properly handle NULL values in query results by using Option<T> types when parsing columns that might contain NULL values.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/result.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\n\n// Parse row as two columns containing an int and text which might be null\nlet rows_result = session\n    .query_unpaged(\"SELECT a, b from ks.tab\", &[])\n    .await?\n    .into_rows_result()?;\n\nfor row in rows_result.rows::<(i32, Option<&str>)>()? {\n    let (int_value, str_or_null): (i32, Option<&str>) = row?;\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Inserting and Querying IP Addresses with ScyllaDB Rust Driver\nDESCRIPTION: Shows how to insert an IPv4 address into a ScyllaDB table and then query it back. Uses std::net::IpAddr for IP address representation and futures::TryStreamExt for async stream handling.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/inet.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse std::net::{IpAddr, Ipv4Addr};\n\n// Insert some ip address into the table\nlet to_insert: IpAddr = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read inet from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(IpAddr,)>()?;\nwhile let Some((inet_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", inet_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating and Executing Lightweight Transaction Statement in Rust with Scylla Driver\nDESCRIPTION: This snippet demonstrates how to create a Lightweight Transaction statement, set its consistency levels, and execute it using the Scylla Rust Driver. It shows how to manually create a Statement, set its consistency to ONE, use cross-datacenter serial consistency, and insert a value into a table.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/lwt.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::{Consistency, SerialConsistency};\n\n// Create a Statement manually to change the Consistency to ONE\nlet mut my_statement: Statement = Statement::new(\"INSERT INTO ks.tab (a) VALUES(?) IF NOT EXISTS\".to_string());\nmy_statement.set_consistency(Consistency::One);\n// Use cross-datacenter serial consistency\nmy_statement.set_serial_consistency(Some(SerialConsistency::Serial));\n\n// Insert a value into the table\nlet to_insert: i32 = 12345;\nsession.query_unpaged(my_statement, (to_insert,)).await?\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling NULL Values in ScyllaDB Statements\nDESCRIPTION: Shows how to handle NULL values in ScyllaDB statements using Option<T> type in Rust.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/values.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nlet null_i32: Option<i32> = None;\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a) VALUES(?)\", (null_i32,))\n    .await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Query Result Processing in Rust\nDESCRIPTION: Shows how to handle query results by iterating over returned rows and extracting values. Includes important notes about unpaged query limitations and performance considerations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/unprepared.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\n\n// Query rows from the table and print them\nlet result = session.query_unpaged(\"SELECT a FROM ks.tab\", &[])\n    .await?\n    .into_rows_result()?;\n\nlet mut iter = result.rows::<(i32,)>()?;\nwhile let Some(read_row) = iter.next().transpose()? {\n    println!(\"Read a value from row: {}\", read_row.0);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating an ExecutionProfile Based on Another Profile in Rust\nDESCRIPTION: This example demonstrates how to create a new ExecutionProfile based on an existing profile. This approach allows reusing common settings while overriding specific parameters, in this case setting a new consistency level while keeping the base profile's timeout.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/execution-profiles/create-and-use.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn Error>> {\nuse scylla::statement::Consistency;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse std::time::Duration;\n\nlet base_profile = ExecutionProfile::builder()\n    .request_timeout(Some(Duration::from_secs(30)))\n    .build();\n\nlet profile = base_profile.to_builder()\n    .consistency(Consistency::All)\n    .build();\n\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Disabling Automated Schema Agreement in Scylla Rust Driver\nDESCRIPTION: This snippet demonstrates how to disable the automatic schema agreement feature when building a Scylla session. It uses the SessionBuilder to configure and create a new session with auto_await_schema_agreement set to false.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/schema-agreement.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .auto_await_schema_agreement(false)\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Handling Bool Type in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates how to insert and read boolean values using the ScyllaDB Rust driver. The example shows inserting a true value and reading bool values from a table using async/await syntax.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/primitive.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\n// Insert a bool into the table\nlet to_insert: bool = true;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a bool from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(bool,)>()?;\nwhile let Some((bool_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", bool_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Map Collections using HashMap<K,V> in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates using HashMap<K,V> to represent a Map in ScyllaDB. The example creates a HashMap with string keys and integer values, inserts it into a table, and then queries and processes the results.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/collections.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse std::collections::HashMap;\n\n// Insert a map of text and int into the table\nlet mut my_map: HashMap<String, i32> = HashMap::new();\nmy_map.insert(\"abcd\".to_string(), 16);\n\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (&my_map,))\n    .await?;\n\n// Read a map from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(HashMap<String, i32>,)>()?;\nwhile let Some((map_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", map_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Basic Timestamp Operations Using CqlTimestamp\nDESCRIPTION: Demonstrates basic timestamp operations using the CqlTimestamp wrapper type, which internally represents time as milliseconds since Unix epoch. This is the default implementation without any additional features enabled.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/timestamp.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::value::CqlTimestamp;\nuse futures::TryStreamExt;\n\n// 64 seconds since unix epoch, 1970-01-01 00:01:04\nlet to_insert = CqlTimestamp(64 * 1000);\n\n// Write timestamp to the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read timestamp from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(CqlTimestamp,)>()?;\nwhile let Some((value,)) = iter.try_next().await? {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting and Querying Timeuuid Values with Scylla Rust Driver\nDESCRIPTION: This snippet demonstrates how to insert Timeuuid values into a Scylla database table and then query them back. It uses the CqlTimeuuid type which is a wrapper around uuid::Uuid with Scylla/Cassandra-specific ordering semantics.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/timeuuid.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# use std::str::FromStr;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse scylla::value::CqlTimeuuid;\n\n// Insert some timeuuid into the table\nlet to_insert: CqlTimeuuid = CqlTimeuuid::from_str(\"8e14e760-7fa8-11eb-bc66-000000000001\")?;\n\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read Timeuuid from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(CqlTimeuuid, )>()?;\n\nwhile let Some((timeuuid,)) = iter.try_next().await? {\n    println!(\"Read a value from row: {}\", timeuuid);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using Keyspaces with ScyllaDB Rust Driver\nDESCRIPTION: This Rust code demonstrates how to use keyspaces with the ScyllaDB Rust driver, including inserting data with and without specifying the keyspace name.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/usekeyspace.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nsession\n    .query_unpaged(\"INSERT INTO my_keyspace.tab (a) VALUES ('test1')\", &[])\n    .await?;\n\nsession.use_keyspace(\"my_keyspace\", false).await?;\n\n// Now we can omit keyspace name in the statement\nsession\n    .query_unpaged(\"INSERT INTO tab (a) VALUES ('test2')\", &[])\n    .await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Working with Set Collections using HashSet<T> in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates using HashSet<T> to represent a Set in ScyllaDB. The example shows creating a HashSet from a vector, inserting it into a table, and then querying and processing the results as a HashSet.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/collections.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse std::collections::HashSet;\n\n// Insert a set of ints into the table\nlet my_set: HashSet<i32> = vec![1, 2, 3, 4, 5].into_iter().collect();\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (&my_set,))\n    .await?;\n\n// Read a set of ints from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(HashSet<i32>,)>()?;\nwhile let Some((set_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", set_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Fetching Database Schema with ScyllaDB Rust Driver\nDESCRIPTION: This snippet demonstrates how to establish a connection to a ScyllaDB cluster and refresh schema metadata on-demand. It connects to a node specified by an environment variable or defaults to '127.0.0.1:9042'.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/schema/schema.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\n# use std::error::Error;\n# use scylla::client::session::Session;\n# use scylla::client::session_builder::SessionBuilder;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let uri = std::env::var(\"SCYLLA_URI\")\n        .unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n\n    let session: Session = SessionBuilder::new().known_node(uri).build().await?;\n    // Schema metadata will be fetched below\n    session.refresh_metadata().await?;\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Load Balancing Policy with Execution Profile in Scylla Rust Driver\nDESCRIPTION: This code demonstrates how to configure a custom load balancing policy in the Scylla Rust driver using execution profiles. It creates a DefaultPolicy instance, builds an ExecutionProfile with that policy, and passes it to the SessionBuilder as the default execution profile.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/load-balancing/load-balancing.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles(uri: &str) -> Result<(), Box<dyn Error>> {\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::policies::load_balancing::DefaultPolicy;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse std::sync::Arc;\n\nlet policy = Arc::new(DefaultPolicy::default());\n\nlet profile = ExecutionProfile::builder()\n    .load_balancing_policy(policy)\n    .build();\nlet handle = profile.into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(&uri)\n    .default_execution_profile_handle(handle)\n    .build()\n    .await?;\n# return Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling Double Type in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates working with Double (f64) values in ScyllaDB using the Rust driver. Shows how to insert and read 64-bit floating-point values using async operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/primitive.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\n// Insert a double into the table\nlet to_insert: f64 = 12345.0;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a double from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(f64,)>()?;\nwhile let Some((double_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", double_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Struct for UDT Serialization\nDESCRIPTION: Definition of a Rust struct that corresponds to the database UDT, implementing SerializeValue and DeserializeValue traits for database operations. The struct supports optional fields and maintains field name matching with the database schema.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/udt.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# async fn check_only_compiles() {\nuse scylla::{DeserializeValue, SerializeValue};\n\n// Define a custom struct that matches the User Defined Type created earlier.\n// Fields don't have to be in the same order as they are in the database.\n// By default, they must have the same names, but this can be worked around\n// using `#[rename] field attribute.\n// Wrapping a field in Option will gracefully handle null field values.\n#[derive(Debug, DeserializeValue, SerializeValue)]\nstruct MyType {\n    int_val: i32,\n    text_val: Option<String>,\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Executing Paged Query Using query_iter\nDESCRIPTION: Example showing how to perform an unprepared query with paging using query_iter and process results as a stream.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/paged.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::stream::StreamExt;\n\nlet mut rows_stream = session\n    .query_iter(\"SELECT a, b FROM ks.t\", &[])\n    .await?\n    .rows_stream::<(i32, i32)>()?;\n\nwhile let Some(next_row_res) = rows_stream.next().await {\n    let (a, b): (i32, i32) = next_row_res?;\n    println!(\"a, b: {}, {}\", a, b);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Query Idempotence in Scylla Rust Driver\nDESCRIPTION: Shows how to mark both regular Statements and PreparedStatements as idempotent. Setting idempotence tells the driver that a query can be safely retried multiple times without changing the result, enabling more aggressive retry strategies.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/retry-policy.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::prepared::PreparedStatement;\n\n// Specify that a Statement is idempotent\nlet mut my_query: Statement = Statement::new(\"SELECT a FROM ks.tab\");\nmy_query.set_is_idempotent(true);\n\n\n// Specify that a PreparedStatement is idempotent\nlet mut prepared: PreparedStatement = session\n    .prepare(\"SELECT a FROM ks.tab\")\n    .await?;\n\nprepared.set_is_idempotent(true);\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Working with Map Collections using BTreeMap<K,V> in ScyllaDB Rust Driver\nDESCRIPTION: Shows how to use BTreeMap<K,V> to represent an ordered Map in ScyllaDB. The example creates a BTreeMap with string keys and integer values, inserts it into a table, and then queries and processes the results.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/collections.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse std::collections::BTreeMap;\n\n// Insert a map of text and int into the table\nlet mut my_map: BTreeMap<String, i32> = BTreeMap::new();\nmy_map.insert(\"abcd\".to_string(), 16);\n\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (&my_map,))\n    .await?;\n\n// Read a map from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(BTreeMap<String, i32>,)>()?;\nwhile let Some((map_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", map_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using value::CqlDecimal for Decimal Data with Scylla Rust Driver\nDESCRIPTION: Example demonstrating how to insert and query decimal values using the built-in value::CqlDecimal type, which represents decimals as signed binary numbers in big-endian order with a 32-bit scale. This approach requires no additional feature flags.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/decimal.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse scylla::value::CqlDecimal;\nuse std::str::FromStr;\n\n// Insert a decimal (123.456) into the table\nlet to_insert: CqlDecimal =\n        CqlDecimal::from_signed_be_bytes_and_exponent(vec![0x01, 0xE2, 0x40], 3);\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a decimal from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(CqlDecimal,)>()?;\nwhile let Some((decimal_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", decimal_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Inspecting ScyllaDB Schema Information\nDESCRIPTION: This snippet shows how to retrieve and print detailed schema information from a ScyllaDB cluster. It iterates through all keyspaces and displays their tables, views, and user-defined types after refreshing the metadata.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/schema/schema.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\n# use std::error::Error;\n# use scylla::client::session::Session;\n# use scylla::client::session_builder::SessionBuilder;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let uri = std::env::var(\"SCYLLA_URI\")\n        .unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n\n    let session: Session = SessionBuilder::new().known_node(uri).build().await?;\n    // Schema metadata will be fetched below\n    session.refresh_metadata().await?;\n\n    let cluster_state = &session.get_cluster_state();\n    let keyspaces_iter = cluster_state.keyspaces_iter();\n\n    for (keyspace_name, keyspace_info) in keyspaces_iter {\n        println!(\"Keyspace {}:\", keyspace_name);\n        println!(\"\\tTables: {:#?}\", keyspace_info.tables);\n        println!(\"\\tViews: {:#?}\", keyspace_info.views);\n        println!(\"\\tUDTs: {:#?}\", keyspace_info.user_defined_types);\n    }\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting and Reading Tuple Data with Scylla Rust Driver\nDESCRIPTION: This code snippet demonstrates how to insert a tuple of int and string into a Scylla database table and then read it back. It uses the Scylla Rust Driver to perform these operations asynchronously.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/tuple.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\n\n// Insert a tuple of int and string into the table\nlet to_insert: (i32, String) = (1, \"abc\".to_string());\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a tuple of int and string from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<((i32, String),)>()?;\nwhile let Some((tuple_value,)) = iter.try_next().await? {\n    let int_value: i32 = tuple_value.0;\n    let string_value: String = tuple_value.1;\n    println!(\"({}, {})\", int_value, string_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Executing Paged Query Using execute_iter\nDESCRIPTION: Example demonstrating how to perform a prepared query with paging using execute_iter and process the results stream.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/paged.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::prepared::PreparedStatement;\nuse futures::stream::StreamExt;\n\nlet prepared: PreparedStatement = session\n    .prepare(\"SELECT a, b FROM ks.t\")\n    .await?;\n\nlet mut rows_stream = session\n    .execute_iter(prepared, &[])\n    .await?\n    .rows_stream::<(i32, i32)>()?;\n\nwhile let Some(next_row_res) = rows_stream.next().await {\n    let (a, b): (i32, i32) = next_row_res?;\n    println!(\"a, b: {}, {}\", a, b);\n}\n```\n\n----------------------------------------\n\nTITLE: Using bigdecimal::BigDecimal with Scylla Rust Driver\nDESCRIPTION: Example showing how to use the bigdecimal::BigDecimal type for handling decimal values in Scylla. This approach requires enabling the 'bigdecimal-04' feature flag in the crate configuration.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/decimal.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate bigdecimal;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse bigdecimal::BigDecimal;\nuse std::str::FromStr;\n\n// Insert a decimal into the table\nlet to_insert: BigDecimal = BigDecimal::from_str(\"12345.0\")?;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a decimal from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(BigDecimal,)>()?;\nwhile let Some((decimal_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", decimal_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using CqlTime for Time Operations in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates how to use the basic CqlTime type to insert and query time values in ScyllaDB. CqlTime is an i64 wrapper that directly represents time as nanoseconds since midnight.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/time.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::value::CqlTime;\nuse futures::TryStreamExt;\n\n// 64 seconds since midnight\nlet to_insert = CqlTime(64 * 1_000_000_000);\n\n// Insert time into the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read time from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(CqlTime,)>()?;\nwhile let Some((value,)) = iter.try_next().await? {\n    // ...\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using Unset Values in ScyllaDB Statements\nDESCRIPTION: Demonstrates how to use Unset values for better performance compared to NULL values when performing inserts.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/values.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::value::{MaybeUnset, Unset};\n\n// Inserting a null results in suboptimal performance\nlet null_i32: Option<i32> = None;\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a) VALUES(?)\", (null_i32,))\n    .await?;\n\n// Using MaybeUnset enum is better\nlet unset_i32: MaybeUnset<i32> = MaybeUnset::Unset;\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a) VALUES(?)\", (unset_i32,))\n    .await?;\n\n// If we are sure that a value should be unset we can simply use Unset\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a) VALUES(?)\", (Unset,))\n    .await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring Percentile Speculative Execution Policy for Scylla Rust Driver Session\nDESCRIPTION: This code snippet demonstrates how to create a PercentileSpeculativeExecutionPolicy, incorporate it into an ExecutionProfile, and apply it to a Session using SessionBuilder. The policy triggers speculative execution when the request to the current host is above a given percentile.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/speculative-execution/percentile.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{sync::Arc, time::Duration};\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::\n    policies::speculative_execution::PercentileSpeculativeExecutionPolicy,\n    client::execution_profile::ExecutionProfile,\n};\n\nlet policy = PercentileSpeculativeExecutionPolicy  {\n    max_retry_count: 3,\n    percentile: 99.0,\n};\n\nlet handle = ExecutionProfile::builder()\n    .speculative_execution_policy(Some(Arc::new(policy)))\n    .build()\n    .into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(handle)\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Working with Set Collections using Vec<T> in ScyllaDB Rust Driver\nDESCRIPTION: Shows how to use Vec<T> to represent a Set in ScyllaDB. The example demonstrates inserting a set of integers into a table and then querying and iterating through the results using rows_stream.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/collections.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\n\n// Insert a set of ints into the table\nlet my_set: Vec<i32> = vec![1, 2, 3, 4, 5];\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (&my_set,))\n    .await?;\n\n// Read a set of ints from the table\nlet mut stream = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(Vec<i32>,)>()?;\nwhile let Some((set_value,)) = stream.try_next().await? {\n    println!(\"{:?}\", set_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using time::Time for Time Operations in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates how to use time::Time to interact with time values in ScyllaDB when the time-03 feature is enabled. This provides a more ergonomic way to work with time values in the database.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/time.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate time;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse time::Time;\n\n// 01:02:03.456,789,012\nlet to_insert = Time::from_hms_nano(1, 2, 3, 456_789_012).unwrap();\n\n// Insert time into the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read time from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(Time,)>()?;\nwhile let Some((time_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", time_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring Simple Speculative Execution Policy for Scylla Session in Rust\nDESCRIPTION: This code snippet demonstrates how to create a SimpleSpeculativeExecutionPolicy, incorporate it into an ExecutionProfile, and use it when building a Scylla Session. It sets up a policy with 3 max retries and a 100ms retry interval.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/speculative-execution/simple.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{sync::Arc, time::Duration};\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::\n    policies::speculative_execution::SimpleSpeculativeExecutionPolicy,\n    client::execution_profile::ExecutionProfile,\n};\n\nlet policy = SimpleSpeculativeExecutionPolicy {\n    max_retry_count: 3,\n    retry_interval: Duration::from_millis(100),\n};\n\nlet handle = ExecutionProfile::builder()\n    .speculative_execution_policy(Some(Arc::new(policy)))\n    .build()\n    .into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(handle)\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Setting Batch Options in Rust with Scylla Driver\nDESCRIPTION: This snippet demonstrates how to set options on a Batch object, specifically showing how to change the consistency level of a batch statement in the Scylla Rust Driver.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/batch.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::batch::Batch;\nuse scylla::statement::Consistency;\n\n// Create a batch\nlet mut batch: Batch = Default::default();\nbatch.append_statement(\"INSERT INTO ks.tab(a) VALUES(16)\");\n\n// Set batch consistency to One\nbatch.set_consistency(Consistency::One);\n\n// Run the batch\nsession.batch(&batch, ((), )).await?\n```\n\n----------------------------------------\n\nTITLE: Working with Set Collections using BTreeSet<T> in ScyllaDB Rust Driver\nDESCRIPTION: Shows how to use BTreeSet<T> to represent an ordered Set in ScyllaDB. The example creates a BTreeSet from a vector, inserts it into a table, and then queries and processes the results as a BTreeSet.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/collections.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse std::collections::BTreeSet;\n\n// Insert a set of ints into the table\nlet my_set: BTreeSet<i32> = vec![1, 2, 3, 4, 5].into_iter().collect();\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (&my_set,))\n    .await?;\n\n// Read a set of ints from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(BTreeSet<i32>,)>()?;\nwhile let Some((set_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", set_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using chrono::NaiveTime for Time Operations in ScyllaDB Rust Driver\nDESCRIPTION: Shows how to use chrono::NaiveTime to interact with time values in ScyllaDB when the chrono-04 feature is enabled. Note that leap seconds are not supported and will cause errors.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/time.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate chrono;\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse chrono::NaiveTime;\nuse futures::TryStreamExt;\n\n// 01:02:03.456,789,012\nlet to_insert = NaiveTime::from_hms_nano_opt(1, 2, 3, 456_789_012);\n\n// Insert time into the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read time from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(NaiveTime,)>()?;\nwhile let Some((time_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", time_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling Tinyint Type in ScyllaDB Rust Driver\nDESCRIPTION: Shows how to work with Tinyint (i8) values in ScyllaDB using the Rust driver. Demonstrates inserting and reading 8-bit integer values with async operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/primitive.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\n// Insert a tinyint into the table\nlet to_insert: i8 = 123;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a tinyint from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(i8,)>()?;\nwhile let Some((tinyint_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", tinyint_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Snappy Compression in Scylla Rust Driver\nDESCRIPTION: This code demonstrates how to enable the Snappy compression algorithm when establishing a connection to a Scylla database. The example shows how to use SessionBuilder to create a Session with compression enabled, falling back to no compression if the database doesn't support it.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/compression.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::client::Compression;\nuse std::error::Error;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let uri = std::env::var(\"SCYLLA_URI\")\n        .unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n\n    let session: Session = SessionBuilder::new()\n        .known_node(uri)\n        .compression(Some(Compression::Snappy))\n        .build()\n        .await?;\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Manual Paging with Query\nDESCRIPTION: Example of manual paging implementation using unprepared queries with explicit paging state management.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/paged.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\nuse scylla::response::{PagingState, PagingStateResponse};\nuse std::ops::ControlFlow;\n\nlet paged_query = Statement::new(\"SELECT a, b, c FROM ks.t\").with_page_size(6);\n\nlet mut paging_state = PagingState::start();\nloop {\n    let (res, paging_state_response) = session\n        .query_single_page(paged_query.clone(), &[], paging_state)\n        .await?;\n\n    match paging_state_response.into_paging_control_flow() {\n        ControlFlow::Break(()) => {\n            break;\n        }\n        ControlFlow::Continue(new_paging_state) => {\n            paging_state = new_paging_state\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Timeuuid Objects Using UUID v1\nDESCRIPTION: This snippet demonstrates how to create custom Timeuuid objects using the UUID v1 features. It shows creating a Timeuuid with the current timestamp and a specified node ID, then storing and querying it from the database.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/timeuuid.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate uuid;\n# extern crate scylla;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# use std::str::FromStr;\nuse futures::TryStreamExt;\nuse scylla::value::CqlTimeuuid;\nuse uuid::Uuid;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\n\n// Tip: you can use random stable numbers or your MAC Address\nlet node_id = [0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC];\n\n// Build your Timeuuid with the current timestamp\nlet to_insert = CqlTimeuuid::from(Uuid::now_v1(&node_id));\n\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))  \n    .await?;\n\n// Read Timeuuid from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(CqlTimeuuid, )>()?;\n\nwhile let Some((timeuuid,)) = iter.try_next().await? {\n    println!(\"Read a value from row: {}\", timeuuid);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling Smallint Type in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates working with Smallint (i16) values in ScyllaDB using the Rust driver. Shows how to insert and read 16-bit integer values using async operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/primitive.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\n// Insert a smallint into the table\nlet to_insert: i16 = 12345;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a smallint from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(i16,)>()?;\nwhile let Some((smallint_value,)) = iter.try_next().await? {\n    println!(\"{}\", smallint_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Preparing Statements with Tracing in Scylla Rust Driver\nDESCRIPTION: This code snippet demonstrates how to enable tracing for a prepared statement, execute the prepare operation, and then retrieve tracing information using the tracing IDs. It shows the complete workflow from creating a statement, enabling tracing, preparing it across all connections, and finally querying the tracing info.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/prepare.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate uuid;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::prepared::PreparedStatement;\nuse scylla::observability::tracing::TracingInfo;\nuse uuid::Uuid;\n\n// Prepare the statement with tracing enabled\nlet mut to_prepare: Statement = Statement::new(\"SELECT a FROM ks.tab\");\nto_prepare.set_tracing(true);\n\nlet mut prepared: PreparedStatement = session\n    .prepare(to_prepare)\n    .await?;\n\n// Now there are tracing ids for each prepare request\nlet tracing_ids: &[Uuid] = &prepared.prepare_tracing_ids;\n\nfor id in tracing_ids {\n    // Query tracing info from system_traces.sessions and system_traces.events\n    let tracing_info: TracingInfo = session.get_tracing_info(id).await?;\n    println!(\"tracing_info: {:#?}\", tracing_info);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Authentication in Scylla Rust Driver\nDESCRIPTION: This snippet shows how to implement custom authentication for the Scylla Rust Driver. It includes the implementation of AuthenticatorSession and AuthenticatorProvider traits, and demonstrates how to use the custom authenticator with SessionBuilder.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/authentication.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bytes::{BufMut, BytesMut};\nuse async_trait::async_trait;\nuse scylla::authentication::{AuthError, AuthenticatorProvider, AuthenticatorSession};\n\nstruct CustomAuthenticator;\n\n#[async_trait]\nimpl AuthenticatorSession for CustomAuthenticator {\n    async fn evaluate_challenge(\n        &mut self,\n        _token: Option<&[u8]>,\n    ) -> Result<Option<Vec<u8>>, AuthError> {\n        Err(\"Challenges are not expected\".to_string())\n    }\n\n    async fn success(&mut self, _token: Option<&[u8]>) -> Result<(), AuthError> {\n        Ok(())\n    }\n}\n\nstruct CustomAuthenticatorProvider;\n\n#[async_trait]\nimpl AuthenticatorProvider for CustomAuthenticatorProvider {\n    async fn start_authentication_session(\n        &self,\n        _name: &str,\n    ) -> Result<(Option<Vec<u8>>, Box<dyn AuthenticatorSession>), AuthError> {\n        let mut response = BytesMut::new();\n        let cred = \"\\0cassandra\\0cassandra\";\n        let cred_length = 20;\n\n        response.put_i32(cred_length);\n        response.put_slice(cred.as_bytes());\n\n        Ok((Some(response.to_vec()), Box::new(CustomAuthenticator)))\n    }\n}\n\nasync fn authentication_example() -> Result<(), Box<dyn Error>> {\n    use scylla::client::session::Session;\n    use scylla::client::session_builder::SessionBuilder;\n\n    let _session: Session = SessionBuilder::new()\n        .known_node(\"127.0.0.1:9042\")\n        .authenticator_provider(Arc::new(CustomAuthenticatorProvider))\n        .build()\n        .await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Int Type in ScyllaDB Rust Driver\nDESCRIPTION: Shows how to work with Int (i32) values in ScyllaDB using the Rust driver. Demonstrates inserting and reading 32-bit integer values with async operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/primitive.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\n// Insert an int into the table\nlet to_insert: i32 = 12345;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read an int from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(i32,)>()?;\nwhile let Some((int_value,)) = iter.try_next().await? {\n    println!(\"{}\", int_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Bigint Type in ScyllaDB Rust Driver\nDESCRIPTION: Demonstrates working with Bigint (i64) values in ScyllaDB using the Rust driver. Shows how to insert and read 64-bit integer values using async operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/primitive.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\n// Insert a bigint into the table\nlet to_insert: i64 = 12345;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a bigint from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(i64,)>()?;\nwhile let Some((bigint_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", bigint_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Float Type in ScyllaDB Rust Driver\nDESCRIPTION: Shows how to work with Float (f32) values in ScyllaDB using the Rust driver. Demonstrates inserting and reading 32-bit floating-point values with async operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/primitive.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\n\n// Insert a float into the table\nlet to_insert: f32 = 123.0;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read a float from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(f32,)>()?;\nwhile let Some((float_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", float_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Using DefaultRetryPolicy with Unprepared Statement in Scylla Rust Driver\nDESCRIPTION: This example shows how to use the DefaultRetryPolicy with an unprepared statement. It demonstrates setting the retry policy directly on the Statement object and through an ExecutionProfile. The statement is then executed using the Session's query_unpaged method.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/default.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::DefaultRetryPolicy;\n\n// Create a Statement manually and set the retry policy\nlet mut my_statement: Statement = Statement::new(\"INSERT INTO ks.tab (a) VALUES(?)\");\nmy_statement.set_retry_policy(Some(Arc::new(DefaultRetryPolicy::new())));\n\n// You can also set retry policy in an execution profile\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(DefaultRetryPolicy::new()))\n    .build()\n    .into_handle();\nmy_statement.set_execution_profile_handle(Some(handle));\n\n// Execute the statement using this retry policy\nlet to_insert: i32 = 12345;\nsession.query_unpaged(my_statement, (to_insert,)).await?;\n```\n\n----------------------------------------\n\nTITLE: Tracing a Prepared Statement in Scylla Rust Driver\nDESCRIPTION: Shows how to enable tracing for a prepared statement by first preparing the statement, enabling tracing with set_tracing(true), executing it, and then retrieving tracing information. The prepared statement in this example performs a SELECT query from a table.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/basic.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::prepared::PreparedStatement;\nuse scylla::response::query_result::QueryResult;\nuse scylla::observability::tracing::TracingInfo;\nuse uuid::Uuid;\n\n// Prepare the statement\nlet mut prepared: PreparedStatement = session\n    .prepare(\"SELECT a FROM ks.tab\")\n    .await?;\n\n// Enable tracing for the prepared statement\nprepared.set_tracing(true);\n\nlet res: QueryResult = session.execute_unpaged(&prepared, &[]).await?;\nlet tracing_id: Option<Uuid> = res.tracing_id();\n\nif let Some(id) = tracing_id {\n    // Query tracing info from system_traces.sessions and system_traces.events\n    let tracing_info: TracingInfo = session.get_tracing_info(&id).await?;\n    println!(\"tracing_info: {:#?}\", tracing_info);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a DefaultPolicy in Rust\nDESCRIPTION: Demonstrates how to create and configure a DefaultPolicy instance using the builder pattern. It shows setting datacenter and rack preferences, enabling token awareness, and permitting datacenter failover.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/load-balancing/default-policy.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# fn test_if_compiles() {\nuse scylla::policies::load_balancing::DefaultPolicy;\n\nlet default_policy = DefaultPolicy::builder()\n        .prefer_datacenter_and_rack(\"dc1\".to_string(), \"rack1\".to_string())\n        .token_aware(true)\n        .permit_dc_failover(true)\n        .build();\n# }\n```\n\n----------------------------------------\n\nTITLE: Handling Case Sensitivity in Keyspace Names with Rust\nDESCRIPTION: This Rust code demonstrates how to handle case sensitivity in keyspace names when using the ScyllaDB Rust driver, showing different scenarios with case-sensitive and case-insensitive keyspace names.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/usekeyspace.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\n// lowercase name without case sensitivity will use my_keyspace\nsession.use_keyspace(\"my_keyspace\", false).await?;\n\n// lowercase name with case sensitivity will use my_keyspace\nsession.use_keyspace(\"my_keyspace\", true).await?;\n\n// uppercase name without case sensitivity will use my_keyspace\nsession.use_keyspace(\"MY_KEYSPACE\", false).await?;\n\n// uppercase name with case sensitivity will use MY_KEYSPACE\nsession.use_keyspace(\"MY_KEYSPACE\", true).await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using DowngradingConsistencyRetryPolicy with Unprepared Statement in Rust\nDESCRIPTION: Demonstrates how to apply the DowngradingConsistencyRetryPolicy to an unprepared Statement. Creates an ExecutionProfile with the policy and attaches it to a Statement before execution.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/downgrading-consistency.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::DowngradingConsistencyRetryPolicy;\n\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(DowngradingConsistencyRetryPolicy::new()))\n    .build()\n    .into_handle();\n\n// Create a Statement manually and set the retry policy\nlet mut my_statement: Statement = Statement::new(\"INSERT INTO ks.tab (a) VALUES(?)\");\nmy_statement.set_execution_profile_handle(Some(handle));\n\n// Execute the statement using this retry policy\nlet to_insert: i32 = 12345;\nsession.query_unpaged(my_statement, (to_insert,)).await?;\n```\n\n----------------------------------------\n\nTITLE: Comparing Query Result Fetching Methods in Scylla Rust Driver\nDESCRIPTION: A detailed comparison table of the three query result fetching methods (unpaged, manually paged, and automatically paged) available in the Scylla Rust Driver, highlighting their differences in API, performance characteristics, and appropriate use cases.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/paged.md#2025-04-17_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n| Query result fetching   | Unpaged                                                                                                                 | Paged manually                                                                                       | Paged automatically                                                                               |\n|-------------------------|-------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|\n| Exposed Session API     | `{query,execute}_unpaged`                                                                                               | `{query,execute}_single_page`                                                                        | `{query,execute}_iter`                                                                            |\n| Working                 | get all results in a single CQL frame, into a single Rust struct                                                        | get one page of results in a single CQL frame, into a single Rust struct                             | upon high-level iteration, fetch consecutive CQL frames and transparently iterate over their rows |\n| Cluster load            | potentially **HIGH** for large results, beware!                                                                         | normal                                                                                               | normal                                                                                            |\n| Driver overhead         | low - simple frame fetch                                                                                                | low - simple frame fetch                                                                             | considerable - `PagerWorker` is a separate tokio task                                         |\n| Feature limitations     | none                                                                                                                    | none                                                                                                 | speculative execution not supported                                                               |\n| Driver memory footprint | potentially **BIG** - all results have to be stored at once!                                                            | small - only one page stored at a time                                                               | small - at most constant number of pages stored at a time                                         |\n| Latency                 | potentially **BIG** - all results have to be generated at once!                                                         | considerable on page boundary - new page needs to be fetched                                         | small - next page is always pre-fetched in background                                             |\n| Suitable operations     | - in general: operations with empty result set (non-SELECTs)</br> - as possible optimisation: SELECTs with LIMIT clause | - for advanced users who prefer more control over paging, with less overhead of `PagerWorker`      | - in general: all SELECTs                                                                         |\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple DefaultPolicy in Rust\nDESCRIPTION: Demonstrates creating a DefaultPolicy with basic configuration, including preferred datacenter, token awareness, and datacenter failover settings.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/load-balancing/default-policy.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# fn test_if_compiles() {\nuse scylla::policies::load_balancing::DefaultPolicy;\n\nlet default_policy = DefaultPolicy::builder()\n        .prefer_datacenter(\"dc1\".to_string())\n        .token_aware(true)\n        .permit_dc_failover(true)\n        .build();\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring Latency Awareness in DefaultPolicy\nDESCRIPTION: Shows how to create a DefaultPolicy with latency awareness enabled. It configures parameters like exclusion threshold, update rate, retry period, and minimum measurements.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/load-balancing/default-policy.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# fn example() {\nuse scylla::policies::load_balancing::\n    LatencyAwarenessBuilder, DefaultPolicy\n};\nuse std::time::Duration;\n\nlet latency_awareness_builder = LatencyAwarenessBuilder::new()\n    .exclusion_threshold(3.)\n    .update_rate(Duration::from_secs(3))\n    .retry_period(Duration::from_secs(30))\n    .minimum_measurements(200);\n\nlet policy = DefaultPolicy::builder()\n        // Here further customisation is, of course, possible.\n        // e.g.: .prefer_datacenter(...)\n        .latency_awareness(latency_awareness_builder)\n        .build();\n# }\n```\n\n----------------------------------------\n\nTITLE: Using DowngradingConsistencyRetryPolicy with Session in Rust\nDESCRIPTION: Configures a Session with DowngradingConsistencyRetryPolicy as the default retry policy. This code creates an ExecutionProfile with the policy and builds a Session using this profile.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/downgrading-consistency.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::DowngradingConsistencyRetryPolicy;\n\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(DowngradingConsistencyRetryPolicy::new()))\n    .build()\n    .into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(handle)\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Using FallthroughRetryPolicy with Unprepared Statements\nDESCRIPTION: This snippet demonstrates applying the FallthroughRetryPolicy to an unprepared statement. The policy is set through an ExecutionProfile handle, which is then attached to the statement before execution.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/fallthrough.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::FallthroughRetryPolicy;\n\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(FallthroughRetryPolicy::new()))\n    .build()\n    .into_handle();\n\n// Create a Statement manually and set the retry policy\nlet mut my_statement: Statement = Statement::new(\"INSERT INTO ks.tab (a) VALUES(?)\");\nmy_statement.set_execution_profile_handle(Some(handle));\n\n// Execute the statement using this retry policy\nlet to_insert: i32 = 12345;\nsession.query_unpaged(my_statement, (to_insert,)).await?;\n```\n\n----------------------------------------\n\nTITLE: Implementing Monotonic Timestamp Generator in Scylla Rust Driver\nDESCRIPTION: This example demonstrates how to use a MonotonicTimestampGenerator with a Session in the Scylla Rust Driver. It shows creating a session with a timestamp generator and executing a statement that will automatically receive a timestamp from the generator.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/timestamp-generators.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn std::error::Error>> {\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::policies::timestamp_generator::MonotonicTimestampGenerator;\nuse scylla::statement::unprepared::Statement;\nuse std::sync::Arc;\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .timestamp_generator(Arc::new(MonotonicTimestampGenerator::new()))\n    .build()\n    .await?;\n\n// This statement will have a timestamp generated \n// by the monotonic timestamp generator\nlet my_statement: Statement = Statement::new(\"INSERT INTO ks.tab (a) VALUES(?)\");\nlet to_insert: i32 = 12345;\nsession.query_unpaged(my_statement, (to_insert,)).await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring FallthroughRetryPolicy in a Session\nDESCRIPTION: This example shows how to create a Session with a FallthroughRetryPolicy applied through an ExecutionProfile. The policy is set as the default retry policy for the session, which will affect all queries executed by it.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/fallthrough.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::FallthroughRetryPolicy;\n\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(FallthroughRetryPolicy::new()))\n    .build()\n    .into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(handle)\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Tracing a Batch Statement in Scylla Rust Driver\nDESCRIPTION: Illustrates how to enable tracing for batch statements by creating a batch, appending an INSERT statement, enabling tracing, and executing the batch. After execution, the code retrieves the tracing information using the tracing_id from the query result.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/basic.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::batch::Batch;\nuse scylla::response::query_result::QueryResult;\nuse scylla::observability::tracing::TracingInfo;\nuse uuid::Uuid;\n\n// Create a batch statement\nlet mut batch: Batch = Default::default();\nbatch.append_statement(\"INSERT INTO ks.tab (a) VALUES(4)\");\n\n// Enable tracing\nbatch.set_tracing(true);\n\nlet res: QueryResult = session.batch(&batch, ((),)).await?;\nlet tracing_id: Option<Uuid> = res.tracing_id();\n\nif let Some(id) = tracing_id {\n    // Query tracing info from system_traces.sessions and system_traces.events\n    let tracing_info: TracingInfo = session.get_tracing_info(&id).await?;\n    println!(\"tracing_info: {:#?}\", tracing_info);\n}\n```\n\n----------------------------------------\n\nTITLE: Using CqlDate Type in Scylla Rust Driver\nDESCRIPTION: Demonstrates how to use the basic CqlDate type for date operations. CqlDate is a u32 wrapper that matches Scylla's internal date representation, available without additional feature flags.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/date.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::value::CqlDate;\nuse futures::TryStreamExt;\n\n// 1970-01-08\nlet to_insert = CqlDate((1 << 31) + 7);\n\n// Insert date into the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read raw Date from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(CqlDate,)>()?;\nwhile let Some((date_value,)) = iter.try_next().await? {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating UDT Schema in ScyllaDB\nDESCRIPTION: SQL query to create a user-defined type 'my_type' with integer and text fields in the 'ks' keyspace.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/udt.md#2025-04-17_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TYPE ks.my_type (int_val int, text_val text)\n```\n\n----------------------------------------\n\nTITLE: Configuring Execution Profiles in Scylla Rust Driver\nDESCRIPTION: Demonstrates the priority hierarchy of execution settings in Scylla Rust Driver. Shows how consistency levels are applied from session profiles, statement profiles, and direct statement settings, with each level taking precedence over the previous one.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/execution-profiles/priority.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn Error>> {\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::Consistency;\nuse scylla::client::execution_profile::ExecutionProfile;\n\nlet session_profile = ExecutionProfile::builder()\n    .consistency(Consistency::One)\n    .build();\n\nlet query_profile = ExecutionProfile::builder()\n    .consistency(Consistency::Two)\n    .build();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(session_profile.into_handle())\n    .build()\n    .await?;\n\nlet mut query = Statement::from(\"SELECT * FROM ks.table\");\n\n// Statement is not assigned any specific profile, so session's profile is applied.\n// Therefore, the statement will be executed with Consistency::One.\nsession.query_unpaged(query.clone(), ()).await?;\n\nquery.set_execution_profile_handle(Some(query_profile.into_handle()));\n// Statement's profile is applied.\n// Therefore, the statement will be executed with Consistency::Two.\nsession.query_unpaged(query.clone(), ()).await?;\n\nquery.set_consistency(Consistency::Three);\n// An option is set directly on the Statement.\n// Therefore, the statement will be executed with Consistency::Three.\nsession.query_unpaged(query, ()).await?;\n\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using time::Date in Scylla Rust Driver\nDESCRIPTION: Demonstrates using time::Date when the time-03 feature is enabled. The date range support depends on specific feature flags enabled in the time crate.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/date.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\nuse time::{Date, Month};\n\n// 2021-03-24\nlet to_insert = Date::from_calendar_date(2021, Month::March, 24).unwrap();\n\n// Insert date into the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read Date from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(Date,)>()?;\nwhile let Some((date_value,)) = iter.try_next().await? {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Page Size for Statement\nDESCRIPTION: Shows how to set the page size for an unprepared Statement object.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/paged.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::unprepared::Statement;\n\nlet mut query: Statement = Statement::new(\"SELECT a, b FROM ks.t\");\nquery.set_page_size(16);\n\nlet _ = session.query_iter(query, &[]).await?;\n```\n\n----------------------------------------\n\nTITLE: Remapping Execution Profile Handles in Scylla Rust Driver\nDESCRIPTION: This code demonstrates how to create execution profiles, assign them to handles, and remap those handles dynamically. It shows the process of changing profile assignments for sessions and statements, illustrating the flexibility of workload management in Scylla Rust Driver.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/execution-profiles/remap.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn Error>> {\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::Consistency;\nuse scylla::client::execution_profile::ExecutionProfile;\n\nlet profile1 = ExecutionProfile::builder()\n    .consistency(Consistency::One)\n    .build();\n\nlet profile2 = ExecutionProfile::builder()\n    .consistency(Consistency::Two)\n    .build();\n\nlet mut handle1 = profile1.clone().into_handle();\nlet mut handle2 = profile2.clone().into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(handle1.clone())\n    .build()\n    .await?;\n\nlet mut query1 = Statement::from(\"SELECT * FROM ks.table\");\nlet mut query2 = Statement::from(\"SELECT pk FROM ks.table WHERE pk = ?\");\n\nquery1.set_execution_profile_handle(Some(handle1.clone()));\nquery2.set_execution_profile_handle(Some(handle2.clone()));\n\n// session1 -> handle1 -> profile1\n// query1 -> handle1 -> profile1\n// query2 -> handle2 -> profile2\n\n// We can now remap handle2 to profile1:\nhandle2.map_to_another_profile(profile1);\n// ...so that the mapping for query2 becomes as follows:\n// query2 -> handle2 -> profile1\n\n// We can also change query1's handle to handle2:\nquery1.set_execution_profile_handle(Some(handle2.clone()));\n// ...and remap handle1 to profile2:\nhandle1.map_to_another_profile(profile2);\n// ...yielding:\n// session1 -> handle1 -> profile2\n// query1 -> handle2 -> profile1\n// query2 -> handle2 -> profile1\n\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Configuring Schema Agreement Check Interval in Scylla Rust Driver\nDESCRIPTION: This example demonstrates how to set a custom interval for checking schema agreement using SessionBuilder. It uses the schema_agreement_interval method to set the duration between checks to 1 second.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/schema-agreement.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nSessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .schema_agreement_interval(Duration::from_secs(1))\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Implementing Query History Collection in Rust\nDESCRIPTION: Example demonstrating how to collect and print query execution history using the ScyllaDB Rust driver. Shows creation of a history collector, attaching it to a query, and accessing the collected history data.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/query-history.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate uuid;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse scylla::statement::unprepared::Statement;\nuse scylla::observability::history::{HistoryCollector, StructuredHistory};\nuse std::sync::Arc;\n\n// Create a query for which we would like to trace the history of its execution\nlet mut query: Statement = Statement::new(\"SELECT * FROM ks.t\");\n\n// Create a history collector and pass it to the query\nlet history_listener = Arc::new(HistoryCollector::new());\nquery.set_history_listener(history_listener.clone());\n\n// Run the query, doesn't matter if it failed, the history will still be saved\nlet _ignore_error = session.query_unpaged(query.clone(), ()).await;\n\n// Access the collected history and print it\nlet structured_history: StructuredHistory = history_listener.clone_structured_history();\nprintln!(\"Query history: {}\", structured_history);\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Implementing Log-Based Logging for Scylla Rust Driver\nDESCRIPTION: This snippet shows how to use the log-based approach for logging in the Scylla Rust Driver. It initializes env_logger, connects to Scylla, and creates and uses a keyspace.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/logging/logging.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate tokio;\n# extern crate tracing;\n# extern crate env_logger;\n# use std::error::Error;\n# use scylla::client::session::Session;\n# use scylla::client::session_builder::SessionBuilder;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    // Setup `log` collector that uses RUST_LOG env variable to configure\n    // verbosity.\n    env_logger::init();\n\n    let uri = std::env::var(\"SCYLLA_URI\").unwrap_or_else(|_| \"127.0.0.1:9042\".to_string());\n    info!(\"Connecting to {}\", uri);\n\n    let session: Session = SessionBuilder::new().known_node(uri).build().await?;\n    session.query_unpaged(\"CREATE KEYSPACE IF NOT EXISTS examples_ks WITH REPLICATION = {'class' : 'NetworkTopologyStrategy', 'replication_factor' : 1}\", &[]).await?;\n\n    session.query_unpaged(\"USE examples_ks\", &[]).await?;\n\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Timestamp Operations Using time::OffsetDateTime\nDESCRIPTION: Demonstrates timestamp handling using the time crate's OffsetDateTime type. Requires the time-03 feature flag. Provides millisecond precision with automatic UTC conversion and timezone handling.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/timestamp.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::TryStreamExt;\nuse time::{Date, Month, OffsetDateTime, PrimitiveDateTime, Time};\n\n// 64.123 seconds since unix epoch, 1970-01-01 00:01:04.123\nlet to_insert = PrimitiveDateTime::new(\n    Date::from_calendar_date(1970, Month::January, 1).unwrap(),\n    Time::from_hms_milli(0, 1, 4, 123).unwrap(),\n)\n.assume_utc();\n\n// Write timestamp to the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read timestamp from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(OffsetDateTime,)>()?;\nwhile let Some((timestamp_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", timestamp_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Value Binding in Rust\nDESCRIPTION: Demonstrates how to bind multiple values to a CQL statement using a tuple. Shows binding both integer and string values in a single query.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/unprepared.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\n// Sending an integer and a string using a tuple\nsession\n    .query_unpaged(\"INSERT INTO ks.tab (a, b, c) VALUES(?, ?, 'text2')\", (2_i32, \"Some text\"))\n    .await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: New DeserializeValue Trait Definition\nDESCRIPTION: Definition of the new DeserializeValue trait for deserializing individual CQL values with type checking.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub trait DeserializeValue<'frame, 'metadata>\nwhere\n    Self: Sized,\n{\n    fn type_check(typ: &ColumnType) -> Result<(), TypeCheckError>;\n    fn deserialize(\n        typ: &'metadata ColumnType<'metadata>,\n        v: Option<FrameSlice<'frame>>,\n    ) -> Result<Self, DeserializationError>;\n}\n```\n\n----------------------------------------\n\nTITLE: Timestamp Operations Using chrono::DateTime\nDESCRIPTION: Shows timestamp handling using the chrono crate's DateTime type with UTC timezone. Requires the chrono-04 feature flag. Provides millisecond precision and automatic UTC conversion.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/timestamp.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse chrono::{DateTime, NaiveDate, NaiveDateTime, NaiveTime, Utc};\nuse futures::TryStreamExt;\n\n// 64.123 seconds since unix epoch, 1970-01-01 00:01:04.123\nlet to_insert = NaiveDateTime::new(\n    NaiveDate::from_ymd_opt(1970, 1, 1).unwrap(),\n    NaiveTime::from_hms_milli_opt(0, 1, 4, 123).unwrap(),\n)\n.and_utc();\n\n// Write timestamp to the table\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read timestamp from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(DateTime<Utc>,)>()?;\nwhile let Some((timestamp_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", timestamp_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TLS with OpenSSL in Scylla Rust Driver\nDESCRIPTION: Code example showing how to set up a TLS connection to a Scylla node using OpenSSL. This snippet creates an SSL context, configures it with a CA certificate, and builds a session with TLS enabled.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/tls.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate openssl;\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse openssl::ssl::{SslContextBuilder, SslMethod, SslVerifyMode};\nuse std::path::PathBuf;\n\n# use std::error::Error;\n# async fn check_only_compiles() -> Result<(), Box<dyn Error>> {\nlet mut context_builder = SslContextBuilder::new(SslMethod::tls())?;\ncontext_builder.set_ca_file(\"ca.crt\")?;\ncontext_builder.set_verify(SslVerifyMode::PEER);\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9142\") // The the port is now 9142\n    .tls_context(Some(context_builder.build()))\n    .build()\n    .await?;\n\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Adding UUID v1 Feature to Project Dependencies\nDESCRIPTION: This snippet shows how to add the UUID crate with v1 feature enabled to a Cargo project. This is required to create custom timestamp-based Timeuuid objects.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/timeuuid.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo add uuid -F v1\n```\n\n----------------------------------------\n\nTITLE: Checking Current Schema Agreement Status in Scylla Rust Driver\nDESCRIPTION: This snippet shows how to check the current schema agreement status without retrying. It uses the Session::check_schema_agreement method and prints whether the schema is in agreement or not based on the result.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/schema-agreement.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nif session.check_schema_agreement().await?.is_some() {\n    println!(\"SCHEMA AGREED\");\n} else {\n    println!(\"SCHEMA IS NOT IN AGREEMENT\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example Scylla Cloud Serverless Configuration File in YAML\nDESCRIPTION: A sample configuration file for a Scylla Cloud Serverless cluster. It includes datacenter configuration, certificate data, server details, and authentication information needed to connect to a serverless cluster.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/connecting.md#2025-04-17_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ndatacenters:\n  datacenter1:\n    certificateAuthorityData: CERTIFICATE_DATA\n    server: 127.0.1.1:9142\n    nodeDomain: cql.cluster-id.scylla.com\n    insecureSkipTlsVerify: false\nauthInfos:\n  default:\n    clientCertificateData: CERTIFICATE_DATA\n    clientKeyData: KEY_DATA\n    username: scylladb\n    password: scylladb\ncontexts:\n  default:\n    datacenterName: datacenter1\n    authInfoName: default\ncurrentContext: default\n```\n\n----------------------------------------\n\nTITLE: Configuring DefaultRetryPolicy with Session in Scylla Rust Driver\nDESCRIPTION: This snippet demonstrates how to configure the DefaultRetryPolicy for a Session object using an ExecutionProfile. It creates a new SessionBuilder, sets the known node, and applies the default execution profile with the custom retry policy.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/default.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::DefaultRetryPolicy;\n\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(DefaultRetryPolicy::new()))\n    .build()\n    .into_handle();\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .default_execution_profile_handle(handle)\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Legacy Query Result Processing Example\nDESCRIPTION: Example showing how to process query results using the old API with FromRow trait.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet iter = session\n    .query_unpaged(\"SELECT name, age FROM my_keyspace.people\", &[])\n    .await?\n    .rows_typed::<(String, i32)>()?;\nfor row in iter {\n    let (name, age) = row?;\n    println!(\"{} has age {}\", name, age);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Table Definition for Performance Demonstration\nDESCRIPTION: SQL statement defining a sample table structure with a compound primary key used in the performance examples.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/prepared.md#2025-04-17_snippet_2\n\nLANGUAGE: sql\nCODE:\n```\nTABLE ks.prepare_table (\n    a int,\n    b int,\n    c int,\n    PRIMARY KEY (a, b)\n)\n```\n\n----------------------------------------\n\nTITLE: Applying DefaultRetryPolicy to Prepared Statement in Scylla Rust Driver\nDESCRIPTION: This snippet illustrates how to use the DefaultRetryPolicy with a prepared statement. It shows preparing a statement, setting the retry policy directly on the PreparedStatement object, and through an ExecutionProfile. The prepared statement is then executed using the Session's execute_unpaged method.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/default.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::prepared::PreparedStatement;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::DefaultRetryPolicy;\n\n// Create PreparedStatement manually and set the retry policy\nlet mut prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.tab (a) VALUES(?)\")\n    .await?;\nprepared.set_retry_policy(Some(Arc::new(DefaultRetryPolicy::new())));\n\n// You can also set retry policy in an execution profile\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(DefaultRetryPolicy::new()))\n    .build()\n    .into_handle();\nprepared.set_execution_profile_handle(Some(handle));\n\n// Execute the statement using this retry policy\nlet to_insert: i32 = 12345;\nsession.execute_unpaged(&prepared, (to_insert,)).await?;\n```\n\n----------------------------------------\n\nTITLE: Legacy FromCqlVal Trait Definition\nDESCRIPTION: Definition of the old FromCqlVal trait used for deserializing CQL values into Rust types.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub trait FromCqlVal<T>: Sized {\n    fn from_cql(cql_val: T) -> Result<Self, FromCqlValError>;\n}\n```\n\n----------------------------------------\n\nTITLE: Legacy FromRow Trait Definition\nDESCRIPTION: Definition of the old FromRow trait used for deserializing rows into custom types.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait FromRow: Sized {\n    fn from_row(row: Row) -> Result<Self, FromRowError>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Session with Default Authentication in Scylla Rust Driver\nDESCRIPTION: This snippet demonstrates how to use the default authentication method with username and password in the Scylla Rust Driver. It uses the SessionBuilder to create a new session with specified credentials.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/authentication.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::client::session::Session;\nuse scylla::client::session_builder::SessionBuilder;\n\nlet session: Session = SessionBuilder::new()\n    .known_node(\"127.0.0.1:9042\")\n    .user(\"myusername\", \"mypassword\")\n    .build()\n    .await?;\n```\n\n----------------------------------------\n\nTITLE: Legacy Iterator Query Example\nDESCRIPTION: Example showing how to process query results using iterator with the old API.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet mut rows_stream = session\n    .query_iter(\"SELECT name, age FROM my_keyspace.people\", &[])\n    .await?\n    .into_typed::<(String, i32)>();\n\nwhile let Some(next_row_res) = rows_stream.next().await {\n    let (a, b): (String, i32) = next_row_res?;\n    println!(\"a, b: {}, {}\", a, b);\n}\n```\n\n----------------------------------------\n\nTITLE: New DeserializeRow Trait Definition\nDESCRIPTION: Definition of the new DeserializeRow trait that provides improved type safety and performance by working with raw serialized data.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub trait DeserializeRow<'frame, 'metadata>\nwhere\n    Self: Sized,\n{\n    fn type_check(specs: &[ColumnSpec]) -> Result<(), TypeCheckError>;\n    fn deserialize(row: ColumnIterator<'frame, 'metadata>) -> Result<Self, DeserializationError>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing New Rust Project with Cargo\nDESCRIPTION: Creates a new Rust project directory structure using Cargo package manager.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/create-project.md#2025-04-17_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo new myproject\n```\n\n----------------------------------------\n\nTITLE: Tracing Prepared Paged Queries with Session::execute_iter\nDESCRIPTION: Shows how to enable tracing for prepared statements using execute_iter, stream the results, and retrieve tracing information for each query execution. Uses PreparedStatement with tracing enabled for better performance.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/paged.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::prepared::PreparedStatement;\nuse scylla::observability::tracing::TracingInfo;\nuse futures::StreamExt;\nuse uuid::Uuid;\n\n// Prepare the statement\nlet mut prepared: PreparedStatement = session\n    .prepare(\"SELECT a FROM ks.tab\")\n    .await?;\n\n// Enable tracing for the prepared statement\nprepared.set_tracing(true);\n\n// Create a paged query iterator and fetch pages\nlet mut row_stream = session\n    .execute_iter(prepared, &[])\n    .await?\n    .rows_stream::<(i32,)>()?;\nwhile let Some(_row) = row_stream.next().await {\n    // Receive rows\n}\n\n// Now there are tracing ids for each performed query\nlet tracing_ids: &[Uuid] = row_stream.tracing_ids();\n\nfor id in tracing_ids {\n    // Query tracing info from system_traces.sessions and system_traces.events\n    let tracing_info: TracingInfo = session.get_tracing_info(id).await?;\n    println!(\"tracing_info: {:#?}\", tracing_info);\n}\n```\n\n----------------------------------------\n\nTITLE: Program Output Example\nDESCRIPTION: Shows the expected output when running the basic Scylla Rust program.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/create-project.md#2025-04-17_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nHello scylla!\n```\n\n----------------------------------------\n\nTITLE: Using FallthroughRetryPolicy with Prepared Statements\nDESCRIPTION: This example shows how to apply the FallthroughRetryPolicy to a prepared statement. After preparing the statement, the ExecutionProfile handle with the policy is attached to it before execution.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/fallthrough.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::prepared::PreparedStatement;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::FallthroughRetryPolicy;\n\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(FallthroughRetryPolicy::new()))\n    .build()\n    .into_handle();\n\n// Create PreparedStatement manually and set the retry policy\nlet mut prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.tab (a) VALUES(?)\")\n    .await?;\n\nprepared.set_execution_profile_handle(Some(handle));\n\n// Run the query using this retry policy\nlet to_insert: i32 = 12345;\nsession.execute_unpaged(&prepared, (to_insert,)).await?;\n```\n\n----------------------------------------\n\nTITLE: ScyllaDB Container Ready Message\nDESCRIPTION: Sample output message indicating that the Scylla database has successfully started and is listening for CQL client connections on port 9042. This confirms the container is operational.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/scylla-docker.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nStarting listening for CQL clients on 172.17.0.2:9042\n```\n\n----------------------------------------\n\nTITLE: Configuring Page Size for PreparedStatement\nDESCRIPTION: Shows how to set the page size for a PreparedStatement object.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/paged.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::prepared::PreparedStatement;\n\nlet mut prepared: PreparedStatement = session\n    .prepare(\"SELECT a, b FROM ks.t\")\n    .await?;\n\nprepared.set_page_size(16);\n\nlet _ = session.execute_iter(prepared, &[]).await?;\n```\n\n----------------------------------------\n\nTITLE: Configuring Tracing with Log Feature in Cargo.toml\nDESCRIPTION: TOML configuration for enabling the log feature on the tracing crate in Cargo.toml, allowing integration with standard Rust logging frameworks.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/logging/logging.md#2025-04-17_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\ntracing = { version = \"0.1.40\" , features = [\"log\"] }\n```\n\n----------------------------------------\n\nTITLE: New Iterator Query Example\nDESCRIPTION: Example showing how to process query results using iterator with the new API.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet mut rows_stream = session\n    .query_iter(\"SELECT name, age FROM my_keyspace.people\", &[])\n    .await?\n    .rows_stream()?;\n\nwhile let Some(next_row_res) = rows_stream.next().await {\n    let (a, b): (String, i32) = next_row_res?;\n    println!(\"a, b: {}, {}\", a, b);\n}\n```\n\n----------------------------------------\n\nTITLE: Selecting and Using Keyspaces in CQL\nDESCRIPTION: This SQL snippet demonstrates how to select and use a keyspace in CQL, allowing for queries without specifying the keyspace name in each statement.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/usekeyspace.md#2025-04-17_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\ncqlsh> SELECT * FROM my_keyspace.table;\n\n a     | b     |\n-------+-------+\n 12345 | 54321 |\n\n(1 rows)\ncqlsh> USE my_keyspace;\ncqlsh:my_keyspace> SELECT * FROM table;\n\n a     | b     |\n-------+-------+\n 12345 | 54321 |\n\n(1 rows)\n```\n\n----------------------------------------\n\nTITLE: Adding Scylla with OpenSSL Support in Cargo.toml\nDESCRIPTION: Configuration for enabling the OpenSSL TLS feature in Cargo.toml. This snippet shows how to include the Scylla crate with OpenSSL support and add the necessary OpenSSL dependency.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/tls.md#2025-04-17_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nscylla = { version = \"0.4\", features = [\"openssl-010\"] }\nopenssl = \"0.10.70\"\n```\n\n----------------------------------------\n\nTITLE: Running CI Checks Locally\nDESCRIPTION: Commands to run the complete CI workflow locally, including format checks, cargo check, linter checks, build, and tests. Includes options for both Linux and macOS.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake ci\nmake dockerized-ci\n```\n\n----------------------------------------\n\nTITLE: New Query Result Processing Example\nDESCRIPTION: Example showing how to process query results using the new API with DeserializeRow trait.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.15-deserialization.md#2025-04-17_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet result = session\n    .query_unpaged(\"SELECT name, age FROM my_keyspace.people\", &[])\n    .await?\n    .into_rows_result()?;\n\nfor row in result.rows::<(&str, i32)>()? {\n    let (name, age) = row?;\n    println!(\"{} has age {}\", name, age);\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Query History Output - Query with Speculative Execution\nDESCRIPTION: Example output showing the execution history of a query that required speculative execution, with multiple nodes being tried before a successful response.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/query-history.md#2025-04-17_snippet_2\n\nLANGUAGE: none\nCODE:\n```\n=== Query #0 ===\n| start_time: 2022-08-26 15:08:28.525367409 UTC\n| Non-speculative attempts:\n| - Attempt #0 sent to 127.0.0.219:9042\n|   request send time: 2022-08-26 15:08:28.525409294 UTC\n|   No result yet\n|\n|\n| > Speculative fiber #0\n| fiber start time: 2022-08-26 15:08:28.537074167 UTC\n| - Attempt #0 sent to 127.0.0.217:9042\n|   request send time: 2022-08-26 15:08:28.537126083 UTC\n|   No result yet\n|\n|\n| > Speculative fiber #1\n| fiber start time: 2022-08-26 15:08:28.548050242 UTC\n| - Attempt #0 sent to 127.0.0.218:9042\n|   request send time: 2022-08-26 15:08:28.548089083 UTC\n|   Success at 2022-08-26 15:08:28.590052778 UTC\n|\n| Query successful at 2022-08-26 15:08:28.590078119 UTC\n=================\n```\n\n----------------------------------------\n\nTITLE: Testing Code Examples in Documentation\nDESCRIPTION: Commands to prepare and run tests for code examples in the documentation book, requiring a running Scylla instance.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Make a clean debug build, otherwise mdbook has problems with multiple versions\ncargo clean\ncargo build --examples\n\nmdbook test -L target/debug/deps/ docs\n```\n\n----------------------------------------\n\nTITLE: Sending Raw USE Keyspace Statement in Rust\nDESCRIPTION: This Rust snippet shows how to send a raw USE keyspace statement using the ScyllaDB Rust driver, although it's not the preferred method due to increased latency.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/usekeyspace.md#2025-04-17_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nsession.query_unpaged(\"USE my_keyspace\", &[]).await?;\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Using DowngradingConsistencyRetryPolicy with Prepared Statement in Rust\nDESCRIPTION: Shows how to use the DowngradingConsistencyRetryPolicy with a prepared statement. The code prepares a statement, then sets an ExecutionProfile with the policy before executing the statement.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/retry-policy/downgrading-consistency.md#2025-04-17_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::prepared::PreparedStatement;\nuse scylla::client::execution_profile::ExecutionProfile;\nuse scylla::policies::retry::DowngradingConsistencyRetryPolicy;\n\nlet handle = ExecutionProfile::builder()\n    .retry_policy(Arc::new(DowngradingConsistencyRetryPolicy::new()))\n    .build()\n    .into_handle();\n\n// Create PreparedStatement manually and set the retry policy\nlet mut prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.tab (a) VALUES(?)\")\n    .await?;\n\nprepared.set_execution_profile_handle(Some(handle));\n\n\n// Execute the statement using this retry policy\nlet to_insert: i32 = 12345;\nsession.execute_unpaged(&prepared, (to_insert,)).await?;\n```\n\n----------------------------------------\n\nTITLE: Building the Documentation Book\nDESCRIPTION: Command to build the documentation book from source, resulting in HTML output in the docs/book directory.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmdbook build docs\n# HTML will be in docs/book\n```\n\n----------------------------------------\n\nTITLE: Accessing Tables from Other Keyspaces in CQL\nDESCRIPTION: This SQL snippet shows how to access tables from other keyspaces while a specific keyspace is selected.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/usekeyspace.md#2025-04-17_snippet_1\n\nLANGUAGE: sql\nCODE:\n```\ncqlsh:my_keyspace> SELECT * FROM other_keyspace.other_table;\n```\n\n----------------------------------------\n\nTITLE: Running Tracing Subscriber Example with RUST_LOG Environment Variable\nDESCRIPTION: Shell command to execute the logging example with the info log level set via RUST_LOG environment variable.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/logging/logging.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nRUST_LOG=info cargo run\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL Dependencies on Debian/Ubuntu\nDESCRIPTION: Command to install OpenSSL development libraries and pkg-config on Debian/Ubuntu systems.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/tls.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\napt install libssl-dev pkg-config\n```\n\n----------------------------------------\n\nTITLE: Configuring SerializeValue Macro for Scylla Driver\nDESCRIPTION: This snippet demonstrates how to configure the SerializeValue macro to enforce field order and skip name checks, mimicking the behavior of the old ValueList macro in the Scylla Rust Driver.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.11-serialization.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(SerializeValue)]\n#[scylla(flavor = \"enforce_order\", skip_name_checks)]\nstruct Person {\n    name: String,\n    surname: String,\n    age: i16,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL Dependencies on Fedora\nDESCRIPTION: Command to install OpenSSL development libraries on Fedora systems.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/tls.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndnf install openssl-devel\n```\n\n----------------------------------------\n\nTITLE: Sample Query History Output - Successful Query\nDESCRIPTION: Example output showing the execution history of a successful query that completed without any retries or speculative execution.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/query-history.md#2025-04-17_snippet_1\n\nLANGUAGE: none\nCODE:\n```\n=== Query #0 ===\n| start_time: 2022-08-25 11:21:50.445075147 UTC\n| Non-speculative attempts:\n| - Attempt #0 sent to 127.0.0.1:9042\n|   request send time: 2022-08-25 11:21:50.445151628 UTC\n|   Success at 2022-08-25 11:21:50.447444362 UTC\n|\n| Query successful at 2022-08-25 11:21:50.447447970 UTC\n=================\n```\n\n----------------------------------------\n\nTITLE: Setting up RST documentation table of contents for execution profiles\nDESCRIPTION: RST directive that sets up a hidden table of contents for the execution profiles documentation, including links to related pages.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/execution-profiles/execution-profiles.md#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :glob:\n\n   create-and-use\n   maximal-example\n   priority\n   remap\n```\n\n----------------------------------------\n\nTITLE: Defining ValueList Trait in Rust for Scylla Driver\nDESCRIPTION: This code snippet defines the ValueList trait used in the old API for serializing data in the Scylla Rust Driver. It includes methods for serialization and writing to a request buffer.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/0.11-serialization.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait ValueList {\n    fn serialized(&self) -> SerializedResult<'_>;\n    fn write_to_request(&self, buf: &mut impl BufMut) -> Result<(), SerializeValuesError>;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL Dependencies on Arch Linux\nDESCRIPTION: Command to install OpenSSL and pkg-config on Arch Linux systems.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/connecting/tls.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npacman -S openssl pkg-config\n```\n\n----------------------------------------\n\nTITLE: Running ScyllaDB Container with Docker\nDESCRIPTION: Command to start a Scylla database container with Docker, exposing the CQL port (9042) and configuring it to use 2 CPUs with the --smp flag. This creates a temporary container that will be removed when stopped.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/scylla-docker.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# on Linux sudo might be required\ndocker run --rm -it -p 9042:9042 scylladb/scylla --smp 2\n```\n\n----------------------------------------\n\nTITLE: Running Full Tracing Example with Parameters in Scylla Rust Driver\nDESCRIPTION: Shell command to run the complete logging example from the driver repository with trace-level logging and a custom Scylla URI.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/logging/logging.md#2025-04-17_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nRUST_LOG=trace SCYLLA_URI=<scylla_ip>:9042 cargo run --example logging\n```\n\n----------------------------------------\n\nTITLE: Running Log-Based Example with Environment Variables in Scylla Rust Driver\nDESCRIPTION: Shell command to run the log-based logging example from the driver repository with trace-level logging and a custom Scylla URI.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/logging/logging.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nRUST_LOG=trace SCYLLA_URI=<scylla_ip>:9042 cargo run --example logging_log\n```\n\n----------------------------------------\n\nTITLE: Inserting and Retrieving UUID Values using Scylla Rust Driver\nDESCRIPTION: This code demonstrates how to insert a UUID into a Scylla database table and then retrieve it using a query. The example uses the uuid crate's Uuid type which is compatible with the Scylla driver, along with futures for handling asynchronous operations.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/uuid.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# extern crate scylla;\n# extern crate uuid;\n# extern crate futures;\n# use scylla::client::session::Session;\n# use std::error::Error;\n# async fn check_only_compiles(session: &Session) -> Result<(), Box<dyn Error>> {\nuse futures::TryStreamExt;\nuse uuid::Uuid;\n\n// Insert some uuid into the table\nlet to_insert: Uuid = Uuid::parse_str(\"8e14e760-7fa8-11eb-bc66-000000000001\")?;\nsession\n    .query_unpaged(\"INSERT INTO keyspace.table (a) VALUES(?)\", (to_insert,))\n    .await?;\n\n// Read uuid from the table\nlet mut iter = session.query_iter(\"SELECT a FROM keyspace.table\", &[])\n    .await?\n    .rows_stream::<(Uuid,)>()?;\nwhile let Some((uuid_value,)) = iter.try_next().await? {\n    println!(\"{:?}\", uuid_value);\n}\n# Ok(())\n# }\n```\n\n----------------------------------------\n\nTITLE: Running Static Checks for scylla-rust-driver\nDESCRIPTION: Command to execute static checks including clippy and formatting for the scylla-rust-driver project. This ensures the code compiles without warnings and adheres to the project's style guidelines.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake static\n```\n\n----------------------------------------\n\nTITLE: Creating and Executing a Batch Statement in Rust with Scylla Driver\nDESCRIPTION: This snippet demonstrates how to create a batch statement, add various types of statements to it (unprepared and prepared), specify bound values, and execute the batch using the Scylla Rust Driver.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/batch.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::batch::Batch;\nuse scylla::statement::unprepared::Statement;\nuse scylla::statement::prepared::PreparedStatement;\n\n// Create a batch statement\nlet mut batch: Batch = Default::default();\n\n// Add an unprepared statement to the batch using its text\nbatch.append_statement(\"INSERT INTO ks.tab(a, b) VALUES(1, 2)\");\n\n// Add an unprepared statement created manually to the batch\nlet unprepared: Statement = Statement::new(\"INSERT INTO ks.tab (a, b) VALUES(3, 4)\");\nbatch.append_statement(unprepared);\n\n// Add a prepared statement to the batch\nlet prepared: PreparedStatement = session\n    .prepare(\"INSERT INTO ks.tab (a, b) VALUES(?, 6)\")\n    .await?;\nbatch.append_statement(prepared);\n\n// Specify bound values to use with each statement\nlet batch_values = ((),\n                    (),\n                    (5_i32,));\n\n// Run the batch\nsession.batch(&batch, batch_values).await?\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Docker Compose for scylla-rust-driver\nDESCRIPTION: Command to run the test suite using a 3-node ScyllaDB cluster managed by Docker Compose. This is the standard way to test the driver on Linux systems.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake test\n```\n\n----------------------------------------\n\nTITLE: Managing ScyllaDB Test Cluster\nDESCRIPTION: Commands to control the ScyllaDB test cluster, including starting it without running tests and stopping it when finished.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake down\nmake up\n```\n\n----------------------------------------\n\nTITLE: Preparing a Batch Statement in Rust with Scylla Driver\nDESCRIPTION: This snippet shows how to prepare a whole batch statement at once, instead of preparing each statement individually. It demonstrates creating a batch with unprepared statements, preparing the entire batch, and then executing it with bound values.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/batch.md#2025-04-17_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse scylla::statement::batch::Batch;\n\n// Create a batch statement with unprepared statements\nlet mut batch: Batch = Default::default();\nbatch.append_statement(\"INSERT INTO ks.simple_unprepared1 VALUES(?, ?)\");\nbatch.append_statement(\"INSERT INTO ks.simple_unprepared2 VALUES(?, ?)\");\n\n// Prepare all statements in the batch at once\nlet prepared_batch: Batch = session.prepare_batch(&batch).await?;\n\n// Specify bound values to use with each statement\nlet batch_values = ((1_i32, 2_i32),\n                    (3_i32, 4_i32));\n\n// Run the prepared batch\nsession.batch(&prepared_batch, batch_values).await?\n```\n\n----------------------------------------\n\nTITLE: Defining a struct in scylla-cql with public field\nDESCRIPTION: Example of a struct defined in scylla-cql with a public field, used to illustrate API evolution strategies that maintain backwards compatibility.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/MAINTENANCE.md#2025-04-17_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub struct A {\n  pub field: Typ,\n}\n```\n\n----------------------------------------\n\nTITLE: Git Backporting Commands\nDESCRIPTION: Commands for cherry-picking commits and PRs when backporting changes to previous versions\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/MAINTENANCE.md#2025-04-17_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit cherry-pick -x -m 1 commit-sha\ngit cherry-pick -x commit-sha\n```\n\n----------------------------------------\n\nTITLE: Release Notes Template\nDESCRIPTION: Template for creating standardized release notes including sections for new features, bug fixes, documentation updates, and contributor statistics\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/MAINTENANCE.md#2025-04-17_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nThe ScyllaDB team is pleased to announce ScyllaDB Rust Driver X.Y.Z,\nan asynchronous CQL driver for Rust, optimized for Scylla, but also compatible with Apache Cassandra!\n\nSome interesting statistics:\n\n- over 2.103k downloads on crates!\n- over 556 GitHub stars!\n\n## Changes\n\n**New features / enhancements:**\n- Some new feature 1 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n- Some new feature 2 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n\n**Bug fixes:**\n- Some bugfix 1 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n- Some bugfix 2 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n\n**Documentation:**\n- Doc update 1 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n- Doc update 2 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n\n**CI / developer tool improvements:**\n- Update 1 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n- Update 2 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n\n**Others:**\n- Update 1 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n- Update 2 ([123](https://github.com/scylladb/scylla-rust-driver/pull/123))\n\nCongrats to all contributors and thanks everyone for using our driver!\n\n----------\n\nThe source code of the driver can be found here:\n- [https://github.com/scylladb/scylla-rust-driver](https://github.com/scylladb/scylla-rust-driver)\nContributions are most welcome!\n\nThe official crates.io registry entry is here:\n- [https://crates.io/crates/scylla](https://crates.io/crates/scylla)\n\nThank you for your attention, please do not hesitate to contact us if you have any questions, issues, feature requests, or are simply interested in our driver!\n\nContributors since the last release:\n\n| commits | author            |\n|---------|-------------------|\n| 45      | Lucille Perkins   |\n| 34      | Rachel Burton     |\n| 17      | Mercedes Marks    |\n```\n\n----------------------------------------\n\nTITLE: Running Dockerized Tests for macOS\nDESCRIPTION: Command for running tests inside a Docker container, designed for macOS users who cannot connect directly to a containerized Scylla instance from the host.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake dockerized-test\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx toctree for Migration Guides in RST\nDESCRIPTION: A ReStructuredText directive that creates a hidden table of contents tree (toctree) for navigation between migration guide documents. It includes references to the serialization and deserialization change guides.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/migration-guides/migration-guides.md#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :glob:\n\n   0.11-serialization\n   0.15-deserialization\n```\n\n----------------------------------------\n\nTITLE: Installing mdbook for Documentation\nDESCRIPTION: Command to install the mdbook tool, which is required for building and testing the project's documentation book.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo install mdbook\n```\n\n----------------------------------------\n\nTITLE: Serving the Documentation Book Locally\nDESCRIPTION: Command to serve the documentation book on a local HTTP server with automatic refreshing when changes are made.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/CONTRIBUTING.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmdbook serve docs\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Structure\nDESCRIPTION: Hierarchical documentation structure using markdown formatting to organize Scylla Rust Driver documentation topics and subtopics.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/SUMMARY.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Summary\n\n[Scylla Rust Driver](index.md)\n\n- [Quick start](quickstart/quickstart.md)\n    - [Creating a project](quickstart/create-project.md)\n    - [Running Scylla using Docker](quickstart/scylla-docker.md)\n    - [Connecting and executing a simple CQL statement](quickstart/example.md)\n\n[...remaining markdown content...]\n```\n\n----------------------------------------\n\nTITLE: RestructuredText Table of Contents Configuration\nDESCRIPTION: Hidden table of contents directive that includes simple and percentile strategy documentation pages.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/speculative-execution/speculative.md#2025-04-17_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n   :hidden:\n   :glob:\n\n   simple\n   percentile\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx toctree for ScyllaDB Rust Driver Documentation\nDESCRIPTION: A Sphinx toctree directive that defines the documentation structure for the ScyllaDB Rust Driver. The directive is configured to hide the table of contents itself while generating navigation links to all the specified documentation pages.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/contents.rst#2025-04-17_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n   :hidden:\n   :glob:\n   :titlesonly:\n\n   index\n   quickstart/quickstart\n   connecting/connecting\n   statements/statements\n   execution-profiles/execution-profiles\n   data-types/data-types\n   load-balancing/load-balancing\n   retry-policy/retry-policy\n   speculative-execution/speculative\n   metrics/metrics\n   migration-guides/migration-guides\n   logging/logging\n   tracing/tracing\n   schema/schema\n```\n\n----------------------------------------\n\nTITLE: Including Hidden Documentation with Sphinx toctree Directive in RST\nDESCRIPTION: A Sphinx toctree directive that hides related documentation pages but makes them available in the documentation structure. Links to various query-related documentation pages.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/statements/statements.md#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :glob:\n\n   unprepared\n   values\n   result\n   prepared\n   batch\n   paged\n   usekeyspace\n   schema-agreement\n   lwt\n   timeouts\n   timestamp-generators\n```\n\n----------------------------------------\n\nTITLE: Configuring RST Documentation Structure\nDESCRIPTION: RST toctree configuration for organizing documentation pages related to different data types in the ScyllaDB Rust driver.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/data-types/data-types.md#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :glob:\n\n   primitive\n   text\n   counter\n   blob\n   inet\n   uuid\n   timeuuid\n   date\n   time\n   timestamp\n   duration\n   decimal\n   varint\n   collections\n   tuple\n   udt\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Markdown Table of Contents in Scylla Rust Driver Documentation\nDESCRIPTION: This code snippet shows a hidden table of contents for the Scylla Rust driver documentation, using reStructuredText directives within a Markdown file. It links to related pages about basic queries, paged queries, prepared statements, and query history.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/tracing/tracing.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```{eval-rst}\n.. toctree::\n   :hidden:\n   :glob:\n\n   basic\n   paged\n   prepare\n   query-history\n```\n```\n\n----------------------------------------\n\nTITLE: RST Table of Contents Configuration\nDESCRIPTION: ReStructuredText directive for configuring the documentation's table of contents, hiding it and using glob pattern to include relevant pages.\nSOURCE: https://github.com/scylladb/scylla-rust-driver/blob/main/docs/source/quickstart/quickstart.md#2025-04-17_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :glob:\n\n   create-project\n   example\n   scylla*\n```"
  }
]