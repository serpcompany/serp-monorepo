[
  {
    "owner": "dotnet",
    "repo": "csharplang",
    "content": "TITLE: Implementing a Custom AsyncMethodBuilder in C#\nDESCRIPTION: Complete implementation pattern for a custom async method builder that works with a task type. This shows all required methods including Create, Start, SetStateMachine, SetException, SetResult, and the await handling methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/task-types.md#2025-04-21_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nclass MyTaskMethodBuilder<T>\n{\n    public static MyTaskMethodBuilder<T> Create();\n\n    public void Start<TStateMachine>(ref TStateMachine stateMachine)\n        where TStateMachine : IAsyncStateMachine;\n\n    public void SetStateMachine(IAsyncStateMachine stateMachine);\n    public void SetException(Exception exception);\n    public void SetResult(T result);\n\n    public void AwaitOnCompleted<TAwaiter, TStateMachine>(\n        ref TAwaiter awaiter, ref TStateMachine stateMachine)\n        where TAwaiter : INotifyCompletion\n        where TStateMachine : IAsyncStateMachine;\n    public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(\n        ref TAwaiter awaiter, ref TStateMachine stateMachine)\n        where TAwaiter : ICriticalNotifyCompletion\n        where TStateMachine : IAsyncStateMachine;\n\n    public MyTask<T> Task { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Iterator Method in C#\nDESCRIPTION: Demonstrates the implementation of an async iterator method that returns IAsyncEnumerable<T>. The method uses async/await pattern with yield return, including exception handling with try/finally blocks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nstatic async IAsyncEnumerable<int> MyIterator()\n{\n    try\n    {\n        for (int i = 0; i < 100; i++)\n        {\n            await Task.Delay(1000);\n            yield return i;\n        }\n    }\n    finally\n    {\n        await Task.Delay(200);\n        Console.WriteLine(\"finally\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Static Abstract Members in Interface - C#\nDESCRIPTION: The snippet demonstrates how to define static abstract members within an interface. This includes static properties, operators, and methods that implementing classes and structs must fulfill. Prior to C# 11, such static members couldn't be abstract, which limited the ability to generalize code that dealt with type-specific operations like operators. The code example shows an interface `IAddable` with static members to enforce addition operations for any type implementing it.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface IAddable<T> where T : IAddable<T>\n{\n    static abstract T Zero { get; }\n    static abstract T operator +(T t1, T t2);\n}\n\nstruct Int32 : â€¦, IAddable<Int32>\n{\n    static Int32 IAddable.operator +(Int32 x, Int32 y) => x + y; // Explicit\n    public static int Zero => 0;                          // Implicit\n}\n\npublic static T AddAll<T>(T[] ts) where T : IAddable<T>\n{\n    T result = T.Zero;                   // Call static operator\n    foreach (T t in ts) { result += t; } // Use `+`\n    return result;\n}\n\nint sixtyThree = AddAll(new [] { 1, 2, 4, 8, 16, 32 });\n```\n\n----------------------------------------\n\nTITLE: Potential Warning Scenario for Default Interface Method Invocation\nDESCRIPTION: This code snippet illustrates a scenario where invoking a default interface method on a generic type with 'allows ref struct' constraint could potentially cause runtime exceptions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    // Virtual method with default implementation\n    void M() { }\n}\n\n// Invocation of a virtual instance method with default implementation in a generic method that has the `allows ref struct`\n// anti-constraint\nvoid M<T>(T p)\n    where T : allows ref struct, I1\n{\n    p.M(); // Warn?\n}\n```\n\n----------------------------------------\n\nTITLE: Static Local Function Declaration Example in C#\nDESCRIPTION: Example showing the syntax and basic context for static local functions in C#. Static local functions cannot capture state from enclosing scope and must be explicitly declared with the static modifier.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/static-local-functions.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic LocalFunction() {\n    // Cannot access enclosing state\n    // Can only access static members and constants\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Reabstraction in Classes (C#)\nDESCRIPTION: Example showing reabstraction of methods in class hierarchies, which is allowed in classes but not in interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class Base\n{\n    public abstract void M();\n}\npublic abstract class A : Base\n{\n    public override void M() { }\n}\npublic abstract class B : A\n{\n    public override abstract void M(); // reabstract Base.M\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Init Property Accessors in C#\nDESCRIPTION: The code demonstrates how init properties can have three potential accessors: get, set, and init. The init accessor is automatically emitted when there is a set accessor, with the init accessor referencing the set accessor if not explicitly defined. Object initializers will use init if available, falling back to set if missing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// Example property with all three accessors\npublic string Property\n{\n    get { /* getter implementation */ }\n    set { /* setter implementation */ }\n    init { /* init implementation */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Init with Async Initialization Example\nDESCRIPTION: Demonstrates how init properties interact with async operations in object initializers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar student = new Student() \n{\n    Name = await SomeMethod()\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Default Interface Method Implementation\nDESCRIPTION: Shows a simple implementation of a concrete method in an interface with a default implementation, and how a class can use it without explicit implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M() { WriteLine(\"IA.M\"); }\n}\n\nclass C : IA { } // OK\n\nIA i = new C();\ni.M(); // prints \"IA.M\"\n\nnew C().M(); // error: class 'C' does not contain a member 'M'\n```\n\n----------------------------------------\n\nTITLE: Double Storage Warning Example in C# Primary Constructor\nDESCRIPTION: Shows a case where the compiler would issue a warning about potential double storage of a parameter. The parameter 'name' is both captured for use in ToString() and used to initialize a property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Person(string name)\n{\n    public string Name { get; set; } = name;   // warning: initialization\n    public override string ToString() => name; // capture\n}\n```\n\n----------------------------------------\n\nTITLE: C# Door State Switch Expression Example\nDESCRIPTION: Demonstrates usage of switch expression pattern matching to handle door state transitions based on actions and key availability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvar newState = (GetState(), action, hasKey) switch {\n    (DoorState.Closed, Action.Open, _) => DoorState.Opened,\n    (DoorState.Opened, Action.Close, _) => DoorState.Closed,\n    (DoorState.Closed, Action.Lock, true) => DoorState.Locked,\n    (DoorState.Locked, Action.Unlock, true) => DoorState.Closed,\n    (var state, _, _) => state };\n```\n\n----------------------------------------\n\nTITLE: Metadata Representation of Required Members in C#\nDESCRIPTION: This snippet shows the implementation of the two key attributes needed for the required members feature: RequiredMemberAttribute and SetsRequiredMembersAttribute. These attributes are recognized by the C# compiler to mark required members and constructors that initialize them.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]\n    public sealed class RequiredMemberAttribute : Attribute\n    {\n        public RequiredMemberAttribute() {}\n    }\n}\n\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]\n    public sealed class SetsRequiredMembersAttribute : Attribute\n    {\n        public SetsRequiredMembersAttribute() {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inferrability and Uniqueness Rules in C# Extension Declarations\nDESCRIPTION: Example showing validation rules for extension declarations, including inferrability of type parameters and uniqueness constraints within the same declaration space. The first extension has an error because T1 is not inferrable from the receiver type, while the third extension conflicts with the second one due to duplicate IsEmpty property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\npublic static class MyExtensions\n{\n    extension<T1>(IEnumerable<int>) // Error! T1 not inferrable\n    {\n        ...\n    }\n    extension<T2>(IEnumerable<T2>)\n    {\n        public bool IsEmpty { get ... }\n    }\n    extension<T3>(IEnumerable<T3>?)\n    {\n        public bool IsEmpty { get ... } // Error! Duplicate declaration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining C# Record Types with Positional Syntax\nDESCRIPTION: This snippet shows how to define record types using positional syntax. It demonstrates both a base record and a derived record with multiple parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nrecord R1(T1 P1);\nrecord R2(T1 P1, T2 P2, T3 P3) : R1(P1);\n```\n\n----------------------------------------\n\nTITLE: Lock Keyword Transformation for System.Threading.Lock\nDESCRIPTION: The special-case transformation that the compiler applies when the lock keyword is used with a System.Threading.Lock object. The compiler converts the lock statement to a using statement with EnterScope().\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/lock-object.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing (x.EnterScope())\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ref readonly and delegate conversion\nDESCRIPTION: Shows potential violation of readonly guarantees when converting between different ref parameter types in delegate assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    static readonly int f = 123;\n    static void Main()\n    {\n        var d = (in int x) => { };\n        d = (ref int x) => { x = 42; }; // warning: mismatch between `ref` and `in`\n        d(f); // changes value of `f` even though it is `readonly`!\n        System.Console.WriteLine(f); // prints 42\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IAsyncEnumerable Interface Structure in C#\nDESCRIPTION: Core interface definitions for async enumeration, including IAsyncEnumerable<T> and IAsyncEnumerator<T> with TryGetNext pattern for performance optimization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator();\n    }\n\n    public interface IAsyncEnumerator<out T> : IAsyncDisposable\n    {\n        ValueTask<bool> WaitForNextAsync();\n        T TryGetNext(out bool success);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: DefaultInterpolatedStringHandler Implementation in System.Runtime.CompilerServices\nDESCRIPTION: Implementation of DefaultInterpolatedStringHandler, a ref struct designed for direct use by the C# compiler to optimize interpolated string handling. This struct provides methods for appending literals and formatted values to build the final string.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// API Proposal issue: https://github.com/dotnet/runtime/issues/50601\nnamespace System.Runtime.CompilerServices\n{\n    [InterpolatedStringHandler]\n    public ref struct DefaultInterpolatedStringHandler\n    {\n        public DefaultInterpolatedStringHandler(int literalLength, int formattedCount);\n        public string ToStringAndClear();\n\n        public void AppendLiteral(string value);\n\n        public void AppendFormatted<T>(T value);\n        public void AppendFormatted<T>(T value, string? format);\n        public void AppendFormatted<T>(T value, int alignment);\n        public void AppendFormatted<T>(T value, int alignment, string? format);\n\n        public void AppendFormatted(ReadOnlySpan<char> value);\n        public void AppendFormatted(ReadOnlySpan<char> value, int alignment = 0, string? format = null);\n\n        public void AppendFormatted(string? value);\n        public void AppendFormatted(string? value, int alignment = 0, string? format = null);\n\n        public void AppendFormatted(object? value, int alignment = 0, string? format = null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Spread Element Target-Type Inference in C# Collection Literals\nDESCRIPTION: This code snippet shows the potential need for target-type inference when using spread elements in collection literals. It demonstrates conditional inclusion of elements and the challenges in evaluating spread elements without a target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<int> span = [a, ..b ? [c] : [d, e], f];\n\nSpan<int> span = [a, ..b ? [c, d, e] : [], f];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Collection Expressions in C# 12.0\nDESCRIPTION: Shows how to create a List<int> using the new collection expressions syntax introduced in C# 12.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nList<int> list = [1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Lambda Expressions with Attributes and Natural Types\nDESCRIPTION: Provides examples of using attributes directly within lambda expressions, showcasing improved functionality with the proposed natural type enhancements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\napp.MapAction([HttpGet(\"/\")] () => new Todo(Id: 0, Name: \"Name\"));\napp.MapAction([HttpPost(\"/\")] ([FromBody] Todo todo) => todo);\n```\n\n----------------------------------------\n\nTITLE: Index and Range Usage Examples\nDESCRIPTION: Examples demonstrating the usage of Index and Range operators with arrays, including from-end indexing and various range slicing patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar array = new int[] { 1, 2, 3, 4, 5 };\nvar thirdItem = array[2];    // array[2]\nvar lastItem = array[^1];    // array[new Index(1, fromEnd: true)]\n\nvar slice1 = array[2..^3];    // array[new Range(2, new Index(3, fromEnd: true))]\nvar slice2 = array[..^3];     // array[Range.EndAt(new Index(3, fromEnd: true))]\nvar slice3 = array[2..];      // array[Range.StartAt(2)]\nvar slice4 = array[..];       // array[Range.All]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Primary Constructor Usage in C#\nDESCRIPTION: An example showing how primary constructors can be used in class declarations, with parameters captured for initialization and member implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class B(bool b) { } // base class\n\npublic class C(bool b, int i, string s) : B(b) // b passed to base constructor\n{\n    public int I { get; set; } = i; // i used for initialization\n    public string S // s used directly in function members\n    {\n        get => s;\n        set => s = value ?? throw new ArgumentNullException(nameof(S));\n    }\n    public C(string s) : this(true, 0, s) { } // must call this(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Create Method for ImmutableArray in C#\nDESCRIPTION: Example of how to implement a create method for ImmutableArray<T> using the CollectionBuilder attribute. This allows ImmutableArray to work with collection expression syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionBuilder(typeof(ImmutableArray), \"Create\")]\npublic struct ImmutableArray<T> { ... }\n\npublic static class ImmutableArray\n{\n    public static ImmutableArray<T> Create<T>(ReadOnlySpan<T> items) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Generic Method with Collection Literal in C#\nDESCRIPTION: Example demonstrating how type inference might work with collection literals when calling a generic method that takes an array parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M<T>(T[] values);\nM([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: C# Null Checking Pattern Examples\nDESCRIPTION: Various syntax options for null checking using property patterns in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nif (s is object o) ... // o is of type object\nif (s is string x) ... // x is of type string\nif (s is {} x) ... // x is of type string\nif (s is {}) ...\n```\n\n----------------------------------------\n\nTITLE: Generated Code Equivalent for Primary Constructor in C#\nDESCRIPTION: Illustrates how the compiler transforms a primary constructor declaration into regular C# code. Shows parameter capturing through private fields, property initialization, and the call to the base constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C : B\n{\n    public int I { get; set; }\n    public string S\n    {\n        get => __s;\n        set => __s = value ?? throw new ArgumentNullException(nameof(value));\n    }\n    public C(string s) : this(0, s) { ... } // must call this(...)\n    \n    // generated members\n    private string __s; // for capture of s\n    public C(bool b, int i, string s)\n    {\n        __s = s; // capture s\n        I = i; // run I's initializer\n        B(b) // run B's constructor\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Constructors without 'this' Initializer in C#\nDESCRIPTION: Demonstrates a class with primary constructor parameters and additional constructors that don't use 'this' initializer. Shows how primary constructor parameters can be used for initialization and captured in properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\npublic class C(bool b, int i, string s) : B(b)\n{\n    public int I { get; set; } = i; // i used for initialization\n    public string S // s used directly in function members\n    {\n        get => s;\n        set => s = value ?? throw new ArgumentNullException(nameof(value));\n    }\n    public C(string s2) : base(true) // cannot use `string s` because it would shadow\n    { \n        s = s2; // must initialize s because it is captured by S\n    }\n    protected C(C original) : base(original) // copy constructor\n    {\n        this.s = original.s; // assignment to b and i not required because not captured\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar Modifications for C# Local Functions\nDESCRIPTION: Diff syntax showing grammar additions to support local functions, including declaration statements, headers, modifiers, and function bodies. Defines the syntactic structure for declaring local functions within block scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/local-functions.md#2025-04-21_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\ndeclaration-statement\n    : local-variable-declaration ';'\n    | local-constant-declaration ';'\n+   | local-function-declaration\n    ;\n\n+local-function-declaration\n+   : local-function-header local-function-body\n+   ;\n\n+local-function-header\n+   : local-function-modifiers? return-type identifier type-parameter-list?\n+       ( formal-parameter-list? ) type-parameter-constraints-clauses\n+   ;\n\n+local-function-modifiers\n+   : (async | unsafe)\n+   ;\n\n+local-function-body\n+   : block\n+   | arrow-expression-body\n+   ;\n```\n\n----------------------------------------\n\nTITLE: Ref Safety Examples in C#\nDESCRIPTION: Demonstrates the rules around ref safety with collection expressions, showing valid and invalid usage patterns with spans.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nstatic ReadOnlySpan<int> AsSpanConstants()\n{\n    return [1, 2, 3]; // ok: span refers to assembly data section\n}\n\nstatic ReadOnlySpan<T> AsSpan2<T>(T x, T y)\n{\n    return [x, y];    // error: span may refer to stack data\n}\n\nstatic ReadOnlySpan<T> AsSpan3<T>(T x, T y, T z)\n{\n    return (T[])[x, y, z]; // ok: span refers to T[] on heap\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring Definite Assignment in Disjunctive Patterns for C#\nDESCRIPTION: Shows how definite assignment becomes complex with 'or' patterns, especially when pattern variables are declared in mutually exclusive patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is 0 or int i)\n{\n    M(i); // is i definitely assigned here?\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nif ((e1, e2) is (0, int i) or (int i, 0))\n{\n    M(i);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IAsyncDisposable Interface in C#\nDESCRIPTION: Core interface definition for asynchronous resource disposal, returning ValueTask from DisposeAsync method. Used to enable cleanup of async resources.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        ValueTask DisposeAsync();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Discrepancy between Collection Expressions and Params Collections\nDESCRIPTION: This example demonstrates the discrepancy between collection expressions and params collections when dealing with a class that implements IEnumerable<long> but has a GetEnumerator() method returning IEnumerator<string>. Some conversions are rejected while others are allowed, leading to inconsistent behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass MyCollection : IEnumerable<long>\n{\n    IEnumerator<long> IEnumerable<long>.GetEnumerator() => throw null;\n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n\n    public IEnumerator<string> GetEnumerator() => throw null; \n\n    public void Add(long l) => throw null; \n    public void Add(string l) => throw null; \n}\n\nclass Program\n{\n    static void Main()\n    {\n        Test(\"2\"); // error CS0029: Cannot implicitly convert type 'string' to 'long'\n        Test([\"2\"]); // error CS1503: Argument 1: cannot convert from 'collection expressions' to 'string'\n        Test(3); // error CS1503: Argument 1: cannot convert from 'int' to 'string'\n        Test([3]); // Ok\n\n        MyCollection x1 = [\"2\"]; // error CS0029: Cannot implicitly convert type 'string' to 'long'\n        MyCollection x2 = [3];\n    }\n\n    static void Test(params MyCollection a)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Nullable Types with Declaration Pattern in C#\nDESCRIPTION: Example demonstrating how to use declaration patterns to test values of nullable types. The pattern matches if the value is non-null and can be cast to the target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nint? x = 3;\nif (x is int v) { // code using v }\n```\n\n----------------------------------------\n\nTITLE: Compilation Example for Collection Expressions with ImmutableArray in C#\nDESCRIPTION: Example showing how a collection expression for ImmutableArray might be compiled by the C# compiler. This demonstrates the internal workings of collection expressions when used with custom collection types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[InlineArray(3)] struct __InlineArray3<T> { private T _element0; }\n\nSpan<int> __tmp = new __InlineArray3<int>();\n__tmp[0] = 1;\n__tmp[1] = 2;\n__tmp[2] = 3;\nImmutableArray<int> ia =\n    ImmutableArray.Create((ReadOnlySpan<int>)__tmp);\n```\n\n----------------------------------------\n\nTITLE: Valid List Pattern Matching Scenarios\nDESCRIPTION: Shows different list pattern matching scenarios that do not cause subsumption errors\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/list-patterns.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ncase [_, 1, ..]: // expr.Length is >= 2 && expr[1] is 1\ncase [.., 1, _]: // expr.Length is >= 2 && expr[^2] is 1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Relational Pattern Usage with Type Inference in C#\nDESCRIPTION: These C# code snippets demonstrate the usage of relational patterns with type inference and explicit type handling for different input types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nbool IsValidPercentage(int x) => x is >= 0 and <= 100;\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsValidPercentage(object x) => x is >= 0 and <= 100;\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsValidPercentage(object x) => x is\n    >= 0 and <= 100 or    // integer tests\n    >= 0F and <= 100F or  // float tests\n    >= 0D and <= 100D;    // double tests\n```\n\n----------------------------------------\n\nTITLE: Extension Method Declaration in C#\nDESCRIPTION: This code snippet demonstrates the typical declaration of an extension method in C#. The `this` keyword in the first parameter indicates that the method extends the `IEnumerable<T>` interface. The class name `SomeExtensionsAndStuff` is used when calling the method as a static method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Extension-API-docs.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class SomeExtensionsAndStuff\n{\n    public static bool IsEmpty<T>(this IEnumerable<T> source) => source.Any() == false;\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding PrintMembers Method in Derived C# Record Types\nDESCRIPTION: This snippet shows how to override the PrintMembers method in a derived record type. It calls the base method and appends additional members specific to the derived type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nprotected override bool PrintMembers(StringBuilder builder);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Double Storage Issue with Primary Constructor Parameters in C#\nDESCRIPTION: This code example shows a case where a primary constructor parameter is used both for property initialization and captured into the class state, potentially causing confusion when the property is later modified but the captured value remains unchanged.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic class Person(string name)\n{\n    public string Name { get; set; } = name;   // initialization\n    public override string ToString() => name; // capture\n}\n```\n\n----------------------------------------\n\nTITLE: Argument Validation with Verify Helper Class in C#\nDESCRIPTION: This code snippet showcases a helper class named Verify that leverages the CallerArgumentExpression attribute for argument validation. It provides methods like NotNull, Argument, and InRange to simplify validation logic and provide meaningful error messages.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\npublic static class Verify\n{\n    public static void Argument(bool condition, string message, [CallerArgumentExpression(\"condition\")] string conditionExpression = null)\n    {\n        if (!condition) throw new ArgumentException(message: message, paramName: conditionExpression);\n    }\n\n    public static void InRange(int argument, int low, int high,\n        [CallerArgumentExpression(\"argument\")] string argumentExpression = null,\n        [CallerArgumentExpression(\"low\")] string lowExpression = null,\n        [CallerArgumentExpression(\"high\")] string highExpression = null)\n    {\n        if (argument < low)\n        {\n            throw new ArgumentOutOfRangeException(paramName: argumentExpression,\n                message: $\"{argumentExpression} ({argument}) cannot be less than {lowExpression} ({low}).\");\n        }\n\n        if (argument > high)\n        {\n            throw new ArgumentOutOfRangeException(paramName: argumentExpression,\n                message: $\"{argumentExpression} ({argument}) cannot be greater than {highExpression} ({high}).\");\n        }\n    }\n\n    public static void NotNull<T>(T argument, [CallerArgumentExpression(\"argument\")] string argumentExpression = null)\n        where T : class\n    {\n        if (argument == null) throw new ArgumentNullException(paramName: argumentExpression);\n    }\n}\n\nstatic T Single<T>(this T[] array)\n{\n    Verify.NotNull(array); // paramName: \"array\"\n    Verify.Argument(array.Length == 1, \"Array must contain a single element.\"); // paramName: \"array.Length == 1\"\n\n    return array[0];\n}\n\nstatic T ElementAt<T>(this T[] array, int index)\n{\n    Verify.NotNull(array); // paramName: \"array\"\n    // paramName: \"index\"\n    // message: \"index (-1) cannot be less than 0 (0).\", or\n    //          \"index (6) cannot be greater than array.Length - 1 (5).\"\n    Verify.InRange(index, 0, array.Length - 1);\n\n    return array[index];\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring an Inline Array Structure with InlineArrayAttribute in C#\nDESCRIPTION: Example of how to declare a structure type that will be laid out as an inline array using the InlineArrayAttribute. This creates a Buffer with 10 object elements arranged sequentially in memory.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.InlineArray(10)]\npublic struct Buffer\n{\n    private object _element0;\n}\n```\n\n----------------------------------------\n\nTITLE: Synthesized Record Implementation\nDESCRIPTION: Detailed example showing the synthesized members for three record types including equality comparisons, operators, and hash code generation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass R1 : IEquatable<R1>\n{\n    public T1 P1 { get; init; }\n    protected virtual Type EqualityContract => typeof(R1);\n    public override bool Equals(object? obj) => Equals(obj as R1);\n    public virtual bool Equals(R1? other)\n    {\n        return !(other is null) &&\n            EqualityContract == other.EqualityContract &&\n            EqualityComparer<T1>.Default.Equals(P1, other.P1);\n    }\n    public static bool operator==(R1? left, R1? right)\n        => (object)left == right || (left?.Equals(right) ?? false);\n    public static bool operator!=(R1? left, R1? right)\n        => !(left == right);\n    public override int GetHashCode()\n    {\n        return HashCode.Combine(EqualityComparer<Type>.Default.GetHashCode(EqualityContract),\n            EqualityComparer<T1>.Default.GetHashCode(P1));\n    }\n}\n\nclass R2 : R1, IEquatable<R2>\n{\n    public T2 P2 { get; init; }\n    protected override Type EqualityContract => typeof(R2);\n    public override bool Equals(object? obj) => Equals(obj as R2);\n    public sealed override bool Equals(R1? other) => Equals((object?)other);\n    public virtual bool Equals(R2? other)\n    {\n        return base.Equals((R1?)other) &&\n            EqualityComparer<T2>.Default.Equals(P2, other.P2);\n    }\n    public static bool operator==(R2? left, R2? right)\n        => (object)left == right || (left?.Equals(right) ?? false);\n    public static bool operator!=(R2? left, R2? right)\n        => !(left == right);\n    public override int GetHashCode()\n    {\n        return HashCode.Combine(base.GetHashCode(),\n            EqualityComparer<T2>.Default.GetHashCode(P2));\n    }\n}\n\nclass R3 : R2, IEquatable<R3>\n{\n    public T3 P3 { get; init; }\n    protected override Type EqualityContract => typeof(R3);\n    public override bool Equals(object? obj) => Equals(obj as R3);\n    public sealed override bool Equals(R2? other) => Equals((object?)other);\n    public virtual bool Equals(R3? other)\n    {\n        return base.Equals((R2?)other) &&\n            EqualityComparer<T3>.Default.Equals(P3, other.P3);\n    }\n    public static bool operator==(R3? left, R3? right)\n        => (object)left == right || (left?.Equals(right) ?? false);\n    public static bool operator!=(R3? left, R3? right)\n        => !(left == right);\n    public override int GetHashCode()\n    {\n        return HashCode.Combine(base.GetHashCode(),\n            EqualityComparer<T3>.Default.GetHashCode(P3));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Declaration Example in C#\nDESCRIPTION: Demonstrates how using declarations can be used for file handling compared to traditional using statements. Shows equivalent code patterns and variable scoping.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/using.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (...) \n{ \n   using FileStream f = new FileStream(@\"C:\\source\\using.md\");\n   // statements\n}\n\n// Equivalent to \nif (...) \n{ \n   using (FileStream f = new FileStream(@\"C:\\source\\using.md\")) \n   {\n    // statements\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Nullable Parameter Warning Example\nDESCRIPTION: Demonstrates the basic case where compiler warns about null default value assigned to non-nullable parameter type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-parameter-default-value-analysis.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string s = null) // warning CS8600: Converting null literal or possible null value to non-nullable type.\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Init-only Properties Usage Example in C#\nDESCRIPTION: Demonstration of init-only properties implementation showing valid and invalid initialization patterns. The example illustrates how required init-only members would generate compile-time errors when not initialized in object initializers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-21.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Person\n{\n    public initonly string Name { get; }\n}\n\nvoid M()\n{\n    var person1 = new Person() { Name = \"person1\" }; // OK\n    var person2 = new Person(); // Error, Name was not initialized\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Required Members in Class Definitions\nDESCRIPTION: This code demonstrates the addition of the 'required' modifier to property definitions in a class to enforce initialization of these properties during object instantiation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Person\n{\n    // The default constructor requires that FirstName and LastName be set at construction time\n    public required string FirstName { get; init; }\n    public string MiddleName { get; init; } = \"\";\n    public required string LastName { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Class with Primary Constructor in C#\nDESCRIPTION: Example of a class with a primary constructor that captures parameters, initializes properties, and includes an additional constructor. Shows parameter passing to base constructor and parameter capturing patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C(bool b, int i, string s) : B(b) // b passed to base constructor\n{\n    public int I { get; set; } = i; // i used for initialization\n    public string S // s used directly in function members\n    {\n        get => s;\n        set => s = value ?? throw new ArgumentNullException(nameof(value));\n    }\n    public C(string s) : this(true, 0, s) { } // must call this(...)\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Static Members Example - C# Interface\nDESCRIPTION: This code shows how to declare abstract static members, like methods and operators, within an interface. These declarations necessitate implementing classes or structs to define these abstract interface members, facilitating polymorphism of static methods, properties, and even events. The interface showcases static abstract declarations for various members, enforcing consistent implementation patterns across types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninterface I<T> where T : I<T>\n{\n    static abstract void M();\n    static abstract T P { get; set; }\n    static abstract event Action E;\n    static abstract T operator +(T l, T r);\n    static abstract bool operator ==(T l, T r);\n    static abstract bool operator !=(T l, T r);\n    static abstract implicit operator T(string s);\n    static abstract explicit operator string(T t);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a ref struct with a ref field in C#\nDESCRIPTION: This code snippet demonstrates how to declare a `ref struct` named `S` containing a public `ref int` field named `Value`. The `ref` keyword indicates that the field holds a reference to an integer, rather than the integer itself. `ref struct` must contain only `ref` fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n``` C#\nref struct S \n{\n    public ref int Value;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Deconstruct Method in C# Positional Record\nDESCRIPTION: This snippet demonstrates a positional record 'R' with a synthesized Deconstruct method, and shows how to use it for deconstructing the record into individual variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic record R(int P1, string P2 = \"xyz\")\n{\n    public void Deconstruct(out int P1, out string P2)\n    {\n        P1 = this.P1;\n        P2 = this.P2;\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        R r = new R(12);\n        (int p1, string p2) = r;\n        Console.WriteLine($\"p1: {p1}, p2: {p2}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Span<char> with Constant String in C# 11.0\nDESCRIPTION: Demonstrates pattern matching a Span<char> or ReadOnlySpan<char> with a constant string, introduced in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nspan is \"123\"\n```\n\n----------------------------------------\n\nTITLE: Synthesized Equals(R other) Method for Record Struct\nDESCRIPTION: This snippet shows the synthesized `Equals(R other)` method for a record struct in C#. It returns `true` if and only if each instance field in the record struct is equal to the corresponding field in the other record struct using `EqualityComparer<TN>.Default.Equals()`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n\"public readonly bool Equals(R other);\"\n```\n\n----------------------------------------\n\nTITLE: Record Declaration Grammar in ANTLR\nDESCRIPTION: ANTLR grammar defining the syntax rules for declaring record types in C#, including modifiers, parameters, base types, and body structure.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nrecord_declaration\n    : attributes? class_modifier* 'partial'? 'record' identifier type_parameter_list?\n      parameter_list? record_base? type_parameter_constraints_clause* record_body\n    ;\n\nrecord_base\n    : ':' class_type argument_list?\n    | ':' interface_type_list\n    | ':' class_type argument_list? ',' interface_type_list\n    ;\n\nrecord_body\n    : '{' class_member_declaration* '}' ';'?\n    | ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Using Interpolated String Handler with Logger in C#\nDESCRIPTION: This code snippet demonstrates the usage of the TraceLoggerParamsInterpolatedStringHandler by incorporating it into a Logger class. It manages logging messages according to the log level set in the logger, efficiently handling string interpolation by only formatting strings when necessary.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// The logger class. The user has an instance of this, accesses it via static state, or some other access\n// mechanism\npublic class Logger\n{\n    // Initialization code omitted\n    public LogLevel EnabledLevel;\n\n    public void LogTrace([InterpolatedStringHandlerArguments(\"\")]TraceLoggerParamsInterpolatedStringHandler handler)\n    {\n        // Impl of logging\n    }\n}\n\nLogger logger = GetLogger(LogLevel.Info);\n\n// Given the above definitions, usage looks like this:\nvar name = \"Fred Silberberg\";\nlogger.LogTrace($\"{name} will never be printed because info is < trace!\");\n\n// This is converted to:\nvar name = \"Fred Silberberg\";\nvar receiverTemp = logger;\nvar handler = new TraceLoggerParamsInterpolatedStringHandler(literalLength: 47, formattedCount: 1, receiverTemp, out var handlerIsValid);\nif (handlerIsValid)\n{\n    handler.AppendFormatted(name);\n    handler.AppendLiteral(\" will never be printed because info is < trace!\");\n}\nreceiverTemp.LogTrace(handler);\n```\n\n----------------------------------------\n\nTITLE: Non-Virtual Static Members - C# Interface\nDESCRIPTION: This snippet demonstrates explicitly non-virtual static members in an interface using the `sealed` modifier. While static members are non-virtual by default, the `sealed` keyword provides a symmetric syntax with instance members, clarifying their non-overridable nature and reinforcing their fixed implementation in derived types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ninterface I0\n{\n    static sealed void M() => Console.WriteLine(\"Default behavior\");\n    \n    static sealed int f = 0;\n    \n    static sealed int P1 { get; set; }\n    static sealed int P2 { get => f; set => f = value; }\n    \n    static sealed event Action E1;\n    static sealed event Action E2 { add => E1 += value; remove => E1 -= value; }\n    \n    static sealed I0 operator +(I0 l, I0 r) => l;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Method Reabstraction Pattern\nDESCRIPTION: Shows how a concrete method in a base interface can be made abstract again in a derived interface, requiring implementing classes to provide an implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M() { WriteLine(\"IA.M\"); }\n}\ninterface IB : IA\n{\n    abstract void IA.M();\n}\nclass C : IB { } // error: class 'C' does not implement 'IA.M'.\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with UTF-8 Literals\nDESCRIPTION: This code demonstrates how the `u8` suffix facilitates overload resolution when both `ReadOnlySpan<byte>` and `string` overloads exist. It shows how using the suffix avoids the need for explicit casting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n\"void Write(ReadOnlySpan<byte> span) { ... }\nvoid Write(string s) {\n    var bytes = Encoding.UTF8.GetBytes(s);\n    Write(bytes.AsSpan());\n}\"\n```\n\n----------------------------------------\n\nTITLE: Simplified Point Implementation Using Init\nDESCRIPTION: Simplified implementation of Point struct using init accessors, enabling object initializer syntax while maintaining immutability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstruct Point\n{\n    public int X { get; init; }\n    public int Y { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Slice Pattern Lowering Example\nDESCRIPTION: Shows how a slice pattern with variable capture is transformed into range-based matching code\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/list-patterns.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nexpr is [1, .. var s, 3]\n// Equivalent to:\nexpr.Length is >= 2\n&& expr[new Index(0, fromEnd: false)] is 1\n&& expr[new Range(new Index(1, fromEnd: false), new Index(1, fromEnd: true))] is var s\n&& expr[new Index(1, fromEnd: true)] is 3\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguities in C# Extension Member Invocations\nDESCRIPTION: This snippet illustrates how to resolve ambiguities between extension members with the same name and arity by using static invocation syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nobject.M(); // ambiguous\nE1.M();\n\nnew object().M2(); // ambiguous\nE1.M2(new object());\n\n_ = _new object().P; // ambiguous\n_ = E1.get_P(new object());\n\nstatic class E1\n{\n    extension(object)\n    {\n        public static void M() { }\n        public void M2() { }\n        public int P => 42;\n    }\n}\n\nstatic class E2\n{\n    extension(object)\n    {\n        public static void M() { }\n        public void M2() { }\n        public int P => 42;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar Definition for Interpolated Raw String Literals in C#\nDESCRIPTION: This code block defines the grammar for interpolated raw string literals in C#. It includes rules for single-line and multi-line literals, as well as the syntax for interpolations within these literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_17\n\nLANGUAGE: BNF\nCODE:\n```\ninterpolated_raw_string_literal\n    : single_line_interpolated_raw_string_literal\n    | multi_line_interpolated_raw_string_literal\n    ;\n\ninterpolated_raw_string_start\n    : $\n    | $$\n    | $$$\n    | etc.\n    ;\n\ninterpolated_raw_string_literal_delimiter\n    : interpolated_raw_string_start raw_string_literal_delimiter\n    ;\n\nsingle_line_interpolated_raw_string_literal\n    : interpolated_raw_string_literal_delimiter interpolated_raw_content raw_string_literal_delimiter\n    ;\n\nmulti_line_interpolated_raw_string_literal\n    : interpolated_raw_string_literal_delimiter whitespace* new_line (interpolated_raw_content | new_line)* new_line whitespace* raw_string_literal_delimiter\n    ;\n\ninterpolated_raw_content\n    : (not_new_line | raw_interpolation)+\n    ;\n\nraw_interpolation\n    : raw_interpolation_start interpolation raw_interpolation_end\n    ;\n\nraw_interpolation_start\n    : {\n    | {{\n    | {{{\n    | etc.\n    ;\n\nraw_interpolation_end\n    : }\n    | }}\n    | }}}\n    | etc.\n    ;\n```\n\n----------------------------------------\n\nTITLE: Tuple Deconstructing Declarations\nDESCRIPTION: Various syntax examples for declaring new variables through tuple deconstruction in different contexts like local declarations, foreach loops, LINQ queries and out parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n(var x, var y) = GetCoordinates();             // locals in declaration statements\nforeach ((var x, var y) in coordinateList) ... // iteration variables in foreach loops\nfrom (x, y) in coordinateList ...              // range variables in queries\nM(out (var x, var y));                         // tuple out parameters\n```\n\n----------------------------------------\n\nTITLE: Async Foreach Loop Syntax Examples in C#\nDESCRIPTION: Demonstrates the syntax for using foreach with both synchronous and asynchronous enumerables, showing the await keyword usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nforeach (var i in enumerable)\nawait foreach (var i in enumerable)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Pattern Usage in C#\nDESCRIPTION: This C# code snippet demonstrates the usage of type patterns in pattern matching expressions, including tuple patterns and switch statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(object o1, object o2)\n{\n    var t = (o1, o2);\n    if (t is (int, string)) {} // test if o1 is an int and o2 is a string\n    switch (o1) {\n        case int: break; // test if o1 is an int\n        case System.String: break; // test if o1 is a string\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Initialization with Default and Override Values in C#\nDESCRIPTION: Examples of initializing dictionaries with default values and user-provided overrides using spread syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nDictionary<string, Option> optionMap = [opt1Name: opt1Default, opt2Name: opt2Default, .. userProvidedOptions];\n\nDictionary<string, Option> optionMap = [.. Defaults.CoreOptions, feature1Name: feature1Override];\n```\n\n----------------------------------------\n\nTITLE: Attribute Targeting for Primary Constructors in C#\nDESCRIPTION: Examples of applying attributes to primary constructors using the 'method' attribute target. Shows both valid cases and cases where warnings would be issued when the 'method' target is used inappropriately.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[method: FooAttr] // Good\npublic partial record Rec(\n    [property: Foo] int X,\n    [field: NonSerialized] int Y\n);\n[method: BarAttr] // warning CS0657: 'method' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are 'type'. All attributes in this block will be ignored.\npublic partial record Rec\n{\n    public void Frobnicate()\n    {\n        ...\n    }\n}\n[method: Attr] // Good\npublic record MyUnit1();\n[method: Attr] // warning CS0657: 'method' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are 'type'. All attributes in this block will be ignored.\npublic record MyUnit2;\n```\n\n----------------------------------------\n\nTITLE: Implementing InterpolatedStringHandlerArgumentAttribute in C#\nDESCRIPTION: Defines an attribute used to specify which parameters should be passed to the string handler constructor. The attribute can take either a single argument or an array of arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\n    public sealed class InterpolatedStringHandlerArgumentAttribute : Attribute\n    {\n        public InterpolatedStringHandlerArgumentAttribute(string argument);\n        public InterpolatedStringHandlerArgumentAttribute(params string[] arguments);\n\n        public string[] Arguments { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Collection Expression Type Flow in C#\nDESCRIPTION: Code examples showing scenarios where collection expressions are used inline with conditional operations and foreach loops, highlighting the need for element type flow in collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-02-05.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// If `byte` doesn't flow into the conditional as an element type, the natural element type will be `int`, and the conversion will fail\nbyte[] x = [1, .. b ? [2] : []];\n\n// If `bool?` doesn't flow into the iteration expression, there will be a compile error because no natural type can be found\nforeach (bool? b in [true, false, null]) {}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with 'is' Operator in C#\nDESCRIPTION: Demonstrates the use of the 'is' operator for pattern matching in C# 7. It shows how to simplify type checking and variable declaration in conditional statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-11-02-Design-Demo.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic string PrintedForm(Person p)\n{\n    if (p is Student s && s.Gpa > 3.5)\n    {\n        return $\"Honor Student {s.Name} ({s.Gpa})\";\n    }\n    else if (p is Student s)\n    {\n        return $\"Student {s.Name} ({s.Gpa})\";\n    }\n    else if (p is Teacher t)\n    {\n        return $\"Teacher {t.Name} of {t.Subject}\";\n    }\n    else\n    {\n        return $\"Person {p.Name}\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Interpolated String Handler in C#\nDESCRIPTION: This code snippet defines a ref struct, TraceLoggerParamsInterpolatedStringHandler, that implements custom logic for building interpolated strings. It checks if logging is enabled and appends formatted parts of the string as necessary. This pattern facilitates efficient string handling for logging operations by minimizing allocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// The handler that will actually \"build\" the interpolated string\"\n[InterpolatedStringHandler]\npublic ref struct TraceLoggerParamsInterpolatedStringHandler\n{\n    // Storage for the built-up string\n\n    private bool _logLevelEnabled;\n\n    public TraceLoggerParamsInterpolatedStringHandler(int literalLength, int formattedCount, Logger logger, out bool handlerIsValid)\n    {\n        if (!logger._logLevelEnabled)\n        {\n            handlerIsValid = false;\n            return;\n        }\n\n        handlerIsValid = true;\n        _logLevelEnabled = logger.EnabledLevel;\n    }\n\n    public void AppendLiteral(string s)\n    {\n        // Store and format part as required\n    }\n\n    public void AppendFormatted<T>(T t)\n    {\n        // Store and format part as required\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Iteration Type Inconsistency with IEnumerable<T> Implementation\nDESCRIPTION: This example demonstrates how the current specification's assumption about iteration type leads to unexpected behavior. It shows a class that implements IEnumerable<long> but has a GetEnumerator() method that returns IEnumerator<string>, causing the actual iteration type to be string despite the generic type argument of IEnumerable<long>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass MyCollection : IEnumerable<long>\n{\n    IEnumerator<long> IEnumerable<long>.GetEnumerator() => throw null;\n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n\n    public void Add(string l) => throw null;\n    \n    public IEnumerator<string> GetEnumerator() => throw null; \n}\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var l in new MyCollection())\n        {\n            string s = l; // Iteration type is string\n        }\n        \n        MyCollection x1 = [\"a\", // error CS0029: Cannot implicitly convert type 'string' to 'long'\n                           2];\n        MyCollection x2 = new MyCollection() { \"b\" };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Array Initialization Syntax Comparison in C#\nDESCRIPTION: Shows equivalent array initialization syntax using both traditional curly braces and new collection literal syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_22\n\nLANGUAGE: c#\nCODE:\n```\nint[] x = { 1, 2, 3 };\nint[] x = [ 1, 2, 3 ];\n```\n\n----------------------------------------\n\nTITLE: Attributes on Lambda Expressions\nDESCRIPTION: Describes how attributes can be attached to lambda expressions and parameters. It distinguishes cases where syntax errors occur due to ambiguity or unsupported scenarios such as in anonymous methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nf = [A] () => { };        // [A] lambda\nf = [return:A] x => x;    // syntax error at '=>'\nf = [return:A] (x) => x;  // [A] lambda\nf = [A] static x => x;    // syntax error at '=>' \n\nf = ([A] x) => x;         // [A] x\nf = ([A] ref int x) => x; // [A] x\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar f = [A1, A2][A3] () => { };    // ok\nvar g = ([A1][A2, A3] int x) => x; // ok\n```\n\nLANGUAGE: csharp\nCODE:\n```\nf = [A] delegate { return 1; };         // syntax error at 'delegate'\nf = delegate ([A] int x) { return x; }; // syntax error at '['\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar y = new C { [A] = x };    // ok: y[A] = x\nvar z = new C { [A] x => x }; // ok: z[0] = [A] x => x\n```\n\nLANGUAGE: csharp\nCODE:\n```\nx = b ? [A];               // ok\ny = b ? [A] () => { } : z; // syntax error at '('\n```\n\n----------------------------------------\n\nTITLE: Declaring Classic Extension Methods in C#\nDESCRIPTION: The code snippet demonstrates the definition of classic extension methods in C#. The methods are declared as static methods within a static class, utilizing the 'this' keyword on the first parameter to indicate the target type. Dependencies include the necessary interfaces or types like ITextBuffer and ITextSnapshotLine. These methods transform the target type into another type or handle it in a custom way.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static partial class Extensions\n{\n    public static SourceTextContainer AsTextContainer(this ITextBuffer buffer)\n        => TextBufferContainer.From(buffer);\n\n    internal static TextLine AsTextLine(this ITextSnapshotLine line)\n        => line.Snapshot.AsText().Lines[line.LineNumber];\n}\n```\n\n----------------------------------------\n\nTITLE: Using Async Enumerator Pattern in C#\nDESCRIPTION: Example code showing typical consumption pattern of an async enumerator with proper disposal handling using try/finally blocks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nIAsyncEnumerator<T> enumerator = enumerable.GetAsyncEnumerator();\ntry\n{\n    while (await enumerator.MoveNextAsync())\n    {\n        Use(enumerator.Current);\n    }\n}\nfinally { await enumerator.DisposeAsync(); }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Event Accessors in Interfaces (C#)\nDESCRIPTION: Example showing the syntax for event declarations in interfaces, highlighting that partial implementation of events is not permitted.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface I1\n{\n    event T e1;\n}\npublic interface I2 : I1\n{\n    override event T\n    {\n        add { }\n        // error: \"remove\" accessor missing\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Record Class with Primary Constructor in C#\nDESCRIPTION: Example of a record class implementation using primary constructor syntax to define Person with Name and Birthday members. This demonstrates the proposed syntax for records with automatic structural equality and constructor/deconstructor generation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-21.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ndata class Person(string Name, DateTime Birthday);\n```\n\n----------------------------------------\n\nTITLE: Required Arguments Collection Expression Example\nDESCRIPTION: Shows how collection expressions handle types where constructor arguments are required, demonstrating both factory method and direct constructor approaches.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nMyCollection<object> c;\nc = [];                  // error: no arguments\nc = [with(capacity: 1)]; // ok\n\n[CollectionBuilder(typeof(MyBuilder), \"Create\")]\nclass MyCollection<T> : IEnumerable<T> { ... }\n\nclass MyBuilder\n{\n    public static MyCollection<T> Create<T>(ReadOnlySpan<T> items, int capacity) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Stream Iteration Syntax\nDESCRIPTION: Final approved syntax for async stream iteration using await with foreach and using statements. This maintains consistency with existing await patterns in the language.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-15.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nawait foreach (...)\nawait using (...)\n```\n\n----------------------------------------\n\nTITLE: Inefficient UTF-8 Encoding at Runtime\nDESCRIPTION: This snippet shows the simplest but least efficient way to encode a string to UTF-8 at runtime. The method call `Encoding.UTF8.GetBytes(\\\"AUTH \\\")` allocates a new byte array every time, impacting performance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n\"// Simplest / most convenient but terribly inefficient\nWriteBytes(Encoding.UTF8.GetBytes(\\\"AUTH \\\"));\"\n```\n\n----------------------------------------\n\nTITLE: Synthesized Equals(object? obj) Method for Record Struct\nDESCRIPTION: This snippet shows the synthesized `Equals(object? obj)` method for a record struct. It checks if the other object is of the same type and then calls the `Equals(R other)` method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n\"public override readonly bool Equals(object? obj);\"\n```\n\n----------------------------------------\n\nTITLE: Virtual Static Members Example - C# Interface\nDESCRIPTION: The snippet illustrates how to declare virtual static members within an interface. Unlike abstract static members, virtual static members must have a body, allowing a default behavior that's shared across implementations unless explicitly overridden. This blend of flexibility and default behavior adds layer of reuse and reduces boilerplate in type definitions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ninterface I<T> where T : I<T>\n{\n    static virtual void M() {}\n    static virtual T P { get; set; }\n    static virtual event Action E;\n    static virtual T operator +(T l, T r) { throw new NotImplementedException(); }\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-line Raw String Literal with Indentation in C#\nDESCRIPTION: Illustrates how indentation is preserved in the content while being stripped from the beginning of each line.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar xml = \"\"\"\n          <element attr=\"content\">\n            <body>\n            </body>\n          </element>\n          \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Implementing a Destructible Struct in C#\nDESCRIPTION: Example of the proposed destructible type syntax showing a Handle struct with a destructor that automatically frees a resource when the variable goes out of scope. This demonstrates the core concept of the destructible types proposal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ndestructible struct Handle\n{\n    IntPtr ptr;\n\n    ~Handle()\n    {\n        if (ptr != IntPtr.Zero) Free(ptr);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: User-Defined Type with Invalid Collection Expression Conversion\nDESCRIPTION: This example shows how a collection expression conversion to a class implementing IEnumerable<char> fails with a confusing error about missing an Add method rather than selecting the valid char[] overload.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass C1 : IEnumerable<char>\n{\n    public static void M1(C1 x)\n    {\n    }\n    public static void M1(char[] x)\n    {\n    }\n\n    void Test()\n    {\n        M1(['a', 'b']); // error CS1061: 'C1' does not contain a definition for 'Add' and no accessible extension method 'Add' accepting a first argument of type 'C1' could be found (are you missing a using directive or an assembly reference?)\n    }\n\n    public static implicit operator char[](C1 x) => throw null;\n    IEnumerator<char> IEnumerable<char>.GetEnumerator() => throw null;\n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Local Variable Nullability Behavior in C#\nDESCRIPTION: Demonstrates the behavior of nullable and non-nullable local variables, including assignments, conversions, and null checks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-07.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nclass C {\n    public static string  S { get; } // won't be null\n    public static string? N { get; } // might be null\n\n    public void M()\n    {\n        int l;\n\n        string s; // won't be null\n        s = C.S; // ok\n        s = C.N; // warning 2: Indirect dereference\n        s = null; // warning 3: null conversion\n        l = s.Length; // ok\n        l = (s != null) ? s.length : 0; // ok\n\n        string? n; // might be null\n        n = C.S; // ok\n        n = C.N; // ok\n        n = null; // ok\n        l = n.Length; // warning 1: Direct dereference\n        l = (n != null) ? n.length : 0; // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Compatible Static Methods in C#\nDESCRIPTION: This example illustrates how compat mode generates a static method from an instance extension method. The compiler uses the instance extension method's attributes, accessibility, return type, name, and body to generate the static method. It also concatenates type parameter and parameter lists.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/compat-mode-in-extensions.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TSource>(this IEnumerable<TSource> source) // Generate compatible extension methods\n    {\n        public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { ... }\n        public IEnumerable<TSource> Select<TResult>(Func<TSource, TResult> selector)  { ... }\n    }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate) { ... }\n    public static IEnumerable<TSource> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)  { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Null Guard Implementation for Non-Nullable Parameters\nDESCRIPTION: Shows a basic null guard pattern for a non-nullable parameter in a public API, demonstrating defensive programming practices.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic void DoWork(Worker worker)\n{\n    // Guard against worker being null\n    if (worker is null)\n    {\n        throw new ArgumentNullException(nameof(worker));\n    }\n\n    // Otherwise use worker argument\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Dictionary with Target-typed new in C#\nDESCRIPTION: Example showing field initialization of a Dictionary using target-typed new expressions to avoid type duplication.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-new.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nDictionary<string, List<int>> field = new() {\n    { \"item1\", new() { 1, 2, 3 } }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Member Disambiguation Using Cast Syntax in C#\nDESCRIPTION: Demonstrates the proposed cast-based syntax for disambiguating extension members, showing how to explicitly specify which extension should be used for methods, properties, indexers, and operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvar v1 = ((Extension)receiver).ExtensionMethod(); // instead of Extension.ExtensionMethod(receiver)\nvar v2 = ((Extension)receiver).ExtensionProperty;\nvar v3 = ((Extension)receiver)[indexerArg];\nvar v4 = (Extension)receiver1 + receiver2;\n```\n\n----------------------------------------\n\nTITLE: Null Guard Implementation with Nullable Parameter\nDESCRIPTION: Demonstrates null guard pattern with an explicitly nullable parameter, showing proper handling of potentially null values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic void DoWork(Worker? worker)\n{\n    // Guard against worker being null\n    if (worker is null)\n    {\n        throw new ArgumentNullException(nameof(worker));\n    }\n\n    // Otherwise use worker argument\n}\n```\n\n----------------------------------------\n\nTITLE: Using Optional Parameters in Lambda Expressions in C# 12\nDESCRIPTION: Demonstrates how to define and use lambda expressions with optional parameters that have default values. The example shows a lambda that adds a value to a parameter with a default value of 2.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar addWithDefault = (int addTo = 2) => addTo + 1;\naddWithDefault(); // 3\naddWithDefault(5); // 6\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Parameter Null States in C#\nDESCRIPTION: Example showing the difference between 'maybe null' and 'maybe default' states for generic type parameters. Illustrates how null handling differs based on type parameter constraints and default values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nvoid M<T>(T t)\n{\n    // There is no guarantee that default(T) is within the legal values for T hence the \n    // state *must* be \"maybe-default\" and hence `local` must be `T?`\n    T? local = default(T);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Life Stage Determination with Relational Patterns in C#\nDESCRIPTION: This C# code snippet demonstrates the use of relational patterns in a switch expression to determine a person's life stage based on their age.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static LifeStage LifeStageAtAge(int age) => age switch\n{\n    < 0 =>  LifeStage.Prenatal,\n    < 2 =>  LifeStage.Infant,\n    < 4 =>  LifeStage.Toddler,\n    < 6 =>  LifeStage.EarlyChild,\n    < 12 => LifeStage.MiddleChild,\n    < 20 => LifeStage.Adolescent,\n    < 40 => LifeStage.EarlyAdult,\n    < 65 => LifeStage.MiddleAdult,\n    _ =>    LifeStage.LateAdult,\n};\n```\n\n----------------------------------------\n\nTITLE: String Handler Implementation Example in C#\nDESCRIPTION: Demonstrates the implementation of string formatting using the interpolated string handler, including the Format method and DefaultInterpolatedStringHandler struct with format provider support.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System\n{\n    public sealed class String\n    {\n        public static string Format(IFormatProvider? provider, [InterpolatedStringHandlerArgument(\"provider\")] ref DefaultInterpolatedStringHandler handler);\n        â€¦\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    public ref struct DefaultInterpolatedStringHandler\n    {\n        public DefaultInterpolatedStringHandler(int baseLength, int holeCount, IFormatProvider? provider); // additional factory\n        â€¦\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Await Foreach Implementation in C#\nDESCRIPTION: Shows the basic syntax of await foreach statement and its expanded form including proper disposal handling.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nawait foreach (V v in x) Â«embedded_statementÂ»\n```\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    E e = ((C)(x)).GetAsyncEnumerator();\n    try {\n        while (await e.MoveNextAsync()) {\n            V v = (V)(T)e.Current;\n            Â«embedded_statementÂ»\n        }\n    }\n    finally {\n        ... // Dispose e\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: UTF-8 Encoding with Runtime Allocation\nDESCRIPTION: This code demonstrates the conventional approach of encoding a string to UTF-8 at runtime using `Encoding.UTF8.GetBytes()`. While convenient, it introduces runtime allocation and startup costs which can be avoided by UTF-8 literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"// Incurs allocation and startup costs performing an encoding that could have been done at compile-time\nstatic readonly byte[] s_authWithTrailingSpace = Encoding.UTF8.GetBytes(\\\"AUTH \\\");\nWriteBytes(s_authWithTrailingSpace);\"\n```\n\n----------------------------------------\n\nTITLE: Basic Partial Method Declaration and Definition Example in C#\nDESCRIPTION: Demonstrates the basic syntax for declaring and implementing a partial method with a message parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npartial class C\n{\n    // The declaration of C.M\n    partial void M(string message);\n}\n\npartial class C\n{\n    // The definition of C.M\n    partial void M(string message) => Console.WriteLine(message);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Enumeration Interfaces in C#\nDESCRIPTION: Core interfaces for async enumeration pattern including IAsyncEnumerable<T> and IAsyncEnumerator<T>. Enables async iteration with support for cancellation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : IAsyncDisposable\n    {\n        ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Function with Return Type in C# 10.0\nDESCRIPTION: Demonstrates the new lambda syntax allowing explicit return type specification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nvar f = short () => 1;\n```\n\n----------------------------------------\n\nTITLE: Implementing Checked and Unchecked Addition Operations in C#\nDESCRIPTION: Demonstrates how checked and unchecked addition operators are implemented and called in different contexts. Shows inheritance relationship between C1 and C2 classes with C2 implementing a checked addition operator for byte parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    static void Add(C2 x, byte y)\n    {\n        object o;\n        \n        // C2.op_CheckedAddition\n        o = checked(x + y);\n        \n        // C1.op_Addition\n        o = unchecked(x + y);\n    }\n\n    static void Add2(C2 x, int y)\n    {\n        object o;\n        \n        // C1.op_Addition\n        o = checked(x + y);\n        \n        // C1.op_Addition\n        o = unchecked(x + y);\n    }\n}\n\nclass C1\n{\n    public static C1 operator + (C1 x, int y) => new C1();\n}\n\nclass C2 : C1\n{\n    public static C2 operator checked + (C2 x, byte y) => new C2();\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing C# Primary Constructor Parameters - Example Syntax\nDESCRIPTION: Example showing primary constructor parameter syntax for C# class member, demonstrating the potential usage of public access modifier.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-07-26.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic int I\n```\n\n----------------------------------------\n\nTITLE: Creating Raw String Literal with Nested Quotes in C#\nDESCRIPTION: Shows how to use extended delimiters to include triple quotes within the raw string literal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar xml = \"\"\"\"\n          Ok to use \"\"\" here\n          \"\"\"\";\n```\n\n----------------------------------------\n\nTITLE: Simplified Base Interface Invocation\nDESCRIPTION: Shows the simplest syntax for base interface invocations when there's no ambiguity about which interface or implementation is being called.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1 { void M(); }\ninterface I3 : I1 { void I1.M() { } }\ninterface I5 : I3\n{\n    void I1.M()\n    {\n        base.M(); // calls I3's implementation of I1.M\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Literal Rewriting in C#\nDESCRIPTION: This snippet shows how a dictionary literal is rewritten by the compiler into a standard `Dictionary` instantiation with subsequent `Add` or indexed assignment operations. This demonstrates the underlying implementation of the dictionary literal syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_15\n\nLANGUAGE: cs\nCODE:\n```\nDictionary<string, int> nameToAge = [\"Dustin\": 42, \"Cyrus\": 43]; // rewritten as:\n\nDictionary<string, int> nameToAge = new Dictionary<string, int>(capacity: 2);\nnameToAge[\"Dustin\"] = 42;\nnameToAge[\"Cyrus\"] = 43;\n    \n// But it could have been (throw vs update semantics):\nnameToAge.Add(\"Dustin\", 42);\nnameToAge.Add(\"Cyrus\", 43);\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Reference Type Grammar in ANTLR\nDESCRIPTION: ANTLR grammar rules defining the syntax for nullable reference types, including reference_type, nullable_reference_type and non_nullable_reference_type productions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nreference_type\n    : ...\n    | nullable_reference_type\n    ;\n    \nnullable_reference_type\n    : non_nullable_reference_type '?'\n    ;\n    \nnon_nullable_reference_type\n    : type\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Prohibited Primary Constructor Parameter Usage in C#\nDESCRIPTION: This snippet illustrates a scenario where referencing primary constructor parameters in member bodies would be disallowed under a simplified version of the feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C(string s)\n{\n    public string S1 => s; // Nope!\n    public string S2 { get; } = s; // Still allowed\n}\n```\n\n----------------------------------------\n\nTITLE: Span Type Stack Allocation Example in C#\nDESCRIPTION: Demonstrates how the compiler can optimize span allocations using stack allocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nforeach (var x in y)\n{\n    Span<int> span = [a, b, c];\n    // do things with span\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing List and Dictionary using Collection Literals in C#\nDESCRIPTION: This snippet demonstrates the proposed syntax for initializing a `List<int>` and a `Dictionary<string, int>` using collection literals in C#. This simplified syntax aims to reduce verbosity when creating and populating collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\nList<int> list = [1, 2, 3];\nDictionary<string, int> nameToAge = [\"Dustin\": 42, \"Cyrus\": 43];\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Shared Variables in C#\nDESCRIPTION: Demonstrates simplified pattern matching using shared variable declarations across or patterns and wrapper types. The code shows how a single variable 'c' can be used across different pattern matches.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/pattern-variables.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is C c or Wrapper { Prop: C c })\n    return c;\n```\n\n----------------------------------------\n\nTITLE: Init Struct Modifier Examples\nDESCRIPTION: Demonstrates equivalent declarations using init at field level versus struct level.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nstruct Point\n{\n    public init int X;\n    public init int Y;\n}\n\n// vs. \n\ninit struct Point\n{\n    public int X;\n    public int Y;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Implementation in Interfaces (C#)\nDESCRIPTION: Example showing how default implementations in interfaces affect class implementations and potential binary compatibility issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    void M() { Impl1 }\n}\ninterface I2 : I1\n{\n}\nclass C : I2\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Method Parameter Type Inference in C#\nDESCRIPTION: Examples showing how method parameter type inference should work with mixed value types, nullable types, and null literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-28.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nM(1, default, null); // int?\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(myShort, myNullableInt, null); Should continue to infer int? , not short?\n```\n\n----------------------------------------\n\nTITLE: Implementing Compiler Synthesized List Type in C#\nDESCRIPTION: This code snippet demonstrates a simple implementation of a compiler-synthesized list type that implements IReadOnlyList<T>, IList<T>, and IList interfaces. It wraps an array and provides read-only access to the collection.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Compiler-synthesized-types.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class SimpleCompilerSynthesizedList<T> : IReadOnlyList<T>, IList<T>, IList\n{\n    private readonly T[] _values;\n\n    public CompilerSynthesizedList(T[] values)\n        => _values = values;\n\n    // IEnumerable/IEnumerable<T>\n\n    public IEnumerator<T> GetEnumerator() => ((IEnumerable<T>)_values).GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();\n\n    // ICollection/ICollection<T>/IReadOnlyCollection<T>\n\n    public bool IsReadOnly => true;\n    public bool IsSynchronized => false;\n    public int Count => _values.Length;\n\n    public bool Contains(T item) => _values.Contains(item);\n    public void CopyTo(T[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);\n    public void CopyTo(Array array, int index) => _values.CopyTo(array, index);\n\n    public void Add(T item) => throw new NotSupportedException();\n    public void Clear() => throw new NotSupportedException();\n    public bool Remove(T item) => throw new NotSupportedException();\n\n    // Not sure what this should return:\n    public object SyncRoot => throw new NotSupportedException();\n\n    // IList/IList<T>/IReadOnlyList<T>\n\n    public bool IsFixedSize => true;\n\n    public T this[int index] { get => _values[index]; set => throw new NotSupportedException(); }\n    object? IList.this[int index] { get => _values[index]; set => throw new NotSupportedException(); }\n\n    public int IndexOf(T item) => ((IList<T>)_values).IndexOf(item);\n    public int IndexOf(object? value) => ((IList)_values).IndexOf(value);\n    public bool Contains(object? value) => ((IList)_values).Contains(value);\n\n    public int Add(object? value) => throw new NotSupportedException();\n    public void Insert(int index, T item) => throw new NotSupportedException();\n    public void Insert(int index, object? value) => throw new NotSupportedException();\n    public void Remove(object? value) => throw new NotSupportedException();\n    public void RemoveAt(int index) => throw new NotSupportedException();\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Method Merging Example\nDESCRIPTION: Illustrates how interface methods with different return types are merged in a derived interface using the override keyword. Shows implementation requirements for classes implementing such interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/covariant-returns.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1 { I1 M(); }\ninterface I2 { I2 M(); }\ninterface I3: I1, I2 { override I3 M(); }\n\nclass C : I1, I2, I3\n{\n    C IN.M();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Span<int> Creation and Capture in C#\nDESCRIPTION: This snippet showcases the creation of Span<int> objects with and without capturing references, illustrating the impact of 'scoped' keyword on safe contexts and ref-safe contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nSpan<int> CreateWithoutCapture(scoped ref int value)\n{\n    // Error: value Rule 3 specifies that the safe-context be limited to the ref-safe-context\n    // of the ref argument. That is the *function-member* for value hence this is not allowed.\n    return new Span<int>(ref value);\n}\n\nSpan<int> CreateAndCapture(ref int value)\n{\n    // Okay: value Rule 3 specifies that the safe-context be limited to the ref-safe-context\n    // of the ref argument. That is the *caller-context* for value hence this is not allowed.\n    return new Span<int>(ref value);\n}\n\nSpan<int> ComplexScopedRefExample(scoped ref Span<int> span)\n{\n    // Okay: the safe-context of `span` is *caller-context* hence this is legal.\n    return span;\n\n    // Okay: the local `refLocal` has a ref-safe-context of *function-member* and a \n    // safe-context of *caller-context*. In the call below it is passed to a \n    // parameter that is `scoped ref` which means it does not contribute \n    // ref-safe-context. It only contributes its safe-context hence the returned\n    // rvalue ends up as safe-context of *caller-context*\n    Span<int> local = default;\n    ref Span<int> refLocal = ref local;\n    return ComplexScopedRefExample(ref refLocal);\n\n    // Error: similar analysis as above but the safe-context of `stackLocal` is \n    // *function-member* hence this is illegal\n    Span<int> stackLocal = stackalloc int[42];\n    return ComplexScopedRefExample(ref stackLocal);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Iteration Type Inconsistency with IEnumerable Implementation\nDESCRIPTION: This example shows how a class implementing only System.Collections.IEnumerable can have a string iteration type rather than object. The specification doesn't require elements to convert to any specific type when a class only implements IEnumerable, but the implementation often assumes object.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass MyCollection : IEnumerable\n{\n    public IEnumerator<string> GetEnumerator() => throw null; \n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n}\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var l in new MyCollection())\n        {\n            string s = l; // Iteration type is string\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interpolated String Handler Example with Constant vs Non-Constant Expressions in C#\nDESCRIPTION: Example demonstrating how constant and non-constant interpolated string expressions are handled differently during overload resolution, with constant expressions preferring the string overload while non-constant expressions prefer the handler overload.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Log(string s) { ... }\nvoid Log(TraceLoggerParamsInterpolatedStringHandler p) { ... }\n\nLog($\"\"); // Calls Log(string s), because $\"\" is a constant expression\nLog($\"{\"test\"}\"); // Calls Log(string s), because $\"{\"test\"}\" is a constant expression\nLog($\"{1}\"); // Calls Log(TraceLoggerParamsInterpolatedStringHandler p), because $\"{1}\" is not a constant expression\n```\n\n----------------------------------------\n\nTITLE: Using IS Expression with Pattern Matching in C#\nDESCRIPTION: Example showing the improved pattern matching syntax for type checking and assignment in C# 7. This concise syntax replaces the traditional pattern of using 'as' operator followed by null check.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar v = expr as Type;\nif (v != null) { // code using v }\n```\n\nLANGUAGE: csharp\nCODE:\n```\nif (expr is Type v) { // code using v }\n```\n\n----------------------------------------\n\nTITLE: Defining a Readonly Ref Struct for Span in C#\nDESCRIPTION: This snippet defines a readonly ref struct for Span\\<T\\> in C#. The ref struct introduces a readonly ref field and an integer to manage data length. The provided constructor conveniently creates a span of length one over a stack value, promoting safe and efficient span operations without unsafe code. This pattern expects a reference to T and an integer, outputting an optimized structure for managing spans.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nreadonly ref struct Span<T>\n{\n    readonly ref T _field;\n    readonly int _length;\n\n    // This constructor does not exist today but will be added as a part \n    // of changing Span<T> to have ref fields. It is a convenient, and\n    // safe, way to create a length one span over a stack value that today \n    // requires unsafe code.\n    public Span(ref T value)\n    {\n        _field = ref value;\n        _length = 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async LINQ Query with Method Call\nDESCRIPTION: Shows how to use async methods within LINQ queries on IAsyncEnumerable<T>, including a separate async method definition.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nIAsyncEnumerable<string> result = from url in urls\n                                  where item % 2 == 0\n                                  select SomeAsyncMethod(item);\n\nasync ValueTask<int> SomeAsyncMethod(int item)\n{\n    await Task.Yield();\n    return item * 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Synthesized == and != Operators for Record Struct\nDESCRIPTION: This snippet shows the synthesized `==` and `!=` operators for a record struct in C#. The `==` operator calls the `Equals(R other)` method, and the `!=` operator delegates to the `==` operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n\"public static bool operator==(R r1, R r2)\\n    => r1.Equals(r2);\\npublic static bool operator!=(R r1, R r2)\\n    => !(r1 == r2);\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Collection with Capacity in C#\nDESCRIPTION: Demonstrates the translation of a collection literal to a type that supports collection initializers and has a constructor with a capacity parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nT __result = new T(capacity: __len);\n__result.Add(__e1);\nforeach (var __t in __s1)\n    __result.Add(__t);\n\n// further additions of the remaining elements\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Conversions with Different Parameter Modifiers in C#\nDESCRIPTION: This code example illustrates the rules for method group conversions between delegates with different parameter modifiers (ref, in, ref readonly). It shows which conversions are allowed with warnings and which result in errors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nDIn dIn = (ref int p) => { }; // error: cannot match `ref` to `in`\nDRef dRef = (in int p) => { }; // warning: mismatch between `in` and `ref`\nDRR dRR = (ref int p) => { }; // error: cannot match `ref` to `ref readonly`\ndRR = (in int p) => { }; // warning: mismatch between `in` and `ref readonly`\ndIn = (ref readonly int p) => { }; // warning: mismatch between `ref readonly` and `in`\ndRef = (ref readonly int p) => { }; // warning: mismatch between `ref readonly` and `ref`\ndelegate void DIn(in int p);\ndelegate void DRef(ref int p);\ndelegate void DRR(ref readonly int p);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating UnscopedRef Usage in Struct\nDESCRIPTION: Shows how UnscopedRef attribute enables ref returns from struct instance members by modifying the ref-safe-context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_19\n\nLANGUAGE: c#\nCODE:\n```\nstruct S\n{\n    int _field;\n\n    // Error: this, and hence _field, can't return by ref\n    public ref int Prop => ref _field;\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Expressions with Explicit Return Types\nDESCRIPTION: Explains the ability to specify explicit return types for lambda expressions, with examples of correct and incorrect syntax, and describes the parser behavior when differentiating between method calls and lambda expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nf = T () => default;                    // ok\nf = short x => 1;                       // syntax error at '=>'\nf = ref int (ref int x) => ref x;       // ok\nf = static void (_) => { };             // ok\nf = async async (async async) => async; // ok?\n```\n\nLANGUAGE: csharp\nCODE:\n```\nf = delegate int { return 1; };         // syntax error\nf = delegate int (int x) { return x; }; // syntax error\n```\n\n----------------------------------------\n\nTITLE: Multi-line Raw String with Terminal Newline\nDESCRIPTION: Shows how to include a terminal newline in a multi-line raw string literal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         This string ends with a new line.\n\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Defining a Person Class with Required Members in C#\nDESCRIPTION: This code snippet defines a basic structure for a 'Person' class that includes required properties and an optional middle name, showcasing how required members can reduce boilerplate code in C# initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Person\n{\n    public string FirstName { get; }\n    public string MiddleName { get; }\n    public string LastName { get; }\n\n    public Person(string firstName, string lastName, string? middleName = null)\n    {\n        FirstName = firstName;\n        LastName = lastName;\n        MiddleName = middleName ?? string.Empty;\n    }\n}\n\nclass Student : Person\n{\n    public int ID { get; }\n    public Student(int id, string firstName, string lastName, string? middleName = null)\n        : base(firstName, lastName, middleName)\n    {\n        ID = id;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Field Capture in Primary Constructor\nDESCRIPTION: Example showing explicit field initialization from primary constructor parameters with private backing fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-03.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person(string first, string last)\n{\n    private string _first = first;\n    private string _last = last;\n    public string Name => _first + \" \" + _last;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring File-Local Classes\nDESCRIPTION: This snippet demonstrates the declaration of file-local classes using the `file` modifier. Each file can contain a file-local class with the same name, and these classes are distinct from each other. Attempts to access a file-local type from another file will result in a compilation error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// File1.cs\nnamespace NS;\n\nfile class Widget\n{\n}\n\n// File2.cs\nnamespace NS;\n\nfile class Widget // different symbol than the Widget in File1\n{\n}\n\n// File3.cs\nusing NS;\n\nvar widget = new Widget(); // error: The type or namespace name 'Widget' could not be found.\n```\n\n----------------------------------------\n\nTITLE: Analysis of Records Feature Design in C#\nDESCRIPTION: Review of nominal records, value equality, and validation approaches. Covers property initialization, state validation, equality comparison implementations, and with expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-26.md#2025-04-21_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Implementing Covariant Returns in Factory Pattern\nDESCRIPTION: Example demonstrating covariant return types using the factory pattern in the context of Roslyn compiler. Shows a base Compilation class and derived CSharpCompilation class with covariant return type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/covariant-returns.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Compilation ...\n{\n    public virtual Compilation WithOptions(Options options)...\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nclass CSharpCompilation : Compilation\n{\n    public override CSharpCompilation WithOptions(Options options)...\n}\n```\n\n----------------------------------------\n\nTITLE: Quicksort Implementation with Local Function in C#\nDESCRIPTION: Demonstrates recursive local function implementation of Quicksort algorithm.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic static void Quicksort<T>(T[] elements) where T : IComparable<T>\n{\n    void Sort(int start, int end)\n    {\n        int i = start, j = end;\n        var pivot = elements[(start + end) / 2];\n\n        while (i <= j)\n        {\n            while (elements[i].CompareTo(pivot) < 0) i++;\n            while (elements[j].CompareTo(pivot) > 0) j--;\n            if (i <= j)\n            {\n                T tmp = elements[i];\n                elements[i] = elements[j];\n                elements[j] = tmp;\n                i++;\n                j--;\n            }\n        }\n        if (start < j) Sort(elements, start, j);\n        if (i < end) Sort(elements, i, end);\n    }\n\n    Sort(elements, 0, elements.Length - 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring the CollectionBuilderAttribute Class in C#\nDESCRIPTION: Definition of the CollectionBuilderAttribute class that is used to specify builder types and methods for collection expressions. This attribute allows custom collection types to support collection expression syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(\n        AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface,\n        Inherited = false,\n        AllowMultiple = false)]\n    public sealed class CollectionBuilderAttribute : System.Attribute\n    {\n        public CollectionBuilderAttribute(Type builderType, string methodName);\n        public Type BuilderType { get; }\n        public string MethodName { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Definition for Throw Expression\nDESCRIPTION: Formal grammar specification in ANTLR notation defining the syntax for throw expressions and their relation to null coalescing expressions in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/throw-expression.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nthrow_expression\n    : 'throw' null_coalescing_expression\n    ;\n\nnull_coalescing_expression\n    : throw_expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Effect on Existing Programs: Private Method Example in C#\nDESCRIPTION: This example shows that a private method in a derived class is unrelated to an interface method with the same name, maintaining compatibility with existing code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M();\n}\nclass Base: IA\n{\n    void IA.M() { }\n}\nclass Derived: Base, IA // OK, all interface members have a concrete most specific override\n{\n    private void M() { } // method unrelated to 'IA.M' because private\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Null Check Assignment Pattern in C#\nDESCRIPTION: Common code pattern that the null coalescing assignment operator aims to simplify, showing manual null check and assignment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/null-coalescing-assignment.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (variable == null)\n{\n    variable = expression;\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Parsing Examples\nDESCRIPTION: Multiple examples showing how generic syntax is interpreted in different contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nF(G < A, B > 7);\nF(G < A, B >> 7);\nx = F < A > +y;\nx = y is C<T> + z;\n```\n\n----------------------------------------\n\nTITLE: Mixed Deconstruction Assignment in C# 10.0\nDESCRIPTION: Demonstrates combining deconstruction declarations and assignments in a single statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\n(existingLocal, var declaredLocal) = expression\n```\n\n----------------------------------------\n\nTITLE: Dictionary Expression Syntax Examples\nDESCRIPTION: Examples showing the proposed syntax for dictionary expressions in C#, including basic key-value pair creation and using the spread operator to merge existing dictionaries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[\"mads\": 21, \"dustin\": 22]\n[.. currentStudents, \"mads\": 21, \"dustin\": 22]\n```\n\n----------------------------------------\n\nTITLE: Defining System.Threading.Lock Type Structure\nDESCRIPTION: The structure of the System.Threading.Lock type that will be special-cased by the C# lock keyword. The type provides Enter/Exit methods and an EnterScope method that returns a ref struct Scope with a Dispose method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/lock-object.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Threading\n{\n    public sealed class Lock\n    {\n        public void Enter();\n        public void Exit();\n        public Scope EnterScope();\n    \n        public ref struct Scope\n        {\n            public void Dispose();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Search with ref struct Constraints\nDESCRIPTION: Extension methods for binary search operations that support ref struct constraints with IComparer and IComparable interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-22-ref-struct-interface-examples.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static int BinarySearch<T, TComparer>(this System.ReadOnlySpan<T> span, T value, TComparer comparer)\n    where TComparer : System.Collections.Generic.IComparer<T>, allows ref struct;\n\npublic static int BinarySearch<T, TComparable>(this System.ReadOnlySpan<T> span, TComparable comparable)\n    where TComparable : System.IComparable<T>, allows ref struct;\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression Discard Parameters in C#\nDESCRIPTION: Examples of using discard parameters (_) in lambda expressions. These parameters indicate unused values in the lambda expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/lambda-discard-parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n(_, _) => 0\n```\n\nLANGUAGE: C#\nCODE:\n```\n(int _, int _) => 0\n```\n\n----------------------------------------\n\nTITLE: Creating ReadOnlySpans from Inline Arrays in C#\nDESCRIPTION: Code that demonstrates how the compiler creates ReadOnlySpan instances from inline array types. This provides read-only access to the elements using MemoryMarshal helper methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<TBuffer, TElement>(ref Unsafe.AsRef(in buffer)), size);\n```\n\n----------------------------------------\n\nTITLE: Using Records to Simplify Object Creation in C#\nDESCRIPTION: This snippet illustrates how the C# 'record' feature simplifies the creation of objects by reducing boilerplate for property initialization while retaining type safety.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nrecord Person(string FirstName, string LastName, string MiddleName = \"\");\nrecord Student(int ID, string FirstName, string LastName, string MiddleName = \"\") : Person(FirstName, LastName, MiddleName);\n```\n\n----------------------------------------\n\nTITLE: Base Interface Invocation with Explicit Interface Reference\nDESCRIPTION: Illustrates a syntax for base interface invocations where the interface containing the method declaration must be specified, but only one implementation source is available.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1 { void M(); }\ninterface I2 { void M(); }\ninterface I3 : I1, I2 { void I1.M() { } void I2.M() { } }\ninterface I5 : I3\n{\n    void I1.M()\n    {\n        base(I1).M(); // calls I3's implementation of I1.M\n    }\n    void I2.M()\n    {\n        base(I2).M(); // calls I3's implementation of I2.M\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Static Lambda Example\nDESCRIPTION: Example showing the basic syntax and usage of a static lambda expression in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/static-anonymous-functions.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic (int x) => x * 2\n```\n\n----------------------------------------\n\nTITLE: Using List Patterns in C# 11.0\nDESCRIPTION: Shows how to use list patterns for matching indexable types, a feature added in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nlist is [1, 2, ..]\n```\n\n----------------------------------------\n\nTITLE: Mixed Auto and Full Accessor Property in C#\nDESCRIPTION: Example of property with auto getter and custom setter using field keyword for INotifyPropertyChanged pattern\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n{ get; set => Set(ref field, value); }\n```\n\n----------------------------------------\n\nTITLE: Defining Collection Expression Conversion Rules for C#\nDESCRIPTION: Proposed rules for collection expression conversion targeting struct or class types implementing IEnumerable. Requires an accessible parameterless constructor and an accessible Add method compatible with the iteration type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-01-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Collection Expression Conversion Rules\n// For types implementing System.Collections.IEnumerable:\n// 1. Must have an accessible parameterless constructor\n// 2. Must have an accessible Add method matching iteration type\n\npublic class ExampleCollection<T>\n{\n    // Parameterless constructor\n    public ExampleCollection() { }\n\n    // Add method matching iteration type\n    public void Add(T item) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Null-conditional Assignment in C#\nDESCRIPTION: Examples showing the syntax and behavior of null-conditional assignment, including basic usage and nested scenarios. The feature allows for conditional assignment based on null checks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-10-26.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\na?.b = c();\n```\n\nLANGUAGE: csharp\nCODE:\n```\na?.b = c?.d = e?.f;\n```\n\n----------------------------------------\n\nTITLE: Compiler Constraints on Method Calls with Ref Structs\nDESCRIPTION: Shows how the compiler must conservatively assume the worst case for ref assignments, making APIs that could potentially create cyclic references effectively unusable without proper lifetime distinctions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_55\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(ref S s)\n{\n    ...\n}\n\nvoid Usage()\n{\n    // safe-context to caller-context\n    S local = default; \n\n    // Error: compiler is forced to assume the worst and concludes a self assignment\n    // is possible here and must issue an error.\n    M(ref local);\n}\n```\n\n----------------------------------------\n\nTITLE: Using CallerArgumentExpression to Capture Argument Expressions in C#\nDESCRIPTION: This code demonstrates how to define functions in C# using the `CallerArgumentExpression` attribute to capture the expression provided as an argument. The attributeâ€™s effects can be toggled via assembly-wide settings for compatibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// Assembly1\n\nvoid Foo(string bar); // V1\nvoid Foo(string bar, string barExpression = \"not provided\"); // V2\nvoid Foo(string bar, [CallerArgumentExpression(\"bar\")] string barExpression = \"not provided\"); // V3\n\n// Assembly2\n\nFoo(a); // V1: Compiles to Foo(a), V2, V3: Compiles to Foo(a, \"not provided\")\nFoo(a, \"provided\"); // V2, V3: Compiles to Foo(a, \"provided\")\n\n// Assembly3\n\n[assembly: EnableCallerArgumentExpression]\n\nFoo(a); // V1: Compiles to Foo(a), V2: Compiles to Foo(a, \"not provided\"), V3: Compiles to Foo(a, \"a\")\nFoo(a, \"provided\"); // V2, V3: Compiles to Foo(a, \"provided\")\n```\n\n----------------------------------------\n\nTITLE: Struct Field Initializers with Record Structs in C#\nDESCRIPTION: This code demonstrates the use of field initializers within a `record struct` without explicitly implementing the primary constructor. It showcases a simplified initialization pattern for record structs, allowing for default values to be assigned to properties upon instantiation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"record struct Person(string Name)\\n{\\n    public object Id { get; init; } = GetNextId();\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Using Alias with Tuple Type in C#\nDESCRIPTION: Example of creating a type alias for a tuple type, which would be allowed under the proposed change to C#'s using alias directive.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/using-alias-types.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing Point = (int x, int y);\n```\n\n----------------------------------------\n\nTITLE: Defining CollectionLiteralBuilder Attribute in C#\nDESCRIPTION: Example of defining the CollectionLiteralBuilder attribute for specifying factory methods for collection types, used in conjunction with collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\n[CollectionLiteralBuilder(\n    typeof(CollectionsMarshal),\n    nameof(CollectionsMarshal.Create))]\npublic class List<T> : IEnumerable<T> { } // or\n\n[CollectionLiteralBuilder(\n    typeof(CollectionsMarshal),\n    nameof(CollectionsMarshal.CreateRange))] \npublic sealed class ImmutableDictionary<TKey, TValue> : IDictionary<TKey, TValue> { }\n```\n\n----------------------------------------\n\nTITLE: Initializing Array with Collection Literal in C#\nDESCRIPTION: Example of initializing a single-dimensional array using a collection literal, showing equivalence to traditional array initialization syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nint[] a = [1, 2, 3]; // equivalent to:\nint[] a = new int[] { 1, 2, 3 };\n```\n\n----------------------------------------\n\nTITLE: Defining Switch Expression Syntax in C#\nDESCRIPTION: The confirmed syntax for switch expressions in C#, showing the expression-based pattern matching with arrow syntax for case handling.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-27.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ne switch\n{\n    a => b,\n    c => d,\n}\n```\n\n----------------------------------------\n\nTITLE: Covariant Array Conversion Example\nDESCRIPTION: Illustrates issues with covariant arrays when converting to Span<T>, showing how the conversion can throw ArrayTypeMismatchException and providing workarounds.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nstring[] s = new[] { \"a\" };\nobject[] o = s;\n\nC.R(o); // wrote 1 previously, now crashes in Span<T> constructor with ArrayTypeMismatchException\nC.R(o.AsEnumerable()); // workaround\n\nstatic class C\n{\n    public static void R<T>(IEnumerable<T> e) => Console.Write(1);\n    public static void R<T>(Span<T> s) => Console.Write(2);\n    // another workaround:\n    public static void R<T>(ReadOnlySpan<T> s) => Console.Write(3);\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Grammar Definition in ANTLR\nDESCRIPTION: Comprehensive ANTLR grammar rules defining various pattern types including declaration, constant, var, positional, property, and discard patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\npattern\n    : declaration_pattern\n    | constant_pattern\n    | var_pattern\n    | positional_pattern\n    | property_pattern\n    | discard_pattern\n    ;\ndeclaration_pattern\n    : type simple_designation\n    ;\nconstant_pattern\n    : constant_expression\n    ;\nvar_pattern\n    : 'var' designation\n    ;\npositional_pattern\n    : type? '(' subpatterns? ')' property_subpattern? simple_designation?\n    ;\nsubpatterns\n    : subpattern\n    | subpattern ',' subpatterns\n    ;\nsubpattern\n    : pattern\n    | identifier ':' pattern\n    ;\nproperty_subpattern\n    : '{' '}'\n    | '{' subpatterns ','? '}'\n    ;\nproperty_pattern\n    : type? property_subpattern simple_designation?\n    ;\nsimple_designation\n    : single_variable_designation\n    | discard_designation\n    ;\ndiscard_pattern\n    : '_'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Lifetime Constraints in C# Method\nDESCRIPTION: Example showing how named lifetimes could be used with scoped values and lifetime constraints, similar to Rust's lifetime system.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_44\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(scoped<'a> ref MyStruct s, scoped<'b> Span<int> span)\n  where 'b >= 'a\n{\n    s.Span = span;\n}\n```\n\n----------------------------------------\n\nTITLE: Target-Typed Collection Literal Example in C#\nDESCRIPTION: Shows usage of collection literal being target-typed to IEnumerable<long>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_24\n\nLANGUAGE: c#\nCODE:\n```\nvoid DoWork(IEnumerable<long> values) { ... }\nDoWork([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Using `nameof` with Parameter Attributes (C#)\nDESCRIPTION: This example illustrates how to use `nameof` to refer to another parameter within an attribute applied to a parameter.  In this case, the `MyAttribute` on the `other` parameter is referencing the `parameter` parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/extended-nameof-scope.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n\"void M(int parameter, [MyAttribute(nameof(parameter))] int other) { }\"\n```\n\n----------------------------------------\n\nTITLE: Modifying Shift Expression Grammar in ANTLR\nDESCRIPTION: This snippet modifies the `shift_expression` rule in the ANTLR grammar to include the unsigned right shift operator `>>>`. It integrates the new operator into the existing hierarchy of shift expressions, allowing it to be used alongside the left shift (`<<`) and right shift (`>>`) operators. The snippet also mentions that binary operator overload resolution will apply.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/unsigned-right-shift-operator.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\n\"shift_expression\\n    : additive_expression\\n    | shift_expression '<<' additive_expression\\n    | shift_expression right_shift additive_expression\\n    | shift_expression unsigned_right_shift additive_expression\\n    ;\"\n```\n\n----------------------------------------\n\nTITLE: Integrating Tuples with LINQ Queries in C#\nDESCRIPTION: This snippet demonstrates how tuples could be used in LINQ queries, potentially competing with anonymous types. It shows both explicit member naming and inferred member names through projection.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\nfrom c in customers\nselect (name: c.Name, age: c.Age) into p\nwhere p.name == \"Kevin\"\nselect p;\n\nfrom c in customers\nselect (c.Name, c.Age) into p // infers (string Name, int Age)\nwhere p.Name == \"Kevin\"\nselect p;\n```\n\n----------------------------------------\n\nTITLE: Using Nullable Compiler Directive in C#\nDESCRIPTION: Example of using a #pragma warning directive to disable nullable warnings in C#. This affects the nullable warning context for subsequent lines of code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n#pragma warning disable nullable\n```\n\n----------------------------------------\n\nTITLE: Using Init and Set in C# Property Declaration\nDESCRIPTION: This C# code snippet demonstrates a property with both `init` and `set` accessors. It allows setting a property internally using the `init` accessor while providing a public `set` accessor that invokes a method to set the field and notify changes. This pattern is commonly used when changes to a property need to trigger additional logic, such as event notification. Dependencies include a method `SetAndNotifyIfChanged` which implements the notification logic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-01-15.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic int Prop\n{ \n    get;\n    private init;\n    set => SetAndNotifyIfChanged(ref field, value);\n}\n```\n\n----------------------------------------\n\nTITLE: Init Property Declaration Equivalence\nDESCRIPTION: Demonstrates how the standalone init accessor and explicit init set accessor declarations are equivalent.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nint Property1 { get; init; }\nint Property1 { get; init set; }\n```\n\n----------------------------------------\n\nTITLE: Primary Constructor Basic Syntax Example in C#\nDESCRIPTION: Demonstrates the proposed syntax for primary constructors in C#, showing parameter declaration and base class constructor chaining.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-10-21.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class C(int i, string s) : B(s)\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ModuleInitializerAttribute in C#\nDESCRIPTION: Defines the ModuleInitializerAttribute class used to mark methods that should be executed during module initialization. The attribute can only be applied to methods and cannot be used multiple times on the same method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/module-initializers.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public sealed class ModuleInitializerAttribute : Attribute { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Copy Constructor for Records in C#\nDESCRIPTION: Demonstrates the generated code for a copy constructor in a record class, which performs a field-wise copy of the original object.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-27.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    protected C(C other)\n    {\n        field1 = other.field1;\n        ...\n        fieldN = other.fieldN;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Debug.Assert with CallerArgumentExpression Attribute in C#\nDESCRIPTION: This code snippet shows how the CallerArgumentExpression attribute can be used to automatically capture the expression passed to the condition parameter of Debug.Assert. This provides more informative error messages when an assertion fails.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\npublic static class Debug\n{\n    public static void Assert(bool condition, [CallerArgumentExpression(\"condition\")] string message = null);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Extension Method Examples in C#\nDESCRIPTION: Demonstrates limitations and proper usage of collection expressions with extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class Extensions\n{\n    public static ImmutableArray<T> AsImmutableArray<T>(this ImmutableArray<T> arg) => arg;\n}\n\nvar x = [1].AsImmutableArray();           // error: collection expression has no target type\nvar y = [2].AsImmutableArray<int>();      // error: ...\nvar z = Extensions.AsImmutableArray([3]); // ok\n```\n\n----------------------------------------\n\nTITLE: Implementing PrintMembers Method for C# Record Types\nDESCRIPTION: This code snippet demonstrates the implementation of the PrintMembers method for record types. It handles both base and derived records, appending member names and values to a StringBuilder.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nbool PrintMembers(System.Text.StringBuilder builder);\n```\n\n----------------------------------------\n\nTITLE: Using Scoped Parameter to Fix JsonReader Ref Safety\nDESCRIPTION: Demonstrates how the scoped keyword resolves the method arguments must match rule friction by indicating that a parameter will not be captured, allowing more flexible calling patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_51\n\nLANGUAGE: csharp\nCODE:\n```\nref struct JsonReader\n{\n    Span<char> _buffer;\n    int _position;\n\n    internal bool TextEquals(scoped ReadOnlySpan<char> text)\n    {\n        var current = _buffer.Slice(_position, text.Length);\n        return current == text;\n    }\n}\n\nclass C\n{\n    static void M(ref JsonReader reader)\n    {\n        Span<char> span = stackalloc char[4];\n        span[0] = 'd';\n        span[1] = 'o';\n        span[2] = 'g';\n\n        // Okay: the compiler never considers `span` as capturable here hence it doesn't\n        // contribute to the method arguments must match rule\n        if (reader.TextEquals(span))\n        {\n            ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Property Initialization Limitations Example in C#\nDESCRIPTION: Shows current limitations of property initialization patterns and how different constructor scenarios handle property initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/fieldof.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass C1 {\n    // \"stuff available in a static context\" can be used:\n    public partial string Prop { get; set; } = ValueFactory.GetValue();\n}\n\nclass C2(string prop) {\n    // primary constructor parameters can be used:\n    public partial string Prop { get; set; } = prop;\n}\n\npublic class C3 {\n    internal C3() {\n        var (first, second) = GetValues();\n        Prop1 = first;\n        Prop2 = second;\n    }\n\n    public partial string Prop1 { get; set; }\n    public partial string Prop2 { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Method Call Ambiguity Example\nDESCRIPTION: Example demonstrating potential ambiguity in parsing generic method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nF(G<A,B>(7));\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Types for Expressions in C#\nDESCRIPTION: This snippet defines a set of recursive types to represent mathematical expressions in C#. It includes an abstract base class Expr and several derived classes for different expression types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nabstract class Expr;\nclass X() : Expr;\nclass Const(double Value) : Expr;\nclass Add(Expr Left, Expr Right) : Expr;\nclass Mult(Expr Left, Expr Right) : Expr;\nclass Neg(Expr Value) : Expr;\n```\n\n----------------------------------------\n\nTITLE: Using UTF-8 String Literals in C# 11.0\nDESCRIPTION: Shows how to create a UTF-8 string literal using the u8 suffix, a feature added in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nReadOnlySpan<byte> s = \"hello\"u8;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Accessibility Rules for Required Members in C#\nDESCRIPTION: This code snippet showcases various error cases related to the accessibility of required members in C#. It demonstrates when required members are not allowed, such as with readonly fields, properties without setters, and hidden or explicit interface implementation members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I\n{\n    int Prop1 { get; }\n}\npublic class Base\n{\n    public virtual int Prop2 { get; set; }\n\n    protected required int _field; // Error: _field is not at least as visible as Base. Open question below about the protected constructor scenario\n\n    public required readonly int _field2; // Error: required fields cannot be readonly\n    protected Base() { }\n\n    protected class Inner\n    {\n        protected required int PropInner { get; set; } // Error: PropInner cannot be set inside Base or Derived\n    }\n}\npublic class Derived : Base, I\n{\n    required int I.Prop1 { get; } // Error: explicit interface implementions cannot be required as they cannot be set in an object initializer\n\n    public required override int Prop2 { get; set; } // Error: this property is hidden by Derived.Prop2 and cannot be set in an object initializer\n    public new int Prop2 { get; }\n\n    public required int Prop3 { get; } // Error: Required member must have a setter or initer\n\n    public required int Prop4 { get; internal set; } // Error: Required member setter must be at least as visible as the constructor of Derived\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Method Implementation Breaking Change Example\nDESCRIPTION: Demonstrates a breaking change in interface method implementation behavior with covariant return types. The example shows how the output would change under the proposed specification revisions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/covariant-returns.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\ninterface I1 { object M(); }\nclass C1 : I1 { public object M() { return \"C1.M\"; } }\nclass C2 : C1, I1 { public new string M() { return \"C2.M\"; } }\nclass Program\n{\n    static void Main()\n    {\n        I1 i = new C2();\n        Console.WriteLine(i.M());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pragma Warning Directives Grammar in ANTLR\nDESCRIPTION: ANTLR grammar rules extending pragma warning directives to support nullable context controls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_4\n\nLANGUAGE: antlr\nCODE:\n```\npragma_warning_body\n    : ...\n    | 'warning' whitespace nullable_action whitespace 'nullable'\n    ;\n\nwarning_action\n    : ...\n    | 'enable'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Accessing Static Abstract Interface Members Through Type Parameters - C#\nDESCRIPTION: Shows how to access static abstract members via type parameters constrained by interfaces with such members. When the type parameter satisfies the interface constraint, the static members can be called directly, providing a mechanism for generic algorithms to leverage the static interface members, which are bound to the concrete type provided.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nT M<T>() where T : I<T>\n{\n    T.M();\n    T t = T.P;\n    T.E += () => { };\n    return t + T.P;\n}\n\nC c = M<C>(); // The static members of C get called\n```\n\n----------------------------------------\n\nTITLE: Alternative Operator Lookup and Resolution Example #1\nDESCRIPTION: Example showing an alternative approach to operator lookup that first attempts to match operators in the current context before falling back to operators in the opposite context. Demonstrates how this affects resolution for addition, subtraction, multiplication, and division operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyClass\n{\n    public static void Add(Int128 lhs, Int128 rhs)\n    {\n        // Resolves to `op_CheckedAddition`\n        Int128 r1 = checked(lhs + rhs);\n\n        // Resolves to `op_Addition`\n        Int128 r2 = unchecked(lhs + rhs);\n\n        // Resolve to `op_Subtraction`\n        Int128 r3 = checked(lhs - rhs);\n\n        // Resolve to `op_Subtraction`\n        Int128 r4 = unchecked(lhs - rhs);\n\n        // Resolves to `op_CheckedMultiply`\n        Int128 r5 = checked(lhs * rhs);\n\n        // Resolves to `op_CheckedMultiply`\n        Int128 r5 = unchecked(lhs * rhs);\n    }\n\n    public static void Divide(Int128 lhs, byte rhs)\n    {\n        // Resolves to `op_CheckedDivision`\n        Int128 r4 = checked(lhs / rhs);\n    }\n}\n\npublic struct Int128\n{\n    public static Int128 operator checked +(Int128 lhs, Int128 rhs);\n    public static Int128 operator +(Int128 lhs, Int128 rhs);\n\n    public static Int128 operator -(Int128 lhs, Int128 rhs);\n\n    public static Int128 operator checked *(Int128 lhs, Int128 rhs);\n\n    public static Int128 operator checked /(Int128 lhs, int rhs);\n    public static Int128 operator /(Int128 lhs, byte rhs);\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Synthesized Equality Members for Record Struct\nDESCRIPTION: This snippet provides an example of synthesized equality members for a record struct `R1` with two properties, `P1` and `P2`. It shows the implementation of `Equals(object? obj)`, `Equals(R1 other)`, `==`, `!=`, and `GetHashCode()`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n\"struct R1 : IEquatable<R1>\\n{\n    public T1 P1 { get; set; }\\n    public T2 P2 { get; set; }\\n    public override bool Equals(object? obj) => obj is R1 temp && Equals(temp);\\n    public bool Equals(R1 other)\\n    {\n        return\\n            EqualityComparer<T1>.Default.Equals(P1, other.P1) &&\\n            EqualityComparer<T2>.Default.Equals(P2, other.P2);\\n    }\\n    public static bool operator==(R1 r1, R1 r2)\\n        => r1.Equals(r2);\\n    public static bool operator!=(R1 r1, R1 r2)\\n        => !(r1 == r2);    \\n    public override int GetHashCode()\\n    {\n        return Combine(\\n            EqualityComparer<T1>.Default.GetHashCode(P1),\\n            EqualityComparer<T2>.Default.GetHashCode(P2));\\n    }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Type Inference Examples in C#\nDESCRIPTION: Shows how type inference works with collection expressions in method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar a = AsArray([1, 2, 3]);          // AsArray<int>(int[])\nvar b = AsListOfArray([[4, 5], []]); // AsListOfArray<int>(List<int[]>)\n\nstatic T[] AsArray<T>(T[] arg) => arg;\nstatic List<T[]> AsListOfArray<T>(List<T[]> arg) => arg;\n```\n\n----------------------------------------\n\nTITLE: Single-line Raw String Literal in C#\nDESCRIPTION: Shows the syntax for creating a single-line raw string literal without newline characters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar xml = \"\"\"<summary><element attr=\"content\"/></summary>\"\"\";\n```\n\n----------------------------------------\n\nTITLE: Demonstrating OverloadResolutionPriority with Span and Array Overloads in C#\nDESCRIPTION: Example showing how the OverloadResolutionPriority attribute affects method resolution, causing a ReadOnlySpan<int> overload to be chosen over an array overload when an array is passed as an argument.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/overload-resolution-priority.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Runtime.CompilerServices;\n\nvar d = new C1();\nint[] arr = [1, 2, 3];\nd.M(arr); // Prints \"Span\"\n\nclass C1\n{\n    [OverloadResolutionPriority(1)]\n    public void M(ReadOnlySpan<int> s) => Console.WriteLine(\"Span\");\n    // Default overload resolution priority\n    public void M(int[] a) => Console.WriteLine(\"Array\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example Fibonacci Top-level Program in C#\nDESCRIPTION: Demonstrates a practical example of top-level statements computing Fibonacci numbers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nif (args.Length == 0\n    || !int.TryParse(args[0], out int n)\n    || n < 0) return;\nConsole.WriteLine(Fib(n).curr);\n\n(int curr, int prev) Fib(int i)\n{\n    if (i == 0) return (1, 0);\n    var (curr, prev) = Fib(i - 1);\n    return (curr + prev, curr);\n}\n```\n\n----------------------------------------\n\nTITLE: Example of File Scoped Namespace Equivalent\nDESCRIPTION: This snippet provides an example of how the file scoped namespace declaration can be written and its semantic equivalence to the traditional declaration structure. It illustrates the simplification of syntax with equivalent results.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/file-scoped-namespaces.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nextern alias A;\nnamespace Name;\nusing B;\nclass C\n{\n}\n\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Compilation Example\nDESCRIPTION: Shows the compiler-generated code for handling collection expressions with spread elements, including length calculation and element copying.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar __tmp1 = a;\nvar __tmp2 = b;\nvar __tmp3 = c;\nvar __result = new int[2 + __tmp2.Length + __tmp3.Length];\nint __index = 0;\n__result[__index++] = __tmp1;\nforeach (var __i in __tmp2) __result[__index++] = __i;\nforeach (var __i in __tmp3) __result[__index++] = __i;\n__result[__index++] = d;\nx = __result;\n```\n\n----------------------------------------\n\nTITLE: Defining Safe Fixed Size Buffers in C#\nDESCRIPTION: Example of the proposed safe fixed size buffer syntax that would allow declaration of fixed-size arrays in safe code with managed or unmanaged element types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_25\n\nLANGUAGE: c#\nCODE:\n```\ninternal struct CharBuffer\n{\n    internal char Data[128];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Checked Operators in C#\nDESCRIPTION: Demonstrates the definition of checked operators in C# within a type, specifying how to declare operators to control overflow behavior. Key functionality includes operator overloading for both unary and binary operations with explicit overflow checks. Prerequisites include understanding of C# operator overloading.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static T operator checked ++(T x) {...}\npublic static T operator checked --(T x) {...}\npublic static T operator checked -(T x) {...}\npublic static T operator checked +(T lhs, T rhs) {...}\npublic static T operator checked -(T lhs, T rhs) {...}\npublic static T operator checked *(T lhs, T rhs) {...}\npublic static T operator checked /(T lhs, T rhs) {...}\npublic static explicit operator checked U(T x) {...}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static T I1.operator checked ++(T x) {...}\npublic static T I1.operator checked --(T x) {...}\npublic static T I1.operator checked -(T x) {...}\npublic static T I1.operator checked +(T lhs, T rhs) {...}\npublic static T I1.operator checked -(T lhs, T rhs) {...}\npublic static T I1.operator checked *(T lhs, T rhs) {...}\npublic static T I1.operator checked /(T lhs, T rhs) {...}\npublic static explicit I1.operator checked U(T x) {...}\n```\n\n----------------------------------------\n\nTITLE: Using Generic Attributes in C# 11.0\nDESCRIPTION: Shows how to use generic attributes, a feature added in C# 11.0 that allows attributes to be generic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n[MyAttribute<int>]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Most Specific Implementation Rule in C#\nDESCRIPTION: This code snippet illustrates the most specific implementation rule for interfaces and classes in C#. It shows how conflicts arising from diamond inheritance must be resolved explicitly by the programmer.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M() { WriteLine(\"IA.M\"); }\n}\ninterface IB : IA\n{\n    void IA.M() { WriteLine(\"IB.M\"); }\n}\ninterface IC : IA\n{\n    void IA.M() { WriteLine(\"IC.M\"); }\n}\ninterface ID : IB, IC { } // compiles, but error when a class implements 'ID'\nabstract class C : IB, IC { } // error: no most specific implementation for 'IA.M'\nabstract class D : IA, IB, IC // ok\n{\n    public abstract void M();\n}\npublic class E : ID { } // Error. No most specific implementation for 'IA.M'\n```\n\n----------------------------------------\n\nTITLE: Init Field Usage Example\nDESCRIPTION: Example showing how init fields would work with object initializers and readonly enforcement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nclass Student\n{\n    public init string FirstName;\n    public init string LastName;\n}\n\nvar s = new Student()\n{\n    FirstName = \"Jarde\",\n    LastName = \"Parsons\",\n}\n\ns.FirstName = \"Jared\"; // Error FirstName is readonly\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Record Inheritance in C#\nDESCRIPTION: Example of record inheritance in C#, showing how base constructor parameters are passed and how ToString() can be overridden.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-01.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nrecord Person(string FirstName, string LastName)\n{\n    public string Fullname => $\"{FirstName} {LastName}\";\n    public override string ToString() => $\"{FirstName} {LastName}\";\n}\n\nrecord Student(string FirstName, string LastName, int Id)\n    : Person(FirstName, LastName)\n{\n    public override string ToString() => $\"{FirstName} {LastName} ({ID})\";\n}\n```\n\n----------------------------------------\n\nTITLE: Target-Typed Static Member Lookup in C#\nDESCRIPTION: This snippet describes a new feature allowing static members of a type to be accessed without qualification if the expression is target-typed. It explains the potential benefits and concerns related to syntax and usability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-03-05.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ntype.GetMethod(\"Name\", .Public | .Instance | .DeclaredOnly); // BindingFlags.Public | ...\n```\n\n----------------------------------------\n\nTITLE: Using enum and delegate Type Constraints in C#\nDESCRIPTION: Example demonstrating the usage of enum and delegate type parameter constraints introduced in C# 7.3. These constraints allow generic type parameters to be restricted to only enum types or delegate types respectively.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/enum-delegate-constraints.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nwhere T : enum\nwhere T : delegate\n```\n\n----------------------------------------\n\nTITLE: Demonstrating OverloadResolutionPriority Impact on Method Callability\nDESCRIPTION: Example showing how OverloadResolutionPriorityAttribute can make certain method overloads effectively uncallable from source code, including cases with conditional methods and type variance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/overload-resolution-priority.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Runtime.CompilerServices;\n\nint i = 1;\nvar c = new C3();\nc.M1(i); // Will call C3.M1(long), even though there's an identity conversion for M1(int)\nc.M2(i); // Will call C3.M2(int, string), even though C3.M1(int) has less default parameters\n\nclass C3\n{\n    public void M1(int i) {}\n    [OverloadResolutionPriority(1)]\n    public void M1(long l) {}\n\n    [Conditional(\"DEBUG\")]\n    public void M2(int i) {}\n    [OverloadResolutionPriority(1), Conditional(\"DEBUG\")]\n    public void M2(int i, [CallerArgumentExpression(nameof(i))] string s = \"\") {}\n\n    public void M3(string s) {}\n    [OverloadResolutionPriority(1)]\n    public void M3(object o) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Invocation Expression Null Handling in C#\nDESCRIPTION: Shows proper null handling patterns for method invocations, demonstrating both incorrect null checking and the recommended nullable-friendly pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\n// The result of an invocation_expression is not tracked\nif (GetText() is not null)\n{\n    // Warning: Converting null literal or possible null value to non-nullable type.\n    string s = GetText();\n    // Warning: Dereference of a possibly null reference.\n    Use(s);\n}\n\n// Nullable friendly pattern\nif (GetText() is string s)\n{\n    Use(s);\n}\n\nstring? GetText() => ... \nUse(string s) {  }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Expressions in C#\nDESCRIPTION: Shows the new syntax for default expressions in C# 7.1, allowing target-typed default expressions where the type is omitted. Also demonstrates cases where the new syntax is not allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-07.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nint i = default(int); // Current\nint i = default;      // New\nvar i = default;      // Error: no target type\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Struct Declaration with Primary Constructor\nDESCRIPTION: ANTLR grammar rules defining the extended syntax for struct declarations with primary constructor parameter lists.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nstruct_declaration\n  : attributes? struct_modifier* 'partial'? 'record'? 'struct' identifier type_parameter_list?\n    parameter_list? struct_interfaces? type_parameter_constraints_clause* struct_body\n  ;\n\nstruct_body\n  : '{' struct_member_declaration* '}' ';'?\n  | ';'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Testing Escape Character Equivalence in C#\nDESCRIPTION: Code sample demonstrating equivalence between the proposed \\e escape sequence and existing representations of the ESCAPE character.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/esc-escape-sequence.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nchar escape_char = '\\e';\n\nAssert.IsTrue(escape_char == (char)0x1b, \"...\");\nAssert.IsTrue(escape_char == '\\u001b', \"...\");\nAssert.IsTrue(escape_char == '\\U0000001b', \"...\");\nAssert.IsTrue(escape_char == '\\x1b', \"...\");\n```\n\n----------------------------------------\n\nTITLE: Defining CollectionsMarshal Factory Methods in C#\nDESCRIPTION: Example of defining the CollectionsMarshal static class with Create and CreateRange methods for efficient collection initialization, used with collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\npublic static class CollectionsMarshal\n{\n    // For cases where the instance can share out its storage as a sequential buffer for caller to place the values in.\n    // Storage span is passed out for caller to populate with no overhead.\n    public static void Create<T>(\n        int capacity,\n        out List<T> collection,\n        out Span<T> storage);\n    \n    public static void Create<T>(\n        int capacity,\n        out ImmutableArray<T> collection,\n        out Span<T> storage);\n    \n    // For cases where the final instance has to manage non-sequential structure.  Storage is passed in and copied over to\n    // internal structure.\n    public static void CreateRange<T>(\n        out ImmutableHashSet<T> collection,\n        ReadOnlySpan<T> storage);\n    \n    // Example of the shape for things like dictionaries.\n    public static void CreateRange<TKey, TValue>(\n        out ImmutableDictionary<TKey, TValue> dictionary,\n        ReadOnlySpan<KeyValuePair<TKey, TValue>> storage);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Shift Right Operators in C#\nDESCRIPTION: This snippet defines the right shift operator for nint and nuint types, facilitating logical right shifting. Dependencies include understanding the behavior of nint and nuint with respect to signed and unsigned integer types. The operator takes 'x' for the value and 'count' for the bits shifted.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnint operator >>(nint x, int count);\n    nuint operator >>(nuint x, int count);\n```\n\n----------------------------------------\n\nTITLE: Defining Null-Forgiving Operator in C# ANTLR Grammar\nDESCRIPTION: ANTLR grammar rules for defining the null-forgiving operator (!) in C#, which can be applied to primary expressions and within null conditional expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR\nCODE:\n```\nprimary_expression\n    : ...\n    | null_forgiving_expression\n    ;\n\nnull_forgiving_expression\n    : primary_expression '!'\n    ;\n\nnull_conditional_expression\n    : primary_expression null_conditional_operations_no_suppression suppression?\n    ;\n\nnull_conditional_operations_no_suppression\n    : null_conditional_operations? '?' '.' identifier type_argument_list?\n    | null_conditional_operations? '?' '[' argument_list ']'\n    | null_conditional_operations '.' identifier type_argument_list?\n    | null_conditional_operations '[' argument_list ']'\n    | null_conditional_operations '(' argument_list? ')'\n    ;\n\nnull_conditional_operations\n    : null_conditional_operations_no_suppression suppression?\n    ;\n\nsuppression\n    : '!'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Runtime Helper for Array Slicing\nDESCRIPTION: Definition of the RuntimeHelpers class containing the GetSubArray method for array slicing operations using Range.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    public static class RuntimeHelpers\n    {\n        public static T[] GetSubArray<T>(T[] array, System.Range range);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Unary and Binary Operators\nDESCRIPTION: These examples outline the declaration of unary and binary operators, demonstrating both the checked and regular versions in a struct. It includes scenarios where only regular or both checked and regular operators are implemented, highlighting the compile-time checks required.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic struct Int128\n{\n    // This is fine, both a checked and regular operator are defined\n    public static Int128 operator checked -(Int128 lhs);\n    public static Int128 operator -(Int128 lhs);\n\n    // This is fine, only a regular operator is defined\n    public static Int128 operator --(Int128 lhs);\n\n    // This should error, a regular operator must also be defined\n    public static Int128 operator checked ++(Int128 lhs);\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic struct Int128\n{\n    // This is fine, both a checked and regular operator are defined\n    public static Int128 operator checked +(Int128 lhs, Int128 rhs);\n    public static Int128 operator +(Int128 lhs, Int128 rhs);\n\n    // This is fine, only a regular operator is defined\n    public static Int128 operator -(Int128 lhs, Int128 rhs);\n\n    // This should error, a regular operator must also be defined\n    public static Int128 operator checked *(Int128 lhs, Int128 rhs);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference and Nullability in C#\nDESCRIPTION: This code snippet illustrates type inference scenarios with nullable reference types, including generic methods and conditional assignments. It highlights potential issues and considerations for type inference with var keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-28.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n    static T[] MakeStack<T>(T element)\n    {\n\n    }\n    static int GetLengthOfMiddleName(Person p)\n    {\n        string? middleName = p.MiddleName;\n\n        //return middleName.Length;\n        if (middleName is null) return 0;\n        var stack = MakeStack(middleName); // infer string[] or string?[]\n    }\n\n\n        bool b = false;\n        string s = null; // suppressible\n        var s2 =\n            //(b ? s : s);\n            Choose(b, s, s);\n        var l = s2.Length; // not suppressible\n```\n\n----------------------------------------\n\nTITLE: Assertion with Debug.Assert in C#\nDESCRIPTION: This code snippet demonstrates the use of Debug.Assert for asserting conditions within a method. It highlights the problem of not having enough context when an assertion fails, leading to difficulties in debugging.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nT Single<T>(this T[] array)\n{\n    Debug.Assert(array != null);\n    Debug.Assert(array.Length == 1);\n\n    return array[0];\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Aliasing Behavior of 'in' Parameters in C#\nDESCRIPTION: Demonstrates how 'in' parameters behave as references/aliases to existing locations, and how their values can change as a side effect of other operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Vector3 v = Vector3.UnitY;\n\nstatic void Main()\n{\n    Test(v);\n}\n\nstatic void Test(in Vector3 v1)\n{\n    Debug.Assert(v1 == Vector3.UnitY);\n    // changes v1 deterministically (no races required)\n    ChangeV();\n    Debug.Assert(v1 == Vector3.UnitX);\n}\n\nstatic void ChangeV()\n{\n    v = Vector3.UnitX;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deconstruction with Instance Method in C#\nDESCRIPTION: Example showing how to implement a deconstructor as an instance method in a class, allowing the class to be deconstructed into component parts using out parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-05-03-04.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Name\n{\n    public void Deconstruct(out string first, out string last) { first = First; last = Last; }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Null-Forgiving Operator Usage in C#\nDESCRIPTION: Examples showing different ways to use the null-forgiving operator (!) to handle nullability warnings and type changes in method parameters and collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-03-21.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(string? ns, List<string?>? ln)\n{\n    string s = ns!; // silence and change nullability\n    var s2 = ns!; // silence and produce string\n    ln = null;\n    List<string>? l = ln!; // silence and change\n    var l2 = ln!;\n    // Idea 1\n    l! // change nullability at the top level\n    l<!> // idea: change nullability at the nested level\n    // Idea 2\n    (List<string>?!)ln; // I do a cast that should warn but ! silences it\n    List<string>? l3 = (!)ln; // Shorthand\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Expression with Arguments Syntax Example\nDESCRIPTION: Demonstrates the proposed syntax for passing a comparer argument to a Dictionary collection expression using the 'with' keyword. The arguments are used to configure the collection's behavior during creation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> nameToAge = [with(comparer), .. d1, .. d2, .. d3];\n```\n\n----------------------------------------\n\nTITLE: Using Parameter Arrays (params) in Lambda Expressions in C# 12\nDESCRIPTION: Demonstrates how to define and use lambda expressions with parameter arrays (params). The example shows a lambda that counts the number of arguments passed to it.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar counter = (params int[] xs) => xs.Length;\ncounter(); // 0\ncounter(1, 2, 3); // 3\n```\n\n----------------------------------------\n\nTITLE: Conditional Spread Element Example\nDESCRIPTION: Shows how empty collection literals can be used in conditional spread elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nbool b = ...\nList<int> l = [x, y, .. b ? [1, 2, 3] : []];\n```\n\n----------------------------------------\n\nTITLE: Defining a Record Class with Positional Parameters in C#\nDESCRIPTION: Demonstrates the concise syntax for declaring a record class with positional parameters, which automatically become properties of the class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Switch Expression with Relational Patterns in C#\nDESCRIPTION: Demonstrates an exhaustive switch expression using relational patterns, which would require changes to the exhaustiveness checking algorithm.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nbyte b = ...;\nint x = b switch { <100 => 0, 100 => 1, 101 => 2, >101 => 3 };\n```\n\n----------------------------------------\n\nTITLE: Block-bodied switch expression example in C#\nDESCRIPTION: This C# code demonstrates the use of block-bodied switch expression arms, allowing multiple statements and conditional logic within each arm. The `break` statement is used to return a value from the block. This is an illustrative example of how to leverage the feature in practice.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/block-bodied-switch-expression-arms.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(List<object> myObjects)\n{\n    var stringified = myObjects switch {\n        List<string> strings => string.Join(strings, \",\"),\n        List<MyType> others => {\n            string result = string.Empty;\n            foreach (var other in others)\n            {\n                if (other.IsFaulted) return;\n                else if (other.IsLastItem) break; // This breaks the foreach, not the switch\n\n                result += other.ToString();\n            }\n\n            break result;\n        },\n        _ => {\n            var message = $\"Unexpected type {myObjects.GetType()}\";\n            Logger.Error(message);\n            throw new InvalidOperationException(message);\n        }\n    };\n\n    Console.WriteLine(stringified);\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference with var Declaration\nDESCRIPTION: Demonstrates type inference for local variables declared with var keyword. The inferred type depends on the null state of the initializing expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = E;\n```\n\n----------------------------------------\n\nTITLE: Resolving Diamond Inheritance with Base Interface Invocation in C#\nDESCRIPTION: This snippet shows how to resolve diamond inheritance conflicts by explicitly delegating to a specific base interface implementation using the base(Type).M syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M() { WriteLine(\"IA.M\"); }\n}\ninterface IB : IA\n{\n    override void IA.M() { WriteLine(\"IB.M\"); }\n}\ninterface IC : IA\n{\n    override void IA.M() { WriteLine(\"IC.M\"); }\n}\n\nclass D : IA, IB, IC\n{\n    void IA.M() { base(IB).M(); }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Ref-Like Struct in C#\nDESCRIPTION: Example of defining a ref struct called TwoSpans<T> that contains two Span<T> fields. The example also shows that arrays of ref-like types are not allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nref struct TwoSpans<T>\n{\n\t// can have ref-like instance fields\n\tpublic Span<T> first;\n\tpublic Span<T> second;\n} \n\n// error: arrays of ref-like types are not allowed. \nTwoSpans<T>[] arr = null;\n```\n\n----------------------------------------\n\nTITLE: Constant Expression Definition in ANTLR\nDESCRIPTION: This ANTLR grammar snippet defines the constant expression rule, indicating what constitutes a constant expression in the context of the proposed C# changes. The snippet is fundamental for understanding how various expressions are evaluated in compile-time context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/constant_interpolated_strings.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nconstant_expression\n    : expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Combinators in C#\nDESCRIPTION: These C# code snippets demonstrate the usage of pattern combinators 'not', 'and', and 'or' for more complex pattern matching scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nif (e is not null) ...\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsLetter(char c) => c is >= 'a' and <= 'z' or >= 'A' and <= 'Z';\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsLetter(char c) => c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z');\n```\n\n----------------------------------------\n\nTITLE: Implementing ToString Method for C# Record Types\nDESCRIPTION: This code demonstrates the implementation of the ToString method for record types. It creates a StringBuilder, appends the record name and member values, and returns the resulting string.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic override string ToString();\n```\n\n----------------------------------------\n\nTITLE: Registering Construction Method with Attributes in C#\nDESCRIPTION: This code snippet demonstrates how to register a construction method for a collection type using custom attributes. It helps in linking the collection type to its construction method effectively.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-04-05.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionLiteralConstruction(typeof(ImmutableCollections), \"AsImmutableArray\")]\npublic struct ImmutableArray<T>\n{\n    // ...\n}\n\npublic static class ImmutableCollections\n{\n    public static ImmutableArray<T> AsImmutableArray<T>(T[] array)\n    {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Union Class as Abstract Record Class in C#\nDESCRIPTION: This code demonstrates the underlying implementation of a union class as an abstract record class with nested derived record classes for each member. The '[Closed]' attribute signifies that the type hierarchy is sealed outside the base type's module. The 'Singleton' property in the 'C' record demonstrates a singleton pattern for members without state variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[Closed]\nabstract record U \n{\n    public record A(int x, string y) : U;\n    public record B(int z) : U;\n    public record C : U { public static C Singleton = new C(); };\n}\n```\n\n----------------------------------------\n\nTITLE: Static Extension Methods with Different Return Types in C#\nDESCRIPTION: Example demonstrating how to define static extension methods with the same name but different return types for different receiver types, showing how they're differentiated in the implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class CollectionExtensions\n{\n    extension<T>(List<T>)\n    {\n        public static List<T> Create() { ... }\n    }\n    extension<T>(HashSet<T>)\n    {\n        public static HashSet<T> Create() { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Class Constraint Grammar in ANTLR\nDESCRIPTION: ANTLR grammar rule defining the syntax for the nullable class constraint using the 'class?' syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nprimary_constraint\n    : ...\n    | 'class' '?'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Creating a Safe Wrapper for Function Pointers in C#\nDESCRIPTION: This snippet shows how to create a safe wrapper around a function pointer. It encapsulates the unsafe delegate* in a struct, allowing it to be used in a safe context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe struct Action {\n    delegate*<void> _ptr;\n\n    Action(delegate*<void> ptr) => _ptr = ptr;\n    public void Invoke() => _ptr();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Argument Lifetime Mismatch in C#\nDESCRIPTION: This code snippet shows why method arguments must have matching lifetimes for ref struct parameters. It demonstrates a potential safety issue where a stackalloc'd Span could escape its scope through method invocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M1(ref Span<int> s1)\n{\n    Span<int> s2 = stackalloc int[1];\n    Swap(ref s1, ref s2);\n}\n\nvoid Swap(ref Span<int> x, ref Span<int> y)\n{\n    // This will effectively assign the stackalloc to the s1 parameter and allow it\n    // to escape to the caller of M1\n    ref x = ref y; \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Expression-Bodied Function Members in C# Class\nDESCRIPTION: Demonstrates the expression-bodied syntax for methods and properties in a Point class with a primary constructor. This concise syntax allows single-expression function members to be written more tersely using the => operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-11-04.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic class Point(int x, int y) {\n    public int X => x;\n    public int Y => y;\n    public double Dist => Math.Sqrt(x * x + y * y);\n    public Point Move(int dx, int dy) => new Point(x + dx, y + dy);\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguity Breaking Change Example in C#\nDESCRIPTION: Shows how C# 12 introduces compilation errors due to ambiguity in overload resolution between ref and in parameters where C# 11 would compile successfully.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar i = 5;\nSystem.Console.Write(C.M(null, ref i));\n\ninterface I1 { }\ninterface I2 { }\nstatic class C\n{\n    public static string M(I1 o, ref int x) => \"1\";\n    public static string M(I2 o, in int x) => \"2\";\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating End-of-Collection Indexing in C#\nDESCRIPTION: Shows two potential syntaxes for indexing from the end of a collection using the caret (^) or tilde (~) operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-14.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ncoll[^x]; // option 1, from end\ncoll[~x]; // option 2-3, from end\n```\n\n----------------------------------------\n\nTITLE: Using 'in' Parameters with Struct Types in C#\nDESCRIPTION: Demonstrates the restrictions on 'in' parameters in C#. The code shows that 'in' parameters are treated as readonly variables, preventing direct assignment or modification of their fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic Vector3 Add (in Vector3 v1, in Vector3 v2)\n{\n    // not OK!!\n    v1 = default(Vector3);\n\n    // not OK!!\n    v1.X = 0;\n\n    // not OK!!\n    foo(ref v1.X);\n\n    // OK\n    return new Vector3(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Is-As Pattern in C#\nDESCRIPTION: This snippet demonstrates how to replace the traditional 'as' and null check pattern with a more concise 'is' pattern in C#. It shows both the old and new approach for comparison.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar v = expr as Type;\nif (v != null) {\n    // code using v\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nif (expr is Type v) {\n    // code using v\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional vs Target-typed Pattern Matching in C#\nDESCRIPTION: Compares verbose traditional pattern matching with the new concise target-typed syntax in switch statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/target-typed-static-member-lookup.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M(Result<ImmutableArray<int>, string> result)\n{\n    switch (result)\n    {\n        case Result<ImmutableArray<int>, string>.Success(var array): ...\n        case Result<ImmutableArray<int>, string>.Error(var message): ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Field Initializer Behavior Example in C#\nDESCRIPTION: Code example demonstrating the behavior of field initializers in structs with explicit constructors. Shows the ambiguity between default initialization and field initializer execution when using parameterless constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-29.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Is this `default(S)`, or does `Field` have a value of 42?\nvar s = new S();\nSystem.Console.WriteLine(s.Field);\n\npublic struct S {\n    public int Field = 42;\n    \n    public S(int i)\n    {\n        // C# executes:\n        //     Field = 42\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Input/Output Type Inference in C#\nDESCRIPTION: Shows how input and output type inference works with dictionary expressions using generic methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\nstatic void InputType<T>(Dictionary<string, T> d);\nstatic void OutputType<T>(Dictionary<string, Func<T>> d);\n\nInputType([\"a\":1]);\nOutputType([\"b\":() => 2)]);\n```\n\n----------------------------------------\n\nTITLE: Main Method Generation Template in C#\nDESCRIPTION: Shows the basic template used to generate the Program class and Main method that wraps top-level statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npartial class Program\n{\n    static async Task Main(string[] args)\n    {\n        // statements\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unknown Length Collection Literal Example in C#\nDESCRIPTION: Demonstrates creation of an ImmutableArray from a collection literal with unknown length spread element.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_23\n\nLANGUAGE: c#\nCODE:\n```\nImmutableArray<int> x = [a, ..unknownLength.ToArray(), b];\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for 'with' Expression in C#\nDESCRIPTION: This ANTLR grammar snippet defines the syntax for the 'with' expression in C#, which is used for non-destructive mutation of record types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_9\n\nLANGUAGE: antlr\nCODE:\n```\nwith_expression\n    : switch_expression\n    | switch_expression 'with' '{' member_initializer_list? '}'\n    ;\n\nmember_initializer_list\n    : member_initializer (',' member_initializer)*\n    ;\n\nmember_initializer\n    : identifier '=' expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Using Method Groups with Optional Parameters in C# 12\nDESCRIPTION: Shows how to use method groups where the underlying method has optional parameters. The example demonstrates how to assign a method with an optional parameter to a variable and then call it with and without arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar addWithDefault = AddWithDefaultMethod;\naddWithDefault(); // 3\naddWithDefault(5); // 6\n\nint AddWithDefaultMethod(int addTo = 2) {\n  return addTo + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Abstract Interface Members - C#\nDESCRIPTION: The code details how static abstract interface members are implemented in classes. Using qualified names, explicit implementations of static members can be declared, thereby enforcing a complete version of the interface in the implementing types. The example shows a class `C` implementing interface `I` with various static abstract members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nclass C : I<C>\n{\n    string _s;\n    public C(string s) => _s = s;\n    static void I<C>.M() => Console.WriteLine(\"Implementation\");\n    static C I<C>.P { get; set; }\n    static event Action I<C>.E\n    {\n        add { ... }\n        remove { ... }\n    }\n    static C I<C>.operator +(C l, C r) => new C($\"{l._s} {r._s}\");\n    static bool I<C>.operator ==(C l, C r) => l._s == r._s;\n    static bool I<C>.operator !=(C l, C r) => l._s != r._s;\n    static implicit I<C>.operator C(string s) => new C(s);\n    static explicit I<C>.operator string(C c) => c._s;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructors and Required Members Contract Enforcement\nDESCRIPTION: This snippet illustrates how constructors in a class with required members must enforce initialization of those members during instantiation, outlining visibility and accessibility constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public required int Prop { get; protected init; }\n\n    // Advertises that Prop is required. This is fine, because the constructor is just as accessible as the property initer.\n    protected C() {}\n\n    // Error: ctor C(object) is more accessible than required property Prop.init.\n    public C(object otherArg) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Extension method example\nDESCRIPTION: This code demonstrates how type inference and applicability rules determine which extension method is used.  It illustrates the desired behavior when an extension method with a more specific type parameter is available.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"IEnumerable<string>.M();\\n\\nstatic class E\\n{\\n  extension(IEnumerable<object>)\\n  {\\n    public static void M() { }\\n  }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Legal Whitespace Examples\nDESCRIPTION: Shows two equivalent legal cases with different amounts of whitespace.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         Start\n<four spaces>\n         End\n         \"\"\";\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         Start\n<nine spaces>\n         End\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Defining Record Structs with Primary Constructors in C#\nDESCRIPTION: Demonstrates the difference between record structs with and without primary constructors. This example shows how primary constructor presence affects the ability to declare additional constructors with the same signature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nrecord struct R1\n{\n    public R1() { } // ok\n}\n\nrecord struct R2()\n{\n    public R2() { } // error: 'R2' already defines constructor with same parameter types\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Type Test Example in C#\nDESCRIPTION: Code example showing the traditional type test pattern versus the new pattern matching syntax in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar v = expr as Type;\nif (v != null) { // code using v\n```\n\nLANGUAGE: C#\nCODE:\n```\nif (expr is Type v) { // code using v\n```\n\n----------------------------------------\n\nTITLE: Enabling Object Initializer for Inline Arrays with Custom Indexer in C#\nDESCRIPTION: This example demonstrates how to enable object initializer syntax for inline arrays by explicitly defining a suitable indexer in the inline array type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nstatic C M2() => new C() { F = {[0] = 111} }; // Ok, indexer is invoked\n\nclass C\n{\n    public Buffer10<int> F;\n}\n\n[System.Runtime.CompilerServices.InlineArray(10)]\npublic struct Buffer10<T>\n{\n    private T _element0;\n\n    public T this[int i]\n    {\n        get => this[i];\n        set => this[i] = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Parameter and Member Declarations in C# Primary Constructors\nDESCRIPTION: Illustrates a potential syntax for allowing primary constructor parameters to also declare members on the type. This example shows how an access specifier on a parameter could trigger member generation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\npublic class C(bool b, protected int i, string s) : B(b) // i is a field as well as a parameter\n{\n    void M()\n    {\n        ... i ... // refers to the field i\n        ... s ... // closes over the parameter s\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Undesired Error with Conditional Access and Out Parameters in Switch Expression\nDESCRIPTION: This snippet illustrates an issue where an out parameter used within a conditional access operation leads to an undesired error when referenced in a switch expression pattern matching context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n_ = c?.M(out object obj4) switch\n{\n    not null => obj4.ToString() // undesired error\n};\n```\n\n----------------------------------------\n\nTITLE: Alternative Constraint Syntax Proposal in C#\nDESCRIPTION: This code snippet presents a proposed syntax for combining constraints and anti-constraints in C# to simplify type parameter usage in generics. The syntax uses \"where\" and \"allows\" in a single clause to specify both usual constraints and exceptional permissions on type parameters, potentially reducing complexity.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-01-22.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nwhere T : IEnumerable<T>, allows ref struct\n```\n\n----------------------------------------\n\nTITLE: Using Inline Array Element Access with Integer Indexing in C#\nDESCRIPTION: Demonstrates how to access elements in an inline array using integer indexing, showing different behaviors based on whether the array variable is writable, readonly, or a value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.InlineArray(10)]\npublic struct Buffer10<T>\n{\n    private T _element0;\n}\n\nvoid M1(Buffer10<int> x)\n{\n    ref int a = ref x[0]; // Ok, equivalent to `ref int a = ref InlineArrayAsSpan<Buffer10<int>, int>(ref x, 10)[0]`\n}\n\nvoid M2(in Buffer10<int> x)\n{\n    ref readonly int a = ref x[0]; // Ok, equivalent to `ref readonly int a = ref InlineArrayAsReadOnlySpan<Buffer10<int>, int>(in x, 10)[0]`\n    ref int b = ref x[0]; // An error, `x` is a readonly variable => `x[0]` is a readonly variable\n}\n\nBuffer10<int> GetBuffer() => default;\n\nvoid M3()\n{\n    int a = GetBuffer()[0]; // Ok, equivalent to `int a = InlineArrayAsReadOnlySpan<Buffer10<int>, int>(GetBuffer(), 10)[0]` \n    ref readonly int b = ref GetBuffer()[0]; // An error, `GetBuffer()[0]` is a value\n    ref int c = ref GetBuffer()[0]; // An error, `GetBuffer()[0]` is a value\n}\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with ref readonly Parameters\nDESCRIPTION: Demonstrates ambiguity resolution between different parameter modifier combinations (ref, in, ref readonly) in method overloads.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1 { }\ninterface I2 { }\nclass C\n{\n    static string M(I1 o, in int i) => \"1\";\n    static string M(I2 o, ref readonly int i) => \"2\";\n    static void Main()\n    {\n        int i = 5;\n        System.Console.Write(M(null, ref i));\n        System.Console.Write(M(null, in i));\n        System.Console.Write(M(null, i));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Collection Expressions in Implicitly-Typed Scenarios in C#\nDESCRIPTION: Examples of using collection expressions in implicitly-typed scenarios where the collection type is observable, such as var declarations, extension methods, and type inference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-inferred-type.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar a = [x, y];                       // var\nvar b = [x, y].Where(e => e != null); // extension methods\nvar c = Identity([x, y]);             // type inference: T Identity<T>(T)\n```\n\n----------------------------------------\n\nTITLE: Defining a Record Class with Caller-Receiver Parameters in C#\nDESCRIPTION: Demonstrates how to declare a Point class as a record with caller-receiver parameters for the With method. This allows creating new instances with modified values easily.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass Point\n{\n    public readonly int X;\n    public readonly int Y;\n    public Point With(int x = this.X, int y = this.Y) => new Point(x, y);\n    // etc\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Span Scope and Allocation Behavior in C#\nDESCRIPTION: This code snippet illustrates various scenarios of using collection expressions with spans, demonstrating differences in scope and allocation behavior across different target frameworks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nReadOnlySpan<int> A()\n{\n    ReadOnlySpan<int> x = [GetInt(), GetInt(), GetInt()];\n\n    // Always illegal on any framework.  'x' has local scope.\n    return x;\n}\n\nReadOnlySpan<int> B()\n{\n    ReadOnlySpan<int> x = [1, 2, 3];\n\n    // Always legal.  'x' has global scope due to being a ReadOnlySpan of constant blittable data.\n    return x;\n}\n\nvoid C()\n{\n    // Stack allocated (using Inline-Array on Net8 and up)\n    //\n    // Heap allocated (using an int[] on Net7 and below).  Will warn in that event.\n    ReadOnlySpan<X> x = [Get(), Get(), Get()];\n}\n\nvoid D()\n{\n    // Temporary ReadOnlySpan<int> is stack allocated (using Inline-Array on Net8 and up)\n    //\n    // Temporary ReadOnlySpan<int> is heap allocated (using an int[] on Net7 and below).  Will warn in that event.\n    ImmutableList<X> x = [Get(), Get(), Get()];\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Query Translation Using Null\nDESCRIPTION: Improved translation approach using null to represent failure cases, resulting in cleaner and more efficient code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nstrings\n\t.Select(s => int.TryParse(s, out int i) ? new { s, i } : null)\n\t.Where(__p => __p != null)\n\t.Select(__p => __p.i);\n```\n\n----------------------------------------\n\nTITLE: Readonly Property Implementation Examples\nDESCRIPTION: Demonstrates various ways to implement readonly properties including accessor-level readonly modifiers and auto-implemented properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/readonly-instance-members.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic readonly int Prop1\n{\n    get\n    {\n        return this._store[\"Prop1\"];\n    }\n    set\n    {\n        this._store[\"Prop1\"] = value;\n    }\n}\n\npublic readonly int Prop2\n{\n    get\n    {\n        return this._store[\"Prop2\"];\n    }\n    set\n    {\n        this._store[\"Prop2\"] = value;\n    }\n}\n\npublic int Prop3\n{\n    readonly get\n    {\n        return this._prop3;\n    }\n    set\n    {\n        this._prop3 = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Left Join Query Expression Example\nDESCRIPTION: Demonstrates the proposed left join syntax in a LINQ query expression to join students with departments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nfrom student in students\nleft join department in departments on student.DepartmentID equals department.ID\nselect new { student.Name, department?.Name }\n```\n\n----------------------------------------\n\nTITLE: Lambda Type Inference Examples in C#\nDESCRIPTION: Code examples demonstrating different scenarios of lambda expression type inference in unconstrained contexts, including var declaration, generic type parameters, and object conversion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-05-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar a = (int x) => x; // What is the type of A?\n\nvoid M1<T>(T t);\nM1((int x) => x); // What is the type of T?\n\nvoid M2(object o);\nM2((int x) => x); // What is the type of the expression? ie, o.GetType() returns what?\n```\n\n----------------------------------------\n\nTITLE: Dictionary Custom Comparer Extension Method in C#\nDESCRIPTION: This code shows an extension method `AsDictionary` for creating a `Dictionary` with a custom comparer from a `List<KeyValuePair<TKey, TValue>>`.  This addresses the limitation of collection literal syntax not allowing for a custom comparer.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nd = [\"Alice\": 42, \"Bob\": 43].AsDictionary(comparer);\n\nstatic class Extensions\n{\n    public static Dictionary<TKey, TValue> AsDictionary<\nTKey, TValue>(\n        this List<KeyValuePair<TKey, TValue>> list,\n        IEqualityComparer<TKey> comparer = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Async Main Feature\nDESCRIPTION: Demonstrates how the proposed async Main feature can be used to directly perform HTTP operations with await syntax in the entrypoint method without additional boilerplate.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/async-main.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Net.Http;\n\nclass Test\n{\n    static async Task Main(string[] args) =>\n\t    Console.WriteLine(await new HttpClient().GetStringAsync(args[0]));\n}\n```\n\n----------------------------------------\n\nTITLE: Using Statement Nesting Example - C#\nDESCRIPTION: Demonstrates common syntax for nesting multiple using statements to avoid excessive indentation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-09.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n{\n    using (expr1)\n    using (expr2)\n    using (expr3)\n    { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Class Constructor Pattern in C#\nDESCRIPTION: Example showing traditional verbose constructor pattern for a Point class with immutable properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-15.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point\n{\n    public int X { get; }\n    public int Y { get; }\n    public Point(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Constructor Behavior in C#\nDESCRIPTION: Demonstrates the behavior of struct constructors with field initializers. If no explicit constructor is declared, one will be synthesized to run field initializers. If an explicit constructor is declared, no synthesis occurs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-28.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstruct S\n{\n    int field = 42; // Field initializer\n\n    // No explicit constructor - synthesized constructor will run field initializer\n}\n\nstruct T\n{\n    int field = 42; // Field initializer\n\n    public T(int value) { } // Explicit constructor - no synthesis, field initializer not run by default\n}\n```\n\n----------------------------------------\n\nTITLE: LINQ Query with Nullable Types and `Where` Clause\nDESCRIPTION: This C# code snippet demonstrates a common LINQ usage scenario where a collection of nullable strings is filtered and then parsed into a `Widget` object.  The compiler issues a false warning when calling `Widget.Parse(i)` because it doesn't recognize that the `Where` clause guarantees `i` is not null. The `Widget` class contains a static `Parse` method that accepts a non-nullable string.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<Widget> M(IEnumerable<string?> items)\n{\n    return items\n        .Where(i => i != null)\n        .Select(i => Widget.Parse(i)); // false warning: converting 'i' to non-nullable\n}\n\nclass Widget\n{\n    public static Widget Parse(string item) => throw null!;\n}\n```\n\n----------------------------------------\n\nTITLE: Using With-Expression on a Record Class in C#\nDESCRIPTION: Shows how to use the With method on a Point record to create a new instance with a modified X value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nPoint p = new Point(3, 4);\np = p.With(x: 1);\n```\n\n----------------------------------------\n\nTITLE: Basic Init Usage Example\nDESCRIPTION: Demonstration of using init-only properties with object initializer syntax for object creation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass Student\n{\n    public string FirstName { get; init; }\n    public string LastName { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Nullable Reference with Conditional Validation\nDESCRIPTION: Demonstrates a valid definite assignment scenario with null check and method call with out parameter\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n\nC c = new C();\nif (c != null && c.M(out object obj0))\n{\n    obj0.ToString(); // ok\n}\n\npublic class C\n{\n    public bool M(out object obj)\n    {\n        obj = new object();\n        return true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation with Partial Methods in C#\nDESCRIPTION: Shows how partial methods can be used to implement interface members and virtual methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IStudent\n{\n    string GetName();\n}\n\npartial class C : IStudent\n{\n    public virtual partial string GetName(); \n}\n\npartial class C\n{\n    public virtual partial string GetName() => \"Jarde\";\n}\n```\n\n----------------------------------------\n\nTITLE: Property Pattern Syntax Modification - C#\nDESCRIPTION: This code snippet illustrates the updated grammar rules for defining property patterns in C#. It specifies the changes that enable referencing nested members directly, which simplifies the structure needed for property pattern clauses.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/extended-property-patterns.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nproperty_pattern\n  : type? property_pattern_clause simple_designation?\n  ;\n```\n\nLANGUAGE: csharp\nCODE:\n```\nproperty_pattern_clause\n  : '{' (subpattern (',' subpattern)* ','?)? '}';\n```\n\nLANGUAGE: csharp\nCODE:\n```\nsubpattern\n- : identifier ':' pattern\n+ : subpattern_name ':' pattern\n  ;\n```\n\nLANGUAGE: csharp\nCODE:\n```\n+subpattern_name\n+ : identifier \n+ | subpattern_name '.' identifier\n+ ;\n```\n\n----------------------------------------\n\nTITLE: Params Span Alignment for Collection Literals in C#\nDESCRIPTION: This code demonstrates the desired behavior of collection literals when used with `params ReadOnlySpan<int>`. The goal is for the collection literal `[1, 2, 3, 4]` to be treated the same as passing individual arguments `1, 2, 3, 4` when the method expects a `ReadOnlySpan<int>`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-21.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(params ReadOnlySpan<int> values);\nM(1, 2, 3, 4);   // as params span\nM([1, 2, 3, 4]); // as direct span\n```\n\n----------------------------------------\n\nTITLE: Creating Dictionaries with Various Element Types in C#\nDESCRIPTION: Examples of creating dictionaries using different element types, including existing key-value pairs, other dictionaries, and mixed elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nDictionary<string, int> d1 = [existingKvp];\nDictionary<string, int> d2 = [.. otherDict];\nDictionary<string, int> nameToAge = [\"mads\": 21, .. existingListOfKVPS];\n```\n\n----------------------------------------\n\nTITLE: Safe Stack Allocation translation example in C#\nDESCRIPTION: This code snippet demonstrates a safer way to handle stack allocation for collection literals within a loop.  It uses a pre-allocated stack buffer and assigns its elements in each iteration to avoid stack growth. This approach is more desirable by avoiding unbounded stack growth.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-21.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> __buffer = stackalloc int[3];\nforeach (...)\n{\n    __buffer[0] = GetA();\n    __buffer[1] = GetB();\n    __buffer[2] = GetC();\n    Span<int> values = __buffer;\n    // do things with span.  It would likely be appropriate to clear __buffer when the scope ends.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Constants Using String Literal\nDESCRIPTION: This code snippet demonstrates the definition of constant strings using traditional concatenation. It showcases how constants are typically defined in C#. The snippet does not require any specific dependencies other than the standard C# library.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/constant_interpolated_strings.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    const string S1 = \"Hello world\";\n    const string S2 = \"Hello\" + \" \" + \"World\";\n    const string S3 = S1 + \" Kevin, welcome to the team!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Basic Types in C#\nDESCRIPTION: Demonstrates pattern matching syntax for basic type checking and value extraction using the 'is' operator and switch statements. Shows how patterns can be used with different types including strings, integers and custom types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nif (o is Point(var x, 5)) ...\nif (o is Point(*, 5) p) Console.WriteLine(o.x);\nif (o is Point p) Console.WriteLine(p.x);\nif (p is (var x, 5) ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String to UTF-8 Conversion Example\nDESCRIPTION: Shows the conversion syntax from string literal to byte array using the u8 suffix, which can be either lowercase or uppercase.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-26.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n\"example\"u8  // Returns byte[]\n\"example\"U8  // Also valid\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Logical Operators in C#\nDESCRIPTION: This snippet establishes logical operators for nint and nuint types, enabling bitwise operations such as AND, OR, and XOR. The operators interact with two nint or nuint values and return the result of the logical operation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nnint operator &(nint x, nint y);\n    nuint operator &(nuint x, nuint y);\n    nint operator |(nint x, nint y);\n    nuint operator |(nuint x, nuint y);\n    nint operator ^(nint x, nint y);\n    nuint operator ^(nuint x, nuint y);\n```\n\n----------------------------------------\n\nTITLE: New() and Struct Constraints with Generic Types in C#\nDESCRIPTION: These snippets demonstrate that calling `new S()` on a struct with a constructor, but without a parameterless one, will not trigger a warning. Also, when using such a struct type for a type parameter with a `new()` or `struct` constraint, no warning is reported.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n\"struct S { public S(int i) { } }\\nstatic T CreateNew<T>() where T : new() => new T();\\n\\n_ = new S();        // no warning called\\n_ = CreateNew<S>(); // ok\"\n```\n\n----------------------------------------\n\nTITLE: Consuming IAsyncEnumerator Pattern in C#\nDESCRIPTION: Example implementation showing how to consume an async enumerator using WaitForNextAsync and TryGetNext methods with proper disposal handling.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nIAsyncEnumerator<T> enumerator = enumerable.GetAsyncEnumerator();\ntry\n{\n    while (await enumerator.WaitForNextAsync())\n    {\n        while (true)\n        {\n            int item = enumerator.TryGetNext(out bool success);\n            if (!success) break;\n            Use(item);\n        }\n    }\n}\nfinally { await enumerator.DisposeAsync(); }\n```\n\n----------------------------------------\n\nTITLE: Tuple Name Inference in Deconstruction Assignment in C#\nDESCRIPTION: Shows how tuple element names are inferred during deconstruction assignment operations, where the names 'f1' and 'f2' are inferred from the left-hand expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/infer-tuple-names.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// tuple has element names \"f1\" and \"f2\" \nvar tuple = ((x.f1, x?.f2) = (1, 2));\n```\n\n----------------------------------------\n\nTITLE: Forward Inference of Element Type\nDESCRIPTION: This C# code snippet demonstrates the concept of forward inference for the element type of a collection literal. The compiler infers the element type of the collection to be `int` by looking forward to the `Add` call. This allows users to use `var` instead of explicitly specifying the element type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-05-10.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Infers the element type to be 'int' by looking forward\n// to the Add call.\nvar collection = [];\ncollection.Add(1);\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Argument Conversion Examples\nDESCRIPTION: Examples demonstrating ambiguity and type inference with collection expression arguments when converting to different collection types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nPrint([with(comparer: null), 1, 2, 3]); // ambiguous or Print<int>(HashSet<int>)?\n\nstatic void Print<T>(List<T> list) { ... }\nstatic void Print<T>(HashSet<T> set) { ... }\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation Inheritance Patterns\nDESCRIPTION: Demonstrates different patterns of interface implementation including explicit implementation and method hiding in derived interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M() { WriteLine(\"IA.M\"); }\n}\ninterface IB : IA\n{\n    void IA.M() { WriteLine(\"IB.M\"); } // Explicit implementation\n}\ninterface IC : IA\n{\n    void M() { WriteLine(\"IC.M\"); } // Creates a new M, unrelated to `IA.M`. Warning\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Methods with MaybeNull Return Annotation in C#\nDESCRIPTION: Example showing how MaybeNull attribute can be used to annotate generic method return types, demonstrating the difference between FirstOrDefault (which may return null) and Identity (which preserves the input type).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-24.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Enumerable\n{\n    [return: MaybeNull]\n    public static T FirstOrDefault<T>(this IEnumerable<T> src) {...}\n\n    public static T Identity<T>(T t) => t;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Discards in C# for Out Parameters, Deconstruction, and Pattern Matching\nDESCRIPTION: This snippet shows various uses of discards in C#, including out parameters, deconstruction, and pattern matching. Discards are represented by '_' and are used when a value is not needed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-15.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nM(out _, out var _, out int _); // three out variable discards\n(_, var _, int _) = GetCoordinates(); // deconstruction into discards\nif (x is var _ && y is int _) { ... } // discards in patterns\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Readonly Struct in C#\nDESCRIPTION: Demonstrates declaring a readonly struct Vector3 and using it in a method. The readonly modifier makes the struct's this parameter an in parameter for all instance methods except constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Test(in Vector3 v1)\n{\n    // no need to make a copy of v1 since Vector3 is a readonly struct\n    System.Console.WriteLine(v1.ToString());\n}\n\nreadonly struct Vector3\n{\n    . . .\n\n    public override string ToString()\n    {\n        // not OK!!  `this` is an `in` parameter\n        foo(ref this.X);\n\n        // OK\n        return $\"X: {X}, Y: {Y}, Z: {Z}\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Indentation Removal in Raw String Literals in C#\nDESCRIPTION: Demonstrates how to preserve leading whitespace by aligning the closing delimiter with the start of the content.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar xml = \"\"\"\n          <element attr=\"content\">\n            <body>\n            </body>\n          </element>\n\"\"\";\n```\n\n----------------------------------------\n\nTITLE: Global Using Directive in C# 10.0\nDESCRIPTION: Demonstrates the new global using directive that allows sharing using statements across multiple files.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nglobal using\n```\n\n----------------------------------------\n\nTITLE: Introducing ref readonly Method Parameters in C#\nDESCRIPTION: New feature allowing ref readonly parameters as a middle ground between ref and in parameters. This prevents rvalue parameters while allowing both ref and in at callsites, with ref usage producing a warning.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-25.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid Method(ref readonly Parameter p) // New syntax for ref readonly parameters\n// Usage:\nMethod(ref variable);     // Works with warning\nMethod(in variable);      // Preferred syntax\nMethod(rvalue);          // Error - rvalues not allowed\n```\n\n----------------------------------------\n\nTITLE: Property Pattern Access in C# 10.0\nDESCRIPTION: Shows extended property pattern syntax for accessing nested members in pattern matching expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nif (e is MethodCallExpression { Method.Name: \"MethodName\" })\n```\n\n----------------------------------------\n\nTITLE: LINQ Extension Methods for IAsyncEnumerable\nDESCRIPTION: Example of LINQ extension method signatures for IAsyncEnumerable<T>, showing Select and Where implementations that support async operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic static IAsyncEnumerable<TResult> Select<TSource, TResult>(this IAsyncEnumerable<TSource> source, Func<TSource, TResult> func);\npublic static IAsyncEnumerable<T> Where(this IAsyncEnumerable<T> source, Func<T, bool> func);\n```\n\n----------------------------------------\n\nTITLE: Using Lambda Parameters with Optional Values in Web Application Endpoints\nDESCRIPTION: Demonstrates a practical use case for optional parameters in lambdas when defining web API endpoints. This example shows how to provide a default value for a task parameter in a web application route handler.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar app = WebApplication.Create(args);\n\napp.MapPost(\"/todos/{id}\", (TodoService todoService, int id, string task = \"foo\") => {\n  var todo = todoService.Create(id, task);\n  return Results.Created(todo);\n});\n```\n\n----------------------------------------\n\nTITLE: Cancellation Token Usage with IAsyncEnumerable in C#\nDESCRIPTION: Example showing how cancellation tokens work with IAsyncEnumerable, demonstrating the current limitation that tokens must be passed manually to the iterator method and cannot be passed during the await foreach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-19.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar iasyncenum = IterMethod(token);\nawait foreach (var x in iasyncenum)\n{\n    ...\n}\n\nIAsyncEnumerable<int> IterMethod(CancellationToken token)\n{\n    yield return 0;\n    token.ThrowIfCancelled();\n    await Task.Delay(1);\n    yield return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Foreach Statements Using Span Types for Inline Arrays in C#\nDESCRIPTION: This code demonstrates the equivalent foreach statements using Span and ReadOnlySpan types for inline arrays, which is how the compiler interprets the previous example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nBuffer10<int> temp = getBufferAsValue();\nforeach (var a in (System.ReadOnlySpan<int>)temp)\n{\n    WriteLine(a);\n}\n\nforeach (var b in (System.Span<int>)getBufferAsWritableVariable())\n{\n    WriteLine(b);\n}\n\nforeach (var c in (System.ReadOnlySpan<int>)getBufferAsReadonlyVariable())\n{\n    WriteLine(c);\n}\n```\n\n----------------------------------------\n\nTITLE: Lowering of UTF-8 Literals\nDESCRIPTION: This code illustrates how the compiler will lower UTF-8 literals to a `ReadOnlySpan<byte>` constructed from a `byte[]` literal. It also shows how multiple consecutive concatenations are optimized into a single creation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n\"ReadOnlySpan<byte> span = \\\"hello\\\"u8;\n\n// Equivalent to\n\nReadOnlySpan<byte> span = new ReadOnlySpan<byte>(new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00 }).\n                               Slice(0,5); // The `Slice` call will be optimized away by the compiler.\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\n\"ReadOnlySpan<byte> span = \\\"h\\\"u8 + \\\"el\\\"u8 + \\\"lo\\\"u8;\n\n// Equivalent to\n\nReadOnlySpan<byte> span = new ReadOnlySpan<byte>(new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00 }).\n                               Slice(0,5); // The `Slice` call will be optimized away by the compiler.\"\n```\n\n----------------------------------------\n\nTITLE: Using ModuleInitializer Attribute in C#\nDESCRIPTION: Demonstrates how to apply the ModuleInitializer attribute to a static method. The method must be static, parameterless, return void, and have internal or public accessibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/module-initializers.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Runtime.CompilerServices;\nclass C\n{\n    [ModuleInitializer]\n    internal static void M1()\n    {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Validating ref fields for null using runtime helpers in C#\nDESCRIPTION: This code demonstrates how to validate a `ref` field to prevent `NullReferenceException`. The `System.Runtime.CompilerServices.Unsafe.IsNullRef` method is used to check if the `ref` field is null. If so, an `InvalidOperationException` is thrown, ensuring the `struct` is used correctly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n```c#\nref struct S1 \n{\n    private ref int Value;\n\n    public int GetValue()\n    {\n        if (System.Runtime.CompilerServices.Unsafe.IsNullRef(ref Value))\n        {\n            throw new InvalidOperationException(...);\n        }\n\n        return Value;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution Priority Attribute\nDESCRIPTION: System.Runtime.CompilerServices.OverloadResolutionPriority attribute implementation with Inherited=false property, looking at least-derived member definition for priority.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-13.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[System.Runtime.CompilerServices.OverloadResolutionPriority]\n```\n\n----------------------------------------\n\nTITLE: Deconstructing a Union Class Member in C#\nDESCRIPTION: This demonstrates how to deconstruct a union class member using type tests and pattern matching. The first 'if' statement checks if 'u' is of type 'A' and assigns it to a variable 'a'. The second 'if' uses pattern matching to directly extract the values of 'x' and 'y' from 'A'. The third 'if' uses property pattern matching to extract the value of the property 'y' from A.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nif (u is A a) { ... }\n\nif (u is A(var x, var y)) { ... }\n\nif (u is A { y: var y }) { ... }\n```\n\n----------------------------------------\n\nTITLE: Parameterless Constructors and Field Initialization in C#\nDESCRIPTION: This example demonstrates field initialization when using a parameterless constructor within a `record struct`. It showcases how properties can be initialized even when using the default constructor, providing flexibility in struct instantiation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"record struct Person()\\n{\\n    public string Name { get; init; }\\n    public object Id { get; init; } = GetNextId();\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Top-level Statements Original Syntax Example\nDESCRIPTION: Example showing the simplified top-level statement syntax in C# that allows direct console output and method definition without explicit class declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-07-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nConsole.WriteLine(GetInt());\n\nstatic int GetInt() => 1;\n```\n\n----------------------------------------\n\nTITLE: Initializing Span Types with Collection Literal in C#\nDESCRIPTION: Demonstration of initializing Span<T> types using collection literals, with notes on compiler heuristics for stack allocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> values = [1, 2, 3]; // equivalent to either:\n\nSpan<int> values = new int[] { 1, 2, 3 }; // or\nSpan<int> values = stackalloc int[] { 1, 2, 3 };\n```\n\n----------------------------------------\n\nTITLE: Foreach Statement with Ref Struct IEnumerable Implementation\nDESCRIPTION: Shows how foreach statement works with a ref struct implementing IEnumerable<T> interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S : IEnumerable<int>\n{\n    IEnumerator<int> IEnumerable<int>.GetEnumerator() {...}\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {...}\n}\n\nclass C\n{\n    static void Main()\n    {\n        foreach (var i in new S()) // IEnumerable<int>.GetEnumerator\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Expression Variables in Constructor Initializer (C#)\nDESCRIPTION: Demonstrates the proposed scoping of an expression variable introduced in a base constructor initializer. The variable 'x' is intended to be in scope for the entire constructor, including the body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-03.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nC(int i) : base(out var x) { ... x ... }\n```\n\n----------------------------------------\n\nTITLE: Collection Literal Example in C#\nDESCRIPTION: Example showing proposed collection literal syntax for creating a HashSet\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-11-01.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nHashSet<int> h = [1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Base Interface Invocation Syntax (Explicit Form)\nDESCRIPTION: Demonstrates the full syntax for base interface invocations where both the interface containing the method declaration and the implementation location must be specified. This allows for invoking different implementations of the same method from multiple parent interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1 { void M(); }\ninterface I2 { void M(); }\ninterface I3 : I1, I2 { void I1.M() { } void I2.M() { } }\ninterface I4 : I1, I2 { void I1.M() { } void I2.M() { } }\ninterface I5 : I3, I4\n{\n    void I1.M()\n    {\n        base<I3>(I1).M(); // calls I3's implementation of I1.M\n        base<I4>(I1).M(); // calls I4's implementation of I1.M\n    }\n    void I2.M()\n    {\n        base<I3>(I2).M(); // calls I3's implementation of I2.M\n        base<I4>(I2).M(); // calls I4's implementation of I2.M\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CallerInfo Structure for Debugging in C#\nDESCRIPTION: This snippet defines a `CallerInfo` struct that encapsulates caller information for debugging purposes, including the caller's file path, method, and argument expressions. It is used within a static class to improve logging and assertion functionality.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nstruct CallerInfo\n{\n    public string MemberName { get; set; }\n    public string TypeName { get; set; }\n    public string Namespace { get; set; }\n    public string FullTypeName { get; set; }\n    public string FilePath { get; set; }\n    public int LineNumber { get; set; }\n    public int ColumnNumber { get; set; }\n    public Type Type { get; set; }\n    public MethodBase Method { get; set; }\n    public string[] ArgumentExpressions { get; set; }\n}\n\n[Flags]\nenum CallerInfoOptions\n{\n    MemberName = 1, TypeName = 2, ...\n}\n\npublic static class Debug\n{\n    public static void Assert(bool condition,\n        [CallerInfo(CallerInfoOptions.FilePath | CallerInfoOptions.Method | CallerInfoOptions.ArgumentExpressions)] CallerInfo callerInfo = default(CallerInfo))\n    {\n        string filePath = callerInfo.FilePath;\n        MethodBase method = callerInfo.Method;\n        string conditionExpression = callerInfo.ArgumentExpressions[0];\n        //...\n    }\n}\n\nclass Bar\n{\n    void Foo()\n    {\n        Debug.Assert(false);\n\n        // Translates to:\n\n        var callerInfo = new CallerInfo();\n        callerInfo.FilePath = @\"C:\\Bar.cs\";\n        callerInfo.Method = MethodBase.GetCurrentMethod();\n        callerInfo.ArgumentExpressions = new string[] { \"false\" };\n        Debug.Assert(false, callerInfo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Primary Constructor Bodies in C#\nDESCRIPTION: Shows how primary constructors could be extended to allow statement blocks directly in the class body. These statements would be executed interspersed with initializers in the generated constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\npublic class C(int i, string s) : B(s)\n{\n    {\n        if (i < 0) throw new ArgumentOutOfRangeException(nameof(i));\n    }\n\tint[] a = new int[i];\n    public int S => s;\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Operator Declaration Rules in C#\nDESCRIPTION: This snippet illustrates various rules and constraints for declaring extension operators, including type compatibility, pair-wise declarations, and restrictions on modifiers and signatures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-operators.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Operators\n{\n    extension(int[])\n    {\n        public static int[] operator +(int[] vector, int scalar) { ... }    // OK; parameter and extended type agree\n        public static int operator +(int scalar1, int scalar2) { ... }      // ERROR: extended type not used as parameter type\n                                                                            // and ERROR: same signature as predefined +(int, int)\n        public static bool operator ==(int[] vector1, int[] vector2){ ... } // ERROR: '!=' declaration missing\n        public static bool operator <(int[] vector1, int[] vector2){ ... }  // OK: `>` is declared below\n    }\n    extension(int[])\n    {\n        public static bool operator >(int[] vector1, int[] vector2){ ... }  // OK: `<` is declared above\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversions from Function Types to Base Types\nDESCRIPTION: This example demonstrates implicit conversions from anonymous functions and method groups to System.MulticastDelegate, System.Linq.Expressions.Expression, and object. These conversions realize the function as an appropriate delegate type or expression tree.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nDelegate d = delegate (object obj) { }; // Action<object>\nExpression e = () => \"\";                // Expression<Func<string>>\nobject o = \"\".Clone;                    // Func<object>\n```\n\n----------------------------------------\n\nTITLE: Fixed Buffer Local Variable Example in C#\nDESCRIPTION: Example showing potential syntax for fixed buffer local variables compared to stackalloc. This demonstrates how fixed buffers could be used as an alternative to stackalloc operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\nclass FixedBufferLocals\n{\n    void Example()\n    {\n        Span<int> span = stackalloc int[42];\n        int buffer[42];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Extension Declarations in C# with Generic Type Inference\nDESCRIPTION: This snippet shows how extension declarations are consumed, demonstrating both extension invocation and static method invocation with and without explicit type arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nstring[] strings = ...;\n\nvar query = strings.Select(s => s.Length); // extension invocation\nvar query2 = strings.Select<string, int>(s => s.Length); // ... with explicit full set of type arguments\n\nvar query3 = Enumerable.Select(strings, s => s.Length); // static method invocation\nvar query4 = Enumerable.Where<string, int>(strings, s => s.Length); // ... with explicit full set of type arguments\n \npublic static class Enumerable\n{\n    extension<TSource>(IEnumerable<TSource> source)\n    {\n        public IEnumerable<TResult> Select<TResult>(Func<T, TResult> predicate) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Uninitialized Values and Definite Assignment in C#\nDESCRIPTION: These examples show that a local or field of a struct type that is not explicitly initialized is zeroed. The compiler reports a definite assignment error for an uninitialized struct that is not empty. The behavior remains unchanged from C# 9.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n\"NoConstructor s1;\\nPublicConstructor s2;\\ns1.ToString(); // error: use of unassigned local (unless type is empty)\\ns2.ToString(); // error: use of unassigned local (unless type is empty)\"\n```\n\n----------------------------------------\n\nTITLE: Simple Record Point Class Example\nDESCRIPTION: Example of a basic record class declaration for a Point type with X and Y coordinates.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Initializing List with Dictionary Elements - C#\nDESCRIPTION: This code snippet demonstrates the initialization of a List using dictionary-like syntax in C#. The code illustrates the proposal for supporting a collection literal syntax that combines indexing with key-value pairs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-14.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nList<string> list = [0: \"first\", 1: \"second\"];\n```\n\n----------------------------------------\n\nTITLE: Interpolated Raw String Literal in C#\nDESCRIPTION: Demonstrates how to create an interpolated raw string literal with custom interpolation delimiters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar json = $$\"\"\"\n             {\n                \"summary\": \"text\",\n                \"length\" : {{value.Length}},\n             };\n             \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Implementing Expression Derivative Calculation in C#\nDESCRIPTION: This function uses pattern matching to compute the derivative of an expression represented by the previously defined recursive types. It demonstrates switch expression pattern matching in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nExpr Deriv(Expr e)\n{\n  switch (e) {\n    case X(): return Const(1);\n    case Const(*): return Const(0);\n    case Add(var Left, var Right):\n      return Add(Deriv(Left), Deriv(Right));\n    case Mult(var Left, var Right):\n      return Add(Mult(Deriv(Left), Right), Mult(Left, Deriv(Right)));\n    case Neg(var Value):\n      return Neg(Deriv(Value));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Switch Expression with Union Class in C#\nDESCRIPTION: This code illustrates the use of a switch expression to handle all possible members of the union class 'U'. Because the union is exhaustive (all members are accounted for), no default case is needed. The code assigns a value to 'x' based on the type of 'u' and the corresponding member's state variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = u switch { \n    A a => a.x,\n    B b => b.z,\n    C c => 0\n    };\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Modern Extension Syntax in C#\nDESCRIPTION: This snippet showcases the proposed syntax for modern extensions, including various member types like methods, properties, events, indexers, operators, and constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nextension E\n{\n    // Instance method form, replaces `public static int M<X>(this SomeType<X> val, ...) { } \n    public int M<X>(...) for SomeType<X> val { }\n\n    // Property form:\n    // Auto-properties, or usage of 'field' not allowed as extensions do not have instance state.\n    public int Count<X> for SomeType<X> val { get { ... } }\n\n    // Event form:\n    // Note: would have to be the add/remove form.\n    // field-backed events would not be possible as extensions do not have instance state.\n    public event Action E<X> for SomeType<X> val { add { } remove { } }\n\n    // Indexer form:\n    public int this<T>[int index] for SomeType<X> val { get { ... } }\n\n    // Operator form:\n    // note: no SomeType<X> val, an operator is static, so it is not passed an instance value.\n    public static SomeTypeX<X> operator+ <X>(SomeType<X> s1, SomeType<X> s2) for SomeType<X> { ... }\n    \n    // Conversion form:\n    // note: no SomeType<X> val, an operator is static, so it is not passed an instance value.\n    public static implicit operator SomeTypeX<X>(int i) for SomeType<X> { ... }\n\n    // Constructor form:\n    // note: no SomeType<X> val, an operator is static, so it is not passed an instance value.\n    public SomeType<X>() for SomeType<X> { }\n\n    // *Static* extension method (not possible today).  Called as `Assert.Boo(\"\", \"\")`\n    // note: no `Assert val`, a static method is not passed an instance value.\n    public static bool Boo(string s1, string s2) for Assert { }\n\n    // Static extensions properties, indexers and events are all conceptually supportable.\n    // Though we can decide which are sensible to have or not.\n    // Static extensions can having backing static fields. Static extension properties can use `field`.\n    \n    // Nested types must be supported to maintain compatibility with existing static classes with extension members in them.\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Interpolated Raw String Literals in C#\nDESCRIPTION: This snippet shows how to use interpolated raw string literals to create a JSON string with an interpolation hole. The double dollar signs ($$) indicate that double braces are needed for interpolations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvar v1 = $$\"\"\"\n         {\n            \"orders\": \n            [\n                { \"number\": {{order_number}} }\n            ]\n         }\n         \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Declarations with Various Member Types in C#\nDESCRIPTION: Example showing how to define extension declarations for IEnumerable<T> and IAsyncEnumerable<int> with instance and static members including methods and properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class IEnumerableExtensions\n{\n    extension<T>(IEnumerable<T> source)\n    {\n        public void Method() { ... }\n        internal static int Property { get => ...; set => ...; }\n        public int Property2 { get => ...; set => ...; }\n    }\n\n    extension(IAsyncEnumerable<int> values)\n    {\n        public async Task<int> SumAsync() { ... }\n    }\n\n    public static void Method2() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing HashSet with Collection Literal in C#\nDESCRIPTION: Example of initializing a HashSet<T> using a collection literal, demonstrating equivalence to traditional collection initializer syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nHashSet<int> set = [1, 2, 3]; // equivalent to:\n\nHashSet<int> set = new HashSet { 1, 2, 3 };\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Context-Sensitive Conversions with CollectionBuilderAttribute in C#\nDESCRIPTION: This code snippet illustrates how the existence of a conversion using CollectionBuilderAttribute can be context-sensitive. It shows how the iteration type of a collection can vary based on extension methods in scope, affecting the conversion behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\n[CollectionBuilder(typeof(MyCollectionBuilder), nameof(MyCollectionBuilder.Create))]\nclass MyCollection\n{\n}\nclass MyCollectionBuilder\n{\n    public static MyCollection Create(ReadOnlySpan<long> items) => throw null;\n    public static MyCollection Create(ReadOnlySpan<string> items) => throw null;\n}\n\nnamespace Ns1\n{\n    static class Ext\n    {\n        public static IEnumerator<long> GetEnumerator(this MyCollection x) => throw null;\n    }\n    \n    class Program\n    {\n        static void Main()\n        {\n            foreach (var l in new MyCollection())\n            {\n                long s = l;\n            }\n        \n            MyCollection x1 = [\"a\", // error CS0029: Cannot implicitly convert type 'string' to 'long'\n                               2];\n        }\n    }\n}\n\nnamespace Ns2\n{\n    static class Ext\n    {\n        public static IEnumerator<string> GetEnumerator(this MyCollection x) => throw null;\n    }\n    \n    class Program\n    {\n        static void Main()\n        {\n            foreach (var l in new MyCollection())\n            {\n                string s = l;\n            }\n        \n            MyCollection x1 = [\"a\",\n                               2]; // error CS0029: Cannot implicitly convert type 'int' to 'string'\n        }\n    }\n}\n\nnamespace Ns3\n{\n    class Program\n    {\n        static void Main()\n        {\n            // error CS1579: foreach statement cannot operate on variables of type 'MyCollection' because 'MyCollection' does not contain a public instance or extension definition for 'GetEnumerator'\n            foreach (var l in new MyCollection())\n            {\n            }\n        \n            MyCollection x1 = [\"a\", 2]; // error CS9188: 'MyCollection' has a CollectionBuilderAttribute but no element type.\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Array Element Access Null Checking in C#\nDESCRIPTION: Demonstrates proper null checking patterns for array element access, showing both the problematic approach and the null-safe pattern using pattern matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\nobject?[] array = ...;\nif (array[0] != null)\n{\n    // Warning: Converting null literal or possible null value to non-nullable type.\n    object o = array[0];\n    // Warning: Dereference of a possibly null reference.\n    Console.WriteLine(o.ToString());\n}\n\n// Nullable friendly pattern\nif (array[0] is {} o)\n{\n    Console.WriteLine(o.ToString());\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Explicit Extension Type in C#\nDESCRIPTION: This code snippet demonstrates the declaration of an explicit extension type 'E' that extends a generic type 'T' and defines a method 'M'. It also shows example usage with both class and struct types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-21.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit extension E<T> for T { void M(); }\nnew C().M();\nnew S().M();\n```\n\n----------------------------------------\n\nTITLE: Implementing Web API Responses in C#\nDESCRIPTION: This code shows two approaches to handling web API responses: one using IActionResult in MVC, and another using a Results type in minimal APIs. It demonstrates how discriminated unions could simplify and type-safe these patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-10-19.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HttpGet(Name = \"GetWeatherForecast\")]\npublic IActionResult Get(int id)\n{\n    return id % 2 == 0\n        ? Ok(Enumerable.Range(1, 5).Select(index => new WeatherForecast\n        {\n            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),\n            TemperatureC = Random.Shared.Next(-20, 55),\n            Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n        }).ToArray())\n        : NotFound();\n}\n\napp.MapGet(\"/minimal-dus/{id}\", Results<Ok<string>, ProblemHttpResult> (int id) => {\n    return id % 2 == 0\n        ? TypedResults.Ok(\"Valid ID\")\n        : TypedResults.Problem(\"Invalid Id\");\n});\n```\n\n----------------------------------------\n\nTITLE: UTF-8 Literal Usage with u8 Suffix\nDESCRIPTION: This code illustrates how the `u8` suffix will be used to create UTF-8 `ReadOnlySpan<byte>` literals. It demonstrates the correct and incorrect ways to assign the literal to different types, highlighting the implicit conversion rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\"string s1 = \\\"hello\\\"u8;             // Error\nvar s2 = \\\"hello\\\"u8;                // Okay and type is ReadOnlySpan<byte>\nReadOnlySpan<byte> s3 = \\\"hello\\\"u8; // Okay.\nbyte[] s4 = \\\"hello\\\"u8;             // Error - Cannot implicitly convert type 'System.ReadOnlySpan<byte>' to 'byte[]'.\nbyte[] s5 = \\\"hello\\\"u8.ToArray();   // Okay.\nSpan<byte> s6 = \\\"hello\\\"u8;         // Error - Cannot implicitly convert type 'System.ReadOnlySpan<byte>' to 'System.Span<byte>'.\"\n```\n\n----------------------------------------\n\nTITLE: Custom Async Method Builder Usage\nDESCRIPTION: Shows how a custom async method builder can be applied to a method using an attribute\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/async-method-builders.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<>))]\nstatic async ValueTask<int> ExampleAsync() { ... }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[AsyncStateMachine(typeof(<ExampleAsync>d__29))]\n[CompilerGenerated]\n[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<>))]\nstatic ValueTask<int> ExampleAsync()\n{\n    <ExampleAsync>d__29 stateMachine;\n    stateMachine.<>t__builder = PoolingAsyncValueTaskMethodBuilder<int>.Create();\n    stateMachine.<>1__state = -1;\n    stateMachine.<>t__builder.Start(ref stateMachine);\n    return stateMachine.<>t__builder.Task;\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Transparency for KeyValuePair in C# Collection Expressions\nDESCRIPTION: This snippet illustrates transparency support for KeyValuePair in any collection expression, but not in direct assignments or other contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nKeyValuePair<string, int> kvp = new(\"mads\", 21);\nDictionary<object, int?> map1 = [kvp]; // legal.\nList<KeyValuePair<object, int?>> map1 = [kvp]; // legal.\n\nKeyValuePair<object, int?> kvp2 = kvp1; // not legal.  User must write:\nKeyValuePair<object, int?> kvp2 = new KeyValuePair<object, int?>(kvp1.Key, kvp.Value);\n```\n\n----------------------------------------\n\nTITLE: Enhanced Switch Statement Example in C#\nDESCRIPTION: Demonstrates the proposed new switch statement syntax using expression-style arms with pattern matching and different statement types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/enhanced-switch-statements.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar o = ...;\nswitch (o)\n{\n    1 => Console.WriteLine(\"o is 1\"),\n    string s => Console.WriteLine($\"o is string {s}\"),\n    List<string> l => {\n        Console.WriteLine(\"o is a list of strings:\");\n        foreach (var s in l)\n        {\n            Console.WriteLine($\"\\t{s}\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Target-typed Member Access Examples in C#\nDESCRIPTION: Demonstrates basic usage of target-typed member access for various scenarios including enum flags, colors, dates, and discriminated unions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/target-typed-static-member-lookup.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ntype.GetMethod(\"Name\", .Public | .Instance | .DeclaredOnly);\ncontrol.ForeColor = .Red;\nentity.InvoiceDate = .Today;\nReadJsonDocument(.Parse(stream));\n\nOption<int> option = condition ? .None : .Some(42);\n\nCustomResult result = condition ? new .Success(42) : new .Error(\"message\");\n\nreturn result switch\n{\n    .Success(var val) => val,\n    .Error => defaultVal,\n};\n```\n\n----------------------------------------\n\nTITLE: Target Typing Collection Expressions to Core Interfaces in C#\nDESCRIPTION: Demonstrates implicit conversion of a collection expression to an interface type, specifically targeting IEnumerable<int>. This example explores how collection expressions can be implicitly converted to core .NET collection interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-08-09.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<int> numbers = [ 1, 2, .. otherNumbers, 3 ];\n```\n\n----------------------------------------\n\nTITLE: Using var Pattern and when Clause in C#\nDESCRIPTION: Demonstration of using a var pattern with a when clause or logical AND operator for checking struct initialization. This is presented as an alternative to a proposed default expression pattern feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-11-06.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar-pattern it and check in `when` or `&&`\n```\n\n----------------------------------------\n\nTITLE: C# Range Syntax Options\nDESCRIPTION: Proposed C# syntax options for handling ranges and end-based indexing using ^ or ~ operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-26.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n~0  // Index at length using tilde\n^0  // Index at length using caret\n1..-1  // Range from second element to last element\n```\n\n----------------------------------------\n\nTITLE: Implementing Abstract Static Members in Interfaces with Generic Self-Reference\nDESCRIPTION: Example interface definition showcasing the proposed syntax for abstract static members in interfaces, using a TSelf generic parameter with a recursive constraint to implement a numeric interface pattern. This approach allows interfaces to define static members that must be implemented by concrete types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-29.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface INumeric<TSelf> where TSelf : INumeric<TSelf>\n{\n    abstract static TSelf Zero { get; }\n    abstract static TSelf operator +(TSelf a, TSelf b);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Static Extension Methods in C#\nDESCRIPTION: Demonstrates the definition of static extension methods which involve specifying the target type directly before the method name. This structure parallels the calling syntax and a sample application is provided alongside a comparison with an existing .NET method signature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed partial class String\n{\n    public static string Create<TState>(int length, TState state, SpanAction<char, TState> action)\n    {\n    }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic partial extensions Extensions\n{\n    public static string string.Create<TState>(int length, TState state, SpanAction<char, TState> action)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Allows Ref Struct Generic Constraint in C#\nDESCRIPTION: Demonstrates how to use the 'allows ref struct' constraint in a generic method to allow Span<T> and other ref struct types as arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nT Identity<T>(T p)\n    where T : allows ref struct\n    => p;\n\n// Okay\nSpan<int> local = Identity(new Span<int>(new int[10]));\n```\n\n----------------------------------------\n\nTITLE: Helper Methods for Inline Array to Span Conversion in C#\nDESCRIPTION: Generic helper methods that can be used across a program to create Span and ReadOnlySpan instances from inline array types. These reduce IL size at use sites by providing reusable implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic static System.Span<TElement> InlineArrayAsSpan<TBuffer, TElement>(ref TBuffer buffer, int size) where TBuffer : struct\n{\n    return MemoryMarshal.CreateSpan(ref Unsafe.As<TBuffer, TElement>(ref buffer), size);\n}\n\npublic static System.ReadOnlySpan<TElement> InlineArrayAsReadOnlySpan<TBuffer, TElement>(in TBuffer buffer, int size) where TBuffer : struct\n{\n    return MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<TBuffer, TElement>(ref Unsafe.AsRef(in buffer)), size);\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Option Union Type in C#\nDESCRIPTION: Demonstrates usage of the Option union type including creation, pattern matching, and conditional access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nOption<string> x = new Some(\"text\");\nOption<string> y = None;\n\nif (x is Some(var value)) {...}\n\nvar v = x is Some(var value) ? value : 0;\n```\n\n----------------------------------------\n\nTITLE: Constructing List<T> with Different Arguments in C#\nDESCRIPTION: Demonstrates various ways to construct a List<T> using collection expressions with different argument patterns, showcasing constructor overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// List<T> candidates:\n//   List<T>()\n//   List<T>(IEnumerable<T> collection)\n//   List<T>(int capacity)\nList<int> l;\nl = [with(capacity: 3), 1, 2]; // new List<int>(capacity: 3)\nl = [with([1, 2]), 3];         // new List<int>(IEnumerable<int> collection)\nl = [with(default)];           // error: ambiguous constructor\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Protected Required Field Access in C#\nDESCRIPTION: Example showing how protected required fields can be initialized in derived classes, though this specific pattern was ultimately not supported in the final design.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Base\n{\n    protected required int _field;\n\n    protected Base() {} // Contract required that _field is set\n}\npublic class Derived : Base\n{\n    public Derived() : init(_field = 1) // Contract is fulfilled and _field is removed from the required members list\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Address-of Operator with Method Groups in C#\nDESCRIPTION: Demonstrates how to use the address-of operator with method groups to create function pointers. Shows type compatibility and overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe class Util {\n    public static void Log() { }\n\n    void Use() {\n        delegate*<void> ptr1 = &Util.Log;\n\n        // Error: type \"delegate*<void>\" not compatible with \"delegate*<int>\";\n        delegate*<int> ptr2 = &Util.Log;\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Actions in ASP.NET with System.Delegate\nDESCRIPTION: Demonstrates the current method of using ASP.NET MapAction, requiring explicit delegate types for lambdas and method groups. This example highlights the current limitations where users have to specify the `System.Delegate` argument explicitly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[HttpGet(\"/\")] Todo GetTodo() => new(Id: 0, Name: \"Name\");\napp.MapAction((Func<Todo>)GetTodo);\n\n[HttpPost(\"/\")] Todo PostTodo([FromBody] Todo todo) => todo;\napp.MapAction((Func<Todo, Todo>)PostTodo);\n```\n\n----------------------------------------\n\nTITLE: Record Struct Declaration Examples in C#\nDESCRIPTION: Examples showing different ways to declare record structs with varying mutability settings through primary constructors. Demonstrates both mutable and readonly record struct declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-09-30.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Public, mutable fields named A and B\nrecord struct R1(int A, int B);\n\n// Public, readonly fields named A and B\nreadonly record struct R2(int A, int B);\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Span Types in C#\nDESCRIPTION: Demonstrates how the new overload resolution rules handle ambiguity between IEnumerable and ReadOnlySpan overloads when working with arrays.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\n\nvar a = new int[] { 1, 2, 3 };\na.M();\n\nstatic class E\n{\n    public static void M(this IEnumerable<int> x) { }\n    public static void M(this ReadOnlySpan<int> x) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Known Length Collection for Array in C#\nDESCRIPTION: Demonstrates the translation of a known length collection literal to a typed array. It includes length calculation and element assignment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nint __len = count_of_expression_elements +\n            __s1.Count;\n            ...\n            __s_n.Count;\n\nT1[] __result = new T1[__len];\nint __index = 0;\n\n__result[__index++] = __e1;\nforeach (T1 __t in __s1)\n    __result[__index++] = __t;\n\n// further assignments of the remaining elements\n```\n\n----------------------------------------\n\nTITLE: Static Member Access in Local Functions\nDESCRIPTION: Demonstrates the allowed access patterns in static local functions, including static members and constant definitions from the enclosing scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/static-local-functions.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void LocalFunction() {\n    // Can access:\n    // - static members\n    // - constant definitions\n    // - nameof() expressions\n}\n```\n\n----------------------------------------\n\nTITLE: Synthesized PrintMembers Method for Record Struct\nDESCRIPTION: This snippet shows the synthesized `PrintMembers` method for a record struct. It appends the name and value of each printable member (non-static public fields and readable properties) to a `StringBuilder`, separated by \", \".\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n\"private bool PrintMembers(System.Text.StringBuilder builder);\"\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Ad Hoc Unions in C#\nDESCRIPTION: Demonstrates different pattern matching scenarios with ad hoc unions, including type tests and variable declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\nif (u is Dog or Cat) { ... }  // normal 'or' pattern\n\nif (u is (Dog or Cat)) { ... }  // type test with ad hoc union\n    \nif (u is (Dog or Cat) pet) {...}  // type test with ad hoc union and variable\n```\n\n----------------------------------------\n\nTITLE: Example of Primary Constructor Parameter Shadowing in C#\nDESCRIPTION: An example showing how primary constructor parameters can be referenced in initializers and member bodies, with shadowing behavior between parameters and fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nclass C(int i)\n{\n    protected int i = i; // references parameter\n    public int I => i; // references field\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Fast Enumeration in C#\nDESCRIPTION: This code snippet demonstrates an optimization for collection expressions that are likely to be enumerated only once. It implements a self-enumerating list type that avoids heap allocation for the first enumeration on the same thread.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Compiler-synthesized-types.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class FastEnumerateCompilerSynthesizedList<T> : IReadOnlyList<T>, IList<T>, IList, /*new*/ IEnumerator<T>\n{\n    private int _enumeratorIndex = -2;\n    private int _initialThreadId = Environment.CurrentManagedThreadId;\n\n    // actual underlying data, using whatever strategy we choose.\n\n    public IEnumerator<T> GetEnumerator()\n    {\n        if (_enumeratorIndex == -2 && _initialThreadId == Environment.CurrentManagedThreadId)\n        {\n            _enumeratorIndex = -1;\n            return this;\n        }\n\n        return new HeapAllocatedEnumerator(...);\n    }\n\n    public bool MoveNext()\n        => ++_enumeratorIndex < this.Count;\n\n    public T Current => this[_enumeratorIndex];\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversions with 'in' Parameters in C#\nDESCRIPTION: Demonstrates that implicit conversions are allowed when passing arguments to 'in' parameters without the 'in' modifier at the call site.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nPrint<int>(Short.MaxValue)     // not an error.\n```\n\n----------------------------------------\n\nTITLE: Immutable Array Creation using Collection Literal\nDESCRIPTION: Demonstrates creating an immutable array using a collection literal with a type alias, highlighting the desire for simplified type specification\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-26.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing CrazyArray = ImmutableArray<List<HashSet<int>>>;\n\nvar v1 = (CrazyArray)[a, b, c];\n```\n\n----------------------------------------\n\nTITLE: Native Integer Array Indexing in C#\nDESCRIPTION: This code shows that native integer expressions can be used as array indices without conversion in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic object GetItem(object[] array, nint index)\n{\n    return array[index]; // ok\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Null Coalescing Assignment Operator\nDESCRIPTION: Grammar definition for the new ??= assignment operator in ANTLR notation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/null-coalescing-assignment.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nassignment_operator\n    : '??='\n    ;\n```\n\n----------------------------------------\n\nTITLE: ReadOnly Ref Struct Safety Example in C#\nDESCRIPTION: Shows how readonly ref structs can still have safety issues when containing ref fields to ref structs, even with readonly protection.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_40\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly ref struct ReadOnlySneaky\n{\n    readonly int Field;\n    readonly ref ReadOnlySpan<int> Span;\n\n    public void SelfAssign()\n    {\n        // Instance method captures a ref to itself\n        Span = new ReadOnlySpan<int>(ref Field, 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: API Design with Span Overloads in C#\nDESCRIPTION: Shows how the new betterness rules allow for adding Span-based overloads to existing APIs without causing ambiguity errors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\n\nC.M(new int[] { 1, 2, 3 }); // would be ambiguous before\n\nstatic class C\n{\n    public static void M(IEnumerable<int> x) { }\n    public static void M(ReadOnlySpan<int> x) { } // can be added now\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Range Types in C#\nDESCRIPTION: Proposal for introducing Range and LongRange types in C# with built-in operators and conversions. This includes the '..' operator for creating ranges with int and long endpoints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-10.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n..(int, int)\n..(long, long)\n```\n\n----------------------------------------\n\nTITLE: Pattern Variable Scope Example\nDESCRIPTION: Example showing scope restriction of pattern variable z to the embedded statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nif (x) M(y is var z);\n```\n\n----------------------------------------\n\nTITLE: Complex Ref Struct Definition with Scoped Ref Field in C#\nDESCRIPTION: This code demonstrates a more complex scenario with nested ref structs and scoped ref fields. It shows how lifetime parameters are defined and constrained for each level of nesting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S1 { }\nref struct S2 \n{\n    ref scoped S1 field;\n}\n\nS2 M(S2 p) { }\n\n// maps to \nref struct S1<out $this> { }\nref struct S2<out $this, $refField1, $field1>\n    where $field1 : $refField1\n{\n    ref<$refField1> S1<$field1> field;\n}\n\nS1<$cm, $l1, $l2> M<$cm, $l1>M(S<$cm, $l1, $l2> p)\n    where $l2 : $l1\n    where $l1 : $local\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference with Collection Expressions in C#\nDESCRIPTION: This snippet illustrates type inference rules for collection expressions, showing how the iteration type is inferred independently for each element.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nAsArray([null]);             // error: cannot infer T\nAsArray([1, 2, 3]);          // AsArray<int>(int[])\n\nstatic T[] AsArray<T>(T[] arg) => arg;\n```\n\nLANGUAGE: c#\nCODE:\n```\nbyte b = 1;\nint i = 2;\n\nArrayAndValue(new[] { b }, i); // error: cannot infer T\nArrayAndValue([b], i);         // ArrayAndValue<int>()\n\nstatic void ArrayAndValue<T>(T[] x, T y) { }\n```\n\n----------------------------------------\n\nTITLE: Nullable Reference Type Analysis Example in C#\nDESCRIPTION: Demonstrates limitations of nullable analysis with interpolated string handlers, particularly how MaybeNull attributes don't flow back through parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nstring s = \"\";\nC c = new C();\nc.M(s, $\"\", c.ToString(), s.ToString()); // No warnings on c.ToString() or s.ToString(), as the `MaybeNull` does not flow back.\n\npublic class C\n{\n    public void M(string s1, [InterpolatedStringHandlerArgument(\"\", \"s1\")] CustomHandler c1, string s2, string s3) { }\n}\n\n[InterpolatedStringHandler]\npublic partial struct CustomHandler\n{\n    public CustomHandler(int literalLength, int formattedCount, [MaybeNull] C c, [MaybeNull] string s) : this()\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Index Operator Usage Example\nDESCRIPTION: Example showing index operator syntax that was discussed. The operator '^' (renamed to 'hat') is defined as a unary operator that takes an int parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n^^1\n```\n\n----------------------------------------\n\nTITLE: Static Lambda with Constant Reference\nDESCRIPTION: Example demonstrating how static anonymous functions can reference constant definitions from the enclosing scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/static-anonymous-functions.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nconst int factor = 2;\nstatic (int x) => x * factor;\n```\n\n----------------------------------------\n\nTITLE: Auto-Implemented Readonly Properties\nDESCRIPTION: Shows valid and invalid combinations of readonly modifier with auto-implemented properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/readonly-instance-members.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// Allowed\npublic readonly int Prop4 { get; }\npublic int Prop5 { readonly get; set; }\n\n// Not allowed\npublic int Prop6 { readonly get; }\npublic readonly int Prop7 { get; set; }\npublic int Prop8 { get; readonly set; }\n```\n\n----------------------------------------\n\nTITLE: Basic Multi-line Raw String Example\nDESCRIPTION: Demonstrates basic multi-line raw string literal syntax without terminal newline.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         This is the entire content of the string.\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Record Struct Syntax Options in C#\nDESCRIPTION: This snippet shows two potential syntax options for declaring record structs in C#. The team ultimately decided on the 'record struct' syntax, with 'record class' also being allowed and synonymous with just 'record'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-10-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nrecord struct Person;\nstruct record Person;\n```\n\n----------------------------------------\n\nTITLE: Stack Allocation with Span<T> example in C#\nDESCRIPTION: This code snippet illustrates a potential issue with naively translating a collection literal to `stackalloc` within a loop.  A simplistic translation would result in growing the stack on each iteration of the loop, leading to a potential stack overflow.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-21.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nforeach (...)\n{\n   Span<T> values = [GetA(), GetB(), GetC()];\n   // do things with values\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Return Type Lambda Syntax\nDESCRIPTION: Demonstrates different syntactic approaches to ref return types in lambda expressions and their parsing implications.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-21.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nDelegate d1 = (ref int () => x); // ok\nDelegate d2 = ref int () => x;   // Currently parses as ref (int () => x)\nDelegate d3 = ref b ? ref int () => x : ref int () => x; // What should this mean?\n```\n\n----------------------------------------\n\nTITLE: Class Hierarchy Example with Checked and Regular Operators #3\nDESCRIPTION: Another example with a different class hierarchy arrangement showing operator resolution when checked and regular operators are defined on different base and derived classes, highlighting the impact on resolution in checked and unchecked contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    static void Add(C2 x, C3 y)\n    {\n        object o;\n        \n        // C2.op_CheckedAddition\n        o = checked(x + y);\n        \n        // C1.op_Addition\n        o = unchecked(x + y);\n    }\n}\n\nclass C1\n{\n    public static C1 operator + (C1 x, C3 y) => new C3();\n}\n\nclass C2 : C1\n{\n    public static C2 operator checked + (C2 x, C1 y) => new C2();\n}\n\nclass C3 : C1\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Using Out Parameters with Span Types in C#\nDESCRIPTION: Demonstrates how changing the ref-safe-context of 'out' parameters allows for more flexible APIs with ref structs. Shows a common pattern in reader-style APIs that would be restricted under previous rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nSpan<byte> Read(Span<byte> buffer, out int read)\n{\n    // .. \n}\n\nSpan<byte> Use()\n{\n    var buffer = new byte[256];\n\n    // If we keep current `out` ref-safe-context this is an error. The language must consider\n    // the `read` parameter as returnable as a `ref` field\n    //\n    // If we change `out` ref-safe-context this is legal. The language does not consider the \n    // `read` parameter to be returnable hence this is safe\n    int read;\n    return Read(buffer, out read);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CollectionBuilderAttribute for Factory Methods in C#\nDESCRIPTION: This snippet defines an attribute, CollectionBuilderAttribute, which specifies a factory method that can be used to create instances of a type. It encapsulates the type of the factory and the method name to be invoked for construction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class | AttributeTargets.Struct)]\npublic sealed class CollectionBuilderAttribute(Type factoryType, string methodName) : System.Attribute\n{\n    public readonly Type FactoryType;\n    public readonly string MethodName;\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Type Pattern Matching Example in C#\nDESCRIPTION: Example demonstrating pattern matching with nullable types in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nint? x = 3;\nif (x is int v) { // code using v\n```\n\n----------------------------------------\n\nTITLE: File-scoped Namespace Declaration in C# 10.0\nDESCRIPTION: Shows the simplified file-scoped namespace declaration syntax that eliminates the need for braces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nnamespace X.Y.Z;\n```\n\n----------------------------------------\n\nTITLE: Implementing Expression Simplification in C#\nDESCRIPTION: This function demonstrates positional patterns in C# to simplify mathematical expressions. It uses pattern matching to identify and simplify various arithmetic patterns like multiplication by 0 or 1, addition with 0, and constant folding.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nExpr Simplify(Expr e)\n{\n  switch (e) {\n    case Mult(Const(0), *): return Const(0);\n    case Mult(*, Const(0)): return Const(0);\n    case Mult(Const(1), var x): return Simplify(x);\n    case Mult(var x, Const(1)): return Simplify(x);\n    case Mult(Const(var l), Const(var r)): return Const(l*r);\n    case Add(Const(0), var x): return Simplify(x);\n    case Add(var x, Const(0)): return Simplify(x);\n    case Add(Const(var l), Const(var r)): return Const(l+r);\n    case Neg(Const(var k)): return Const(-k);\n    default: return e;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Synthesized ToString Method for Record Struct\nDESCRIPTION: This snippet shows the synthesized `ToString` method for a record struct. It creates a `StringBuilder`, appends the record struct name, calls `PrintMembers`, and returns the resulting string.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n\"public override string ToString();\"\n```\n\n----------------------------------------\n\nTITLE: FirstOrNull Generic Method Implementation in C#\nDESCRIPTION: Example of a potential FirstOrNull extension method implementation showing how the T? syntax could be used with notnull constraint.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-08.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static T? FirstOrNull<T>(this IEnumerable<T> e) where T : notnull\n```\n\n----------------------------------------\n\nTITLE: Initializing ReadOnlySpan of char with Array Syntax\nDESCRIPTION: This snippet demonstrates how to create a ReadOnlySpan<char> initialized with an array of characters. Despite using the 'new' keyword and referencing a char[] type, the C# compiler optimizes the code to avoid allocations, storing the data directly in the assembly's data segment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static ReadOnlySpan<char> s_chars = new char[] { 'a', 'b', 'c' };\n```\n\n----------------------------------------\n\nTITLE: Using 'in' Arguments at Call Sites in C#\nDESCRIPTION: Demonstrates how to pass arguments to methods with 'in' parameters. The code shows passing variables and readonly fields as 'in' arguments to both methods and indexers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nint x = 1;\n\nvoid M1<T>(in T x)\n{\n  // . . .\n}\n\nvar x = M1(in x);  // in argument to a method\n\nclass D\n{\n    public string this[in Guid index];\n}\n\nD dictionary = . . . ;\nvar y = dictionary[in Guid.Empty]; // in argument to an indexer\n```\n\n----------------------------------------\n\nTITLE: Using Non-trailing Named Arguments in C# Method Calls\nDESCRIPTION: Examples showing both currently disallowed cases that would become legal with this proposal, and cases that would remain illegal. The proposal allows named arguments in non-trailing positions only when they correspond to the correct positional parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/non-trailing-named-arguments.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nDoSomething(isEmployed:true, name, age); // currently disallowed, even though all arguments are in position\n// CS1738 \"Named argument specifications must appear after all fixed arguments have been specified\"\n```\n\n----------------------------------------\n\nTITLE: Nullable Analysis with Required Members and SetsRequiredMembersAttribute in C#\nDESCRIPTION: This snippet demonstrates how nullable analysis interacts with required members and the SetsRequiredMembersAttribute. It shows warning scenarios for potentially null required members in constructors and how different constructor chaining patterns affect nullable analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\npublic class Base\n{\n    public required string Prop1 { get; set; }\n\n    public Base() {}\n\n    [SetsRequiredMembers]\n    public Base(int unused) { Prop1 = \"\"; }\n}\npublic class Derived : Base\n{\n    public required string Prop2 { get; set; }\n\n    [SetsRequiredMembers]\n    public Derived() : base()\n    {\n    } // Warning: Prop1 and Prop2 are possibly null.\n\n    [SetsRequiredMembers]\n    public Derived(int unused) : base()\n    {\n        Prop1.ToString(); // Warning: possibly null dereference\n        Prop2.ToString(); // Warning: possibly null dereference\n    }\n\n    [SetsRequiredMembers]\n    public Derived(int unused, int unused2) : this()\n    {\n        Prop1.ToString(); // Ok\n        Prop2.ToString(); // Ok\n    }\n\n    [SetsRequiredMembers]\n    public Derived(int unused1, int unused2, int unused3) : base(unused1)\n    {\n        Prop1.ToString(); // Ok\n        Prop2.ToString(); // Warning: possibly null dereference\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref Assignment Expression in C#\nDESCRIPTION: This snippet shows a linked list walk using the new ref assignment expression. The expression 'l = ref l.Next' reassigns the ref local 'l' to point to the next node in the list.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-24.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nwhile ((l = ref l.Next) != null) ... // linked list walk\n```\n\n----------------------------------------\n\nTITLE: Illustrating Ref Local Assignment with Conditional Operator in C#\nDESCRIPTION: Demonstrates the potential syntax for assigning a ref local variable using the conditional operator with refs. This example shows concerns about the abundance of 'ref' keywords in the syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-28.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nref int r = ref (a1 != null ? ref a1[0] : ref a2[0]); // Four \"ref\"s\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Target-Typed Stackalloc Initializers in C#\nDESCRIPTION: These examples show various ways of using stackalloc, including target-typed initializers. The snippets demonstrate both traditional int* typing and the new Span<int> typing for stackalloc expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-24.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar x = new int[] { 1, 2, 3 };               // allowed today\nvar z = stackalloc int[5];                   // z is int* for back compat\nSpan<int> zs = stackalloc int[5];            // target typed\nvar y = stackalloc int[] { 1, 2, 3 };        // should be allowed? y is int*\nSpan<int> ys = stackalloc int[] { 1, 2, 3 }; // should be allowed? y is Span<int>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Task<T> Covariance Issue in C#\nDESCRIPTION: This snippet shows a common scenario where Task<T> covariance causes a warning when converting Task<string> to Task<string?>. The method M() returns a non-nullable Task<string> which causes a warning when assigned to a nullable Task<string?>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-10-24.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Threading.Tasks;\n\n#nullable enable\n\npublic class C\n{\n   public Task<string?> M() // not async\n   {\n       return Task.FromResult(\"\"); // type of return value is Task<string>, which warns when converting to Task<string?>.\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: AsyncLocal Variable Reference\nDESCRIPTION: Reference to AsyncLocal type discussed in context of execution context preservation\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-01.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nAsyncLocal\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching Syntax Examples in C#\nDESCRIPTION: Examples showing different pattern matching syntaxes for various types including integers, classes, anonymous types, records, tuples, and collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-14.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nint x                           // Declaration\nPoint { X: int x, Y: int y }   // Property pattern\n{ X: 3, Y: 4 }               // Anonymous type pattern\nPoint(int x, int y)          // Record pattern\n(int x, int y)               // Tuple pattern\nint[] [1, 2, 3]              // Proposed list pattern\n```\n\n----------------------------------------\n\nTITLE: Class Hierarchy with Virtual Method Override and Base Call\nDESCRIPTION: Demonstrates how base method calls work in class hierarchies. If a middle class's implementation is missing at runtime, the CLR will find the next implementation up the hierarchy. This behavior differs from interfaces where such fallback is not supported by the runtime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-29.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass A\n{\n    public virtual void M() { }\n}\nclass B : A\n{\n    public override void M() { }\n}\nclass C : B\n{\n    public override void M() { base.M(); }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Span<char> Using Switch in C#\nDESCRIPTION: The snippet shows usage of a switch statement to perform pattern matching on a Span<char> to check if its value matches 'ABC'. It returns true for a match and false otherwise.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/pattern-match-span-of-char-on-string.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic bool IsABC(Span<char> s)\n{\n    return s switch { \"ABC\" => true, _ => false };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Constant Patterns with Enums in C#\nDESCRIPTION: Demonstrates how constant patterns are interpreted in the context of the type they are tested against, using an enum example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-07.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nE myE = ...;\n\nif (e is 0) ... // 0 means (E)0, not (int)0;\n```\n\n----------------------------------------\n\nTITLE: Example Extension Method Declarations - C#\nDESCRIPTION: This C# code snippet demonstrates various types of extension members, including instance members, static members, and compatible extension methods using the newly defined syntax for extension declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/compromise-design-for-extensions.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n// Different kinds of extension members\\npublic extension E for C\\n{\\n    // Instance members - assume f is an accessible instance field on C\\n    public string P { get => f; set => f = value.Trim(); }         // Property\\n    public T M<T>() where T : IParsable<T> => T.Parse(f, default); // Method\\n    public char this[int index] => f[index];                       // Indexer\\n    public C(string f) => this.f = f;                              // Constructor\\n\\n    // Static members\\n    public static int ff = 0;                                // Static field\\n    public static int PP { get; set => field = Abs(value); } // Static property\\n    public static C MM(string s) => new C(s);                // Static method\\n    public static C operator +(C c1, C c2) => c1.f + c2.f;   // Operator\\n    public static implicit operator C(string s) => new C(s); // UD conversion\\n}\\n\\n// Type- and member-level for-clauses for attributes, nullability and ref-ness\\npublic extension NullableStringExtensions for string?\\n{\\n    public bool IsNullOrEmpty for [NotNullWhen(false)] string? \\n        => this is null or [];\\n    public string AsNotNull => this is null ? \"\" : this;\\n    public void MakeNotNull for [NotNull] ref string? => this ??= \"\";\\n}\\n\\n// Core LINQ methods as a non-compatible generic extension\\npublic extension Enumerable<T> for IEnumerable<T>\\n{\\n    public IEnumerable<T> Where(Func<bool> predicate) { ... }\\n    public IEnumerable<TResult> Select<TResult>(Func<T, TResult> selector) { ... }\\n}\\n\\n// Core LINQ methods as compatible extension methods\\npublic extension Enumerable\\n{\\n    public IEnumerable<TResult> Select<TSource, TResult>(Func<TSource, TResult> selector) for IEnumerable<TSource> source { ... }\\n    public IEnumerable<TSource> Where<TSource>(Func<TSource, bool> predicate) for IEnumerable<TSource> source { ... }\\n}\n```\n\n----------------------------------------\n\nTITLE: Inference and Limitations of Lambda Expressions\nDESCRIPTION: Highlights the necessity for method type inference to make exact inferences from explicit lambda return types. It also discusses variance conversions and the parser's ability to handle `ref` return types correctly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void F<T>(Func<T, T> f) { ... }\nF(int (i) => i); // Func<int, int>\n```\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<object> f1 = string () => null; // error\nFunc<object?> f2 = object () => x;   // warning\n```\n\nLANGUAGE: csharp\nCODE:\n```\nd = ref int () => x; // d = (ref int () => x)\nF(ref int () => x);  // F((ref int () => x))\n```\n\nLANGUAGE: csharp\nCODE:\n```\nclass var { }\n\nd = var (var v) => v;              // error: contextual keyword 'var' cannot be used as explicit lambda return type\nd = @var (var v) => v;             // ok\nd = ref var (ref var v) => ref v;  // error: contextual keyword 'var' cannot be used as explicit lambda return type\nd = ref @var (ref var v) => ref v; // ok\n```\n\n----------------------------------------\n\nTITLE: Collection Builder Method Parameter Ordering\nDESCRIPTION: Demonstrates different approaches to parameter ordering in collection builder methods, showing tradeoffs between optional parameters and params usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nclass MySetBuilder\n{\n    public static MySet<T> Create<T>(ReadOnlySpan<T> items, IEqualityComparer<T> comparer = null) { ... }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar s = MySetBuilder.Create(StringComparer.Ordinal, x, y, z);\n\nclass MySetBuilder\n{\n    public static MySet<T> Create<T>(IEqualityComparer<T> comparer, params ReadOnlySpan<T> items) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: IAsyncEnumerable Interface with CancellationToken in C#\nDESCRIPTION: Interface definition showing proposed CancellationToken support in IAsyncEnumerable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-28.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nIAsyncEnumerable<T>\n{\n    IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken token = default);\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Init Implementation Example\nDESCRIPTION: Demonstrates advanced init accessor usage including readonly field assignment and property initialization within init accessors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass Complex\n{\n    readonly int Field1;\n    int Field2;\n    int Prop1 { get; init; }\n    int Prop2\n    {\n        get => 42;\n        init\n        {\n            Field1 = 13; // okay\n            Field2 = 13; // okay\n            Prop1 = 13; // okay\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Async Main Method\nDESCRIPTION: Shows how the async example gets transformed into a Program class with async Main method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npartial class Program\n{\n    static async Task $Main(string[] args)\n    {\n        await System.Threading.Tasks.Task.Delay(1000);\n        System.Console.WriteLine(\"Hi!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Slicing Inline Arrays with Range Expressions in C#\nDESCRIPTION: Shows how to slice inline arrays using range expressions, resulting in Span<T> or ReadOnlySpan<T> depending on whether the array variable is writable or readonly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvoid M1(Buffer10<int> x)\n{\n    System.Span<int> a = x[..]; // Ok, equivalent to `System.Span<int> a = InlineArrayAsSpan<Buffer10<int>, int>(ref x, 10).Slice(0, 10)`\n}\n\nvoid M2(in Buffer10<int> x)\n{\n    System.ReadOnlySpan<int> a = x[..]; // Ok, equivalent to `System.ReadOnlySpan<int> a = InlineArrayAsReadOnlySpan<Buffer10<int>, int>(in x, 10).Slice(0, 10)`\n    System.Span<int> b = x[..]; // An error, System.ReadOnlySpan<int> cannot be converted to System.Span<int>\n}\n\nBuffer10<int> GetBuffer() => default;\n\nvoid M3()\n{\n    _ = GetBuffer()[..]; // An error, `GetBuffer()` is a value\n}\n```\n\n----------------------------------------\n\nTITLE: Using Digit Separators in C# Numeric Literals\nDESCRIPTION: Examples demonstrating the use of underscore as digit separator in various numeric literal formats including binary, hexadecimal, decimal, and floating-point numbers. Underscores can appear between any digits except at the start or end of numbers, and near special characters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/digit-separators.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint bin = 0b1001_1010_0001_0100;\nint hex = 0x1b_a0_44_fe;\nint dec = 33_554_432;\nint weird = 1_2__3___4____5_____6______7_______8________9;\ndouble real = 1_000.111_1e-1_000;\n```\n\n----------------------------------------\n\nTITLE: String Handler Usage Example in C#\nDESCRIPTION: Shows how the string handler is used and how it gets lowered by the compiler, including the transformation of interpolated strings into handler method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar formatted = string.Format(CultureInfo.InvariantCulture, $\"{X} = {Y}\");\n\n// Is lowered to\n\nvar tmp1 = CultureInfo.InvariantCulture;\nvar handler = new DefaultInterpolatedStringHandler(3, 2, tmp1);\nhandler.AppendFormatted(X);\nhandler.AppendLiteral(\" = \");\nhandler.AppendFormatted(Y);\nvar formatted = string.Format(tmp1, handler);\n```\n\n----------------------------------------\n\nTITLE: Defining Static and Instance Extension Members in C#\nDESCRIPTION: The snippet defines a static class 'MyExtensions' which contains two extension definitions. The first, a generic extension, provides instance methods for checking if a collection is empty, filtering, accessing elements by index, etc. The second targets 'IEnumerable<int>' specifically, offering methods like 'Range', 'Repeat', and an operator '+'. This setup utilizes LINQ and requires 'System.Linq'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic static class MyExtensions\n{\n    extension<T>(IEnumerable<T> source)\n    {\n        public bool IsEmpty => !source.Any();\n        public IEnumerable<T> Where(Func<T, bool> predicate) => ...;\n        public T this[int index] => source.ElementAt(index);\n\n        public static IEnumerable<T> Empty => [];\n        public static implicit operator ReadOnlySpan<T>(IEnumerable<T> sequence)\n            => sequence.ToArray().AsSpan();\n    }\n    extension(IEnumerable<int> source)\n    {\n        public IEnumerable(int element, int count) \n            => Enumerable.Repeat(element, count);\n\n        public static IEnumerable<int> Range(int start, int count) \n            => Enumerable.Range(start, count);\n        public static IEnumerable<int> operator +(IEnumerable<int> sequence, int value)\n            => sequence.Select(i => i + value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Declarations with Different Receiver Types (C#)\nDESCRIPTION: Shows various ways to declare extensions with different receiver types, including generic and non-generic versions, and static extension members with constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable source) // extension members for IEnumerable\n    {\n        public bool IsEmpty { get { ... } }\n    }\n    extension<TSource>(IEnumerable<TSource> source) // extension members for IEnumerable<TSource>\n    {\n        public IEnumerable<T> Where(Func<TSource, bool> predicate) { ... }\n        public IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector) { ... }\n    }\n    extension<TElement>(IEnumerable<TElement>) // static extension members for IEnumerable<TElement>\n        where TElement : INumber<TElement>\n    {\n        public static IEnumerable<TElement> operator +(IEnumerable<TElement> first, IEnumerable<TElement> second) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Definite Assignment Error in Struct Constructor\nDESCRIPTION: Demonstrates how struct constructors in C# require definite assignment of fields, resulting in compilation errors if fields are left uninitialized. This requires explicit initialization of struct members before returning from the constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/auto-default-structs.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic struct S\n{\n    public int x, y;\n    public S() // error: Fields 'S.x' and 'S.y' must be fully assigned before control is returned to the caller\n    {\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Collection Literal Usage in C#\nDESCRIPTION: Examples of common usage patterns for collection literals in C#, including array initialization, list creation with spread operator, and dictionary initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nint[] a = [1, 2, 3];\nList<object> list = [start, .. middle, end];\nIDictionary<string, int> d = [k1:v1, k2:v2, k3:v3];\n```\n\n----------------------------------------\n\nTITLE: Examples of 'in' Parameter Declarations in C#\nDESCRIPTION: Shows various contexts where 'in' parameters can be used in C#, including lambda expressions, indexers, and operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n(in int x) => x                                                     // lambda expression  \nTValue this[in TKey index];                                         // indexer\npublic static Vector3 operator +(in Vector3 x, in Vector3 y) => ... // operator\n```\n\n----------------------------------------\n\nTITLE: Metadata Encoding for Ad Hoc Unions in C#\nDESCRIPTION: Shows how ad hoc union types are encoded in metadata using custom attributes to preserve type information despite type erasure.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M((A or B) x);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Overload Resolution with Collection Expressions in C#\nDESCRIPTION: This snippet shows proposed behavior for overload resolution with collection expressions, preferring Span<T> over arrays or interfaces for collection expression arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nSpanAndArray([1, 2, 3]);  // (proposed) uses Span<T> overload\nSpanAndInterface([4, 5]); // (proposed) uses Span<T> overload\n\nstatic void SpanAndArray<T>(Span<T> args) { }\nstatic void SpanAndArray<T>(T[] args) { }\n    \nstatic void SpanAndInterface<T>(Span<T> args) { }\nstatic void SpanAndInterface<T>(IEnumerable<T> args) { }\n```\n\n----------------------------------------\n\nTITLE: Extension Constructor Example for IEnumerable\nDESCRIPTION: Example showing how to implement an extension constructor for IEnumerable<int> that creates a range sequence. Demonstrates static factory method pattern for extension constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable<int>)\n    {\n        public static IEnumerable(int start, int count) => Range(start, count);\n    }\n    public static IEnumerable<int> Range(int start, int count) { ... } \n}\n```\n\n----------------------------------------\n\nTITLE: Default Expression Ignoring Constructor in C#\nDESCRIPTION: This example demonstrates that using the `default` keyword to initialize a struct will ignore any defined parameterless constructor, and instead will create a zeroed instance of the struct.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n\"// struct S { public S() { } }\\n\\n_ = default(S); // constructor ignored, no warning\"\n```\n\n----------------------------------------\n\nTITLE: List Instantiation with Collection Literal Compiler Optimization\nDESCRIPTION: Demonstrates the proposed compiler optimization for creating List<T> instances using collection literals\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-26.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nList<int> list = [a, b, c]; // translates to:\n\nList<int> list = new List(capacity: 3);\nCollectionsMarshal.SetCount(list, 3);\nSpan<int> __storage = CollectionsMarshal.AsSpan(list);\n__storage[0] = a;\n__storage[1] = b;\n__storage[2] = c;\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Checked and Unchecked Operators in C#\nDESCRIPTION: This example demonstrates the implementation of Int128 struct with checked and unchecked operators for addition, subtraction, multiplication, and division operations. It shows how these operators are resolved in different checked/unchecked contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyClass\n{\n    public static void Add(Int128 lhs, Int128 rhs)\n    {\n        // Resolves to `op_CheckedAddition`\n        Int128 r1 = checked(lhs + rhs);\n\n        // Resolves to `op_Addition`\n        Int128 r2 = unchecked(lhs + rhs);\n\n        // Resolve to `op_Subtraction`\n        Int128 r3 = checked(lhs - rhs);\n\n        // Resolve to `op_Subtraction`\n        Int128 r4 = unchecked(lhs - rhs);\n\n        // Resolves to `op_CheckedMultiply`\n        Int128 r5 = checked(lhs * rhs);\n\n        // Error: Operator '*' cannot be applied to operands of type 'Int128' and 'Int128'\n        Int128 r6 = unchecked(lhs * rhs);\n    }\n\n    public static void Divide(Int128 lhs, byte rhs)\n    {\n        // Resolves to `op_Division` - it is a better match than `op_CheckedDivision`\n        Int128 r4 = checked(lhs / rhs);\n    }\n}\n\npublic struct Int128\n{\n    public static Int128 operator checked +(Int128 lhs, Int128 rhs);\n    public static Int128 operator +(Int128 lhs, Int128 rhs);\n\n    public static Int128 operator -(Int128 lhs, Int128 rhs);\n\n    // Cannot be declared in C# - missing unchecked operator, but could be declared by some other language\n    public static Int128 operator checked *(Int128 lhs, Int128 rhs);\n\n    public static Int128 operator checked /(Int128 lhs, int rhs);\n\n    public static Int128 operator /(Int128 lhs, byte rhs);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Checked Operators in Different Contexts\nDESCRIPTION: Example showing how checked operators are inapplicable in an unchecked context. The code illustrates that Int128's checked multiplication operator can be resolved in a checked context but causes an error in an unchecked context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyClass\n{\n    public static void Add(Int128 lhs, Int128 rhs)\n    {\n        // Resolves to `op_CheckedMultiply`\n        Int128 r5 = checked(lhs * rhs);\n\n        // Error: Operator '*' cannot be applied to operands of type 'Int128' and 'Int128'\n        Int128 r5 = unchecked(lhs * rhs);\n    }\n}\n\npublic struct Int128\n{\n    public static Int128 operator checked *(Int128 lhs, Int128 rhs);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ConfigureAwait with IAsyncEnumerable in C#\nDESCRIPTION: Example of how to use ConfigureAwait with IAsyncEnumerable in the await foreach syntax. This demonstrates how to configure task behavior at the await foreach site.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-19.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nawait foreach (var x in iasyncenum.ConfigureAwait(false))\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Address-of Operator in C#\nDESCRIPTION: Illustrates how overload resolution works in conjunction with the address-of operator when targeting method groups.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe class Util {\n    public static void Log() { }\n    public static void Log(string p1) { }\n    public static void Log(int i) { }\n\n    void Use() {\n        delegate*<void> a1 = &Log; // Log()\n        delegate*<int, void> a2 = &Log; // Log(int i)\n\n        // Error: ambiguous conversion from method group Log to \"void*\"\n        void* v = &Log;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Object Assignment with Null Conditional Operator\nDESCRIPTION: Demonstrates basic null-conditional assignment to an object property, where assignment only occurs if the parent object is non-null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/null-conditional-assignment.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nclass C\n{\n    public object obj;\n}\n\nvoid M(C? c)\n{\n    c?.obj = new object();\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Iterator Example\nDESCRIPTION: Example of a traditional synchronous iterator implementation, shown for comparison with async iterators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nstatic IEnumerable<int> MyIterator()\n{\n    try\n    {\n        for (int i = 0; i < 100; i++)\n        {\n            Thread.Sleep(1000);\n            yield return i;\n        }\n    }\n    finally\n    {\n        Thread.Sleep(200);\n        Console.WriteLine(\"finally\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Person, Student, and Teacher Classes in C#\nDESCRIPTION: Defines a small hierarchy of classes including Person, Student, and Teacher. This class structure is used to demonstrate pattern matching features in C# 7.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-11-02-Design-Demo.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Person\n{\n    public Person(string name) { this.Name = name; }\n    public string Name { get; }\n}\n\nclass Student : Person\n{\n    public Student(string name, double gpa) : base(name)\n        { this.Gpa = gpa; }\n    public double Gpa { get; }\n}\n\nclass Teacher : Person\n{\n    public Teacher(string name, string subject) : base(name)\n        { this.Subject = subject; }\n    public string Subject { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Various Extension Member Types in C#\nDESCRIPTION: Example showing syntax for additional extension member types including indexers, events, operators and user-defined conversions. The example demonstrates how these extensions could be declared for a primitive type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nextensions E for int\n{\n    public bool number.this[int bit] => ...;\n\n    public event Action number.NonsenseEvent\n    {\n        add => ...;\n        remove => ...;\n    }\n\n    public static event Action int.NonsenseEvent\n    {\n        add => ...;\n        remove => ...;\n    }\n\n    public static operator +(int x, string y) => ...;\n\n    public static implicit operator int(string x) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Postconditions in C#\nDESCRIPTION: Examples of conditional postconditions using attributes like [MaybeNullWhen] and [NotNullWhen]. These attributes are applied to parameters of bool-returning methods to express nullability conditions based on the method's return value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-05-15.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Version \n{ \n    // If it parses successfully, the Version will not be null. \n    public static bool TryParse( \n        string? input, \n        [NotNullWhen(true)] out Version? Version); \n} \n \npublic static class Semaphore \n{ \n    // Not just for parsingâ€¦ \n    public static bool TryOpenExisting( \n        string name, \n        [NotNullWhen(true)] out Semaphore? result); \n} \n \npublic class Queue<T> \n{ \n    // With unconstrained generics, we use the inverse \n    public bool TryDequeue([MaybeNullWhen(false)] out T result) \n} \n \n \npublic static class MemoryMarshal<T> \n{ \n    // It applies as well with constrained generics. \n    public static bool TryGetMemoryManager<T, TManager>( \n        ReadOnlyMemory<T> memory, [NotNullWhen(true)] out TManager? manager) \n        where TManager : MemoryManager<T> \n} \n \npublic class String \n{ \n    // Not just for outsâ€¦ also relevant to inferrig nullability of \n    // input arguments based on the return value. \n    public static bool IsNullOrEmpty([NotNullWhen(true)] string? value) \n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of fieldof() Expression in C#\nDESCRIPTION: Demonstrates the basic usage of fieldof() expression in a constructor to directly access and modify a property's backing field, bypassing the setter logic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/fieldof.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C {\n    public C(DataStore store) {\n        this.store = store;\n\n        fieldof(this.Prop) = store.ReadPropFromDisk();\n        M(ref fieldof(this.Prop));\n    }\n\n    void Method() {\n        // error: 'fieldof' can only be used during initialization (see also Alternatives)\n        fieldof(this.Prop) = \"a\";\n    }\n\n    private DataStore store;\n\n    public string Prop {\n        get => field;\n        set {\n            if (value != field) {\n                field = value;\n                store.WritePropToDisk(value);\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining InterpolatedStringHandler with Custom Argument\nDESCRIPTION: Example showing how to define a logger method using the new InterpolatedStringHandlerArgumentValue attribute to pass a log level.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/interpolated-string-handler-argument-value.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void LogDebug(\n    this ILogger logger,\n    [InterpolatedStringHandlerArgument(nameof(logger))]\n    [InterpolatedStringHandlerArgumentValue(LogLevel.Debug)]\n    LogInterpolatedStringHandler message);\n```\n\n----------------------------------------\n\nTITLE: Definite Assignment in Structs - Examples\nDESCRIPTION: Shows various constructor examples in structs illustrating how the proposed changes handle definite assignment, including scenarios with implicit initialization of unassigned fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/auto-default-structs.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstruct S\n{\n    int x, y;\n\n    // Example 1\n    public S()\n    {\n        // ok. Compiler inserts an assignment of `this = default`.\n    }\n\n    // Example 2\n    public S()\n    {\n        // ok. Compiler inserts an assignment of `y = default`.\n        x = 1;\n    }\n\n    // Example 3\n    public S()\n    {\n        // valid since C# 1.0. Compiler inserts no implicit assignments.\n        x = 1;\n        y = 2;\n    }\n\n    // Example 4\n    public S(bool b)\n    {\n        // ok. Compiler inserts assignment of `this = default`.\n        if (b)\n            x = 1;\n        else\n            y = 2;\n    }\n\n    // Example 5\n    void M() { }\n    public S(bool b)\n    {\n        // ok. Compiler inserts assignment of `y = default`.\n        x = 1;\n        if (b)\n            M();\n\n        y = 2;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Interfaces with File-Local Structs\nDESCRIPTION: This snippet shows that file-local types, such as structs, can implement interfaces just like regular type declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nfile struct Widget : IEquatable<Widget>\n{\n    public bool Equals(Widget other) => true;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullness Dependencies in C#\nDESCRIPTION: Examples of using the [NotNullIfNotNull] attribute to express dependencies between input and output nullability. This attribute is applied to return values, ref, or out parameters to indicate non-nullness based on a specific input parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-05-15.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass Path \n{ \n    [return: NotNullIfNotNull(nameof(path))] \n    public static string? GetFileName(string? path); \n} \n \nclass RegistryKey \n{ \n    [return: NotNullIfNotNull(nameof(defaultValue))] \n    public object? GetValue(string name, object? defaultValue) \n} \n \nclass Interlocked \n{ \n    public static T Exchange<T>([NotNullIfNotNull(nameof(value))] ref T location1, T value) where T : class? \n} \n \nclass Volatile \n{ \n    public static void Write<T>([NotNullIfNotNull(nameof(value))] ref T location, T value) where T : class? \n \n    [return: NotNullIfNotNull(nameof(location))] \n    public static T Read(ref T location); \n} \n \nclass Delegate \n{ \n    [return: NotNullIfNotNull(nameof(a))] \n    [return: NotNullIfNotNull(nameof(b))] \n    public static Delegate? Combine(Delegate? a, Delegate? b) \n}\n```\n\n----------------------------------------\n\nTITLE: Basic Fixed Statement Usage Example in C#\nDESCRIPTION: Demonstrates the current fixed statement syntax for pinning a byte array and obtaining a native pointer to its buffer.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/pattern-based-fixed.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfixed(byte* ptr = byteArray)\n{\n   // ptr is a native pointer to the first element of the array\n   // byteArray is protected from being moved/collected by the GC for the duration of this block \n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Return Type Variance Example\nDESCRIPTION: Shows how variance is handled with explicit return types in lambda expressions when converting to delegate types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-21.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<object> f = string () => \"\";\n```\n\n----------------------------------------\n\nTITLE: Init Accessor Inheritance Example\nDESCRIPTION: Example showing how init accessors work with inheritance, demonstrating base class property access in derived classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nclass Base\n{\n    public bool Value { get; init; }\n}\n\nclass Derived : Base\n{\n    public Derived()\n    {\n        // Not allowed with get only properties but allowed with init\n        Value = true;\n    }\n}\n\nclass Consumption\n{\n    void Example()\n    {\n        var d = new Derived() { Value = true };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Params with Non-Constructible Collection Type\nDESCRIPTION: This example illustrates an issue with the params collection feature where a non-constructible collection type is allowed as a params parameter type, leading to confusing error messages when using it.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass C1 : IEnumerable<char>\n{\n    public static void M1(params C1 x) // It is probably better to report an error about an invalid `params` modifier\n    {\n    }\n    public static void M1(params ushort[] x)\n    {\n    }\n\n    void Test()\n    {\n        M1('a', 'b'); // error CS1061: 'C1' does not contain a definition for 'Add' and no accessible extension method 'Add' accepting a first argument of type 'C1' could be found (are you missing a using directive or an assembly reference?)\n        M2('a', 'b'); // Ok\n    }\n\n    public static void M2(params ushort[] x)\n    {\n    }\n\n    IEnumerator<char> IEnumerable<char>.GetEnumerator() => throw null;\n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Async Iterator Method with CancellationToken in C#\nDESCRIPTION: Example of async iterator method signature with optional CancellationToken parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-28.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nasync IAsyncEnumerable<int> M(..., CancellationToken token = default)\n{ ... }\n```\n\n----------------------------------------\n\nTITLE: Legal Dictionary Expression Examples\nDESCRIPTION: Examples of various legal dictionary expressions, showing assignments to both dictionary types and collection types with different source elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Assigning to dictionary types:\nDictionary<string, int> nameToAge1 = [\"mads\": 21, existingKvp];     // as would\nDictionary<string, int> nameToAge2 = [\"mads\": 21, .. existingDict]; // as would\nDictionary<string, int> nameToAge3 = [\"mads\": 21, .. existingListOfKVPS];\n\n// Assigning to collection types:\nList<string, int> nameToAge1 = [\"mads\": 21, existingKvp];     // as would\nList<string, int> nameToAge2 = [\"mads\": 21, .. existingDict]; // as would\nList<string, int> nameToAge3 = [\"mads\": 21, .. existingListOfKVPS];\n```\n\n----------------------------------------\n\nTITLE: Declaring Extension Operators in C#\nDESCRIPTION: This snippet demonstrates how to declare extension operators within an extension block. It shows the syntax for declaring static binary operators and a compound assignment operator for array multiplication.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-operators.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Operators\n{\n    extension<TElement>(TElement[] source) where TElement : INumber<TElement>\n    {\n        public static TElement[] operator *(TElement[] vector, TElement scalar) { ... }\n        public static TElement[] operator *(TElement scalar, TElement[] vector) { ... }\n        public void operator *=(TElement scalar) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Operator Lookup and Overload Resolution in Checked Context\nDESCRIPTION: Example demonstrating more complex operator lookup rules where both regular and checked operators can coexist. Shows how the compiler prefers checked operators in checked contexts and regular operators in unchecked contexts, with specifics about exact matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyClass\n{\n    public static void Add(Int128 lhs, Int128 rhs)\n    {\n        // Resolves to `op_CheckedAddition`\n        Int128 r1 = checked(lhs + rhs);\n\n        // Resolves to `op_Addition`\n        Int128 r2 = unchecked(lhs + rhs);\n\n        // Resolve to `op_Subtraction`\n        Int128 r3 = checked(lhs - rhs);\n\n        // Resolve to `op_Subtraction`\n        Int128 r4 = unchecked(lhs - rhs);\n    }\n\n    public static void Multiply(Int128 lhs, byte rhs)\n    {\n        // Resolves to `op_Multiply` even though `op_CheckedMultiply` is also applicable\n        Int128 r4 = checked(lhs * rhs);\n    }\n}\n\npublic struct Int128\n{\n    public static Int128 operator checked +(Int128 lhs, Int128 rhs);\n    public static Int128 operator +(Int128 lhs, Int128 rhs);\n\n    public static Int128 operator -(Int128 lhs, Int128 rhs);\n\n    public static Int128 operator checked *(Int128 lhs, int rhs);\n    public static Int128 operator *(Int128 lhs, byte rhs);\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Rewrite of Conditional Access Null Check in C#\nDESCRIPTION: A rewritten version of the previous example showing how the conditional access operator could be interpreted as a logical condition, demonstrating how s would be tracked as maybe-null after the condition.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-20.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string s)\n{\n    if (s == null || s.ToString() == null)\n    {\n        // s would be maybe-null after this point\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: With Constructor Implementation in C#\nDESCRIPTION: Shows how to implement a With constructor for supporting object copying.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nclass UserInfo\n{\n    ...\n    [WithConstructor] // placeholder syntax, up for debate\n    public UserInfo With()\n    {\n        return new UserInfo() { Username = this.Username, Email = this.Email, IsAdmin = this.IsAdmin };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inference with Extension Methods in C#\nDESCRIPTION: Demonstrates an example where type inference is used to apply an extension container for a given receiver. Type constraints and considerations for method applicability are managed through the generic type system in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nvar numbers = new List<int>();\n\nforeach (var text in numbers.ToFormattedStrings(\"x8\"))\n{\n    Console.WriteLine(text);\n}\n\nextensions EnumerableExtensions<T> for IEnumerable<T> where T : IFormattable\n{\n    public IEnumerable<string> source.ToFormattedStrings(string format)\n        => source.Select(x => x.ToString(format, formatProvider: null));\n}\n\n```\n\n----------------------------------------\n\nTITLE: Extension Declarations for Multiple Types in C#\nDESCRIPTION: This code demonstrates how extension declarations can be used to define extension members for different underlying types, such as `IEnumerable` and `IEnumerable<T>`. Each extension declaration specifies the underlying type and any associated type parameters. The 'extension' keyword is used along with the target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable) // extension members for IEnumerable\n    {\n        public bool IsEmpty { get { ... } }\n    }\n    extension<T>(IEnumerable<T>) // extension members for IEnumerable<T>\n    {\n        public IEnumerable<T> Where(Func<T, bool> predicate) { ... }\n        public IEnumerable<TResult> Select<TResult>(Func<T, TResult> selector) { ... }\n        public static IEnumerable<T> operator +(IEnumerable<T> e1, IEnumerable<T> e2) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Collection with Builder Method in C#\nDESCRIPTION: Illustrates the use of a custom collection type with a CollectionBuilder attribute, showing how the Create method is invoked with arguments and elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nMyCollection<string> c = [with(GetComparer()), \"1\", \"2\"];\n// IEqualityComparer<string> _tmp1 = GetComparer();\n// ReadOnlySpan<string> _tmp2 = [\"1\", \"2\"];\n// c = MyBuilder.Create<string>(_tmp1, _tmp2);\n\n[CollectionBuilder(typeof(MyBuilder), \"Create\")]\nclass MyCollection<T> { ... }\n\nclass MyBuilder\n{\n    public static MyCollection<T> Create<T>(ReadOnlySpan<T> elements);\n    public static MyCollection<T> Create<T>(IEqualityComparer<T> comparer, ReadOnlySpan<T> elements);\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Passing of Readonly References in C#\nDESCRIPTION: Illustrates how values can be implicitly passed as readonly references without the need for a 'ref' keyword at the call site, simplifying the syntax for callers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-22.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nint x = 1, y = 2;\nint z = Choose(x, y); // implicitly passed by readonly ref\n```\n\n----------------------------------------\n\nTITLE: Using Extended nameof Scope in Attributes in C# 11.0\nDESCRIPTION: Demonstrates the extended scope of nameof in attributes, allowing reference to parameters, introduced in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n[MyAttribute(nameof(parameter))] void M(int parameter) { }\n```\n\n----------------------------------------\n\nTITLE: Examples of Unmanaged and Non-Unmanaged Types in C#\nDESCRIPTION: Code showing the difference between a struct that satisfies the unmanaged constraint (contains only unmanaged field types) and one that doesn't (contains reference type fields).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/blittable.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Unmanaged type\nstruct Point \n{ \n    int X;\n    int Y {get; set;}\n}\n\n// Not an unmanaged type\nstruct Student \n{ \n    string FirstName;\n    string LastName;\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Using Declarations and Disposal Order\nDESCRIPTION: Shows how multiple using declarations are handled and their disposal order at the end of scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/using.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n{ \n    using var f1 = new FileStream(\"...\");\n    using var f2 = new FileStream(\"...\");\n    using var f3 = new FileStream(\"...\");\n    ...\n    // Dispose f3\n    // Dispose f2 \n    // Dispose f1\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Synthesized Printing Members for Record Struct\nDESCRIPTION: This snippet shows an example implementation of the synthesized `PrintMembers` and `ToString` methods for a record struct `R1` with properties `P1` and `P2`. It demonstrates how the members are appended to the `StringBuilder`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n\"struct R1 : IEquatable<R1>\\n{\n    public T1 P1 { get; set; }\\n    public T2 P2 { get; set; }\\n\\n    private bool PrintMembers(StringBuilder builder)\\n    {\n        builder.Append(nameof(P1));\n        builder.Append(\" = \");\n        builder.Append(this.P1); // or builder.Append(this.P1.ToString()); if P1 has a value type\n        builder.Append(\", \");\n\n        builder.Append(nameof(P2));\n        builder.Append(\" = \");\n        builder.Append(this.P2); // or builder.Append(this.P2.ToString()); if P2 has a value type\n\n        return true;\n    }\n\n    public override string ToString()\\n    {\n        var builder = new StringBuilder();\n        builder.Append(nameof(R1));\n        builder.Append(\" { \");\n\n        if (PrintMembers(builder))\n            builder.Append(\" \");\n\n        builder.Append(\"}\");\n        return builder.ToString();\n    }\n}\"\n```\n\n----------------------------------------\n\nTITLE: Syntax Definition for 'field' Keyword in C# 14\nDESCRIPTION: A diff showing the addition of 'field' as a primary expression in the C# grammar when used in property accessors with language version 14 or higher.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\nprimary_no_array_creation_expression\n    : literal\n+   | 'field'\n    | interpolated_string_expression\n    | ...\n    ;\n```\n\n----------------------------------------\n\nTITLE: Handling Type Parameters with Anonymous Types in C#\nDESCRIPTION: Example demonstrating anonymous type field nullability tracking and how nullability information is preserved through type inference and method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-06.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic T Identity<T>(T t) => t;\n\nstatic void F(string x, string? y)\n{\n    var a = new { x };\n    a.x.ToString();           // ok\n\n    a = new { x = y };        // warning?\n    a.x.ToString();           // warning\n\n    Identity(a).x.ToString(); // warning?\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Interface Implementation with Generic Methods and Nullable Reference Types\nDESCRIPTION: Example showing ambiguity when implementing an interface with generic methods that have nullable parameters. This code was valid in C# 7 but becomes ambiguous with nullable reference types, as T? could refer to either Nullable<T> for value types or nullable reference types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-03.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface I\n{\n    void Foo<T>(T value) where T : class;\n    void Foo<T>(T? value) where T : struct;\n}\n\nclass C : I\n{\n    void I.Foo<T>(T? value) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Top-level Statements Desugared Implementation\nDESCRIPTION: Shows how the compiler transforms top-level statements into a partial Program class with a Main method. Demonstrates the internal implementation of the syntactic sugar.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-07-12.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\npartial class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(GetInt());\n\n        static int GetInt() => 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Natural Type Inference with Mixed Types in Dictionary-Like Collections in C#\nDESCRIPTION: This code snippet illustrates natural type inference when mixing string and object types in the new dictionary-like syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstring s1, s2;\nobject o1, o2;\nvar d = [s1: o1, o2: s2];\n```\n\n----------------------------------------\n\nTITLE: Extended Partial Method Features in C#\nDESCRIPTION: Demonstrates new capabilities of partial methods including out parameters and return types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npartial class D\n{\n    // Okay\n    internal partial bool TryParse(string s, out int i); \n}\n\npartial class D\n{\n    internal partial bool TryParse(string s, out int i) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Local Data Escape Through Ref Scoped Parameter in C#\nDESCRIPTION: This code illustrates how the 'ref scoped' parameter prevents local data from escaping the current method. It shows an error when trying to assign a local struct to a ref scoped parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M<$param1>(ref<$local> S<$param1> p)\n    where $param1 : $local\n{\n\n    S<$local> s = new S<$local>(stackalloc int[42]);\n\n    // error: cannot convert S<$local> to S<$param1>\n    p = s;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Null Check Method with Nullable Reference Types in C#\nDESCRIPTION: This code demonstrates how a null check method like IsNullOrEmpty() can affect the compiler's understanding of a variable's null state within a conditional block.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-08-20.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nif (!x.IsNullOrEmpty())\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy Initialization Using 'field' Keyword\nDESCRIPTION: Example of lazy initialization pattern using the 'field' keyword with the null-coalescing assignment operator in an expression-bodied property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n// No 'field' symbol in scope.\npublic class LazyInit\n{\n    public string Value => field ??= ComputeValue();\n    private static string ComputeValue() { /*...*/ }\n}\n```\n\n----------------------------------------\n\nTITLE: Using var with Anonymous Functions and Method Groups\nDESCRIPTION: These examples demonstrate how var declarations work with anonymous functions and method groups. The compiler infers the appropriate delegate type when the signature is clear, but reports errors when the type cannot be determined.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar f1 = () => default;           // error: cannot infer type\nvar f2 = x => x;                  // error: cannot infer type\nvar f3 = () => 1;                 // System.Func<int>\nvar f4 = string () => null;       // System.Func<string>\nvar f5 = delegate (object o) { }; // System.Action<object>\n\nstatic void F1() { }\nstatic void F1<T>(this T t) { }\nstatic void F2(this string s) { }\n\nvar f6 = F1;    // error: multiple methods\nvar f7 = \"\".F1; // error: the delegate type could not be inferred\nvar f8 = F2;    // System.Action<string>\n```\n\n----------------------------------------\n\nTITLE: Implementing Getter-Only Auto-Property with Initializer in C#\nDESCRIPTION: Demonstrates the syntax for a getter-only auto-property with an initializer, allowing the declaration of immutable properties with non-default values. The property's backing field is readonly and cannot be modified after initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-11-04.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic bool IsActive { get; } = true;\n```\n\n----------------------------------------\n\nTITLE: Initializers in Partial Properties with 'field' Keyword in C#\nDESCRIPTION: Demonstration of how initializers might work with partial properties that use the 'field' keyword, examining the interaction between definition and implementation parts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\npartial class C\n{\n    public partial int Prop { get; set; } = 1;\n    public partial int Prop { get => field; set => field = value; } = 2;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ReadOnlySpan<T> Structure\nDESCRIPTION: Implementation of a readonly ref struct for ReadOnlySpan<T> with basic initialization and storage of a reference and length.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_45\n\nLANGUAGE: c#\nCODE:\n```\npublic readonly ref struct ReadOnlySpan<T>\n{\n    readonly ref readonly T _value;\n    readonly int _length;\n\n    public ReadOnlySpan(in T value)\n    {\n        _value = ref value;\n        _length = 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Range Example in C#\nDESCRIPTION: Demonstrates the evaluation order and side effects when using Range operations with a custom Collection class. Shows how Length property access and Slice method are called.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nclass Collection {\n    private int[] _array = new[] { 1, 2, 3 };\n\n    public int Length {\n        get {\n            Console.Write(\"Length \");\n            return _array.Length;\n        }\n    }\n\n    public int[] Slice(int start, int length) {\n        var slice = new int[length];\n        Array.Copy(_array, start, slice, 0, length);\n        return slice;\n    }\n}\n\nclass SideEffect {\n    Collection Get() {\n        Console.Write(\"Get \");\n        return new Collection();\n    }\n\n    void Use() {\n        var array = Get()[0..2];\n        Console.WriteLine(array.Length);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic String to UTF8 Byte Sequence Conversions in C#\nDESCRIPTION: Examples of implicit conversions from string constants to byte[], Span<byte>, and ReadOnlySpan<byte> with UTF8 encoding.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nbyte[] array = \"hello\";             // new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f }\nSpan<byte> span = \"dog\";            // new byte[] { 0x64, 0x6f, 0x67 }\nReadOnlySpan<byte> span = \"cat\";    // new byte[] { 0x63, 0x61, 0x74 }\n```\n\n----------------------------------------\n\nTITLE: Efficient List Initialization with CollectionsMarshal in C#\nDESCRIPTION: Example of using the proposed CollectionsMarshal.Create method for efficient List<T> initialization with collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nList<int> list = [1, 2, 3]; // equivalent to:\nCollectionsMarshal.Create<int>(capacity: 3, out List<int> list, out Span<T> __storage);\n__storage[0] = 1;\n__storage[1] = 2;\n__storage[2] = 3;\n```\n\n----------------------------------------\n\nTITLE: Defining Shift Left Operators in C#\nDESCRIPTION: This snippet defines the left shift operator for nint and nuint types, allowing for bitwise left shifting. Dependencies include a basic understanding of nint and nuint types. The operator takes two parameters: 'x' (the value to shift) and 'count' (the number of bits to shift).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnint operator <<(nint x, int count);\n    nuint operator <<(nuint x, int count);\n```\n\n----------------------------------------\n\nTITLE: Constructing Dictionary Types with Arguments in C#\nDESCRIPTION: Shows how dictionary interface types are constructed using collection expressions with different arguments, demonstrating overload resolution for various interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nIDictionary<string, int> d;\nIReadOnlyDictionary<string, int> r;\n\nd = [with(StringComparer.Ordinal)]; // new Dictionary<string, int>(StringComparer.Ordinal)\nr = [with(StringComparer.Ordinal)]; // new $PrivateImpl<string, int>(StringComparer.Ordinal)\n\nd = [with(capacity: 2)]; // new Dictionary<string, int>(capacity: 2)\nr = [with(capacity: 2)]; // error: 'capacity' parameter not recognized\n```\n\n----------------------------------------\n\nTITLE: Demonstrating FirstOrDefault Return Type with T?\nDESCRIPTION: Example of how T? could be used to express the return type of FirstOrDefault method, showing how it would better represent nullable behavior when T is instantiated with non-nullable reference types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-25.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic T? FirstOrDefault<T>(this IEnumerable<T> src);\n```\n\n----------------------------------------\n\nTITLE: Definite Assignment Error in Record Struct Primary Constructor\nDESCRIPTION: Example showing a definite assignment error in a record struct primary constructor. The error occurs because the property X is initialized with the parameter X before the backing field x is properly assigned.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nrecord struct Pos(int X) // definite assignment error in primary constructor\n{\n    private int x;\n    public int X { get { return x; } set { x = value; } } = X;\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Construction API Pattern with CollectionLiteralBuilder Attribute\nDESCRIPTION: Demonstrates a proposed API pattern for creating collections with contiguous backing storage using an attribute to specify a creation method\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-05-26.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionLiteralBuilder(\n    typeof(CollectionsMarshal),\n    nameof(CollectionsMarshal.CreateUnsafe))]\npublic class MyCollection<T> : IEnumerable<T> { }\n\npublic static class CollectionsMarshal\n{\n    public static void CreateUnsafe<T>(\n        int capacity,\n        out MyCollection<T> collection,\n        out Span<T> storage);\n\n    public static void CreateUnsafe<T>(\n        int capacity,\n        out List<T> collection,\n        out Span<T> storage);\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient Byte Conversion with Unmanaged Constraint in C#\nDESCRIPTION: Implementation of a generic method that converts an unmanaged type to a span of bytes, demonstrating the allocation-free, compile-time safe operations that the constraint enables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/blittable.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<byte> Convert<T>(ref T value) where T : unmanaged \n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Global Using Directives in C#\nDESCRIPTION: This snippet provides the extended syntax of using directives by introducing an optional 'global' keyword that can be used in compilation units in C#. Global using directives can only be used at the compilation unit level and must precede any normal using directives. They ensure that the specified namespace or type is globally available to all compilation units within the program.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/GlobalUsingDirective.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\ncompilation_unit\n    : extern_alias_directive* global_using_directive* using_directive* global_attributes? namespace_member_declaration*\n    ;\n\nglobal_using_directive\n    : global_using_alias_directive\n    | global_using_namespace_directive\n    | global_using_static_directive\n    ;\n\nglobal_using_alias_directive\n    : 'global' 'using' identifier '=' namespace_or_type_name ';'\n    ;\n\nglobal_using_namespace_directive\n    : 'global' 'using' namespace_name ';'\n    ;\n    \nglobal_using_static_directive\n    : 'global' 'using' 'static' type_name ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Empty Collection Singleton Examples\nDESCRIPTION: Demonstrates various uses of empty collection literals with different collection types and mutability requirements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Can be a singleton, like Array.Empty<int>()\nint[] x = []; \n\n// Can be a singleton. Allowed to use Array.Empty<int>(), Enumerable.Empty<int>(),\n// or any other implementation that can not be mutated.\nIEnumerable<int> y = [];\n\n// Must not be a singleton.  Value must be allowed to mutate, and should not mutate\n// other references elsewhere.\nList<int> z = [];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lambda Capture of field Keyword in C# Property\nDESCRIPTION: This snippet shows how the 'field' keyword can be captured in a lambda expression within a property getter. It demonstrates that 'field' can be used even when there are no other references to it.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public static int P\n    {\n        get\n        {\n            Func<int> f = static () => field;\n            return f();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Type Inference Example\nDESCRIPTION: Demonstrates different scenarios of lambda parameter and return type inference in method calls, showing how explicit type annotations affect type inference behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-21.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void F<T>(Func<T, T> f) { ... }\n\nF((int i) => i); // ok (in C# 9 and 10)\nF(i => i);       // error (in C# 9 and 10)\nF(int (i) => i); // what should the behavior in C# 10 be?\n```\n\n----------------------------------------\n\nTITLE: Instance method overload resolution example\nDESCRIPTION: This example demonstrates how the compiler resolves overloads of instance methods.  The compiler prefers methods defined in the derived class over those in the base class when both are applicable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\"new Derived().M(new Derived()); // Derived.M\\n\\npublic class Base \\n{\\n    public void M(Derived d) { }\\n}\\n\\npublic class Derived : Base \\n{\\n    public void M(Base b) { }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: List Pattern Exhaustiveness Example\nDESCRIPTION: Example demonstrating complex list pattern matching scenarios with exhaustiveness checking, including patterns with ranges and multiple conditions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-07.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n_ = list switch\n{\n    { .., >= 0 } => 1,\n    { < 0 } => 2,\n    { Count: <= 0 or > 1 } => 3,\n};\n```\n\n----------------------------------------\n\nTITLE: Complex Null Conditional Assignment Examples\nDESCRIPTION: Shows advanced scenarios including ref returns, chained null-conditional operators, and null-coalescing assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/null-conditional-assignment.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    ref int M() => /*...*/;\n}\n\nvoid M1(C? c)\n{\n    c?.M() = 42; // equivalent to:\n    if (c is not null)\n        c.M() = 42;\n}\n\nint? M2(C? c)\n{\n    return c?.M() = 42; // equivalent to:\n    return c is null ? (int?)null : c.M() = 42;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a ref struct with lifetime parameters in C#\nDESCRIPTION: This snippet demonstrates how to define a ref struct with explicit lifetime parameters, including the special $this lifetime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S<out $this, $a> \n```\n\n----------------------------------------\n\nTITLE: Implicit Coercion to Union Type in C#\nDESCRIPTION: Demonstrates how a value can be implicitly coerced to a union type when an implicit coercion exists from that value to one of the union's member types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n(string or double) value = 10;\n```\n\n----------------------------------------\n\nTITLE: Recursive Pattern Matching in C# with Nested Object Structure\nDESCRIPTION: This snippet demonstrates a more advanced pattern matching syntax using recursive T { ... } patterns. It shows how the pattern can match the nested structure of the object being tested.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nif (s is ExpressionStatement {\n        Expr is AssignmentExpressionSyntax {\n            Left is IdentifierName { Name is val l },\n            Right is IdentifierName { Name is val r } } }\n    && l.name = r.name) ...\n```\n\n----------------------------------------\n\nTITLE: Error for Implicit Initialization with Manual Setter\nDESCRIPTION: Shows the error generated when a struct has semi-auto properties with manual implementations and implicit initialization is not desired, prompting the user to manually handle field initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/auto-default-structs.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstruct S\n{\n    public int X\n    {\n        get => field;\n        set => field = field < value ? value : field;\n    }\n\n    public S() // error: backing field of 'S.X' is implicitly initialized to 'default'.\n    {\n        X = 1;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Partial Events and Constructors in C#\nDESCRIPTION: Example of declaring partial events and constructors in a C# class, showing both the declaration and implementation parts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/partial-events-and-constructors.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npartial class C\n{\n    partial C(int x, string y);\n    partial event Action<int, string> MyEvent;\n}\n\npartial class C\n{\n    partial C(int x, string y) { }\n    partial event Action<int, string> MyEvent\n    {\n        add { }\n        remove { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Example with Nullable Types\nDESCRIPTION: Demonstrates type inference behavior with nullable reference types and conditionals, showing how nullability is propagated through different scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring? n = \"world\";\nvar x = b ? \"Hello\" : n; // string?\nvar y = b ? \"Hello\" : null; // string? or error\nvar z = b ? 7 : null; // Error today, could be int?\n```\n\n----------------------------------------\n\nTITLE: Basic Range Operator Usage Example\nDESCRIPTION: Demonstrates basic array slicing with the range operator syntax in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-22.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar numbers = ints[from..to];\n```\n\n----------------------------------------\n\nTITLE: Declaring Extension Operators (C#)\nDESCRIPTION: Demonstrates how to declare extension operators within an extension declaration, allowing for type parameters and constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TElement>(IEnumerable<TElement>) where TElement : INumber<TElement>\n    {\n        public static IEnumerable<TElement> operator *(IEnumerable<TElement> vector, TElement scalar) { ... }\n        public static IEnumerable<TElement> operator *(TElement scalar, IEnumerable<TElement> vector) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Iterator with Cancellation Attribute in C#\nDESCRIPTION: Example showing proposed syntax for specifying cancellation token parameter with attribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-28.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nIAsyncEnumerable<int> M(..., [Cancellation]CancellationToken token = default)\n```\n\n----------------------------------------\n\nTITLE: Array Nullability Covariance Example in C#\nDESCRIPTION: Example showing array assignment between nullable and non-nullable types demonstrating covariance behavior\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-04.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\narrayOfNullable = arrayOfNonNullable; // warning\n```\n\n----------------------------------------\n\nTITLE: Expression-Bodied Indexer in C#\nDESCRIPTION: Demonstrates using expression-bodied syntax for implementing an indexer property. This provides a concise way to define a getter-only indexer that returns a value based on the index parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-11-04.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic Customer this[Id id] => store.LookupCustomer(id);\n```\n\n----------------------------------------\n\nTITLE: Collection Pattern Syntax Proposals in C#\nDESCRIPTION: Different proposed syntaxes for collection pattern matching, including empty collection checks and length-based patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-14.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nint[] and []                    // Empty array pattern\nint[] { [1, 2, 3] }           // Nested brackets pattern\n{ 1, 2, 3 }                   // Curly brace pattern\nint[] [0]                     // Length test pattern\n[>= 0 and < 256] { 1, 2, .. } // Combined length and content pattern\nMyType { Property: a } [10] { 1, 2, 3, .. } // Complex pattern\n```\n\n----------------------------------------\n\nTITLE: Null Coalescing Assignment Semantics\nDESCRIPTION: Shows the actual semantic implementation of the null coalescing assignment operator, where assignment is only performed if x is null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-16.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n(x ?? (x = y))\n```\n\n----------------------------------------\n\nTITLE: Partial Method Call Erasure Example in C#\nDESCRIPTION: Shows how partial method calls are erased at compile time when no implementation is provided.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npartial class D\n{\n    partial void M(string message);\n\n    void Example()\n    {\n        M(GetIt()); // Call to M and GetIt erased at compile time\n    }\n\n    string GetIt() => \"Hello World\";\n}\n```\n\n----------------------------------------\n\nTITLE: Default Interface Methods with Private Method in C#\nDESCRIPTION: This snippet illustrates how default interface methods interact with private methods in derived classes, showing consistency with the previous example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M() { }\n}\nclass Derived: IA // OK, all interface members have a concrete most specific override\n{\n    private void M() { } // method unrelated to 'IA.M' because private\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging with Custom Handler\nDESCRIPTION: Complete example showing the implementation of a logging system using the new interpolated string handler functionality with custom argument values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/interpolated-string-handler-argument-value.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Original code\nvar someOperation = RunOperation();\nILogger logger = CreateLogger(LogLevel.Error, ...);\nlogger.LogWarn($\"Operation was null: {operation is null}\");\n\n// Approximate translated code:\nvar someOperation = RunOperation();\nILogger logger = CreateLogger(LogLevel.Error, ...);\nvar loggingInterpolatedStringHandler = new LoggingInterpolatedStringHandler(20, 1, logger, LogLevel.Warn, out bool continueBuilding);\nif (continueBuilding)\n{\n    loggingInterpolatedStringHandler.AppendLiteral(\"Operation was null: \");\n    loggingInterpolatedStringHandler.AppendFormatted(operation is null);\n}\nLoggingExtensions.LogWarn(logger, loggingInterpolatedStringHandler);\n\n\n// Helper libraries\nnamespace Microsoft.Extensions.Logging;\n{\n    using System.Runtime.CompilerServices;\n\n    [InterpolatedStringHandler]\n    public struct LoggingInterpolatedStringHandler\n    {\n        public LoggingInterpolatedStringHandler(int literalLength, int formattedCount, ILogger logger, LogLevel logLevel, out bool continueBuilding)\n        {\n            if (logLevel < logger.LogLevel)\n            {\n                continueBuilding = false;\n            }\n            else\n            {\n                continueBuilding = true;\n                // Set up the rest of the builder\n            }\n        }\n    }\n    public static class LoggerExtensions\n    {\n        public static void LogWarn(\n            this ILogger logger,\n            [InterpolatedStringHandlerArgument(nameof(logger))]\n            [InterpolatedStringHandlerArgumentValue(LogLevel.Warn)]\n            ref LogInterpolatedStringHandler message);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Parameter Annotation in C#\nDESCRIPTION: Example showing method parameter annotation with nullable and non-nullable string types. Used to illustrate the behavior when only partial nullable annotations are used.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-29.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string arg1, string? arg2)\n```\n\n----------------------------------------\n\nTITLE: Inheritance With Constructor Pattern in C#\nDESCRIPTION: Demonstrates implementing With constructors in an inheritance hierarchy with covariant return types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nclass Base\n{\n    ...\n    protected Base(Base original)\n    {\n        // validation\n    }\n    [WithConstructor]\n    public virtual Base With() => new Base(this);\n}\nclass Derived : Base\n{\n    ...\n    protected Derived(Derived original)\n    : base(original)\n    {\n        // validation\n    }\n    [WithConstructor]\n    public override Derived With() => new Derived(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'with' Expressions with Records in C#\nDESCRIPTION: Examples showing how 'with' expressions work with records, allowing for non-destructive mutation. The example demonstrates creating a new Point with only the Y value changed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Notes.md#2025-04-21_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nstruct Point(int X, int Y);\nPoint p = ...\np with { Y = 4 }\n```\n\n----------------------------------------\n\nTITLE: Constructing Collections with KeyValuePair Iteration Type in C#\nDESCRIPTION: This snippet describes the process of constructing collections when the iteration type is KeyValuePair<K, V>. It covers scenarios for both indexer-based and Add method-based constructions, handling key-value pair elements, expression elements, and spread elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n// Pseudo-code representation of the construction process\n\n// For indexer-based construction:\nforeach (var element in collectionExpression)\n{\n    if (element is KeyValuePairElement)\n    {\n        var key = EvaluateKey(element);\n        var value = EvaluateValue(element);\n        collection[key] = value;\n    }\n    else if (element is ExpressionElement)\n    {\n        if (CanConvertToKeyValuePair(element))\n        {\n            var kvp = ConvertToKeyValuePair(element);\n            collection[kvp.Key] = kvp.Value;\n        }\n        else\n        {\n            var kvp = (KeyValuePair<K, V>)element;\n            collection[ConvertKey(kvp.Key)] = ConvertValue(kvp.Value);\n        }\n    }\n    else if (element is SpreadElement)\n    {\n        foreach (var item in GetEnumerator(element))\n        {\n            if (CanConvertToKeyValuePair(item))\n            {\n                var kvp = ConvertToKeyValuePair(item);\n                collection[kvp.Key] = kvp.Value;\n            }\n            else\n            {\n                var kvp = (KeyValuePair<K, V>)item;\n                collection[ConvertKey(kvp.Key)] = ConvertValue(kvp.Value);\n            }\n        }\n    }\n}\n\n// For Add method-based construction:\nforeach (var element in collectionExpression)\n{\n    if (element is KeyValuePairElement)\n    {\n        var key = EvaluateKey(element);\n        var value = EvaluateValue(element);\n        collection.Add(new KeyValuePair<K, V>(ConvertKey(key), ConvertValue(value)));\n    }\n    else if (element is ExpressionElement)\n    {\n        if (CanConvertToKeyValuePair(element))\n        {\n            collection.Add((KeyValuePair<K, V>)element);\n        }\n        else\n        {\n            var kvp = (KeyValuePair<K, V>)element;\n            collection.Add(new KeyValuePair<K, V>(ConvertKey(kvp.Key), ConvertValue(kvp.Value)));\n        }\n    }\n    else if (element is SpreadElement)\n    {\n        foreach (var item in GetEnumerator(element))\n        {\n            if (CanConvertToKeyValuePair(item))\n            {\n                collection.Add((KeyValuePair<K, V>)item);\n            }\n            else\n            {\n                var kvp = (KeyValuePair<K, V>)item;\n                collection.Add(new KeyValuePair<K, V>(ConvertKey(kvp.Key), ConvertValue(kvp.Value)));\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with ReadOnlySpan<char> in C#\nDESCRIPTION: This code snippet demonstrates how to use pattern matching with ReadOnlySpan<char> to check if its value matches a constant string. It returns true if the pattern matches the constant string '123'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/pattern-match-span-of-char-on-string.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic bool Is123(ReadOnlySpan<char> s)\n{\n    return s is \"123\";\n}\n```\n\n----------------------------------------\n\nTITLE: Not Pattern Matching with Type Check in C#\nDESCRIPTION: Example showing the proposed 'not' pattern matching syntax for type checking with variable declaration and scoping.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-03-19.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nif (x is not string s) { ... }\nelse { ... /* s */ }\n```\n\n----------------------------------------\n\nTITLE: Initializing IReadOnlyDictionary with Collection Literal in C#\nDESCRIPTION: Example of initializing an IReadOnlyDictionary<TKey, TValue> interface type using a collection literal, showing potential implementation details.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nIReadOnlyDictionary<string, int> nameToAge = [ \"Dustin\": 42, \"Cyrus\": 43 ]; // possibly equivalent to:\nIReadOnlyDictionary<string, int> nameToAge = new Dictionary<string, int> { { \"Dustin\", 42 }, { \"Cyrus\", 43 } }; \n```\n\n----------------------------------------\n\nTITLE: Demonstrating Diamond Inheritance with Classes and Interfaces (C#)\nDESCRIPTION: Example illustrating diamond inheritance scenario involving both classes and interfaces, demonstrating how the most specific override is determined.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M();\n}\ninterface IB : IA\n{\n    override void M() { WriteLine(\"IB\"); }\n}\nclass Base : IA\n{\n    void IA.M() { WriteLine(\"Base\"); }\n}\nclass Derived : Base, IB // allowed?\n{\n    static void Main()\n    {\n        IA a = new Derived();\n        a.M();           // what does it do?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar Update for Partial Properties in C#\nDESCRIPTION: Proposed grammar update for property declarations to add optional 'partial' modifier, similar to method and class declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nproperty_declaration\n-    : attributes? property_modifier* type member_name property_body\n+    : attributes? property_modifier* 'partial'? type member_name property_body\n    ;  \n```\n\n----------------------------------------\n\nTITLE: Interface Definition with Tuple Parameters in C#\nDESCRIPTION: Example showing an interface declaration with a tuple parameter that demonstrates compatibility issues between C# 6.0 and 7.0 implementations. The method takes a tuple with named elements 'a' and 'b'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-28.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IUtil\n{\n    void M((int a, int b) x);\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Equality Comparison Example\nDESCRIPTION: Example demonstrating tuple equality comparison syntax with mixed numeric types, showing how equality should work across different numeric types like int and byte.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-21.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n(i1, i2) == (b1, b2)\n```\n\n----------------------------------------\n\nTITLE: Flow Control Without Variable Usage - C#\nDESCRIPTION: Shows flow control case where using variable is never read but lifetime management is still relevant.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-09.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n{\n    goto target;\n    using var x = new FileStream(...);\ntarget:\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Generic Attribute Usage Example\nDESCRIPTION: Demonstrates scenarios where generic attributes cannot be used due to type parameter restrictions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/generic-attributes.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\n\npublic class Attr<T1> : Attribute { }\n\npublic class Program<T2>\n{\n    [Attr<T2>] // error\n    [Attr<List<T2>>] // error\n    void M() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Field Initialization Warning\nDESCRIPTION: Demonstrates how a warning is issued for implicit initialization of struct fields to default values, which can be escalated to an error through diagnostics settings for users preferring pre-C# 11 behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/auto-default-structs.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstruct S\n{\n    int x;\n    public S() // warning: 'S.x' is implicitly initialized to 'default'.\n    {\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Ref Ternary Expression for Parameter Passing in C#\nDESCRIPTION: Examples of using ref ternary expressions to pass or return references conditionally. The syntax ensures only the relevant path is evaluated based on the condition.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n// pass by reference\nfoo(ref (arr != null ? ref arr[0]: ref otherArr[0]));\n\n// return by reference\nreturn ref (arr != null ? ref arr[0]: ref otherArr[0]);\n```\n\n----------------------------------------\n\nTITLE: Exploring Property Pattern Syntax in C#\nDESCRIPTION: Presents different syntax options for property patterns in C#, comparing the use of colons, equals signs, and 'is' keyword for pattern matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-30.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nif (e is { Name: \"Mads\", Employer: { ID: string id } }) { WriteLine(id); }\n```\n\nLANGUAGE: c#\nCODE:\n```\nif (e is { Name = \"Mads\", Employer = { ID = string id } }) { WriteLine(id); }\n```\n\nLANGUAGE: c#\nCODE:\n```\nif (e is { Name == \"Mads\", Employer == { ID == string id } }) { WriteLine(id); }\n```\n\nLANGUAGE: c#\nCODE:\n```\nif (e is { Name is \"Mads\", Employer is { ID is string id } }) { WriteLine(id); }\n```\n\n----------------------------------------\n\nTITLE: Implementing 'ref readonly' Returns in C# for Immutable Arrays\nDESCRIPTION: Demonstrates how to use 'ref readonly' returns to efficiently return readonly references to array elements in an immutable array structure.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nstruct ImmutableArray<T>\n{\n    private readonly T[] array;\n\n    public ref readonly T ItemRef(int i)\n    {\n        // returning a readonly reference to an array element\n        return ref this.array[i];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Malformed UTF-16 String in UTF-8 Literal\nDESCRIPTION: This example highlights the error handling of malformed UTF-16 input strings when using the `u8` suffix. The compiler will emit an error for invalid UTF-16 sequences.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n\"var bytes = \\\"hello \\\\uD8\\\\uD8\\\"u8; // Error: malformed UTF16 input string\n\nvar bytes2 = \\\"hello \\\\uD801\\\\uD802\\\"u8; // Allowed: invalid UTF16 values, but it's correctly formed.\"\n```\n\n----------------------------------------\n\nTITLE: Implementing ref struct Fields with Deserializer Example in C#\nDESCRIPTION: Shows usage of ref scoped fields within a ref struct type, demonstrating field access restrictions and escape prevention.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nref struct Deserializer\n{\n    ref scoped Utf8JsonReader reader;\n\n    ReadOnlySpan<byte> M1()\n    {\n        // okay: implicitly scoped to current method\n        var span = reader.ValueSpan; \n\n        // okay\n        reader.Skip();\n\n        // Error: can't escape the ref data the ref scoped field refers to\n        return reader.ValueSpan;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Actions in ASP.NET with Natural Types\nDESCRIPTION: Illustrates how the proposed changes to lambda expressions and method groups allow MapAction to accept method groups directly without explicit delegate type declaration, simplifying code structure.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[HttpGet(\"/\")] Todo GetTodo() => new(Id: 0, Name: \"Name\");\napp.MapAction(GetTodo);\n\n[HttpPost(\"/\")] Todo PostTodo([FromBody] Todo todo) => todo;\napp.MapAction(PostTodo);\n```\n\n----------------------------------------\n\nTITLE: Implementing System.Index Structure\nDESCRIPTION: Definition of the System.Index structure required for the hat operator (^) implementation. Includes constructor for creating indices from either end of a collection.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System\n{\n    public readonly struct Index\n    {\n        public Index(int value, bool fromEnd);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Switch Expression in C#\nDESCRIPTION: Example showing pattern matching using switch expressions to determine state transitions based on current state, action and key status.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-04.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar newState = (GetState(), action, hasKey) switch {\n    (DoorState.Closed, Action.Open, _) => DoorState.Opened,\n    (DoorState.Opened, Action.Close, _) => DoorState.Closed,\n    (DoorState.Closed, Action.Lock, true) => DoorState.Locked,\n    (DoorState.Locked, Action.Unlock, true) => DoorState.Closed,\n    var (state, _, _) => state };\n```\n\n----------------------------------------\n\nTITLE: Extension Method with CallerArgumentExpression in C#\nDESCRIPTION: This code snippet demonstrates how the CallerArgumentExpression attribute can be used with the 'this' parameter of an extension method. It captures the expression corresponding to the object before the dot.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\npublic static void ShouldBe<T>(this T @this, T expected, [CallerArgumentExpression(\"this\")] string thisExpression = null) {}\n\ncontestant.Points.ShouldBe(1337); // thisExpression: \"contestant.Points\"\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Proposed Nullable Analysis in C# Constructor\nDESCRIPTION: This snippet illustrates the behavior of the proposed approach for nullable constructor analysis. It shows how warnings are generated for null assignments and potential null states at constructor exit points.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-constructor-analysis.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public string Prop { get; set; }\n    public C()\n    {\n        Prop = null; // Warning: cannot assign null to 'Prop'\n    } // Warning: Prop may be null when exiting 'C.C()'\n    \n    // This is consistent with currently shipped behavior:\n    [MemberNotNull(nameof(Prop))]\n    void M()\n    {\n        Prop = null; // Warning: cannot assign null to 'Prop'\n    } // Warning: Prop may be null when exiting 'C.M()'\n}\n```\n\n----------------------------------------\n\nTITLE: Array Reverse Method Breaking Change Example\nDESCRIPTION: Demonstrates the breaking change when calling Reverse() on arrays, where the method now binds to MemoryExtensions.Reverse instead of Enumerable.Reverse, requiring a workaround.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(int[] a)\n{\n    foreach (var x in a.Reverse()) { } // fine previously, an error now (`Reverse` returns `void`)\n    foreach (var x in Enumerable.Reverse(a)) { } // workaround\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Method Usage with Span Types in C#\nDESCRIPTION: Demonstrates how the new span conversions enable extension methods to work with arrays and Span types without requiring explicit overloads. Shows StartsWith extension method working with array types through implicit span conversion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint[] arr = [1, 2, 3];\nConsole.WriteLine(\n    arr.StartsWith(1) // CS8773 in C# 13, permitted with this proposal\n    );\n\npublic static class MemoryExtensions\n{\n    public static bool StartsWith<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T> => span.Length != 0 && EqualityComparer<T>.Default.Equals(span[0], value);\n}\n```\n\n----------------------------------------\n\nTITLE: List Pattern Lowering Example\nDESCRIPTION: Demonstrates how a simple list pattern is transformed into equivalent index-based matching code\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/list-patterns.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nexpr is [1, 2, 3]\n// Equivalent to:\nexpr.Length is 3\n&& expr[new Index(0, fromEnd: false)] is 1\n&& expr[new Index(1, fromEnd: false)] is 2\n&& expr[new Index(2, fromEnd: false)] is 3\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Reference Types and Type Parameters in C# ANTLR Grammar\nDESCRIPTION: ANTLR grammar rules for defining nullable reference types and type parameters in C#. This includes modifications to existing type productions and new productions for nullable reference types and type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ntype\n    : value_type\n    | reference_type\n    | nullable_type_parameter\n    | type_parameter\n    | type_unsafe\n    ;\n\nreference_type\n    : ...\n    | nullable_reference_type\n    ;\n\nnullable_reference_type\n    : non_nullable_reference_type '?'\n    ;\n\nnon_nullable_reference_type\n    : reference_type\n    ;\n\nnullable_type_parameter\n    : non_nullable_non_value_type_parameter '?'\n    ;\n\nnon_nullable_non_value_type_parameter\n    : type_parameter\n    ;\n```\n\n----------------------------------------\n\nTITLE: Antlr Grammar for Record Struct Declaration\nDESCRIPTION: This snippet defines the Antlr grammar rule for declaring a record struct in C#. It specifies the required keywords ('record', 'struct'), identifier, optional type parameters, parameter list, interfaces, constraints, and the body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\n\"record_struct_declaration\\n    : attributes? struct_modifier* 'partial'? 'record' 'struct' identifier type_parameter_list?\\n      parameter_list? struct_interfaces? type_parameter_constraints_clause* record_struct_body\\n    ;\\n\\nrecord_struct_body\\n    : struct_body\\n    | ';'\\n    ;\"\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Overload Resolution Examples in C#\nDESCRIPTION: Shows various cases of overload resolution with collection expressions and params parameters, including type conversion scenarios and ambiguity cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static void Test1()\n    {\n        M1(['1', '2', '3']); // IEnumerable<char> overload is used because `char` is an exact match\n        M1('1', '2', '3');   // IEnumerable<char> overload is used because `char` is an exact match\n    }\n\n    static void M1(params IEnumerable<char> value) {}\n    static void M1(params System.ReadOnlySpan<MyChar> value) {}\n\n    class MyChar\n    {\n        private readonly int _i;\n        public MyChar(int i) { _i = i; }\n        public static implicit operator MyChar(int i) => new MyChar(i);\n        public static implicit operator char(MyChar c) => (char)c._i;\n    }\n\n    static void Test2()\n    {\n        M2([1]); // Span overload is used\n        M2(1);   // Array overload is used, not generic\n    }\n\n    static void M2<T>(params System.Span<T> y){}\n    static void M2(params int[] y){}\n\n    static void Test3()\n    {\n        M3(\"3\", [\"4\"]); // Ambiguity, better-ness of argument conversions goes in opposite directions.\n        M3(\"3\", \"4\");   // Ambiguity, better-ness of argument conversions goes in opposite directions.\n                        // Since parameter types are different (\"object, string\" vs. \"string, object\"), tie-breaking rules do not apply\n    }\n\n    static void M3(object x, params string[] y) {}\n    static void M3(string x, params Span<object> y) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deconstruction with Extension Method in C#\nDESCRIPTION: Example showing how to implement a deconstructor as an extension method, allowing existing types to be augmented with deconstruction capability without modifying their source code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-05-03-04.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class Extensions\n{\n    public static void Deconstruct(this Name name, out string first, out string last) { first = name.First; last = name.Last; }\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple and Deconstruction Examples\nDESCRIPTION: Examples showing tuple literals and deconstruction with generic types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n(A < B, C > D, E < F, G > H)\n(A<B,C> D, E<F,G> H) = e;\n```\n\n----------------------------------------\n\nTITLE: Implementing ImmutableHashSet with ReadOnlySpan<T> in C#\nDESCRIPTION: This code snippet showcases the implementation of ImmutableHashSet using a ReadOnlySpan<T> as input. The CollectionBuilderAttribute is used to specify the factory method that constructs the collection instance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionBuilder(typeof(ImmutableHashSet), \"Create\")]\npublic class ImmutableHashSet<T> { /*...*/ }\n\npublic static class ImmutableHashSet\n{\n    public static ImmutableHashSet<T> Create<T>(ReadOnlySpan<T> values);\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Tuples in C#\nDESCRIPTION: Shows how to unpack a tuple's values into individual variables, allowing direct access to the components without using the tuple variable as an intermediary.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\n(var sum, var count) = Tally(myValues); // deconstruct result\nConsole.WriteLine($\"Sum: {sum}, count: {count}\");\n```\n\n----------------------------------------\n\nTITLE: Defining Constants Using Interpolated Strings\nDESCRIPTION: This code snippet illustrates the proposed change allowing interpolated strings to be defined as constants. It highlights how interpolated strings would be implemented in C# constants and the benefits of such changes. The snippet requires C# 6.0 or higher for string interpolation functionality.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/constant_interpolated_strings.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    const string S1 = $\"Hello world\";\n    const string S2 = $\"Hello{\" \"}World\";\n    const string S3 = $\"{S1} Kevin, welcome to the team!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Nullable and Non-Nullable Reference Types in C#\nDESCRIPTION: Example showing method declaration using the proposed nullable and non-nullable reference type syntax. The method takes a non-null string parameter and returns a potentially null string.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-10-17.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    string? M(string! s) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Primary Constructor Parameter Shadowing in C#\nDESCRIPTION: Shows how primary constructor parameters can be shadowed by fields, potentially causing confusion with parameter vs field references.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-10-17.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass C(int i)\n{\n    protected int i = i; // References parameter\n    public int I => i; // References field\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Literal Spread Example\nDESCRIPTION: Demonstrates proposed spread operator (..) usage in collection literals for C#. The syntax is under discussion as it may conflict with range expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-04-03.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar list = [1, 2, ..existingList, 3, 4];\n```\n\n----------------------------------------\n\nTITLE: Using Tuples for Immutable Object Values in C#\nDESCRIPTION: Shows how tuples could be used as the value type for immutable objects, simplifying the class structure and providing built-in support for deconstruction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person \n{\n\tpublic readonly (string Name, int Age) Value; // a tuple\n\tpublic Person((string Name, int Age) value) { Value = value; }\n\tâ€¦\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Result Union Type in C#\nDESCRIPTION: Demonstrates usage of the Result union type including creation and pattern matching with switch expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\nResult<string, string> x = Success(\"hurray!\");\nResult<string, string> y = Failure(\"boo\");\n\nswitch (x)\n{\n    case Success(var value): ...;\n    case Failure(var error): ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Duplicate Method Requirements Without Unmanaged Constraint in C#\nDESCRIPTION: Code snippet showing the current approach where developers must write duplicate methods for each unmanaged type they want to support, illustrating the problem the unmanaged constraint aims to solve.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/blittable.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint Hash(Point point) { ... } \nint Hash(TimeSpan timeSpan) { ... } \n```\n\n----------------------------------------\n\nTITLE: Lambda Direct Invocation Examples in C#\nDESCRIPTION: Examples showing different patterns of lambda direct invocation, including variable assignment and immediate execution scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-05-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// If this works\nvar zeroF = (int x) => x;\nvar zero = zeroF(0);\n\n// This should also work\nvar zero = ((int x) => x)(0);\n\n// But this wouldn't work with var, so is it fine to have not work here?\nvar zero = (x => x)(0);\n```\n\n----------------------------------------\n\nTITLE: AsyncEnumerableExtensions Implementation\nDESCRIPTION: Complete implementation of the ConfigureAwait extension methods for async enumeration, including supporting types and structures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Threading.Tasks\n{\n    public static class AsyncEnumerableExtensions\n    {\n        public static ConfiguredAsyncEnumerable<T> ConfigureAwait<T>(this IAsyncEnumerable<T> enumerable, bool continueOnCapturedContext) =>\n            new ConfiguredAsyncEnumerable<T>(enumerable, continueOnCapturedContext);\n\n        public struct ConfiguredAsyncEnumerable<T>\n        {\n            private readonly IAsyncEnumerable<T> _enumerable;\n            private readonly bool _continueOnCapturedContext;\n\n            internal ConfiguredAsyncEnumerable(IAsyncEnumerable<T> enumerable, bool continueOnCapturedContext)\n            {\n                _enumerable = enumerable;\n                _continueOnCapturedContext = continueOnCapturedContext;\n            }\n\n            public ConfiguredAsyncEnumerator<T> GetAsyncEnumerator() =>\n                new ConfiguredAsyncEnumerator<T>(_enumerable.GetAsyncEnumerator(), _continueOnCapturedContext);\n\n            public struct ConfiguredAsyncEnumerator<T>\n            {\n                private readonly IAsyncEnumerator<T> _enumerator;\n                private readonly bool _continueOnCapturedContext;\n\n                internal ConfiguredAsyncEnumerator(IAsyncEnumerator<T> enumerator, bool continueOnCapturedContext)\n                {\n                    _enumerator = enumerator;\n                    _continueOnCapturedContext = continueOnCapturedContext;\n                }\n\n                public ConfiguredValueTaskAwaitable<bool> MoveNextAsync() =>\n                    _enumerator.MoveNextAsync().ConfigureAwait(_continueOnCapturedContext);\n\n                public T Current => _enumerator.Current;\n\n                public ConfiguredValueTaskAwaitable DisposeAsync() =>\n                    _enumerator.DisposeAsync().ConfigureAwait(_continueOnCapturedContext);\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lifetime Notation for Scoped References in C#\nDESCRIPTION: This snippet illustrates how the 'scoped' keyword is expressed using lifetime notation. It shows the relationship between the method's return value and its parameter lifetimes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/REF-2022-11-11.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<int> Read(scoped ref int i) {\n    ...\n}\n\n'b Span<int> Read('a ref 'b int i) {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Switch Statement in C#\nDESCRIPTION: Shows how to use pattern matching in a switch statement in C# 7. This approach allows for more concise and readable code when dealing with multiple type checks and conditions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-11-02-Design-Demo.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic string PrintedForm(Person p)\n{\n    switch (p)\n    {\n        case Student s when s.Gpa > 3.5 :\n            return $\"Honor Student {s.Name} ({s.Gpa})\";\n        case Student s :\n            return $\"Student {s.Name} ({s.Gpa})\";\n        case Teacher t :\n            return $\"Teacher {t.Name} of {t.Subject}\";\n        default :\n            return $\"Person {p.Name}\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: With Expression Usage in C#\nDESCRIPTION: Example of using the proposed with expression for creating modified copies of immutable objects.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar userInfo = new UserInfo() \n{\n    Username = \"andy\",\n    Email = \"angocke@microsoft.com\",\n    IsAdmin = true\n};\nvar newUserName = userInfo with { Username = \"angocke\" };\n```\n\n----------------------------------------\n\nTITLE: Defining Async Main Methods as Entry Points in C#\nDESCRIPTION: Shows the proposed signatures for async Main methods that can serve as program entry points. These methods return Task or Task<int> and can be used with or without command-line arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-28.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nTask Main();\nTask Main(string[] args);\nTask<int> Main();\nTask<int> Main(string[] args);\n```\n\n----------------------------------------\n\nTITLE: Prefer By-Value Parameter in C# Extension Methods\nDESCRIPTION: This snippet illustrates how to prefer an extension method with a by-value parameter over one with an `in` parameter. The example defines two extension methods named `P` for the `int` type, one taking an `in int` and the other taking an `int` by value, with the latter being preferred.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\n_ = 42.P;\n\npublic static class E\n{\n    extension(in int i)\n    {\n        public int P => throw null; \n    }\n    extension(int i) // better parameter-passing mode\n    {\n        public int P => 0;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Interface Properties with Auto-Accessors in C#\nDESCRIPTION: Shows different scenarios of implementing properties in interfaces with auto-accessors. Instance properties with field access result in errors while static properties can use the field keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I\n{\n           object P1 { get; set; }                           // ok: not an implementation\n           object P2 { get => field; set { field = value; }} // error: instance field\n\n           object P3 { get; set { } } // error: instance field\n    static object P4 { get; set { } } // ok: equivalent to { get => field; set { } }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Reference Type Dereference in C#\nDESCRIPTION: This snippet shows how dereferencing a nullable reference type affects its null state in different code paths. It illustrates the concept of split state after dereference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-08-20.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ntry\n{\n    string? x = y;\n    var z = x.Substring(1);\n    ...\n}\ncatch\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating cyclic self-assignment problem with lifetimes in C#\nDESCRIPTION: This example shows how the lifetime model helps identify and prevent cyclic self-assignment issues in ref structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S<out $this>\n{\n    int field;\n    ref<$this> int refField;\n\n    static void SelfAssign<$ro, $cm>(ref<$ro> S<$cm> s)\n    {\n        // error: the types work out here to ref<$cm> int = ref<$ro> int and that is \n        // illegal as $ro has no conversion to $cm (the relationship is the other direction)\n        s.refField = ref<$ro> s.field;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ref scoped Parameter Usage in C#\nDESCRIPTION: Shows how ref scoped parameters constrain the safe-to-escape of values to prevent returning from current method. Demonstrates valid and invalid operations with Span<T>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<int> M(Span<T> p1, ref scoped Span<int> p2)\n{\n    // Error: cannot return scoped value\n    return p2;\n\n    // Error: the safe-to-escape of p1 is not convertible to p2.\n    p2 = p1;\n\n    // Okay: heap can always be assigned\n    p2 = default;\n\n    // Okay\n    p2[0] = 42;\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded Switch Statement with Pattern Matching in C#\nDESCRIPTION: This snippet showcases an expanded switch statement utilizing pattern matching. It includes a 'where' clause for additional filtering in case labels.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nswitch (o) {\ncase ExpressionStatement(\n        AssignmentExpressionSyntax(IdentifierName l, IdentifierName r)\n        where (l.name == r.name):\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Public Parameterless Struct Constructor in C#\nDESCRIPTION: This code demonstrates the requirement for a parameterless constructor in a struct to be declared as `public`. The example highlights that `internal` or other non-public access modifiers are not allowed for parameterless struct constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\"struct S0 { }                   // ok\\nstruct S1 { public S1() { } }   // ok\\nstruct S2 { internal S2() { } } // error: parameterless constructor must be 'public'\"\n```\n\n----------------------------------------\n\nTITLE: Function Types with Discards\nDESCRIPTION: This snippet demonstrates how function types interact with discards. While assigning a lambda to a variable works, assigning to a discard is not allowed as function types are not used in assignments to discards.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nd = () => 0; // ok\n_ = () => 1; // error\n```\n\n----------------------------------------\n\nTITLE: Custom Downstream Operator with Nullability Propagation in C# LINQ\nDESCRIPTION: This example demonstrates how nullability information should be propagated to custom downstream operators in LINQ queries, showing the desired behavior for nullable analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-07.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nenumerable\n    .Where(x => x.Item != null)\n    .SelectAsArray(x => new HasNotNullable(x.Item)); // state of 'x.Item' is still propagated, although it seems like the compiler can't make a hard assumption that this lambda is operating on the collection element.\n```\n\n----------------------------------------\n\nTITLE: Switch Pattern Matching with Shared Variables in C#\nDESCRIPTION: Shows pattern matching in a switch statement where multiple case labels share the same variable declaration for similar transformation patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/pattern-variables.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nExpr Simplify(Expr e)\n{\n  switch (e) {\n    case Mult(Const(1), var x):\n    case Mult(var x, Const(1)): \n    case Add(Const(0), var x):\n    case Add(var x, Const(0)):\n        return Simplify(x);\n    // ..\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Copy Operations with ref scoped in C#\nDESCRIPTION: Demonstrates how ref scoped enables more flexible call site usage when working with multiple ref struct values having different lifetimes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nref struct Data { ... }\nvoid Copy1(ref Data source, ref Data dest) { ... }\nvoid Copy2(ref Data source, ref scoped Data dest) { ... }\n\nvoid Use(ref Data data)\n{\n    // STE: current method\n    var local = new Data(stackalloc int[42]);\n\n    // Error: compiler has to assume local copied to data \n    Copy1(ref data, ref local);\n\n    // Okay: compiler knows lifetime only flows data -> local\n    Copy2(ref data, ref local);\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Index Operator\nDESCRIPTION: ANTLR grammar definition for the unary index from end operator (^).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nunary_expression\n    : '^' unary_expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref Field Assignment Restrictions in C#\nDESCRIPTION: Example showing invalid ref field assignment due to lifetime mismatches between ref<$cm> and ref<$ro> types. The code illustrates why certain ref field reassignments are illegal due to lifetime conversion rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\n// error: the types here are:\n//  - refField is ref<$cm> int\n//  - ref parameter is ref<$ro> int\n// That means the RHS is not convertible to the LHS ($ro is not covertible to $cm) and \n// hence this reassignment is illegal\n@this.refField = ref<$ro> parameter;\n```\n\n----------------------------------------\n\nTITLE: Parameter Null Checking Syntax Options in C#\nDESCRIPTION: Various syntax proposals for parameter null checking feature, including current and alternative forms being considered.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-13.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string s!!);     // Current form\nvoid M(string! s);      // Type modifier form\nvoid M(string s!);      // Less shouty form\nvoid M(notnull string s); // Keyword form\nvoid M(string s ?? throw); // Null coalescing form\nvoid M(string s is not null); // Pattern matching form\nvoid M(checked string s);  // Checked keyword form\nvoid M(string s) where s is not null; // Contract-style form\n```\n\n----------------------------------------\n\nTITLE: Declaring Extension Members in Static Classes (C#)\nDESCRIPTION: Demonstrates how to declare extension members inside a static class, including new extension declarations, classic extension methods, and non-extension members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    // New extension declaration\n    extension(IEnumerable source) { ... }\n    \n    // Classic extension method\n    public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source) { ... }\n    \n    // Non-extension member\n    public static IEnumerable<int> Range(int start, int count) { ... } \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Short-hand Null Checking Syntax for Parameters in C#\nDESCRIPTION: Demonstrates a proposed syntax for concise null checking of method parameters, throwing an ArgumentNullException if the parameter is null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-07-26.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic void M(string name!) { ... }\n\n// equivalent to\npublic void M(string name)\n{\n    if (name is null) throw new ArgumentNullException(nameof(name));\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Lowering LogDictionary Method with Stack Allocation in C#\nDESCRIPTION: Example showing how the LogDictionary method might be lowered by the compiler to use stack allocation and buffer reuse.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void LogDictionary<K, V>(this Logger log, Dictionary<K, V> dictionary)\n{\n    FixedSizeBuffer2<object> _tmp = new FixedSizeBuffer2<object>();\n\n    log.Log(\"Dictionary\",\n        new ReadOnlySpan<object>(Array.Empty<object>()); // no reuse\n\n    foreach (var (k, v) in dictionary)\n    {\n        _tmp.Items[0] = k;\n        _tmp.Items[1] = v;\n        log.Log(\"{0}, {1}\",\n            MemoryMarshal.CreateReadOnlySpan<object>(ref _tmp.Items, 2)); // reuse\n        MemoryMarshal.CreateSpan<object>(ref _tmp.Items, 2).Clear();      // clear\n    }\n\n    _tmp.Items[0] = dictionary.Count;\n    log.Log(\"Count = {0}\",\n        MemoryMarshal.CreateReadOnlySpan<object>(ref _tmp.Items, 1)); // reuse slice\n}\n```\n\n----------------------------------------\n\nTITLE: Using new C# language features with Person class\nDESCRIPTION: Illustrates the use of object initializer, positional deconstruction, and with-expression on a Person object.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-02-29.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar p = new Person { FirstName = \"Mickey\", LastName = \"Mouse\" }; // object initializer\nif (p is Person(\"Mickey\", *)) // positional deconstruction\n{\n  return p with { FirstName = \"Minney\" }; // with-expression\n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Change Example with Tuple Names\nDESCRIPTION: Demonstrates a potential breaking change scenario with inferred tuple names affecting method resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-05.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nAction y = () => {}\nvar t = (x: x, y) // (int x, Action y) or (int x, Action)?\nt.y(); // a call of the second component or of an extension method y on the type (int, int)?\n```\n\n----------------------------------------\n\nTITLE: Potential Future Use of Discards in C# Foreach Loops\nDESCRIPTION: This snippet shows a potential future use of discards in foreach loops, where the loop variable is not needed. Currently, 'var _' can be used for the same effect.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-15.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nforeach (_ in e) { ... } // I don't care about the values\n```\n\n----------------------------------------\n\nTITLE: Basic Out Parameter Declaration Expression\nDESCRIPTION: Example showing declaration expressions with out parameters to get coordinates, demonstrating the 'spill out' behavior that was later removed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-09-03.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nGetCoordinates(out var x, out var y);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Required Member Syntax in C#\nDESCRIPTION: Code examples showing the proposed syntax for required members, including init(Prop), init required, and init required! modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-10-25.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninit(Prop)           // Requires all type members except those in init clause\ninit required        // Does not require any members, compiler enforces initialization\ninit required!       // Same as above but without compiler enforcement\n```\n\n----------------------------------------\n\nTITLE: Using Null-Forgiving Operator in C#\nDESCRIPTION: Examples of using the null-forgiving operator (!) in C# expressions. The operator has no runtime effect but changes the null state of the expression to \"not null\" for static analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar v = expr!;\nexpr!.M();\n_ = a?.b!.c;\n```\n\n----------------------------------------\n\nTITLE: Defining a File Scoped Namespace\nDESCRIPTION: This snippet demonstrates how to define a file scoped namespace in C#. It replaces the traditional namespace declaration format with a cleaner, less verbose syntax to improve readability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/file-scoped-namespaces.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace X.Y.Z;\n\nusing System;\n\nclass X\n{\n}\n\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Example with C# 9 Implementation\nDESCRIPTION: Implementation of ASP.NET endpoints using C# 9 syntax with explicit delegate type casting\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-03.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nvar app = WebApplication.Create(args);\n\n[HttpGet(\"/\")]\nTodo GetTodo() => new(Id: 0, Name: \"Play more!\", IsComplete: false);\napp.MapAction((Func<Todo>)GetTodo);\n\n[HttpPost(\"/\")]\nTodo EchoTodo([FromBody] Todo todo) => todo;\napp.MapAction((Func<Todo, Todo>)EchoTodo);\n\n[HttpGet(\"/id/{id?}\")]\nIResult GetTodoFromId([FromRoute] int? id) =>\n    id is null ?\n    new StatusCodeResult(404) :\n    new JsonResult(new Todo(Id: id.Value, Name: \"From id!\", IsComplete: false));\napp.MapAction((Func<int?, IResult>)GetTodoFromId);\n\nawait app.RunAsync();\n\nrecord Todo(int Id, string Name, bool IsComplete);\n```\n\n----------------------------------------\n\nTITLE: Tuples as Return Types in C#\nDESCRIPTION: Example of the proposed tuple syntax showing a method returning multiple values (sum and count) with named members, allowing callers to access these values through dot notation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic (int sum, int count) Tally(IEnumerable<int> values) { ... }\n\nvar t = Tally(myValues);\nConsole.WriteLine($\"Sum: {t.sum}, count: {t.count}\");\n```\n\n----------------------------------------\n\nTITLE: Constructing Arrays, Spans, and Interfaces from Collection Expressions in C#\nDESCRIPTION: This snippet describes the process of constructing arrays, spans, and interfaces from collection expressions. It includes steps for evaluating elements, determining known length, creating initialization instances, and handling different element types including KeyValuePair elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// Pseudo-code representation of the construction process\n\n// Evaluate elements and determine known length\nvar elements = EvaluateElements(collectionExpression);\nvar knownLength = DetermineKnownLength(elements);\n\n// Create initialization instance\nvar initializationInstance = CreateInitializationInstance(targetType, knownLength);\n\n// Populate initialization instance\nif (IsKeyValuePairIterationType())\n{\n    foreach (var element in elements)\n    {\n        if (element is KeyValuePairElement)\n        {\n            var key = EvaluateKey(element);\n            var value = EvaluateValue(element);\n            initializationInstance[key] = value;\n        }\n        else if (element is ExpressionElement)\n        {\n            if (CanConvertToKeyValuePair(element))\n            {\n                var kvp = ConvertToKeyValuePair(element);\n                initializationInstance[kvp.Key] = kvp.Value;\n            }\n            else\n            {\n                var kvp = (KeyValuePair<K, V>)element;\n                initializationInstance[ConvertKey(kvp.Key)] = ConvertValue(kvp.Value);\n            }\n        }\n        else if (element is SpreadElement)\n        {\n            foreach (var item in GetEnumerator(element))\n            {\n                if (CanConvertToKeyValuePair(item))\n                {\n                    var kvp = ConvertToKeyValuePair(item);\n                    initializationInstance[kvp.Key] = kvp.Value;\n                }\n                else\n                {\n                    var kvp = (KeyValuePair<K, V>)item;\n                    initializationInstance[ConvertKey(kvp.Key)] = ConvertValue(kvp.Value);\n                }\n            }\n        }\n    }\n}\nelse\n{\n    foreach (var element in elements)\n    {\n        if (element is ExpressionElement)\n        {\n            initializationInstance[currentIndex++] = element;\n        }\n        else if (element is SpreadElement)\n        {\n            foreach (var item in GetEnumerator(element))\n            {\n                initializationInstance[currentIndex++] = item;\n            }\n        }\n    }\n}\n\n// Create final collection instance from initialization instance\nreturn CreateFinalInstance(initializationInstance, targetType);\n```\n\n----------------------------------------\n\nTITLE: Specifying Refness for Extension Declarations (C#)\nDESCRIPTION: Shows how to specify refness (ref, ref readonly, in) for extension declarations with value type receivers, and how to use the readonly modifier for instance members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong bits) // receiver is passed by ref\n    {\n        public bool this[int index]\n        {\n            set => bits = value ? bits | Mask(index) : bits & ~Mask(index); // mutates receiver\n            readonly get => (bits & Mask(index)) != 0;                // cannot mutate receiver\n        }\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n```\n\n----------------------------------------\n\nTITLE: Examples of Partial Indexers with Attribute Merging in C#\nDESCRIPTION: Demonstration of how partial indexers work in C#, including attribute merging across declarations and implementation details with backing storage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npartial class C\n{\n    public partial int this[int x] { get; set; }\n    public partial int this[int x]\n    {\n        get => this._store[x];\n        set => this._store[x] = value;\n    }\n}\n\n// attribute merging\npartial class C\n{\n    public partial int this[[Attr1] int x]\n    {\n        [Attr2] get;\n        set;\n    }\n\n    public partial int this[[Attr3] int x]\n    {\n        get => this._store[x];\n        [Attr4] set => this._store[x] = value;\n    }\n\n    // results in a merged member emitted to metadata:\n    public int this[[Attr1, Attr3] int x]\n    {\n        [Attr2] get => this._store[x];\n        [Attr4] set => this._store[x] = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Null Coalescing Assignment Example\nDESCRIPTION: Example showing null coalescing assignment operator syntax and behavior, which only assigns if left-hand side is null. Uses 'is null' check rather than == operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-16.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nif (x is null) x = y;\n```\n\n----------------------------------------\n\nTITLE: Array Indexing with Negative Ranges in C#\nDESCRIPTION: Demonstrates proposed syntax for array slicing using negative indices, where negative numbers count from the end of the array. The range excludes the last element.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-31.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\na[-5..-1]\n```\n\n----------------------------------------\n\nTITLE: Conversion Examples for KeyValuePair<K, V> Collections in C#\nDESCRIPTION: Examples demonstrating allowed and disallowed conversions when creating KeyValuePair<string, int> collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nList<KeyValuePair<string, int>> list;\nlist = [default];             // ok\nlist = [new()];               // ok\nlist = [new StringIntPair()]; // error: UDC not supported\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C# 8.0 Nullable Reference Type Operator\nDESCRIPTION: Shows the use of the '!' (null-forgiving) operator in C# 8.0 which silences nullable warnings at a specific point without flowing through the execution path.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-02.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n!\n```\n\n----------------------------------------\n\nTITLE: Using Null-Forgiving Operator with Inherent Types in C#\nDESCRIPTION: Examples showing how the null-forgiving operator works with inherent types, converting nullable reference types to non-nullable ones.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-16.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar s = GetNameOrNull()!;\nGetNameOrNull()!.Length;\n```\n\n----------------------------------------\n\nTITLE: UTF-8 Byte Representation Concatenation\nDESCRIPTION: This code snippet demonstrates the proposed addition operator overload for `ReadOnlySpan<byte>` to concatenate UTF-8 byte sequences. It clarifies how the operator works with `u8` literals and values produced by the operator itself.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n\"ReadOnlySpan<byte> operator +(ReadOnlySpan<byte> x, ReadOnlySpan<byte> y);\"\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Usage with IEnumerable in C#\nDESCRIPTION: This snippet demonstrates using a collection expression as an argument to a method expecting an `IEnumerable<int>`. The key aspect is that the code using the collection expression doesn't need to know, or depend on, the underlying concrete type that is used to implement the collection. The compiler chooses an efficient type, but the consumer only interacts with the `IEnumerable<int>` interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvoid DoSomething(IEnumerable<int> values) { ... }\n\n// Allowed, an efficient type is used here, but you will not know what it is, or be able\n// to take a dependency on it.\nDoSomething([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Pattern-based Fixed Statement Translation in C#\nDESCRIPTION: Shows how a pattern-based fixed statement is translated into lower-level operations including pinning and unpinning references.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/pattern-based-fixed.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nfixed(byte* ptr = thing)\n{ \n    // <BODY>\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbyte* ptr;\n// specially decorated \"pinned\" IL local slot, not visible to user code.\npinned ref byte _pinned;\n\ntry\n{\n    // NOTE: null check is omitted for value types \n    // NOTE: `thing` is evaluated only once (temporary is introduced if necessary) \n    if (thing != null)\n    {\n        // obtain and \"pin\" the reference\n        _pinned = ref thing.GetPinnableReference();\n\n        // unsafe cast in IL\n        ptr = (byte*)_pinned;\n    }\n    else\n    {\n        ptr = default(byte*);\n    }\n\n    // <BODY> \n}\nfinally   // finally can be omitted when not observable\n{\n    // \"unpin\" the object\n    _pinned = nullptr;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating AllowNull Property Flow Analysis Issue in C#\nDESCRIPTION: Example showing unexpected warning behavior with AllowNull attribute on string property where flow state tracking conflicts with the attribute intention.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-09-04.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    private string _f = string.Empty;\n\n    [AllowNull]\n    public string P\n    {\n        get => _f;\n        set => _f = value ?? string.Empty;\n    }\n\n    static void Main(string[] args)\n    {\n        var p = new Program();\n        p.P = null; // No warning, as expected\n        Console.Write(p.P.Length); // unexpected warning\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing ImmutableHashSet using Constructor in C#\nDESCRIPTION: This code snippet presents an alternative method for creating an ImmutableHashSet using its constructor, which also accepts a ReadOnlySpan<T> as an argument for efficient initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionBuilder(typeof(ImmutableHashSet<>), \".ctor\")]\npublic class ImmutableHashSet<T>\n{\n    public ImmutableHashSet(ReadOnlySpan<T> values);\n}\n\n// code:\nImmutableHashSet<int> values = [1, 2, 3];\n\n// translates to:\nReadOnlySpan<int> __values = [1, 2, 3];\nImmutableHashSet<int> values = new ImmutableHashSet<int>(__values);\n```\n\n----------------------------------------\n\nTITLE: Optional Parameters in Struct Constructors in C#\nDESCRIPTION: This example shows that structs with constructors containing optional parameters or params arrays are not considered parameterless constructors by the compiler. The compiler ignores these constructors when instantiating the struct without parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S1 { public S1(string s = \"\") { } }\nstruct S2 { public S2(params object[] args) { } }\n\n_ = new S1(); // ok: ignores constructor\n_ = new S2(); // ok: ignores constructor\n```\n\n----------------------------------------\n\nTITLE: Basic Auto-Property Implementation Example\nDESCRIPTION: Demonstrates a basic Point class with auto-properties and shows equivalent implementations with explicit use of the 'field' keyword and with traditional backing fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n// No 'field' symbol in scope.\npublic class Point\n{\n    public int X { get; set; }\n    public int Y { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Role-based Interface Extension in C#\nDESCRIPTION: Example demonstrating how roles could be used to implement interfaces on existing types, specifically showing a FractionAdditiveIdentity role implementing IAdditiveIdentity for a Fraction type. Includes usage with generic methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-12-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nrole FractionAdditiveIdentity : Fraction, IAdditiveIdentity<Fraction>\n{\n    public static Fraction Zero => new(0, 1);\n    public static Fraction operator+(Fraction left, Fraction right) => left + right;\n}\n\npublic T Sum<T>(IEnumerable<T> elements) where T : IAdditiveIdentity<T>\n{\n    T result = T.Zero;\n    foreach (var el in elements)\n    {\n        result += el;\n    }\n    return result;\n}\n\nIEnumerable<FractionAdditiveIdentity> fractions = ...;\nConsole.WriteLine(Sum(fractions));\n```\n\n----------------------------------------\n\nTITLE: Analyzing Ref-Safety Scope for Local Span Usage in C#\nDESCRIPTION: This example shows a local-scoped Span<int> created with a collection expression. The span does not escape the method, demonstrating a case where local scope could be inferred.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvoid M()\n{\n    // Local scoped, s does not escape.\n    Span<int> s = [x, y, z];\n    foreach (var v in s)\n        Console.WriteLine(v);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating modopt for Extension Type Encoding in C#\nDESCRIPTION: Shows how modopt could be used to encode extension types in method signatures. It includes examples for both regular methods and virtual method overrides.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// source\nvoid M(E e)\n\n// codegen\nvoid M(C modopt(E) e)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvirtual void M2(C c)\n// other assembly\noverride void M2(E e)\n```\n\n----------------------------------------\n\nTITLE: Switch Statement with Pattern Matching in C#\nDESCRIPTION: Example of a switch statement using various pattern matching forms, including constants, type patterns with variable declarations, and positional patterns for a Point type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Notes.md#2025-04-21_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nswitch (o)\n{\n    case 3:\n\t\t...\n\t\tbreak;\n\tcase string s:\n\t\tM(s);\n\t\tbreak;\n\tcase Point(3, int y):\n\t\tM(y);\n\t\tbreak;\n\tcase Point(int x, 4):\n\t\tM(x);\n\t\tbreak;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Interfaces with Ref Structs in C#\nDESCRIPTION: This C# code snippet demonstrates a function with an anti-constraint, allowing ref structs as type parameters without boxing them to interfaces. The proposed syntax involves using \"allow\" to explicitly permit ref structs, thereby enabling generic constraints without incurring boxing costs. The snippet is targeted at leveraging such constructs to enhance core abstractions in libraries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-01-22.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nT Identity<T>(T p)\n    allow T : ref struct\n    => p;\n\n// Okay\nSpan<int> local = Identity(new Span<int>(new int[10]));\n```\n\n----------------------------------------\n\nTITLE: Null-Checking Parameter Syntax Example in C#\nDESCRIPTION: An example of the proposed param! syntax for automatic null checking of parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-07-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string p! = null)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Quote Sequence Length Requirement in C# Raw String Literals\nDESCRIPTION: Examples showing how the delimiter quotes must be longer than any sequence of quotes within the string content. The first example shows an unclear approach, while the second shows the approved approach where the delimiter has more quotes than the content.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nvar v = \"\"\"\n        contents\"\"\"\"\"\n        \"\"\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar v = \"\"\"\"\"\"\n        contents\"\"\"\"\"\n        \"\"\"\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Bitwise Complement Operator for IntPtr and UIntPtr\nDESCRIPTION: Defines the bitwise complement operator for System.IntPtr and System.UIntPtr types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator ~(System.IntPtr)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator ~(System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Argument Spilling with 'in' Parameters and Await in C#\nDESCRIPTION: Demonstrates how arguments to 'in' parameters can be spilled by value when direct references cannot be preserved across await suspension points.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nM1(RefReturningMethod(), await SomethingAsync())   // not an error.\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Comparison Operators in C#\nDESCRIPTION: This snippet outlines the predefined comparison operators for nint and nuint types, facilitating equality and relational comparisons. The operators handle pairs of nint or nuint values, with results being boolean indicating the comparison outcome.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nbool operator ==(nint x, nint y);\n    bool operator ==(nuint x, nuint y);\n    bool operator !=(nint x, nint y);\n    bool operator !=(nuint x, nuint y);\n    bool operator <(nint x, nint y);\n    bool operator <(nuint x, nuint y);\n    bool operator >(nint x, nint y);\n    bool operator >(nuint x, nuint y);\n    bool operator <=(nint x, nint y);\n    bool operator <=(nuint x, nuint y);\n    bool operator >=(nint x, nint y);\n    bool operator >=(nuint x, nuint y);\n```\n\n----------------------------------------\n\nTITLE: Preferred Nominal Record Syntax in C#\nDESCRIPTION: The team's preferred syntax for nominal records, creating a class with public init-only properties and additional record functionality including equality and non-destructive mutation methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-11.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nrecord class Person { string FirstName; string LastName; }\n```\n\n----------------------------------------\n\nTITLE: Migration Example for Modern Extensions in C#\nDESCRIPTION: This snippet demonstrates how existing static classes with extension methods can be migrated to the new modern extension syntax, maintaining semantic and binary compatibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// Existing style\nstatic class E\n{\n    static TField field;\n    static int Property => ...\n    static void NonExtensionHelperMethod() { }\n\n    static int ExtensionMethod(this string x, ...) { }\n    static T GenericExtensionMethod<T, U>(this U u, ...) { }\n}\n\n// New style\nextension E\n{\n    // Non extensions stay exactly the same.\n    static TField field;\n    static int Property => ...\n\n    // Note the lack of a 'for-clause'.  This is a normal static method.\n    // An *modern static extension method* will have a 'for-clause' on it\n    static void NonExtensionHelperMethod() { }\n\n    // Migrated *instance* extension members\n    int ExtensionMethod(...) for string x { }\n    T GenericExtensionMethod<T, U>(...) for U u { }\n}\n```\n\n----------------------------------------\n\nTITLE: IEnumerable.Cast Annotation Example\nDESCRIPTION: Example of Cast<TResult> method return type annotation showing nullability concerns in .NET 5. The method returns IEnumerable<TResult?> which indicates nullable elements regardless of input nullability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-09-14.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TResult?> Cast<TResult>(this IEnumerable source)\n```\n\n----------------------------------------\n\nTITLE: Stream Merging with Pattern Matching in C#\nDESCRIPTION: Demonstrates a potential implementation of merging different typed streams using pattern matching as an alternative to Go's select statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nforeach (var e in myInts.Merge(myStrings))\n{\n  switch (e)\n  {\n    case int i:\n      ...\n    case string s:\n      ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Covariance with Ad Hoc Union Types in C#\nDESCRIPTION: Shows how ad hoc union types can be used with generic covariance when there's a subtype relationship between the members of different unions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Groom(IEnumerable<(Dog or Cat)> animals) => ...;\n\nList<(Chihuahua or Siamese)> pets = ...;\nGroom(pet);\n```\n\n----------------------------------------\n\nTITLE: Comparing Constrained vs Unconstrained T? Behavior\nDESCRIPTION: Example showing how T? would mean different things depending on whether T is constrained to struct or unconstrained, demonstrating the cognitive dissonance problem with the syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-25.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic T? M1<T>(T t) where T : struct;\npublic T? M2<T>(T t);\n\nvar i1 = M1(7); // i1 is int?\nvar i2 = M2(7); // i2 is int\n```\n\n----------------------------------------\n\nTITLE: Required Member Initialization Example in C#\nDESCRIPTION: Example demonstrating the initialization of required members with default values in a class. Shows both field and property initialization patterns that were discussed regarding potential warning scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-21.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public required int Field = 1;\n    public required int Prop { get; set; } = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Key-Value Pair Collections in C#\nDESCRIPTION: Example of creating a List of KeyValuePair<string, int> using dictionary expression syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nList<KeyValuePair<string, int>> = [\"mads\": 21];\n```\n\n----------------------------------------\n\nTITLE: Using `nameof` with Method Parameters in Attributes (C#)\nDESCRIPTION: This example demonstrates how to use the `nameof` expression to refer to a method parameter within an attribute applied to the method itself. The `MyAttribute` attribute will receive the string representation of the `parameter` name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/extended-nameof-scope.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n\"[MyAttribute(nameof(parameter))] void M(int parameter) { }\"\n```\n\n----------------------------------------\n\nTITLE: Defining Notnull Constraint in C#\nDESCRIPTION: Placeholder specification for the 'notnull' type parameter constraint introduced in C# 8.0. The constraint ensures that a type parameter can only be satisfied by non-nullable types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/notnull-constraint.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnotnull\n```\n\n----------------------------------------\n\nTITLE: Error Case: Abstract Class Not Implementing Interface Method in C#\nDESCRIPTION: This code snippet shows an error case where an abstract class does not implement a required interface method, violating the most specific implementation rule.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IF\n{\n    void M();\n}\nabstract class F : IF { } // error: 'F' does not implement 'IF.M'\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Methods in Fluent Assertions Library\nDESCRIPTION: Illustrates an existing extension method from the Fluent Assertions library and how static properties could minimize syntactic requirements. The transition from a method to a property form shows potential simplifications and improved syntactic flow in test assertions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionExtensions\n{\n    public static TypeAssertions Should(this Type subject)\n    {\n        return new TypeAssertions(subject);\n    }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic static class AssertionExtensions<T> for T\n{\n    public static TypeAssertions T.Should\n    {\n        return new TypeAssertions(typeof(T));\n    }\n}\n\n// Usage:\nMyBaseClass.Should.BeAbstract;\n\n```\n\n----------------------------------------\n\nTITLE: Multi-dimensional Slicing with Ranges in C#\nDESCRIPTION: Illustrates a potential syntax for multi-dimensional slicing using ranges, including from-end indexing and open-ended ranges.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-14.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvar slice = myTensor[x1..x2, y1.:l, ^z1.., ..];\n```\n\n----------------------------------------\n\nTITLE: Signature transformation for extension methods\nDESCRIPTION: This code shows how extension methods are transformed into a single signature during overload resolution when using a one-phase lookup approach. The transformation combines type parameters and parameters from the extension container and the method itself into a single signature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n\"static class E\\n{\\n  extension<extensionTypeParameters>(receiverParameter)\\n  {\\n    void M<methodTypeParameters>(methodParameters);  \\n  }\\n}\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\n\"static void M<extensionTypeParameters, methodTypeParameters>(this receiverParameter, methodParameters);\"\n```\n\n----------------------------------------\n\nTITLE: Using Collection Literal with Natural Type in C#\nDESCRIPTION: Demonstrates the use of a collection literal with its natural type (List<T>). This syntax allows for concise creation of lists without explicitly specifying the type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nvar x = [1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Record Type Example Hierarchy\nDESCRIPTION: Example showing three record types (R1, R2, R3) demonstrating inheritance and parameter passing between record types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nrecord R1(T1 P1);\nrecord R2(T1 P1, T2 P2) : R1(P1);\nrecord R3(T1 P1, T2 P2, T3 P3) : R2(P1, P2);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constants with Default in C#\nDESCRIPTION: Illustrates how default can be used in constant declarations, similar to null, but only for certain types that allow constants.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-07.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nconst string S = null;    // sure\nconst string S = default; // sure\nconst int? NI = null;     // error\nconst int? NI = default;  // error\n```\n\n----------------------------------------\n\nTITLE: List Spreads and Pattern Matching in C#\nDESCRIPTION: This snippet shows the relationship between list spreads and pattern matching, demonstrating how a list can be deconstructed using pattern matching with spread syntax and then reconstructed using collection literals with spread syntax. This demonstrates the complementary nature of these features.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nif (x is [var start, .. var middle, var end]) // pattern form:\n    \nList<string> values = [\"start\", .. middle, \"end\"]; // translates to potentially:\n    \nList<string> values = new List<string>(capacityIfKnown);\nvalues.Add(\"start\");\nvalues.AddRange(middle);\nvalues.Add(\"end\");\n    \n// or potentially:\n    \nList<string> values = new List<string>(capacityIfKnown);\nvalues.Add(start);\nforeach (var v in middle)\n    values.Add(v);\nvalues.Add(end);\n```\n\n----------------------------------------\n\nTITLE: Using Scoped Local Variables with Spans in C#\nDESCRIPTION: Shows how the 'scoped' modifier affects local variable declarations for ref structs like Span<int>. Demonstrates how scoped locals have a function-member safe-context regardless of their initializer's lifetime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> ScopedLocalExamples()\n{\n    // Error: `span` has a safe-context of *function-member*. That is true even though the \n    // initializer has a safe-context of *caller-context*. The annotation overrides the \n    // initializer\n    scoped Span<int> span = default;\n    return span;\n\n    // Okay: the initializer has safe-context of *caller-context* hence so does `span2` \n    // and the return is legal.\n    Span<int> span2 = default;\n    return span2;\n\n    // The declarations of `span3` and `span4` are functionally identical because the \n    // initializer has a safe-context of *function-member* meaning the `scoped` annotation\n    // is effectively implied on `span3`\n    Span<int> span3 = stackalloc int[42];\n    scoped Span<int> span4 = stackalloc int[42];\n}\n```\n\n----------------------------------------\n\nTITLE: Is Operator and Nullability State in False Case in C#\nDESCRIPTION: Examples showing how the 'is' operator affects nullability tracking in the false branch of conditional statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nstring s = string.Empty;\nif (!(s is object)) { s.ToString(); /* could warn? */ }\nif (!(s is string)) { s.ToString(); /* could warn? */ }\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Example in C#\nDESCRIPTION: This code demonstrates a collection expression assigned to an IEnumerable<T>. The compiler can optimize this by using a single allocation, even when immediately iterated.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\n    \"DoSomething([1, 2, 3]);\"\n```\n\n----------------------------------------\n\nTITLE: Pure Null Check Examples in C#\nDESCRIPTION: Demonstration of different syntax patterns for null checking in C#, including is null, is object, and other variations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-18.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ne is null       // pure\n\ne is object     // Proposed\ne is [System.]Object // Proposed\ne is object _\ne is object x\n\ns is string        // s denotes expr of static type string\ns is string x\no is string x\n\ne is {}          // Proposed\ne is {} _\ne is {} x\n\ne == null       // pure\ne != null       // pure\n\ne is not null   // pure\ne is not object // etc...\n```\n\n----------------------------------------\n\nTITLE: Proposed Nullable Extension Operator in Generic Methods\nDESCRIPTION: Demonstrates a proposed operator ('^') that would make a type nullable if it's a non-nullable reference type, but leave it unchanged if already nullable. The example shows how this would work with FirstOrDefault() to return a nullable type when the collection might be empty.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-07.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static T^ FirstOrDefault<T>(this IEnumerable<T> source);\n\nvar a = new string[] { \"a\", \"b\", \"c\" };\nvar b = new string[] {};\n\nvar couldBeNull = condition ? a.FirstOrDefault() : b.FirstOrDefault(); // string?\n```\n\n----------------------------------------\n\nTITLE: Proposed Happy Path Usage for Async Method Nullability in C#\nDESCRIPTION: This code snippet demonstrates the proposed behavior for MemberNotNull attribute on async methods, where postconditions are only applied if the call is immediately awaited.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    string? item;\n    \n    [MemberNotNull(nameof(item))]\n    public async Task MAsync()\n    {\n        await Task.Yield(); // no warning\n        item = \"a\";\n    }\n\n    public static void Main()\n    {\n        C c = new C();\n        await c.MAsync();\n        c.item.ToString(); // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated With-er Implementation in C#\nDESCRIPTION: Shows how the compiler would expand the With-er syntax into concrete implementation code with a virtual With method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-29.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point(int X, int Y)\n{\n    public virtual Point With(int X, int Y) => new Point(X, Y);\n}\nvar p2 = p1.With(p1.X, 2);\n```\n\n----------------------------------------\n\nTITLE: Analyzing Nullable Flow in Lambda Expressions (C#)\nDESCRIPTION: This code snippet demonstrates the challenges of nullable flow analysis when variables are captured in lambda expressions. It shows how the nullability of captured variables can change over time and across different execution paths.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-04.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstatic void F(object? x)\n    {\n        object y = null;\n        Action f = () => y = x; // warning?\n        if (x == null) return;\n        f();\n        y.ToString(); // warning?\n    }\n```\n\n----------------------------------------\n\nTITLE: Existing Collection Expression Example\nDESCRIPTION: Shows an existing valid collection expression syntax that creates a List of Widgets, demonstrating why certain syntax choices for arguments would be problematic due to backwards compatibility concerns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nList<Widget> c = [new(...), w1, w2, w3];\n```\n\n----------------------------------------\n\nTITLE: Native Integer Constant Declaration in C#\nDESCRIPTION: Shows how to declare a constant native integer using explicit casting, as there is no direct syntax for native int literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nconst nint i = (nint)42;\n```\n\n----------------------------------------\n\nTITLE: Implementing GetAsyncEnumerator with Cancellation Token\nDESCRIPTION: Example showing how to implement IAsyncEnumerable's GetAsyncEnumerator method with manual cancellation token checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-12.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass C : IAsyncEnumerable\n{\n    IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken token)\n    {\n        ...\n        token.ThrowIfCancelled();\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Null-Forgiving Operator Usage in C#\nDESCRIPTION: Example showing the usage of the null-forgiving operator (!) and its effect on type interpretation and warning suppression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-23.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nstring? n = GetStringOrNull();\n\nvar l = n!.Length; // why no warning?\nvar s = n!;\n```\n\n----------------------------------------\n\nTITLE: DebuggerDisplay Attribute Usage\nDESCRIPTION: Using nameof in a DebuggerDisplay attribute to reference method names for debug visualization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[DebuggerDisplay(\"={\" + nameof(getString) + \"()}\")]\nclass C {\n    string getString() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Null Dereference Warning in C# Constructor\nDESCRIPTION: This example shows how the proposed approach handles potential null dereferences in constructors. It demonstrates that a warning is generated for dereferencing a possibly null reference, but no warning is given at the constructor exit if the flow state is promoted to NotNull after dereference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-constructor-analysis.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public string Prop { get; set; }\n    public C()\n    {\n        Prop.ToString(); // Warning: dereference of a possible null reference.\n    } // No warning: Prop's flow state was 'promoted' to NotNull after dereference\n    \n    // This is also consistent with currently shipped behavior:\n    [MemberNotNull(nameof(Prop))]\n    void M()\n    {\n        Prop.ToString(); // Warning: dereference of a possible null reference.\n    } // No warning: Prop's flow state was 'promoted' to NotNull after dereference\n}\n```\n\n----------------------------------------\n\nTITLE: User-defined Span Conversions Through Inheritance Example\nDESCRIPTION: Demonstrates how implicit span conversions affect behavior when user-defined conversions are involved in a type hierarchy. Shows the difference between current and future behavior for span and integer scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<string> span = [];\nvar d = new Derived();\nd.M(span); // Base today, Derived tomorrow\nint i = 1;\nd.M(i); // Derived today, demonstrates new behavior\n\nclass Base\n{\n    public void M(Span<string> s)\n    {\n        Console.WriteLine(\"Base\");\n    }\n\n    public void M(int i)\n    {\n        Console.WriteLine(\"Base\");\n    }\n}\n\nclass Derived : Base\n{\n    public static implicit operator Derived(ReadOnlySpan<string> r) => new Derived();\n    public static implicit operator Derived(long l) => new Derived();\n\n    public void M(Derived s)\n    {\n        Console.WriteLine(\"Derived\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dictionary Expression Overwrite Semantics in C#\nDESCRIPTION: This code snippet illustrates potential use cases for dictionary expressions with overwrite semantics, including copying with overrides, applying default values, and merging dictionaries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2024-01-23.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Making a copy, but overwriting some elements\nDictionary<string, int> dest = [.. source, \"mads\": 21];\n\n// Having some default values, but allowing them to be supplanted.\nDictionary<string, int> dest = [\"mads\": 21, .. source];\n\n// Merging two dictionaries, with the later ones winning.\nDictionary<string, int> dest = [.. source1, .. source2];\n```\n\n----------------------------------------\n\nTITLE: Using Statement with Ref Struct IDisposable Implementation\nDESCRIPTION: Demonstrates how a using statement handles a ref struct that implements IDisposable interface. The Dispose method is called automatically when the using block ends.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S2 : System.IDisposable\n{\n    void System.IDisposable.Dispose()\n    {\n    }\n}\n\nclass C\n{\n    static void Main()\n    {\n        using (new S2())\n        {\n        } // S2.System.IDisposable.Dispose is called\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Attributes on Implicit 'this' Parameter in C#\nDESCRIPTION: This snippet shows how to apply attributes to the implicit `this` parameter in extension members using the `param` target. This allows developers to specify additional metadata and behavior for the underlying value, such as nullability annotations. `param` target is used to refer to implicit parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\npublic static class NullableExtensions\n{\n    extension(string?)\n    {\n        public string AsNotNull => this is null ? \"\" : this;\n        [param:NotNullWhen(false)] public bool IsNullOrEmpty => this is null or [];\n    }\n    extension<T> (T) where T : class?\n    {\n        [param:NotNull] public void ThrowIfNull() => ArgumentNullException.ThrowIfNull(this);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Primary Constructor Parameter Access in C#\nDESCRIPTION: This code demonstrates potential rules for accessing primary constructor parameters within other constructors, showing allowed and disallowed usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C(bool b, int i, string s) : B(b)\n{\n    public C(string s) : this(b, s) // b still disallowed\n    { \n        i++; // could be allowed\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Tuple Name Inference with LINQ in C#\nDESCRIPTION: Demonstrates how tuple element names 'f1' and 'f2' are inferred in a LINQ query when selecting tuple elements from an object.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/infer-tuple-names.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// \"c\" and \"result\" have element names \"f1\" and \"f2\"\nvar result = list.Select(c => (c.f1, c.f2)).Where(t => t.f2 == 1);\n```\n\n----------------------------------------\n\nTITLE: Null-Propagating Operator Semantics\nDESCRIPTION: Examples showing the equivalent expanded form of null-propagating operator expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-03.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\ne?.m(â€¦)   =>   ((e == null) ? null : e0.m(â€¦))\ne?.x      =>   ((e == null) ? null : e0.x)\ne?.$x     =>   ((e == null) ? null : e0.$x)\ne?[â€¦]     =>   ((e == null) ? null : e0[â€¦])\n```\n\n----------------------------------------\n\nTITLE: Grammar for Collection Expressions in C#\nDESCRIPTION: The formal grammar productions for collection expressions in C#, defining the syntax for creating collection literals with expression elements and spread elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nprimary_no_array_creation_expression\n  ...\n+ | collection_expression\n  ;\n\n+ collection_expression\n  : '[' ']'\n  | '[' collection_element ( ',' collection_element )* ']'\n  ;\n\n+ collection_element\n  : expression_element\n  | spread_element\n  ;\n\n+ expression_element\n  : expression\n  ;\n\n+ spread_element\n  : '..' expression\n  ;\n```\n\n----------------------------------------\n\nTITLE: Defining RequiresLocation Attribute in C#\nDESCRIPTION: Custom attribute definition used to mark ref readonly parameters in metadata. The attribute is restricted to parameters only and cannot be used multiple times or inherited.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\n    public sealed class RequiresLocationAttribute : Attribute\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern-Based Using Example with ref struct\nDESCRIPTION: Shows how pattern-based using works with ref struct types that have a Dispose method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/using.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nref struct Resource\n{ \n    public void Dispose() { ... }\n}\n\nusing (var r = new Resource())\n{\n    // statements\n}\n```\n\n----------------------------------------\n\nTITLE: Self-Type Interface with Static Virtual Equality Operators\nDESCRIPTION: Example of a clearer interface declaration using the self-type pattern for static virtual equality operators, which is less likely to be misunderstood by developers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-06-06.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IThing<TSelf> where TSelf : IThing<TSelf>\n{\n    static virtual bool operator ==(TSelf i1, TSelf i2) => ...\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Existing Parameter Order Impact on Overload Resolution\nDESCRIPTION: Example illustrating how parameter order already affects overload resolution with named arguments. The issue is not unique to the new proposal but exists with current named argument behavior as well.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/non-trailing-named-arguments.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(int y, int x) { }\nvoid M<T>(int x, T y) { }\n\nvoid M2()\n{\n    M(3, 4);\n    M(x: 3, y: 4); // Invokes M(int, int)\n    M(3, y: 4); // Invokes M<T>(int, T)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Async Initialization in ImmutableArray Creation in C#\nDESCRIPTION: This code demonstrates how to create ImmutableArray from asynchronous values while handling the translation to utilize a temporary array, highlighting efficiency considerations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// code:\nImmutableArray<string> values = [await a, await b, await c];\n\n// translation:\nstring[] __temp = new string[] { await a, await b, await c };\n\nCollectionsMarshal.Create<string>(capacity: 3, out ImmutableArray<string> values, out Span<string> __storage);\n__temp.CopyTo(__storage);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Indexer Evaluation Order in Nested Member Initializers\nDESCRIPTION: This code snippet demonstrates why indexers used as member initializers with interpolated string handlers are disallowed. It shows the evaluation order problem where arguments to indexers are evaluated before the receiver, which could lead to confusing behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar x1 = new C1 { C2 = { [GetString()] = { A = 2, B = 4 } } };\n\n/* Lowering:\n__c1 = new C1();\nstring argTemp = GetString();\n__c1.C2[argTemp][1] = 2;\n__c1.C2[argTemp][3] = 4;\n\nPrints:\nGetString\nget_C2\nget_C2\n*/\n\nstring GetString()\n{\n    Console.WriteLine(\"GetString\");\n    return \"\";\n}\n\nclass C1\n{\n    private C2 c2 = new C2();\n    public C2 C2 { get { Console.WriteLine(\"get_C2\"); return c2; } set { } }\n}\n\nclass C2\n{\n    public C3 this[string s]\n    {\n        get => new C3();\n        set { }\n    }\n}\n\nclass C3\n{\n    public int A\n    {\n        get => 0;\n        set { }\n    }\n    public int B\n    {\n        get => 0;\n        set { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ref struct with default and NullReferenceException in C#\nDESCRIPTION: This example illustrates the behavior of initializing a `ref struct` with the `default` keyword when it contains a `ref` field. Accessing the `ref` field without proper initialization results in a `NullReferenceException` at runtime, since `ref` fields will have the value `null` when `default` is used.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n```c#\nref struct S \n{\n    public ref int Value;\n}\n\nS local = default;\nlocal.Value.ToString(); // throws NullReferenceException\n```\n```\n\n----------------------------------------\n\nTITLE: Async Foreach Syntax Example\nDESCRIPTION: Example showing the proposed syntax for async foreach iteration using await keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-30.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nforeach await ( ... )\n```\n\n----------------------------------------\n\nTITLE: Remove Static/Instance Mismatches in C# Extension Methods\nDESCRIPTION: This snippet demonstrates the removal of static/instance mismatches when resolving extension methods. It defines two extension methods named `M` for the `object` type, one static and the other an instance method. The call `object.M()` should resolve to the static method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nobject.M();\n\nstatic class E1\n{\n    extension(object)\n    {\n        public static string M() => throw null;\n    }\n}\n\nstatic class E2\n{\n    extension(object o)\n    {\n        public string M() => throw null;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Ref field property example in C#\nDESCRIPTION: This code snippet demonstrates the difference between returning a regular field as `ref` and returning a `ref` field as `ref` from a `ref struct`. A `ref` field can be returned as `ref` from a `ref struct`, but a normal field cannot because the *ref-safe-context* of `this` in a struct is function-member.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n```c#\nref struct RS\n{\n    ref int _refField;\n    int _field;\n\n    // Okay: this falls into bullet one above. \n    public ref int Prop1 => ref _refField;\n\n    // Error: This is bullet four above and the ref-safe-context of `this`\n    // in a `struct` is function-member.\n    public ref int Prop2 => ref _field;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using collection literals as an alternative to params in C#\nDESCRIPTION: Shows how collection literals can provide a simpler syntax than params for passing collections to methods. This example demonstrates calling a Log method with a collection literal of arguments instead of using params.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nlog.Log(\"({0}, {1}, {2})\", [x, y, z]);\n\nabstract class Logger\n{\n    public abstract void Log(string format, IEnumerable<object> args);\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Expression Concept in C#\nDESCRIPTION: This snippet shows a potential syntax for a pattern matching expression in C#, allowing concise switching based on patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Design-Review.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar x = match(e) { p => e, p => e, * => e }\n```\n\n----------------------------------------\n\nTITLE: Using Static Local Functions as Alternative to Instance Method Function Pointers in C#\nDESCRIPTION: This code demonstrates a workaround for instance method function pointers by using a static local function. It achieves the same functionality without the need for the 'instance' calling convention.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe class Instance {\n    void Use() {\n        static string toString(Instance i) => i.ToString();\n        delegate*<Instance, string> f = &toString;\n        f(this);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Null Values in Tuples\nDESCRIPTION: Example of comparing null values within tuples, demonstrating that null literals can be compared directly without requiring a specific type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/tuple-equality.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n(0, null) == (0, null)\n```\n\n----------------------------------------\n\nTITLE: Simple Primary Constructor Syntax for C# Class\nDESCRIPTION: Example of a minimal primary constructor syntax being discussed, where X and Y parameters might generate properties rather than just being captured as variables in the class scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-04.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Record Types in C#\nDESCRIPTION: Illustrates how record types support positional pattern matching, allowing for easy deconstruction and value comparison.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nPoint p = new Point(3, 4);\nif (p is Point(3, var y)) { // if X is 3\n    Console.WriteLine(y);   // print Y\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Method with New Constraints in C#\nDESCRIPTION: This code demonstrates the use of new constraint types: unmanaged, Enum, and Delegate. These constraints allow for more specific type restrictions in generic methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-24.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M<T1, T2, T3>()\n    where T1: unmanaged\n    where T2: Enum\n    where T3: Delegate\n    {\n        \n    }\n```\n\n----------------------------------------\n\nTITLE: Attribute Compatibility Examples in C#\nDESCRIPTION: Shows how T? annotations are equivalent to MaybeNull and AllowNull attributes for compatibility with C# 8 assemblies.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class A\n{\n    [return: MaybeNull] public abstract T F1<T>();\n    public abstract void F2<T>([AllowNull] T t);\n}\n\npublic class B : A\n{\n    public override T? F1<T>() where T : default { ... }       // matches A.F1<T>()\n    public override void F2<T>(T? t) where T : default { ... } // matches A.F2<T>()\n}\n```\n\n----------------------------------------\n\nTITLE: Substring Extraction Using Ranges in C#\nDESCRIPTION: Compares traditional substring extraction with a potential range-based syntax, demonstrating how ranges could simplify string slicing operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-14.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar startIndex = s.IndexOf(\"|\")+1;\nvar endIndex = s.IndexOf(startIndex, \"|\"); // -1 ?\nvar result = s.Substring(startIndex, endIndex-startIndex);\nvar result = s[startIndex..endIndex]\n```\n\n----------------------------------------\n\nTITLE: Defining a Record Class in C#\nDESCRIPTION: Example syntax for defining a record class with X and Y parameters. This demonstrates the concise declaration syntax that automatically generates constructor, properties, and common methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Notes.md#2025-04-21_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nclass Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Value-Based Equality Implementation in C#\nDESCRIPTION: Shows how to implement value-based equality and hash code calculation by delegating to the wrapped value type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic override bool Equals(object other) => (other as Person)?.Value.Equals(Value) ?? false; // or similar\npublic override int GetHashCode() => Value.GetHashCode;\n```\n\n----------------------------------------\n\nTITLE: Standard Non-Nullable Parameter\nDESCRIPTION: Basic method signature with non-nullable string parameter for comparison with attributed versions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-11-04.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string s)\n```\n\n----------------------------------------\n\nTITLE: Example of Attribute Syntax for Primary Constructors in C# Records\nDESCRIPTION: Example demonstrating proposed syntax for applying attributes to properties via primary constructor parameters in a data class. This shows how attributes might be applied when using the concise primary constructor syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-07-22.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ndata class C([property: MyAttribute]int X);\n```\n\n----------------------------------------\n\nTITLE: Comparing Switch Expression Syntax Options in C#\nDESCRIPTION: Presents various syntax options for switch expressions, including compact and formatted versions, and demonstrates their usage in variable assignments and method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-30.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\ne ? { 1: \"one\", 2: \"two\", var x when x > 2: \"two many\", \"too few\" }\n```\n\nLANGUAGE: c#\nCODE:\n```\ne ? \n{ \n    1: \"one\", \n    2: \"two\", \n    var x when x > 2: \"two many\", \n    \"too few\" \n}\n```\n\nLANGUAGE: c#\nCODE:\n```\ne switch \n{ \n    1: \"one\", \n    2: \"two\", \n    var x when x > 2: \"two many\", \n    \"too few\" \n}\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar x = e\n    ? 1 -> \"one\"\n    : 2 -> \"two\"\n    : var x when x > 2 -> \"too many\"\n    : _ -> \"too few\";\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar x = e ? \n{ \n    1: \"one\", \n    2: \"two\", \n    var x when x > 2: \"two many\", \n    \"too few\"\n};\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar x = e switch \n{ \n    1: \"one\", \n    2: \"two\", \n    var x when x > 2: \"two many\", \n    \"too few\" \n};\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(x switch { null => 0, _ => x.Length });\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(x switch { null: 0, x.Length });\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(x ? null -> 0 : _ -> x.Length);\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(x ? { null: 0, x.Length });\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(x ? null -> 0 : x.Length);\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(x ? { null -> 0, x.Length });\n```\n\n----------------------------------------\n\nTITLE: Iterator and Unsafe Context Examples in C#\nDESCRIPTION: Demonstrates various scenarios of iterator methods with unsafe contexts, including property accessors, partial methods, and lambda expressions. Shows how safe and unsafe contexts interact within iterator blocks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-unsafe-in-iterators-async.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nclass A : System.Attribute { }\nunsafe partial class C1\n{ // unsafe context\n    [/* unsafe context */ A]\n    IEnumerable<int> M1(\n        /* unsafe context */ int*[] x)\n    { // safe context (this is the iterator block implementing the iterator)\n        yield return 1;\n    }\n    IEnumerable<int> M2()\n    { // safe context (this is the iterator block implementing the iterator)\n        unsafe\n        { // unsafe context\n            { // unsafe context (this is *not* the block implementing the iterator)\n                yield return 1; // error: `yield return` in unsafe context\n            }\n        }\n    }\n    [/* unsafe context */ A]\n    unsafe IEnumerable<int> M3(\n        /* unsafe context */ int*[] x)\n    { // safe context\n        yield return 1;\n    }\n    [/* unsafe context */ A]\n    IEnumerable<int> this[\n        /* unsafe context */ int*[] x]\n    { // unsafe context\n        get\n        { // safe context\n            yield return 1;\n        }\n        set { /* unsafe context */ }\n    }\n    [/* unsafe context */ A]\n    unsafe IEnumerable<int> this[\n        /* unsafe context */ long*[] x]\n    { // unsafe context (the iterator declaration is unsafe)\n        get\n        { // safe context\n            yield return 1;\n        }\n        set { /* unsafe context */ }\n    }\n    IEnumerable<int> M4()\n    {\n        yield return 1;\n        var lam1 = async () =>\n        { // safe context\n          // spec violation: in Roslyn, this is an unsafe context in LangVersion 12 and lower\n            await Task.Yield(); // error in C# 12, allowed in C# 13\n            int* p = null; // error in both C# 12 and C# 13 (unsafe in iterator)\n        };\n        unsafe\n        {\n            var lam2 = () =>\n            { // unsafe context, lambda cannot be an iterator\n                yield return 1; // error: yield cannot be used in lambda\n            };\n        }\n        async void local()\n        { // safe context\n          // spec violation: in Roslyn, this is an unsafe context in LangVersion 12 and lower\n            await Task.Yield(); // error in C# 12, allowed in C# 13\n            int* p = null; // allowed in C# 12, error in C# 13 (breaking change in Roslyn)\n        }\n        local();\n    }\n    public partial IEnumerable<int> M5() // unsafe context (inherits from parent)\n    { // safe context\n        yield return 1;\n    }\n}\npartial class C1\n{\n    public partial IEnumerable<int> M5(); // safe context (inherits from parent)\n}\nclass C2\n{ // safe context\n    [/* unsafe context */ A]\n    unsafe IEnumerable<int> M(\n        /* unsafe context */ int*[] x)\n    { // safe context\n        yield return 1;\n    }\n    unsafe IEnumerable<int> this[\n        /* unsafe context */ int*[] x]\n    { // unsafe context\n        get\n        { // safe context\n            yield return 1;\n        }\n        set { /* unsafe context */ }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Scoped Ref Parameters in C#\nDESCRIPTION: Demonstrates how the 'scoped' modifier allows for APIs in C# 11 to maintain the same safety rules as C# 10 when dealing with references and spans. The example shows legal uses of scoped refs with parameters and local variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> CreateSpan(scoped ref int parameter)\n{\n    // Just as with C# 10, the implementation of this method isn't relevant to callers.\n}\n\nSpan<int> BadUseExamples(int parameter)\n{\n    // Legal in C# 10 and legal in C# 11 due to scoped ref\n    return CreateSpan(ref parameter);\n\n    // Legal in C# 10 and legal in C# 11 due to scoped ref\n    int local = 42;\n    return CreateSpan(ref local);\n\n    // Legal in C# 10 and legal in C# 11 due to scoped ref\n    Span<int> span = stackalloc int[42];\n    return CreateSpan(ref span[0]);\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression with Variable Capture in C#\nDESCRIPTION: Shows a typical lambda expression in C# that captures a variable from its enclosing scope. This example is used to illustrate the current behavior of lambda captures and the potential need for more explicit capture specifications.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvar name = GetName();\nvar query = customers.Where(c => c.Name == name);\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with ref structs in C#\nDESCRIPTION: Demonstrates the limitations of pattern matching with ref structs where only identity conversions are allowed. Shows valid and invalid pattern matching scenarios in generic contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T> where T : allows ref struct\n{\n    void M1(T t) { if (t is T x) { } } // ok (T is T)\n    void M2(R r) { if (r is R x) { } } // ok (R is R)\n    void M3(T t) { if (t is R x) { } } // error (T is R)\n    void M4(R r) { if (r is T x) { } } // error (R is T)\n}\nref struct R { }\n```\n\n----------------------------------------\n\nTITLE: Using Collection Expressions in Foreach and Spread Elements in C#\nDESCRIPTION: Examples of using collection expressions with inferred element types in foreach loops and spread elements. These scenarios do not require a specific collection type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-inferred-type.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nforeach (var i in [x, y, z]) { }\n\nint[] items = [x, y, .. b ? [z] : []];\n```\n\n----------------------------------------\n\nTITLE: List Pattern Syntax Definition in ANTLR\nDESCRIPTION: Defines the ANTLR grammar rules for list pattern matching syntax, including list pattern clauses, slice patterns, and primary pattern extensions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/list-patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nlist_pattern_clause\n  : '[' (pattern (',' pattern)* ','?)? ']'\n  ;\n\nlist_pattern\n  : list_pattern_clause simple_designation?\n  ;\n\nslice_pattern\n  : '..' pattern?\n  ;\n\nprimary_pattern\n  : list_pattern\n  | slice_pattern\n  | // all of the pattern forms previously defined\n  ;\n```\n\n----------------------------------------\n\nTITLE: Implementing IAsyncEnumerable with Ref Struct\nDESCRIPTION: Demonstrates implementing IAsyncEnumerable<T> interface on a ref struct type and using it in an await foreach statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S : IAsyncEnumerable<int>\n{\n    IAsyncEnumerator<int> IAsyncEnumerable<int>.GetAsyncEnumerator(CancellationToken token) {...}\n}\n\nclass C\n{\n    static async Task Main()\n    {\n        await foreach (var i in new S()) // S.IAsyncEnumerable<int>.GetAsyncEnumerator\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ref/await Restrictions in C#\nDESCRIPTION: Shows error cases and allowed usage patterns for ref locals in relation to await statements within code blocks. Illustrates how ref locals are restricted around await operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-unsafe-in-iterators-async.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    ref int x = ...;\n    await Task.Yield();\n    x.ToString();\n}\n{\n    ref int x = ...;\n    x.ToString();\n    await Task.Yield();\n}\n```\n\n----------------------------------------\n\nTITLE: Caching Lambda Expressions with Nullable Variables (C#)\nDESCRIPTION: This snippet illustrates how caching a lambda expression that captures nullable variables can lead to more nullable warnings. It demonstrates the complexity of tracking nullability across different execution paths and method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-04.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nM(string? x, string? y)\n{\n    Action f = () => y = x;\n    x = null;\n    //M1(f);\n    x = \"\";\n    M2(f);\n    y.Length;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation Priority Example\nDESCRIPTION: Shows behavior of params keyword with implicit interface implementation and priority inheritance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/overload-resolution-priority.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nvar c = new C();\nc.M(1, 2, 3); // error CS1501: No overload for method 'M' takes 3 arguments\n((I)c).M(1, 2, 3);\n\ninterface I\n{\n    void M(params int[] ints);\n}\n\nclass C : I\n{\n    public void M(int[] ints) { Console.WriteLine(\"params\"); }\n}\n```\n\n----------------------------------------\n\nTITLE: C# Function Pointer Conversions Example\nDESCRIPTION: Demonstrates conversion rules between different function pointer types based on signatures and calling conventions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nunsafe class Example {\n    void Conversions() {\n        delegate*<int, int, int> p1 = ...;\n        delegate* managed<int, int, int> p2 = ...;\n        delegate* unmanaged<int, int, int> p3 = ...;\n\n        p1 = p2; // okay p1 and p2 have compatible signatures\n        Console.WriteLine(p2 == p1); // True\n        p2 = p3; // error: calling conventions are incompatible\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation with 'field' Keyword\nDESCRIPTION: Shows how the basic auto-property example would be equivalent to explicit property implementations using the 'field' keyword to access the backing field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n// No 'field' symbol in scope.\npublic class Point\n{\n    public int X { get { return field; } set { field = value; } }\n    public int Y { get { return field; } set { field = value; } }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Type Inference with Collection Literals (Basic) in C#\nDESCRIPTION: This code snippet demonstrates a basic example of using collection literals with generic type inference. The goal is to infer the type parameter `T` of method `M` from the elements of the collection literal `[1, 2, 3]`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-21.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvoid M<T>(T[] values);\nM([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Declaring Struct with Non-Nullable Reference Type Field in C#\nDESCRIPTION: Illustrates the potential issue with non-nullable reference type fields in structs, as structs can be uninitialized leading to null reference exceptions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-09.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstruct S\n{\n    public string s; // warn anyway?\n    public S(string s) => this.s = s;\n}\n\nS[] a = ...; // array of uninitialized S's\nvar l = a[0].s.Length; // null reference exception\n```\n\n----------------------------------------\n\nTITLE: Lowering List Pattern '{0, 1, ..}' in C#\nDESCRIPTION: Example of lowering a list pattern that checks for a collection starting with 0 and 1, followed by any number of elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/list-patterns-enumerables.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n@{\n  var helper = new ListPatternHelper(collection, 2, 0);\n\n  helper.TryGetStartElement(index: 0, out var element0) && element0 is 0 &&\n  helper.TryGetStartElement(1, out var element1) && element1 is 1\n}\n```\n\n----------------------------------------\n\nTITLE: CLR Support API for Default Interface Implementation in C#\nDESCRIPTION: This code defines a runtime feature constant to indicate support for default interface implementation, allowing compilers to detect runtime compatibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    public static class RuntimeFeature\n    {\n        // Presence of the field indicates runtime support\n        public const string DefaultInterfaceImplementation = nameof(DefaultInterfaceImplementation);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing Partial Property Examples in C#\nDESCRIPTION: Example showing both a defining declaration (with semicolon bodies) and an implementing declaration of a partial property in a partial class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npartial class C\n{\n    // Defining declaration\n    public partial string Prop { get; set; }\n\n    // Implementing declaration\n    public partial string Prop { get => field; set => field = value; }\n}\n```\n\n----------------------------------------\n\nTITLE: String Interpolation Grammar in C#\nDESCRIPTION: Defines the lexical grammar for string interpolation in C#, including format specifications and escape sequences.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\ninterpolated-string:\n    $ \" \"\n    $ \" interpolated-string-literal-characters \"\n\ninterpolated-string-literal-characters:\n    interpolated-string-literal-part interpolated-string-literal-parts\n    interpolated-string-literal-part\n```\n\n----------------------------------------\n\nTITLE: Generic Interface Type Constraint Example\nDESCRIPTION: Example of a generic interface constraint pattern mentioned in the static abstracts discussion, demonstrating the Curiously Recurring Template Pattern (CRTP).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-30.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nINumeric<T> where T : INumeric<T>\n```\n\n----------------------------------------\n\nTITLE: Prefix Increment/Decrement Operator Examples with Reference Types\nDESCRIPTION: Examples of prefix increment operations with reference types, demonstrating different scenarios including error cases and proper usage with instance increment operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar a = ++(new C()); // error: not a variable\nvar b = ++a; // var temp = a; temp.op_Increment(); b = temp; \n++b; // b.op_Increment();\nvar d = ++C.P1; // error: setter is missing\n++C.P1; // error: setter is missing\nvar e = ++C.P2; // var temp = C.op_Increment(C.get_P2()); C.set_P2(temp); e = temp;\n++C.P2; // var temp = C.op_Increment(C.get_P2()); C.set_P2(temp);\n\nclass C\n{\n    public static C P1 { get; } = new C();\n    public static C P2 { get; set; } = new C();\n\n    public static C operator ++(C x) => ...;\n    public void operator ++() => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Expression-Based Pattern Matching in C#\nDESCRIPTION: Demonstrates relaxed single-declaration rules within expression boundaries where each variable is assigned once.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/pattern-variables.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is C c || e is Wrapper { Prop: C c }) ;\nif (b ? e is C c : e is Wrapper { Prop: C c }) ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Warning for Implicit Conversion of Lock Type\nDESCRIPTION: Example showing how implicit conversion of a System.Threading.Lock to object will trigger a compiler warning. When used with the lock keyword after conversion, it will use monitor-based locking instead of the Lock-specific behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/lock-object.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nobject l = new System.Threading.Lock(); // warning\nlock (l) { } // monitor-based locking is used here\n```\n\n----------------------------------------\n\nTITLE: Option Union Type Definition in C#\nDESCRIPTION: Defines an Option union struct type for representing optional values, similar to Option types in other languages.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\npublic union struct Option<TValue>\n{\n    Some(TValue value);\n    None = default;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-line Raw String Literal in C#\nDESCRIPTION: Demonstrates the basic syntax for creating a multi-line raw string literal with automatic indentation removal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar xml = \"\"\"\n          <element attr=\"content\"/>\n          \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Current Array Initialization Syntax in C#\nDESCRIPTION: Examples of existing array initialization syntax patterns in C# using the new keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/stackalloc-array-initializers.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew int[3]\nnew int[3] { 1, 2, 3 }\nnew int[] { 1, 2, 3 }\nnew[] { 1, 2, 3 }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Simplified Lambda Parameter Declaration in C#\nDESCRIPTION: Example showing how the proposed feature allows for simplified lambda parameter declarations, particularly with the 'out' modifier.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/simple-lambda-parameters-with-modifiers.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ndelegate bool TryParse<T>(string text, out T result);\n\nTryParse<int> parse1 = (text, out result) => Int32.TryParse(text, out result);\n```\n\n----------------------------------------\n\nTITLE: Auto-Accessors in Partial Properties with 'field' Keyword in C#\nDESCRIPTION: Examples examining whether partial property implementations should be able to use auto-accessors with the 'field' keyword, showing various combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\npartial class C\n{\n    public partial int Prop0 { get; set; }\n    public partial int Prop0 { get => field; set => field = value; } // this is equivalent to the two \"semi-auto\" forms below.\n\n    public partial int Prop1 { get; set; }\n    public partial int Prop1 { get => field; set; } // is this a valid implementation part?\n\n    public partial int Prop2 { get; set; }\n    public partial int Prop2 { get; set => field = value; } // what about this? will there be disagreement about which is the \"best\" style?\n\n    public partial int Prop3 { get; }\n    public partial int Prop3 { get => field; } // it will only be valid to use at most 1 auto-accessor, when a second accessor is manually implemented.\n```\n\n----------------------------------------\n\nTITLE: Indexer Pattern Example in C#\nDESCRIPTION: Example showing proposed syntax for indexer patterns allowing deconstruction of objects with indexers, including array indices and ranges.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-16.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n{ [1]: pattern, [2..^4]: var slice }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Special Handling of Where Clause for Null Checks in C#\nDESCRIPTION: This snippet shows a proposed solution for handling null tests on collection elements in LINQ queries. The Where clause filters out null values, potentially changing the nullability of the return type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<string> M(IEnumerable<string?> items)\n{\n    return items.Where(x => x != null); // no warning.\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Target Typing for Tuple Literals in C#\nDESCRIPTION: Demonstrates how tuple literals can be target typed to compatible tuple types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n(string name, byte age) t = (null, 5); // Ok: the expressions null and 5 convert to string and byte\n```\n\n----------------------------------------\n\nTITLE: Managing Span<int> Parameter Swapping with ref scoped in C#\nDESCRIPTION: Illustrates parameter scope isolation and valid operations between ref scoped parameters, including local variable assignments and restrictions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Swap(ref scoped Span<int> p1, ref scoped Span<int> p2)\n{\n    // Error: can't assign current parameter 2 to current parameter 1\n    p2 = p1;\n\n    // Error: can't assign current parameter 1 to current parameter 2\n    p1 = p2;\n\n    // Okay: as current parameter 1 and 2 can be converted to current method\n    scoped Span<int> local1 = p1; \n    scoped Span<int> local2 = p2; \n\n    // Okay: however the safe-to-escape here is current parameter N, not \n    // current method so this could cause a bit of confusion later on\n    Span<int> local3 = p1; \n    Span<int> local4 = p2; \n\n    // Okay: the safe-to-escape of the value is inferred in this case as it is \n    // done for ref locals today.\n    ref Span<int> refLocal1 = ref p1;\n    ref Span<int> refLocal2 = ref p2;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ExperimentalAttribute in C#\nDESCRIPTION: Definition of the ExperimentalAttribute class that can be applied to various code elements to mark them as experimental. The attribute requires a diagnosticId parameter and provides optional properties for URL format and custom messages.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/experimental-attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Assembly |\n                    AttributeTargets.Module |\n                    AttributeTargets.Class |\n                    AttributeTargets.Struct |\n                    AttributeTargets.Enum |\n                    AttributeTargets.Constructor |\n                    AttributeTargets.Method |\n                    AttributeTargets.Property |\n                    AttributeTargets.Field |\n                    AttributeTargets.Event |\n                    AttributeTargets.Interface |\n                    AttributeTargets.Delegate, Inherited = false)]\n    public sealed class ExperimentalAttribute : Attribute\n    {\n        public ExperimentalAttribute(string diagnosticId)\n        {\n            DiagnosticId = diagnosticId;\n        }\n\n        public string DiagnosticId { get; }\n        public string? UrlFormat { get; set; }\n        public string? Message { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Nullable Type for Implicitly Typed Local Variables in C#\nDESCRIPTION: Demonstrates how 'var' infers an annotated type for reference types and unconstrained type parameters. For string literals, 'var' is inferred as 'string?', and for new instances of unconstrained generic types, 'var' is inferred as 'T?'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar s = \"\";\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar t = new T();\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Example\nDESCRIPTION: Example of collection expression syntax mentioned in context of ReadOnlySpan initialization feature discussion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-09.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Generic Method with Nullable Class Constraint - Self Assignment\nDESCRIPTION: Demonstrates behavior of nullable analysis with generic type parameter self-assignment. No warning is produced because T could be nullable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M<T>(T p1) where T : class?\n{\n    p1 = p1; // p1 may be null, but we don't produce a warning because\n             // the T could be nullable\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Interface Method Resolution in C#\nDESCRIPTION: This code snippet illustrates a complex case of method resolution with interface inheritance, overrides, and the base() syntax. It demonstrates potential ambiguity in method lookup when multiple interfaces are involved and highlights the challenges in determining which implementation to call.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-27.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface I1\n{ \n    void M(int) { }\n}\n\ninterface I2\n{\n    void M(short) { }\n}\n\ninterface I3\n{\n    override void I1.M(int) { }\n}\n\ninterface I4 : I3\n{\n    void M2()\n    {\n        base(I3).M(0) // What does this do?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ImmutableArray<T> With Span Directly in C#\nDESCRIPTION: This method generates an ImmutableArray<T> while providing a span to the underlying storage. The caller will populate the collection using the span, allowing for direct manipulation of memory without additional copies.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-04-05.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Create ImmutableArray<T> and return a span to the underlying storage.\npublic static ImmutableArray<T> CreateImmutableArray<T>(int size, out Span<T> span)\n{\n    // ...\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<T> __span;\nImmutableArray<T> result = CreateImmutableArray(e.Count + 2, out __span);\n\nint __i = 0;\n__span[__i++] = x;\nforeach (T __t in e)\n    __span[__i++] = __t;\n__span[__i++] = y;\n```\n\n----------------------------------------\n\nTITLE: Dictionary Type Inference Example in C#\nDESCRIPTION: Demonstrates how type inference works with dictionary expressions using KeyValuePair types and the AsDictionary method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\nKeyValuePair<object, long> kvp = ...;\nvar a = AsDictionary([\"mads\": 21, \"dustin\": 22, kvp]); // AsDictionary<object, long>(Dictionary<object, long> arg)\n\nstatic Dictionary<TKey, TValue> AsDictionary<TKey, TValue>(Dictionary<TKey, TValue> arg) => arg;\n```\n\n----------------------------------------\n\nTITLE: Range Iteration Examples\nDESCRIPTION: Demonstrates foreach loop usage with range operators using constant values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-22.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nforeach (var x in 1..100) { ... }\n\nforeach (var x in 0..100) { ... }\n```\n\n----------------------------------------\n\nTITLE: Interface Collection with Ad Hoc Union in C#\nDESCRIPTION: Demonstrates using an interface collection with an ad hoc union type, showing interchangeability through generics.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nIReadOnlyList<(Cat or Dog)> pets = F<Dog, Cat>(rufus, petunia);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullability and Setter Analysis with field Keyword in C#\nDESCRIPTION: This snippet illustrates the nullability concerns with field-backed properties. It shows a case where a warning should be generated due to potential null reference issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    string Prop\n    {\n        get => field;\n\n        // getter is not null-resilient, so `field` is not-annotated.\n        // We should warn here that `field` may be null when exiting.\n        set { }\n    }\n\n    public C()\n    {\n        Prop = \"a\"; // ok\n    }\n\n    public static void Main()\n    {\n        new C().Prop.ToString(); // NRE at runtime\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation with Nullability in C#\nDESCRIPTION: Shows correct implementation of interface with nullability constraints on type parameters. Demonstrates how nullability annotations must match when implementing interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-10.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninterface I1<T>\n{\n    void M<U>() where U : T\n}\n\nclass C : I1<C?>\n{\n    void I1<C?>.M<X>() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Future Pattern Variable Sharing in C#\nDESCRIPTION: This example demonstrates a potential future feature where case clauses could share variables extracted from similar but different patterns. Currently not supported but considered for future implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\ncase (int age, string name):\ncase (string name, int age):\n    WriteLine($\"{name} is {age} years old.\");\n    break;\n```\n\n----------------------------------------\n\nTITLE: Returning Tuples by Position in C#\nDESCRIPTION: Shows how to construct and return a tuple value with members assigned by position, target-typed to the method's return type, similar to a parameter list.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic (int sum, int count) Tally(IEnumerable<int> values) \n{\n    var sum = 0; var count = 0;\n    foreach (var value in values) { sum += value; count++; }\n    return (sum, count); // target typed to the return type\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Ref and In Extension Methods in C#\nDESCRIPTION: Shows how to declare extension methods that take the this parameter by reference (ref) or as a readonly reference (in). Ref extensions can only be called on writable LValues, while in extensions allow implicit copying if necessary.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n// this can be called on either RValue or an LValue\npublic static void Reader(in this Guid self)\n{\n    // do something nonmutating.\n    WriteLine(self == default(Guid));\n}\n\n// this can be called only on an LValue\npublic static void Mutator(ref this Guid self)\n{\n    // can mutate self\n    self = new Guid();\n}\n```\n\n----------------------------------------\n\nTITLE: For-Loop Equivalent Scoping Example in C#\nDESCRIPTION: Example showing the equivalent scoping behavior of a for-loop with declaration expressions, rewritten as nested blocks and a while loop to illustrate the intended scope containment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-01-06.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n{\n  int i = (int a = 0);\n  while (i < (int b = 10))\n  {\n    { i += (int c = 1)); }\n    (int d += i);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Primary Pattern Syntax in ANTLR\nDESCRIPTION: ANTLR grammar defining the syntax for primary patterns, including list, length, and slice patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/list-patterns-enumerables.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nprimary_pattern\n  : list_pattern\n  | length_pattern\n  | slice_pattern\n  | // all of the pattern forms previously defined\n  ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Interface Method with MemberwiseClone in C#\nDESCRIPTION: An example interface implementation showing a potential use case for accessing object.MemberwiseClone() within an interface. The example demonstrates creating a WithX method that clones the implementing object and modifies a property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-01.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface IPoint\n{\n    public int X { get; protected set;}\n    public int Y { get; protected set;}\n\n    public IPoint WithX(int x)\n    {\n        var tmp = MemberwiseClone();\n        tmp.X = x;\n        return tmp;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Definite Assignment Issues with 'not' Pattern in C#\nDESCRIPTION: Demonstrates a scenario where definite assignment of a pattern variable in a 'not' pattern is ambiguous, potentially requiring special handling.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is not int i) return;\nM(i); // is i definitely assigned here?\n```\n\n----------------------------------------\n\nTITLE: Property Signature Example in C#\nDESCRIPTION: Illustrates the property signature examples used throughout the document, where `T` is not a value type. This establishes the context for discussing how the `field` keyword interacts with nullable reference types within properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n\"T Prop { ...field... } // or\\nT Prop => ...field...;\"\n```\n\n----------------------------------------\n\nTITLE: Using 'in' Extension Methods in C#\nDESCRIPTION: Shows how 'in' extension methods can be called with RValues or expressions requiring implicit conversions as the receiver.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static IEnumerable<T> Concat<T>(in this (IEnumerable<T>, IEnumerable<T>) arg)  => . . .;\n\n(\"aa\", \"bb\").Concat<char>()    // not an error.\n```\n\n----------------------------------------\n\nTITLE: Readonly Method Usage with 'in' Parameters\nDESCRIPTION: Shows how readonly methods affect compiler behavior when used with 'in' parameters, preventing unnecessary copying of struct instances.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/readonly-instance-members.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class MyClass\n{\n    public static float ExistingBehavior(in Vector2 vector)\n    {\n        return vector.GetLength();\n    }\n\n    public static float ReadonlyBehavior(in Vector2 vector)\n    {\n        return vector.GetLengthReadonly();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Range Operator\nDESCRIPTION: ANTLR grammar definition for range expressions and multiplicative expressions, establishing operator precedence.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_4\n\nLANGUAGE: antlr\nCODE:\n```\nrange_expression\n    : unary_expression\n    | range_expression? '..' range_expression?\n    ;\n\nmultiplicative_expression\n    : range_expression\n    | multiplicative_expression '*' range_expression\n    | multiplicative_expression '/' range_expression\n    | multiplicative_expression '%' range_expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Disallowed Expression Forms for nameof Operator\nDESCRIPTION: Comprehensive list of expression types that are not permitted as arguments to the nameof operator in C#. These restrictions ensure the argument has a clear name and won't have side effects when evaluated.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n    invocation-expression        e(args)\n    assignment                   x += 15\n    query-expression             from y in z select y\n    lambda-expression            () => e\n    conditional-expression       a ? b : c\n    null-coalescing-expression   a?? b\n    binary-expression            ||, &&, |, ^, &, ==, !=,\n                                 <, >, <=, >=, is, as, <<,\n                                 >>, +, -, *, /, %\n    prefix-expression            +, -, !, ~, ++, --,\n                                 *, &, (T)e\n    postfix-expression           ++, --\n    array-creation-expression    new C[â€¦]\n    object-creation-expression   new C(â€¦)\n    delegate-creation-expression new Action(â€¦)\n    anonymous-object-creation-expression new {â€¦}\n    typeof-expression            typeof(int)\n    checked-expression           checked(â€¦)\n    unchecked-expression         unchecked(â€¦)\n    default-value-expression     default(â€¦)\n    anonymous-method-expression  delegate {â€¦}\n    pointer-member-access        e->x\n    sizeof-expression            sizeof(int)\n    literal                      \"hello\", 15\n    parenthesized-expression     (x)\n    element-access               e[i]\n    base-access-indexed          base[i]\n    await-expression             await e\n    nameof-expression            nameof(e)\n    vb-dictionary-lookup         e!foo \n```\n\n----------------------------------------\n\nTITLE: Migration Example for Non-Extension Static Methods in C#\nDESCRIPTION: This snippet demonstrates how non-extension static methods, such as Enumerable.Range, would be migrated to the new modern extension syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic class Enumerable\n{\n    public static IEnumerable<int> Range(int start, int count) { ... }\n}\n\n\nextension Enumerable\n{\n    // Exact same signature.  No 'for-clause'.\n    public static IEnumerable<int> Range(int start, int count) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional Pattern Matching Without Shared Variables in C#\nDESCRIPTION: Shows the more verbose traditional approach without shared variable declarations, requiring separate if statements and switch cases for each pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/pattern-variables.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is C c1) \n    return c1;\nif (e is Wrapper { Prop: C c2 }) \n    return c2;\n\nExpr Simplify(Expr e)\n{\n  switch (e) {\n    case Mult(Const(1), var x):\n        return Simplify(x);\n    case Mult(var x, Const(1)): \n        return Simplify(x);\n    case Add(Const(0), var x):\n        return Simplify(x);\n    case Add(var x, Const(0)):\n        return Simplify(x);\n    // ..\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructor Pattern Example\nDESCRIPTION: Shows how pattern matching can be used with deconstructors for positional deconstruction of objects.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nif (o is Person(\"George\", var last)) ...\n```\n\n----------------------------------------\n\nTITLE: Using Inline Arrays in Foreach Statements in C#\nDESCRIPTION: This snippet illustrates how inline array types can be used as collections in foreach statements, showing examples with value, writable reference, and readonly reference variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nforeach (var a in getBufferAsValue())\n{\n    WriteLine(a);\n}\n\nforeach (var b in getBufferAsWritableVariable())\n{\n    WriteLine(b);\n}\n\nforeach (var c in getBufferAsReadonlyVariable())\n{\n    WriteLine(c);\n}\n\nBuffer10<int> getBufferAsValue() => default;\nref Buffer10<int> getBufferAsWritableVariable() => default;\nref readonly Buffer10<int> getBufferAsReadonlyVariable() => default;\n```\n\n----------------------------------------\n\nTITLE: UnscopedRef Implementation Example\nDESCRIPTION: Demonstrates correct and incorrect usage of UnscopedRef attribute in struct properties and parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_20\n\nLANGUAGE: c#\nCODE:\n```\nstruct S\n{\n    int field; \n\n    // Error: `field` has the ref-safe-context of `this` which is *function-member* because \n    // it is a `scoped ref`\n    ref int Prop1 => ref field;\n\n    // Okay: `field` has the ref-safe-context of `this` which is *caller-context* because \n    // it is a `ref`\n    [UnscopedRef] ref int Prop1 => ref field;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Target-typed new with XmlReader Configuration in C#\nDESCRIPTION: Demonstrates using target-typed new for creating configuration objects where type can be inferred from the context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-new.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nXmlReader.Create(reader, new() { IgnoreWhitespace = true });\n```\n\n----------------------------------------\n\nTITLE: Record Property Implementation Example\nDESCRIPTION: Example showing record declaration with explicit property implementation and potential key modifier usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-12.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nrecord Point1(int X)\n{\n    public int X { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Qualified Member Access for Extension Methods in C#\nDESCRIPTION: Demonstrates the usage of qualified member access to call static and instance members from 'MyExtensions'. This approach can clarify which extension class is being referenced, which is useful in case of ambiguity.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = IEnumerable<int>.(MyExtensions.Range)(0, 10);\nvar empty = IEnumerable<int>.(MyExtensions.Empty);\nrange (MyExtensions.+=) 5; /* or */ (MyExtensions.+)(range, 5);\nReadOnlySpan<int> span = (MyExtensions.implicit)(range);\n\n// Instance extension members\nvar query = range.(MyExtensions.Where)(i => i < 10);\nvar isEmpty = query.(MyExtensions.IsEmpty);\nvar first = query.(MyExtensions.this)[0];\nvar repetition = (MyExtensions.new) IEnumerable<int>(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Custom Union Struct with Union Attribute in C#\nDESCRIPTION: Demonstrates how to create a custom union type as a struct with the Union attribute and the required pattern-matching API.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\n[Union]\npublic struct U    \n{\n    public record struct A(int x, string y);\n    public record struct B(int z);\n\n    public bool TryGetA(out var A a) { ... }\n    public bool TryGetB(out var B b) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Valid Lambda Conversions Without Specifying Default Parameter Values in C#\nDESCRIPTION: This code snippet shows cases that should be accepted for backward compatibility. When a lambda doesn't specify any default parameter value while being assigned to a delegate type that has default parameters, the conversion is allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-07-13.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ndelegate void D(int i = 0);\nD d1 = i => {}; // Fine: no value specified\nD d2 = (int i) => {}; // Fine: no value specified\n```\n\n----------------------------------------\n\nTITLE: Directly indexing fixed-size array fields in movable context in C#\nDESCRIPTION: This code demonstrates the scenario that would be permitted with the proposed change. It allows direct indexing of a fixed-size array field in a movable context without requiring pinning, while still maintaining the unsafe context requirement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/indexing-movable-fixed-fields.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe struct S\n{\n    public fixed int myFixedField[10];\n}\n\nclass Program\n{\n    static S s;\n\n    unsafe static void Main()\n    {\n        int p = s.myFixedField[5]; // indexing fixed-size array fields would be ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compound Assignment with Reference Types in C#\nDESCRIPTION: This code snippet illustrates how compound assignment operators work with reference types in C#. It shows error cases, behavior with properties, and the evaluation order of expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nvar a = (new C())+=10; // error: not a variable\nvar b = a += 100; // var temp = a; temp.op_AdditionAssignment(100); b = temp; \nvar c = b + 1000; // c = C.op_Addition(b, 1000)\nc += 5; // c.op_AdditionAssignment(5);\nvar d = C.P1 += 11; // error: setter is missing\nvar e = C.P2 += 12; // var temp = C.op_Addition(C.get_P2(), 12); C.set_P2(temp); e = temp;\nC.P2 += 13; // var temp = C.op_Addition(C.get_P2(), 13); C.set_P2(temp);\n\nclass C\n{\n    public static C P1 { get; } = new C();\n    public static C P2 { get; set; } = new C();\n\n    // op_Addition\n    public static C operator +(C x, int y) => ...;\n\n    // op_AdditionAssignment\n    public void operator +=(int y) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: RegexGenerated Partial Method Example in C#\nDESCRIPTION: Demonstrates a proposed use case for extended partial methods with source generators using a regex matching example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[RegexGenerated(\"(dog|cat|fish)\")] \npartial bool IsPetMatch(string input);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating LINQ Query with Out Variables in C#\nDESCRIPTION: This snippet shows a LINQ query using out variables and tuple deconstruction. It parses strings to integers and selects successful parse results.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-25.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nfrom s in strings\nlet t = (b: int.TryParse(out var n), n)\nwhere t.b\nselect t.n\n```\n\n----------------------------------------\n\nTITLE: Extension Declarations with Member-Level Underlying Types (C#)\nDESCRIPTION: This C# code snippet demonstrates the proposed syntax for declaring underlying types at the member level within an extension declaration using a `.` token. This allows different extension methods to target different types within the same extension declaration, promoting code grouping and readability.  The code illustrates the `IsKind` and `ContainsDirective` methods targeting different syntax types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class CSharpExtensions\n{\n    extension\n    {\n        public bool (SyntaxToken).IsKind(SyntaxKind kind) => ...;\n        public bool (SyntaxTrivia).IsKind(SyntaxKind kind) => ...;\n        [param: NotNullWhen(true)]\n        public bool (SyntaxNode?).IsKind(SyntaxKind kind) => ...;\n        public bool (SyntaxNodeOrToken).IsKind(SyntaxKind kind) => ...;\n        public bool (SyntaxNode).ContainsDirective(SyntaxKind kind) => ...;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Interface Methods with Base Calls in C#\nDESCRIPTION: Example showing interface inheritance with explicit implementations and base call syntax for resolving multiple interface method implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-14.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface I1 { void M(); }\ninterface I2 { void M(); }\ninterface I3 : I1, I2 { void I1.M() { } void I2.M() { } }\ninterface I4 : I1, I2 { void I1.M() { } void I2.M() { } }\ninterface I5 : I3, I4\n{\n    void I1.M()\n    {\n        base<I3>(I1).M();\n        base<I4>(I1).M();\n    }\n    void I2.M()\n    {\n        base<I3>(I2).M();\n        base<I4>(I2).M();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Workaround: Default Value Assignment\nDESCRIPTION: Alternative Pre-C# 6.0 workaround for struct auto-property initialization by explicitly assigning the default value to 'this'. This initializes all fields to their default values but disables definite assignment analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-6.0/struct-autoprop-init.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S \n{ \n    int X { get; set; } \n    int Y { get; set; } \n    public S(int x, int y) \n    { \n        this = default(S); \n        this.X = x; \n        this.Y = y; \n    } \n} \n```\n\n----------------------------------------\n\nTITLE: Conditional Attribute Example on Lambda Expressions\nDESCRIPTION: Example code demonstrating the potential use of System.Diagnostics.ConditionalAttribute on lambda expressions, which is noted as an open issue regarding whether this should be allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n([Conditional(\"DEBUG\")] static (x, y) => Assert(x == y))(a, b); // ok?\n```\n\n----------------------------------------\n\nTITLE: String Interpolation with Format Specifiers in C#\nDESCRIPTION: Shows how format specifiers can be included in string interpolation expressions, allowing for alignment and other formatting options similar to String.Format.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-21.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n$\"Hello, {name}, you have {amount,-3} donut\\{s\\} left.\"\n```\n\n----------------------------------------\n\nTITLE: Dictionary Overload Resolution Examples in C#\nDESCRIPTION: Illustrates overload resolution scenarios between different dictionary types and interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\nvoid X(IDictionary<A, B> dict);\nvoid X(Dictionary<A, B> dict);\n\nvoid X(IEnumerable<KeyValuePair<A, B>> dict);\nvoid X(Dictionary<A, B> dict);\n\nvoid X(Dictionary<A, B> dict);\nvoid X(ImmutableDictionary<A, B> dict);\n\nX([a, b]); // ambiguous\n```\n\n----------------------------------------\n\nTITLE: List with KeyValuePair Example\nDESCRIPTION: Example showing how collection expressions containing KeyValuePair elements can instantiate a collection type with an element of KeyValuePair.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nList<KeyValuePair<string, int>> nameToAge = [\"mads\": 21];\n```\n\n----------------------------------------\n\nTITLE: Alternative Collection Construction API with Create Method\nDESCRIPTION: Alternative approach for constructing collections using a static Create method that accepts a ReadOnlySpan of elements\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-05-26.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionLiteralBuilder(\n    typeof(MyCollection),\n    nameof(MyCollection.Create))]\npublic class MyCollection<T> : IEnumerable<T> { }\n\npublic static class MyCollection\n{\n    public static MyCollection<T> Create<T>(ReadOnlySpan<T> elements);\n}\n```\n\n----------------------------------------\n\nTITLE: Pointer Arithmetic with Native Integers in C#\nDESCRIPTION: This code demonstrates how native integers (nint and nuint) are promoted to long and ulong for pointer arithmetic operations in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic T* AddLeftS(nint x, T* y) => x + y;   // T* operator +(long left, T* right)\nstatic T* AddLeftU(nuint x, T* y) => x + y;  // T* operator +(ulong left, T* right)\nstatic T* AddRightS(T* x, nint y) => x + y;  // T* operator +(T* left, long right)\nstatic T* AddRightU(T* x, nuint y) => x + y; // T* operator +(T* left, ulong right)\nstatic T* SubRightS(T* x, nint y) => x - y;  // T* operator -(T* left, long right)\nstatic T* SubRightU(T* x, nuint y) => x - y; // T* operator -(T* left, ulong right)\n```\n\n----------------------------------------\n\nTITLE: Implementing Instance Extension Members with Receiver Parameter (C#)\nDESCRIPTION: Demonstrates how to implement instance extension members using the receiver parameter name to refer to the receiver object.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable source)\n    {\n        // 'source' refers to receiver\n        public bool IsEmpty => !source.GetEnumerator().MoveNext();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Record Struct Syntax in C#\nDESCRIPTION: Shows a potential syntax for declaring a record struct, which combines features of records with the value semantics of structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-27.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nrecord struct Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Ref Readonly Variable Usage\nDESCRIPTION: Demonstrates the usage of ref readonly variables and the different ways to express them in the language, including method parameter passing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-02.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nref readonly tmp = ref Get();\nM(in tmp);\n```\n\n----------------------------------------\n\nTITLE: Defining Predefined Unsigned Right Shift Operators in C#\nDESCRIPTION: This code snippet defines the signatures of the predefined unsigned right shift operators for various integral types in C#. These operators perform an unsigned right shift on the left operand (`x`) by a number of bits specified by the right operand (`count`). The high-order bits are filled with zeros during the shift operation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/unsigned-right-shift-operator.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n\"int operator >>>(int x, int count);\\n   uint operator >>>(uint x, int count);\\n   long operator >>>(long x, int count);\\n   ulong operator >>>(ulong x, int count);\\n   nint operator >>>(nint x, int count);\\n   nuint operator >>>(nuint x, int count);\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Compatible Extension Methods (C#)\nDESCRIPTION: Demonstrates how to declare extension methods that are compatible with classic extension methods by using the 'this' modifier in the receiver specification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TSource>(this IEnumerable<TSource> source) // Generate compatible extension methods\n    {\n        public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { ... }\n        public IEnumerable<TSource> Select<TResult>(Func<TSource, TResult> selector)  { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Math with Associated Types in C#\nDESCRIPTION: Example demonstrating the limitations of using associated types for self-type constraints in generic math implementations. Shows how compiler type inference would be problematic without explicit generic type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-11-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// How is the compiler to know that the `INumber.self` of the `left` parameter is the same as the `INumber.self` of the `right` parameter, and how does it make\n// any assumptions about the return type?\npublic INumber.self Add(INumber.self left, INumber.self right) => left + right;\n\n// Users would actually need to resort to generics to relate these parameters:\npublic T Add<T>(T left, T right) where T : INumber.self => left + right;\n```\n\n----------------------------------------\n\nTITLE: LINQ Join Method Signatures\nDESCRIPTION: API signatures for the Join, LeftJoin, and RightJoin extension methods in .NET 10.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(\n    this IEnumerable<TOuter> outer,\n    IEnumerable<TInner> inner,\n    Func<TOuter, TKey> outerKeySelector,\n    Func<TInner, TKey> innerKeySelector,\n    Func<TOuter, TInner, TResult> resultSelector);\n\npublic static IEnumerable<TResult> LeftJoin<TOuter, TInner, TKey, TResult>(\n    this IEnumerable<TOuter> outer,\n    IEnumerable<TInner> inner,\n    Func<TOuter, TKey> outerKeySelector,\n    Func<TInner, TKey> innerKeySelector,\n    Func<TOuter, TInner?, TResult> resultSelector);\n\npublic static IEnumerable<TResult> RightJoin<TOuter, TInner, TKey, TResult>(\n    this IEnumerable<TOuter> outer,\n    IEnumerable<TInner> inner,\n    Func<TOuter, TKey> outerKeySelector,\n    Func<TInner, TKey> innerKeySelector,\n    Func<TOuter?, TInner, TResult> resultSelector);\n```\n\n----------------------------------------\n\nTITLE: C# Function Pointer Basic Usage Example\nDESCRIPTION: Demonstrates basic usage of function pointers compared to standard delegates in C#, showing invocation syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nunsafe class Example\n{\n    void M(Action<int> a, delegate*<int, void> f)\n    {\n        a(42);\n        f(42);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Factory Methods for Checked Operations in LINQ Expression Trees\nDESCRIPTION: Defines the factory methods that will be used to create checked operations in LINQ Expression Trees. These methods support creating expression tree nodes for checked arithmetic operations and conversions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static UnaryExpression NegateChecked (Expression expression, MethodInfo? method);\n\npublic static BinaryExpression AddChecked (Expression left, Expression right, MethodInfo? method);\npublic static BinaryExpression SubtractChecked (Expression left, Expression right, MethodInfo? method);\npublic static BinaryExpression MultiplyChecked (Expression left, Expression right, MethodInfo? method);\n\npublic static UnaryExpression ConvertChecked (Expression expression, Type type, MethodInfo? method);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Missing Nullable Warning in Constructors\nDESCRIPTION: Example code showing how nullable warnings are currently missing in constructors when a property is used before initialization. This is the issue the improved nullable analysis proposal aims to fix.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-07-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public string Prop { get; set; }\n    public C() // we get no \"uninitialized member\" warning, as expected\n    {\n        Prop.ToString(); // unexpectedly, there is no \"possible null receiver\" warning here\n        Prop = \"\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conceptual Example of Extensions Implementing Interfaces in C#\nDESCRIPTION: A hypothetical example showing how extensions might work with interfaces in the future. The example demonstrates implementing IDisposable for a string type through an extension container.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\npublic extensions E for string : IDisposable\n{\n    public void s.Dispose()\n    {\n       \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Global Using Example in C#\nDESCRIPTION: Example of global using directive syntax showing Task import from System.Threading.Tasks\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-07-19.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Threading.Tasks.Task;\n```\n\n----------------------------------------\n\nTITLE: Synthesized PrintMembers and ToString Methods for C# Record Types\nDESCRIPTION: This extensive code snippet demonstrates the synthesized PrintMembers and ToString methods for both base and derived record types. It shows how these methods are implemented to provide a string representation of the record's state.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/records.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nclass R1 : IEquatable<R1>\n{\n    public T1 P1 { get; init; }\n    \n    protected virtual bool PrintMembers(StringBuilder builder)\n    {\n        builder.Append(nameof(P1));\n        builder.Append(\" = \");\n        builder.Append(this.P1); // or builder.Append(this.P1.ToString()); if T1 is a value type\n        \n        return true;\n    }\n    \n    public override string ToString()\n    {\n        var builder = new StringBuilder();\n        builder.Append(nameof(R1));\n        builder.Append(\" { \");\n\n        if (PrintMembers(builder))\n            builder.Append(\" \");\n\n        builder.Append(\"}\");\n        return builder.ToString();\n    }\n}\n\nclass R2 : R1, IEquatable<R2>\n{\n    public T2 P2 { get; init; }\n    public T3 P3 { get; init; }\n    \n    protected override bool PrintMembers(StringBuilder builder)\n    {\n        if (base.PrintMembers(builder))\n            builder.Append(\", \");\n            \n        builder.Append(nameof(P2));\n        builder.Append(\" = \");\n        builder.Append(this.P2); // or builder.Append(this.P2); if T2 is a value type\n        \n        builder.Append(\", \");\n        \n        builder.Append(nameof(P3));\n        builder.Append(\" = \");\n        builder.Append(this.P3); // or builder.Append(this.P3); if T3 is a value type\n        \n        return true;\n    }\n    \n    public override string ToString()\n    {\n        var builder = new StringBuilder();\n        builder.Append(nameof(R2));\n        builder.Append(\" { \");\n\n        if (PrintMembers(builder))\n            builder.Append(\" \");\n\n        builder.Append(\"}\");\n        return builder.ToString();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: LINQ Query Syntax with IAsyncEnumerable\nDESCRIPTION: Demonstrates LINQ query syntax usage with IAsyncEnumerable<T>, showing how standard query operators work with async collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nIAsyncEnumerable<int> enumerable = ...;\nIAsyncEnumerable<int> result = from item in enumerable\n                               where item % 2 == 0\n                               select item * 2;\n```\n\n----------------------------------------\n\nTITLE: Using readonly modifiers with ref fields in C#\nDESCRIPTION: This snippet shows how `readonly` modifiers can be combined with `ref` fields in different ways. `ref readonly` means the field can be ref reassigned but cannot be value assigned, `readonly ref` means the field cannot be ref reassigned outside of a constructor or `init` methods, and `readonly ref readonly` combines both restrictions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n```c#\nref struct ReadOnlyExample\n{\n    ref readonly int Field1;\n    readonly ref int Field2;\n    readonly ref readonly int Field3;\n\n    void Uses(int[] array)\n    {\n        Field1 = ref array[0];  // Okay\n        Field1 = array[0];      // Error: can't assign ref readonly value (value is readonly)\n        Field2 = ref array[0];  // Error: can't repoint readonly ref\n        Field2 = array[0];      // Okay\n        Field3 = ref array[0];  // Error: can't repoint readonly ref\n        Field3 = array[0];      // Error: can't assign ref readonly value (value is readonly)\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: String vs Char Array Overload Resolution\nDESCRIPTION: Example demonstrating method overload resolution between string and char array parameters with collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-02.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M2(string s);\nvoid M2(char[] characters);\nM(['a', 'b', 'c']);\n```\n\n----------------------------------------\n\nTITLE: Pointer Hoisting in Local Functions\nDESCRIPTION: Demonstrates how pointers can be hoisted into lambda expressions/local functions, showing that pointer hoisting is already supported in certain scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-unsafe-in-iterators-async.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe public void* M(void* p)\n{\n    var d = () => p;\n    return d();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguous Iteration Type with CollectionBuilderAttribute in C#\nDESCRIPTION: This code snippet illustrates the problem of ambiguous iteration types when using the CollectionBuilderAttribute. It shows a Collection class that implements multiple IEnumerable<T> interfaces, causing issues with foreach loops and type inference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\nCollection x = [1L, 2L];\n\n// error CS1640: foreach statement cannot operate on variables of type 'Collection' because it implements multiple instantiations of 'IEnumerable<T>'; try casting to a specific interface instantiation\nforeach (var x in new Collection) { }\n\nstatic class Builder\n{\n    public Collection Create(ReadOnlySpan<long> items) => throw null;\n}\n\n[CollectionBuilder(...)]\nclass Collection : IEnumerable<int>, IEnumerable<string>\n{\n    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;\n    IEnumerator<string> IEnumerable<string>.GetEnumerator() => throw null;\n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Union Struct Member in C#\nDESCRIPTION: This snippet demonstrates how to construct a member of a union struct.  A new instance of the 'A' member, which is part of the 'U' union struct, is created using the 'new' keyword, passing in the required parameters (an integer and a string). The resulting object, of type 'A', is then implicitly converted and assigned to a variable 'u' of type 'U'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nU u = new A(10, \"ten\");\n```\n\n----------------------------------------\n\nTITLE: Using Declaration Grammar in ANTLR\nDESCRIPTION: Formal grammar specification for using declarations in ANTLR format.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/using.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nlocal-using-declaration:\n  'using' type using-declarators\n\nusing-declarators:\n  using-declarator\n  using-declarators , using-declarator\n  \nusing-declarator:\n  identifier = expression\n```\n\n----------------------------------------\n\nTITLE: Record Declaration and With-Expression in C#\nDESCRIPTION: Example showing record type declaration and usage of with-expression for non-destructive mutation of immutable objects.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-10-07-Design-Review.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass Point(int X, int Y, int Z);\n...\n    Point p = ...;\n    Point q = p with { Y = 2 };\n```\n\nLANGUAGE: csharp\nCODE:\n```\n    Point q = new Point(X: p.X, Y: 2, Z: p.Z);\n```\n\nLANGUAGE: csharp\nCODE:\n```\n    Point q = p.With(X: p.X, Y: 2, Z: p.Z);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Safe-to-Return Rules for 'ref readonly' Returns in C#\nDESCRIPTION: Illustrates the rules for what is considered safe to return as a 'ref readonly', including the handling of RValues passed as 'in' parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nref readonly Vector3 Test1()\n{\n    // can pass an RValue as \"in\" (via a temp copy)\n    // but the result is not safe to return\n    // because the RValue argument was not safe to return by reference\n    return ref Test2(default(Vector3));\n}\n\nref readonly Vector3 Test2(in Vector3 r)\n{\n    // this is ok, r is returnable\n    return ref r;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Pointer Features with Unmanaged Constraint in C#\nDESCRIPTION: Example showing how type parameters with the unmanaged constraint can use pointer features like fixed, which are normally only available to unmanaged types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/blittable.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Hash<T>(T value) where T : unmanaged\n{\n    // Okay\n    fixed (T* p = &value) \n    { \n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Complex Ref-Safety Scope Analysis in C#\nDESCRIPTION: This snippet illustrates a more complex scenario where ref-safety scope constraints need to flow backwards through method invocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> M()\n{\n    Span<int> s1 = [x, y, z];\n    Span<int> s2 = X(s1);\n    return s2;\n}\n\nSpan<T> X<T>(Span<T> s) => s;\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Task Type with AsyncMethodBuilder in C#\nDESCRIPTION: Example of a generic custom task type MyTask<T> with its AsyncMethodBuilder attribute and required GetAwaiter method. The awaiter pattern implementation includes the necessary members to support the await keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/task-types.md#2025-04-21_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n[AsyncMethodBuilder(typeof(MyTaskMethodBuilder<>))]\nclass MyTask<T>\n{\n    public Awaiter<T> GetAwaiter();\n}\n\nclass Awaiter<T> : INotifyCompletion\n{\n    public bool IsCompleted { get; }\n    public T GetResult();\n    public void OnCompleted(Action completion);\n}\n```\n\n----------------------------------------\n\nTITLE: Generic TryGet Pattern Implementation in C#\nDESCRIPTION: Example of the TryGet pattern implementation showing a generic method with bool return value and out parameter for handling potential null values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-15.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic bool TryGet(out T result) { ... }\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression Ambiguity Example\nDESCRIPTION: Demonstration of how lambda expressions with natural types in C# 10 can create ambiguous method overload scenarios that were previously unambiguous in C# 9.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-23.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic void F(object obj, Action callback) { }\nstatic void F(int i, Delegate callback) { }\n\n// C#9: F(object, Action)\n// C#10: ambiguous\nF(0, () => { });\n```\n\n----------------------------------------\n\nTITLE: Parsing Ambiguity in Nullable Array Types with Pattern Matching\nDESCRIPTION: Example code demonstrating the parsing ambiguity that occurs with nullable array types in pattern matching expressions. This syntax is ambiguous because the parser cannot easily determine whether the '?' applies to the array type or is part of a pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-09.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nif (o is string[][]?(var e0, var e1, var e2) s)\n```\n\n----------------------------------------\n\nTITLE: Using Digit Separators in Numeric Literals in C# 7.2\nDESCRIPTION: This code snippet demonstrates the evolution of digit separator usage in C# numeric literals across different language versions, highlighting the new C# 7.2 feature that allows an underscore after binary (0b) and hexadecimal (0x) prefixes. The snippet includes examples of decimal, hexadecimal, and binary literals with various digit separator placements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/leading-separator.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n    123      // permitted in C# 1.0 and later\n    1_2_3    // permitted in C# 7.0 and later\n    0x1_2_3  // permitted in C# 7.0 and later\n    0b101    // binary literals added in C# 7.0\n    0b1_0_1  // permitted in C# 7.0 and later\n\n    // in C# 7.2, _ is permitted after the `0x` or `0b`\n    0x_1_2   // permitted in C# 7.2 and later\n    0b_1_0_1 // permitted in C# 7.2 and later\n```\n\n----------------------------------------\n\nTITLE: Defining Class and Class? Constraints in C# ANTLR Grammar\nDESCRIPTION: ANTLR grammar rule for defining the 'class?' constraint in C#, which is a nullable counterpart to the 'class' constraint.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nprimary_constraint\n    : ...\n    | 'class' '?'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Using InterpolatedStringBuilderAttribute in C#\nDESCRIPTION: Demonstrates the use of InterpolatedStringBuilderAttribute to enable conversion from interpolated string literals to a custom type. The attribute simplifies conversion rules and improves diagnostic messages.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-28.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[InterpolatedStringBuilder]\npublic class MyStringBuilder\n{\n    public void Append(string s) { }\n    public void Append(int i) { }\n    // Other Append methods...\n\n    public static MyStringBuilder Create(int literalLength, int formattedCount) { return new MyStringBuilder(); }\n}\n\nMyStringBuilder builder = $\"Hello {42}\"; // Valid conversion due to attribute\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default in array creation expressions in C#\nDESCRIPTION: Including default values in array initialization using the default literal where the type is inferred from the array type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar x = new[] { default, ImmutableArray.Create(y) };\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Init Property Usage in Interfaces\nDESCRIPTION: Example showing potential usage of init properties in interfaces with generic constraints, highlighting a use case for allowing init setters in interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-06.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface I\n{\n    int Prop { get; init set; }\n}\n\npublic void MyMethod<T>() where T : I, new()\n{\n    var t = new T() {\n        Prop = 1\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: UTF-8 String Literal Type Conversion Examples\nDESCRIPTION: Shows the supported conversion targets for UTF-8 string literals\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-26.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nbyte[] arr = \"example\"u8;\nSpan<byte> span = \"example\"u8;\nReadOnlySpan<byte> roSpan = \"example\"u8;\n```\n\n----------------------------------------\n\nTITLE: Struct Initializers in C#\nDESCRIPTION: Illustrates various scenarios of struct initializers. Shows examples of allowed and disallowed initializer usage in structs based on the presence and type of constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-10.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nstruct S0 { public int x = 5; } // Bad\nstruct S1 { public int x = 5; S1(int i) : this() { x += i; } } // Bad\nstruct S2 { public int x = 5; S2(int i) { this = new S2(); x += i; } } // Good\nstruct S3(int i) { public int x = 5 + i; } // Good\n```\n\n----------------------------------------\n\nTITLE: Workaround for Struct Initialization in C#\nDESCRIPTION: Shows a workaround for initializing a struct when a parameterless constructor is present, using default(S) and this as an l-value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nS(int x) { this = default(S); this.X = x; }\n```\n\n----------------------------------------\n\nTITLE: Alternative Extension Container Prototype in C#\nDESCRIPTION: This shows an alternative design to group related members within the extension container in C#. Multiple members share the same receiver (`IEnumerable<T> source`) and are declared in the same extension container.  It illustrates multiple extension properties and methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Extension-API-docs.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nextension<T>(IEnumerable<T> source)\n{\n    public bool IsEmpty { get; }\n    public int Length { get; }\n    public IEnumerable<T> Sample(int sampleInterval);\n}\n```\n\n----------------------------------------\n\nTITLE: Efficient byte array initialization\nDESCRIPTION: This code shows an efficient but verbose way to initialize a `ReadOnlySpan<byte>` with specific byte values representing a UTF-8 string. It avoids runtime encoding but can be error-prone due to manual byte representation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"// Efficient but verbose and error prone\nstatic ReadOnlySpan<byte> AuthWithTrailingSpace => new byte[] { 0x41, 0x55, 0x54, 0x48, 0x20 };\nWriteBytes(AuthWithTrailingSpace);\"\n```\n\n----------------------------------------\n\nTITLE: Global Using Directive Example in C#\nDESCRIPTION: Example of a potential syntax for declaring global using directives that would apply project-wide. This is one of the proposed approaches discussed in the meeting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-01-13.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nglobal using System;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Init Property Syntax Options\nDESCRIPTION: Code examples showing three considered syntax variations for implementing init-only properties in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// 1. Use init \nint Option1 { get; init; }\n// 2. Use init set\nint Option2 { get; init set; }\n// 3. Use initonly\nint Option3 { get; initonly; }\n```\n\n----------------------------------------\n\nTITLE: Using Ordinary Arguments with 'in' Parameters in C#\nDESCRIPTION: Shows how regular arguments without modifiers can match 'in' parameters, allowing for more flexible API usage. This includes passing literals, computed results, and values requiring implicit conversions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nPrint(\"hello\");      // not an error.\n\nvoid Print<T>(in T x)\n{\n  //. . .\n}\n```\n\n----------------------------------------\n\nTITLE: Emitted Code for Debug.Assert with CallerArgumentExpression in C#\nDESCRIPTION: This code snippet represents the code that the compiler emits when using Debug.Assert with the CallerArgumentExpression attribute. It demonstrates how the expression string is automatically passed as the message.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nT Single<T>(this T[] array)\n{\n    Debug.Assert(array != null, \"array != null\");\n    Debug.Assert(array.Length == 1, \"array.Length == 1\");\n\n    return array[0];\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Method argument matching for ref safety in C#\nDESCRIPTION: Shows how the compiler enforces ref safety by ensuring arguments' contexts match properly when passing ref parameters. This prevents unsafe reference escapes by analyzing returnable inputs and outputs of methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_62\n\nLANGUAGE: c#\nCODE:\n```\nref struct R { }\n\nclass Program\n{\n    static void F0(ref R a, scoped ref R b) => throw null;\n\n    static void F1(ref R x, scoped R y)\n    {\n        F0(ref x, ref y);\n    }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\nref struct R { }\n\nclass Program\n{\n    static void F0(ref R a, ref int b) => throw null;\n\n    static void F1(ref R x)\n    {\n        int y = 42;\n        F0(ref x, ref y);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Members of Generic Type Parameters (C#)\nDESCRIPTION: Demonstrates how members of generic type parameters can be accessed using nameof with unbound types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/unbound-generic-types-in-nameof.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass A<TItem, TCollection> where TCollection : IReadOnlyCollection<TItem>\n{\n    public TCollection B { get; }\n}\n\nnameof(A<,>.B)        // evaluates to \"B\"\nnameof(A<,>.B.Count)  // evaluates to \"Count\"\n```\n\n----------------------------------------\n\nTITLE: Auto-Property Initialization in Struct in C#\nDESCRIPTION: Demonstrates the use of auto-property initializers to simplify struct initialization and satisfy definite assignment requirements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic int X { get; set; } = 0;\n```\n\n----------------------------------------\n\nTITLE: Filter Implementation with Local Function in C#\nDESCRIPTION: Example of using local function for implementing a filter with proper argument validation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static IEnumerable<T> Filter<T>(IEnumerable<T> source, Func<T, bool> predicate)\n{\n    if (source == null) throw new ArgumentNullException(nameof(source));\n    if (predicate == null) throw new ArgumentNullException(nameof(predicate));\n\n    IEnumerable<T> Iterator()\n    {\n        foreach (var element in source)\n        if (predicate(element))\n        yield return element;\n    }\n    return Iterator();\n}\n```\n\n----------------------------------------\n\nTITLE: Union Struct Declaration and Implementation\nDESCRIPTION: Illustrates the definition of a union struct with implicit and explicit conversion operators, as well as TryGet methods for each member type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n[Union]\nstruct U \n{\n    public record struct A(int x, string y);\n    public record struct B(int z);\n    public record struct C { public static C Singleton = default; };\n\n    public static implicit operator U(A value) {...};\n    public static implicit operator U(B value) {...};\n    public static implicit operator U(C value) {...};\n\n    public static explicit operator A(U union) {...};\n    public static explicit operator B(U union) {...};\n    public static explicit operator C(U union) {...};\n\n    public bool TryGetA(out A value) {...};\n    public bool TryGetB(out B value) {...};\n    public bool TryGetC(out C value) {...};\n\n    public enum UnionKind { A = 1, B = 2, C = 3 };\n    public UnionKind Kind => {...};\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'in' Keyword for Ref Readonly Parameters in C#\nDESCRIPTION: Shows the use of the 'in' keyword as a shorthand for 'ref readonly' on method parameters. This provides a more concise syntax for readonly reference parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-22.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic ref readonly int Choose(in int i1, in int i2) { ... } // Equivalent to the above\n```\n\n----------------------------------------\n\nTITLE: Referencing Underlying Value Using 'this' in C#\nDESCRIPTION: This snippet illustrates how the `this` keyword is used within an extension member to refer to the underlying value. The `this` keyword provides a way to access the properties and methods of the extended type. The reference can be implicit, meaning you don't always need to explicitly specify `this`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable)\n    {\n        // 'this' refers to underlying value\n        public bool IsEmpty => !this.GetEnumerator().MoveNext();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invocation Syntax for Extension Methods in C#\nDESCRIPTION: Explores an invocation syntax that uses a method-style call on types to utilize extension members. This unique pattern aligns the invocation with familiar method syntax, presenting an intuitive alternative for extension invocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = MyExtensions(IEnumerable<int>).Range(0, 10);\nvar empty = MyExtensions(IEnumerable<int>).Empty;\nMyExtensions(range) += 5;\nReadOnlySpan<int> span = MyExtensions(range);\n\n// Instance extension members\nvar query = MyExtensions(range).Where(i => i < 10);\nvar isEmpty = MyExtensions(query).IsEmpty;\nvar first = MyExtensions(query)[0];\nvar repetition = new MyExtensions(IEnumerable<int>)(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference with Nullable Types in C#\nDESCRIPTION: This code snippet illustrates a current limitation in the prototype where type inference doesn't pick up inferred nullability, only declared nullability. The array 'a' is inferred as string?[] instead of the expected string[].\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-11-08.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string? s)\n{\n    if (s == null) return;\n    var a = new[] { s }; // string?[], should be string[]\n}\n```\n\n----------------------------------------\n\nTITLE: Yield in Try/Catch Block Exploration\nDESCRIPTION: Discussion of allowing yield statements within try and finally blocks in iterators, with specific considerations around disposal and error handling. No final decision was reached in the meeting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-28.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Potential future syntax exploration\nIEnumerable<int> ExampleIterator()\n{\n    try {\n        yield return 1;\n    } finally {\n        // Potential disposal logic\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Field Initialization without Parameterless Constructor\nDESCRIPTION: Example showing struct behavior where field initialization requires explicit constructor definition. Demonstrates that no parameterless constructor is synthesized when field initializers are present.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-03.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nConsole.WriteLine(new S().field1); // This prints 0\n\nstruct S\n{\n    int field1 = 1; // No constructor is synthesized\n    int field2;\n    public S(int field2) => this.field2 = field2;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Binary Literal Usage in C#\nDESCRIPTION: Example showing how the proposed binary literal syntax would be used in C# code to represent the decimal value 19 in binary format.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/binary-literals.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint nineteen = 0b10011;\n```\n\n----------------------------------------\n\nTITLE: Importing Extension Methods in C#\nDESCRIPTION: Demonstrates importing extension methods from a specific class. This example shows how to import only the query methods for in-memory collections from System.Linq.Enumerable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-10.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Linq.Enumerable;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Null Check with Conditional Access Operator in C#\nDESCRIPTION: An example method showing a conditional access operator (s?.ToString()) in a null equality check, which is being discussed for how it should affect nullability tracking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-20.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string s)\n{\n    if (s?.ToString() == null)\n    {\n        // is `s` maybe null?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Member with Parameter Name and Underlying Type (C#)\nDESCRIPTION: This C# code snippet illustrates how to include a parameter name when declaring an instance extension member with its underlying type. This provides improved readability and allows for better documentation of the extension member. It uses the 'List<T>' underlying type and provides the parameter name 'list'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Extensions\n{\n    extension<T>\n    {\n        public bool (List<T> list).IsEmpty => list.Count == 0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dictionary Expressions in C#\nDESCRIPTION: This snippet discusses how dictionary types are determined based on iteration types and indexers. It outlines the rules for identifying a dictionary and how collection expressions will use the appropriate indexer for adding key-value pairs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-03-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n__The conversion rules__ pertain to how we decide that a given type is a dictionary type. For the pertinent situation, where the type is not an interface and does not provide a `CollectionBuilderAttribute`, the proposal requires the type to have an iteration type of `KeyValuePair<TKey, TValue>` for some `TKey` and `TValue`, as well as a matching get-set indexer.\n\nIf the type explicitly implemented e.g. `IDictionary<TKey, TValue>` we wouldn't recognize it as a dictionary - the type itself needs to have the right members.\n\nWhen a type is a dictionary type, collection expressions will be implemented using its indexer rather than `Add` methods.\n```\n\nLANGUAGE: C#\nCODE:\n```\n__The construction rules__ pertain to how we bind to the indexer on such a type.\n\nFor _key value pair elements_ `e1:e2` the proposal invokes the setter of the best applicable indexer, based on the key and value expressions in each pair.\n```\n\nLANGUAGE: C#\nCODE:\n```\nFor _expression elements_ `e` and _spread elements_ `..e` the proposed rules require elements to implicitly convert to `KeyValuePair<TKey, TValue>`, exactly matching the iteration type of the dictionary type.\n```\n\n----------------------------------------\n\nTITLE: Using Collection Literals with ReadOnlySpan in C#\nDESCRIPTION: This snippet shows how collection literals can be evaluated using FixedSizeArray and ReadOnlySpan. It supports both stack and heap allocation based on runtime conditions. It requires Enumerable and possibly other dependencies for conversion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/params-improvements/PI-2022-11-03.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar _tmp1 = new FixedSizeArray8<int>();\nReadOnlySpan<int> _tmp2;\nif (Enumerable.TryGetNonEnumeratedCount(e, out int n) && n <= 8)\n{\n    int i = 0;\n    foreach (var item in e)\n    {\n        _tmp1.Array[i++] = item;\n        if (i == n) break;\n    }\n    _tmp2 = new ReadOnlySpan<int>(_tmp1.Array, 0, n);\n}\nelse\n    _tmp2 = new ReadOnlySpan<int>(e.ToArray());\n```\n\n----------------------------------------\n\nTITLE: Illustrating Interface Constraints with Generic Types in C#\nDESCRIPTION: This snippet demonstrates the use of interface constraints with generic types in C#. It shows how constraints can affect the nullability of type parameters when working with interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-08-22.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninterface I {}\nvoid M<T>() where T : I {}\n```\n\n----------------------------------------\n\nTITLE: Restrictions on File-Local Types in Signatures\nDESCRIPTION: This snippet illustrates the restriction on using file-local types in signatures (parameters, returns, type parameter constraints) of non-file-local types. File-local types can only appear in signatures or as base types of other file-local types. Explicit interface implementations are also subject to this restriction in the initial iteration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nfile class FileBase\n{\n}\n\npublic class Derived : FileBase // error\n{\n    private FileBase M2() => new FileBase() // error\n}\n\nfile class FileDerived : FileBase // ok\n{\n    private FileBase M2() => new FileBase(); // ok\n}\n\nfile interface I\n{\n    void M(I i);\n}\n\nclass C : I\n{\n    void I.M(I i) { } // error\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Dictionary with Custom Comparer\nDESCRIPTION: Demonstrates creating a case-insensitive dictionary using a custom comparer in the collection expression syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> caseInsensitiveMap = [StringComparer.CaseInsensitive, .. existingMap];\n\n// Or even:\nDictionary<string, int> caseInsensitiveMap = [StringComparer.CaseInsensitive];\n```\n\n----------------------------------------\n\nTITLE: Readonly Behavior with Ref Fields\nDESCRIPTION: Demonstrates that readonly only applies to the ref itself but not to the data it references, allowing field value changes through readonly ref structs while preventing ref reassignment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_59\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S\n{\n    ref int Field;\n\n    readonly void Method()\n    {\n        // Legal or illegal?\n        Field = 42;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Deconstructing Assignments and Declarations in C#\nDESCRIPTION: Examples of deconstructing assignments, declarations, and out variables in C#. These snippets show the current syntax and potential generalizations using declaration expressions and tuple expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-10-25-26.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Deconstructing assignments\n(x, y) = e\n\n// Deconstructing declarations\n(X x, Y y) = e\n\n// Out variables\nM(out X x)\n```\n\n----------------------------------------\n\nTITLE: Generated Main Method for Fibonacci Example\nDESCRIPTION: Shows how the Fibonacci example gets transformed into a Program class with Main method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npartial class Program\n{\n    static void $Main(string[] args)\n    {\n        if (args.Length == 0\n            || !int.TryParse(args[0], out int n)\n            || n < 0) return;\n        Console.WriteLine(Fib(n).curr);\n        \n        (int curr, int prev) Fib(int i)\n        {\n            if (i == 0) return (1, 0);\n            var (curr, prev) = Fib(i - 1);\n            return (curr + prev, curr);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Params Array Ambiguity Examples in C#\nDESCRIPTION: Shows ambiguous scenarios with empty params arrays of different element types, including both traditional arrays and spans.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static void Main()\n    {\n        // Old scenarios\n        C.M1(); // Ambiguous since params arrays were introduced\n        C.M1([]); // Ambiguous since params arrays were introduced\n\n        // New scenarios\n        C.M2(); // Ambiguous in C# 13\n        C.M2([]); // Ambiguous in C# 13\n        C.M3(); // Ambiguous in C# 13\n        C.M3([]); // Ambiguous in C# 13\n    }\n\n    public static void M1(params int[] a) {\n    }\n    \n    public static void M1(params int?[] a) {\n    }\n    \n    public static void M2(params ReadOnlySpan<int> a) {\n    }\n    \n    public static void M2(params Span<int?> a) {\n    }\n    \n    public static void M3(params ReadOnlySpan<int> a) {\n    }\n    \n    public static void M3(params ReadOnlySpan<int?> a) {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating IEquatable<T> Nullable Contravariance in C#\nDESCRIPTION: This snippet illustrates how IEquatable<T> is specially treated as 'nullable-contravariant' in C#. It shows that IEquatable<string?> can be converted to IEquatable<string>, but not vice versa.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-10-24.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nIEquatable<string?> e1 = ...;\nIEquatable<string> e2 = e1; // ok\nIEquatable<string?> e3 = e2; // warning CS8619: Nullability of reference types in value of type 'IEquatable<string>' doesn't match target type 'IEquatable<string?>'.\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Positional Pattern Matching\nDESCRIPTION: Grammar rules defining the syntax for positional pattern matching in C#, including subpatterns and pattern variations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_4\n\nLANGUAGE: antlr\nCODE:\n```\npositional_pattern\n    : type? '(' subpatterns? ')' property_subpattern? simple_designation?\n    ;\nsubpatterns\n    : subpattern\n    | subpattern ',' subpatterns\n    ;\nsubpattern\n    : pattern\n    | identifier ':' pattern\n    ;\n```\n\n----------------------------------------\n\nTITLE: TryParse Declaration Expression Pattern\nDESCRIPTION: Common pattern showing declaration expression usage within an if condition using TryParse.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-09-03.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nif (int.TryParse(s, out int i)) { â€¦ i â€¦ }\n```\n\n----------------------------------------\n\nTITLE: Inferred Element Type Examples in C# Collection Expressions\nDESCRIPTION: Examples demonstrating inferred element types in collection expressions, including cases where inference succeeds and fails.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-inferred-type.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nforeach (var i in [1, .. b ? [2, 3] : []]) { } // ok: collection of int\nforeach (var i in []) { }                      // error: cannot determine element type\nforeach (var i in [1, null]) { }               // error: no common type for int, <null>\n```\n\n----------------------------------------\n\nTITLE: Interface Member Access on Structs\nDESCRIPTION: Shows that interface members are not directly inherited by structs and require explicit casting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nvar s = default(S);\ns.M(); // error: 'S' does not contain a member 'M'\n```\n\n----------------------------------------\n\nTITLE: Null Test Switch Statement Example\nDESCRIPTION: Example showing null testing behavior in switch statements with conditional cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-13.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nswitch (s)\n{\n    case null when s.Length == 1:\n        break;\n    case null when M(s = \"foo\"):\n        break;\n    case _ when s.Length == 2:\n        break;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Base Call Semantics in Class Inheritance\nDESCRIPTION: This code example illustrates how base.M() calls work in traditional class inheritance. The behavior finds the 'nearest' implementation and makes a direct call, with fallback behavior if the target method isn't present at runtime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-25.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass A \n{\n    virtual void M() {}\n}\n\nclass B : A \n{ \n    // override void M() { }\n}\n\nclass C : B\n{\n    override void M() => base.M();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Container Declarations in C#\nDESCRIPTION: Examples of various extension container declarations in C#, showcasing different syntaxes including generic type parameters and for-clauses.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nextensions E\n{\n}\n\nextensions E<T>\n{\n}\n\nextensions E for string\n{\n}\n\nextensions E<T> for T where T : IEquatable<T>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Method Resolution with Collection Expressions\nDESCRIPTION: This example demonstrates how a collection type that passes the conversion rules but isn't actually constructible can lead to ambiguous method resolution. The conversion to string is included in overload resolution even though it would fail at runtime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nclass C1\n{\n    public static void M1(string x)\n    {\n    }\n    public static void M1(char[] x)\n    {\n    }\n    \n    void Test()\n    {\n        M1(['a', 'b']); // error CS0121: The call is ambiguous between the following methods or properties: 'C1.M1(string)' and 'C1.M1(char[])'\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type inference example with block-bodied switch in C#\nDESCRIPTION: This C# example illustrates how the type of a switch expression is determined when using block-bodied arms. It shows that the compiler considers the types of expressions used in `break` statements within the blocks when inferring the best common type for the switch expression. The resulting type of the switch expression will be the best common type among all the contributed types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/block-bodied-switch-expression-arms.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nbool b = ...;\nvar o = ...;\n_ = o switch {\n    1 => (byte)1,\n    2 => {\n        if (b) break (short)2;\n        else break 3;\n    }\n    _ => 4L;\n};\n```\n\n----------------------------------------\n\nTITLE: Stack Allocation for Span Arguments in C#\nDESCRIPTION: This code demonstrates stack allocation of a collection expression as an argument to a builder method. The `Create` method is invoked with a stack-allocated `ReadOnlySpan<T>`. The `ImmutableArray` is constructed using this span as an argument.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nImmutableArray<int> ia = [x, y, z]; // stack allocate Create() argument\n\n[CollectionBuilder(typeof(ImmutableArray), \"Create\")]\npublic struct ImmutableArray<T> { ... }\n\npublic static class ImmutableArray\n{\n    public static ImmutableArray<T> Create(ReadOnlySpan<T> values) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Assignment in Loop\nDESCRIPTION: Example of using deconstructing assignment within a for loop condition.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-13.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nfor (... ;; (current, next) = (next, next.Next)) { ... }\n```\n\n----------------------------------------\n\nTITLE: Interface Property Access Control in C#\nDESCRIPTION: Example showing interface property implementation with mixed access levels, demonstrating virtual and private accessor combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-17.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninterface IA\n{\n    public virtual int P\n    {\n        get => 3;\n        private set => { } \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying NullableFilterAttribute to LINQ Where method in C#\nDESCRIPTION: Demonstrates the usage of the NullableFilterAttribute on the predicate parameter of the LINQ Where method. This allows for improved nullable state flow analysis within predicate lambdas.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-22.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\n\nnamespace System.Linq;\n\npublic static class Enumerable\n{\n    public static IEnumerable<TSource> Where<TSource>(\n        this IEnumerable<TSource> source,\n        [NullableFilter] Func<TSource, bool> predicate)\n    {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #pragma warning with Custom Identifiers in C#\nDESCRIPTION: Example showing the extended #pragma warning directive syntax that allows disabling diagnostics using custom identifiers and compiler-specific identifiers in the CS#### format. This demonstrates how custom diagnostic providers can be referenced alongside traditional compiler warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-07-09.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#pragma warning disable AsyncCoreSet\n#pragma warning disable CS1234\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Properties in C#\nDESCRIPTION: Provides examples of instance extension properties within extension containers for different types, illustrating how existing methods could be transformed into properties. These properties enhance syntax readability and mimic typical property syntax in C# utility classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\ninternal extensions IComparerExtensions<T> for IComparer<T>\n{\n    public IComparer<T> comparer.Inverse => new InverseComparer<T>(comparer)\n}\n\ninternal extensions ISymbolExtensions for ISymbol\n{\n    public bool ([NotNullWhen(true)] ISymbol? symbol).IsImplicitValueParameter\n        => ...;\n}\n\ninternal extensions CompilationExtensions for Compilation\n{\n    public INamedTypeSymbol? compilation.AttributeType\n        => compilation.GetTypeByMetadataName(typeof(Attribute).FullName!);\n\n    public INamedTypeSymbol? compilation.ExceptionType\n        => compilation.GetTypeByMetadataName(typeof(Exception).FullName!);\n\n    public INamedTypeSymbol? compilation.EqualityComparerOfTType\n        => compilation.GetTypeByMetadataName(typeof(EqualityComparer<>).FullName!);\n\n    public INamedTypeSymbol? compilation.ActionType\n        => compilation.GetTypeByMetadataName(typeof(Action).FullName!);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Implicit Creation of ReadOnlySpan<T> in C#\nDESCRIPTION: Example showing how a call to a method with a params ReadOnlySpan<T> parameter might be emitted by the compiler.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nlog.Log(\"({0}, {1}, {2})\", x, y, z);\n\n// Potentially emitted as:\nlog.Log(\"({0}, {1}, {2})\",\n    new System.ReadOnlySpan<object>(new object[] { x, y, z }));\n```\n\n----------------------------------------\n\nTITLE: Attribute-Based Representation of Nullable Types\nDESCRIPTION: Shows how nullable and non-nullable reference types would be represented using attributes in compiled code, which allows backward compatibility with earlier C# versions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-10-17.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    [Nullable] string M([NonNullable] string s) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Ref-Safety Scope for Escaping Span in C#\nDESCRIPTION: This example demonstrates a case where a Span<int> created with a collection expression escapes the method, suggesting a need for global scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> M()\n{\n    // Global scoped, since 's' escapes out of 'M'.\n    Span<int> s = [x, y, z];\n    UseSpan(s);\n    return s;\n}\n```\n\n----------------------------------------\n\nTITLE: Lowering List Pattern '{.., 3, 4}' in C#\nDESCRIPTION: Example of lowering a list pattern that checks for a collection ending with 3 and 4, preceded by any number of elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/list-patterns-enumerables.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n@{\n  var helper = new ListPatternHelper(collection, 0, 2);\n\n  helper.Count() >= 2 && // `..` with 2 ending patterns\n  helper.GetEndElement(hatIndex: 2) is 3 && // [^2] is 3\n  helper.GetEndElement(1) is 4 // [^1] is 4\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Irrefutable Patterns in C#\nDESCRIPTION: Examples demonstrating the potential use of irrefutable patterns in C#. Shows how definite assignment could be improved for patterns that are always fulfilled.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-10-25-26.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nif (GetInt() is int i) { ... }\nUseInt(i); // Currently an error. We could know that i is definitely assigned here\n\n// Future example with recursive patterns\nif (input is Assignment(Expression left, var right) && left == right) { ... }\n... // condition failed, but left and right are still assigned\n```\n\n----------------------------------------\n\nTITLE: Invalid Optional Parameter UTF8 Conversion in C#\nDESCRIPTION: Example showing limitation of using UTF8 string conversion as default parameter value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\n// Error: The argument is not constant\nvoid Write(ReadOnlySpan<byte> message = \"missing\") { ... }\n```\n\n----------------------------------------\n\nTITLE: Emitting Call with FixedSizeArray in C#\nDESCRIPTION: Illustrates how a method call with params arguments can be emitted by creating a temporary FixedSizeArray to hold arguments, and then creating a ReadOnlySpan from it. The example assumes dependency on the FixedSizeArray2 type and optimizes for stack allocation when certain conditions are met.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/params-improvements/PI-2022-11-03.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar _tmp1 = new FixedSizeArray2<object>();\n_tmp1.Array[0] = x;\n_tmp1.Array[1] = y;\nvar _tmp2 = new ReadOnlySpan<object>(_tmp.Array);\n\n// WriteLine(string format, params ReadOnlySpan<object> args);\nWriteLine(\"{0}, {1}\", _tmp2);\n```\n\n----------------------------------------\n\nTITLE: Array Element Assignment with Null Conditional Operator\nDESCRIPTION: Demonstrates null-conditional assignment to an array element, where the assignment only occurs if the array reference is non-null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/null-conditional-assignment.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(object[]? arr)\n{\n    arr?[42] = new object();\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Old and New Extension Syntax in C#\nDESCRIPTION: This code snippet demonstrates the improved clarity of the new extension syntax compared to the old syntax. The new syntax uses 'for X' to explicitly specify which interface is being extended versus which interface is being added, resolving ambiguity issues in partial extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-02-22.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Old syntax - Which of these is the interface getting extended, and which is the interface getting added?\npartial explicit extension Ext1 : Interface1;\npartial explicit extension Ext2 : Interface2;\n\n// New syntax - Unambiguous for both human and computer compilers. Interface1 is the extended type, and Interface2\n// is the type being added.\npartial explicit extension Ext1 for Interface1;\npartial explicit extension Ext1 : Interface2;\n```\n\n----------------------------------------\n\nTITLE: GetAsyncEnumerator Pattern with Type Constraints\nDESCRIPTION: Shows recognition of GetAsyncEnumerator pattern method on a type parameter with allows ref struct constraint.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IMyAsyncEnumerable<T>\n{\n    IAsyncEnumerator<int> GetAsyncEnumerator(CancellationToken cancellationToken = default);\n}\n\nclass C\n{\n    static async Task Test<T>() where T : IMyAsyncEnumerable<int>, allows ref struct\n    {\n        await foreach (var i in default(T)) // IMyAsyncEnumerable<int>.GetAsyncEnumerator\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Method Uniqueness with Classic Extension Methods\nDESCRIPTION: Demonstrates how uniqueness rules apply between classic extension methods and new extension declarations within the same static class. The second declaration causes an error because it duplicates the functionality of the first classic extension method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source) { ... }\n    \n    extension(IEnumerable source) \n    {\n        IEnumerable<TResult> Cast<TResult>() { ... } // Error! Duplicate declaration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Implementation with Traditional Backing Fields\nDESCRIPTION: Shows how both previous examples are equivalent to manually implementing properties with traditional named backing fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n// No 'field' symbol in scope.\npublic class Point\n{\n    private int __x;\n    private int __y;\n    public int X { get { return __x; } set { __x = value; } }\n    public int Y { get { return __y; } set { __y = value; } }\n}\n```\n\n----------------------------------------\n\nTITLE: Range Patterns Comparison\nDESCRIPTION: Compares different range notations including exclusive, inclusive, and relative ranges with various scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-22.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n// Exclusive x..y\nRange incl = start..end+1;\nRange excl = start..end;\nRange rel  = start..start+length;\nRange emp  = 0..0;\n\n// Inclusive x..y\nRange incl = start..end;\nRange excl = start..end-1;\nRange rel  = start..start+length-1;\nRange emp  = 0..-1;\n\n// Relative x:l\nRange incl = start:end-start+1;\nRange excl = start:end-start;\nRange rel  = start:length;\nRange emp  = 0:0;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Methods on Tuples in C#\nDESCRIPTION: Shows how extension methods work with tuples, even when element names differ.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nstatic void M(this (int x, int y) t) { ... }\n\n(int a, int b) t = ...;\nt.M(); // Sure\n```\n\n----------------------------------------\n\nTITLE: IAsyncEnumerator Interface Definition\nDESCRIPTION: Definition of the IAsyncEnumerator interface with Current property and async MoveNext method returning Task<bool>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IAsyncEnumerator<T>\n{\n  public T Current { get; }\n  public Task<bool> MoveNextAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Nullable Types in C#\nDESCRIPTION: Examples demonstrating type inference behavior with nullable types in different contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-23.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nstring? n = \"Hello\";\nvar s = n; // 'string' or 'string?' ?\n```\n\nLANGUAGE: c#\nCODE:\n```\nList<T> M<T>(T t) => new List<T>{ t };\n\nvoid N(string? s)\n{\n    if (s != null) WriteLine(M(s)[0].Length);     // 1\n    if (s != null) { var l = M(s); l.Add(null); } // 2\n}\n```\n\n----------------------------------------\n\nTITLE: Example 5: Alternative Operator Resolution with Inheritance\nDESCRIPTION: Shows how operator resolution changes when checked and unchecked operators are defined differently in base and derived classes. Demonstrates the interaction between checked/unchecked contexts and inheritance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    static void Add(C2 x, byte y)\n    {\n        object o;\n        \n        // C2.op_CheckedAddition\n        o = checked(x + y);\n        \n        // C1.op_Addition\n        o = unchecked(x + y);\n    }\n\n    static void Add2(C2 x, int y)\n    {\n        object o;\n        \n        // C1.op_Addition\n        o = checked(x + y);\n        \n        // C1.op_Addition\n        o = unchecked(x + y);\n    }\n}\n\nclass C1\n{\n    public static C1 operator + (C1 x, int y) => new C1();\n}\n\nclass C2 : C1\n{\n    public static C2 operator checked + (C2 x, byte y) => new C2();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Analysis in Switch Statements (C#)\nDESCRIPTION: This code snippet illustrates a case where nullable analysis interacts with switch statement exhaustiveness. It shows that even if all cases are covered, the variable 'i' is not considered definitely assigned at the end of the switch statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-10.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nint i;\nswitch (s)\n{\n    case string t: i = 0; break;\n}\nConsole.WriteLine(i); // is i definitely assigned?\n```\n\n----------------------------------------\n\nTITLE: Efficient ImmutableDictionary Initialization with CollectionsMarshal in C#\nDESCRIPTION: Example of using the proposed CollectionsMarshal.Create method for efficient ImmutableDictionary<TKey, TValue> initialization with collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nImmutableDictionary<string, int> namesToAge = [ \"Dustin\": 42, \"Cyrus\": 43 ]; // equivalent to:\n    \n// Storage is initialized (ideally on stack when safe), and passed to type to own creating its internal structure\nReadOnlySpan<KeyValuePair<string, int>> storage = [ new(\"Dustin\", 42), new(\"Cyrus\", 43) ]; // could be heap or stack.\nCollectionsMarshal.Create<string, int>(out ImmutableDictionary<string, int> namesToAge, storage);\n```\n\n----------------------------------------\n\nTITLE: Element-wise Analysis of Tuple Conversions in C#\nDESCRIPTION: Example demonstrating how tuple type inference works with nullable types, showing when warnings are generated and how the inferred type is determined.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-06.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// current behavior:\nstatic T Id<T>(T t) => t;\nstatic void M(string? x, string y)\n{\n    (string, string) t = (x, y); // warning: (string?, string) mismatch\n    t.Item1.ToString();          // warning: Item1 may be null\n    var x = Id(t); // what is the inferred type of x?\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Primary Constructor Body in C#\nDESCRIPTION: Demonstrates the syntax for adding a constructor body to a primary constructor, allowing for argument validation and initialization logic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic class ConfigurationException(Configuration configuration, string message) \n    : Exception(message)\n{\n    {\n        if (configuration == null) \n        {\n            throw new ArgumentNullException(nameof(configuration));\n        }\n    }\n    private Configuration configuration = configuration;\n    public override string ToString() => Message + \"(\" + configuration + \")\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TryMoveNext Method for IAsyncEnumerator in C#\nDESCRIPTION: Demonstrates a potential TryMoveNext method signature for IAsyncEnumerator to check for queued items synchronously.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-18.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nbool? TryMoveNext();\n```\n\n----------------------------------------\n\nTITLE: Resolving Conditional Expression Ambiguity with Parentheses in C#\nDESCRIPTION: Illustrates the proposed solution of using parentheses to disambiguate target-typed static member lookup in conditional expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/target-typed-static-member-lookup.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nexpr ? (.Name) : ...\n```\n\n----------------------------------------\n\nTITLE: SkipLocalsInit Analysis Rules Implementation in C#\nDESCRIPTION: Rules for implementing definite assignment analysis with SkipLocalsInit attribute. Defines when to use strong vs weak analysis and how warnings/errors are handled based on compilation settings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-07-20.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n1. If a method has the [SkipLocalsInit] attribute, or the compilation has the \"strict\" feature enabled, we use the strong version of analysis for its body. Otherwise\n2. If a sufficiently high /warnversion (>= 5) is enabled, we run the strong version of analysis, and\n  a. If it reports no diagnostics, we are done.\n  b. If it reports diagnostics, we run the weak version of analysis. Errors that are common to the two runs are reported as errors, and errors only reported by the strong version are downgraded to a warning.\n3. Otherwise we run the weak version of analysis.\n```\n\n----------------------------------------\n\nTITLE: Tuple Deconstruction Grammar Forms - C#\nDESCRIPTION: Shows different proposed syntax options for tuple deconstruction with using statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-09.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n    (using var x, using var y) = M(); // Form 0\n    using (x, y) = M();               // Form 1\n    using (var x, var y) = M();       // Form 2\n    using var (x, y) = M();           // Form 3\n    using var t = M();                // Form 4\n```\n\n----------------------------------------\n\nTITLE: Property with Change Notification in C#\nDESCRIPTION: Property implementation with auto getter and change-tracking setter\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    get;\n    set\n    {\n        if (field == value) return;\n        field = value;\n        OnXyzChanged();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Extension Constructors (C#)\nDESCRIPTION: Shows how to implement extension constructors as static factory methods, allowing construction of types without accessible constructors like interfaces and enums.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable<int>)\n    {\n        public static IEnumerable(int start, int count) => Range(start, count);\n    }\n    public static IEnumerable<int> Range(int start, int count) { ... } \n}\n```\n\n----------------------------------------\n\nTITLE: Breaking Change Example for Ref/In Parameter Resolution\nDESCRIPTION: Demonstrates a breaking change in C# 12 where overload resolution behavior changes for ref/in parameter mismatches between instance and extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    string M(in int i) => \"C\";\n    static void Main()\n    {\n        int i = 5;\n        System.Console.Write(new C().M(ref i));\n    }\n}\nstatic class E\n{\n    public static string M(this C c, ref int i) => \"E\";\n}\n```\n\n----------------------------------------\n\nTITLE: Out Variable Scope Limitation\nDESCRIPTION: Shows limitation of current scope rules where out variables are not accessible after their declaring statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-15.md#2025-04-23_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nGetCoordinates(out var x, out var y);\n...; // x and y not in scope :-(\n```\n\n----------------------------------------\n\nTITLE: Using Nullability and Attributes in Extension Declarations (C#)\nDESCRIPTION: Illustrates how to use nullable reference types and attributes in extension declarations, including constraints and parameter attributes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static class NullableExtensions\n{\n    extension(string? text)\n    {\n        public string AsNotNull => text is null ? \"\" : text;\n    }\n    extension([NotNullWhen(false)] string? text)\n    {\n        public bool IsNullOrEmpty => text is null or [];\n    }\n    extension<T> ([NotNull] T t) where T : class?\n    {\n        public void ThrowIfNull() => ArgumentNullException.ThrowIfNull(t);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating breaking change in unsafe context inheritance\nDESCRIPTION: Demonstrates the breaking change in C# 13 where iterators will correctly introduce a safe context. In C# 12, unsafe operations were incorrectly allowed in local functions inside iterators due to a Roslyn implementation bug.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-unsafe-in-iterators-async.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe class C // unsafe context\n{\n    System.Collections.Generic.IEnumerable<int> M() // an iterator\n    {\n        yield return 1;\n        local();\n        async void local()\n        {\n            int* p = null; // allowed in C# 12; error in C# 13 (breaking change)\n            await Task.Yield(); // error in C# 12, allowed in C# 13\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Proposed Constructor Syntax for Required Properties in C#\nDESCRIPTION: This snippet showcases a potential syntax for specifying required properties in constructors. It uses the 'require' keyword followed by property names, similar to type parameter constraint clauses.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-01-11.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic Person() require FirstName, LastName\n{\n}\n\npublic Student() require ID\n    : base()\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FrugalList<T> Structure\nDESCRIPTION: Implementation of a fixed-size list structure with indexed access using UnscopedRef attribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_46\n\nLANGUAGE: c#\nCODE:\n```\nstruct FrugalList<T>\n{\n    private T _item0;\n    private T _item1;\n    private T _item2;\n\n    public int Count = 3;\n\n    public FrugalList(){}\n\n    public ref T this[int index]\n    {\n        [UnscopedRef] get\n        {\n            switch (index)\n            {\n                case 0: return ref _item0;\n                case 1: return ref _item1;\n                case 2: return ref _item2;\n                default: throw null;\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Primary Constructor Parameter Passing to Base Constructor\nDESCRIPTION: This code shows the more common pattern where a primary constructor parameter is passed to the base class constructor, ensuring the value is not double-stored and the protected field is referenced by the derived type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-08.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Base(string a)\n{\n    protected readonly string a = a;\n}\n\npublic class Derived(string a = \"derived\") : Base(a)\n{\n    public void M()\n    {\n        Console.WriteLine(a);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: List Pattern with Nested Slice Example\nDESCRIPTION: Example showing list pattern matching with nested slice patterns to illustrate how slice patterns contribute to exhaustiveness checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-07.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n_ = list switch\n{\n    { .., >= 0 } => 1,\n    { ..{ .., < 0 } } => 3,\n};\n```\n\n----------------------------------------\n\nTITLE: Example of Partial Type Inference Syntax in C#\nDESCRIPTION: This snippet illustrates potential uses of partial type inference in C#, specifically in invocation expressions and object creation expressions. It highlights '_', arrays, nullable types, and provides context for ongoing discussions about type arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-22.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// This code is to show the possible application\n// and is not an indication of syntax.\nG<_,>\n_[] // arrays\n_? // nullable types\n```\n\n----------------------------------------\n\nTITLE: Grammar Production Rules for Dictionary Expressions\nDESCRIPTION: Grammar productions that are added to the C# language specification to support dictionary expressions, including the definition for key-value pair elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\ncollection_element\n  : expression_element\n  : spread_element\n+ | key_value_pair_element\n  ;\n\n+ key_value_pair_element\n+  : expression ':' expression\n+  ;\n```\n\n----------------------------------------\n\nTITLE: Implementing NativeIntegerAttribute Class in C#\nDESCRIPTION: Definition of the NativeIntegerAttribute class used to indicate native integer types in metadata. The attribute can be applied to various code elements and includes transform flags to specify which parts of a type reference are native integers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly bool[] TransformFlags;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Null Check Syntax Examples\nDESCRIPTION: Code examples showing different syntax options considered for parameter null checking, including the accepted format and alternatives that were discussed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-14.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string s!)           // Accepted syntax\nvoid M(string! s)           // Alternative syntax\nvoid M(string? param!)       // Warning case\npublic string! s            // Field syntax option\npublic string s!            // Alternative field syntax\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref Readonly Local Usage in C#\nDESCRIPTION: This snippet shows the basic usage of ref readonly locals compared to regular variable assignment. It demonstrates how ref readonly locals provide a way to reference a value without allowing mutation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-09-25.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = a[1];\nref readonly var r = ref a[1];\n```\n\n----------------------------------------\n\nTITLE: Multiple Interface Implementation with Ref Struct Constraint\nDESCRIPTION: Demonstrates implementing multiple async enumerable interfaces with allows ref struct constraint and IAsyncEnumerable<T>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IMyAsyncEnumerable1<T>\n{\n    IAsyncEnumerator<int> GetAsyncEnumerator(CancellationToken cancellationToken = default);\n}\n\ninterface IMyAsyncEnumerable2<T>\n{\n    IAsyncEnumerator<int> GetAsyncEnumerator(CancellationToken cancellationToken = default);\n}\n\nclass C\n{\n    static async Task Test<T>() where T : IMyAsyncEnumerable1<int>, IMyAsyncEnumerable2<int>, IAsyncEnumerable<int>, allows ref struct\n    {\n        await foreach (var i in default(T)) // IAsyncEnumerable<int>.GetAsyncEnumerator\n        {\n            System.Console.Write(i);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unbound Generic Types in nameof (C#)\nDESCRIPTION: Examples of using unbound generic types with nameof, including simple and nested cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/unbound-generic-types-in-nameof.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnameof(A<>)            // evaluates to \"A\"\nnameof(Dictionary<,>)    // evaluates to \"Dictionary\"\nnameof(A<>.B)           // evaluates to \"B\"\nnameof(A<>.B.Count)     // evaluates to \"Count\"\n```\n\n----------------------------------------\n\nTITLE: Compound Assignment Evaluation Order Example\nDESCRIPTION: Shows evaluation order in compound assignment operations with params collections, including index evaluation and collection population.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static void Test(Program p)\n    {\n        p[GetA(), GetC()]++;\n    }\n\n    int this[int a, params MyCollection c] { get => 0; set {} }\n\n    static int GetA() => 0;\n    static int GetC() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Property Validation Using field Keyword in C#\nDESCRIPTION: Example demonstrating property validation using the proposed field keyword for accessing the backing field. Includes validation to ensure value is not negative.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-01.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic int PositiveValue\n{\n    get => field;\n    set\n    {\n         if (value < 0)\n            throw new ArgumentException(\"Cannot be negative\")\n        field = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Class with Primary Constructor in C# 12.0\nDESCRIPTION: Demonstrates the use of primary constructors to reduce boilerplate code when defining a class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Point(int x, int y);\n```\n\n----------------------------------------\n\nTITLE: Analyzing Null Comparison Flow Analysis in C#\nDESCRIPTION: Example demonstrating the question of whether flow analysis should cause non-nullable types to become nullable when compared to null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-31.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string x)\n{\n   if (x == null)\n   {\n       // is x now treated as 'string?' here?\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Base Interface Invocation with Single Method Disambiguation\nDESCRIPTION: Shows a simplified syntax for base interface invocations when there's no ambiguity about which method is being called, but multiple implementations from different parent interfaces are available.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1 { void M(); }\ninterface I3 : I1 { void I1.M() { } }\ninterface I4 : I1 { void I1.M() { } }\ninterface I5 : I3, I4\n{\n    void I1.M()\n    {\n        base<I3>.M(); // calls I3's implementation of I1.M\n        base<I4>.M(); // calls I4's implementation of I1.M\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Current Boilerplate for Async Logic in Main Method\nDESCRIPTION: Shows the current pattern required to use async code in a C# application entrypoint, where a separate async method must be created and called from Main.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/async-main.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Main()\n{\n    MainAsync().GetAwaiter().GetResult();\n}\n\nprivate static async Task MainAsync()\n{\n    ... // Main body here\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Object Initializer Limitations for Inline Arrays in C#\nDESCRIPTION: This snippet shows that by default, element initialization is not supported for inline arrays using the object initializer syntax. It results in a compiler error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nstatic C M2() => new C() { F = {[0] = 111} }; // error CS1913: Member '[0]' cannot be initialized. It is not a field or property.\n\nclass C\n{\n    public Buffer10<int> F;\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Null Checking with NotNull Constraint\nDESCRIPTION: Example showing null checking in generic methods with notnull constraint.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-05.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic T Id<T>(T t) where T : notnull\n{\n    if (t is null) Console.WriteLine();\n    return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Annotated Type Substitution Examples in C#\nDESCRIPTION: Shows how T? behaves when substituted with already annotated types, demonstrating that double annotation is avoided.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar u1 = new U[0].FirstOrDefault();  // U? u1\nvar u2 = new U?[0].FirstOrDefault(); // U? u2\n```\n\n----------------------------------------\n\nTITLE: Declaring Method Overloads for Collection Parameters in C#\nDESCRIPTION: Example showing method overloads with different collection parameter types (array and list) that could create ambiguity when called with collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M(T[] values);\npublic void M(List<T> values);\n```\n\n----------------------------------------\n\nTITLE: Generating Static Methods from Extension Methods in C#\nDESCRIPTION: This snippet demonstrates how implicit compatibility is achieved by generating a static method that mimics a classic extension method. The static method is generated based on the attributes, return type, name, and parameters of the declared instance extension method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/implicit-compatibility-for-ported-extension-methods.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TSource>(IEnumerable<TSource> source)\n    {\n        public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { ... }\n        public IEnumerable<TSource> Select<TResult>(Func<TSource, TResult> selector)  { ... }\n    }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate) { ... }\n    public static IEnumerable<TSource> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)  { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Collections with Various Scopes in C#\nDESCRIPTION: This snippet demonstrates how the C# compiler allocates storage for collection expressions for different scenarios like empty collections, primitive constants, and dynamic values. The `Print` method accepts a `ReadOnlySpan<object>` which is scoped implicitly. Depending on parameters, collections may have global or local scope with different memory allocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nPrint([]);               // empty collection, no allocation\nPrint([1, 2, 3]);        // primitive constants, assembly data, global scope\nPrint([x, y, z]);        // stack allocation, local scope\nPrint((int[])[1, 2, 3]); // heap allocation, global scope\n\nstatic void Print(ReadOnlySpan<object> values) { ... } // argument is implicitly scoped\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Type Equivalence in C#\nDESCRIPTION: Code showing how tuple types with different element names are equivalent via identity conversion, and how unnamed tuples are compatible with named tuples.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-01.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n(int x, int y) t1 = ...;\n(int a, int b) t2 = t1; // identity conversion\n(int, int) t3 = t1;     // identity conversion\n```\n\n----------------------------------------\n\nTITLE: Flow Analysis Warning Silencing in C#\nDESCRIPTION: Example demonstrating how flow analysis handles warning silencing for nullable variables and type parameters when null checks are performed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-23.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid M<T>(string? s, T t)\n{\n    if (s != null) WriteLine(s.Length);     // How is the warning silenced?\n    if (t != null) WriteLine(t.ToString()); // How is the warning silenced?\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguous Overload Resolution in C#\nDESCRIPTION: This example shows an ambiguous case in overload resolution between a concrete List<int> and a ReadOnlySpan<int> when using a collection expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(List<int> list);\nvoid M(ReadOnlySpan<int> list);\n\nM([1, 2, 3]); // Ambiguous.\n```\n\n----------------------------------------\n\nTITLE: Using Non-trailing Named Arguments with Params\nDESCRIPTION: Example showing how non-trailing named arguments would work with parameter arrays (params) in C#. This allows naming the initial parameters while passing the remaining params arguments positionally.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/non-trailing-named-arguments.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Task\n{\n    public static Task When(TaskStatus all, TaskStatus any, params Task[] tasks);\n}\nTask.When(all: TaskStatus.RanToCompletion, any: TaskStatus.Faulted, task1, task2)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Extension Members in C#\nDESCRIPTION: This code illustrates the use of static and instance extension members defined in 'MyExtensions'. It demonstrates creating ranges, checking if sequences are empty, and utilizes a custom '+=' operator. Dependencies include 'System.Linq' and 'System'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = IEnumerable<int>.Range(0, 10);\nvar empty = IEnumerable<int>.Empty;\nrange += 5;\nReadOnlySpan<int> span = range;\n\n// Instance extension members\nvar query = range.Where(i => i < 10);\nvar isEmpty = query.IsEmpty;\nvar first = query[0];\nvar repetition = new IEnumerable<int>(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Extension Member Disambiguation Example in C#\nDESCRIPTION: This code snippet illustrates a potential disambiguation syntax for extension members using the `@` operator. It allows specifying the enclosing type for member lookup. The type argument for `T` is inferred from the type of `strings` during lookup.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\nstring[] strings = ...;\nvar query  = (strings @ Enumerable).Where(s => s.Length > 10);\n \npublic static class Enumerable\n{\n    extension<T>(IEnumerable<T>)\n    {\n        public IEnumerable<T> Where(Func<T, bool> predicate) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default for optional parameters in C#\nDESCRIPTION: Declaring method parameters with default values using the default literal where the type is inferred from the parameter type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvoid Method(ImmutableArray<SomeType> arrayOpt = default)\n```\n\n----------------------------------------\n\nTITLE: Adding Nullable Parameter Override in C# Class Hierarchy\nDESCRIPTION: This snippet demonstrates how adding a nullable parameter override in a base class can affect derived classes using the '!!' operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// Assembly2\nabstract class C2 : C1 {\n   protected override void M(object? o) { \n       ...\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Literal Usage with Builder Semantics\nDESCRIPTION: This C# code snippet demonstrates how a collection literal might be used with builder semantics, where the natural type of the collection is anonymous but provides methods like `Add` and `Remove`. The compiler would optimize the collection initialization, potentially using `ImmutableArray<T>` directly to avoid intermediate bookkeeping.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-05-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar collection = [1, 2, 3];\ncollection.Remove(2);\nTakesImmutableArray(collection);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Pattern Matching Errors in C#\nDESCRIPTION: Shows various scenarios where pattern matching could produce errors or warnings, including impossible matches and redundant patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\ncase >= 0 and <= 100D:\n```\n\nLANGUAGE: csharp\nCODE:\n```\ncase 1 and 2:\n```\n\nLANGUAGE: csharp\nCODE:\n```\ncase 1 or 2 or 3 or 1:\n```\n\nLANGUAGE: csharp\nCODE:\n```\ncase < 2: break;\ncase 0 or 1 or 2 or 3 or 4 or 5: break;\n```\n\n----------------------------------------\n\nTITLE: Using Stackalloc with Span<T> in C#\nDESCRIPTION: This code demonstrates how Span<T> could be used with stackalloc to allocate memory on the stack, showing one of the key use cases for the Span<T> abstraction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-01.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nSpan<byte> s = stackalloc byte[4];\n```\n\n----------------------------------------\n\nTITLE: Value Type Substitution Examples in C#\nDESCRIPTION: Demonstrates behavior when T? is used with value types, showing how nullability is handled differently compared to reference types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar i1 = new int[0].FirstOrDefault();  // int i1\nvar i2 = new int?[0].FirstOrDefault(); // int? i2\n```\n\n----------------------------------------\n\nTITLE: Implementing Ref Choice Method in C#\nDESCRIPTION: A workaround method that conditionally returns a reference to one of two parameters based on a boolean condition. This demonstrates the current limitation where all arguments must be evaluated at the call site.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/conditional-ref.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nref T Choice(bool condition, ref T consequence, ref T alternative)\n{\n    if (condition)\n    {\n         return ref consequence;\n    }\n    else\n    {\n         return ref alternative;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reference Equality Short-Circuiting in C# Record Equals Method\nDESCRIPTION: Proposal to add a reference equality check at the start of the Equals instance method for C# records. This aims to improve performance by short-circuiting the equality comparison when objects are referentially equal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-08-24.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic virtual bool Equals(MyRecord other)\n{\n    if (ReferenceEquals(this, other)) return true;\n    // Existing equality comparison logic\n}\n```\n\n----------------------------------------\n\nTITLE: Using Attributes on 'this' Parameter in C# Extension Methods\nDESCRIPTION: Demonstrates how a new 'this' attribute target could allow specifying attributes on the implicit 'this' parameter of extension members, particularly useful for nullability annotations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[this:NotNullWhen(false)] public bool IsNullOrEmpty => this is null or [];\n```\n\n----------------------------------------\n\nTITLE: Using Generic Attributes for Extension Type Encoding in C#\nDESCRIPTION: Demonstrates how generic attributes could be used to encode extension types in method signatures. It uses a hypothetical Extension<T> attribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-07.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// source\nvoid M(E e)\n\n// codegen\nvoid M([Extension<E>] Underlying e) // System.Extension`1 (new)\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Method with Nullable and Interface Constraints in C#\nDESCRIPTION: This code snippet demonstrates the syntax for defining generic methods with nullable and interface constraints in C#. It shows both incorrect and correct ways to specify constraints on generic type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-11.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M1<T>(T t) where T : I, T : class?\n\nvoid M1<T>(T t) where T : I?, T : class?\n\nvoid M1<T>(T t) where T : I, T: class\n```\n\n----------------------------------------\n\nTITLE: Raw String with Leading Quote\nDESCRIPTION: Example of a raw string literal that starts with a quote character.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         \"The content of this string starts with a quote\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Constraints on Unsettable Required Members\nDESCRIPTION: Rules established for required fields and properties: required fields cannot be readonly, and required properties must have setters/initers as accessible as their constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-23.md#2025-04-21_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Initialization with field Keyword in C#\nDESCRIPTION: This snippet shows a lazily initialized property using the 'field' keyword. It demonstrates how the property can be implemented without explicit backing field declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public C() { } // It would be undesirable to warn about 'Prop' being uninitialized here\n\n    string Prop => field ??= GetPropValue();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Interface Method Without Boxing in C#\nDESCRIPTION: Example showing how to use generic methods with ref parameters to avoid boxing when working with interface methods on structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-19.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic static void Increment<T>(ref T t) where T : I => t.Increment();\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Customer Properties in C#\nDESCRIPTION: Example demonstrating pattern matching syntax for checking customer middle name against empty string or null values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-03-19.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ncase Customer { MiddleName: \"\" or null }\n```\n\n----------------------------------------\n\nTITLE: Utilizing Instance Extension Methods with For-Clause in C#\nDESCRIPTION: The code example shows instance extension methods within a defined extension container using the for-clause, which avoids repetition of the receiver type declaration when the for-clause is clear. This approach enhances syntactic simplicity, aligning closely to lambda expression forms.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\ninternal partial extensions ProjectExtensions for Project\n{\n    public Document project.GetRequiredDocument(DocumentId documentId)\n        => project.GetDocument(documentId) ?? throw new ...;\n\n    public Document project.GetRequiredDocument(SyntaxTree tree)\n        => project.GetDocument(tree) ?? throw new ...;\n\n    public TextDocument project.GetRequiredAdditionalDocument(DocumentId documentId)\n        => project.GetAdditionalDocument(documentId) ?? throw new ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Partial Events with Weak Event Libraries in C#\nDESCRIPTION: Example of using partial events with a weak event library, showing user-defined event and a library-generated implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/partial-events-and-constructors.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npartial class C\n{\n    [WeakEvent]\n    partial event Action<int, string> MyEvent;\n\n    void M()\n    {\n        RaiseMyEvent(0, \"a\");\n    }\n}\n\npartial class C\n{\n    private readonly WeakEvent _myEvent;\n\n    partial event Action<int, string> MyEvent\n    {\n        add { _myEvent.Add(value); }\n        remove { _myEvent.Remove(value); }\n    }\n\n    protected void RaiseMyEvent(int x, string y)\n    {\n        _myEvent.Invoke(x, y);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Small Collection Expressions in C#\nDESCRIPTION: This code snippet shows an optimization for small, fixed-size collection expressions. It implements a specialized list type for collections with exactly two elements, avoiding array indirection and overhead.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Compiler-synthesized-types.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class SmallCompilerSynthesizedList2<T> : IReadOnlyList<T>, IList<T>, IList\n{\n    private readonly T _v1;\n    private readonly T _v2;\n\n    public SmallCompilerSynthesizedList2(T v1, T v2)\n        => (_v1 = v1, _v2 = v2);\n\n    public int Count => 2;\n\n    // remainder of methods optimized to just access fields directly.\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar Changes for Unbound Generic Types in nameof (C#)\nDESCRIPTION: Proposed grammar changes to support unbound generic types in nameof expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/unbound-generic-types-in-nameof.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nnamed_entity\n    : named_entity_target ('.' identifier (type_argument_list | generic_dimension_specifier)?)*\n    ;\n    \nnamed_entity_target\n    : simple_name\n    | 'this'\n    | 'base'\n    | predefined_type \n    | qualified_alias_member\n    ;\n\nsimple_name\n    : identifier (type_argument_list | generic_dimension_specifier)?\n    ;\n\ngeneric_dimension_specifier\n    : '<' ','* '>'\n```\n\n----------------------------------------\n\nTITLE: Defining Lambda with Optional Parameters in C# 12.0\nDESCRIPTION: Shows how to declare a lambda expression with optional parameters, a new feature in C# 12.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n(int i = 42) => { }\n```\n\n----------------------------------------\n\nTITLE: Combining Switch Expressions and Property Patterns in C#\nDESCRIPTION: Demonstrates the use of property patterns within switch expressions, showcasing different syntax options and their implications.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-30.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nvar result = person switch \n{ \n    { Name: \"Mads\", Employer: { ID: string id } }: id,\n    (_, id: var pid){ Name: \"Matt\" }: pid,\n    _: null\n};\n```\n\nLANGUAGE: c#\nCODE:\n```\nvar result = person switch \n{ \n    { Name is \"Mads\", Employer is { ID is string id } }: id,\n    (_, var pid){ Name is \"Matt\" }: pid,\n    _: null\n};\n```\n\n----------------------------------------\n\nTITLE: Exploring Dictionary Types as Params in C#\nDESCRIPTION: This code snippet explores the support for dictionary types as params parameter types. It demonstrates the use of KeyValuePair<K, V> in params methods and the limitations of k:v syntax in expanded form.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nKeyValuePair<string, int> x, y;\n\nToDictionary(x, y);\nToReadOnlyDictionary(x, y);\n\nstatic Dictionary<K, V> ToDictionary<K, V>(\n    params Dictionary<K, V> elements) => elements;          // C#14: ok?\n\nstatic IReadOnlyDictionary<K, V> ToReadOnlyDictionary<K, V>(\n    params IReadOnlyDictionary<K, V> elements) => elements; // C#14: ok?\n\nToList(\"one\":1);   // error: syntax error ':'\nToList([\"two\":2]); // C#14: ok\n\nstatic List<KeyValuePair<K, V>> ToList<K, V>(params List<KeyValuePair<K, V>> elements) => elements;\n```\n\n----------------------------------------\n\nTITLE: Custom Union with Closed Class Hierarchy in C#\nDESCRIPTION: Shows how to create a custom union type using a class hierarchy with the Closed attribute for exhaustiveness checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\n[Closed]\npublic class U { ... }\npublic class A(int x, string y) : U { ... }\npublic class B(int z) : U { ... }\n```\n\n----------------------------------------\n\nTITLE: Using Alias with Nullable Generic List Example\nDESCRIPTION: Example showing a using alias declaration for a List with nullable string elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-01-11.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing MyList = List<string?>;\n```\n\n----------------------------------------\n\nTITLE: ReadOnlySpan<T> Variance Conversion Example\nDESCRIPTION: Demonstration of a feature where ReadOnlySpan<T> variance conversion will be supported in C# 13+ with requirement of CastUp<TDerived> method. If the method is not found, compiler will issue an error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-13.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nReadOnlySpan<T>.CastUp<TDerived>\n```\n\n----------------------------------------\n\nTITLE: AllowNull Field Attribute Example in C#\nDESCRIPTION: Shows how the `[field: AllowNull]` attribute allows assigning maybe-null values to a non-nullable field-backed property\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[field: AllowNull]\npublic string ResetIfSetToDefault\n{\n    get => field ?? GetDefault();\n    set => field = (value == GetDefault() ? null : value);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating nullable state analysis with multiple Where calls in C#\nDESCRIPTION: Shows how multiple Where method calls can be composed to refine nullable state analysis, allowing for more precise null-checking of collection elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-22.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nrecord Widget(string? Prop) { }\n\nvar x = en.Where(w => w is not null) // IEnumerable<Widget>\n          .Where(w => w.Prop is not null); // IEnumerable<Widget+element-flow-state>\n```\n\n----------------------------------------\n\nTITLE: Static Helper Method Implementation\nDESCRIPTION: Current workaround using wrapper method to handle static abstract member access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/self-constraint.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static T GetAdditiveIdentity<T>()\n    where T : IAdditiveIdentity<T>\n{\n    return T.AdditiveIdentity;\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Compat Mode in C# Extension\nDESCRIPTION: This code snippet demonstrates how to activate compatibility mode for a C# extension method using the `this` keyword on the receiver parameter. Compatibility mode aims to ensure that upgraded classic extension methods either behave compatibly or result in a compile-time error if compatibility isn't possible.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/compat-mode-in-extensions.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TSource>(this IEnumerable<TSource> source) // `this` means compat mode\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Parameter Annotation Implementation Details in C#\nDESCRIPTION: Detailed implementation example showing the correct annotations and constraints for different type scenarios. Shows how U?? notation works with reference types and value types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-08.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract class A<T>\n{\n    internal abstract F<U>(ref U?? u) where U : T;\n}\nclass B1 : A<string>\n{\n    internal override F<U>(ref U?? u) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Methods with 'ref' Parameter in C#\nDESCRIPTION: Shows how a type-based approach could specify 'ref' or 'in' in the 'for' clause to allow mutations of value type receivers. The example implements a Swap method and a Sum property for a tuple.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic extension TupleExtensions for ref (int x, int y)\n{\n    public void Swap() => (x, y) = (y, x); // `this` is by ref and can be mutated\n    public readonly int Sum => x + y; // `this` is ref readonly and cannot me mutated\n}\n```\n\n----------------------------------------\n\nTITLE: Function Type Determination for Extension Methods in C#\nDESCRIPTION: This code illustrates how function types are determined for extension methods. The example defines two extension methods named `M` for the `object` type, one static and another instance method with a parameter. The code attempts to bind `C.M` to a static method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nvar x = C.M; // binds to static method\n\npublic class C { }\npublic static class E1\n{\n    extension(object)\n    {\n        public static void M() { }\n    }\n    extension(object o)\n    {\n        public void M(int i) { }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Preferred Positional Record Syntax in C#\nDESCRIPTION: The team's preferred syntax for positional records, creating a class with the same features as nominal records plus a constructor and Deconstruct method based on the parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-11.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nrecord class Person(string FirstName, string LastName);\n```\n\n----------------------------------------\n\nTITLE: Example of IEnumerable Implementation with Params Collections\nDESCRIPTION: This example shows how a class implementing only IEnumerable with a string iteration type behaves differently with params collections than with direct arguments. The collection expression allows mixing string and int, but direct params arguments reject the int.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass MyCollection : IEnumerable\n{\n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n\n    public IEnumerator<string> GetEnumerator() => throw null; \n    public void Add(object l) => throw null;\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Test(\"2\", 3); // error CS1503: Argument 2: cannot convert from 'int' to 'string'\n        Test([\"2\", 3]); // Ok\n    }\n\n    static void Test(params MyCollection a)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Expression with contextual element-target-typing in C#\nDESCRIPTION: Illustrates a collection expression where the target type `byte` influences the created collection type. This ensures the loop is legal, demonstrating contextual element-target-typing. It shows how element types can propagate to influence collection expression types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2024-01-23.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n\t\t- `foreach (byte b in [1, 2, 3])`.  Here, we believe that the `byte` type should help influence the collection type being created (so that this case is legal).\n```\n\n----------------------------------------\n\nTITLE: Initializing Unknown Length Collection in C#\nDESCRIPTION: Shows the translation of an unknown length collection literal to a type that supports collection initializers. This is the least optimized approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nT __result = new T();\n\n__result.Add(__e1);\nforeach (var __t in __s1)\n    __result.Add(__t);\n\n// further additions of the remaining elements\n```\n\n----------------------------------------\n\nTITLE: Ref Conditional Operator Original Syntax\nDESCRIPTION: Shows the originally proposed syntax for conditional operator with ref variables, using explicit ref keywords.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ncond ? ref v1 : ref v2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scope Rules in C# Primary Constructors\nDESCRIPTION: Illustrates the nested scopes in a primary constructor, including base arguments, field initializers, and the constructor body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npartial class C(int x1) : B(int x3 = x1 /* x2 in scope but can't be used */)\n{\n    public int X0 { get; } = (int x2 = x1);\n    {\n        int x4 = X0 + x1 + x2 + x3;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Required Virtual Properties Example in C#\nDESCRIPTION: Demonstrates the interaction between required members and virtual/abstract property overrides, showing potential issues with base property access. This example illustrates an anti-pattern where overridden properties don't delegate to original storage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract class Base\n{\n    public required abstract int Prop1 { get; set; }\n    public required virtual int Prop2 { get; set; }\n}\n\nclass Derived : Base\n{\n    public required override int Prop1 { get; set; } // This is probably fine?\n    public required override int Prop2 { get; set; } // Is this ok?\n    \n    public void ToString()\n    {\n        _ = base.Prop1; // Already illegal\n        _ = base.Prop2; // What happens, was base.Prop2 initialized?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Methods and Implicit Extensions in C#\nDESCRIPTION: This snippet illustrates the definition of extension methods and the use of implicit extensions in C#. It discusses how extension methods are resolved during overloads.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-02-28.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class Extensions\n{\n    public static X ToX<Y>(this IEnumerable<Y> values) => ...\n}\n\nimplicit extension ImmutableArrayExtensions<Y> for ImmutableArray<Y>\n{\n    public X ToX() => ...\n}\n\n// or reverse:\n\nstatic class Extensions\n{\n    public static X ToX<Y>(this ImmutableArray<Y> values) => ...\n}\n\nimplicit extension IEnumerableExtensions<Y> for IEnumerable<Y>\n{\n    public X ToX() => ...\n}\n```\n\n----------------------------------------\n\nTITLE: String Parameter Null Check Flow Analysis\nDESCRIPTION: Shows warning behavior for string parameter assignment within null-checked block.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-05.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string p1)\n{\n    if (p1 == null)\n    {\n        string x = p1; // W warning? -> Yes\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Objects with Factory Method Syntax in C#\nDESCRIPTION: Example showing proposed syntax for using object initializers with factory methods, requiring the 'new' keyword to maintain clarity and reduce ambiguity with other language features.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-20.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar s = new Create() { Name = \"Andy\" };\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Length Property Pattern Matching in C#\nDESCRIPTION: Examples showing different cases of Length property pattern matching and their warning/error behavior, particularly for negative length values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-09-22.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nx is { Length: -1 } // Warning, not subsumbed by any previous case\nx is { Length: >=0 } // Considered Exhaustive\nx is { Length: <5 or -1 } // Error on the -1, subsumed by <5. No warning on the <5.\n```\n\n----------------------------------------\n\nTITLE: Effect on Existing Programs: Static Method Example in C#\nDESCRIPTION: This example demonstrates that a static method in a class is unrelated to an interface method with the same name, preserving existing behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M();\n}\nclass C: IA // Error: IA.M has no concrete most specific override in C\n{\n    public static void M() { } // method unrelated to 'IA.M' because static\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Types Supporting Both Collection and Dictionary Initialization in C#\nDESCRIPTION: This code snippet presents a hybrid type that supports both collection and dictionary initialization. It demonstrates the potential ambiguity in initialization and the preferred approach for such types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Hybrid<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>\n{\n    public void Add(KeyValuePair<TKey, TValue> pair);\n    public TValue this[TKey key] { ... }\n}\n\n// This would compile in C# 12:\n// Translating to calls to .Add.\nHybrid<string, int> nameToAge = [someKvp];\n```\n\n----------------------------------------\n\nTITLE: Using Best Common Type with Function Types\nDESCRIPTION: This example shows how the best common type is determined for an array of anonymous functions. Both lambda expressions have the same signature, so they share a common function type Func<string, int>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar fs = new[] { (string s) => s.Length, (string s) => int.Parse(s) }; // Func<string, int>[]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullability Warnings in C#\nDESCRIPTION: Shows code that generates warnings when using a potentially null value in contexts requiring non-null values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-01-08.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid Bad([CouldBeNull] string s)\n{\n    Foo(s);           // Warning!\n    var l = s.Length; // Warning!\n}\n```\n\n----------------------------------------\n\nTITLE: Cast Expression vs. Collection Indexer Ambiguity in C#\nDESCRIPTION: Examples showing the ambiguity between cast expressions and collection literals, where the same syntax could be interpreted as either indexing into an expression or casting to a collection type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\nvar v = (Expr)[1, 2, 3];\n\nvar v = (ImmutableArray<int>)[1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Example of Defaultable Types in Generic Method Signature in C#\nDESCRIPTION: Shows an example of how defaultable types could be used in generic method signatures, specifically for methods like 'FirstOrDefault' that may return null even for non-nullable type arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-14.md#2025-04-23_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nT? FirstOrDefault<T>(this IEnumerable<T> src)\n```\n\n----------------------------------------\n\nTITLE: Extending Collection Literal Grammar for Dictionary Elements in C#\nDESCRIPTION: This code snippet shows the proposed grammar additions to support dictionary-like elements in collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\ncollection_literal_element\n  : expression_element\n+ | dictionary_element\n  | spread_element\n  ;\n\n+ dictionary_element\n  : expression ':' expression\n  ;\n```\n\n----------------------------------------\n\nTITLE: Async Implementation with Local Function in C#\nDESCRIPTION: Shows optimization pattern using local async function for handling async operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\npublic Task<byte> GetByteAsync()\n{\n    async Task<byte> ActuallyGetByteAsync()\n    {\n        await buffer.GetMoreBytesAsync();\n        byte result;\n        if (!buffer.TryGetBufferedByte(out result)) throw ...; // we just got more\n        return result;\n    }\n\n    byte result;\n    if (!buffer.TryGetBufferedByte(out result)) return ActuallyGetByteAsync(); // slow path\n\n    if (taskCache[result] == null) taskCache[result] = Task.FromResult(result);\n    return taskCache[result];\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Virtual Interface Members in C#\nDESCRIPTION: Examples showing different approaches to declaring non-virtual members in interfaces using virtual and sealed modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-05.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1\n{\n    virtual void M1() { ... }\n    void M2() { ... } // non-virtual\n}\ninterface I2\n{\n    void M1() { ... } \n    sealed void M2() { ... } // non-virtual\n}\ninterface I3\n{\n    virtual void M1() { ... } \n    sealed void M2() { ... } // non-virtual\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Compound Assignment Operator in C#\nDESCRIPTION: Example of implementing a += compound assignment operator in a class. The operator adjusts the Value field by adding the parameter value to it.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass C1\n{\n    public int Value;\n\n    public void operator +=(int x)\n    {\n        Value+=x;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Boxing Interface Implementation\nDESCRIPTION: Demonstrates how struct must be boxed to access interface methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nIA s = default(S); // an S, boxed\ns.M(); // ok\n```\n\n----------------------------------------\n\nTITLE: Tuple-like Functionality of KeyValuePair in Collections - C#\nDESCRIPTION: This snippet compares the flexibility of KeyValuePairs in dictionary expressions with the similar behavior of tuples in C#. It showcases how the language handles type transparency for KeyValuePairs during collection allocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nList<(object? key, int? value)> map = [(\"mads\", 21)];\n```\n\n----------------------------------------\n\nTITLE: Exploring Nullability Inference in C# Casts\nDESCRIPTION: This snippet illustrates different scenarios where nullability inference might be applied in casts. It demonstrates the potential impact on existing code and the design considerations for new code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-21.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nobject o = ...;\nvar o = (object)...;\n\nclass X { object[] o; }\n```\n\n----------------------------------------\n\nTITLE: Type Merging Rules for C# Nullable Types\nDESCRIPTION: Formal specification of type merging rules for handling nullable types and generic type parameters in C#. Covers basic types, generic types, tuple types and special cases like object/dynamic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\nMerge(T, T, d) = T\nMerge(S, T?, +) = Merge(S?, T, +) = Merge(S, T, +)?\nMerge(S, T?, -) = Merge(S?, T, -) = Merge(S, T, -)\nMerge(C<S1,...,Sn>, C<T1,...,Tn>, +) = C<Merge(S1, T1, d1),...,Merge(Sn, Tn, dn)>\nMerge(C<S1,...,Sn>, C<T1,...,Tn>, -) = C<Merge(S1, T1, d1),...,Merge(Sn, Tn, dn)>\nMerge((S1 s1,..., Sn sn), (T1 t1,..., Tn tn), d) = (Merge(S1, T1, d)n1,...,Merge(Sn, Tn, d) nn)\nMerge(object, dynamic) = Merge(dynamic, object) = dynamic\n```\n\n----------------------------------------\n\nTITLE: Async Method Builder Example\nDESCRIPTION: Illustrates the usage of AsyncMethodBuilder attribute for customizing async method generation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-21.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[AsyncMethodBuilder(typeof(MyCustomBuilder))]\npublic async int M() => ...;\n```\n\n----------------------------------------\n\nTITLE: Implementing Value Equality Class Variations with Key Keyword\nDESCRIPTION: Examples showing different ways to implement value equality in classes using the proposed 'key' keyword and IEquatable interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-12.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nkey class HasValueEquality1 { public key int X { get; } }\nclass HasValueEquality2 { public key int X { get; } }\nkey class HasValueEquality3 { public key X { get; } }\nclass HasValueEquality4 : IEquatable<HasValueEquality4> { public int X { get; } }\n```\n\n----------------------------------------\n\nTITLE: Struct Default Initialization Example\nDESCRIPTION: Example of requiring default initialization in struct constructors, which was discussed but rejected as it would interfere with field initializers\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-14.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nthis = default;\n```\n\n----------------------------------------\n\nTITLE: XML Documentation Output for Partial Indexers with Mismatched Parameter Names\nDESCRIPTION: Sample XML documentation output showing how documentation is generated when parameter names differ between partial indexer declarations, highlighting potential confusion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_7\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\"?>\n<doc>\n    <assembly>\n        <name>ConsoleApp1</name>\n    </assembly>\n    <members>\n        <member name=\"T:C\">\n            <summary>\n            My type\n            </summary>\n        </member>\n        <member name=\"P:C.Item(System.Int32)\">\n            <summary>\n            <paramref name=\"x\"/> // warning CS1734: XML comment on 'C.this[int]' has a paramref tag for 'x', but there is no parameter by that name\n            <paramref name=\"y\"/> // ok. 'Go To Definition' will go to 'int y'.\n            </summary>\n        </member>\n    </members>\n</doc>\n```\n\n----------------------------------------\n\nTITLE: Defining Non-Method Extension Members with Open Generic Types in C#\nDESCRIPTION: This snippet illustrates how to declare a property as an extension member with the member-based approach. It showcases handling open generic types without compromising compatibility with classic extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic extensions MemoryExtensions \n{\n    public Span<T> (T[]? array).AsSpan<T> { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating UnscopedRef and Scoped Ref Parameter Compatibility\nDESCRIPTION: This code snippet demonstrates how a method with a 'ref' parameter in an interface can be implemented by a method with a 'scoped ref' parameter in a struct, explaining the allowance for omitting UnscopedRef in implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    void M(ref Span<char> span);\n}\n\nstruct S : I1\n{\n    public void M(scoped ref Span<char> span) { }\n}\n```\n\n----------------------------------------\n\nTITLE: GetFirstOrDefault with MaybeNull Return Attribute\nDESCRIPTION: Example demonstrating the MaybeNull attribute on a method return value that currently warns when returning null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-06.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[return: MaybeNull]\nT GetFirstOrDefault<T>()\n{\n    return null; // currently warns\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Proposed Record Syntax in C#\nDESCRIPTION: Examples showing two alternative syntaxes for declaring records in C#: using the new 'record' keyword and using 'data class'. The examples use a Point record with X and Y coordinates to illustrate the syntax differences.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-10.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nrecord Point(int X, int Y);\n```\n\nLANGUAGE: C#\nCODE:\n```\ndata class Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Event Handler Assignment with Null Conditional Operator\nDESCRIPTION: Shows how to conditionally add an event handler using the null-conditional operator, which only attaches if the parent object exists.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/null-conditional-assignment.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nclass C\n{\n    public event Action E;\n}\n\nvoid M(C? c)\n{\n    c?.E += () => { Console.WriteLine(\"handled event E\"); };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Default Expressions with Unconstrained Generic Types in C#\nDESCRIPTION: Shows the potential warnings when using default expressions with unconstrained generic types, which could lead to null values for reference types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-09.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nT M<T>()\n{\n\treturn default(T); // warning\n\treturn default;    // warning\n}\n```\n\n----------------------------------------\n\nTITLE: Using Alias for Tuple Type in C# 12.0\nDESCRIPTION: Shows how to create a using alias for a tuple type, which is now allowed in C# 12.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing Point = (int x, int y);\n```\n\n----------------------------------------\n\nTITLE: Examining Legacy Code Compatibility with Nullable References in C#\nDESCRIPTION: This snippet demonstrates a scenario where legacy code might be affected by the introduction of nullable reference types. It shows how explicit casts might interact with nullability warnings in upgraded methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-21.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nM((string)y); // \n```\n\n----------------------------------------\n\nTITLE: Basic join-into with select Translation\nDESCRIPTION: Shows how a join-into clause immediately followed by a select clause is translated into a GroupJoin method call in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nfrom Â«x1Â» in Â«e1Â»  \njoin Â«x2Â» in Â«e2Â» on Â«k1Â» equals Â«k2Â» into Â«gÂ»  \nselect Â«vÂ»\n```\n\nLANGUAGE: csharp\nCODE:\n```\n( Â«e1Â» ) . GroupJoin( Â«e2Â» , Â«x1Â» => Â«k1Â» , Â«x2Â» => Â«k2Â» ,\n                     ( Â«x1Â» , Â«gÂ» ) => Â«vÂ» )\n```\n\n----------------------------------------\n\nTITLE: Exploring Ref Readonly Locals in Various Contexts in C#\nDESCRIPTION: This code snippet illustrates different scenarios where ref readonly locals might be used, including method calls, ternary operators, and array access. It also shows potential syntax for returning ref readonly values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-09-25.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nMyRefTaker(42);\nMyRefTaker(ref MyRefReturner());\nref readonly int r = 42;\nref readonly int r = ref MyRefReturner();\nb ? 42 : MyRefReturner()\n\nreturn ref r;\n\nref readonly int x = a[1];\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching and Nullability State in C#\nDESCRIPTION: Example demonstrating how pattern matching with 'is' affects the nullability state of a variable after the pattern match.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string s)\n{\n    if  (s is IComparable t)\n    {\n    }\n    s.ToString(); // warning\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Interpolated Verbatim Strings in C#\nDESCRIPTION: Demonstrates the two equivalent ways to define interpolated verbatim strings in C# 8.0, using either @$\" or $@\" prefix combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/alternative-interpolated-verbatim.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n@$\"...\"\n```\n\nLANGUAGE: C#\nCODE:\n```\n$@\"...\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Single-Element Deconstruction Patterns in C#\nDESCRIPTION: This snippet shows examples of single-element deconstruction patterns in a switch statement, illustrating potential syntax for matching 1D points.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-11-20.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nswitch(my1DPoint)\ncase 1DPoint(0):\n...\ncase 1DPoint(var x):\n...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inline Type Testing with Declaration Expressions in C#\nDESCRIPTION: Shows how to test a type and assign to a variable in a single expression. This approach works for reference types and nullable value types using the 'as' operator combined with null checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nif ((var s = e as string) != null) { â€¦ s â€¦ } // inline type test\n```\n\n----------------------------------------\n\nTITLE: Proposed Ref Ternary Syntax\nDESCRIPTION: The proposed syntax for conditional ref expressions using the ternary operator pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/conditional-ref.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<condition> ? ref <consequence> : ref <alternative>;\n```\n\n----------------------------------------\n\nTITLE: Extension Member with GenerateStaticMethod Attribute in C#\nDESCRIPTION: This code snippet shows extension members with the `GenerateStaticMethod` attribute. This attribute would generate an equivalent classic extension method. Type parameters from the extension declaration and the method declaration would be concatenated.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_15\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<T>(IEnumerable<T>)\n    {\n        [GenerateStaticMethod(\"source\")]\n        public IEnumerable<T> Where(Func<T, bool> predicate) \n        { \n            foreach (var e in this){ ... }\n        }\n        [GenerateStaticMethod(\"source\")]\n        public IEnumerable<T> Select<TResult>(Func<T, TResult> selector) \n        { \n            foreach (var e in this){ ... }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String.Format Equivalent of Interpolated String in C#\nDESCRIPTION: Shows how the compiler would translate an interpolated string into an equivalent String.Format call, handling format specifiers and escaping literal curly braces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-21.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nString.Format(\"Hello, {0}, you have {1,-3} donut{{s}} left.\", name, amount)\n```\n\n----------------------------------------\n\nTITLE: Python-style Range Example\nDESCRIPTION: Shows range usage with array length, demonstrating the advantage of exclusive ranges.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-22.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar s = a[0..a.Length];\n```\n\n----------------------------------------\n\nTITLE: Span constructor example with ref field in C#\nDESCRIPTION: This example shows a `Span<T>` constructor assigning a `ref` parameter to a `readonly ref` field. The assignment is legal because the *safe-context* of `this` is *return-only* and the *ref-safe-context* of `value` is *caller-context*.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n```c#\nreadonly ref struct Span<T>\n{\n    readonly ref T _field;\n    readonly int _length;\n\n    public Span(ref T value)\n    {\n        // Falls into the `x.e1 = ref e2` case, where `x` is the implicit `this`. The \n        // safe-context of `this` is *return-only* and ref-safe-context of `value` is \n        // *caller-context* hence this is legal.\n        _field = ref value;\n        _length = 1;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Equivalent Nested Expression Class Definition\nDESCRIPTION: Shows the equivalent class-based implementation of the nested Expr enum class example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/discriminated-unions.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nabstract partial class Expr\n{\n    abstract partial class Binary : Expr\n    {\n        public record Addition(Expr left, Expr right) : Binary;\n        public record Multiplication(Expr left, Expr right) : Binary;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conceptual Slice Syntax in C#\nDESCRIPTION: This snippet demonstrates a potential syntax for array slicing in C#, which could be overloadable for different types like IEnumerable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Design-Review.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// Conceptual slice syntax\n// Not actual C# code\n```\n\n----------------------------------------\n\nTITLE: Illustrating Setter Analysis for Potential Uninitialized Fields in C#\nDESCRIPTION: This example demonstrates a scenario where a setter might exit without initializing the backing field, potentially leading to a nullability warning.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public C() { Prop = \"...\" };\n\n    public string Prop\n    {\n        get;\n        set\n        {\n            if (condition) field = value;\n        //  CS8774 Member 'field' must have a non-null value when exiting.\n        }\n        ~\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Declaration with Required Modifier Example\nDESCRIPTION: Example demonstrating the new 'required' keyword that will be disallowed as a type name in C# 11 without @ escaping. This decision follows the pattern set by 'record' in C# 9.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-12-15.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n@required class MyClass {} // Valid in C# 11\nrequired class MyClass {} // Invalid in C# 11\n```\n\n----------------------------------------\n\nTITLE: Range Expression Ambiguity in C#\nDESCRIPTION: Demonstrates syntax ambiguity between spread_element and range_expression in collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_19\n\nLANGUAGE: c#\nCODE:\n```\nRange[] ranges = [range1, ..e, range2];\n```\n\n----------------------------------------\n\nTITLE: Extension Scoping and Shadowing in C#\nDESCRIPTION: This code illustrates scoping and shadowing issues related to extension parameters within a static class. The example defines an extension on `string` with several members, including a static property `P` and instance methods `M2` and `M3`. The discussion revolved around whether the extension parameter `s` should be in scope for static members and whether instance methods should be able to shadow the extension parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-03-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"public static class E\n{\n    static string s;\n    extension(string s)\n    {\n        public int M(int i)\n        {\n            return s.Length + i;\n        }\n        public static string P => s; // Does this error that the extension parameter s can't be used, or bind to E.s?\n        public void M2(string s) { ... } // Should we allow this to shadow the extension parameter?\n        public static void M3(string s) { ... } // Should we allow this to shadow the extension parameter, since there's no implicit s?\n        public static void M4() { s.ToString(); } // Does this bind to the extension receiver parameter and error, or to E.s?\n    }\n}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Basic IAsyncEnumerable Interface Structure in C#\nDESCRIPTION: The primary design for async streams that mirrors the synchronous IEnumerable<T> pattern. This interface structure allows for asynchronous iteration with a straightforward API that includes IAsyncEnumerable<T>, IAsyncEnumerator<T>, and IAsyncDisposable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-03.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IAsyncEnumerable<out T>\n{\n    IAsyncEnumerator<T> GetAsyncEnumerator();\n}\n\npublic interface IAsyncEnumerator<out T> : IAsyncDisposable\n{\n    ValueTask<bool> MoveNextAsync();\n    T Current { get; }\n}\n\npublic interface IAsyncDisposable\n{\n    ValueTask DisposeAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Conversion in C#\nDESCRIPTION: Shows how tuple types can be converted in a pointwise manner, allowing assignment between compatible tuple types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n(byte, short) t1 = (1, 2);\n(int, int t2) = t1; // Why not?\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncEnumerableWithCancellation in C#\nDESCRIPTION: Demonstrates a struct implementation for wrapping an IAsyncEnumerable with cancellation support. Includes an extension method for easy usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-18.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstruct AsyncEnumerableWithCancellation<T>(IAsyncEnumerable<T> src, CancellationToken ct)\n{\n\tpublic IAsyncEnumerator<T> GetAsyncEnumerator() => src.GetAsyncEnumerator(ct);\n}\n\npublic static class AsyncEnumerable\n{\n\tpublic static AsyncEnumerableWithCancellation<T> WithCancellation<T>(this IAsyncEnumerable<T> src, CT ct) => new AEWC<T>(...);\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Unknown Length Array Creation in C#\nDESCRIPTION: Demonstrates an optimized approach for creating an array from an unknown length collection literal, avoiding intermediary list creation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nT1[] __result = <private_details>.CreateArray<T1>(\n    count_of_expression_elements);\nint __index = 0;\n\n<private_details>.Add(ref __result, __index++, __e1);\nforeach (var __t in __s1)\n    <private_details>.Add(ref __result, __index++, __t);\n\n// further additions of the remaining elements\n\n<private_details>.Resize(ref __result, __index);\n```\n\n----------------------------------------\n\nTITLE: Var? Syntax Proposal in C#\nDESCRIPTION: Example showing proposed var? syntax for declaring nullable variables with type inference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-18.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar? current = myLinkedList.Head;\n// now current is nullable, but the flow state is non-null\ncurrent.ToString(); // no warning, because the flow analysis says it's not null\n```\n\n----------------------------------------\n\nTITLE: Returning Tuples by Name in C#\nDESCRIPTION: Demonstrates creating, populating and returning a tuple by explicitly naming the members, allowing the compiler to infer the tuple type from the names and values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic (int sum, int count) Tally(IEnumerable<int> values) \n{\n    var res = (sum: 0, count: 0); // infer tuple type from names and values\n    foreach (var value in values) { res.sum += value; res.count++; }\n    return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Using nameof with Instance Members in C# 12.0\nDESCRIPTION: Demonstrates the relaxed restrictions on using instance members inside nameof expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nnameof(field.ToString)\n```\n\n----------------------------------------\n\nTITLE: Using the Unmanaged Constraint with Generic Method in C#\nDESCRIPTION: Example of applying the unmanaged constraint to a generic method parameter, which restricts the method to only accept unmanaged types as defined in the C# language specification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/blittable.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Hash<T>(T value) where T : unmanaged\n{\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Out Variables and Tuple Deconstruction in C#\nDESCRIPTION: This snippet demonstrates a LINQ query using out variables and tuple deconstruction, which are not currently allowed in query expressions. The code attempts to parse strings to integers and select successful parse results.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-18.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nfrom s in strings\nlet (b, i) = (int.TryParse(s, out var x), x)\nwhere b\nselect i\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default in return statements in C#\nDESCRIPTION: Using default literal in return statements where the type is inferred from the method's return type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nreturn default;\n```\n\n----------------------------------------\n\nTITLE: Using Declaration with Control Flow\nDESCRIPTION: Demonstrates how using declarations interact with control flow statements like goto.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/using.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    using var f1 = new FileStream(\"...\");\n  target:\n    using var f2 = new FileStream(\"...\");\n    if (someCondition) \n    {\n        // Causes f2 to be disposed but has no effect on f1\n        goto target;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Future Work: Merging Extension Declaration and Member Syntax\nDESCRIPTION: Proposed shorthand syntax that combines the extension declaration with the member definition, creating a more 'member-based' approach. Examples show both an indexer extension and a method extension using this more concise syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong bits) public bool this[int index]\n    {\n        get => (bits & Mask(index)) != 0;\n        set => bits = value ? bits | Mask(index) : bits & ~Mask(index);\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n \npublic static class Enumerable\n{\n    extension<TSource>(IEnumerable<TSource> source) public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Compiler Directives in C# ANTLR Grammar\nDESCRIPTION: ANTLR grammar rules for defining nullable compiler directives in C#, including #nullable directives and pragma warning directives for controlling nullable contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR\nCODE:\n```\npp_directive\n    : ...\n    | pp_nullable\n    ;\n\npp_nullable\n    : whitespace? '#' whitespace? 'nullable' whitespace nullable_action (whitespace nullable_target)? pp_new_line\n    ;\n\nnullable_action\n    : 'disable'\n    | 'enable'\n    | 'restore'\n    ;\n\nnullable_target\n    : 'warnings'\n    | 'annotations'\n    ;\n\npragma_warning_body\n    : ...\n    | 'warning' whitespace warning_action whitespace 'nullable'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Input and Output Type Inference with Collection Expressions in C#\nDESCRIPTION: These snippets show input and output type inference for collection expressions, including inference from lambda parameters and return types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nInputTypeInference([(int y) => { }]); // InputTypeInference<int>()\n\nstatic void InputTypeInference<T>(List<Action<T>> x) { }\n```\n\nLANGUAGE: c#\nCODE:\n```\nOutputTypeInference([() => 1]);       // OutputTypeInference<int>()\n\nstatic void OutputTypeInference<T>(List<Func<T>> x) { }\n```\n\n----------------------------------------\n\nTITLE: Switch Expression vs Conditional Expression Comparison\nDESCRIPTION: Shows the behavioral difference between conditional expressions and switch expressions in method overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-conditional-expression.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nM(b ? 1 : 2); // calls M(long)\nM(b switch { true => 1, false => 2 }); // calls M(short)\n```\n\n----------------------------------------\n\nTITLE: Ref Variable Assignment Syntax Discussion in C#\nDESCRIPTION: Code examples showing two potential syntaxes for ref variable assignment, demonstrating the tradeoffs between requiring and not requiring the ref keyword on the left-hand side.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-02.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nref r = ref v; // or\nr = ref v;\n```\n\n----------------------------------------\n\nTITLE: Expression-Bodied Operator in C#\nDESCRIPTION: Demonstrates using expression-bodied syntax for defining an operator overload. This syntax provides a concise way to implement operators that have a single expression implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-11-04.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic static Complex operator +(Complex a, Complex b) => a.Add(b);\n```\n\n----------------------------------------\n\nTITLE: Dynamic Binding Example with IFoo Interface\nDESCRIPTION: Code example demonstrating a breaking change in dynamic binding behavior where the result type changes from dynamic to object when using dynamic parameters with interface methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-24.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Text.Json;\n\npublic class C\n{\n    public static C M(IFoo foo, dynamic value)m\n    {\n        var result = foo.Bar(\"name\", value);\n        return JsonSerializer.Deserialize<C>(result);\n    }\n}\n\npublic interface IFoo\n{\n    object Bar(string name, object value);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Assignment Pattern with Conditional Expressions in C#\nDESCRIPTION: This code demonstrates a scenario where both arms of a conditional expression result in a conditional state, allowing the compiler to join corresponding conditional states. The example shows how a variable 'y' can be conditionally assigned in both branches of a ternary operator and still be safely used in an if block.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nbool b = true;\nobject x = null;\nint y;\nif (b ? x != null && Set(out y) : x != null && Set(out y))\n{\n  y.ToString();\n}\n\nbool Set(out int x) { x = 0; return true; }\n```\n\n----------------------------------------\n\nTITLE: Translating Dictionary Literal to Custom Collection in C#\nDESCRIPTION: Shows the translation of a dictionary literal when the target type is a custom dictionary collection initializer. It creates a new instance with capacity and adds elements using indexers and foreach loops.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nT __result = new T(capacity: __len);\n\n__result[__e1.Key] = __e1.Value;\n__result[__k1] = __v1;\nforeach (var __t in __s1)\n    __result[__t.Key] = __t.Value;\n\n// further additions of the remaining elements\n```\n\n----------------------------------------\n\nTITLE: Improved Pattern Matching with Target-typing in C#\nDESCRIPTION: Shows the simplified pattern matching syntax using target-typed member access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/target-typed-static-member-lookup.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M(Result<ImmutableArray<int>, string> result)\n{\n    switch (result)\n    {\n        case .Success(var array): ...\n        case .Error(var message): ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Matching in C# with ExpressionStatement Example\nDESCRIPTION: This snippet compares code without pattern matching to code using the proposed pattern matching syntax for C#. It shows how pattern matching can simplify nested null checks and type casting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar e = s as ExpressionStatement;\nif (e != null) {\n    var a = e.Expr as AssignmentExpressionSyntax;\n    if (a != null) {\n        var l = a.Left as IdentifierName;\n        var r = a.Right as IdentifierName;\n        if (l != null && r != null & l.Name.name == r.Name.name) ...\n```\n\nLANGUAGE: C#\nCODE:\n```\nif (s is ExpressionStatement e &&\n    e.Expr is AssignmentExpressionSyntax a &&\n    a.Left is IdentifierName l &&\n    a.Right is IdentifierName r &&\n    l.Name.name == r.Name.name) ...\n```\n\n----------------------------------------\n\nTITLE: Null Check Flow Analysis Example in C#\nDESCRIPTION: Example showing how null checking affects flow analysis in a linked list traversal scenario.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-18.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar current = myLinkedList.Head; // assume Head is nullable oblivious/unannotated\nwhile (current is object)\n{\n    ...\n    current = current.Next; // assume oblivious\n}\ncurrent.ToString(); // only warns if `is object` is a pure null test\n```\n\n----------------------------------------\n\nTITLE: Modifying Shift Operator Declaration Requirement in C#\nDESCRIPTION: This code snippet shows the proposed change to the C# specification regarding the declaration of overloaded shift operators. It removes the restriction that the second operand must be of type `int`. This modification allows for more flexibility when defining shift operators for custom types, especially in generic contexts where the shift amount may naturally be of a different type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/relaxing_shift_operator_requirements.md#2025-04-21_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n\"- When declaring an overloaded shift operator, the type of the first operand must always be the class or struct containing the operator declaration,\nand the type of the second operand must always be int.\n+ When declaring an overloaded shift operator, the type of the first operand must always be the class or struct containing the operator declaration.\"\n```\n\n----------------------------------------\n\nTITLE: Spreading Elements in Dictionary Expressions - C#\nDESCRIPTION: Demonstrates how both 'spread' elements and 'expression' elements evaluating to KeyValuePair values can be seamlessly integrated into dictionary initializations, enhancing the flexibility of dictionary expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> nameToAge = [.. defaultValues, otherMap.Single(predicate)];\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Null Filter with Nullable Type Parameters\nDESCRIPTION: Sample implementation of a generic method that filters out null values from a collection, demonstrating a practical use case for allowing nullable annotations on unconstrained generic parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-27.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<T> FilterNull<T>(IEnumerable<T?> e)\n{\n    foreach (var i in e)\n    {\n        if (i != null)\n        {\n            yield return e;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Use of Ref Choice Method in C#\nDESCRIPTION: Example demonstrating how the Choice method workaround can lead to unexpected behavior because all arguments are evaluated unconditionally, potentially causing a NullReferenceException.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n// will crash with NRE because 'arr[0]' will be executed unconditionally\nref var r = ref Choice(arr != null, ref arr[0], ref otherArr[0]);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Overload Resolution for KeyValuePair<K, V> Collections in C#\nDESCRIPTION: This code snippet shows overload resolution rules when the target types are KeyValuePair<K, V> collections. It demonstrates how ambiguity can arise in certain cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\nKeyValuePair<byte, int> e;\nDictionary<byte, int> d;\n...\nPrint([1:2]); // <int, int>\nPrint([e])    // ambiguous\nPrint([..d])  // ambiguous\n\nvoid Print(List<KeyValuePair<int, int>> pairs) { ... }\nvoid Print(List<KeyValuePair<byte, object>> pairs) { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Read-Only Interface Members in C#\nDESCRIPTION: This code snippet outlines the essential members found within the read-only interfaces `IEnumerable<T>`, `IReadOnlyCollection<T>`, and `IReadOnlyList<T>`. It showcases the core functionality required for iterating and accessing elements within a read-only sequence, focusing on the `GetEnumerator`, `Count`, and indexer (`this[int index]`) members. This illustrates the minimal API surface these interfaces expose.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n\n{\n    public IEnumerator<T> GetEnumerator(); // and the non-generic equivalent.\n    public int Count { get; }\n    public T this[int index] { get; }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Inference for KeyValuePair<K, V> Collections in C#\nDESCRIPTION: This code snippet illustrates type inference rules for elements when the target type is a KeyValuePair<K, V> collection. It shows how different element types are inferred in various collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nstring x; int y;\nKeyValuePair<string, long> e;\nDictionary<object, int> d;\n...\nPrint([x:y]);         // Print<string, int>\nPrint([e]);           // Print<string, long>\nPrint([..d]);         // Print<object, int>\nPrint([x:y, e, ..d]); // Print<object, long>\n\nvoid Print<K, V>(List<KeyValuePair<K, V>> pairs) { ... }\n```\n\n----------------------------------------\n\nTITLE: Class Inheritance Pattern Matching in C#\nDESCRIPTION: Example demonstrating pattern matching with inheritance hierarchy\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-08.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass B { }\nclass C : B { }\nif (o is (B or C) and var x)\n    // x is `B`\n```\n\n----------------------------------------\n\nTITLE: Creating ImmutableArray<T> Using Array as Storage in C#\nDESCRIPTION: This method creates an ImmutableArray<T> by accepting an array and using it as the underlying storage. It aims to optimize memory allocation by directly utilizing the passed array, effectively avoiding additional allocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-04-05.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Create ImmutableArray<T> using the array as the underlying storage.\npublic static ImmutableArray<T> AsImmutableArray<T>(T[] array)\n{\n    // ...\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nT[] __array = new T[e.Count + 2];\n\nint __i = 0;\n__array[__i++] = x;\nforeach (T __t in e)\n    __array[__i++] = __t;\n__array[__i++] = y;\n\nImmutableArray<T> result = AsImmutableArray(__array);\n```\n\n----------------------------------------\n\nTITLE: Array Find Method with MaybeNull Return Attribute\nDESCRIPTION: Implementation of Array.Find with [MaybeNull] attribute to indicate possible null return value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-05-15.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Array \n{ \n    // Result can be default(T) if no match is found \n    [return: MaybeNull] \n    public static T Find<T>(T[] array, Predicate<T> match); \n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Examples in C#\nDESCRIPTION: Demonstrates various pattern matching operations, including value matching, type patterns with variable declarations, and property pattern matching against a Point type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Notes.md#2025-04-21_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nobject x = ...;\nif (x is 3) ...\nif (x is string s) ...\nif (x is Point { X is 3, Y is int y }) ...\nif (x is Point(3, int y)) ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Null-Resilient Getters in C#\nDESCRIPTION: Examples of implementing null-resilient getters using the 'field' keyword and MaybeNull attribute. These snippets demonstrate common scenarios for lazy initialization and defaulting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[field: MaybeNull]\npublic string Prop => field ?? GetDefault();\n\n[field: MaybeNull]\npublic List<int> Prop => field ??= new();\n\n[field: MaybeNull]\npublic SomeComponent Prop => LazyInitializer.EnsureInitialized(ref field);\n```\n\n----------------------------------------\n\nTITLE: Interface Invocation and Struct This Escape in C#\nDESCRIPTION: This code demonstrates the implications of 'this' escape rules on interface invocation, particularly when the interface is implemented by a struct. The escapability of 'this' in a struct affects the safety of returning refs from generic methods constrained to interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    ref int Get();\n}\n\nref int Use<T>(T p)\n    where T : I1\n{\n    return ref p.Get();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguity in Collection Expression Overload Resolution in C#\nDESCRIPTION: Example code showing a scenario where collection expressions can lead to ambiguity in overload resolution. This demonstrates an ambiguity between ReadOnlySpan<int> and Span<int?> when using an empty collection expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/collection-expressions-better-conversion.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M(ReadOnlySpan<int> ros) { ... }\npublic void M(Span<int?> span) { ... }\n\nM([]); // Ambiguous\n```\n\n----------------------------------------\n\nTITLE: Implementing Specialized Route Builder with Constant Propagation in C#\nDESCRIPTION: This code snippet demonstrates the implementation of a specialized route builder using extension shadowing and constant propagation. It shows how the AOT compiler can optimize the code based on constant expected attributes and caller information.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/interceptors/IC-2023-03-20.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// ASP.NET library\nimplicit extension RouteBuilderExtension for IEndpointRouteBuilder\n{\n    public void MapGet(\n        string route,\n        Delegate handler) { }\n}\n\n// Generated.cs\nimplicit extension SpecializedRouteBuilder : RouteBuilderExtension\n{\n    // produced by the source generator:\n    public void MapGet(\n        string route,\n        Delegate handler,\n        [ConstantExpected] [CallerFilePath] string? filePath = null,\n        [CallerLineNumber] int lineNumber = -1,\n        [CallerCharacterNumber] int characterNumber = -1) // https://github.com/dotnet/csharplang/issues/3992\n    {\n        switch (filePath, lineNumber, characterNumber)\n        {\n            case (\"User.main.cs\", 5, 11): MapProducts(handler);\n            case (\"User.main.cs\", 6, 11): MapUsers(handler);\n            // imagine there are many many more cases than these...\n            default: throw new Exception(\"unknown route\");\n        }\n    }\n    \n    // roughly what the AOT compiler ends up generating:\n    public void MapGet(\n        string route,\n        Delegate handler,\n        [ConstantExpected] [CallerFilePath] string? filePath = null,\n        [CallerLineNumber] int lineNumber = -1,\n        [CallerCharacterNumber] int characterNumber = -1) // https://github.com/dotnet/csharplang/issues/3992\n    {\n        switch (filePath, lineNumber, characterNumber)\n        {\n            // The path which adds a handler for 'Products' is unreachable, so it is elided here.\n            case (\"User.main.cs\", 6, 11): MapUsers(handler);\n            // imagine there are many many more cases than these...\n            default: throw new Exception(\"unknown route\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Record Class in C# with Automatic Value Semantics Generation\nDESCRIPTION: This snippet demonstrates the proposed 'record' feature in C#, which would automatically generate value semantics for a class. It shows basic syntax and how to customize default behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nclass Point(int X, int Y);\n\nclass Point(int X, int Y)\n{\n    public int X { get; set; } = X;\n}\n\nclass Point(int x:X, int y:Y)\n{\n    public int X { get; set; } = x;\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference with var? Declaration\nDESCRIPTION: Shows type inference for local variables declared with var? keyword. The inferred type is independent of the null state of the initializing expression and always results in a nullable type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar? x = E;\n```\n\n----------------------------------------\n\nTITLE: Declaring Ref Readonly Method in C#\nDESCRIPTION: Demonstrates the syntax for declaring a method with ref readonly parameters and return type. This allows passing and returning references without the risk of modification by the recipient.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-22.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic ref readonly int Choose(ref readonly int i1, ref readonly int i2) { ... }\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Virtual Interface Members Syntax Example\nDESCRIPTION: Example showing the explicit implementation syntax for interface operators where IMyInterface prefix is placed before the operator keyword\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-06.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nIMyInterface.operator\n```\n\n----------------------------------------\n\nTITLE: Declaring Implicit Extension Types in C#\nDESCRIPTION: This snippet demonstrates the current interim syntax for declaring implicit extension types in C#. The syntax requires specifying the underlying type, as well as any base extensions and interfaces. This approach aims to streamline the declaration and use of extension types in C# projects.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-17.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension Extension for UnderlyingType : BaseExtension, Interface { }\n```\n\n----------------------------------------\n\nTITLE: Using 'scoped' Keyword for Local Scope Span in C#\nDESCRIPTION: This example shows how the 'scoped' keyword could be used to explicitly request local scope for a Span<int> created with a collection expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nvoid M()\n{\n    // 's' has 'local scope'\n    scoped Span<int> s = [x, y, z];\n    foreach (var v in s)\n        Console.WriteLine(v);\n}\n```\n\n----------------------------------------\n\nTITLE: Static Lambda with Static Member Access\nDESCRIPTION: Example showing how static anonymous functions can access static members from the enclosing scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/static-anonymous-functions.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic (int x) => x * MyClass.StaticValue;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating UnscopedRef Implementation Logic for Structs\nDESCRIPTION: This code example visualizes the 'this' parameter as an explicit argument in a struct method, helping to explain the rationale behind UnscopedRef rules for interface implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S\n{\n    public void M(scoped ref S this) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Deconstructor Method Example\nDESCRIPTION: Demonstrates a potential implementation of a deconstructor method returning tuple values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\npublic (string firstName, string lastName) GetValues() { ... }\n```\n\n----------------------------------------\n\nTITLE: Potential Issue with Asynchronous Operations and Span<T> in C#\nDESCRIPTION: This code demonstrates a problem with Span<T> in asynchronous contexts, where lifting GetSpan() to a local variable wouldn't work due to the ref-like nature of Span<T> that prevents it from being captured across await points.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-01.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nM(await X, GetSpan());\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parameter Null Checking Syntax in C#\nDESCRIPTION: Example of the accepted parameter null checking syntax using double exclamation marks (!!), which enforces that the parameter cannot be null at runtime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-24.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M(Chitty chitty!!)\n```\n\n----------------------------------------\n\nTITLE: Extension Overriding Base Type Member\nDESCRIPTION: This snippet illustrates an extension defined for the 'string' type that overrides the 'Length' property. It also includes a method that demonstrates the shadowing of the base type member 'Length', highlighting the potential confusion it can cause, as it accesses the base member instead of the extension member.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-09-30.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nextension E for string\n{\n    public int Length => 10;\n\n    public void M()\n    {\n        Console.WriteLine(this.Length); // This calls `string.Length`, not `E.Length`\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Data Property Syntax to Explicit Property Declaration in C#\nDESCRIPTION: Demonstrates the syntactic difference between the proposed data property shorthand and its equivalent explicit property declaration. The data property provides a more concise syntax for declaring a property with get and init accessors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-22.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ndata int X;\n\n// versus\n\npublic int X { get; init; }\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression Ambiguity in C#\nDESCRIPTION: Illustrates ambiguity between collection literals in conditional expressions and null conditional operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_21\n\nLANGUAGE: c#\nCODE:\n```\nM(x ? [a, b, c] : [d, e, f]);\n\nM(x ? [a, b, c]);\n```\n\n----------------------------------------\n\nTITLE: Implementing Initialized Flag Pattern in C#\nDESCRIPTION: An alternative approach using an initialized flag to control property setter behavior during and after initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/fieldof.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    private readonly bool _initialized;\n\n    public C(string prop)\n    {\n        Prop = prop;\n        _initialized = true;\n    }\n\n    public string Prop\n    {\n        get => field;\n        set\n        {\n            if (!_initialized)\n            {\n                field = value;\n                return;\n            }\n\n            if (value != field)\n            {\n                field = value;\n                OnPropertyChanged();\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LogDictionary Extension Method with params ReadOnlySpan<T> in C#\nDESCRIPTION: Example of an extension method using params ReadOnlySpan<T> to log the contents of a dictionary.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void LogDictionary<K, V>(this Logger log, Dictionary<K, V> dictionary)\n{\n    log.Log(\"Dictionary\");\n\n    foreach (var (k, v) in dictionary)\n        log.Log(\"{0}, {1}\", k, v);\n\n    log.Log(\"Count = {0}\", dictionary.Count);\n}\n```\n\n----------------------------------------\n\nTITLE: Prefix Increment/Decrement Operator Examples with Value Types\nDESCRIPTION: Examples of prefix increment operations with value types, showing different scenarios and their behavior with struct types including property operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar a = ++(new S()); // error: not a variable\nvar b = ++S.P2; // var temp = S.op_Increment(S.get_P2()); S.set_P2(temp); b = temp;\n++S.P2; // var temp = S.op_Increment(S.get_P2()); S.set_P2(temp);\n++b; // b.op_Increment(); \nvar d = ++S.P1; // error: set is missing\n++S.P1; // error: set is missing\nvar e = ++b; // var temp = b; temp.op_Increment(); e = (b = temp); \n\nstruct S\n{\n    public static S P1 { get; } = new S();\n    public static S P2 { get; set; } = new S();\n\n    public static S operator ++(S x) => ...;\n    public void operator ++() => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Approach B2: Flow Analysis Example (C#)\nDESCRIPTION: Illustrates the approach of performing flow analysis between constructors and accessors. This involves re-thinking the backing field as a nullable local field and analyzing constructor statements with calls to the accessors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n\"T Prop { get => ...field...; set => ...field... } = optional_initializer;\\n\\npublic C()\\n{\\n    // ... constructor statements ...\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Object Modification with 'with' Expression in C#\nDESCRIPTION: Example showing proposed syntax for creating modified copies of immutable objects using a 'with' expression to change specific properties while copying others.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar newIfStatement = ifStatement with { Condition = newCondition, Statement = newStatement };\n```\n\n----------------------------------------\n\nTITLE: Null State Changes with Collections\nDESCRIPTION: Example demonstrating how the null-forgiving operator affects null state and warning suppression with nested collection types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-03-21.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(string? ns, List<string?>? ln)\n{\n    // I happen to know that if ln is not null, it doesn't contain nulls\n    List<string>? l = ln!; \n    _ = l.Count; // warning?\n}\n```\n\n----------------------------------------\n\nTITLE: Using MemberNotNullAttribute with Required Members\nDESCRIPTION: Implementation reference for using MemberNotNullAttribute to inform nullability error suppression for fields initialized by required properties in C# 11.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-11-30.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMemberNotNullAttribute\n```\n\n----------------------------------------\n\nTITLE: Fixing a Span in Memory with Raw Pointer Access in C#\nDESCRIPTION: This code illustrates a potential syntax for locking a Span in memory to get a raw pointer for operations that might require one. This is shown as a discussion point around Memory<T> and preventing freeing while a Span is in use.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-01.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nSpan<byte> b = ...;\nfixed(byte* p = &b.GetRawPointer())\n```\n\n----------------------------------------\n\nTITLE: Alternative Interface Implementation Syntax Proposal in C#\nDESCRIPTION: Proposed alternative syntax showing separate declaration and implementation in interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-14.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1\n{\n    int M(int i, bool b, string s); // declares the member\n \tint I1.M(int i, bool b, string s) => s?.Length ?? i; // provides a default implementation\n}\n\ninterface I2 : I1\n{\n    int I1.M(int i, bool b, string s) => b ? i : s?.Length ?? 0; // no change\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Record With-er Example in C#\nDESCRIPTION: Demonstrates the basic syntax for using the proposed With-er feature with a Point record class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-29.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic data class Point(int X, int Y);\nvar p2 = p1 with { Y = 2 };\n```\n\n----------------------------------------\n\nTITLE: Nested Member With-Expression Syntax Proposals in C#\nDESCRIPTION: Proposed syntax alternatives for nested member initialization using with expressions, showing different approaches to property modification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-09-22.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nmethodCallExpression with { Method with { Name = \"MethodName\", BaseType = \"C\" } }\nmethodCallExpression with { Method = { Name = \"MethodName\", BaseType = \"C\" } } // more similar to nested object initializer?\n```\n\n----------------------------------------\n\nTITLE: Implementing WithCancellation Extension Methods for IAsyncEnumerable in C#\nDESCRIPTION: Demonstrates two potential implementations of WithCancellation extension methods for IAsyncEnumerable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-18.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static class AsyncEnumerable\n{\n\tclass AsyncEnumerableWithCancellation<T> : IAsyncEnumerable<T>{ ... }\n\tpublic static IAsyncEnumerable<T> WithCancellation<T>(this IAsyncEnumerable<T> enumerable, CancellationToken token)\n\t  => new IAsyncEnumerableWithCancellation<T>(enumerable, token);\n\n\t// Or\n\tpublic static IAsyncEnumerator<T> WithCancellation<T>(this IAsyncEnumerable<T> enumerable, CancellationToken token)\n\t  => enumerable.GetEnumerator(token);\n}\n```\n\n----------------------------------------\n\nTITLE: LINQ Query Expression with Null Filtering\nDESCRIPTION: Example demonstrating how LINQ query expressions could potentially handle null filtering to produce non-null element types in the result.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-11-27.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar query =\n    from s in nullableStrings\n    where s != null\n    select s;\n```\n\n----------------------------------------\n\nTITLE: Property Change Notification Using field Keyword in C#\nDESCRIPTION: Example showing property implementation with PropertyChanged notification using the proposed field keyword for accessing the backing field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-01.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic int P\n{\n    get => field;\n    set\n    {\n        PropertyChanged();\n        field = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Dictionary with KeyValuePairs - C#\nDESCRIPTION: This code snippet demonstrates how to initialize a dictionary using KeyValuePair elements. It showcases the creation of a Dictionary object and collection casting, allowing for the addition of KeyValuePairs directly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar dictionary = new Dictionary<string, int>();\nvar collection = (ICollection<KeyValuePair<string, int>>)dictionary;\ncollection.Add(new KeyValuePair<string, int>(\"mads\", 21));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Self-Applicability Constraints in C# Interface Static Methods\nDESCRIPTION: Example showing how abstract static members in interfaces affect type parameter constraints, where an interface with abstract static members cannot satisfy its own constraint.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-02-08.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IHasStatics\n{\n    abstract static int GetValue(); // No implementation of GetValue here\n}\n\nclass C : IHasStatics\n{\n    static int GetValue() => 0;\n}\n\nvoid UseStatics<T>() where T : IHasStatics\n{\n    int v = T.GetValue();\n}\n\nUseStatics<C>();           // C satisfies constraint\nUseStatics<IHasStatics>(); // Error: IHasStatics doesn't satisfy constraint\n```\n\n----------------------------------------\n\nTITLE: Base Call Syntax Options for Interface Implementation in C#\nDESCRIPTION: Various syntax proposals for implementing base calls in interface implementations, demonstrating different approaches to method resolution and type specification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-14.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace N {\n    interface I1<T> { int M(string s) => s.Length; }\n}\nclass C : I1<T>\n{\n    int I1.M(string s)\n    {\n        // Options:\n        base<N.I1<T>>.M(s);\n        base(N.I1<T>).M(s);\n        N.I1<T>.base.M(2);\n        base{N.I1<T>}\n        base:N.I1<T>.M(s);\n        base!N.I1<T>.M(s);\n        base@N.I1<T>.M(s);\n        base::global::N.I1<T>.M(s);\n        base.(N.I1<T>).M(s);\n        (base as N.I1).M(s); // base isn't an expression, so this isn't legal today\n        ((N.I1)base).M(s); // same here\n        base.N.I1.M(s);  // clash with a member on base, doesn't allow for qualified name\n        N.I1.M(s); // this is currently a static call on I1, can't work\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Complexity of Static Virtual Members in C# Interfaces\nDESCRIPTION: This code snippet illustrates the complexity of implementing static virtual members in interfaces, specifically the challenge of passing along type information for method invocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-02-24.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I\n{\n    virtual static void I1() { I2(); }\n    abstract static I2();\n}\n\nclass C : I\n{\n    public static void I2() {}\n}\n\nC.I1();\n// How does the runtime pass along the information that the type here is C,\n// and I.M1() should invoke C.I2()?\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Switch Expression\nDESCRIPTION: Grammar rules defining the syntax for switch expressions in C#, including arms and case guards.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_7\n\nLANGUAGE: antlr\nCODE:\n```\nmultiplicative_expression\n    : switch_expression\n    | multiplicative_expression '*' switch_expression\n    | multiplicative_expression '/' switch_expression\n    | multiplicative_expression '%' switch_expression\n    ;\nswitch_expression\n    : range_expression 'switch' '{' '}'\n    | range_expression 'switch' '{' switch_expression_arms ','? '}'\n    ;\nswitch_expression_arms\n    : switch_expression_arm\n    | switch_expression_arms ',' switch_expression_arm\n    ;\nswitch_expression_arm\n    : pattern case_guard? '=>' expression\n    ;\ncase_guard\n    : 'when' null_coalescing_expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Explicit Global Scope for Span with Collection Expression in C#\nDESCRIPTION: This snippet demonstrates how to explicitly create a Span<int> with global scope using collection expressions, either by casting to an array or using the new keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> M()\n{\n    // Either:\n    Span<int> s1 = (int[])[x, y, z];\n    Span<int> s1 = new[] { x, y, z };\n    \n    return x ? s1 : s2;\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Qualified Alias Member Resolution Algorithm in C#\nDESCRIPTION: This text explains changes made to the algorithm for resolving a 'qualified_alias_member,' which affects how certain references are evaluated. It includes criteria for undefined references based on the presence of different types of using directives and alias associations, and it outlines potential compile-time errors that can occur due to ambiguities with namespace and type associations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/GlobalUsingDirective.md#2025-04-21_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n*  Otherwise, starting with the namespace declaration ([Â§14.3](https://github.com/dotnet/csharpstandard/blob/draft-v8/standard/namespaces.md#143-namespace-declarations)) immediately containing the *qualified_alias_member* (if any), continuing with each enclosing namespace declaration (if any), and ending with the compilation unit containing the *qualified_alias_member*, the following steps are evaluated until an entity is located:\n\n   * If the namespace declaration or compilation unit contains a *using_alias_directive* that associates `N` with a type, **or, when a compilation unit is reached, the program contains a *global_using_alias_directive* that associates `N` with a type,** then the *qualified_alias_member* is undefined and a compile-time error occurs.\n   * Otherwise, if the namespace declaration or compilation unit contains an *extern_alias_directive* or *using_alias_directive* that associates `N` with a namespace, ***or, when a compilation unit is reached, the program contains a *global_using_directive* that associates `N` with a namespace,** then:\n     * If the namespace associated with `N` contains a namespace named `I` and `K` is zero, then the *qualified_alias_member* refers to that namespace.\n     * Otherwise, if the namespace associated with `N` contains a non-generic type named `I` and `K` is zero, then the *qualified_alias_member* refers to that type.\n     * Otherwise, if the namespace associated with `N` contains a type named `I` that has `K` type parameters, then the *qualified_alias_member* refers to that type constructed with the given type arguments.\n     * Otherwise, the *qualified_alias_member* is undefined and a compile-time error occurs.\n```\n\n----------------------------------------\n\nTITLE: Handling Nullable Reference Types with Class Constraints\nDESCRIPTION: Example showing warning behavior when passing nullable reference types to generic methods with class constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstatic void F<T>(T t) where T : class { t.ToString(); /* no warning */ }\nF(maybeNull); // warning: string? does not satisfy 'class' constraint\nF<string?>(string.Empty); // warning: string? does not satisfy 'class' constraint\n```\n\n----------------------------------------\n\nTITLE: Readonly Field Behavior with 'field' Keyword in C#\nDESCRIPTION: Examples showing when a synthesized backing field should be considered read-only, demonstrating valid and invalid operations in different readonly contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S\n{\n    readonly object P0 { get => field; } = \"\";         // ok\n    object P1          { get => field ??= \"\"; }        // ok\n    readonly object P2 { get => field ??= \"\"; }        // error: 'field' is readonly\n    readonly object P3 { get; set { _ = field; } }     // ok\n    readonly object P4 { get; set { field = value; } } // error: 'field' is readonly\n}\n```\n\n----------------------------------------\n\nTITLE: Warning for Non-Nullable Backing Field Assignment\nDESCRIPTION: Shows how the C# compiler warns if a non-nullable backing field is not assigned before the constructor exits, showcasing flow analysis for properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n// this will appropriate warn if the constructor or initializer\n// does not assign to the property as the backing field is `string`\n// and thus must be assigned before the constructors exit.\nstring Prop { get => field; set => field = value.Trim(); }\n```\n\n----------------------------------------\n\nTITLE: Future Implementation for IDictionary<T> in C# 13\nDESCRIPTION: In C# 13, when dictionary support is added, IDictionary<T> will be implemented as a new Dictionary<T>. This provides a mutable dictionary implementation for collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-11.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>();\n```\n\n----------------------------------------\n\nTITLE: Simulating Async Main Method Invocation in C#\nDESCRIPTION: Demonstrates how the runtime would invoke async Main methods as entry points. It uses the GetAwaiter().GetResult() pattern to block and wait for the task to complete.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-28.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nMain(...).GetAwaiter().GetResult();\n```\n\n----------------------------------------\n\nTITLE: Join Usage Examples\nDESCRIPTION: Examples demonstrating the usage of inner, left, and right join operators with method syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nvar query = students.Join(\n    departments,\n    student => s.DepartmentID,\n    department => department.ID,\n    (student, department) => new { student.FirstName, student.LastName, Department = department.Name });\n\nvar query = students.LeftJoin(\n    departments,\n    student => s.DepartmentID,\n    department => department.ID,\n    (student, department) => new { student.FirstName, student.LastName, Department = department?.Name });\n\nvar query = students.RightJoin(\n    departments,\n    student => s.DepartmentID,\n    department => department.ID,\n    (student, department) => new { student?.FirstName, student?.LastName, Department = department.Name });\n```\n\n----------------------------------------\n\nTITLE: Inheritance Without Constructors\nDESCRIPTION: Example showing clean inheritance pattern without constructor boilerplate.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-15.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Person\n{\n    public string Name { get; }\n}\npublic class Student : Person\n{\n    public string ID { get;}\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Reabstraction in Classes for Interface Methods in C#\nDESCRIPTION: This snippet demonstrates how explicit reabstraction of interface methods could be supported in classes, though it was decided not to implement this feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nabstract class E : IA, IB, IC // ok\n{\n    abstract void IA.M();\n}\n```\n\n----------------------------------------\n\nTITLE: Synthesized GetHashCode() Method for Record Struct\nDESCRIPTION: This snippet shows the synthesized `GetHashCode()` method for a record struct. It combines the hash codes of each instance field using `System.Collections.Generic.EqualityComparer<TN>.Default.GetHashCode()`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/record-structs.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n\"public override readonly int GetHashCode();\"\n```\n\n----------------------------------------\n\nTITLE: Silencing Warnings for Default Expressions with Unconstrained Type Parameters in C#\nDESCRIPTION: Demonstrates potential syntax for silencing warnings when using default expressions with unconstrained type parameters. It shows the use of the '!' operator to suppress warnings about creating null values for potentially non-nullable types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-14.md#2025-04-23_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nT t = default(T)!; // if that's allowed, or some version of it\nT t = default!;    // if that's allowed\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Conditional Ref Operations in C#\nDESCRIPTION: Presents an alternative syntax proposal for conditional ref operations without introducing new keywords. This approach treats both branches of the conditional as variables if they are of the same type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-28.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n(a1 != null ? a1[0] : a2[0]) = value; \nref int r = ref (a1 != null ? a1[0] : a2[0]); // Two \"ref\"s\n```\n\n----------------------------------------\n\nTITLE: Create Method Parameter Ordering Example\nDESCRIPTION: Conceptual reference to parameter ordering in interpolated string builders, specifically regarding the Create method parameters and their lexical ordering requirements. This is discussed in the context of maintaining consistent evaluation order.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-21.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nCreate()\n```\n\n----------------------------------------\n\nTITLE: New() Expression and Parameterless Constructors in C#\nDESCRIPTION: This code shows that the `new()` operator invokes the parameterless constructor if it's public; otherwise, it initializes the instance to zero. The behavior depends on the accessibility of the parameterless constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n\"// public struct PublicConstructor { public PublicConstructor() { } }\\n// public struct PrivateConstructor { private PrivateConstructor() { } }\\n\\n_ = new PublicConstructor();  // call PublicConstructor::.ctor()\\n_ = new PrivateConstructor(); // initobj PrivateConstructor\"\n```\n\n----------------------------------------\n\nTITLE: Merged Extension Declaration and Member Syntax\nDESCRIPTION: Alternative syntax showing how to combine extension declaration with individual members, demonstrating both indexer and method examples.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong bits) public bool this[int index]\n    {\n        get => (bits & Mask(index)) != 0;\n        set => bits = value ? bits | Mask(index) : bits & ~Mask(index);\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n \npublic static class Enumerable\n{\n    extension<TSource>(IEnumerable<TSource> source) public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Nested Properties in MethodCallExpression - C#\nDESCRIPTION: This code snippet demonstrates the enhanced syntax for property patterns in C#, allowing direct matching of nested properties in a more concise manner. The goal is to improve readability by reducing the nesting noise typically associated with traditional property pattern syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/extended-property-patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is MethodCallExpression { Method.Name: \"MethodName\" })\n```\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is MethodCallExpression { Method: { Name: \"MethodName\" } })\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dictionary Splat Operations in C#\nDESCRIPTION: Examples showing how collection literals could be used to combine dictionaries through splat operations. These operations would merge dictionaries, potentially with union semantics where later keys could overwrite earlier ones.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-04-26.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[.. dict1, .. dict2]\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[.. dict1, key: value]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating lifetime rules with ref struct in C#\nDESCRIPTION: This example illustrates lifetime rules for ref structs, including constructor definitions and method parameter lifetimes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S<out $this>\n{\n    // Implicitly \n    ref<$this> int Field;\n\n    S<$ro> new<$ro>(ref<$ro> int f)\n    {\n        Field = ref f;\n    }\n}\n\nS<$ro> M2<$ro>(\n    ref<$ro> int i,\n    S<$ro> span1)\n    S<$local> span2)\n{\n    // okay: types match exactly\n    return span1;\n\n    // error: has lifetime $local which has no conversion to $ro\n    return span2;\n\n    // okay: type S<$heap> has a conversion to S<$ro> because $heap has a\n    // conversion to $ro and the first lifetime parameter of S<> is covariant\n    return default(S<$heap>)\n\n    // okay: the ref lifetime of ref $i is $ro so this is just an \n    // identity conversion\n    S<$ro> local = new S<$ro>(ref $i);\n    return local;\n\n    int[] array = new int[42];\n    // okay: S<$heap> is convertible to S<$ro>\n    return new S<$heap>(ref<$heap> array[0]);\n\n    // okay: the parameter of the ctor is $ro ref int and the argument is $heap ref int. These \n    // are convertible.\n    return new S<$ro>(ref<$heap> array[0]);\n\n    // error: has ref lifetime $local which has no conversion to $a hence \n    // it's illegal\n    int local = 42;\n    return ref local;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression Type Inference in C#\nDESCRIPTION: Examples demonstrating how best common type inference should work with null literals and default values in conditional expressions. Shows how the compiler should infer nullable value types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-28.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nb1 ? 1 : b2 ? null : b3 ? 2 : default; // default is 0\nb1 ? 1 : b2 ? default : b3 ? 2 : null; // default is null\n\nb1 ? 1 : (b2 ? null : (b3 ? 2 : default)); // default is 0\nb1 ? 1 : (b2 ? default : (b3 ? 2 : null)); // default is null\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Role Declaration in C#\nDESCRIPTION: This snippet demonstrates defining a role on a function pointer. It highlights the limitations of using attributes to encode function pointer roles, as there's no place to store the attribute on the function pointer type itself.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nrole MyFunctionPointerRole : delegate*<...> { }\n// can't put function pointer in typeof in attribute\n\ndelegate*<MyRole> // nowhere to store attribute\n```\n\n----------------------------------------\n\nTITLE: Equivalent Expanded Property Implementation in C#\nDESCRIPTION: This snippet shows the equivalent code that would be generated by the compiler when processing the auto-implemented property with field-targeted attribute. It demonstrates how the attribute would be applied to the backing field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/auto-prop-field-attrs.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Serializable]\npublic class Foo \n{\n    [NonSerialized]\n    private string _mySecretBackingField;\n    \n    public string MySecret\n    {\n        get { return _mySecretBackingField; }\n        set { _mySecretBackingField = value; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Interpolated String Example - C#\nDESCRIPTION: Example showing potential syntax for conditional interpolation with hypothetical syntax marker discussed but not adopted.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-24.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n$\"{?name}\"\n```\n\n----------------------------------------\n\nTITLE: Nested Ref Struct Context Example in C#\nDESCRIPTION: Illustrates ref-field-safe-context rules for nested ref structs and how they interact with span lifetime tracking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\nref struct Nested\n{\n    ref Span<int> Span;\n}\n\nSpan<int> M(ref Nested nested) => nested.Span;\n```\n\n----------------------------------------\n\nTITLE: Using Struct and Enum Constraints Together in C#\nDESCRIPTION: This snippet shows how to combine the struct and Enum constraints for a generic type parameter. This is allowed as a special case, even though normally only interfaces can be combined with the struct constraint.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-24.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nwhere T : struct, Enum\n```\n\n----------------------------------------\n\nTITLE: Defining Scoped Ref Field in C# Struct\nDESCRIPTION: This snippet shows how a 'scoped ref' field is defined in a struct and mapped to its annotation level representation. It demonstrates the lifetime parameters and their relationships.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S\n{\n    scoped ref int i;\n}\nS M(S p) { }\n\n// maps to \nref struct S<out $this, $refField1>\n{\n    ref<$refField1> int i;\n}\n\nS<$cm> M<$cm, $l1>(S<$cm, $l1> p)\n    where $l1 : $local\n{\n\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Subtle Changes Affecting Generic Interface Constraints\nDESCRIPTION: This example demonstrates how adding a default interface method to a previously constraint-eligible interface can cause breaking changes for consumers using ref structs as type arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1<T>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Params Collection Method Ambiguity in C#\nDESCRIPTION: Code snippet illustrating method overload resolution complexity with params collections, showing how different method signatures can create ambiguous method calls\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-01-29.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nTest([1,2,3]); // error CS0121: The call is ambiguous between the following methods or properties: 'Program.Test(params int[])' and 'Program.Test(params long[])'\nTest(1, 2, 3); // We pick 'static void Test(params int[] x)'\n\npartial class Program\n{\n    static void Test(params int[] x) {}\n    static void Test(params long[] x) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ValueFormattableString in C#\nDESCRIPTION: Demonstrates the implementation of ValueFormattableString struct and its usage in creating efficient interpolated strings. Shows how the compiler translates interpolated strings into ValueFormattableString.Create calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/format.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly struct ValueFormattableString {\n    public static ValueFormattableString Create(Variant v) { ... } \n    public static ValueFormattableString Create(string s) { ... } \n    public static ValueFormattableString Create(string s, params ReadOnlySpan<Variant> collection) { ... } \n}\n\nclass ConsoleEx { \n    static void Write(ValueFormattableString f) { ... }\n}\n\nclass Program { \n    static void Main() { \n        ConsoleEx.Write(42);\n        ConsoleEx.Write($\"hello {DateTime.UtcNow}\");\n\n        // Translates into \n        ConsoleEx.Write(ValueFormattableString.Create((Variant)42));\n        ConsoleEx.Write(ValueFormattableString.Create(\n            \"hello {0}\", \n            new Variant(DateTime.UtcNow)));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative to readonly field initialization using init-only properties in C#\nDESCRIPTION: Example showing how init-only properties with private init accessors can provide similar functionality to readonly fields that can be initialized in object initializers, without requiring a new language feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-15.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    public string? ReadonlyProp { get; private init; }\n\n    public static C Create()\n        => new C() { ReadonlyProp = null; };\n}\n```\n\n----------------------------------------\n\nTITLE: Span Implementation with Shallow Readonly Semantics\nDESCRIPTION: Shows how the Span<T> pattern depends on readonly being shallow for ref fields, allowing indexers to return references to data through readonly ref struct instances.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_60\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly ref struct SpanOfOne\n{\n    readonly ref int Field;\n\n    public ref int this[int index]\n    {\n        get\n        {\n            if (index != 1)\n                throw new Exception();\n            return ref Field;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Delegate Capture Behavior with Method Calls (C#)\nDESCRIPTION: This code snippet compares two different approaches to passing delegates and references, demonstrating how the order of execution can affect nullable flow analysis. It highlights the challenges in accurately tracking nullability across method boundaries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-04.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvoid M1(Action, ref string s);\nM1(() => y = x, ref y);\n\nvoid M2(ref string s, Action);\nM2(ref y, () => y = x);\n```\n\n----------------------------------------\n\nTITLE: Multiple Definitions in Case Blocks for C#\nDESCRIPTION: Illustrates a potential syntax for allowing multiple definitions of the same variable in different cases of a switch statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n    case (0, int x):\n    case (int x, 0):\n        Console.WriteLine(x);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullability Safety Hole with Manual Attributes in C#\nDESCRIPTION: Shows how manual nullability attributes can create a safety hole where removing null-handling code doesn't trigger warnings, potentially leading to runtime errors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    [AllowNull]\n    private string resetIfSetToDefault;\n\n    public string ResetIfSetToDefault\n    {\n        // Removed `?? GetDefault()` without warnings!\n        get => resetIfSetToDefault; \n        set => resetIfSetToDefault = value == GetDefault() ? null : value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: As-Operator to Invoke Extension Methods in C#\nDESCRIPTION: Showcases how the 'as' operator can be utilized to invoke static and instance extension methods. This pattern provides error-safe execution by facilitating null-reference checking scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = (IEnumerable<int> as MyExtensions).Range(0, 10);\nvar empty = (IEnumerable<int> as MyExtensions).Empty;\n(range as MyExtensions) += 5;\nReadOnlySpan<int> span = range as MyExtensions;\n\n// Instance extension members\nvar query = (range as MyExtensions).Where(i => i < 10);\nvar isEmpty = (query as MyExtensions).IsEmpty;\nvar first = (query as MyExtensions)[0];\nvar repetition = new (IEnumerable<int> as MyExtensions)(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Class Implementation of Non-Virtual Interface Members\nDESCRIPTION: Demonstrates potential issues with implementing non-virtual interface members in a class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-05.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nclass C : I1\n{\n    public void M2() { ... } // Doesn't implement I1.M2, which isn't virtual!\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Method Syntax in C#\nDESCRIPTION: Example showing potential syntax conflict between instance and static methods in extension types. Demonstrates the ambiguity between E.M(instance) and instance.M() calling patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-26.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic void M(this int i)\n```\n\n----------------------------------------\n\nTITLE: Nullability State After Conditional Access on Non-nullable String in C#\nDESCRIPTION: A simple example showing how the conditional access operator affects the nullability state of a non-nullable string variable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstring x = \"\";\nx?.ToString(); // warning?\n```\n\n----------------------------------------\n\nTITLE: Example of Cross-Body Nullability Analysis Issue in C#\nDESCRIPTION: Demonstrates a limitation in cross-body nullability analysis where conditional initialization in a setter would still trigger a warning in the constructor despite apparent initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    // With cross-body analysis, this still warns!\n    // CS8618: Non-nullable property 'Prop' must contain a non-null value when exiting constructor\n    public C() { Prop = \"...\"; }\n\n    public string Prop\n    {\n        get;\n        set { if (condition) field = value; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ReadOnlySpan of char with Collection Literal\nDESCRIPTION: This code illustrates the use of a collection literal to initialize a ReadOnlySpan<char>. The C# compiler treats it similarly to the array syntax, optimizing storage and pointing directly to the data segment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static ReadOnlySpan<char> s_chars = ['a', 'b', 'c'];\n```\n\n----------------------------------------\n\nTITLE: String Interpolation with Potential Custom Interpolators in C#\nDESCRIPTION: Examples of how the chosen $ prefix syntax could be extended in the future to support custom interpolators for specific formatting needs like localization or SQL safety.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-21.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nLOC$\"Hello, {name}, you have {amount} donut\\{s\\} left.\"\nSQL$\"â€¦\"\nURI$\"â€¦\"\n```\n\n----------------------------------------\n\nTITLE: Defining IAsyncEnumerator Interface in C#\nDESCRIPTION: Shows a potential interface definition for IAsyncEnumerator with covariant type parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-18.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IAsyncEnumerator<out T>\n{\n\tTask<bool> MoveNextAsync();\n\tT Current { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Invalid Span Example with Local Variable Reference\nDESCRIPTION: Code demonstrating a compatibility gap in C# 7.2 span safety rules that doesn't account for constructors that capture references to stack variables through ref parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_29\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> CreateSpanOfInt()\n{\n    // This is legal according to the 7.2 span rules because they do not account\n    // for a constructor in the form Span(ref T value) existing. \n    int local = 42;\n    return new Span<int>(ref local);\n}\n```\n\n----------------------------------------\n\nTITLE: Anonymous Method Discard Parameters in C#\nDESCRIPTION: Example of using discard parameters (_) in anonymous method declarations. The discard parameters indicate unused method parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/lambda-discard-parameters.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ndelegate(int _, int _) { return 0; }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Ref Choice Method in C#\nDESCRIPTION: A typical workaround method that returns a reference to one of two variables based on a condition. All arguments are evaluated at the call site, which can lead to unintuitive behavior and bugs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nref T Choice(bool condition, ref T consequence, ref T alternative)\n{\n    if (condition)\n    {\n         return ref consequence;\n    }\n    else\n    {\n         return ref alternative;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Analysis in Unreachable Code in C#\nDESCRIPTION: Example showing a case where nullability warnings might be generated in code that is technically unreachable due to a boolean condition that always evaluates to true.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-06.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic void M(bool b, string s)\n{\n    var t = (b || true) ? s : null;\n    t.ToString(); // warning?\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Tuple Comparison with Conversions\nDESCRIPTION: Example demonstrating the evaluation order when comparing tuples with conversions and method calls, showing how expressions are evaluated left-to-right before element-wise comparisons.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/tuple-equality.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Warning Types in C#\nDESCRIPTION: Examples showing three distinct kinds of nullable warnings: direct dereference, indirect dereference, and null conversion to not-nullable type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-07.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstring s = ...;\nstring? n = ...;\n\nvar l = n.Length; // Warning 1: Direct dereference\ns = n;            // Warning 2: Indirect dereference\ns = null;         // Warning 3: null conversion\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation Using Ref Ternary\nDESCRIPTION: Example showing the correct implementation of conditional ref expression that safely handles null array conditions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/conditional-ref.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nref var r = ref (arr != null ? ref arr[0]: ref otherArr[0]);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Interface Implementation with Nullability Mismatch\nDESCRIPTION: Demonstrates an incorrect implementation where nullability annotations don't match between interface and implementing class, which would result in a compilation error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-10.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass C : I1<C?>\n{\n    void I1<C>.M<X>() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Interface Hierarchy in C#\nDESCRIPTION: Demonstrates the inheritance hierarchy pattern using interfaces and concrete implementations for Roslyn symbol types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic interface ISymbol { ... }\npublic interface ILocalSymbol : ISymbol { ... }\n\npublic abstract class CSharpSymbol : ISymbol { ... }\npublic class CSharpLocalSymbol : CSharpSymbol, ILocalSymbol { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Extensions with Grouping Syntax in C#\nDESCRIPTION: This C# code snippet demonstrates a proposed syntax for creating extensions with a grouping mechanism. It is a conceptual proposal showcasing how extensions for IEnumerable<T> and IList<T> could be defined within a single extension statement. No specific dependencies are required to understand the syntax. The snippet raises questions about type parameter scoping and whether it matches the expected metadata structure in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-14.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nextension E\n{\n    for IEnumerable<T> where T\n    {\n        public void M1() { ... }\n    }\n\n    for IList<T> where T\n    {\n        public void M2() { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Native Integer Operator Compatibility in C#\nDESCRIPTION: This code snippet shows how native integer operators are available in C# 9 but not in earlier versions. It demonstrates the use of predefined conversions as a workaround.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class A\n{\n    public static nint F;\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\nclass B : A\n{\n    static void Main()\n    {\n        F = F + 1; // error: nint operator+ not available with -langversion:8\n        F = (System.IntPtr)F + 1; // ok\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Approach A1: Backing Field Same Type as Property (C#)\nDESCRIPTION: Demonstrates the simplest approach where the backing field has the same type as the property. This approach avoids new rules but can lead to uninitialized field warnings, requiring user intervention.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n\"T Prop { ...field... }\\n\\n// Would be the same as\\nT _field;\\nT Prop { ..._field... }\"\n```\n\n----------------------------------------\n\nTITLE: Using Tuple Equality with Regular Tuples\nDESCRIPTION: Example demonstrating how tuple equality expressions are evaluated element-wise for regular tuples, converting to a series of equality checks combined with logical AND operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/tuple-equality.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n(int, (int, int)) t1, t2;\nt1 == (1, (2, 3))\n```\n\n----------------------------------------\n\nTITLE: WPF Dependency Property Registration\nDESCRIPTION: Registration of a WPF dependency property using nameof to specify the property name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic static DependencyProperty AgeProperty = DependencyProperty.Register(nameof(Age), typeof(int), typeof(C));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguity in Interface Method Overrides in C#\nDESCRIPTION: This snippet shows a scenario where an interface implements two other interfaces with the same method name. The conclusion was that this is allowed, but doesn't introduce a new member, resulting in an ambiguous call.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-17.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M1(); }\n\ninterface I2 { void M1() { ... } }\n\ninterface I3 : I1, I2 { override void M1() { ... } }\n\nI3 x;\nx.M1();\n```\n\n----------------------------------------\n\nTITLE: Approach B2: No Constructor Update Required (C#)\nDESCRIPTION: Illustrates an idiomatic case where the NRT analysis will automatically account for the getter returning a non-null value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\n\"string Prop { get => field ?? \\\"\\\"; private set; } // or\\nstring Prop { get => field ??= ComputeInitialValue(); }\"\n```\n\n----------------------------------------\n\nTITLE: Simplified Constructor Syntax with Key Members\nDESCRIPTION: Proposed simplified syntax using key modifier and implicit constructor initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-15.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point\n{\n    public key int X { get; }\n    public key int Y { get; }\n    public Point(X, Y); // name matching and type absence implies initialization\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Operator Prototype in C#\nDESCRIPTION: This code snippet demonstrates how an extension operator would be represented within an extension container. The `static` modifier is included in the prototype, since it would be present in source code. In this case, the `+` operator is being overloaded.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Extension-API-docs.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nextension<T>(IEnumerable<T>)\n{\n    public static IEnumerable<T> operator + (IEnumerable<T> left, IEnumerable<T> right);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Base Call Semantics in Interface Implementations\nDESCRIPTION: This example shows how base() calls would work in interface default implementations. It demonstrates potential ambiguity when there are multiple inheritance paths, highlighting why special semantics are needed for interface base calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-25.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ninterface IA\n{\n    void M();\n}\ninterface IB : IA\n{\n    void IA.M() // If this gets removed, the IC.M call will fail\n    {\n        base(IA).M();\n    }\n}\ninterface IC : IB\n{\n    void IA.M() => base(IB).M();\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Type Inference Options in C# 10\nDESCRIPTION: Code demonstrates potential syntax for opt-in natural type inference for lambdas, showing the (_) cast approach as one possible solution. This is discussed in the context of breaking changes and implementation complexity.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-21.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n(_)\n```\n\n----------------------------------------\n\nTITLE: List<T> Optimization Example\nDESCRIPTION: This C# code snippet illustrates how `List<T>` creation could be optimized away by the compiler if a different backing storage performs better and the difference is not observable. In this example, no actual `List<T>` instance would be created; instead, the code would be lowered to use `stackalloc` or a similar mechanism.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-05-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nList<int> list = new List<int> { 1, 2 };\nforeach (var item in list) // Only usage of 'list'\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Member Resolution in C# - DoesNotReturn\nDESCRIPTION: Code reference showing GitHub issue link for DoesNotReturn attribute discussion. The context indicates this is about method return behavior analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-10-13.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://github.com/dotnet/csharplang/issues/5231\n```\n\n----------------------------------------\n\nTITLE: UnscopedRef for Non-Ref Struct Parameters\nDESCRIPTION: Shows how [UnscopedRef] is useful when working with non-ref struct types, allowing ref fields to reference parameters across method boundaries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_57\n\nLANGUAGE: csharp\nCODE:\n```\nint x = 1;\nF(ref x).RefField = 2;\nConsole.WriteLine(x); // prints 2\n\nstatic S F([UnscopedRef] ref int x)\n{\n    S local = new();\n    local.M(ref x);\n    return local;\n}\n\nref struct S\n{\n    public ref int RefField;\n\n    public void M([UnscopedRef] ref int data)\n    {\n        RefField = ref data;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit operator for Collection Expression in C#\nDESCRIPTION: Discusses the potential for using implicit conversion operators to make types constructible with collection expressions. The example suggests that if a type has a `public static implicit operator ThisType(T[] array)` conversion, it could be constructed using a collection expression. It also mentions breaking changes related to overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2024-01-23.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nFor example, we might say that if a type has a `public static implicit operator ThisType(T[] array)` conversion operator, that it would then be constructible with a collection expression.\n```\n\n----------------------------------------\n\nTITLE: Static Class Access Restrictions\nDESCRIPTION: Shows the access modifier restrictions for static classes, illustrating that private protected cannot be used in static class members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/private-protected.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic class StaticClass {\n    public static int field1;     // Allowed\n    private static int field2;    // Allowed\n    internal static int field3;   // Allowed\n    // private protected static int field4;  // Not allowed in static classes\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Union with Extension API in C#\nDESCRIPTION: Shows how to create a custom union type with a different internal API and provide the expected union pattern through extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\n[Union]\npublic struct U\n{\n    public bool IsA { get; }\n    public void GetA(out int x, out string y);\n    public bool IsB { get; }\n    public void GetB(out int z);\n}\n\npublic implicit extension UX for U \n{\n    public record struct A(int x, int y);\n    public record struct B(int z);\n\n    public bool TryGetA(out A a) { ... }\n    public bool TryGetB(out B b) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguity in Dictionary Collection Literals in C#\nDESCRIPTION: Example showing how collection literals could create ambiguous syntax when using nested expressions. This snippet illustrates a potential parsing ambiguity with nested collection literals inside a conditional expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-06-05.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<K, V> d = [a ? [b] : c]; // [a ? ([b]) : c)] or [(a ? [b]) : c]?\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Container Syntax in ANTLR\nDESCRIPTION: ANTLR grammar rules defining the syntax for declaring extension containers in C#. This includes modifiers, optional generic type parameters, for-clause, and container body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nextension_container_declaration\n    : attributes? extension_container_modifier* 'partial'? 'extensions' identifier type_parameter_list? for_clause? type_parameter_constraints_clause* extension_container_body ';'?\n    ;\n\nextension_container_modifier\n    : 'public'\n    | 'internal'\n    | unsafe_modifier   // unsafe code support\n    ;\n    \nfor_clause\n    : 'for' type\n    ;\n\nextension_container_body\n    : '{' extension-container-member* '}'\n    ;\n\nextension-container-member\n    : extension_member_declaration\n    | class_member_declaration\n    ;\n\nextension_member_declaration\n    : extension_method_declaration\n    | extension_property_declaration\n    ;\n```\n\n----------------------------------------\n\nTITLE: Index Target Type Conversion Example in C#\nDESCRIPTION: Shows how Index expressions are converted when used with Countable types, demonstrating the evaluation order and side effects in member access scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nclass Collection {\n    private int[] _array = new[] { 1, 2, 3 };\n\n    public int Length {\n        get {\n            Console.Write(\"Length \");\n            return _array.Length;\n        }\n    }\n\n    public int GetAt(int index) => _array[index];\n}\n\nclass SideEffect {\n    Collection Get() {\n        Console.Write(\"Get \");\n        return new Collection();\n    }\n\n    void Use() {\n        int i = Get().GetAt(^1);\n        Console.WriteLine(i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Positional and Nominal Record Syntax in C#\nDESCRIPTION: Shows different syntax options for declaring records, including positional and nominal forms with various property declaration styles.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-27.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic record Point(int X, int Y);\npublic record Point\n{\n    public int X { get; init; }\n    public int Y { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lambda with Target-typed new-expression in C#\nDESCRIPTION: Shows how target-typed new-expressions can be used within lambda expressions, potentially affecting overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-25.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nM2(Func<S1> f);\nM2(Func<S2> f);\nM2(() => new () { x = 43 });\n\nS1 Foo() => new () { x = 43 };\n```\n\n----------------------------------------\n\nTITLE: List of KeyValuePair Initialization in C#\nDESCRIPTION: This snippet raises the question of whether a list of `KeyValuePair` objects can be initialized using the dictionary literal syntax. This highlights the potential extension of the dictionary literal syntax to other collection types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_16\n\nLANGUAGE: c#\nCODE:\n```\nList<KeyValuePair<string, int>> pairs = [\"Dustin\": 42, \"Cyrus\": 43]; // Is this ok?  Or would we require you say:\n    \nList<KeyValuePair<string, int>> pairs = [new(\"Dustin\", 42), new(\"Cyrus\", 43)];\n```\n\n----------------------------------------\n\nTITLE: Interceptor Attribute Arguments\nDESCRIPTION: Describes the proposed arguments to the `[InterceptsLocation]` attribute for identifying the location where interception occurs. It utilizes a version number and an opaque data string, which contains a checksum of the file contents, the integer location of the call in the syntax, and the file name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-15.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Corrected Property-Based Implementation in C#\nDESCRIPTION: Improved version using properties instead of captured parameters, ensuring consistent state management between X, Y properties and derived calculations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-03.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n    public double Dist => Math.Sqrt(X * X + Y * Y);\n    public void Move(int dx, int dy)\n    {\n        X += dx; Y += dy;\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Checked User-Defined Operators in C# 11.0\nDESCRIPTION: Demonstrates how to define a checked variant of a user-defined operator, introduced in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic static Int128 operator checked +(Int128 lhs, Int128 rhs) { ... }\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Example with Natural Types Proposal\nDESCRIPTION: Simplified implementation using proposed natural types feature with inline lambda expressions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-03.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Mvc;\n\nvar app = WebApplication.Create(args);\n\napp.MapAction([HttpGet(\"/\")] () => new(Id: 0, Name: \"Play more!\", IsComplete: false));\napp.MapAction([HttpPost(\"/\")] ([FromBody] Todo todo) => todo);\n\nawait app.RunAsync();\n\nrecord Todo(int Id, string Name, bool IsComplete);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref Struct Instance Method Safety Issue in C#\nDESCRIPTION: This code snippet illustrates why instance methods of ref struct types need to be analyzed for lifetime safety. It shows how mismatched lifetimes could create a type safety hole by storing a stackalloc'd Span in a ref struct field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S\n{\n    public Span<int> Span;\n\n    public void Set(Span<int> span)\n    {\n        Span = span;\n    }\n}\n\nvoid Broken(ref S s)\n{\n    Span<int> span = stackalloc int[1];\n\n    // The result of a stackalloc is now stored in s.Span and escaped to the caller\n    // of Broken\n    s.Set(span); \n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversions of Inline Arrays to Span Types in C#\nDESCRIPTION: Illustrates the implicit conversion rules from inline array types to Span<T> and ReadOnlySpan<T>, including ref-safety constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvoid M1(Buffer10<int> x)\n{\n    System.ReadOnlySpan<int> a = x; // Ok, equivalent to `System.ReadOnlySpan<int> a = InlineArrayAsReadOnlySpan<Buffer10<int>, int>(in x, 10)`\n    System.Span<int> b = x; // Ok, equivalent to `System.Span<int> b = InlineArrayAsSpan<Buffer10<int>, int>(ref x, 10)`\n}\n\nvoid M2(in Buffer10<int> x)\n{\n    System.ReadOnlySpan<int> a = x; // Ok, equivalent to `System.ReadOnlySpan<int> a = InlineArrayAsReadOnlySpan<Buffer10<int>, int>(in x, 10)`\n    System.Span<int> b = x; // An error, readonly mismatch\n}\n\nBuffer10<int> GetBuffer() => default;\n\nvoid M3()\n{\n    System.ReadOnlySpan<int> a = GetBuffer(); // An error, ref-safety\n    System.Span<int> b = GetBuffer(); // An error, ref-safety\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Extension Method as Instance Method in C#\nDESCRIPTION: This code snippet shows how to call an extension method as if it were an instance method of the extended type.  In this case, the `IsEmpty()` method is called directly on an instance of `IEnumerable<T>`, as if it were a member of that interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Extension-API-docs.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbool empty = sequence.IsEmpty();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Syntax Ambiguity in C# Collection Literals\nDESCRIPTION: Illustrates a potential syntax ambiguity between dictionary_element and conditional_expression in collection literals. The example shows how a single expression can be interpreted in two different ways.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nvar v = [ a ? [b] : c ];\n```\n\n----------------------------------------\n\nTITLE: C# Function Pointer Calling Conventions\nDESCRIPTION: Shows various calling convention specifications for function pointers including managed, unmanaged, and specific platform conventions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ndelegate* managed<int, int>;\n\ndelegate* unmanaged<int, int>;\n\ndelegate* unmanaged[Cdecl] <int, int>;\n\ndelegate* unmanaged[Stdcall, SuppressGCTransition] <int, int>;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Collection Expression Ambiguity in C#\nDESCRIPTION: Example showing potential ambiguity between collection slicing and range expressions using the '..' operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-09.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar x = [1.., .. b, 3..4]\n```\n\n----------------------------------------\n\nTITLE: Type Pattern Usage Examples in C#\nDESCRIPTION: Demonstrates the proposed type pattern syntax for pattern matching, showing how it can be used in if statements and switch expressions without requiring variable introduction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-11.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(object o1, object o2)\n{\n    var t = (o1, o2);\n    if (t is string) // This is currently legal and we would just change the spec to say that this\n                     // is a type pattern, although the `is` would prefer a type in an ambiguity\n                     // to preserve backwards compatibility\n    if (t is (int, string)) // This would now be legal as a tuple pattern, containing two type patterns\n    switch (t)\n    {\n        case string: // this would now work, but would be the inverse of `is`, preferring a constant\n                     // for backwards compatibility\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Immutable Record Properties with initonly in C#\nDESCRIPTION: Shows how to define immutable properties using the proposed initonly modifier.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class UserInfo\n{\n    public initonly string Username { get; }\n    public initonly string Email { get; }\n    public initonly bool IsAdmin { get; } = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Narrowing with Nullable References in C#\nDESCRIPTION: Shows how a nullable string variable is narrowed to non-nullable type after null check, allowing direct access to string methods without warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-11.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string? n)\n{\n\tif (n == null) return;\n\tvar s = n;        // s is string, not string? \n\tvar l = s.Length; // ok\n\tn = null;         // ok\n\ts = null;         // warning\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring Union Type Unification in C# Generic Methods\nDESCRIPTION: This snippet demonstrates a scenario where union type equivalence affects type inference and unification in generic methods, particularly with conditional expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-10-31.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Type unification between ternary branches\nstatic (T | U) F<T, U>(bool b, T t, U u) => b ? t : u;\nvar x = true ? F(cond1, 1, \"hello\") : F(cond2, \"world\", 2); // type of var? union (int | string) or union(string | int)\n```\n\n----------------------------------------\n\nTITLE: Tracking Nullability through Conditional Ref Expressions in C#\nDESCRIPTION: Code demonstrating the nullability tracking issue when using ref variables with conditional expressions. The example shows how assigning null through a conditional ref expression affects nullability state tracking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring? x = \"\";\nstring? y = \"\";\n(b ? ref x : ref y) = null;\nx.ToString(); // warning?\ny.ToString(); // warning?\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Interpolation Example in C#\nDESCRIPTION: This snippet demonstrates a potentially ambiguous case of interpolation in raw string literals. The interpretation favors the innermost braces forming the interpolation, with outermost ones treated as content.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nvar v1 = $$\"\"\"\n         {{{order_number}}}\n         \"\"\"\n```\n\n----------------------------------------\n\nTITLE: CallerArgumentExpression Parameter Default Values Example\nDESCRIPTION: Demonstrates the behavior of CallerArgumentExpression with default parameter values and generated code scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-14.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M([CallerMemberName]string arg1 = \"1\", [CallerArgumentExpression(\"arg1\")]string arg2 = \"2\")\n{\n    Console.WriteLine(arg2); // What gets printed?\n}\n\nvoid M2()\n{\n    M();\n}\n```\n\n----------------------------------------\n\nTITLE: Flow Analysis Impact on Method Refactoring in C#\nDESCRIPTION: Demonstrates how flow analysis constraints affect method refactoring, particularly when null checks are performed in one method but the information is lost when extracting code to another method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-31.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    string? Prop1 { get; }\n    string? Prop2 { get; }\n}\n\nclass C2\n{\n    void M1(C c)\n    {\n        if (c.Prop1 != null && c.Prop2 != null)\n        {\n            M2(c);\n        }\n    }\n\n    void M2(C c)\n    { \n        // The null checking from M1 is lost here and M2 has to\n        // check again for null to avoid a warning\n        c.Prop1.Equals(...)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Property Declaration Expansion - C#\nDESCRIPTION: Shows how the alternative property declaration syntax would expand into full class implementation with auto-properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-07.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person(string FirstName, string LastName)\n{\n   public string FirstName { get; } = FirstName;\n   public string LastName { get; } = LastName;\n}\n```\n\n----------------------------------------\n\nTITLE: List Pattern Slice with Empty Pattern\nDESCRIPTION: Example demonstrating empty slice pattern behavior in list patterns, which doesn't emit Length checks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-05-26.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n{ .. }        // No Length check emitted\n{ .._ }       // No Slice call emitted\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Optional 'in' Parameters in C#\nDESCRIPTION: Shows how to use optional 'in' parameters with default values, and how they are passed at the call site.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nPrint(\"hello\");      // not an error, same as\nPrint(\"hello\", c: Color.Black);\n\nvoid Print(string s, in Color c = Color.Black)\n{\n    // . . .\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Union Class Variable in C#\nDESCRIPTION: This snippet demonstrates how to declare a nullable union class variable. The '?' after 'U' indicates that the variable 'u' can hold either a value of type 'U' or 'null'. This is a standard way to handle nullability with reference types in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nU? u = null;\n```\n\n----------------------------------------\n\nTITLE: Final Decided Function Pointer Syntax in C#\nDESCRIPTION: The syntax pattern finalized by the language design team for function pointers, using 'delegate*' prefix with optional calling convention and generic-style parameter and return type notation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-30.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n'delegate*' optional_calling_convention '<' type < type , ... > , return_type '>'\n```\n\n----------------------------------------\n\nTITLE: Potential Future CollectionBuilder Attribute Usage for Memory<T> in C#\nDESCRIPTION: This example shows how the CollectionBuilder attribute might be used in the future to support collection expressions for Memory<T> without special-casing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\n[CollectionBuilder(typeof(Memory<>, \"op_Implicit\"))]\npublic readonly struct Memory<T>\n{\n    public static implicit operator Memory<T>(T[]? array) { ... } \n}\n```\n\n----------------------------------------\n\nTITLE: Casting Nullable to Non-nullable Reference Type\nDESCRIPTION: Example demonstrating the current warning behavior when casting from a nullable reference type to a non-nullable type with type checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-06.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nBoundNode? node = ...;\nif (node.Kind == BoundKind.Expression)\n{\n    var x = (BoundExpression)node; // warning if node is nullable\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining Null Checking Operator with LINQ\nDESCRIPTION: Shows how the null checking operator can be chained with method calls, demonstrating its use in more complex expressions while maintaining null safety.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-08-18.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nif (person.Kind == Student) \n{\n  var passed = !person.Courses!.Any(c => c.Grade == F);\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAsyncEnumerable Interface with Cancellation Token in C#\nDESCRIPTION: Shows a potential interface definition for IAsyncEnumerable with a CancellationToken parameter and default implementation for GetEnumerator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-18.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IAsyncEnumerable<out T>\n{\n\tIAsyncEnumerator<T> GetEnumerator(CancellationToken token);\n\tIAsyncEnumerator<T> GetEnumerator() => GetEnumerator(default(CancellationToken)); \n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Expression Variables in Query Clauses (C#)\nDESCRIPTION: Shows an example of using expression variables in LINQ query clauses. The decision was made to scope these variables to individual query clauses, not as range variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-03.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nfrom x in e\nwhere M(x, out var y)\nselect y\n```\n\n----------------------------------------\n\nTITLE: Defining Interface Hierarchy with Default Implementations in C#\nDESCRIPTION: This code snippet demonstrates a hierarchy of interfaces with default implementations, showing how ambiguity can arise when new implementations are added without recompilation of implementing classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-11.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M() { Impl1 } }\ninterface I2 : I1 { override void M() { Impl2 } }\ninterface I3 : I1 { }\nclass C : I2, I3 { }\n```\n\n----------------------------------------\n\nTITLE: Protected Internal and Private Protected Access Rules\nDESCRIPTION: Code example showing the basic member accessibility rules for private protected and protected internal modifiers. The member is accessible within a subclass if that subclass is in the same assembly as the member.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/private-protected.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass BaseClass {\n    private protected int field1;    // Accessible in derived classes within same assembly\n    protected internal int field2;  // Accessible in derived classes and within assembly\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing List with Dictionary Expression in C#\nDESCRIPTION: This snippet demonstrates initializing a List with a dictionary expression using a proposed syntax. It highlights potential issues with accessing list elements when initialized as a Collection of KeyValuePair. The example uses a string-int pair with the key 'mads' and value 21.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-03-11.md#2025-04-21_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nList<KeyValuePair<string, int>> list = [\"mads\": 21];\nConsole.Write(list[\"mads\"]); // Can't consume like this because it's a List\n```\n\n----------------------------------------\n\nTITLE: Capturing 'this' in Lambdas in C#\nDESCRIPTION: Example demonstrating how capturing 'this' in lambda expressions can lead to memory leaks by creating references to the containing instance. The code shows how nested lambdas can create unintended capture chains.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/README.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C {\n    event Action e;\n    void M1() {\n        e += () => {\n            M2(); // Implicitly captures 'this', keeps 'this' alive as long as event handler is alive\n        }\n    }\n    void M2() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Method Conversion Preference in C#\nDESCRIPTION: This code demonstrates the use of extension methods with IEnumerable and attempts to determine which extension method should be preferred based on conversion rules.  The goal is to decide if `IEnumerable<C1>` should be favored over `IEnumerable<object>` when the input is `IEnumerable<C2>` because `C2` inherits from `C1`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nIEnumerable<C2> iEnumerableOfC2 = null;\n_ = iEnumerableOfC2.P; // should we prefer IEnumerable<C1> because it is a better conversion? (parameter-like behavior)\n\npublic static class E\n{\n    extension(IEnumerable<C1> i)\n    {\n       int P => 0;\n    }\n    extension(IEnumerable<object> i)\n    {\n       int P => throw null;\n    }\n}\npublic class C1 { }\npublic class C2 : C1 { }\n```\n```\n\n----------------------------------------\n\nTITLE: Using UnscopedRef with Interface Methods in C#\nDESCRIPTION: Demonstrates how [UnscopedRef] attribute can be used on interface methods and properties to allow for full expressiveness of ref struct implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    [UnscopedRef]\n    ref int P1 { get; }\n    ref int P2 { get; }\n}\n\nstruct S1\n{\n    [UnscopedRef]\n    internal ref int P1 { get {...} }\n\n    internal ref int P2 { get {...} }\n}\n\nref int M<T>(T t, S1 s)\n    where T : I1, allows ref struct\n{\n    // Error: may return ref to t\n    return ref t.P1;\n\n    // Error: may return ref to t\n    return ref s.P1;\n\n    // Okay\n    return ref t.P2;\n\n    // Okay\n    return ref s.P2;\n}\n```\n\n----------------------------------------\n\nTITLE: XML Documentation Output for Partial Properties in C#\nDESCRIPTION: Sample XML documentation file generated for a class with a partial property, demonstrating how only the implementation part comment is included in the final documentation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\"?>\n<doc>\n    <assembly>\n        <name>ConsoleApp1</name>\n    </assembly>\n    <members>\n        <member name=\"T:C\">\n            <summary>\n            My type\n            </summary>\n        </member>\n        <member name=\"P:C.Prop\">\n            <summary>\n            Implementation part comment\n            </summary>\n        </member>\n    </members>\n</doc>\n```\n\n----------------------------------------\n\nTITLE: Approach A2: Control Warnings with Attributes (C#)\nDESCRIPTION: Demonstrates using attributes to control nullable warnings for the backing field. This allows suppressing warnings and providing appropriate warnings when `field` is used unsafely.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n\"[field: MaybeNull] string Prop { ...field... }\\n\\n// Would be the same as\\n[MaybeNull] string _field;\\nstring Prop { ..._field... }\"\n```\n\n----------------------------------------\n\nTITLE: Instance Increment Operator Implementation\nDESCRIPTION: Shows how to implement an instance increment operator that modifies the object's value in-place without allocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass C1\n{\n    public int Value;\n\n    public void operator ++()\n    {\n        Value++;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Validated With Constructor in C#\nDESCRIPTION: Implementation of With constructor with validation support using a private constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nclass UserInfo\n{\n    ...\n    private UserInfo(UserInfo original)\n    {\n        // validation code\n    }\n    [WithConstructor]\n    public UserInfo With() => new UserInfo(this);\n}\n```\n\n----------------------------------------\n\nTITLE: Array vs Span Pattern Matching in C#\nDESCRIPTION: Shows how pattern matching works differently between arrays (which support variance) and Span types. Arrays allow pattern matching while Span types do not.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nM1<object[]>([\"0\"]); // prints\nM1<string[]>([\"1\"]); // prints\n\nvoid M1<T>(T t)\n{\n    if (t is object[] r) Console.WriteLine(r[0]); // ok\n}\n\nvoid M2<T>(T t) where T : allows ref struct\n{\n    if (t is ReadOnlySpan<object> r) Console.WriteLine(r[0]); // error\n}\n```\n\n----------------------------------------\n\nTITLE: Approach B2: Known-Safe Example (C#)\nDESCRIPTION: Illustrates an idiomatic case where NRT analysis will know that the getter will always return a non-null value due to assignment in the constructor, and an invariant in the setter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\n\"string Prop { get => field; set => field = value.Trim(); }\\n\\npublic C()\\n{\\n    this.Prop = \\\"\\\";\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Collection Expression with Non-Generic Interface\nDESCRIPTION: Example showing collection expression assignment to non-generic ICollection interface, demonstrating planned future support for heterogeneous collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-02.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nICollection c = [\"a\", 2, null];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Member Redirection for Disambiguation in C#\nDESCRIPTION: This code shows a potential workaround for extension member ambiguity by creating a helper extension that redirects to a specific implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-as-static-types.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// OtherFile.cs\nusing E1;\n\nextension HelperExtensions for string\n{\n    public void E1_M() => M();\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Nullable Structs to Null in Tuples\nDESCRIPTION: Example showing the special case of comparing a nullable struct to null within a tuple when the struct has no custom equality operator, interpreted as a HasValue check.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/tuple-equality.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n(0, (S?)x) == (0, null)\n```\n\n----------------------------------------\n\nTITLE: Basic Compound Assignment Implementation Example\nDESCRIPTION: Demonstrates current C# behavior with compound assignment operators where a new instance must be allocated and returned.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass C1\n{\n    static void Main()\n    {\n        var c1 = new C1();\n        c1 += 1;\n        System.Console.Write(c1);\n    }\n    \n    public static C1 operator+(C1 x, int y) => new C1();\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Field Access Property in C#\nDESCRIPTION: Simple property implementation with explicit field access in both accessors\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n{ get => field; set => field = value; }\n```\n\n----------------------------------------\n\nTITLE: Conflicting Static Extension Methods in C#\nDESCRIPTION: Example showing a conflict scenario where static extension methods have the same name and return type but different receiver types, which would cause signature conflicts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class CollectionExtensions\n{\n    extension<T>(List<T>)\n    {\n        public static T[] Create() { ... }\n    }\n    extension<T>(HashSet<T>)\n    {\n        public static T[] Create() { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Values Through Ref Ternary Expressions in C#\nDESCRIPTION: Examples of assigning values to the target of a ref ternary expression. The expression is writeable only if both targets are writeable LValues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n// assign to\n(arr != null ? ref arr[0]: ref otherArr[0]) = 1;\n\n// error. readOnlyField is readonly and thus conditional expression is readonly\n(arr != null ? ref arr[0]: ref obj.readOnlyField) = 1;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Conversion in Relational Pattern Matching\nDESCRIPTION: Example showing how type conversion affects relational pattern matching behavior when comparing a short value stored as object against an integer literal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-18.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nobject o = (short)1;\n_ = o switch\n{\n    < 3 => 0, // This would be false, since `o` is a short, not an int, and the\n              // unconverted '3' is an `int`\n};\n```\n\n----------------------------------------\n\nTITLE: Explicit Ownership Transfer with Destructible Types in C#\nDESCRIPTION: Example showing how ownership of destructible types must be explicitly transferred using the 'move' keyword, preventing accidental double disposal and ensuring clear ownership responsibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvoid M()\n{\n    Handle h = CreateHandle();\n    Handle h2 = h; // Not allowed! Moves are explicit\n    Handle h3 = move h; // Explicit owner transfer\n    \n    M2(new Handle()); // ok, no owner\n    M2(h3); // Not allowed!\n    M2(move h3); // ok, explicit owner transfer\n\n}\nvoid M2(Handle h) ...\n```\n\n----------------------------------------\n\nTITLE: Indexer Resolution for Custom Dictionary Types in C#\nDESCRIPTION: Example illustrating indexer resolution for custom dictionary types with multiple indexers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nMyDictionary<string, int> d =\n  [\n    (object)\"one\":1, // this[object] { set; }\n    \"two\":2          // this[string] { set; }\n  ];\n\nclass MyDictionary<K, V> : IEnumerable<KeyValuePair<object, object>>\n{\n  // ...\n  public V this[K k] { ... }\n  public object this[object o] { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Declaration with Goto Example\nDESCRIPTION: Example demonstrating goto behavior with using declarations, which led to the decision that goto cannot jump past a using var declaration, similar to try-finally restrictions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-03.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ngoto label;\nusing var x = ...;\nlabel:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Ref Struct with Ref Field in C#\nDESCRIPTION: This snippet shows the definition of a ref struct with a ref field, illustrating the concept of layered lifetimes within a single type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/REF-2022-11-11.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nref struct RS { \n  ref 'a Span<byte> Field; \n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Field Initialization and Default Construction Behavior\nDESCRIPTION: This code snippet illustrates the issue with struct default construction behavior. It shows a struct with an initialized field and demonstrates how Activator.CreateInstance behavior differs between .NET Framework and .NET Core 2.0+.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-07-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic struct S\n{\n    public readonly int Field = 1; // Field is set by the default constructor\n}\n\npublic void M<T>()\n{\n    var s = (S)Activator.CreateInstance(typeof(T));\n    Console.WriteLine(s.Field);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Base and Derived Classes with Params and Scoped - C#\nDESCRIPTION: This code demonstrates the interaction between `params` and `scoped` keywords in overridden methods. It shows how the C# compiler enforces explicit specification of `scoped` or `params` on overrides when either is present in the base method signature, avoiding potential user confusion related to inferred `scoped` due to `params` usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-02-21.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass Base\n{\n    internal virtual Span<int> M1(scoped Span<int> s1, params Span<int> s2) => throw null!;\n    internal virtual void M2(scoped Span<int> s1) => throw null!;\n    internal virtual void M3(params Span<int> s2) => throw null!;\n}\n\nclass Derived : Base\n{\n    internal override Span<int> M1(Span<int> s1, // Today: error, missing `scoped` on override\n                                   Span<int> s2  // Proposed: error, missing `scoped` or `params`\n                                  ) => throw null!;\n    internal override void M2(Span<int> s1) => throw null!; // Today: no error\n    internal override void M3(Span<int> s2) => throw null!; // Proposed: no error\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Method with Null Check Flow Analysis\nDESCRIPTION: Demonstrates flow analysis behavior in null-checked code block with generic type parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-05.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvoid M<T>(T p) where T : class?\n{\n    if (p == null) // <- this is fine\n    {\n        T x = p; // <- this also doesn't give a warning because\n                 // there is no conversion\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Switch Statement in C#\nDESCRIPTION: Example showing pattern matching in a switch statement with both value and type patterns. Demonstrates handling of conversions between types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-10-07-Design-Review.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nFoo foo = ...; // has a conversion to int\nswitch (foo)\n{\n    case 1: // uses the converted value\n    case Foo(2): // uses the original value\n    case 3: // uses the converted value\n}\n```\n\n----------------------------------------\n\nTITLE: Join-into with Continued Query Body Translation\nDESCRIPTION: Demonstrates how a join-into clause followed by additional query clauses is translated, creating an anonymous type to carry the join results.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nfrom Â«x1Â» in Â«e1Â»  \njoin Â«x2Â» in Â«e2Â» on Â«k1Â» equals Â«k2Â» into *gÂ»  \n...\n```\n\nLANGUAGE: csharp\nCODE:\n```\nfrom * in ( Â«e1Â» ) . GroupJoin(  \n   Â«e2Â» , Â«x1Â» => Â«k1Â» , Â«x2Â» => Â«k2Â» , ( Â«x1Â» , Â«gÂ» ) => new { Â«x1Â» , Â«gÂ» })\n...\n```\n\n----------------------------------------\n\nTITLE: Approach A1: Idiomatic Migration (C#)\nDESCRIPTION: Illustrates the idiomatic case of migrating a field and property declaration to the `field` keyword.  However, doing so would require a non-trivial transformation with potentially annoying suppressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n\"string? _prop;\\nstring Prop { get => _prop ??= ComputeInitialValue(); }\"\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression Null State Analysis in C#\nDESCRIPTION: Shows the complexity of tracking null states when using lambda expressions and delegate conversions, highlighting the tradeoffs between safety and practicality.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-31.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvoid M()\n{\n    int? x = null;\n    Action a = () => x = 0;\n    a();\n    // What's the null state of `x` here?\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating params Span<T> vs params T[] Usage\nDESCRIPTION: Illustrates the breaking change scenario where params Span<T> becomes preferred over params T[] arrays, potentially causing issues with expression trees. The workaround requires explicit array creation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew[] { } // Explicit array creation workaround for expression tree compatibility\n```\n\n----------------------------------------\n\nTITLE: Binary Compatibility Example\nDESCRIPTION: Demonstrates binary compatibility concerns with interface implementation inheritance across multiple assemblies.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    void M() { Impl1 }\n}\ninterface I2 : I1\n{\n    override void M() { Impl2 }\n}\ninterface I3 : I1\n{\n}\nclass C : I2, I3\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Target Typing with List<T> for IReadOnlyList<T> in C#\nDESCRIPTION: This snippet demonstrates collection expression usage when target typing to `IReadOnlyList<T>` and defaulting to `List<T>`.  The expression `[]` will be interpreted as a `List<OrderTag>`, which may lead to unexpected behavior for read-only scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nclass Order : ITaggable\n{\n    // Legal. Is equivalent to: `Tags { get; } = new List<OrderTag>();\n    public IReadOnlyList<OrderTag> Tags { get; } = [];\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded Data Class Equivalent\nDESCRIPTION: Shows the expanded form of a data class with primary constructor, including auto-generated properties and constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\ndata class Point\n{\n    public int X { get; }\n    public int Y { get; }\n\n    public Point(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n\n    public void Deconstruct(out int X, out int Y)\n    {\n        X = this.X;\n        Y = this.Y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Additional Examples of Non-trailing Named Arguments\nDESCRIPTION: A series of examples showing which non-trailing named argument usages would become legal with this proposal and which would remain illegal. Shows the function definition and various calling patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/non-trailing-named-arguments.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic void DoSomething(bool isEmployed, string personName, int personAge) { ... }\n\nDoSomething(isEmployed:true, name, age); // currently CS1738, but would become legal\nDoSomething(true, personName:name, age); // currently CS1738, but would become legal\nDoSomething(name, isEmployed:true, age); // remains illegal\nDoSomething(name, age, isEmployed:true); // remains illegal\nDoSomething(true, personAge:age, personName:name); // already legal\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Tuple Arrays in C#\nDESCRIPTION: Examples showing how type inference works with tuple arrays, where names are preserved only when all elements with names agree on them.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-01.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar a1 = new[]{ t1, t1 }; // infers (int x, int y)[], since all agree\nvar a2 = new[]{ t1, t2 }; // infers (int, int)[], since not all agree\nvar a3 = new[]{ t1, t3 }; // infers (int x, int y)[] since all with names agree\n```\n\n----------------------------------------\n\nTITLE: Custom Value Override Property in C#\nDESCRIPTION: Property with custom getter value and field-based setter\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n{ get => overriddenValue; set => field = value; }\n```\n\n----------------------------------------\n\nTITLE: Implementing Instance Extension Methods in C#\nDESCRIPTION: This snippet illustrates the implementation of instance extension methods where the receiver parameter is placed before the method name, eliminating the need for the 'this' modifier. This approach enhances readability and aligns the syntax closer to instance method calls. Required parameters are included in parentheses syntax before the method name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic partial extensions Extensions\n{\n    public SourceTextContainer (ITextBuffer buffer).AsTextContainer()\n        => TextBufferContainer.From(buffer);\n\n    internal TextLine (ITextSnapshotLine line).AsTextLine()\n        => line.Snapshot.AsText().Lines[line.LineNumber];\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Case for Differing Lambda Default Parameter Values in C#\nDESCRIPTION: This code snippet illustrates a case where a lambda with a default parameter value different from its target delegate type should produce an error. The delegate 'D' has a default parameter value of 0, while the lambda tries to use 1.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-07-13.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ndelegate void D(int i = 0);\nD d = (int i = 1) => {}; // Error: default parameter values differ.\n```\n\n----------------------------------------\n\nTITLE: Default Constraint Usage Examples in C#\nDESCRIPTION: Shows the usage of the new 'default' constraint for handling unconstrained type parameters in inheritance scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nclass A2\n{\n    public virtual void F2<T>(T? t) where T : struct { }\n    public virtual void F2<T>(T? t) { }\n}\n\nclass B2 : A2\n{\n    public override void F2<T>(T? t) /*where T : struct*/ { }\n    public override void F2<T>(T? t) where T : default { }\n}\n```\n\n----------------------------------------\n\nTITLE: Postfix Increment/Decrement Operator Examples with Reference Types\nDESCRIPTION: Examples of postfix increment operations with reference types, showing different scenarios including property access and the resulting intermediate operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar a = (new C())++; // error: not a variable\nvar b = new C(); \nvar c = b++; // var temp = b; b = C.op_Increment(temp); c = temp; \nb++; // b.op_Increment();\nvar d = C.P1++; // error: missing setter\nC.P1++; // error: missing setter\nvar e = C.P2++; // var temp = C.get_P2(); C.set_P2(C.op_Increment(temp)); e = temp;\nC.P2++; // var temp = C.get_P2(); C.set_P2(C.op_Increment(temp));\n\nclass C\n{\n    public static C P1 { get; } = new C();\n    public static C P2 { get; set; } = new C();\n\n    public static C operator ++(C x) => ...; \n    public void operator ++() => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Span<T> in C#\nDESCRIPTION: Example of how Span<T> is referenced in C#. Span<T> is a special type that logically contains a ref and a size/range, requiring special safety considerations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-29.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nSpan<T>\n```\n\n----------------------------------------\n\nTITLE: Declaring Readonly Parameters in C# Methods\nDESCRIPTION: Shows how to declare readonly parameters in method signatures, preventing modification of the parameter within the method body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/readonly-locals.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic void Update(readonly int index = 0) // Default values are ok though not required\n{\n    ...\n    index = 0; // Error: can't assign to readonly parameters\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Static Class Container Example\nDESCRIPTION: Example showing how extensions are declared inside top-level non-generic static classes\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    // New extension declaration\n    extension(IEnumerable source) { ... }\n    \n    // Classic extension method\n    public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source) { ... }\n    \n    // Non-extension member\n    public static IEnumerable<int> Range(int start, int count) { ... } \n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Collections with Non-KeyValuePair Iteration Type in C#\nDESCRIPTION: This snippet outlines the process of constructing collections when the iteration type is not KeyValuePair<K, V>. It handles expression elements and spread elements, using the Add method for adding items to the collection.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n// Pseudo-code representation of the construction process\n\nforeach (var element in collectionExpression)\n{\n    if (element is ExpressionElement)\n    {\n        collection.Add(element);\n    }\n    else if (element is SpreadElement)\n    {\n        foreach (var item in GetEnumerator(element))\n        {\n            collection.Add(item);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Parameter with RValues\nDESCRIPTION: Examples demonstrating ref parameters with literal values and await expressions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-09-27.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nFoo(ref 42);\nFoo(ref await FooAsync());\n```\n\n----------------------------------------\n\nTITLE: Modified Function Pointer Syntax with Calling Convention in C#\nDESCRIPTION: A proposed modification where 'func' is always the first token and the calling convention is the second token.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-30.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nfunc cdecl*<int, void>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref Struct Preference in Overload Resolution in C#\nDESCRIPTION: This example shows how a ref struct (ValueSet<T>) could be preferred over a non-ref struct (HashSet<T>) in overload resolution when using collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nref struct ValueSet<T> { ... }\n\nvoid M(ValueSet<int> list);\nvoid M(HashSet<int> list);\n\nM([x, y, z]); // calls the ValueList version.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Return Only vs Containing Method Scopes in C#\nDESCRIPTION: This example demonstrates how lifetime relationships can be established between method parameters and return values, allowing for both value and reference returns while preventing cyclic assignment issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/REF-2022-11-11.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nref struct RS { }\nSpan<int> Create(ref RS i) {\n    ...\n}\n\n'b Span<int> Create('b ref 'a RS i) {\n    where 'b <= 'a\n\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Native Integer Usage in C#\nDESCRIPTION: Demonstrates basic usage of the nint type as a contextual keyword, showing variable declaration and method invocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnint x = 3;\n_ = nint.Equals(x, 3);\n```\n\n----------------------------------------\n\nTITLE: INotifyPropertyChanged Implementation\nDESCRIPTION: Property implementation using nameof for INotifyPropertyChanged event args to maintain type safety when referencing property names.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nint p {\n    get { return this._p; }\n    set { this._p = value; PropertyChanged(this, new PropertyChangedEventArgs(nameof(this.p)); }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Reference Type Annotation Scoping in C#\nDESCRIPTION: Code example showing how URTANN (Unannotated Reference Types Are Non-Null) attribute affects method behavior with nullable strings. The first method has no warning due to nullability being 'oblivious', while the second method is annotated with URTANN.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-05-30.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nT M(string s) => M2(s); // No warning because s is oblivious\n\n[URTANN]\nT M2(string s) => ...\n```\n\n----------------------------------------\n\nTITLE: Proposed Dictionary Expression Syntax Variations\nDESCRIPTION: Multiple candidate syntaxes explored for adding key comparers and initialization arguments to dictionary expressions in C#\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-11-20.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew(...) with [... elements]\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[.. elements] with (Comparer)\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[comparer; .. elements]\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[comparer: comparerInstance, .. elements]\n```\n\n----------------------------------------\n\nTITLE: Alternative Example of Operator Ambiguity Resolution in C#\nDESCRIPTION: Another example showing ambiguity in the checked context but a different resolution in the unchecked context. This demonstrates how the presence of checked operators affects operator resolution in class inheritance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    static void Add(C2 x, C3 y)\n    {\n        object o;\n        \n        // error CS0034: Operator '+' is ambiguous on operands of type 'C2' and 'C3'\n        o = checked(x + y);\n        \n        // C1.op_Addition\n        o = unchecked(x + y);\n    }\n}\n\nclass C1\n{\n    public static C1 operator + (C1 x, C3 y) => new C3();\n}\n\nclass C2 : C1\n{\n    // Cannot be declared in C# - missing unchecked operator, but could be declared by some other language\n    public static C2 operator checked + (C2 x, C1 y) => new C2();\n}\n\nclass C3 : C1\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Struct Generic Parameter Behavior in C#\nDESCRIPTION: Shows the behavior of generic parameters with 'allows ref struct' constraint, including lifetime rules and boxing restrictions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1 { }\nI1 M1<T>(T p)\n    where T : I1, allows ref struct\n{\n    // Error: cannot box potential ref struct\n    return p;\n}\n\nT M2<T>(T p)\n    where T : allows ref struct\n{\n    Span<int> span = stackalloc int[42];\n\n    // The safe-to-escape of the return is current method because one of the inputs is\n    // current method\n    T t = M3<int, T>(span);\n\n    // Error: the safe-to-escape is current method.\n    return t;\n\n    // Okay\n    return default;\n    return p;\n}\n\nR M3<T, R>(Span<T> span)\n    where R : allows ref struct\n{\n    return default;\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Conditional Method Usage with Field Keyword in C#\nDESCRIPTION: Demonstrates how the field keyword might be used in conditional code (like Debug.Assert calls). The decision is that backing fields should be generated even when only used in conditional methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    object P\n    {\n        get\n        {\n            Debug.Assert(field is null);\n            return null;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating IntRange Usage with '..' Operator in C#\nDESCRIPTION: This snippet shows how the '..' operator is used to create an IntRange. The operator is defined on the operand types, and the natural type IntRange wins in overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-12-06.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nIntRange r = 1 .. 10;\n```\n\n----------------------------------------\n\nTITLE: Nullable Reference Type Attribute Usage\nDESCRIPTION: Examples of nullable reference type attributes including NotNullWhenFalse, EnsuresNotNull, and NullableEquals. Shows usage in method signatures and equality comparisons.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-05-02.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nstatic bool IsNullOrEmpty([NotNullWhenFalse] string? s) { }\n```\n\nLANGUAGE: c#\nCODE:\n```\nstatic void AssertNotNull<T>([EnsuresNotNull] T? t) where T : class { }\n```\n\nLANGUAGE: c#\nCODE:\n```\nstatic void EnsureNotNull([EnsuresNotNull] ref string? s) { if (s is null) s = \"\"; }\n```\n\nLANGUAGE: c#\nCODE:\n```\nclass Object\n{\n    [NullableEquals] public static bool ReferenceEquals(object? x, object? y) { }\n    [NullableEquals] public static bool Equals(object? x, object? y) { }\n    [NullableEquals] public virtual bool Equals(object? other) { }\n    [NullableEquals] public static bool operator==(object? x, object? y) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda with Attribute Syntax Example\nDESCRIPTION: Example showing potential ambiguous syntax when using attributes with lambda expressions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-03.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MyAttribute] x => x; // Does MyAttribute apply to the parameter or the entire lambda?\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Interface Method Breaking Change for Ref Structs\nDESCRIPTION: This code example shows how adding a default interface method can break existing ref struct implementations until they are recompiled, highlighting versioning considerations for API authors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    // 1. The addition of a DIM method to an _existing_ interface\n    void M() { }\n}\n\n// 2. A ref struct implementing the interface but not explicitly defining the DIM \n// method\nref struct S : I1 { }\n\n// 3. The invocation of the DIM method in a generic method that has the `allows ref struct`\n// anti-constraint\nvoid M<T>(T p)\n    where T : allows ref struct, I1\n{\n    p.M();\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern-Based Method Binding with C# Extension Types\nDESCRIPTION: Illustrates a scenario involving pattern-based invocations (specifically deconstruction) with extension types. The decision is to allow extension methods to participate in such scenarios, but not extension properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-06-07.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension E for C\n{\n   public dynamic Deconstruct { get { ... } } \n}\n\nclass C\n{\n   void M()\n   {\n     (int i, int j) = this;\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Expression Variable Scope in Local Declaration\nDESCRIPTION: Example demonstrating the use of expression variables in local declarations where variable t is declared in the out parameter and used in a subsequent initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-08-24.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nint x = M(out int t), y = t;\n```\n\n----------------------------------------\n\nTITLE: Exploring Type Inference with Target-typed new-expressions in C#\nDESCRIPTION: Demonstrates potential scenarios where type inference could be influenced by the contents of a target-typed new-expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-25.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nM<T>(C<T> c);\nM(new C (...) { ... });\n\nM (new (...) {...});\n```\n\n----------------------------------------\n\nTITLE: Filtering and Transforming Nullable Types in LINQ Query in C#\nDESCRIPTION: This code demonstrates filtering out null values from a collection of nullable items and transforming them into non-nullable types. It showcases the need for tracking nullability within collection elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-07.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<HasNotNullable> M1(IEnumerable<HasNullable> enumerable)\n{\n    return enumerable\n        .Where(x => x.Item != null)\n        .Select(x => new HasNotNullable(x.Item)); // ok\n}\n\nrecord HasNullable(string? Item);\nrecord HasNotNullable(string Item);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating AllowNull Attribute Nullability Hole in C#\nDESCRIPTION: This code snippet illustrates an existing nullability hole in C# when using the AllowNull attribute on a field, which can lead to potential null reference issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// C# 12\nclass C\n{\n    [AllowNull]\n    private string resetIfSetToDefault;\n\n    public string ResetIfSetToDefault\n    {\n        // Removed `?? GetDefault()` without warnings!\n        get => resetIfSetToDefault;\n        set => resetIfSetToDefault = value == GetDefault() ? null : value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression in Collection Literals\nDESCRIPTION: Shows conditional element addition in collection literals using nested expressions. This syntax is being reviewed for potential improvements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-04-03.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar list = [1, 2, ...(condition ? [element] : []), 3, 4];\n```\n\n----------------------------------------\n\nTITLE: Type Inference Example in C#\nDESCRIPTION: This code demonstrates type inference in compat mode, where arguments are inferred using the generated static method signature. Compat mode passes the receiver as the first argument.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/compat-mode-in-extensions.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(I<string> i, out object o)\n{\n    i.M1(out o); // infers E.M1<object>\n    i.M2(out o); // error CS1503: Argument 1: cannot convert from 'out object' to 'out string'\n    i.M3(out o); // infers E.M3<object>\n}\n\npublic static class E\n{\n   public static void M1<T>(this I<T> i, out T t) { ... }\n   extension<T>(I<T> i)\n   {\n      public void M2(out T t) { ... }\n   }\n   extension<T>(this I<T> i) // Compat mode\n   {\n      public void M3(out T t) { ... }\n   }\n}\npublic interface I<out T> { }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Contextual Keyword Usage in C# Property Accessor\nDESCRIPTION: Example showing different usage scenarios of 'field' keyword within a property getter, illustrating the various contexts where keyword escaping might be required. This demonstrates simple name usage, declaration, and qualified access scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-03-04.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nint Prop\n{\n    get\n    {\n        int field = 1; // If it's only simple names that need to be escaped, this is legal\n        field = 2; // This needs to be escaped in every version; are we ok with the inconsistency between declaration and usage?\n        this.field = 3; // This is unambiguous, but does it need to be escaped anyways?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Logical Structure of Span<T> in C#\nDESCRIPTION: This code shows the conceptual structure of the Span<T> type, which consists of a reference to data and a length. The note mentions this exact implementation isn't possible because the CLR doesn't support ref fields directly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-01.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstruct Span<T>\n{\n\tref T data;\n\tint length;\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Property Method Calling in C#\nDESCRIPTION: This code snippet demonstrates the different ways of accessing an extension property, highlighting which forms are allowed and disallowed. The example defines an extension property `Prop` for the `object` type within a static class `C`. The meeting decided to disallow calling the underlying `get_Prop` method directly on an instance of `object` using the `object.get_Prop()` syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-03-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"_ = new object().Prop; // Allowed\n_ = C.get_Prop(new object()); // Previously said this is allowed\n_ = new object().get_Prop(); // Should this be allowed?\n\npublic static class C\n{\n    extension (object o)\n    {\n        public int Prop { get => 1; }\n    }\n}\"\n```\n\n----------------------------------------\n\nTITLE: Record Usage Example in C#\nDESCRIPTION: Demonstrates object initialization using object initializer syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M()\n{\n    var userInfo = new UserInfo() \n    {\n        Username = \"andy\",\n        Email = \"angocke@microsoft.com\",\n        IsAdmin = true\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Using Ref Ternary Expressions as Method Receivers in C#\nDESCRIPTION: Examples showing how ref ternary expressions can be used as receivers for method calls, potentially avoiding unnecessary copying of struct values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n// no copies\n(arr != null ? ref arr[0]: ref otherArr[0]).StructMethod();\n\n// invoked on a copy.\n// The receiver is `readonly` because readOnlyField is readonly.\n(arr != null ? ref arr[0]: ref obj.readOnlyField).StructMethod();\n\n// no copies. `ReadonlyStructMethod` is a method on a `readonly` struct\n// and can be invoked directly on a readonly receiver\n(arr != null ? ref arr[0]: ref obj.readOnlyField).ReadonlyStructMethod();\n```\n\n----------------------------------------\n\nTITLE: Using Array<T>.Empty() for params parameters with zero arguments in C#\nDESCRIPTION: This change proposes to use Array<T>.Empty() to create a zero-element array when no arguments are provided to a params parameter. The current language specification requires creating a new array, so this represents a language change to optimize memory usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-6.0/empty-params-array.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nArray<T>.Empty()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating field keyword usage scenarios in C# property getter\nDESCRIPTION: Code example showing various contexts where 'field' appears as an identifier rather than a keyword, including tuple elements, anonymous types, and pattern matching scenarios. These cases illustrate the complexity of implementing the field keyword detection.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-10-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    int Prop\n    {\n        get\n        {\n            var x = (field: 1, 2); // Tuple element named field, not a use of the field keyword\n            var y = new { field = 1 }; // Anonymous type property named field\n            var x = new Foo() { field = 1 }; // Regular type member named field\n            if (x is { field: 1 }) {} // Regular type member named field\n            return 1; // No usage of the field keyword, so a backing field should not be generated\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Fixed Statement Functionality in C#\nDESCRIPTION: Outlines the new support for a special method returning a pinned reference in the fixed statement. Discusses considerations for generics, nullable types, and ref extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-07.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nGetPinnableReference\n```\n\n----------------------------------------\n\nTITLE: Generic Match Function in C#\nDESCRIPTION: This snippet demonstrates a generic Match function used in the Roslyn codebase for type-based matching and execution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Design-Review.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMatch<T1, T2, TResult>(Func<T1, TResult> f1, Func<T2, TResult> f2) { ... }\nvar x = Match((string s) => e, (int i) => e);\n```\n\n----------------------------------------\n\nTITLE: Analyzing String Casts with Nullable References in C#\nDESCRIPTION: This code snippet showcases various scenarios of casting to string types, both nullable and non-nullable. It explores different use cases and their implications on nullability warnings and type inference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-21.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n(string)null;   // A\nM((string)null);// B \nM((string?)x);  // C\nM((string?)F()) // D - F is unannotated, and I want to impose my understanding of what it is\nM((string)F())  // E - F is unannotated, and I want to impose my understanding of what it is\n```\n\n----------------------------------------\n\nTITLE: Passing Underlying Value by Reference in C#\nDESCRIPTION: This code demonstrates how to pass the underlying value by reference to an extension member using the `ref` keyword in the extension declaration. This allows extension members to mutate the underlying value directly, which is particularly useful for value types. Value types must be used when utilizing the ref keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong) // underlying value is passed by ref\n    {\n        public bool this[int index]\n        {\n            get => (this & Mask(index)) != 0;\n            set => this = value ? this | Mask(index) : this & ~Mask(index); // mutates underlying value\n        }\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Name Binding with Target Types in C#\nDESCRIPTION: Shows proposed improvements to name binding with known target types, including examples with nested classes and enum values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-11.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass Outer\n{\n    public class Inner1 : Outer {}\n    public class Inner2<T> : Outer {}\n}\n\nint M1(Outer o) => o switch\n{\n    Inner1 _ => 0, // Binds to Outer\n    Inner2<int> _ => 1;\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\nColor x = b ? Red : Greed;\nvar y = b ? Color.Red : Greed;\n```\n\n----------------------------------------\n\nTITLE: Conversion and Unification of Anonymous Delegates with Optional Parameters in C#\nDESCRIPTION: Demonstrates how anonymous delegates with optional parameters are unified when parameters in the same position have the same default value, regardless of parameter name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nint E(int j = 13) {\n  return 11;\n}\n\nint F(int k = 0) {\n  return 3;\n}\n\nint G(int x = 13) {\n  return 4;\n}\n\nvar a = (int i = 13) => 1;\n// internal delegate int b'(int arg = 13);\nvar b = (int i = 0) => 2;\n// internal delegate int c'(int arg = 0);\nvar c = (int i = 13) => 3;\n// internal delegate int b'(int arg = 13);\nvar d = (int c = 13) => 1;\n// internal delegate int b'(int arg = 13);\n\nvar e = E;\n// internal delegate int b'(int arg = 13);\nvar f = F;\n// internal delegate int c'(int arg = 0);\nvar g = G;\n// internal delegate int b'(int arg = 13);\n\na = b; // Not allowed\na = c; // Allowed\na = d; // Allowed\nc = e; // Allowed\ne = f; // Not Allowed\nb = f; // Allowed\ne = g; // Allowed\n\nd = (int c = 10) => 2; // Warning: default parameter value is different between new lambda\n                       // and synthesized delegate b'. We won't do implicit conversion\n```\n\n----------------------------------------\n\nTITLE: Translating Deconstruction with Type Conversion in C#\nDESCRIPTION: Demonstration of how a deconstruction statement would be translated to handle type conversion from byte to int, using temporary variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-09-06.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\np.Deconstruct(out byte __x, out byte __y);\n(int x, int y) = (__x, __y);\n```\n\n----------------------------------------\n\nTITLE: Logging Implementation Example with String Handler\nDESCRIPTION: Comprehensive example showing both the original logging code and its approximate translation using the interpolated string handler, demonstrating how the method name is utilized.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/interpolated-string-handler-method-names.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Original code\nvar someOperation = RunOperation();\nILogger logger = CreateLogger(LogLevel.Error, ...);\nlogger.LogWarn($\"Operation was null: {operation is null}\");\n\n// Approximate translated code:\nvar someOperation = RunOperation();\nILogger logger = CreateLogger(LogLevel.Error, ...);\nvar loggingInterpolatedStringHandler = new LoggingInterpolatedStringHandler(20, 1, \"LogWarn\", logger, out bool continueBuilding);\nif (continueBuilding)\n{\n    loggingInterpolatedStringHandler.AppendLiteral(\"Operation was null: \");\n    loggingInterpolatedStringHandler.AppendFormatted(operation is null);\n}\nLoggingExtensions.LogWarn(logger, loggingInterpolatedStringHandler);\n```\n\n----------------------------------------\n\nTITLE: Constructing Span<T> with Arguments in C#\nDESCRIPTION: Demonstrates the limitations of using arguments with Span<T> in collection expressions, showing valid and invalid constructions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<int> a = [with(), 1, 2, 3]; // ok\nSpan<int> b = [with([1, 2]), 3]; // error: arguments not supported\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct This Escape Rules in C#\nDESCRIPTION: This snippet illustrates the difference in ref-safe-to-escape rules between 'this' and other ref parameters in struct members. The 'this' parameter is not ref-safe-to-escape, while other ref parameters are.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S\n{ \n    int Field;\n\n    // Illegal because `this` isn't safe to escape as ref\n    ref int Get() => ref Field;\n\n    // Legal\n    ref int GetParam(ref int p) => ref p;\n}\n```\n\n----------------------------------------\n\nTITLE: UTF-8 String Interpolation - C#\nDESCRIPTION: Reference to TryWriteUtf8 API optimization in .NET 8 for efficient UTF-8 string handling\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-16.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nTryWriteUtf8() // Optimized in .NET 8\n```\n\n----------------------------------------\n\nTITLE: Defining and Implementing Partial Events and Constructors in C#\nDESCRIPTION: Example showing defining and implementing declarations for partial events and constructors in a C# class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/partial-events-and-constructors.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npartial class C\n{\n    // defining declarations\n    partial C();\n    partial C(int x);\n    partial event Action E, F;\n\n    // implementing declarations\n    partial C() { }\n    partial C(int x) { }\n    partial event Action E { add { } remove { } }\n    partial event Action F { add { } remove { } }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dictionary Collection Expression with Comparer in C#\nDESCRIPTION: Example of a hypothetical syntax for passing a custom string comparer to a dictionary collection expression. Shows how a comparer could be specified along with spreading multiple sources of key-value pairs into a single dictionary.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<string, object> nameToOptions = [\n    comparer: StringComparer.OrginalIgnoreCase,\n    .. GetDefaultOptions(),\n    .. GetHostSpecificOptions(),\n    .. GetPlatformSpecificOptions(),\n];\n```\n\n----------------------------------------\n\nTITLE: Switching on Anonymous Unions in C#\nDESCRIPTION: This snippet demonstrates how to pattern match against anonymous union types in C#. It utilizes the switch expression to handle different types within the union, including cases for both 'int' and 'string'. The snippet shows various ways to implement type checks and match patterns effectively.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-11-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M((int|string) x) \n{\n    object o = x;\n    _ = o switch\n    {\n        (int|string) => 0,\n        _ => 0\n    };\n    _ = o switch\n    {\n        int or string => 1,\n        _ => 1\n    };\n    _ = o switch\n    {\n        int => 2,\n        string => 2,\n        _ => 2,\n    };\n\n    // Switch on x\n    _ = x switch\n    {\n        int => 2, // Could use x.IsTypeOf<int>\n        string => 2,\n        _ => 2,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Member-Based Extensions Proposal for C#\nDESCRIPTION: As part of an exploratory proposal, this snippet presents a member-based extension syntax that reflects the classic extension methods and enhances compatibility by expressing underlying types at the member level. Dependencies include knowledge of C# static methods and class structures. The design enables existing classic extension methods' compatibility by allowing invocation as static methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic partial extensions Extensions\n{\n    public SourceTextContainer (ITextBuffer buffer).AsTextContainer()\n        => TextBufferContainer.From(buffer);\n\n    internal TextLine (ITextSnapshotLine line).AsTextLine()\n        => line.Snapshot.AsText().Lines[line.LineNumber];\n}\ninternal extensions IComparerExtensions<T> for IComparer<T>\n{\n    public IComparer<T> comparer.Inverse => new InverseComparer<T>(comparer)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref Parameter Assignment Safety in C#\nDESCRIPTION: Code example showing potential safety concerns when assigning to ref parameters of ref-like structs, specifically demonstrating the interaction between Span<T> and ref parameters. This highlights why caller-side validation is necessary for safety guarantees.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-28.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(ref Span<int> x, ref int y) \n{\n    // One of two things must be true about this:\n    //  1. This is an error\n    //  2. The caller has guaranteed this is safe\n    x = new Span<int>(ref y); \n}\n```\n\n----------------------------------------\n\nTITLE: Record Type Value Equality Variations\nDESCRIPTION: Different approaches to implementing value equality in record types, showing variations with key keyword and implicit behaviors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-12.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nrecord Point1(int X); // Implies value equality over X\nrecord Point2a(int X); // Implies inherited equality\nkey record Point2b1(int X); // Implies value equality over X\nkey record Point2b2a(int X); // Implies \"empty\" value equality\nkey record Point2b2b(key int X); // Implies value equality over X\n\n\nkey class Point3a(int X); // implies record + value equality over X\ndata class Point3b(int X); // implies record with inherited equality\n```\n\n----------------------------------------\n\nTITLE: Interpolated String Addition Expression Example - C#\nDESCRIPTION: Demonstrates the order of operations in interpolated string addition with parentheses. The expression shows how multiple interpolated strings can be combined using the + operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-25.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n$\".....\" + ($\".....\" + $\".....\"\n```\n\n----------------------------------------\n\nTITLE: Await Spilling Implementation Challenge\nDESCRIPTION: Illustrates implementation challenges with await expressions in conditional operators when dealing with variable references.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-01.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n(cond ? v1 : v2).M(await ...);\n```\n\n----------------------------------------\n\nTITLE: Proposed LINQ Query Syntax with Tuple Deconstruction in C#\nDESCRIPTION: This snippet demonstrates a proposed syntax for LINQ queries using tuple deconstruction. It simplifies the previous example by directly deconstructing the tuple in the let clause.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-25.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nfrom s in strings\nlet (b, i) = (int.TryParse(out var n), n)\nwhere b\nselect i\n```\n\n----------------------------------------\n\nTITLE: Parameter References in Doc Comments for Partial Indexers in C#\nDESCRIPTION: Example demonstrating how paramref elements in documentation comments refer to parameters from the declaration where the doc comment is placed, even if parameter names differ between declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// My type\n/// </summary>\npartial class C\n{\n    public partial int this[int x] { get; set; }\n\n    /// <summary>\n    /// <paramref name=\"x\"/> // warning CS1734: XML comment on 'C.this[int]' has a paramref tag for 'x', but there is no parameter by that name\n    /// <paramref name=\"y\"/> // ok. 'Go To Definition' will go to 'int y'.\n    /// </summary>\n    public partial int this[int y] { get => 1; set { } } // warning CS9256: Partial property declarations 'int C.this[int x]' and 'int C.this[int y]' have signature differences.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pattern Combinators in ANTLR Grammar for C#\nDESCRIPTION: This ANTLR grammar snippet defines the syntax for pattern combinators in C# 9.0, including 'and', 'or', and 'not' patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_6\n\nLANGUAGE: ANTLR\nCODE:\n```\npattern\n    : disjunctive_pattern\n    ;\ndisjunctive_pattern\n    : disjunctive_pattern 'or' conjunctive_pattern\n    | conjunctive_pattern\n    ;\nconjunctive_pattern\n    : conjunctive_pattern 'and' negated_pattern\n    | negated_pattern\n    ;\nnegated_pattern\n    : 'not' negated_pattern\n    | primary_pattern\n    ;\nprimary_pattern\n    : // all of the patterns forms previously defined\n    ;\n```\n\n----------------------------------------\n\nTITLE: Parameter Validation Using nameof\nDESCRIPTION: Common pattern for null parameter validation using nameof to get the parameter name for the exception message.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvoid f(string s) {\n    if (s == null) throw new ArgumentNullException(nameof(s));\n}\n```\n\n----------------------------------------\n\nTITLE: Return-only Scope Documentation\nDESCRIPTION: Markdown section explaining the new return-only scope feature added to handle breaking changes with ref parameters. This scope sits between method scope and calling function scope, allowing ref returns through specific channels.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-10-05.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n#### Return-only scope\n\nIn response to breaking changes seen by customers with `ref` parameters, we added a new scope in between the method scope and the calling function scope: return-only. Something that is return-only is only allowed to escape by ref through a `ref`-return or an out parameter, and not through ref assignment to a `ref` parameter.\n```\n\n----------------------------------------\n\nTITLE: Future Implementation for IReadOnlyDictionary<T> in C# 13\nDESCRIPTION: For IReadOnlyDictionary<T> in C# 13, the implementation will follow a strategy consistent with IReadOnlyList<T>, likely synthesizing a private type similar to System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-11.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// Synthesized by the compiler\nprivate sealed class SynthesizedReadOnlyDictionary<TKey, TValue> : IReadOnlyDictionary<TKey, TValue>\n{\n    // Implementation details\n}\n```\n\n----------------------------------------\n\nTITLE: Indexer Accessor Warning Issues\nDESCRIPTION: Shows how indexer accessors can produce duplicate warnings that don't clearly indicate the source of the problem.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-parameter-default-value-analysis.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public int this[int i, string s = null] // no warning here\n    {\n        get // entire accessor syntax has warning CS8600: Converting null literal or possible null value to non-nullable type.\n        {\n            return i;\n        }\n\n        set // entire accessor syntax has warning CS8600: Converting null literal or possible null value to non-nullable type.\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assignment Using this Keyword for Field Initialization\nDESCRIPTION: Equivalent constructor code using 'this' keyword to show how field initialization in a primary constructor works conceptually.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n    this.configuration = configuration;\n```\n\n----------------------------------------\n\nTITLE: Extension property example: Prefer more specific type\nDESCRIPTION: This code shows how extension properties are resolved when multiple candidates exist. The example demonstrates the desired behavior of preferring a more specific type parameter for the receiver.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n\"_ = \\\".P; // should pick E(string).P\\n\\npublic static class E\\n{\\n    extension(object o)\\n    {\\n        public int P => throw null; \\n    }\\n    extension(string s) // more specific parameter type\\n    {\\n        public int P => 0;\\n    }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Generic Null Checking Example\nDESCRIPTION: Example demonstrating null checking behavior in generic methods without constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-05.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic T Id<T>(T t)\n{\n    if (t is null) Console.WriteLine();\n    return t; // warn?\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy Evaluation with Spreads in C#\nDESCRIPTION: This snippet raises the question of whether spread elements should be evaluated lazily, using an example with an infinite sequence generated by an `IEnumerable`. It highlights the potential performance implications of eager versus lazy evaluation of spread elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nstatic IEnumerable<int> GetIntegers()\n{\n    for (int i = 0; ; i++)\n        yield return i;\n}\n\nIEnumerable<int> e = [..GetIntegers()];\nint first = e.First();\n```\n\n----------------------------------------\n\nTITLE: Raw String with Single Quotes\nDESCRIPTION: Example of a raw string literal with content starting and ending with quotes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         \"The content of this string starts and ends with a quote\"\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Method Group Conversion Warning\nDESCRIPTION: This example shows that converting a method group to object triggers a warning since the conversion is valid but likely unintentional. The explicit cast silences the warning, clarifying the programmer's intent.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nRandom r = new Random();\nobject obj;\nobj = r.NextDouble;         // warning: Converting method group to 'object'. Did you intend to invoke the method?\nobj = (object)r.NextDouble; // ok\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Translation Examples\nDESCRIPTION: Demonstration of how collection expressions with initialization arguments get translated to constructor calls or creation methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> nameToAge1 = [with(StringComparer.OrdinalIgnoreCase), ...]; // translates to:\n\n// argument_list *becomes* the argument list for the\n// constructor call. \n__result = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase); // followed by normal initialization\n\n// or:\n\nImmutableDictionary<string, int> nameToAge2 = [with(StringComparer.OrdinalIgnoreCase), ...]; // translates to:\n\n// argument_list arguments are passed initially to the\n// 'create method'.\n__result = ImmutableDictionary.CreateRange(StringComparer.OrdinalIgnoreCase, /* key/values to initialize dictionary with */);\n\n// or\n\nIReadOnlyDictionary<string, int> nameToAge2 = [with(StringComparer.OrdinalIgnoreCase), ...]; // translates to:\n\n// create synthesized dictionary with hashing/equality\n// behavior determined by StringComparer.OrdinalIgnoreCase.\n```\n\n----------------------------------------\n\nTITLE: Implementing Discriminated Union as Record-Based Class Hierarchy in C#\nDESCRIPTION: Example showing how discriminated unions might be implemented using records, with an abstract base class and derived classes for each variant, demonstrating the singleton pattern challenge.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-03-30.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nabstract class Color\n{\n    public class Red() : Color;\n    public class Green() : Color;\n    public class Blue() : Color;\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Element Names in Partial Classes\nDESCRIPTION: Demonstrates the requirement for consistent tuple element names across partial class declarations implementing generic interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-13.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npartial class C : IEnumerable<(string name, int age)> { ... }\npartial class C : IEnumerable<(string fullname, int)> { ... } // error: names must be specified and the same\n```\n\n----------------------------------------\n\nTITLE: Class with Virtual Method Having Nullable Class Constraint\nDESCRIPTION: Defines a class with a virtual method that has a nullable class constraint on its type parameter in a #nullable enable context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-15.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\npublic class A\n{\n    public virtual void F2<T>(T y) where T : class?\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Expression Pattern Matching with Match Operator in C#\nDESCRIPTION: LINQ query using pattern matching expression to calculate areas of different geometric primitives. Shows type-based pattern matching with multiple cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-10-07-Design-Review.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar areas =\n    from primitive in primitives\n    let area = primitive match (\n        case Line l: 0\n        case Rectangle r: r.Width * r.Height\n        case Circle c: Math.PI * c.Radius * c.Radius\n        case *: throw new ApplicationException()\n    )\n    select new { Primitive = primitive, Area = area };\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullability Context with Compiler Directives in C#\nDESCRIPTION: Example of using compiler directives to control nullable annotations and warnings in a Dictionary class. The #nonnull and #pragma warning directives are used to toggle nullability context at different levels.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-03.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class Dictionary<TKey, TValue> : ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, ICollection, IDictionary, IDeserializationCallback, ISerializable\n{\n    public Dictionary() { }\n    public Dictionary(IDictionary<TKey, TValue> dictionary) { }\n    public Dictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection) { }\n    public Dictionary(IEqualityComparer<TKey>? comparer) { }\n \n#nonnull disable\n    public Dictionary(int capacity) { }\n    public Dictionary(IDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer) { }\n    public Dictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer) { }\n#nonnull restore\n \n    public Dictionary(int capacity, IEqualityComparer<TKey>? comparer) { }\n \n#pragma warning disable null\n    protected Dictionary(SerializationInfo info, StreamingContext context) { }\n#pragma warning restore null\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating proposed ref usage in async methods\nDESCRIPTION: Shows how ref locals could be allowed in async methods when they don't cross await points. Previously this was disallowed, but the proposal would permit it when the ref doesn't need to be hoisted across awaits.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-unsafe-in-iterators-async.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nasync void M()\n{\n    await ...;\n    ref int x = ...; // error previously, proposed to be allowed\n    x.ToString();\n    await ...;\n    // x.ToString(); // still error\n}\n```\n\n----------------------------------------\n\nTITLE: Task Return Type Reference\nDESCRIPTION: Reference to Task return types in async methods discussed in context of optimization\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-01.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nTask\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref-Struct Collection with Custom Builder in C#\nDESCRIPTION: Illustrates how the chosen approach applies to custom ref-struct collections using a CollectionBuilder attribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\n[CollectionBuilder(FrugalListBuilder)]\nref struct FrugalList<T>\n{\n}\n\nstatic class FrugalListBuilder\n{\n    public static FrugalList<T> Create(ReadOnlySpan<T> values);\n}\n\n// ...\nFrugalList<int> f = [a, b, c]; // Stack-allocated, local scope.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Member Hiding in Implicit Extensions in C#\nDESCRIPTION: This example demonstrates how member hiding in derived implicit extensions can lead to ambiguity in method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension Base for object \n{\n    void M() { }\n}\nimplicit extension Derived for object : Base\n{\n    new void M() { }\n}\n\nobject o = ...;\no.M(); // ambiguous\n```\n\n----------------------------------------\n\nTITLE: Invalid Pre-C# 6.0 Struct with Auto-Properties\nDESCRIPTION: Example of code that would cause errors before C# 6.0 due to strict rules about initializing auto-properties in structs. This would generate errors because the backing fields of auto-properties must be fully assigned before control returns to the caller.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-6.0/struct-autoprop-init.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S \n{ \n    int X { get; set; } \n    int Y { get; set; } \n    public S(int x, int y) \n    { \n        this.X = x; \n        this.Y = y; \n    } \n} \n```\n\n----------------------------------------\n\nTITLE: Named Tuple Element Syntax in C#\nDESCRIPTION: Examples of named tuple element syntax alternatives.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nvar t = (x: 3);\nvar t = (: 3); // yuck!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Async Method Nullability Issue in C#\nDESCRIPTION: This code snippet illustrates the current issue with MemberNotNull attribute on async methods, where exceptions are packaged into a Task and returned to the caller, potentially causing unexpected null reference exceptions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    string? item;\n    \n    [MemberNotNull(nameof(item))]\n    public async Task MAsync()\n    {\n        Helper();\n        item = \"a\";\n        await Task.Yield(); // no warnings\n    }\n\n    public static void Helper() => throw new Exception();\n    \n    public static void Main()\n    {\n        C c = new C();\n        var t = c.MAsync(); // exception is thrown indirectly through Helper and included in the returned Task\n        c.item.ToString(); // no warning, NRE at runtime\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Required Ref Property Declaration - C#\nDESCRIPTION: Example showing potential syntax for declaring a required ref property in C#. This demonstrates a way to enforce value assignment to a ref-returning property's storage location.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-05-23.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nref required int Prop { get; }\n```\n\n----------------------------------------\n\nTITLE: Handling Overload Resolution in C# Extension Methods\nDESCRIPTION: This example highlights how classic extension methods can create ambiguities during overload resolution based on method applicability. It contrasts this with the proposed behavior for new extension methods which should eliminate such ambiguities appropriately.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/implicit-compatibility-for-ported-extension-methods.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n\"Hello\".M(\"World!\"); // Ambiguous!\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic static class MyExtensions\n{\n    public static void M(this object o, string s) { ... }\n    public static void M(this string s, object o) { ... }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\n\"Hello\".M(\"World!\"); // Picks string.M(object) because receiver is more specific\n\npublic static class MyExtensions\n{\n    extension(object o)\n    {\n        publicvoid M(string s) { ... }\n    }\n    extension(string s)\n    {\n        public void M(object o) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Async File.Exists Method with NotNull Attribute in C#\nDESCRIPTION: This code snippet shows a hypothetical async File.Exists method with a NotNull attribute, demonstrating how nullability checks could work with async methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System\n{\n    public static class File\n    {\n        public static async Task<bool> ExistsAsync([NotNull] string? path); // throws an exception if path is null\n    }\n}\n\npublic class C\n{\n    public static async Task M(string? path)\n    {\n        if (await File.ExistsAsync(path))\n        {\n            path.ToString(); // ok\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Extension Member Ambiguity in C#\nDESCRIPTION: This code demonstrates potential ambiguity issues when multiple extensions define the same member, and discusses possible resolution approaches.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-as-static-types.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic extension E1 for string\n{\n    public void M() => ...;\n}\nextension E2 for string\n{\n    public void M() => ...;\n    public void P => ... M() ...; // Ambiguity? Closeness rule?\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Null Propagation Chain in C#\nDESCRIPTION: Shows the recommended approach using multiple null propagating operators to safely handle null checks at each level.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nvar x = a?.b?.c;\n```\n\n----------------------------------------\n\nTITLE: String.Format Implementation in C#\nDESCRIPTION: Shows the underlying String.Format method that string interpolation uses for string construction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nString.Format(string format, params object args[])\n```\n\n----------------------------------------\n\nTITLE: ReadOnlySpan vs Array Overload Resolution in C#\nDESCRIPTION: Example showing ambiguous resolution between ReadOnlySpan<string> and object[] parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-09-20.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void C(ReadOnlySpan<string> r);\nstatic void C(object[] r);\n\nC([\"1\", \"2\"]); // Ambiguous today, because object[] and ROS<string> cannot be converted between\n```\n\n----------------------------------------\n\nTITLE: Declaration Expression with Local Function in C#\nDESCRIPTION: Demonstration of proposed declaration expression syntax that allows embedding local functions within expression contexts, showing an implementation returning IEnumerable<T>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nreturn (IEnumerable<T> Impl() { ... yield return ... }; Impl());\n```\n\n----------------------------------------\n\nTITLE: Extension with Nullability Annotations in C#\nDESCRIPTION: Examples of extension declarations with nullability-related attributes like DoesNotReturnIf and NotNullIfNotNull, showing how these attributes can be applied to extension parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n    extension([System.Diagnostics.CodeAnalysis.DoesNotReturnIf(false)] bool b)\n    {\n        public void AssertTrue() => throw null!;\n    }\n```\n\n----------------------------------------\n\nTITLE: Basic Null Propagating Operation in C#\nDESCRIPTION: Simple example showing null propagating operator usage with chained member access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nvar x = a?.b.c;\n```\n\n----------------------------------------\n\nTITLE: Extension Operators Declaration Example\nDESCRIPTION: Example demonstrating how to declare extension operators within extension declarations\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TElement>(IEnumerable<TElement>) where TElement : INumber<TElement>\n    {\n        public static IEnumerable<TElement> operator *(IEnumerable<TElement> vector, TElement scalar) { ... }\n        public static IEnumerable<TElement> operator *(TElement scalar, IEnumerable<TElement> vector) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Indexer Pattern Matching Syntax - C#\nDESCRIPTION: The code snippet illustrates a community proposal for indexer pattern matching, which could potentially influence the syntax for dictionary literals.  It shows how indexer access and property patterns could be combined. This is an example of the possible syntax and how it could work.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-06.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n\"var dict5 = { [\\\"key1\\\"] = \\\"value1\\\", [\\\"key2\\\"] = \\\"value2\\\" };\\n\\nif (dict5 is { [\\\"key1\\\"]: var value })\\n{\"\n```\n\n----------------------------------------\n\nTITLE: Using Method Groups with Parameter Arrays in C# 12\nDESCRIPTION: Shows how to use method groups where the underlying method has a parameter array. The example demonstrates how to assign a method with a params array to a variable and then call it with varying numbers of arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar counter = CountMethod;\ncounter(); // 0\ncounter(1, 2); // 2\n\nint CountMethod(params int[] xs) {\n  return xs.Length;\n}\n```\n\n----------------------------------------\n\nTITLE: Usage of Role as Extension Method in C#\nDESCRIPTION: This snippet demonstrates how to use a role as an extension method on an `UnderlyingType`. It shows how the instance members on the underlying type take precedence over the extension methods. The lookup rules are similar to existing extension method lookup.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing MyRoleNamespace;\nUnderlyingType underlying = ...;\nunderlying.M1();\nunderlying.M2();\nunderlying.M3();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nUnderlyingType underlying = ...;\nunderlying.M1();\nunderlying.M2();\nnew MyRole(ref underlying).M3();\n```\n\n----------------------------------------\n\nTITLE: Collection Type Inference from Spread Elements\nDESCRIPTION: This C# code snippet demonstrates the question of how collection type inference should work when using spread elements within collection literals. It shows an example where an `ImmutableArray<int>` is spread into a new collection literal, and the desired behavior is to infer the type of the new collection `b` as `ImmutableArray<int>` as well. The discussion revolves around handling distinct types, interfaces, and potential breaking changes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-04-28.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nImmutableArray<int> a = [1, 2, 3];\nvar b = [..a, 4]; // ImmutableArray<int> b\n```\n\n----------------------------------------\n\nTITLE: Ambiguity Example with Identical Simple Names and Type Names in C#\nDESCRIPTION: Demonstrates the ambiguity that can occur when a type name and a parameter name are identical (\"Color Color\" scenario). The example shows a case where the compiler cannot determine if Color refers to the parameter or the type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S1(Color Color)\n{\n    public void Test()\n    {\n        Color.M1(this); // Error: ambiguity between parameter and typename\n    }\n}\n\nclass Color\n{\n    public void M1<T>(T x, int y = 0)\n    {\n        System.Console.WriteLine(\"instance\");\n    }\n    \n    public static void M1<T>(T x) where T : unmanaged\n    {\n        System.Console.WriteLine(\"static\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variance Inconsistencies in Static Interface Members (C#)\nDESCRIPTION: This code snippet illustrates the current inconsistency in variance rules for different types of static members in interfaces. Fields are allowed to use variant type parameters, while properties, methods, and events are not.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/variance-safety-for-static-interface-members.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface I<out T>\n{\n    static Task<T> F = Task.FromResult(default(T)); // No problem\n    static Task<T> P => Task.FromResult(default(T));   //CS1961\n    static Task<T> M() => Task.FromResult(default(T));    //CS1961\n    static event EventHandler<T> E; // CS1961\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Code Block with Parameters in Razor\nDESCRIPTION: Demonstrates line mapping for a code block containing parameter declarations in a Razor component\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/enhanced-line-directives.md#2025-04-21_snippet_4\n\nLANGUAGE: Razor\nCODE:\n```\n@code {\n    [Parameter]\n    public int IncrementAmount { get; set; }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\n#line lineof('[') \"a.razor\"\n    [Parameter]\n    public int IncrementAmount { get; set; }\n#line hidden\n```\n\n----------------------------------------\n\nTITLE: Equivalent Color Class Definition\nDESCRIPTION: Shows the equivalent class-based implementation of the Color enum class with static properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/discriminated-unions.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npartial abstract class Color\n{\n    public static Color Red => ...;\n    public static Color Green => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Pointer Arithmetic Operators in C#\nDESCRIPTION: This snippet defines arithmetic operators applicable to pointer types in an unsafe context, allowing for addition and subtraction of pointers with nint or nuint types. The operators require two parameters: a pointer and an integer offset, producing a new pointer as the result.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nT* operator +(T* x, nint y);\n    T* operator +(T* x, nuint y);\n    T* operator +(nint x, T* y);\n    T* operator +(nuint x, T* y);\n    T* operator -(T* x, nint y);\n    T* operator -(T* x, nuint y);\n```\n\n----------------------------------------\n\nTITLE: Implicit Coercion from Ad Hoc Union in C#\nDESCRIPTION: Shows how a value of an ad hoc union can be implicitly coerced to a type if all member types of the union can be implicitly coerced to that type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n(int, short) value = 10;\ndouble value2 = value;\n```\n\n----------------------------------------\n\nTITLE: KeyValuePair Type Conversion Example\nDESCRIPTION: Example showing how dictionary expressions handle KeyValuePair type conversions, allowing assignment between dictionaries with different but compatible key and value types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<string, int> d1 = ...;\n\n// Assignment possible, even though KeyValuePair<string, int>` is not itself assignable to KeyValuePair<object, long>\nDictionary<object, long> d2 = [.. d1];\n```\n\n----------------------------------------\n\nTITLE: Invalid Mixed Whitespace Example\nDESCRIPTION: Demonstrates an illegal case where indentation whitespace is inconsistent.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         Start\n<tab>\n         End\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Initializing readonly fields in same type example in C#\nDESCRIPTION: Example showing a potential feature where readonly fields could be set in an object initializer within the same type. This would enable static factory methods to initialize readonly fields using object initializer syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-15.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    public readonly string? ReadonlyField;\n\n    public static C Create()\n        => new C() { ReadonlyField = null; };\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Nullable Fields in LINQ\nDESCRIPTION: This C# code snippet demonstrates a transformation scenario where a collection of `C1` objects (containing a nullable string `field1`) is transformed into a collection of `C2` objects (containing a non-nullable string `field2`). Even though a `Where` clause filters out `C1` objects where `field1` is null, the compiler still issues a warning when assigning `i.field1` to `field2`.  The classes `C1` and `C2` are defined with nullable and non-nullable string fields, respectively.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<C2> Transform(IEnumerable<C1> items)\n{\n    return items\n        .Where(i => i.field1 != null)\n        .Select(i => new C2 { field2 = i.field1 }); // would still warn\n}\n\nclass C1\n{\n    public string? field1;\n}\n\nclass C2\n{\n    public required string field2;\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Extension Method Migration Example in C#\nDESCRIPTION: This snippet shows a more complex example of migrating an existing extension method with generic constraints to the new modern extension syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic class Enumerable\n{\n    public static TResult Sum<TSource, TResult, TAccumulator>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)\n        where TResult : struct, INumber<TResult>\n        where TAccumulator : struct, INumber<TAccumulator>\n    {\n        // Original body\n    }\n}\n\nextension Enumerable\n{\n    public TResult Sum<TSource, TResult, TAccumulator>(Func<TSource, TResult> selector)\n        for IEnumerable<TSource> source\n        where TResult : struct, INumber<TResult>\n        where TAccumulator : struct, INumber<TAccumulator>\n    {\n        // Exactly the same code as original body.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Compiler Representation of Static Delegate\nDESCRIPTION: Shows how the compiler would internally represent a static delegate as a blittable struct with a single IntPtr member and a well-known method name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/static-delegates.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstruct <Func>e__StaticDelegate\n{\n    IntPtr pFunction;\n\n    static int WellKnownCompilerName();\n}\n```\n\n----------------------------------------\n\nTITLE: 2022 C# Language Design Meeting Notes Directory\nDESCRIPTION: A markdown-formatted listing of all C# Language Design Team meetings from 2022, organized chronologically from latest to earliest. Each entry includes the meeting date and key topics discussed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# C# Language Design Notes for 2022\\n\\nOverview of meetings and agendas for 2022\\n\\n## Wed Dec 14, 2022\\n\\n[C# Language Design Meeting for December 14th, 2022](https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-12-14.md)\\n\\n- Breaking change for raw string literals\\n- Program as internal by default\n```\n\n----------------------------------------\n\nTITLE: Implementing Checked Operator with Unchecked Logic Example\nDESCRIPTION: Example showing implementation of a checked operator that uses unchecked logic in its body, demonstrating why operator bodies shouldn't automatically be in checked context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\noperator checked ++(...)\\n{\\n    unchecked { ... }\\n    _ = unchecked(...);\\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Arguments for Method Construction\nDESCRIPTION: Language feature exploring semantics of collection expression arguments, including constructor scenarios, overload resolution, and interface implementations\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-01-22.md#2025-04-21_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Tuple Type Equivalence Challenge with Method Overrides in C#\nDESCRIPTION: Illustrates a potential issue with tuple type equivalence when used in virtual method signatures, where the same tuple types might not be recognized as equivalent in derived classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nclass C\n{\n    public abstract (int x, int y) GetCoordinates();\n}\nclass D : C\n{\n    public override (int x, int y) GetCoordinates() { ... } // Error! different return type!!?!\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Constructor Runtime Bug in .NET Framework\nDESCRIPTION: Code example showing a bug in Activator.CreateInstance() on older .NET Framework versions where struct constructors are only correctly invoked the first time, with subsequent calls being zeroed out after construction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Console.WriteLine(CreateStruct<S>().Initialized); // True\nSystem.Console.WriteLine(CreateStruct<S>().Initialized); // False (On .NET Framework)\n\nT CreateStruct<T>() where T : struct\n{\n    return new T();\n}\n\nstruct S\n{\n    public readonly bool Initialized;\n    public S() { Initialized = true; }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multi-Targeted Scenario for Func<T> with Span<char>\nDESCRIPTION: This code snippet shows how Func<Span<char>> would compile in .NET 9.0 but fail in other target frameworks, highlighting potential confusion for developers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n// Works in net9.0 but fails in all other TF\nFunc<Span<char>> func;\n```\n\n----------------------------------------\n\nTITLE: Comparing Match Expression Syntax Options in C#\nDESCRIPTION: This code snippet demonstrates three different syntax options for implementing a match expression in C#. It shows variations using 'switch', 'match', and different formatting styles to handle state transitions based on current state and action.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-11-29.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n            state = (state, action) switch (\n                (DoorState.Closed, Action.Open) => DoorState.Opened,\n                (DoorState.Opened, Action.Close) => DoorState.Closed,\n                (DoorState.Closed, Action.Lock) => DoorState.Locked,\n                (DoorState.Locked, Action.Unlock) => DoorState.Closed,\n                _ => state);\n\n            state = match (state, action) \n            {\n                (DoorState.Closed, Action.Open) => DoorState.Opened,\n                (DoorState.Opened, Action.Close) => DoorState.Closed,\n                (DoorState.Closed, Action.Lock) => DoorState.Locked,\n                (DoorState.Locked, Action.Unlock) => DoorState.Closed,\n                _ => state\n            };\n\n            state = switch (state, action)\n            {\n                case (DoorState.Closed, Action.Open): DoorState.Opened\n                case (DoorState.Opened, Action.Close): DoorState.Closed\n                case (DoorState.Closed, Action.Lock): DoorState.Locked\n                case (DoorState.Locked, Action.Unlock): DoorState.Closed\n                case _: state\n            };\n```\n\n----------------------------------------\n\nTITLE: Implementing ICollection<T> or IList<T> in C#\nDESCRIPTION: When a collection expression targets ICollection<T> or IList<T>, the compiler will construct a new List<T>. This provides a mutable collection implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-11.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nList<T> collection = new List<T>();\n```\n\n----------------------------------------\n\nTITLE: Illustrating Current 'is' Expression Behavior in C#\nDESCRIPTION: Demonstrates the current behavior of 'is' expressions with various types and conversions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nbyte b = 5;\nWriteLine(b is byte);           // True:  identity conversion\nWriteLine((object)b is byte);   // True:  boxing conversion\nWriteLine((object)b is object); // True:  reference conversion\nWriteLine(b is int);            // False: numeric conversion changes representation\n```\n\n----------------------------------------\n\nTITLE: Extension Member with Attribute in C#\nDESCRIPTION: This code snippet shows an extension member with an attribute applied to its parameter. This attribute is preserved during lowering. The `[param:NotNull]` attribute is applied to the `__this` parameter in the generated code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\npublic static class NullableExtensions\n{\n    extension<T> (T) where T : class?\n    {\n        [param:NotNull] public void ThrowIfNull() => ArgumentNullException.ThrowIfNull(this);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Implementation for Record Equality Operators\nDESCRIPTION: Semantic implementation of equality operators for records, showing how the == and != operators would delegate to the Equals method. This allows consistent equality behavior across records.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-07-27.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npubic static bool operator==(R? one, R? other)\n    => (object)one == other || (one?.Equals(other) ?? false);\npublic static bool operator!=(R? one, R? other)\n    => !(one == other);\n```\n\n----------------------------------------\n\nTITLE: Nullable Warning Example with Partial Properties in C#\nDESCRIPTION: Example demonstrating how nullable analysis works with partial properties, showing that non-nullable properties trigger warnings when not initialized in constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npartial class C\n{\n    public partial string Prop { get; set; }\n    public partial string Prop { get => field; set => field = value; }\n\n    public C() // warning CS8618: Non-nullable property 'Prop' must contain a non-null value when exiting constructor. Consider declaring the property as nullable.\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default as Optional Parameter in C#\nDESCRIPTION: Shows how default can be used as a default argument for optional parameters, even for non-constant types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-07.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(MyStruct ms = default) { ... } // sure\n```\n\n----------------------------------------\n\nTITLE: Declaring a Standard Union Class in C#\nDESCRIPTION: This code snippet demonstrates how to declare a standard union class named 'U' in C#.  The union class has three members: A, B, and C. Each member can hold state variables, allowing it to represent different data structures within the same union.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nunion U \n{\n    A(int x, string y);\n    B(int z);\n    C;\n}\n```\n\n----------------------------------------\n\nTITLE: Field Parameter Declaration in Primary Constructor\nDESCRIPTION: Example showing syntax for field parameters, which allows creating a field directly from a primary constructor parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic class ConfigurationException(private Configuration configuration, â€¦)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Constraints with Nullable Reference Types in C#\nDESCRIPTION: This code snippet illustrates the use of generic constraints in C# with nullable reference types. It shows how constraints affect the nullability of type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-08-22.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M<T, U>() where T : class, U : T` {}\n```\n\n----------------------------------------\n\nTITLE: Initializing Class Fields with Nullable Reference Types in C#\nDESCRIPTION: Demonstrates the warning behavior for uninitialized non-nullable reference fields in a class. Fields without initialization or constructor assignment generate warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-09.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n\tstring s1;\n    string s2 = \"Hello\";\n    string s3; // warning: not initialized to non-null value\n    public C(string s) => s1 = s;\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring safe-context for declaration expressions in C#\nDESCRIPTION: Illustrates how the compiler infers the safe-context for declaration expressions involving ref structs, including how the 'scoped' modifier affects the resulting context boundaries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_63\n\nLANGUAGE: c#\nCODE:\n```\nref struct RS\n{\n    public RS(ref int x) { } // assumed to be able to capture 'x'\n\n    static void M0(RS input, out RS output) => output = input;\n\n    static void M1()\n    {\n        var i = 0;\n        var rs1 = new RS(ref i); // safe-context of 'rs1' is function-member\n        M0(rs1, out var rs2); // safe-context of 'rs2' is function-member\n    }\n\n    static void M2(RS rs1)\n    {\n        M0(rs1, out var rs2); // safe-context of 'rs2' is function-member\n    }\n\n    static void M3(RS rs1)\n    {\n        M0(rs1, out scoped var rs2); // 'scoped' modifier forces safe-context of 'rs2' to the current local context (function-member or narrower).\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying C# Grammar for Member Access Syntax Enhancement\nDESCRIPTION: Diff showing the modifications to the C# language grammar to introduce the standalone 'member_binding' syntax with a leading dot. This change affects member_access, base_access, null_conditional_member_access, dependent_access, and null_conditional_projection_initializer productions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/target-typed-static-member-lookup.md#2025-04-21_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n member_access\n-    : primary_expression '.' identifier type_argument_list?\n-    | predefined_type '.' identifier type_argument_list?\n-    | qualified_alias_member '.' identifier type_argument_list?\n+    : primary_expression member_binding\n+    | predefined_type member_binding\n+    | qualified_alias_member member_binding\n+    | member_binding\n     ;\n\n+member_binding\n+    '.' identifier type_argument_list?\n\n base_access\n-    : 'base' '.' identifier type_argument_list?\n+    : 'base' member_binding\n     | 'base' '[' argument_list ']'\n     ;\n\n null_conditional_member_access\n-    : primary_expression '?' '.' identifier type_argument_list?\n+    : primary_expression '?' member_binding\n       (null_forgiving_operator? dependent_access)*\n     ;\n\n dependent_access\n-    : '.' identifier type_argument_list?    // member access\n+    : member_binding            // member access\n     | '[' argument_list ']'     // element access\n     | '(' argument_list? ')'    // invocation\n     ;\n\n null_conditional_projection_initializer\n-    : primary_expression '?' '.' identifier type_argument_list?\n+    : primary_expression '?' member_binding\n     ;\n```\n\n----------------------------------------\n\nTITLE: Invalid User-Defined Conversions with Function Types\nDESCRIPTION: This snippet demonstrates that function type conversions are not considered when determining whether a user-defined conversion operator applies to an anonymous function or method group. Neither implicit nor explicit conversions work in this case.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public static implicit operator C(Delegate d) { ... }\n}\n\nC c;\nc = () => 1;      // error: cannot convert lambda expression to type 'C'\nc = (C)(() => 2); // error: cannot convert lambda expression to type 'C'\n```\n\n----------------------------------------\n\nTITLE: Extensions Disambiguation Syntax Exploration\nDESCRIPTION: Investigation of potential syntax options for disambiguating extension types, including member-focused approaches and various syntactic forms for referencing extensions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-01-22.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nrange = MyExtension.op_Plus(range, 5);\n```\n\n----------------------------------------\n\nTITLE: Classic extension method overload resolution example 2\nDESCRIPTION: This example demonstrates how classic extension methods are resolved resulting in an ambiguous call. When multiple extension methods are applicable and none is better than the other, the call results in an ambiguity error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n\"\\\".M(\\\"\"); // ambiguous\\n\\npublic static class E \\n{\\n    public static void M(this object o, string s) { }\\n    public static void M(this string s, object o) { }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Nullability in Union Structs\nDESCRIPTION: Shows how to declare a nullable union struct variable using the nullability notation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nU? u = null;\n```\n\n----------------------------------------\n\nTITLE: Full Generated Class Implementation\nDESCRIPTION: Demonstrates the complete generated code including initonly properties, protected copy constructor, and With method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nclass Point\n{\n    public initonly int X { get; }\n    public initonly int Y { get; }\n\n    public Point(int x, int y)\n    {\n        X = x;\n        Y = y;\n    }\n\n    protected Point(Point other)\n    : this(other.X, other.Y)\n    { }\n\n    [WithConstructor]\n    public virtual Point With() => new Point(this);\n\n    public void Deconstruct(out int X, out int Y)\n    {\n        X = this.X;\n        Y = this.Y;\n    }\n\n    // Generated equality\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ImmutableArray Nullability Issue in C#\nDESCRIPTION: This code snippet illustrates the current issue with ImmutableArray and defaultable value types, where no warning is given for potentially null reference exceptions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// ImmutableArray\nImmutableArray<int> arrOpt = default;\nforeach (var item in arr) // no warning, NRE at runtime\n{\n    Console.Write(item);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Underlying Type Members in C# Extension Types\nDESCRIPTION: Demonstrates the desired behavior for accessing members of the underlying type within an extension type. This functionality is not currently supported but is planned for implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-06-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nextension E for C\n{\n  void M()\n  {\n    this.MethodFromUnderlying(); // problem\n    MethodFromUnderlying(); // problem\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating first-class span types problem in Expression lambda (C#)\nDESCRIPTION: This example demonstrates how first-class span types can lead to runtime exceptions when used within an Expression lambda. The Contains method with a ReadOnlySpan parameter is selected, causing issues during compilation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/ignore-overloads-in-expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nExpression<Func<string[], string, bool>> expr =\n    (x, y) => x.Contains(y); // System.MemoryExtensions.Contains<T>(this ReadOnlySpan<T>, T)\n\nvar f = expr.Compile(preferInterpretation: true); // Exception\n```\n\n----------------------------------------\n\nTITLE: Target Typing with List<T> for IEnumerable<T> in C#\nDESCRIPTION: This example shows how collection expressions would work if the compiler implicitly used `List<T>` when targeting `IEnumerable<T>`.  It provides simplicity and brevity, but introduces performance and safety concerns due to the mutable nature of `List<T>`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvoid DoSomething(IEnumerable<int> values) { ... }\n\n// Legal. Is equivalent to `DoSomething(new List<int> { 1, 2, 3 })`\nDoSomething([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Task<never> Usage Example\nDESCRIPTION: Example demonstrating the proposed 'never' return type in the context of async methods that only throw exceptions. This shows how the never type could be used with generic Task returns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-24.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nTask<never>\n```\n\n----------------------------------------\n\nTITLE: Translation of 'with' Expression in C#\nDESCRIPTION: Shows how a 'with' expression is translated by the compiler into a constructor call that preserves the unchanged values from the original record.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Notes.md#2025-04-21_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nnew Point(p.X, 4)\n```\n\n----------------------------------------\n\nTITLE: Discussion Section Header\nDESCRIPTION: Markdown formatted section headers for the main discussion topics\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-02.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n## Discussion\n\n### Partner scenarios in roles and extensions\n```\n\n----------------------------------------\n\nTITLE: ReadOnlySpan vs String Overload Resolution\nDESCRIPTION: Example showing method overload resolution between string and ReadOnlySpan<char> parameters with collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-02.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M1(string s) {}\nvoid M1(ReadOnlySpan<char> r) {}\nM1(['a', 'b', 'c'])\n```\n\n----------------------------------------\n\nTITLE: Defining a Sealed Record Class Inheriting from an Abstract Record in C#\nDESCRIPTION: Shows how to create a sealed record class that inherits from an abstract record class. This sealed record adds a Gpa property while inheriting the Name property from Person.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Student(string Name, decimal Gpa) : Person(Name);\n```\n\n----------------------------------------\n\nTITLE: Showing Natural Type Inference for Tuple Literals in C#\nDESCRIPTION: Examples of how tuple literals acquire their natural type when not part of a conversion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvar t = (\"John\", 5); // Ok: the type of t is (string, int)\nvar t = (null, 5); //   Error: null doesn't have a type\n```\n\n----------------------------------------\n\nTITLE: Invalid Extension Declaration in C#\nDESCRIPTION: This code snippet demonstrates an invalid extension declaration due to the type parameter `T1` not being inferrable. The underlying type `IEnumerable<int>` does not use the type parameter `T1`. The code also shows a duplicate declaration error for the `IsEmpty` property, as it is defined for both `IEnumerable<T3>` and `IEnumerable<T3>?`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\npublic static class MyExtensions\n{\n    extension<T1>(IEnumerable<int>) // Error! T1 not inferrable\n    {\n        ...\n    }\n    extension<T2>(IEnumerable<T2>)\n    {\n        public bool IsEmpty { get ... }\n    }\n    extension<T3>(IEnumerable<T3>?)\n    {\n        public bool IsEmpty { get ... } // Error! Duplicate declaration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Field-Targeted Attributes to Auto-Implemented Properties in C#\nDESCRIPTION: This example demonstrates the proposed syntax for applying a NonSerialized attribute to the backing field of an auto-implemented property in a serializable class. The field: prefix indicates that the attribute should target the backing field rather than the property itself.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/auto-prop-field-attrs.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Serializable]\npublic class Foo \n{\n    [field: NonSerialized]\n    public string MySecret { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Raw C# Code References\nDESCRIPTION: Markdown documentation containing code-like references to C# language features including `BinaryCompatOnlyAttribute`, `params`, `Program`, `ReadOnlySpan`, `unsafe`, and other C# specific syntax elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `BinaryCompatOnlyAttribute`\n- `params` improvements\n- `Program`\n- `ReadOnlySpan`\n- `unsafe`\n- `Create` methods\n- `lock` statement pattern\n- `is` expression\n```\n\n----------------------------------------\n\nTITLE: Ref Ternary Usage Examples\nDESCRIPTION: Various usage examples of ref ternary expressions including passing by reference, returning by reference, and assignment operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/conditional-ref.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// pass by reference\nfoo(ref (arr != null ? ref arr[0]: ref otherArr[0]));\n\n// return by reference\nreturn ref (arr != null ? ref arr[0]: ref otherArr[0]);\n\n// assign to\n(arr != null ? ref arr[0]: ref otherArr[0]) = 1;\n\n// use in regular context\nint x = (arr != null ? ref arr[0]: ref otherArr[0]);\n```\n\n----------------------------------------\n\nTITLE: Implementing TryGetValue with MaybeNullWhen Attribute\nDESCRIPTION: Example showing nullable attribute usage in method body with TryGetValue implementation that currently triggers a warning.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-06.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nbool TryGetValue<T>([MaybeNullWhen(false)]out T t)\n{\n    return other.TryGetValue(out t); // currently warns\n}\n```\n\n----------------------------------------\n\nTITLE: Using Readonly Locals in Lambda Expressions in C#\nDESCRIPTION: Demonstrates the use of readonly locals in lambda expressions to prevent accidental mutation of captured variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/readonly-locals.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly long index = ...;\nParallel.ForEach(data, item => {\n    T element = item[index];\n    index = 0; // Error: can't assign to readonly locals outside of declaration\n});\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Example with Lambda Return Types\nDESCRIPTION: Implementation using proposed lambda return type syntax with explicit return type declarations\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-03.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Mvc;\n\nvar app = WebApplication.Create(args);\n\napp.MapAction([HttpPost(\"/\")] ([FromBody] Todo todo) : Todo => todo);\napp.MapAction([HttpGet(\"/\")] () : Todo => new(Id: 0, Name: \"Play more!\", IsComplete: false));\n\napp.MapAction([HttpGet(\"/id/{id?}\")] ([FromRoute] int? id) : IResult => \n    id is null ?\n    new StatusCodeResult(404) :\n    new JsonResult(new Todo(Id: id.Value, Name: \"From id!\", IsComplete: false)));\n\nawait app.RunAsync();\n\nrecord Todo(int Id, string Name, bool IsComplete);\n```\n\n----------------------------------------\n\nTITLE: Defining NotNull Constraint in C# ANTLR Grammar\nDESCRIPTION: ANTLR grammar rule for defining the 'notnull' constraint in C#, which specifies that a type parameter may not be a nullable type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nprimary_constraint\n    : ...\n    | 'notnull'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Local Function with Var Return Type in C#\nDESCRIPTION: Example of a proposed syntax allowing local functions to be declared with var return type, demonstrating string concatenation of person properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nvar fullName(Person p) => $\"{p.First} {p.Last}\"; // yeah, it's probably going to be a string.\n```\n\n----------------------------------------\n\nTITLE: Inferred Tuple Element Names in C#\nDESCRIPTION: Example showing how tuple element names can be inferred from variable names and explicit declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-05.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nint a = 1;\n...\nvar t = (a, b: 2, 3); // (int a, int b, int)\n```\n\n----------------------------------------\n\nTITLE: Collection Expression with List and Conditional in C#\nDESCRIPTION: Demonstrates a collection expression assigned to `List<Predicate>`, showcasing how the target type `Predicate` influences the type of elements within the conditional expression `[_ => true]`. This ensures the overall expression succeeds, reflecting contextual type influence.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2024-01-23.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n\t\t- `List<Predicate> list = [a, b, .. c ? [_ => true] : []]`.  Similarly, the use of `Predicate` here in the target should help influence the type of `[_ => true]` such that this code succeeds.\n```\n\n----------------------------------------\n\nTITLE: Explicit Coercion Between Ad Hoc Union Types in C#\nDESCRIPTION: Demonstrates explicit coercion between ad hoc union types when at least one member type of the source can be coerced to a member type of the target.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n(float or double) value = 10.0;\n(int or short) value2 = (int or short)value;\n```\n\n----------------------------------------\n\nTITLE: Defining a Positional Record with Data Properties in C#\nDESCRIPTION: Example syntax proposal for positional records with explicit 'data' keyword to indicate public init-only properties. This approach would make the 'data' keyword generalizable to other contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-11.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nrecord Person(data string FirstName, data string LastName);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Attribute Behavior for Generic Types in C#\nDESCRIPTION: This code snippet shows the expected behavior of nullable attributes on properties for generic types in C#, including both constrained and unconstrained generic scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-09-11.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing System.Diagnostics.CodeAnalysis;\n\nclass Box<T> {\n    T _value;\n\n    [AllowNull]\n    T Value {\n        get => _value;\n        set {\n            if (value != null) {\n                _value = value;\n            }\n        }\n    }\n    \n    static void TestConstrained<U>(Box<U> box) where U : class {\n        box.Value = null; // ok\n        Console.WriteLine(box.Value.ToString()); // ok\n\n        if (box.Value == null) {\n            Console.WriteLine(box.Value.ToString()); // warning\n        }\n    }\n\n    static void TestUnconstrained<U>(Box<U> box, U value) {\n        box.Value = default(U); // 'default(U)' always produces a warning when U could be a non-nullable reference type\n        Console.WriteLine(box.Value.ToString()); // ok\n\n        box.Value = value; // ok\n        Console.WriteLine(box.Value.ToString()); // ok\n\n        if (box.Value == null) {\n            Console.WriteLine(box.Value.ToString()); // warning\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Range Syntax Exploration in C#\nDESCRIPTION: Various syntax examples exploring different range notation options, including discussions of ambiguity with colons and other language features.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-31.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\na[3..+7]\na[3.+7]\na[3.:7] // Not ambiguous   object o = b ? 3..: 7.: 9 ; \na[3..:7] // object o = b ? 3..: 7..: 9 ; find the range!\na[3:.7] // NO\na[3::7] // NO?\na[3:7] // NO\na[x:y] // NO\n```\n\n----------------------------------------\n\nTITLE: Subsumption in Pattern Matching with ReadOnlySpan<char>\nDESCRIPTION: Illustrates a switch expression to determine the numeric representation of a ReadOnlySpan<char> based on its pattern, checking various list and constant string patterns. Some patterns are marked as unreachable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/pattern-match-span-of-char-on-string.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstatic int ToNum(ReadOnlySpan<char> s)\n{\n    return s switch\n    {\n        { Length: 0 } => 0,\n        \"\" => 1,        // error: unreachable?\n        ['A',..] => 2,\n        \"ABC\" => 3,     // error: unreachable?\n        _ => 4,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Method with Struct Constraint\nDESCRIPTION: This code snippet shows a generic method with a struct constraint, demonstrating how the current language design allows new instances of struct type parameters to be created. This behavior would need to be reconsidered with non-defaultable struct types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-07-01.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M<T>() where T : struct\n{\n    var y = new T(); // Perfectly valid\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Issues with Signed Bitwise Operations in C#\nDESCRIPTION: This code snippet illustrates a potential problem with using signed bitwise operations on nint types that are converted from IntPtr. The right shift operation may produce unexpected results if the value is intended to represent an unsigned pointer.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-23.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nIntPtr M(IntPtr p)\n{\n    nint x = p;\n    x >> 1;\n    return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Literal Pattern Matching Syntax - C#\nDESCRIPTION: The code snippet demonstrates how pattern matching might be used with dictionary literals. It showcases a potential syntax for checking if a dictionary contains a specific key and extracting its value. It also refers to a community proposal for indexer patterns, providing context for alternative syntax considerations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-06.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"var dict2 = [ \\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\" ];\\n\\nif (dict5 is [ \\\"key1\\\": var value ])\\n{\"\n```\n\n----------------------------------------\n\nTITLE: Tuple Deconstruction Pattern Examples in C#\nDESCRIPTION: Various syntax examples for tuple deconstruction patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n(x) = e;\n(x, (y)) = e;\n```\n\n----------------------------------------\n\nTITLE: Modifying Binary Operator Declaration Requirement in C#\nDESCRIPTION: This code snippet displays the proposed modification to the C# specification concerning binary operator declarations, specifically for shift operators. The original specification mandated the second parameter of a binary `<<` or `>>` operator to be of type `int` or `int?`. This change removes that restriction, allowing the second parameter to be of any type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/relaxing_shift_operator_requirements.md#2025-04-21_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n-*  A binary `<<` or `>>` operator must take two parameters, the first of which must have type `T` or `T?` and the second of which must have type `int` or `int?`, and can return any type.\n+*  A binary `<<` or `>>` operator must take two parameters, the first of which must have type `T` or `T?`, and can return any type.\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Method with new() Constraint in C#\nDESCRIPTION: Demonstrates a generic method with a new() constraint, which should call Activator.CreateInstance instead of using default(T) for structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic T M<T>() where T: new() { return new T(); }\n```\n\n----------------------------------------\n\nTITLE: Using CollectionsMarshal for ImmutableArray with Direct Storage in C#\nDESCRIPTION: In this snippet, the CollectionsMarshal class provides a factory method for creating ImmutableArray instances with optimized span usage, allowing direct manipulation of underlying storage during construction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[CollectionBuilder(typeof(CollectionsMarshall), \"Create\")]\npublic struct ImmutableArray<T> { /*...*/ }\n\n// In System.Runtime.CompilerServices\npublic static class CollectionsMarshall\n{\n    public static Span<T> Create<T>(int capacity, out ImmutableArray<T> result);\n    // or:\n    public static void Create<T>(int capacity, out ImmutableArray<T> result, out Span<T> storage);\n}\n\n// code:\nImmutableArray<string> values = [\"a\", \"b\", \"c\"];\n```\n\n----------------------------------------\n\nTITLE: Record Struct Implementation Example\nDESCRIPTION: Complete implementation example of a record struct including equality members and deconstructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic struct Pair(object First, object Second);\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic struct Pair : IEquatable<Pair>\n{\n    public object First { get; }\n    public object Second { get; }\n    public Pair(object First, object Second)\n    {\n        this.First = First;\n        this.Second = Second;\n    }\n    public bool Equals(Pair other)\n    {\n        return Equals(First, other.First) && Equals(Second, other.Second);\n    }\n    public override bool Equals(object other)\n    {\n        return (other as Pair)?.Equals(this) == true;\n    }\n    public override int GetHashCode()\n    {\n        return (First?.GetHashCode()*17 + Second?.GetHashCode()).GetValueOrDefault();\n    }\n    public Pair With(object First = this.First, object Second = this.Second) => new Pair(First, Second);\n    public void Deconstruct(out object First, out object Second)\n    {\n        First = self.First;\n        Second = self.Second;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Runtime Ambiguity Example in C# Interface Implementation\nDESCRIPTION: Demonstrates a potential runtime ambiguity scenario when multiple interfaces provide implementations of the same method. Shows how changes to interface implementations can create conflicts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/CLR-2017-03-23.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IA\n{\n    void M();\n}\npublic interface IB : IA\n{\n    override void IA.M() { WriteLine(\"IB\"); }\n}\npublic interface IC : IA\n{\n}\nclass C : IB, IC\n{\n    static void Main()\n    {\n        IA a = new C();\n        a.M();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Method Type Inference Example\nDESCRIPTION: Demonstrates type inference complexities with extension methods, showcasing differences between current extension methods and proposed extension types\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-02.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public void M(I<string> i, out object o)\n    {\n        i.M(out o); // infers E.M<object>\n        i.M2(out o); // error CS1503: Argument 1: cannot convert from 'out object' to 'out string'\n    }\n}\npublic static class E\n{\n   public static void M<T>(this I<T> i, out T t) { t = default; }\n}\npublic static extension E2<T> for I<T>\n{\n   public static void M2(out T t) { t = default; }\n}\npublic interface I<out T> { }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Proposed Tuple Member Direct Assignment in C#\nDESCRIPTION: Illustrates a proposed (but rejected) syntax for directly assigning tuple members in method returns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\n(string first, string last) GetName()\n{\n  first = ...; last = ...; // Assign the result directly\n  return;                  // No need to return an explicit value\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Method with Null Check and Type Inference\nDESCRIPTION: Shows type inference behavior in generic context with null checking and subsequent method call.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-05.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvoid M<T>(T x) \n{\n    if (x == null) throw;\n    var y = x;\n    var z = M(y); // What is the inferred type?\n    z.Value = null; // warning?\n}\n...\nBox<T> M<T>(T t) => new Box(t);\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax Proposals for List Slice Patterns in C#\nDESCRIPTION: Comparison of syntax options for slice patterns in list matching, showing variations with and without spaces after the slice operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-09-22.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ne is [ first, .. var rest ] // Space\ne is [ first, ..var rest ] // No space\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Syntax Examples in C#\nDESCRIPTION: Examples demonstrating various pattern matching syntax options including empty tuples, single-element tuples, and named patterns\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-05.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nif (e is ()) ...\n\nif (e is (1) _) ...\nif (e is (x: 1)) ...\nif (e is (1, 2)) ...\n```\n\n----------------------------------------\n\nTITLE: Using Null Checking Operator with Collections\nDESCRIPTION: Demonstrates usage of the postfix ! operator to assert non-nullability when the compiler cannot infer it from context. Shows how it can be used with property access on known non-null objects.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-08-18.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nif (person.Kind == Student) \n{\n  List<Course> courses = person.Courses!; // I know it's not null for a student, but the compiler doesn't.\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Target-typed new-expression with Nullable Value Types in C#\nDESCRIPTION: Shows how target-typed new-expressions could be used with nullable value types, allowing construction of the underlying type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-25.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nS? s = new (){}\n```\n\n----------------------------------------\n\nTITLE: Grammar Changes for Using Alias Directive in C#\nDESCRIPTION: Proposed grammar modification to the C# language specification to allow using alias directives to reference any type, not just named types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/using-alias-types.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nusing_alias_directive\n-    : 'using' identifier '=' namespace_or_type_name ';'\n+    : 'using' identifier '=' (namespace_name | type) ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Proposed Primary Constructor with Public Property in C#\nDESCRIPTION: Example of a potential syntax for a primary constructor that generates a public property. This shows how member syntax might be allowed in the parameter list to give users more control over declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-04.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Person(\n    public string Name { get; init; }\n);\n```\n\n----------------------------------------\n\nTITLE: ReadOnlySpan Preference Breaking Change\nDESCRIPTION: Shows how the preference of ReadOnlySpan over Span can break existing code, particularly when overloads differ by return type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\ndouble[] x = new double[0];\nSpan<ulong> y = MemoryMarshal.Cast<double, ulong>(x); // previously worked, now a compilation error (returns ReadOnlySpan, not Span)\nSpan<ulong> z = MemoryMarshal.Cast<double, ulong>(x.AsSpan()); // workaround\n\nstatic class MemoryMarshal\n{\n    public static ReadOnlySpan<TTo> Cast<TFrom, TTo>(ReadOnlySpan<TFrom> span) => default;\n    public static Span<TTo> Cast<TFrom, TTo>(Span<TFrom> span) => default;\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Literal Syntax Options - C#\nDESCRIPTION: The code snippet presents various syntax options considered for dictionary literals in C#. It shows different ways of representing key-value pairs within square brackets or curly braces, using colons or fat arrows to separate keys and values. These examples illustrate the syntax under consideration and the trade-offs between different options.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-06.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"var dict1 = { \\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\" };\\n\\nvar dict2 = [ \\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\" ];\\n\\nvar dict3 = [ [\\\"key1\\\"] = \\\"value1\\\", [\\\"key2\\\"] = \\\"value2\\\" ];\\n\\nvar dict4 = [ \\\"key1\\\" => \\\"value1\\\", \\\"key2\\\" => \\\"value2\\\" ];\"\n```\n\n----------------------------------------\n\nTITLE: Importing Static Members in C#\nDESCRIPTION: Demonstrates the syntax for importing static members from a type. This snippet shows the adopted syntax for the 'using static' feature, which allows importing static members without specifying 'static' keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-10.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing System.Console;\n```\n\n----------------------------------------\n\nTITLE: Generic List with Unsafe Array Example\nDESCRIPTION: Example of unsafe pointer type usage within generic type parameters, demonstrating the enforcement hole being discussed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-03-13.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nList<int*[]>\n```\n\n----------------------------------------\n\nTITLE: Method Group Inference with Default Parameters in C#\nDESCRIPTION: Demonstrates current behavior of method group inference with default parameters, which will be changed in C# 11 to generate custom delegate types. Shows potential issues with the current approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar m = M; // Infers Action<int>\nm(); // Error: no value provided for arg0\n\nvoid M(int i = 1) {}\n```\n\n----------------------------------------\n\nTITLE: Value Deconstruction in C#\nDESCRIPTION: Example of unconditional deconstruction syntax for extracting values from structured types. Shows both method declaration for supporting deconstruction and usage syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n(var x, var y) = getPoint();\n\nclass Point {\n    public Point(int x, int y) {...}\n    void Deconstruct(out int x, out int y) { ... }\n    static bool Match(Point p, out int x, out int y) ...\n    static bool Match(JObject json, out int x, out int y) ...\n}\n```\n\n----------------------------------------\n\nTITLE: Type Inference Changes for C# Extension Methods\nDESCRIPTION: This snippet compares type inference between classic and new extension methods, illustrating the differences in how arguments affect inference of type parameters, with an example including method parameters and type argument inference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/implicit-compatibility-for-ported-extension-methods.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(I<string> i, out object o)\n{\n    i.M1(out o); // infers E.M1<object>\n    i.M2(out o); // infers E.M2<object>\n}\n\npublic static class E\n{\n   public static void M1<T>(this I<T> i, out T t) { ... }\n   extension<T>(I<T> i)\n   {\n      public void M2(out T t) { ... }\n   }\n}\npublic interface I<out T> { }\n```\n\n----------------------------------------\n\nTITLE: Implementing Fixed-Size Buffers using InlineArrayAttribute in C#\nDESCRIPTION: This snippet demonstrates how fixed-size buffers are implemented using the InlineArrayAttribute. It shows the equivalent C# code for a class with fixed-size buffer fields, including the Buffer10<T> struct decorated with the InlineArrayAttribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\npublic partial class C\n{\n    public Buffer10<int> buffer1;\n    public readonly Buffer10<int> buffer2;\n}\n\n[System.Runtime.CompilerServices.InlineArray(10)]\npublic struct Buffer10<T>\n{\n    private T _element0;\n\n    [UnscopedRef]\n    public System.Span<T> AsSpan()\n    {\n        return System.Runtime.InteropServices.MemoryMarshal.CreateSpan(ref _element0, 10);\n    }\n\n    [UnscopedRef]\n    public readonly System.ReadOnlySpan<T> AsReadOnlySpan()\n    {\n        return System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(\n                    ref System.Runtime.CompilerServices.Unsafe.AsRef(in _element0), 10);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MaybeNull Field Attribute Example in C#\nDESCRIPTION: Demonstrates the usage of the `[field: MaybeNull]` attribute on a property, which relaxes initialization requirements\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[field: MaybeNull]\npublic string Prop { get => field; set => field = value; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Group Resolution Breaking Change in C#\nDESCRIPTION: Code example showing a potential breaking change in C# where single-method method groups could be affected by natural type assignment. The example demonstrates how method resolution between instance and extension methods could change.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nvar c = new C();\nD.M(c.MyMethod);\n\n// Outputs \"Extension\" today, would print Instance if c.MyMethod had a natural type.\n\nclass C\n{\n    public void MyMethod() { Console.WriteLine(\"Instance\"); }\n}\n\nstatic class CExt\n{\n    public static void MyMethod(this C c, string s) { Console.WriteLine(\"Extension\"); }\n}\n\nclass D\n{ \n    public static void M(Delegate d) { d.DynamicInvoke(); }\n    public static void M(Action<string> a) { a(\"\"); }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern-Based Using Code Generation\nDESCRIPTION: Demonstrates the code generation pattern for pattern-based using statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/using.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n{\n\t  Resource r = new Resource();\n\t  try {\n\t\t    // statements\n\t  }\n\t  finally {\n\t\t    if (r != null) r.Dispose();\n\t  }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Initialization in C#\nDESCRIPTION: This C# code shows collection expressions being used to initialize properties of a class implementing `ITaggable`. It demonstrates the use of `[]` to initialize an `IReadOnlyList<OrderTag>` with an efficient empty singleton. It also shows the use of `[]` to initialize an `IList<int>` which, while technically not guaranteed, defaults to `List<T>`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nclass Order : ITaggable\n{\n    // Legal. An efficient 'empty', read-only singleton will be used.\n    public IReadOnlyList<OrderTag> Tags { get; } = [];\n\n    // Legal. Equivalent to: `{ get; } = new List<int>()`, \n    // though we technically would not guarantee `List<T>`\n    public IList<int> ProductIds { get; } = [];\n}\n\n```\n\n----------------------------------------\n\nTITLE: Previous Behavior: Errors with Optional and Params in Lambdas\nDESCRIPTION: Demonstrates the errors generated before C# 12 when attempting to use optional parameters or params arrays in lambda expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar addWithDefault = (int addTo = 2) => addTo + 1; // error CS1065: Default values are not valid in this context.\nvar counter = (params int[] xs) => xs.Length; // error CS1670: params is not valid in this context\n```\n\n----------------------------------------\n\nTITLE: Async Where Extension Methods Overloads\nDESCRIPTION: Example showing potential overloads of the Where extension method combining sync/async enumerables with sync/async predicates.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static IEnumerable<T> Where<T>(this IEnumerable<T> source, Func<T, bool> predicate);\npublic static IAsyncEnumerable<T> Where<T>(this IAsyncEnumerable<T> source, Func<T, bool> predicate);\npublic static IAsyncEnumerable<T> Where<T>(this IEnumerable<T> source, Func<T, Task<bool>> predicate);\npublic static IAsyncEnumerable<T> Where<T>(this IAsyncEnumerable<T> source, Func<T, Task<bool>> predicate);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Records Syntax in C#\nDESCRIPTION: Example showing the proposed syntax for positional records in C#, using primary constructor-like parameter declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-22.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C(X x, Y y, Z z)\n```\n\n----------------------------------------\n\nTITLE: Defining Deconstruct Extension Methods in C#\nDESCRIPTION: This code shows three different ways of defining a Deconstruct extension method. The first two (with 'this' and 'this in') are eligible as deconstructors, while the third (with 'this ref') is not considered a valid deconstructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-24.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic static void Deconstruct(this int i, out int x, out int y);     // 1\npublic static void Deconstruct(this in int i, out int x, out int y);  // 2\npublic static void Deconstruct(this ref int i, out int x, out int y); // 3\n```\n\n----------------------------------------\n\nTITLE: Grammar Definition for Binary Literals in ANTLR\nDESCRIPTION: The formal ANTLR grammar specification for adding binary literals to the C# language, including the syntax for binary-integer-literal, binary-digits, and binary-digit productions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/binary-literals.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\ninteger-literal:\n    : ...\n    | binary-integer-literal\n    ;\nbinary-integer-literal:\n    : `0b` binary-digits integer-type-suffix-opt\n    | `0B` binary-digits integer-type-suffix-opt\n    ;\nbinary-digits:\n    : binary-digit\n    | binary-digits binary-digit\n    ;\nbinary-digit:\n    : `0`\n    | `1`\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ~ Operator for End Indexing in C#\nDESCRIPTION: Example showing how the existing bitwise complement operator (~) could be repurposed to represent indices from the end of a sequence, where ~0 equals -1, ~1 equals -2, etc.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-05.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n~0  // -1 (last element)\n~1  // -2 (second to last element)\n```\n\n----------------------------------------\n\nTITLE: Target-typed new with Delegates and Tuples in C#\nDESCRIPTION: Examples showing target-typed new usage with delegates and tuples, including both valid and redundant cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-new.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n(int a, int b) t = new(1, 2); // \"new\" is redundant\nAction a = new(() => {}); // \"new\" is redundant\n\n(int a, int b) t = new(); // OK; same as (0, 0)\nAction a = new(); // no constructor found\n```\n\n----------------------------------------\n\nTITLE: Examples of Array Creation with Inline Array Types in C#\nDESCRIPTION: This code snippet demonstrates various ways to create arrays that incorporate anonymous inline array types as element types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nnew int[2][5];\nnew int[][5] {default, default};\nnew [] {default(int[5]), default(int[5])};\n```\n\n----------------------------------------\n\nTITLE: Custom AsyncMethodBuilder Example\nDESCRIPTION: Demonstrates applying a custom async method builder to a specific method using the new AsyncMethodBuilderAttribute\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/async-method-builders.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<>))]\nstatic async ValueTask<int> ExampleAsync() { ... }\n```\n\n----------------------------------------\n\nTITLE: Deconstruction in Query Expressions\nDESCRIPTION: Example showing desired syntax for using deconstruction in query expressions to break down tuples into components.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nfrom (x, y) in points\nlet (dx, dy) = (x - x0, y - y0)\nselect Sqrt(dx * dx + dy * dy)\n```\n\n----------------------------------------\n\nTITLE: Implementing Exhaustive Switch Statements with Null Cases in C#\nDESCRIPTION: This code snippet demonstrates how to make the previous switch statements truly exhaustive by adding null cases for both the Animal and Box<Animal> types. It addresses the missing null checks in the previous example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-05-14.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nint M(Animal a)\n{\n    return a switch \n    {\n        Cat c => 1,\n        Dog d => 2,\n        null  => 3\n    }\n}\nint M(Box<Animal> b)\n{\n    return b switch \n    {\n        Box(Cat c) => 1,\n        Box(Dog d) => 2,\n        Box(null)  => 3,\n        null       => 3\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Setter Analysis for Non-Null Fields in C#\nDESCRIPTION: This snippet shows a potential warning scenario where a non-null field is dereferenced in a setter before initialization, which could lead to a null reference exception.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public C() { Prop = \"...\" };\n\n    public string Prop\n    {\n        get;\n        set\n        {\n            // CS8602 Dereference of a possibly null reference.\n            Console.WriteLine(field.Length);\n                              ~~~~~\n            field = value;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Syntax for Primary Constructor Body and Validator in C#\nDESCRIPTION: Illustrates the proposed syntax for including both a primary constructor body and a validator (final initializer) in a class with a primary constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-27.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nclass TypeName(int X, int Y)\n{\n    public TypeName\n    {\n        // constructor\n    }\n\n    init\n    {\n        // validator\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Warnings for Unconstrained Type Parameters in C#\nDESCRIPTION: Shows examples of warnings that occur when working with unconstrained type parameters in the context of nullable reference types. It demonstrates warnings for dereferencing without a null check and creating potentially null values for non-nullable reference types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-14.md#2025-04-23_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar s = t.ToString(); // warning: dereference without null check\nT t = default(T); // warning: may be creating null value of non-nullable ref type\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays and Nullable Types of Tuples in C#\nDESCRIPTION: Examples showing the intended syntax for creating arrays of tuple types and nullable tuple instances using the new operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-10-18.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar array = new (int x, int y)[10];   // Absolutely\nvar nullable = new (int x, int y)?(); // Why not?\n```\n\n----------------------------------------\n\nTITLE: Array Start/Count Range Syntax in C#\nDESCRIPTION: Shows proposed syntax for array slicing using start and count notation. The +n notation indicates counting forward n elements from the start position.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-31.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\na[5..+10] // Starts at 5, goes to 15 (exclusive)\na[-10..+3] // Starts at length-10, goes to length-7 (exclusive)\n```\n\n----------------------------------------\n\nTITLE: Extension Method Static Implementation Pattern\nDESCRIPTION: Represents the new approach for implementing extensions as static methods rather than using Unsafe.As, similar to current extension methods. This approach maintains binary compatibility and allows for preview releases in .NET 9.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-12.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nUnsafe.As // Previous rejected approach\n// New approach will use static methods similar to current extension methods\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conflicting Override of Default Implementations in C#\nDESCRIPTION: This snippet illustrates a scenario where ambiguous overrides can occur at runtime due to multiple interface implementations. The conclusion was to throw an exception at call time, similar to Java's approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-17.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M1(); }\n\ninterface I2 : I1 { override void M1() { ... } } \n\ninterface I3 : I1 { override void M1() { ... } } \n\nclass C : I2, I3 {} // what happens when you load?\n\nC x;\nx.M1(); // what happens when you call?\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution Example with UTF-8 Literals\nDESCRIPTION: Code showing potential ambiguity in method overload resolution with string literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nM(\"\");\nstatic void M1(ReadOnlySpan<char> charArray) => ...;\nstatic void M1(byte[] byteArray) => ...;\n```\n\n----------------------------------------\n\nTITLE: Defining Parenthesized Patterns in ANTLR Grammar for C#\nDESCRIPTION: This ANTLR grammar snippet defines the syntax for parenthesized patterns in C# 9.0, allowing programmers to override precedence in pattern matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nprimary_pattern\n    : parenthesized_pattern\n    | // all of the existing forms\n    ;\nparenthesized_pattern\n    : '(' pattern ')'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Constructor Base Initialization with Expression Variable\nDESCRIPTION: Example showing expression variable declaration in a constructor's base initializer, where the variable is intended to be accessible throughout the constructor body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-08-24.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic C() : base(out int x)\n{\n\t// use x?\n}\n```\n\n----------------------------------------\n\nTITLE: Using Clauses as Statements for Extension Methods in C#\nDESCRIPTION: Demonstrates using clauses within blocks to scope extension method availability, effectively modifying their accessibility inline without altering the class-wide setup.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\nusing static MyExtensions \n{\n    // Static extension members\n    var range = IEnumerable<int>.Range(0, 10);\n    var empty = IEnumerable<int>.Empty;\n    range += 5;\n    ReadOnlySpan<int> span = range;\n\n    // Instance extension members\n    var query = range.Where(i => i < 10);\n    var isEmpty = query.IsEmpty;\n    var first = query[0];\n    var repetition = new IEnumerable<int>(first, 10);\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Infoof and Nameof Operators in C#\nDESCRIPTION: Shows the proposed syntax for the 'infoof' and 'nameof' operators, where 'infoof' would return reflection information and 'nameof' would return the name as a string.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nPropertyInfo info = infoof(Point.X);\nstring name = nameof(Point.X); // \"X\"\n```\n\n----------------------------------------\n\nTITLE: Example of Expression Variables in While Conditions in C#\nDESCRIPTION: Code example demonstrating the scope question for expression variables used in while loop conditions. The team was considering whether variables declared in the condition should persist across iterations and be in scope after the loop.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-30.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nwhile (src.TryGetNext(out int x))\n{\n\t// Same or different `x` each time around?\n}\n// x in scope here?\n```\n\n----------------------------------------\n\nTITLE: Implementing Native Integer Struct in C#\nDESCRIPTION: Example implementation of a native integer type as a struct wrapping IntPtr. Shows basic structure including a value field and ToString override, representing one possible approach to native integer implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-26.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstruct NativeInt \n{ \n\tpublic IntPtr Value;\n\tpublic override string ToString() { ... }\n}\n/// etc\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution Priority Attribute Usage\nDESCRIPTION: Example showing incorrect usage of OverloadResolutionPriorityAttribute on an override method, which will be marked as an error since these attributes are ignored on overrides.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-17.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass Derived : Base\n{\n    [OverloadResolutionPriority(1)] // This will become an error\n    public override void Method() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Method Group Natural Types with Extension Members in C#\nDESCRIPTION: This code snippet demonstrates a potential confusion related to extension methods and how method groups are resolved in C#. The issue involves interaction between a class method and an extension method for a different class, showcasing the current behavior and the proposed changes to this behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-07-24.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar c = new C();\nvar d = new D();\nd.Del(c.M); // Today, this calles DExt.Del. With the change, it would call D.Del\n\npublic class C\n{\n    public void M() { }\n}\n\npublic static class CExt\n{\n    public static void M(this C c, object o) {}\n}\n\npublic class D\n{\n    public void Del(Delegate d) {}\n}\n\npublic static class DExt\n{\n    public static void Del(this D d, Action<object> action) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Deconstruction in Query Clauses (C#)\nDESCRIPTION: Demonstrates a proposed alternative for carrying multiple range variables forward in a LINQ query using deconstruction syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-03.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nfrom x in e\nlet (m, z) = (M(x, out var y), y)\nselect z;\n```\n\n----------------------------------------\n\nTITLE: Uint128 Checked Operator Implementation Example\nDESCRIPTION: Example showing how uint128 type needs both checked and unchecked logic within checked operators for handling different overflow scenarios in lower and upper bits.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-07.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nresult.lower = left.lower + right.lower; // overflow is expected/by-design\\nresult.upper = left.upper + right.upper; // overflow is an exception for checked operator\n```\n\n----------------------------------------\n\nTITLE: Parameter Null-Checking Syntax Proposals in C#\nDESCRIPTION: Various syntax proposals for parameter null-checking in C# method declarations, including different placements of ! operator, checked keyword, and attribute-based approaches.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-17.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string param!)\nvoid M(string param!!)\nvoid M(string! param)\nvoid M(string !param)\nvoid M(checked string param)\nvoid M(string param ?? throw)\nvoid M(string param is not null)\nvoid M(notnull string param)\nvoid M(null checked string param)\nvoid M(bikeshed string param)\nvoid M([NullChecked(\"Helper\")] string param)\n/* contract precondition forms */\nvoid M(string param) Requires.NotNull(param)\nvoid M(string param) when param is not null\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Importing Static Members in C#\nDESCRIPTION: Shows an alternative syntax that was considered but not adopted for importing static members. This syntax explicitly includes the 'static' keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-10.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nusing static System.Console;\n```\n\n----------------------------------------\n\nTITLE: Using the Unmanaged Constraint with Different Type Arguments in C#\nDESCRIPTION: Demonstration of valid and invalid type arguments when using the unmanaged constraint, showing that only true unmanaged types will compile successfully.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/blittable.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nHash(new Point()); // Okay \nHash(42); // Okay\nHash(\"hello\") // Error: Type string does not satisfy the unmanaged constraint\n```\n\n----------------------------------------\n\nTITLE: Lazy Initialization with Field Keyword in C#\nDESCRIPTION: Demonstrates lazy initialization of a property using the `field` keyword, allowing non-nullable properties to be initialized on-demand\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic List<int> LazyProp => field ??= new();\n```\n\n----------------------------------------\n\nTITLE: Cast Expression Examples\nDESCRIPTION: Shows cast expression behavior with conditional expressions, demonstrating preservation of existing language semantics.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-conditional-expression.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n_ = (short)(b ? 1 : 2);\n```\n\nLANGUAGE: csharp\nCODE:\n```\n_ = (A)(b ? c : d);\n```\n\n----------------------------------------\n\nTITLE: Translating Dictionary Literal to Interface in C#\nDESCRIPTION: Demonstrates how a dictionary literal is translated when the target type is an interface implemented by Dictionary<TKey, TValue>. It creates a temporary dictionary and assigns it to the interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<TKey, TValue> __temp = [...]; /* standard translation */\nI<TKey, TValue> __result = __temp;\n```\n\n----------------------------------------\n\nTITLE: Expression Tree Span Handling\nDESCRIPTION: Demonstrates how span-based overloads are preferred even in expression trees, causing runtime failures due to ref struct limitations in the interpreter engine.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nExpression<Func<int[], int, bool>> exp = (array, num) => array.Contains(num);\nexp.Compile(preferInterpretation: true); // fails at runtime in C# 14\n\nExpression<Func<int[], int, bool>> exp2 = (array, num) => Enumerable.Contains(array, num); // workaround\nexp2.Compile(preferInterpretation: true); // ok\n```\n\n----------------------------------------\n\nTITLE: Complex Method Overload Resolution with Dynamic Parameters\nDESCRIPTION: Code snippet demonstrating method overload resolution scenarios involving different parameter types and params collections, highlighting potential ambiguity in method selection\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-01-29.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Test3()\n{\n    M3(\"3\", [\"4\"]); // Span overload is used, better on the first argument conversion, none is better on the second\n    M3(\"3\", \"4\");   // Ambiguity, better-ness of argument conversions goes in opposite directions.\n                    // Since parameter types are different (\"object, string\" vs. \"string, object\"), tie-breaking rules do not apply\n}\n\nstatic void M3(object x, params string[] y) {}\nstatic void M3(string x, params Span<object> y) {}\n```\n\n----------------------------------------\n\nTITLE: List Pattern Matching Example with Subsumption Error\nDESCRIPTION: Demonstrates a compilation error scenario where two list patterns create identical matching conditions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/list-patterns.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ncase [_, .., 1]: // expr.Length is >= 2 && expr[^1] is 1\ncase [.., _, 1]: // expr.Length is >= 2 && expr[^1] is 1\n```\n\n----------------------------------------\n\nTITLE: Using byte[] with Utf8 String Literals in Async Methods\nDESCRIPTION: Example showing how to create a byte array from a Utf8 string literal in an async context where ReadOnlySpan<byte> cannot be used as a local variable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-18.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nbyte[] myU8 = \"I am an async resilient Utf8 string\"u8;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple Warnings in C# Constructor with Conditional Logic\nDESCRIPTION: This snippet shows how the proposed approach handles multiple return points in a constructor with conditional logic. It demonstrates that warnings are generated independently for each uninitialized property at each return point.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-constructor-analysis.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    string Prop1 { get; set; }\n    string Prop2 { get; set; }\n\n    public C(bool a)\n    {\n        if (a)\n        {\n            Prop1 = \"hello\";\n            return; // warning for Prop2\n        }\n        else\n        {\n            return; // warning for Prop1 and for Prop2\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Discard Parameters in Lambda Expressions with Scope Implications\nDESCRIPTION: Example demonstrating potential scoping issues when using discards in lambda parameters while having an existing '_' variable in scope. This raises questions about whether the '_' inside the lambda body refers to the outer variable or is a discard.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-28.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M()\n{\n    int _ = 0;\n    Action<int, int> a = (_, _) =>\n    {\n        _ = 1; // Is this a discard, or does it capture the local above?\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Using default Operator with Structs in C#\nDESCRIPTION: Example showing the usage of `default(S)` to initialize a struct type, which might trigger warnings in future C# versions when nullary constructors on structs are allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-08-26.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ndefault(S)\n```\n\n----------------------------------------\n\nTITLE: List Pattern Syntax - ANTLR Grammar Proposals\nDESCRIPTION: Four different syntax proposals for list patterns in C#, showing various approaches to combining type patterns, length patterns, and property/list subpatterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-16.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\n1. '[' (pattern (',' pattern)* ']')\n\n2. type? ('(' subpatterns? ')')? ('[' pattern ']')? ('{' property_subpatterns_or_list_element_patterns '}')?  \n\n3. type? ('(' subpatterns? ')')? ('[' pattern ']')? ('{' property_subpatterns '}')? ('{' list_subpatterns '}')?  \n\n4. type? ('(' subpatterns? ')')? ('[' pattern ']')? ('{' property_subpatterns_and_list_element_patterns '}')?  \n```\n\n----------------------------------------\n\nTITLE: Singleton Value Access Shorthand in C#\nDESCRIPTION: Demonstrates the proposed shorthand syntax for accessing singleton instances through static Singleton properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\n// Instead of:\n    \nvar x = U.C.Singleton;\n\n// You can write:\n\nvar x = U.C;\n```\n\n----------------------------------------\n\nTITLE: Inline Array with Record Struct Code Example\nDESCRIPTION: Example code pattern that will be disallowed - applying InlineArrayAttribute to a record struct, which would result in incorrect behavior for Equals, GetHashCode, and ToString implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-17.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[InlineArray(8)]\nrecord struct MyInlineArray // This will become an error\n{\n    private int _element;\n}\n```\n\n----------------------------------------\n\nTITLE: Virtual Method Override with MaybeNull Attribute\nDESCRIPTION: Example showing inheritance scenario with MaybeNull attribute and nullable warnings in method overrides.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-06.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass A<T>\n{\n    [return: MaybeNull]\n    virtual T M();\n}\n\nclass B : A<string>\n{\n    override string? M(); // warns about no [MaybeNull]\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Interceptor Signature Variance with Generics in C#\nDESCRIPTION: This C# code snippet illustrates a use case where interceptor signature variance and advanced generics are needed. It shows how the type parameter `TCaptured` within the return value of `M3<T>` can be used, requiring a parameter type difference between the interceptor and original methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/interceptors/interceptors-issues-2024-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```cs\nclass Original<TCaptured>\n{\n    public void M1()\n    {\n        API.M2(() => this);\n    }\n}\n\nclass API\n{\n    public static void M2(Delegate del) { }\n}\n\nclass Interceptors\n{\n    [InterceptsLocation(/* API.M2(() => this) */)]\n    public static void M3<T>(Func<T> func) { }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Deconstructing a Union Struct Member in C#\nDESCRIPTION: This demonstrates how to deconstruct a union struct member using type tests and pattern matching. The first 'if' statement checks if 'u' is of type 'A' and assigns it to a variable 'a'. The second 'if' uses pattern matching to directly extract the values of 'x' and 'y' from 'A'. The third 'if' uses property pattern matching to extract the value of the property 'y' from A.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nif (u is A a) { ... }\n\nif (u is A(var x, var y)) { ... }\n\nif (u is A { y: var y }) { ... }\n```\n\n----------------------------------------\n\nTITLE: Breaking Change: Method Group Type Inference\nDESCRIPTION: Shows the breaking change in C# 12 where method groups with optional parameters or params arrays are now inferred as anonymous delegate types rather than Action/Func types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvoid WriteInt(int i = 0) {\n  Console.Write(i);\n}\n\nvar writeInt = WriteInt; // Inferred as anonymous delegate type\nDoAction(writeInt, 3); // Error, cannot convert from anonymous delegate type to Action\n\nvoid DoAction(Action<int> a, int p) {\n  a(p);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Binary Comparison Syntax in C#\nDESCRIPTION: Comparison between current syntax and proposed ternary comparison operator syntax for comparing three values in ascending order.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-11-16.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Current syntax\na < b && b < c\n\n// Proposed syntax\na < b < c\n```\n\n----------------------------------------\n\nTITLE: Record Struct Constructor Initializer Requirements in C#\nDESCRIPTION: This example shows that an explicit parameterless constructor within a `record struct` must use a `this` initializer to call either the primary constructor or another explicitly declared constructor. This ensures consistent and proper initialization of the record struct.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n\"record struct R5(int F)\\n{\\n    public R5() { }                  // error: must have 'this' initializer that calls explicit .ctor\\n    public R5(object o) : this() { } // ok\\n    public int F =  F;\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Calling Extension Method as Static Method in C#\nDESCRIPTION: This code snippet demonstrates calling an extension method as a static method. The extension method `IsEmpty` is called using the class name `SomeExtensionsAndStuff` in which it is defined.  The extended object is passed as a parameter to the static method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Extension-API-docs.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nbool empty = SomeExtensionsAndStuff.IsEmpty(sequence);\n```\n\n----------------------------------------\n\nTITLE: Optimizing Blittable Constant Collections in C#\nDESCRIPTION: This code snippet shows an optimization for collection expressions of blittable constants. It uses a static ReadOnlySpan to store the constant values and provides a no-allocation enumeration implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Compiler-synthesized-types.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class BlittableWrapperX : IReadOnlyList<T>, IList<T>, IList\n{\n    // Has no-alloc optimization\n    private static ReadOnlySpan<char> __values => new char[] { 'a', 'b', 'c', 'd', 'e', 'f' };\n\n    public IEnumerator<char> GetEnumerator()\n    {\n        for (int i, n = 6; i < n> i++)\n            yield return __values[i];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Interface Method Warning Example\nDESCRIPTION: Example showing potential warning case for default interface method implementation with ref struct types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-22-ref-struct-interface-examples.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    // Virtual method with default implementation\n    void M() { }\n}\n\n// Invocation of a virtual instance method with default implementation in a generic method that has the `allows ref struct`\n// anti-constraint\nvoid M<T>(T p)\n    where T : allows ref struct, I1\n{\n    p.M(); // Warn?\n}\n```\n\n----------------------------------------\n\nTITLE: Class Hierarchy Example with Checked and Regular Operators #2\nDESCRIPTION: Example demonstrating operator resolution in a class hierarchy where checked and regular operators are defined at different levels. Shows how the checked context influences which overload is selected based on inheritance relationships.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    static void Add(C2 x, C3 y)\n    {\n        object o;\n        \n        // C1.op_CheckedAddition\n        o = checked(x + y);\n        \n        // C2.op_Addition\n        o = unchecked(x + y);\n    }\n}\n\nclass C1\n{\n    public static C1 operator checked + (C1 x, C3 y) => new C3();\n}\n\nclass C2 : C1\n{\n    public static C2 operator + (C2 x, C1 y) => new C2();\n}\n\nclass C3 : C1\n{\n}\n```\n\n----------------------------------------\n\nTITLE: JsonObject Creation with Dynamic Member Names\nDESCRIPTION: Example showing how to construct a JsonObject with dynamic member names using the $ operator in object initializers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-12-16.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvar json = new JsonObject \n{ \n    $foo = 1,\n    $bar = new JsonArray { \"Hello\", \"World\" },\n    $baz = new JsonObject { $x = 1, $y = 2 }\n};\n```\n\n----------------------------------------\n\nTITLE: Shadowing in LINQ Queries Example in C#\nDESCRIPTION: Example demonstrating shadowing in LINQ queries where a variable 'c' is used both as a local variable and as a range variable in a LINQ query. The second example shows the equivalent method-based LINQ syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-16.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// char c;\nvar q = from c in s\n        from c2 in s\n        where c != ' '\n        select c;\nvar q2 = s\n    .SelectMany(c => s, (c, c2) => new { c, c2 })\n    .Where(_x => _x.c != ' ')\n    .Select(_x => _x.c);\n```\n\n----------------------------------------\n\nTITLE: Extension Member Consumption with Disambiguation Example\nDESCRIPTION: Illustrates a strawman approach for disambiguating extension member lookups using a hypothetical '@' syntax. The example shows how type parameters can be inferred from the receiver expression without explicit specification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nstring[] strings = ...;\nvar query  = (strings @ Enumerable).Where(s => s.Length > 10);\n \npublic static class Enumerable\n{\n    extension<T>(IEnumerable<T>)\n    {\n        public IEnumerable<T> Where(Func<T, bool> predicate) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct with Property Setter Compilation Error\nDESCRIPTION: Illustrates the issue of having manually defined setters on properties within structs, which can lead to compilation errors due to definite assignment rules. This code snippet highlights the problem where property-backed fields aren't considered definitely assigned.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/auto-default-structs.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic struct S\n{\n    public int X { get => field; set => field = value; }\n    public S() // error: struct fields aren't fully assigned. But caller can only assign 'this.field' by assigning 'this'.\n    {\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Modeling ref struct constructors in C#\nDESCRIPTION: Demonstrates how constructors for ref structs are analyzed for ref safety, where the compiler models 'this' as an 'out' parameter to ensure that ref parameters can be safely captured as ref fields while preventing unsafe ref escapes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_61\n\nLANGUAGE: c#\nCODE:\n```\nref struct S\n{\n    ref int field;\n\n    public S(ref int f)\n    {\n        field = ref f;\n    }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic static void ctor(out S @this, ref int f)\n{\n    // The ref-safe-context of `ref f` is *return-only* which is also the \n    // safe-context of `this.field` hence this assignment is allowed\n    @this.field = ref f;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating #nullable Pragma Scoping in C#\nDESCRIPTION: Example showing how #nullable pragma context applies based on the last token in type syntax, specifically in generic type parameters\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nDictionary<string,\n#nullable disable\n    string>\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Null-forgiving Operator with Out Parameters in C#\nDESCRIPTION: Examples illustrating various usages of the null-forgiving operator (!) with out parameters and assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nM(out x!);\n```\n\n----------------------------------------\n\nTITLE: Illustrating Scoping Issues in C# Pattern Matching with If-Else Statements\nDESCRIPTION: This code demonstrates potential scoping issues when using pattern matching in if-else statements. It shows how variable redeclaration can cause errors in nested conditions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nif (o is string s) { ... s ... }\nelse if (o is short s) { ... s ... } // error: redeclaration of s\nelse ...\n```\n\n----------------------------------------\n\nTITLE: Lowering List Pattern '{0, 1}' in C#\nDESCRIPTION: Example of lowering a list pattern that checks for a collection with exactly two elements, 0 and 1.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/list-patterns-enumerables.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n@{\n  var helper = new ListPatternHelper(collection, 2, 0);\n\n  helper.TryGetStartElement(index: 0, out var element0) && element0 is 0 &&\n  helper.TryGetStartElement(1, out var element1) && element1 is 1 &&\n  helper.Last()\n}\n```\n\n----------------------------------------\n\nTITLE: ITuple Interface Definition in C#\nDESCRIPTION: Definition of ITuple interface for dynamic deconstructability checking, with Size property and indexed access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-12.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\ninterface ITuple\n{\n    int Size;\n    object this[int i] { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Temporary Variables and Tuple Name Assignments in C#\nDESCRIPTION: Shows how storing a tuple in a temporary variable can lead to different behavior with named tuples, as assignments follow positional rather than named matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-01.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvar tmp = (last: \"Doe\", first: \"John\"); // infers (string last, string first)\n(string first, string last) t8 = tmp;   // assigns by position, so first = \"Doe\"\n```\n\n----------------------------------------\n\nTITLE: Example of Ambiguous Nullability Warnings with Manual Attributes in C#\nDESCRIPTION: A potential issue where nullability warnings target the wrong location (in the property usage) rather than at the source of the issue (the initialization).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T>\n{\n    public C(T[] prop) { Prop = prop; }\n\n    // CS8602: Dereference of a possibly null reference.\n    public T[] Prop { get => (T[])field.Clone(); private set; }\n                                  ~~~~~\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Record Struct Primary Constructors in C#\nDESCRIPTION: Illustrates the rules for record struct primary constructors. Parameterless primary constructors are allowed, and explicit constructors must call the primary constructor, similar to record class types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-28.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nrecord struct R1() // Parameterless primary constructor allowed\n{\n    public R1(int value) : this() { } // Explicit constructor must call primary constructor\n}\n\nrecord struct R2(int Value)\n{\n    public R2() : this(0) { } // Explicit constructor must call primary constructor\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Protocol Members in C#\nDESCRIPTION: Example showing how Objective-C/Swift protocols with optional members are currently projected into C# interfaces, highlighting the limitation of only being able to represent non-optional members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-08.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nprotocol Foo\n{\n    void Hello();\n@optional\n\tint Color { get; set; }\n\tint Bye();\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\ninterface IFoo\n{\n\tvoid Hello();\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Readonly Extension Type Members for Value Types in C#\nDESCRIPTION: Illustrates how to declare readonly members in extension types for value types. This prevents mutation of the receiver and provides similar benefits to passing value types by value in classic extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Compatibility through coexistence between extension types and extension methods.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic extension TupleExtensions for (int x, int y)\n{\n    public readonly int Sum() => x + y; // `this` is readonly and cannot me mutated\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Compiler Directives Grammar in ANTLR\nDESCRIPTION: ANTLR grammar rules defining the syntax for #nullable compiler directives and their actions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\npp_directive\n    : ...\n    | pp_nullable\n    ;\n    \npp_nullable\n    : whitespace? '#' whitespace? 'nullable' whitespace nullable_action pp_new_line\n    ;\n    \nnullable_action\n    : 'disable'\n    | 'enable'\n    | 'restore'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Feature Reference - params IEnumerable\nDESCRIPTION: Reference to proposed feature for supporting params IEnumerable parameters, noted as having too many open questions about exact support scope including Span<T> considerations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-08-31.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nparams IEnumerable\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression with Value Capture in C#\nDESCRIPTION: Illustrates a potential syntax for capturing variables by value in lambda expressions. This would create a copy of the captured variable, preventing the lambda from observing or effecting changes to the original variable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nvar name = GetName();\nvar query = customers.Where([val name]c => c.Name == name);\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation of Language Design Meeting Notes\nDESCRIPTION: Structured markdown document detailing the C# language design meeting agenda, discussions, and conclusions around discriminated unions and collection expression conversions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-24.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# C# Language Design Meeting for July 24th, 2024\n\n## Agenda\n\n- [Discriminated Unions](#discriminated-unions)\n- [Better conversion from collection expression with `ReadOnlySpan<T>` overloads](#better-conversion-from-collection-expression-with-readonlyspant-overloads)\n\n## Quote of the Day\n\n- \"I put that there so people will complain\"\n\n## Discussion\n\n### Discriminated Unions\n\nChampion issue: https://github.com/dotnet/csharplang/issues/113  \nProposal: https://github.com/dotnet/csharplang/blob/18a527bcc1f0bdaf542d8b9a189c50068615b439/proposals/TypeUnions.md\n\nFirst up today, the discriminated unions working group presented the proposal they've been working on for a while to the broader LDM. This was a broad overview session, rather than a deep dive into nitty-gritty\nquestions; there are still plenty of little details that will need to be filled in, but we're cautiously optimistic about this proposal and moving forward with it. There was some concern about some of the\nternary behavior, but we can dig more into that as we bring this proposal back for detailed follow ups in the future.\n\n### Better conversion from collection expression with `ReadOnlySpan<T>` overloads\n\nChampion issue: https://github.com/dotnet/csharplang/issues/8297  \nRelated issue: https://github.com/dotnet/roslyn/issues/73857\n\nWe followed up from [last Wednesday](LDM-2024-07-17.md#better-conversion-from-collection-expression-with-readonlyspant-overloads), revisiting an even narrower proposal; just looking at implicit reference\nconversions, rather than all implicit conversions except numeric conversions. However, LDM still does not prefer the narrow fix; it has edge cases and isn't generalizable. There is some concern that rules around\n`OverloadResolutionPriority` might not work here; `string.Concat` has 15 overloads in .NET 9, and this isn't the type of break-glass scenario `OverloadResolutionPriority` was designed for. Given this, we reaffirm\nthat we want to look into doing the recursive approach, ie better conversion from element.\n\n#### Conclusion\n\nContinue looking into option 3, better conversion from element.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Breaking Change with Value Types in C#\nDESCRIPTION: Illustrates a potential breaking change in existing code if the alternative syntax for conditional ref operations is adopted. This example shows how semantics could change for value types with mutating methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-28.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n(b ? v1 : v2).M();\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Type Declaration with Attributes in C#\nDESCRIPTION: Example showing the proposed syntax for function pointers with calling conventions and attributes. Uses cdecl calling convention and includes SuppressGCTransition and MyFuncAttr attributes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-01.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ndelegate* cdecl[SuppressGCTransition, MyFuncAttr]<void> ptr;\n```\n\n----------------------------------------\n\nTITLE: Tuple Assignment to System.Tuple\nDESCRIPTION: Example showing how tuple literal syntax could be used to construct a System.Tuple instance, demonstrating potential interoperability between ValueTuple and existing tuple-like types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nSystem.Tuple<int, string> t = (5, null);\n```\n\n----------------------------------------\n\nTITLE: Extension method for converting to byte array\nDESCRIPTION: This C# code snippet demonstrates an attempt to use an extension method to convert a collection literal containing an integer to a byte array. The language design team discussed whether element type conversions should be allowed in this scenario, drawing an analogy to tuples.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-07-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar byteArray = [4].ToArray<byte>(); // Converts from int->byte\n```\n\n----------------------------------------\n\nTITLE: Lowering List Pattern '{1, 2, .., 3, 4}' in C#\nDESCRIPTION: Example of lowering a complex list pattern that checks for a collection starting with 1 and 2, ending with 3 and 4, with any number of elements in between.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/list-patterns-enumerables.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n@{\n  var helper = new ListPatternHelper(collection, 2, 2);\n\n  helper.TryGetStartElement(index: 0, out var element0) && element0 is 1 &&\n  helper.TryGetStartElement(1, out var element1) && element1 is 2 &&\n  helper.Count() >= 4 && // `..` with 2 starting patterns and 2 ending patterns\n  helper.GetEndElement(hatIndex: 2) is 3 &&\n  helper.GetEndElement(1) is 4\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Class Syntax in C#\nDESCRIPTION: This code snippet shows a proposed syntax for declaring extension members using an 'extension class'. It includes examples of extending a Person class with static fields, instance methods, instance properties, static properties, and constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-05-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Person\n{\n    public string Name { get; }\n    public Person(string name) { Name = name; }\n}\n\nextension class Enrollee extends Person\n{\n    static Dictionary<Person, Professor> enrollees = new ();                                            // static field\n    public void Enroll(Professor supervisor) { enrollees[this] = supervisor; }                          // instance method\n    public Professor Supervisor => enrollees.TryGetValue(this, out var supervisor) ? supervisor : null; // instance property\n    public static ICollection<Person> Students => enrollees.Keys;                                       // static property\n    public Person(string name, Professor supervisor) : this(name) { this.Enroll(supervisor); }          // constructor\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Program Reference\nDESCRIPTION: Code reference discussing the generated Program class visibility for top-level statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-09.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nProgram\n```\n\n----------------------------------------\n\nTITLE: Demonstration of Pattern Behavior with Constants in C#\nDESCRIPTION: Code snippets demonstrating the current behavior of constants with pattern matching, including warning and error scenarios that might be affected by making patterns into constant expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-11-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic const int A = 4;\npublic  bool B1 = A is 4; // warning CS8520: The given expression always matches the provided constant.\n\npublic bool B2 = A switch { 4 => true }; // warning CS8509: The switch expression does not handle all possible values of its input type (it is not exhaustive). For example, the pattern '0' is not covered.\npublic bool B3 = true is true and false; // error CS8518: An expression of type 'bool' can never match the provided pattern\n```\n\n----------------------------------------\n\nTITLE: Zero and One Element Tuple Syntax Examples in C#\nDESCRIPTION: Shows various syntax examples for zero and one element tuples including deconstruction patterns and return statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar () = e;       // who cares to deconstruct?\nvar (x) = e;      // just get through property?\nvar (x, (y)) = e; // recursive - can't just grab a member\n```\n\n----------------------------------------\n\nTITLE: Example of Ambiguous Checked/Unchecked Operator Selection in C#\nDESCRIPTION: Demonstrates a case where operator selection becomes ambiguous in checked context but resolves in unchecked context. The example shows class hierarchy with C2 inheriting from C1 and different operators defined between classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    static void Add(C2 x, C3 y)\n    {\n        object o;\n        \n        // error CS0034: Operator '+' is ambiguous on operands of type 'C2' and 'C3'\n        o = checked(x + y);\n        \n        // C2.op_Addition\n        o = unchecked(x + y);\n    }\n}\n\nclass C1\n{\n    // Cannot be declared in C# - missing unchecked operator, but could be declared by some other language\n    public static C1 operator checked + (C1 x, C3 y) => new C3();\n}\n\nclass C2 : C1\n{\n    public static C2 operator + (C2 x, C1 y) => new C2();\n}\n\nclass C3 : C1\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax Options for Type of default(T)\nDESCRIPTION: Alternative syntax proposals for expressing \"the type of default(T)\" without using T?, showing the preferred T?? solution that was ultimately chosen.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-25.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M1<T,U>(default(T) x) // X\nvoid M1<T,U>(default<T> x) // Y\nvoid M1<T,U>(T?? x)        // Z\n```\n\n----------------------------------------\n\nTITLE: Basic Bouncer Pattern\nDESCRIPTION: Traditional null check pattern where condition result affects following code blocks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-15.md#2025-04-23_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(object o)\n{\n  if (o == null) throw new ArgumentNullException(nameof(o));\n  ...; // o is known not to be null\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C# 8.0 Index From End Operator\nDESCRIPTION: Shows the '^' operator syntax for indexing from the end of sequences in C# 8.0, which was discussed as an alternative to Python's negative index approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-02.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n^\n```\n\n----------------------------------------\n\nTITLE: Demonstrating uint Pattern Matching Rules in C#\nDESCRIPTION: Code example showing how type tests and constant pattern matching work with uint values, illustrating the requirement for explicit type tests.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-23.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\n\nuint u = 1;\nConsole.WriteLine(u is 1); // true\nConsole.WriteLine(((object)u) is 1); // false\nConsole.WriteLine(((object)u) is uint and 1); // true\nConsole.WriteLine(M1(u)); // false\nConsole.WriteLine(M2(u)); // true\n\nbool M1<T>(T t) => t is 1;\nbool M2<T>(T t) => t is uint and 1;\n```\n\n----------------------------------------\n\nTITLE: Warning for Redundant 'or' Pattern After 'not' in C#\nDESCRIPTION: This snippet describes a compiler warning for detecting redundant 'or' patterns following 'not' in C# pattern matching. The goal is to help users avoid common mistakes by alerting them when an 'or' pattern is unnecessary and might be intended for a different scope. No additional dependencies are required for this feature, and the warning is generated by the C# compiler. It's targeted to catch specific known bad patterns without being exhaustive.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-11-04-patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n\"is not 42 or 43 // warning: the pattern 43 is redundant. Did you mean to parenthesize the `or` pattern?\"\n```\n\n----------------------------------------\n\nTITLE: C# nameof Usage Examples\nDESCRIPTION: Implied syntax examples showing how nameof would be used in code, with type arguments omitted for generic types but dimension specifiers allowed for disambiguation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nnameof(identifier)\nnameof(System::Console)\nnameof(List<,>.Count)\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax Options for Unconstrained Type Parameter\nDESCRIPTION: Various proposed syntax options for expressing \"unconstrained\" in method overrides to distinguish it from class and struct constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-25.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\noverride void M1<[Unconstrained]T,U>(T? x)           // a\noverride void M1<T,U>(T? x) where T: object?         // b\noverride void M1<T,U>(T? x) where T: unconstrained   // c\noverride void M1<T,U>(T? x) where T:                 // d\noverride void M1<T,U>(T? x) where T: ?               // e\noverride void M1<T,U>(T? x) where T: null            // f\noverride void M1<T,U>(T? x) where T: class|struct    // g\noverride void M1<T,U>(T? x) where T: class or struct // h\noverride void M1<T,U>(T? x) where T: cluct           // joke\n```\n\n----------------------------------------\n\nTITLE: Generated Record Implementation in C#\nDESCRIPTION: Shows how the compiler expands the shorthand record syntax into a full record declaration with auto-implemented init-only properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-19.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nrecord Point\n{\n    public int X { get; init; }\n    public int Y { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Constant Pattern Equality with Object Type in C#\nDESCRIPTION: This example demonstrates the behavior of constant pattern equality when switching on an object type, raising questions about how equality should be determined across different numeric types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\nswitch((object)7)\n{\n  case (byte)7:\n    WriteLine(\"Match!\");\n    break;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ref struct Constraint Syntax in C#\nDESCRIPTION: Demonstration of two syntax proposals for allowing ref structs in generic constraints. The accepted approach uses 'where T : allows ref struct' syntax within existing where clauses.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-02-26.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nwhere T : allows ref struct\n```\n\nLANGUAGE: C#\nCODE:\n```\nallows T : ref struct\n```\n\n----------------------------------------\n\nTITLE: Extension Container Prototype with Type Receiver in C#\nDESCRIPTION: This code snippet presents an extension container where the receiver is a type (IEnumerable<T>). The receiver parameter does not have a name. It contains an extension method called `Create` which is `static`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Extension-API-docs.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nextension<T>(IEnumerable<T>)\n{\n    public static IEnumerable<T> Create(int size, Func<int, T> factory);\n}\n```\n\n----------------------------------------\n\nTITLE: Ambiguity in Base Calls for Default Interface Implementations\nDESCRIPTION: Illustrates potential ambiguities that can arise when making base calls to default implementations in interfaces with multiple inheritance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-31.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M() { ... } }\ninterface I2 { void M() { ... } }\ninterface I3 : I1, I2 { void N() { base.M(); } } // which declaration of M()?\n```\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M(); }\ninterface I2: I1 { void I1.M() { ... } }\ninterface I3: I1 { void I1.M() { ... } }\ninterface I4: I2, I3 { void N() { base.M(); } } // which implementation of M()?\n```\n\n----------------------------------------\n\nTITLE: Collection Initialization with 'args' Keyword Examples\nDESCRIPTION: Alternative syntax using args() instead of with() for collection initialization with arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n// With an existing type:\n\n// Initialize to twice the capacity since we'll have to add\n// more values later.\nList<string> names = [args(capacity: values.Count * 2), .. values];\n\n// With the dictionary types.\nDictionary<string, int> nameToAge1 = [args(comparer)];\nDictionary<string, int> nameToAge2 = [args(comparer), kvp1, kvp2, kvp3];\nDictionary<string, int> nameToAge3 = [args(comparer), k1:v1, k2:v2, k3:v4];\nDictionary<string, int> nameToAge4 = [args(comparer), .. d1, .. d2, .. d3];\n\nDictionary<string, int> nameToAge = [args(comparer), kvp1, k1: v2, .. d1];\n```\n\n----------------------------------------\n\nTITLE: Nullable Analysis Abstract Domain Definition\nDESCRIPTION: Proposed enum defining the abstract domain for nullable analysis, representing three possible states for null checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-13.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nenum\n{\n    NotNull,\n    MaybeNull,\n    MaybeNullEvenIfNotNullable\n}\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default for local variable declaration in C#\nDESCRIPTION: Declaring local variables using the default literal where the type is inferred from the variable declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nImmutableArray<SomeType> x = default;\n```\n\n----------------------------------------\n\nTITLE: Collection Expression with Spread Elements Example\nDESCRIPTION: Demonstrates how the compiler processes a collection expression with spread elements, showing evaluation order and array construction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nint[] x = [a, ..b, ..c, d];\n```\n\n----------------------------------------\n\nTITLE: Value Member Enum Class Example\nDESCRIPTION: Demonstrates enum class with value members for color definitions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/discriminated-unions.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nenum class Color\n{\n    Red,\n    Green\n}\n```\n\n----------------------------------------\n\nTITLE: VB-Style Property Backing Field Naming - C#\nDESCRIPTION: Example of potential VB-inspired naming convention for property backing fields discussed as an alternative to field keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-24.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n_PropName\n```\n\n----------------------------------------\n\nTITLE: Illustrating Breaking Change in Record Syntax for C#\nDESCRIPTION: Demonstrates how the new record syntax in C# 9 could potentially break existing code that uses method declarations with similar syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-27.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nrecord M(int X, int Y) { ... }\n\nclass C\n{\n    record M(int X, int Y) { ... }\n    partial record M(int X, int Y);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Interface Default Implementation in C#\nDESCRIPTION: Example showing basic default implementation syntax in interfaces and interface inheritance with implementation overriding.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-14.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1\n{\n    int M(int i, bool b, string s) { return s?.Length ?? i; }\n}\n\ninterface I2 : I1\n{\n    int I1.M(int i, bool b, string s) { return b ? i : s?.Length ?? 0; }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Out Parameters as Tuple Return Values in C#\nDESCRIPTION: This snippet proposes a new syntax for handling out parameters as additional return values in a tuple, similar to F#. It compares the current style with a potential new style using tuples.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\nbool TryGet(out int value){ ... }\n\n/* current style */\nint value;\nbool b = TryGet(out value);\n\n/* New style */\n(int value, bool b) = TryGet();\n```\n\n----------------------------------------\n\nTITLE: Readonly Variable Declaration\nDESCRIPTION: Proposed syntax alternatives for declaring readonly variables, showing potential abbreviations like 'val' or 'let' instead of the full 'readonly var' keyword combination.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-24.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nreadonly var\nval\nlet\n```\n\n----------------------------------------\n\nTITLE: Modern Type-Based Extensions in C#\nDESCRIPTION: This snippet demonstrates a modern approach to type-based extensions with C#. It emphasizes type declarations for extensions involving instance and static members, benefitting from features like indexed properties and user-defined conversions. The snippet presumes familiarity with C# class design patterns and syntax. Inputs and outputs use typical method and property constructs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nextension E for C\n{\n    // Instance members\n    public string P { get => f; set => f = value.Trim(); }         // Property\n    public T M<T>() where T : IParsable<T> => T.Parse(f, default); // Method\n    public char this[int index] => f[index];                       // Indexer\n    public C(string f) => this.f = f;                              // Constructor\n\n    // Static members\n    public static int ff = 0;                                // Static field\n    public static int PP { get; set => field = Abs(value); } // Static property\n    public static C MM(string s) => new C(s);                // Static method\n    public static C operator +(C c1, C c2) => c1.f + c2.f;   // Operator\n    public static implicit operator C(string s) => new C(s); // UD conversion\n}\n```\n\n----------------------------------------\n\nTITLE: Named Arguments Evaluation Order Example\nDESCRIPTION: Demonstrates evaluation order of named arguments with params collections where collection instance is created and populated between argument evaluations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static void Main()\n    {\n        Test(b: GetB(), c: GetC(), a: GetA());\n    }\n\n    static void Test(int a, int b, params MyCollection c) {}\n\n    static int GetA() => 0;\n    static int GetB() => 0;\n    static int GetC() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar for Instance Extension Methods in ANTLR\nDESCRIPTION: Defines ANTLR grammar rules for declaring instance extension methods in an extension container. Key structures include 'extension_method_declaration', 'extension_method_header', and 'receiver_parameter', outlining how these syntactic components are constructed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_5\n\nLANGUAGE: antlr\nCODE:\n```\nextension_method_declaration\n    : attributes? method_modifiers return_type extension_method_header method_body\n    | attributes? ref_method_modifiers ref_kind ref_return_type extension_method_header ref_method_body\n    ;\n\nextension_method_header\n    : receiver_parameter '.' member_name '(' parameter_list? ')'\n    | receiver_parameter '.' member_name type_parameter_list '(' parameter_list? ')' type_parameter_constraints_clause*\n    ;\n\nreceiver_parameter\n    : '(' attributes? receiver_mode_modifier? type? identifier ')'\n    | identifier\n    | type\n    ;\n\nreceiver_mode_modifier\n    | 'ref'\n    | 'ref readonly'\n    | 'in'\n\n```\n\n----------------------------------------\n\nTITLE: Using Null-Forgiving Operator with Default Expressions in C#\nDESCRIPTION: Example showing how the null-forgiving operator suppresses warnings when used with default expressions on non-nullable reference types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-16.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ndefault(T)!\n```\n\n----------------------------------------\n\nTITLE: Nullable Value Type to Object Conversion\nDESCRIPTION: Example of nullable value type conversion to object.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nint? i = null;\nobject o = i;\no.ToString();\n```\n\n----------------------------------------\n\nTITLE: Non-Warning Array Creation in C#\nDESCRIPTION: Example of array creation that should not trigger nullability warnings despite creating null elements\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-04.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar array = new string[10];\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation with Tuple Element Names\nDESCRIPTION: Shows potential conflicts when implementing interfaces with different tuple element names in method signatures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-13.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 : IEnumerable<(int a, int b)> {}\ninterface I2 : IEnumerable<(int c, int d)> {}\ninterface I3 : I1, I2 {} // what comes out when you enumerate?\nclass C : I1 { public IEnumerator<(int e, int f)> GetEnumerator() {} }\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Negation Syntax Examples in C#\nDESCRIPTION: Code examples showing different approaches to pattern matching negation, including negation outside if condition and negative patterns syntax\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-09.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif !(o is int i)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nnot int i\n```\n\n----------------------------------------\n\nTITLE: Reference Type Substitution Examples in C#\nDESCRIPTION: Shows how T? behaves when the type parameter is substituted with reference types, including both nullable and non-nullable variants.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar s1 = new string[0].FirstOrDefault();  // string? s1\nvar s2 = new string?[0].FirstOrDefault(); // string? s2\n```\n\n----------------------------------------\n\nTITLE: Implementing NonNull Generic Constraints in C#\nDESCRIPTION: Examples showing usage of nonnull generic constraint for Marshal and Dictionary implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-05-15.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Marshal \n{ \n    // The method fills in the provided instance from the pointer, and thus \n    // T shouldn't be null. \n    public static void PtrToStructure<T>(IntPtr ptr, T structure) \n        where T : nonnull \n \n    // Alternatively, [DisallowNull] could be used. \n    public static void PtrToStructure<T>(IntPtr ptr, [DisallowNull] T structure) \n} \n \n// TKey on Dictionary, IDictionary, ConcurrentDictionary, etc. should not be null \npublic class Dictionary<TKey, TValue> : \n    IDictionary<TKey, TValue>, \n    IDictionary, IReadOnlyDictionary<TKey, TValue>, \n    ISerializable, \n    IDeserializationCallback \n    where TKey : nonnull\n```\n\n----------------------------------------\n\nTITLE: Self-Referential CallerArgumentExpression Example\nDESCRIPTION: Shows a self-referential usage of CallerArgumentExpression attribute that triggers a warning.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-14.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M3([CallerArgumentExpression(\"arg1\")]string arg1 = \"\"); // Warning?\n\nM3(); // What gets passed? null? \"\"?\n```\n\n----------------------------------------\n\nTITLE: Escaped Braces Interpolation Example\nDESCRIPTION: Demonstrates handling of escaped braces in interpolated strings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n$\"\\{{6234:D}\\}\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\nString.Format(\"{0}{1:D}{2}\", \"{\", 6234, \"}\")\n```\n\n----------------------------------------\n\nTITLE: Tuple Assignment Comparison\nDESCRIPTION: Illustrates the intuitive expectation for tuple conversions by comparing direct assignment and intermediate variable assignment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\n(long, long) tuple = (1, 1);\n\nvar tmp = (1, 1);\n(long, long) tuple = tmp; // Doesn't work??!?\n```\n\n----------------------------------------\n\nTITLE: Generic Method Invocation Example in C#\nDESCRIPTION: Example showing how the enhanced type inference affects generic method calls\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/nullable-enhanced-common-type.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nM(1, null)    // Where M<T>(T a, T b)\n```\n\n----------------------------------------\n\nTITLE: Interface Declaration with Type Parameter in #nullable disabled Context\nDESCRIPTION: Demonstrates an interface declaration in a #nullable disabled context, which creates an oblivious object constraint on the type parameter T.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-15.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable disable\ninterface I\n{\n    T M<T>(T arg);\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Bouncer Pattern Limitation\nDESCRIPTION: Shows limitation of current scope rules when using pattern matching in bouncer pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-15.md#2025-04-23_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(object o)\n{\n  if (!(o is int i)) throw new ArgumentException(\"Not an int\", nameof(o));\n  ...; // we know o is int, but i is out of scope :-(\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Discriminated Union Syntax as an Enum Class in C#\nDESCRIPTION: Example showing how a discriminated union might be represented as an enum class in C#, using Color as a simple example with Red, Green, and Blue variants.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-03-30.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nenum class Color\n{\n    Red,\n    Green,\n    Blue\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Member Access Issue with Tuples in C#\nDESCRIPTION: Shows how member names could be lost when using tuples with dynamic, preventing access to named members at runtime if tuple names aren't preserved.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\ndynamic d = (a: 7, b: 9);\nWriteLine(t.a); // Error! Huh ??!?\n```\n\n----------------------------------------\n\nTITLE: Declaration Expressions in Initializers with Shared Variables\nDESCRIPTION: Example showing how the initialization scope allows declaration expressions to share variables between initializers, enabling value sharing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic class ConfigurationException(Configuration configuration, string message) \n    : Exception(message)\n{\n    private Configuration configuration = configuration;\n    public bool IsRemote { get; } = (var settings = configuration.Settings)[\"remote\"];\n    public bool IsAsync { get; } = settings[\"async\"];\n    public override string ToString() => Message + \"(\" + configuration + \")\";\n}\n```\n\n----------------------------------------\n\nTITLE: List Pattern Length Syntax Example\nDESCRIPTION: Demonstrates the proposed list pattern syntax for checking collection length.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-14.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n_ = list is [0]; // List has length 0;\n```\n\n----------------------------------------\n\nTITLE: Interface Name Lookup Example in C#\nDESCRIPTION: Demonstrates potential naming conflicts when adding new members to interfaces with default implementations. Shows different ways to access interface members and potential syntax options.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-21.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nitf IA { void Foo() {} }\n\nitf IB {}\n\nitf IC : IA, IB \n{ \n    void Bar() \n    { \n        Foo();            // allowed? What if IB adds Foo()?\n        this.Foo();       // same? different?\n        ((IA)this).Foo(); // would be allowed\n        this(IA).Foo();   // new syntax?\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: Attempting Complex Extension Members in C# 4\nDESCRIPTION: The provided code snippet showcases an abandoned approach to generalize extension methods to handle multiple member kinds, such as properties, indexers, and operators in C# 4. Dependence on static methods and the need for a `this` parameter with properties are key features. Inputs and outputs are specific to Foo<T>, Dict<K,V>, and similar constructs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic extension E\n{\n    public static string Name<T>(this Foo<T> myself){ get { â€¦ } set { â€¦ } }\n    public static V this<K,V>(this Dict<K,V> dict)[K index] { get { â€¦ } }\n    public static event Handler<MyArgs> OnExplode<T>(this Foo<T> it) { \n    \tadd { â€¦ }\n    \tremove { â€¦ }\n    }\n    public static operator + (BigInteger i, Complex c) { â€¦ }\n    public static implicit operator Complex(BigInteger i) { â€¦ }\n}\n```\n\n----------------------------------------\n\nTITLE: Range Pattern Matching in C#\nDESCRIPTION: Proposed syntax for pattern matching with ranges, showing pattern matching on character ranges.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-04.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nif (ch is in 'a' to 'z')\nswitch (ch) {\n    case in 'a' to 'z':\n```\n\n----------------------------------------\n\nTITLE: Interface Method Implementation Conflict\nDESCRIPTION: Shows a modified version of IC that creates a conflict in method implementation, demonstrating potential runtime issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/CLR-2017-03-23.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IC : IA\n{\n    override void IA.M() { WriteLine(\"IB\"); }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Global Using Namespace Directive in ANTLR\nDESCRIPTION: The 'global_using_namespace_directive' rule defines the syntax for a global using directive in C#, which allows types from a namespace to be used without qualification. This directive imports types only from the specified namespace and does not cascade into nested namespaces. It can cause ambiguities if types with the same name exist in the importing compilation unit.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/GlobalUsingDirective.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nglobal_using_namespace_directive\n    : 'global' 'using' namespace_name ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Interface Property Implementation in C#\nDESCRIPTION: Shows a class implementing an interface property with both get and set accessors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-17.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass C : IA\n{\n    public int P\n    {\n        get => 4;\n        set { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Class with Constraints in #nullable disabled Context and Method in #nullable enable Context\nDESCRIPTION: Demonstrates how type parameters with constraints declared in a #nullable disabled context are treated as oblivious when used in a #nullable enable context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-15.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n#nullable disable\nclass A<T1, T2, T3> where T2 : class where T3 : object\n{\n    #nullable enable\n    void M2()\n    {\n        T1 x2 = default; // warning?\n        T2 y2 = default; // warning?\n        T3 z2 = default; // warning?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Discriminated Unions in C#\nDESCRIPTION: Example showing nested enum class syntax for discriminated unions, demonstrating scoping issues with nested members BinaryOperator containing Add and Multiply cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-13.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nenum class Expr\n{\n    enum class BinaryOperator\n    {\n        Add(Expr left, Expr right),\n        Multiply(Expr left, Expr right)\n    }\n}\n\nExpr M(Expr left, Expr right)\n{\n    return Add(left, right); // error, no name \"Add\" found under Expr\n}\n\nint M(Expr e) => e switch\n{\n    Add _ => 0, // error, no name Add found under Expr\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Element Naming in C#\nDESCRIPTION: Demonstrates partial naming of tuple elements in both literals and type declarations. Shows how tuple element names must match when converting between tuple types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-12.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nList<(string firstName, string lastName, bool paid)> people = ...;\n\npeople.Add((\"John\", \"Doe\", paid: true));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Label Statement Usage in C#\nDESCRIPTION: Example showing current label statement syntax that requires `:;` at the end of a scope, which impacts code readability. This pattern is common in high-performance and generated code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-09.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nif (!Condition()) goto AfterWork;\nWork();\nAfterWork:;\n```\n\n----------------------------------------\n\nTITLE: Converting Collection Expression to IEnumerable<T> in C#\nDESCRIPTION: Example of passing a collection expression to a method that accepts IEnumerable<T>. This demonstrates the need for implicit conversion from collection expressions to interface types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n// Passing to something that can only read data.\nvoid DoSomething(IEnumerable<int> values) { ... }\nDoSomething([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Dictionary Initializer Equivalent Code\nDESCRIPTION: Shows the equivalent code that dictionary initializers compile to, using temporary variables and indexer assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-12-16.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nvar __tmp = new JsonObject();\n__tmp[\"first name\"] = \"Donald\";\n__tmp[\"last name\"] = \"Duck\";\n__tmp[\"city\"] = \"Duckburg\";\nvar payload = __tmp;\n```\n\n----------------------------------------\n\nTITLE: Params Parameter Instance Method Requirement in C#\nDESCRIPTION: Additional requirement for params parameters ensuring that the Add method is an instance method, not an extension method, to improve usability without requiring specific using statements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-01-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Params Parameter Rule: Add method must be an instance method\n\npublic void ProcessItems(params int[] items) { }\n\n// Correct: Instance method Add\npublic class ValidCollection\n{\n    public void Add(int item) { }\n}\n\n// Incorrect: Extension method Add\npublic static class InvalidCollection\n{\n    public static void Add(this Collection<int> collection, int item) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Nullable Array Complexity in C#\nDESCRIPTION: Example of how nullability would further complicate the syntax of anonymous inline arrays. Shows a non-null regular array of 4-element nullable int arrays.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-01.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nint[]?[4]\n```\n\n----------------------------------------\n\nTITLE: Generic Default Value Handling\nDESCRIPTION: Example showing default value handling in generic methods with warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nT M<T>()\n{\n    T t = default(T); // W warning\n    return default(T); // safety warning\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dictionary Spreading Behavior in C# Collection Literals\nDESCRIPTION: Example showing how spreading dictionaries into a new dictionary literal would work, particularly highlighting the question of how duplicate keys would be handled. This example was used to discuss whether add semantics or overwrite semantics should be preferred.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-06-05.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\nDictionary<int, int> dictionary1 = [1 : 2];\nDictionary<int, int> dictionary2 = [1 : 3];\nM([..dictionary1, ..dictionary2]);\n\nvoid M(Dictionary<int, int> d)\n{ \n    foreach (var (k, v) in d) Console.WriteLine($\"{k} {v}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Return Type Parsing Example - Multiplication\nDESCRIPTION: Code example showing parsing ambiguity between multiplication operation and lambda with return type\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-02.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nF(x * () => y)\n```\n\n----------------------------------------\n\nTITLE: Tuple Literal Deconstruction\nDESCRIPTION: Examples of deconstructing tuple literals with type inference and variable assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-13.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n(string x, byte y, var z) = (null, 1, 2);\n(string x, byte y) t = (null, 1);\n```\n\nLANGUAGE: c#\nCODE:\n```\nstring x;\nbyte y;\n\n(x, y) = (null, 1);\n(x, y) = (y, x); // swap!\n```\n\n----------------------------------------\n\nTITLE: Code Reference - C# Ref Struct Interface Example\nDESCRIPTION: Example showing ref struct and interface relationship syntax mentioned in the discussion, particularly highlighting the 'allows' keyword usage for ref struct constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IEnumerable<T>\n{\n    IEnumerator<T> GetEnumerator();\n}\n```\n\n----------------------------------------\n\nTITLE: Nullability of Conditional Access with Generic Type Parameters in C#\nDESCRIPTION: Example showing conditional access operator usage with generic type parameters having constraints, demonstrating the nullability implications.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T, U>\n    where T : U\n    where U : C<T, U>?\n{\n    static void M(U x)\n    {\n        U y = x?.F();\n        T z = x?.F();\n    }\n    T F() => throw null;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Where Extension Method with Cancellation in C#\nDESCRIPTION: Demonstrates an async extension method for filtering an IAsyncEnumerable with cancellation support.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-18.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic async IAsyncEnumerable<T> Where<T>(this IAE<T> src, Func<T, CT token, Task<bool>> pred)(CT token)\n{\n\tforeach (await var v in src.With(token: token))\n\t{\n\t\tif (await pred(v, token)) yield return v;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional Extension Methods in C#\nDESCRIPTION: Shows a traditional static class with extension methods, which would need to be split into separate extension types in the new extension syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-08-09.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class MemoryExtension\n{\n  public static void M1(this Type1)\n  public static void M2(this Type2)\n}\n```\n\n----------------------------------------\n\nTITLE: With Expression Usage in C# 10.0\nDESCRIPTION: Shows how to create a new instance of a record struct with modified values using the with expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nvar newPoint = point with { X = 100 };\n```\n\n----------------------------------------\n\nTITLE: Syntactic Disambiguation Examples\nDESCRIPTION: Illustrates various syntactic edge cases with collection literals, including conditional expressions and disambiguation strategies\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-26.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = a ? [b] : c;\nvar v2 = [a ? [b] : c];\n\n// Disambiguation cases\n[a ? [b] : c]  // Interpreted as list literal\n[range1, ..x, range2]  // Always a spread element\n```\n\n----------------------------------------\n\nTITLE: Potential Function Pointer Syntax Options in C#\nDESCRIPTION: A list of different syntax options being considered for function pointers in C#. The team was evaluating various ways to represent function pointers with different calling conventions and parameter declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-23.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n1. func* managed int(string)\n2. func*(string)->int\n3. func* managed (string)->int\n4. func* managed (string)=>int\n5. managed int(string)*\n   5a. int(string)*\n6. managed int(string)\n7. managed (string)->int\n8. delegate* int(string)\n9. func int(string)*\n10. delegate int(string)*\n```\n\n----------------------------------------\n\nTITLE: Runtime Behavior and Reflection for Optional Parameters in Lambdas in C#\nDESCRIPTION: Demonstrates how default parameter values are emitted to metadata and can be inspected at runtime using reflection, showing the similarity to standard named delegates.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar addWithDefault = (int addTo = 2) => addTo + 1;\nint AddWithDefaultMethod(int addTo = 2)\n{\n    return addTo + 1;\n}\n\nvar defaultParm = addWithDefault.Method.GetParameters()[0].DefaultValue; // 2\n\nvar add1 = AddWithDefaultMethod;\ndefaultParm = add1.Method.GetParameters()[0].DefaultValue; // 2\n```\n\n----------------------------------------\n\nTITLE: Problematic Usage of Ref Choice Method\nDESCRIPTION: Example showing how the Choice method workaround can lead to NullReferenceException due to unconditional evaluation of arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/conditional-ref.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// will crash with NRE because 'arr[0]' will be executed unconditionally\nref var r = ref Choice(arr != null, ref arr[0], ref otherArr[0]);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Overload Resolution Ambiguity in C#\nDESCRIPTION: Example showing ambiguous overload resolution between Span<object> and string[] parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-09-20.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void A(Span<object> value) { }\nstatic void A(string[] value)     { }\n\nA([string.Empty]); // error: ambiguous\n```\n\n----------------------------------------\n\nTITLE: Customer Orders Join Example\nDESCRIPTION: A practical example showing how a customer-orders relationship is queried using join-into with additional filtering, demonstrating the complete translation process.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nfrom c in customers\njoin o in orders on c.CustomerID equals o.CustomerID into co\nlet n = co.Count()\nwhere n >= 10\nselect new { c.Name, OrderCount = n }\n```\n\nLANGUAGE: csharp\nCODE:\n```\nfrom * in (customers).GroupJoin(\n    orders,\n    c => c.CustomerID,\n    o => o.CustomerID,\n    (c, co) => new { c, co })\nlet n = co.Count()\nwhere n >= 10\nselect new { c.Name, OrderCount = n }\n```\n\nLANGUAGE: csharp\nCODE:\n```\ncustomers\n    .GroupJoin(\n        orders,\n        c => c.CustomerID,\n        o => o.CustomerID,\n        (c, co) => new { c, co })\n    .Select(x => new { x, n = x.co.Count() })\n    .Where(y => y.n >= 10)\n    .Select(y => new { y.x.c.Name, OrderCount = y.n })\n```\n\n----------------------------------------\n\nTITLE: Using-Operator for Extension Method Invocation in C#\nDESCRIPTION: Explores the 'using' operator for method invocation, presenting another approach to extend syntax with conditional invocation capabilities similar to 'using' directives.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = (IEnumerable<int> using MyExtensions).Range(0, 10);\nvar empty = (IEnumerable<int> using MyExtensions).Empty;\n(range using MyExtensions) += 5;\nReadOnlySpan<int> span = range using MyExtensions;\n\n// Instance extension members\nvar query = (range using MyExtensions).Where(i => i < 10);\nvar isEmpty = (query using MyExtensions).IsEmpty;\nvar first = (query using MyExtensions)[0];\nvar repetition = new (IEnumerable<int> using MyExtensions)(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Lambda Type Inference Example in C#\nDESCRIPTION: Demonstrates lambda expression with type inference for delegate type generation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar f = (int x) => x * x; // infers a compiler generated delegate type for int -> int.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Subsumption and Case Guards in C# Switch Statements\nDESCRIPTION: This snippet illustrates how earlier patterns can hide later ones in switch statements, and how case guards can be used to avoid subsumption issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\ncase Point(*, 2):\ncase Point(1, 2): // error/warning\n\ncase Point(var x, 2) where (x > 2): \ncase Point(1, 2): // fine\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Exhaustiveness in Switch Statements with Animal Classes in C#\nDESCRIPTION: This code snippet shows two switch statements that appear exhaustive but are missing null cases for both the Animal and Box<Animal> types. It illustrates the complexity of exhaustiveness checking in discriminated unions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-05-14.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nsealed class Animal\n{\n    sealed class Dog: Animal {}\n    sealed class Cat: Animal {}\n}\n\nint M(Animal a)\n{\n    return a switch \n    {\n        Cat c => 1,\n        Dog d => 2,\n    }\n}\nint M(Box<Animal> b)\n{\n    return b switch \n    {\n        Box(Cat c) => 1,\n        Box(Dog d) => 2,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JsonReader Ref Safety Limitations\nDESCRIPTION: Shows a common friction point in low-level code where the method arguments must match rule prevents using stack-allocated spans with ref struct methods, even when no capture occurs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_50\n\nLANGUAGE: csharp\nCODE:\n```\nref struct JsonReader\n{\n    Span<char> _buffer;\n    int _position;\n\n    internal bool TextEquals(ReadOnlySpan<char> text)\n    {\n        var current = _buffer.Slice(_position, text.Length);\n        return current == text;\n    }\n}\n\nclass C\n{\n    static void M(ref JsonReader reader)\n    {\n        Span<char> span = stackalloc char[4];\n        span[0] = 'd';\n        span[1] = 'o';\n        span[2] = 'g';\n\n        // Error: The safe-context of `span` is function-member \n        // while `reader` is outside function-member hence this fails\n        // by the above rule.\n        if (reader.TextEquals(span))\n        {\n            ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ITensor Interface with ref struct Support\nDESCRIPTION: Interface definition for ITensor<T> with an UnscopedRef attribute and ReadOnlySpan return type for Lengths property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-22-ref-struct-interface-examples.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninterface ITensor<T>\n{\n    [UnscopedRef]\n    ReadOnlySpan<nint> Lengths { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Role Type Declaration and Emit Strategy in C#\nDESCRIPTION: This snippet demonstrates the declaration of a role type in C# and its proposed emit strategy using a ref struct.  It shows how the `this` keyword is replaced with `@this` to access members of the underlying type. Interfaces are disallowed until phase 2.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nrole MyRole<T> : UnderlyingType where T : Constraint \n{\n    // Member declarations\n    void M()\n    {\n        ... usage of `this` with type `MyRole` ...\n        _ = this.ExistingMethod();\n        _ = this.existingField;\n        this.M();\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nref struct MyRole<T> where T : Constraint // possibly with a special base type like `System.Role` or `System.Role<...>` or some other marker\n{\n    ref UnderlyingType @this;\n    MyRole(ref UnderlyingType underlying)\n    {\n        @this = ref underlying;\n    }\n\n    // Member declarations\n    void M()\n    {\n        ... usages of `this` are replaced with `@this` ...\n        _ = @this.ExistingMethod();\n        _ = @this.existingField;\n        this.M();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ref Local Usage in C#\nDESCRIPTION: This snippet shows how ref locals can be used to modify nested struct data efficiently. It illustrates the need for non-reassignable, unsafe-to-return ref locals in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-01.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nNode n = ...; struct\nref Node l = ref GetLeftMostSubNode(ref n);\nl.Contents = ...; // modify leftmost node\n```\n\n----------------------------------------\n\nTITLE: Referencing RefSafetyRulesAttribute Discussion\nDESCRIPTION: Markdown section discussing the introduction of RefSafetyRulesAttribute to handle ref safety rules versioning in C# modules. The attribute allows distinction between pre-C# 11 and new ref safety rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-10-05.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n#### `RefSafetyRulesAttribute`\n\nThis attribute will allow us to better recognize whether a module should be treated with the new ref safety rules, or with the pre-C# 11 safety rules. We did have some concerns about the particular format, but these were resolved through discussion:\n```\n\n----------------------------------------\n\nTITLE: Traditional Wither Pattern in C#\nDESCRIPTION: Example of current wither pattern used in Roslyn for modifying immutable objects, showing method chaining to modify multiple properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar newIfStatement = ifStatement.WithCondition(newCondition).WithStatement(newStatement);\n```\n\n----------------------------------------\n\nTITLE: Method Conversion with ref readonly Parameters\nDESCRIPTION: Shows method overload resolution and delegate conversion behavior with ref readonly parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/ref-readonly-parameters.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    void M(I1 o, ref readonly int x) => System.Console.Write(\"1\");\n    void M(I2 o, ref int x) => System.Console.Write(\"2\");\n    void Run()\n    {\n        D1 m1 = this.M;\n        D2 m2 = this.M; // currently ambiguous\n\n        var i = 5;\n        m1(null, in i);\n        m2(null, ref i);\n    }\n    static void Main() => new C().Run();\n}\ninterface I1 { }\ninterface I2 { }\nclass X : I1, I2 { }\ndelegate void D1(X s, ref readonly int x);\ndelegate void D2(X s, ref int x);\n```\n\n----------------------------------------\n\nTITLE: Defining Partial Extension Types in C#\nDESCRIPTION: Shows a partial extension type declaration where the underlying type is derived from other parts of the extension.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-2023-02-21.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npartial implicit extension R { }\n```\n\n----------------------------------------\n\nTITLE: Natural Type Inference with KeyValuePair in Collection Expressions in C#\nDESCRIPTION: This example demonstrates how natural type inference works with KeyValuePair elements in collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstring s1, s2;\nobject o1, o2;\nvar d = [KeyValuePair.Create(s1, o1), KeyValuePair.Create(o2, s2)];\n```\n\n----------------------------------------\n\nTITLE: C# Grammar Rules for nameof Expression\nDESCRIPTION: Formal grammar specification for the nameof operator expression, showing three possible syntax patterns for accessing identifiers, including namespace-qualified and type-member access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_11\n\nLANGUAGE: bnf\nCODE:\n```\n_nameof-expression_:\n* `nameof`   `(`   _identifier_   `)`\n* `nameof`   `(`   _identifier_   `::`   _identifier_   `)`\n* `nameof`   `(`   _unbound-type-name_   `.`   _identifier_   `)`\n```\n\n----------------------------------------\n\nTITLE: ValueTuple Struct Definition for C# Tuples\nDESCRIPTION: Shows the proposed implementation of ValueTuple<T1,T2,T3> as a mutable struct with public fields, which would serve as the underlying type for tuples in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-01.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic struct ValueTuple<T1, T2, T3>\n{\n    public T1 Item1;\n    public T2 Item2;\n    public T3 Item3;\n}\n```\n\n----------------------------------------\n\nTITLE: Static Extension Method Betterness Issue in C#\nDESCRIPTION: This code demonstrates a potential issue with betterness rules when applied to static extension methods. Two extension methods, `M`, are defined for the `int` type within separate static classes, one using `in int` and the other using `int`. The example calls the extension method `M2` on the `int` type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nint.M2();\npublic static class E1\n{\n    extension(in int i)\n    {\n       public static void M() { }\n    }\n}\n\npublic static class E2\n{\n    extension(int)\n    {\n        public static void M() { }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Syntax Examples in C#\nDESCRIPTION: This snippet outlines the proposed syntax for pattern matching in C#, including various pattern types and the extended is-expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-01.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npattern:\n  *\n  type identifier // scope is a separate issue\n  type { id is pattern, ... } [identifier]\n  type (pattern, ...)\n  constant-expression\n\nis-expression:\n  relational-expression is pattern\n```\n\n----------------------------------------\n\nTITLE: Generic Parameter Null Check Example\nDESCRIPTION: Example showing null check syntax with unconstrained generic parameters, which was decided to be allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-14.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M<T>(T param!)         // Allowed on unconstrained generic parameters\n```\n\n----------------------------------------\n\nTITLE: Nullable Array Hybrid Approach in C#\nDESCRIPTION: Hybrid approach demonstrating array covariance and nullable covariance assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-28.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstring?[][] a = new string?[3][];\n// string[]?[] a = new string[]?[3]; // disallow ? in new\nstring[]?[] a = new string[3][];\nstring[][]? a = new string[3][];\n```\n\n----------------------------------------\n\nTITLE: C# Property Accessor with this.value Pattern\nDESCRIPTION: Example demonstrating property accessor implementation using this.value pattern, showing both get and set accessors with value pointer assignment. This pattern represents a common but potentially problematic field access approach in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-15-usage-data.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic int Value\n{\n  get { return this.value; }\n  set\n  {\n    this.value = value;\n    this.valuePtr = &value;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Explicit Extension Types for ReadOnlySpan<byte> in C#\nDESCRIPTION: Demonstrates the declaration of explicit extension types for ReadOnlySpan<byte>, showcasing potential type safety concerns between different extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-2023-02-21.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit extension CustomerExtension for ReadOnlySpan<byte> : PersonExtension\nexplicit extension EmailExtension for ReadOnlySpan<byte>\n```\n\n----------------------------------------\n\nTITLE: Scoping Expression Variables in Field Initializers (C#)\nDESCRIPTION: Illustrates various potential scoping options for expression variables introduced in field initializers. The chosen option limits the scope to only the same initializer expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-03.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nclass C\n{\n    int i = M(out int x)\n            .N(x), // here?\n        y = M(x);  // here?\n    int j = x;     // here?\n    int X => x;    // here?\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Extension Member Disambiguation Challenges in C#\nDESCRIPTION: This snippet illustrates the challenges in disambiguating between members of two imported extensions and suggests potential workarounds.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-as-static-types.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing E1; // Brings in void M() on string;\nusing E2; // Also brings in void M() on string;\n\n\"Hello\".M(); // Ambiguous\n((E1)\"Hello\").M(); // No longer allowed\n```\n\n----------------------------------------\n\nTITLE: Binary Compatibility Challenge Example\nDESCRIPTION: Demonstrates a semantic challenge where interface implementation behavior can change based on compilation order and assembly dependencies.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-08.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\n// step 1\n\ninterface I { }\n\nclass C : I { public void M() { /* C.M */ } }\n\n// step 2\n\ninterface I { void M() { /* I.M */} }\n\nI i = new C();\ni.M(); // calls I.M default implementation\n\n// step 3: recompile C\n\nI i = new C();\ni.M(); // calls C.M non-virtual method\n```\n\n----------------------------------------\n\nTITLE: Struct Field Initialization with Parameterless Constructor\nDESCRIPTION: Example showing a struct with field initializers and an empty parameterless constructor, demonstrating the current requirement to explicitly write a constructor when using field initializers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nstruct S \n{\n\tstring label = \"<unknown>\";\n\tbool pending = true;\n\tpublic S(){}\n\tâ€¦\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Addition to Pattern Matching Specification in C# 7.1\nDESCRIPTION: The code snippet shows the proposed modification to the C# specification for pattern matching, adding support for open types. This change makes the 'is' operator type compatibility rules consistent with the 'as' operator when working with generics.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/generics-pattern-match.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nCertain combinations of static type of the left-hand-side and the given type are considered incompatible and result in compile-time error. A value of static type `E` is said to be *pattern compatible* with the type `T` if there exists an identity conversion, an implicit reference conversion, a boxing conversion, an explicit reference conversion, or an unboxing conversion from `E` to `T`**, or if either `E` or `T` is an open type**. It is a compile-time error if an expression of type `E` is not pattern compatible with the type in a type pattern that it is matched with.\n```\n\n----------------------------------------\n\nTITLE: Compiler Warning Scenarios with LINQ\nDESCRIPTION: Examples demonstrating cases where the compiler generates warnings in LINQ operations with nullable types, showing where null-forgiving operator might be needed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-03-21.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nList<string?> strings;\nvar query = strings.Where(s => s != null).Select(s => s.Length); // What?? Why warning?\n```\n\n----------------------------------------\n\nTITLE: Variable Pattern Grammar in ANTLR\nDESCRIPTION: ANTLR grammar definition for var pattern matching syntax, allowing variable designations in pattern matching expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-04.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nvar_pattern\n    : 'var' variable_designation\n    ;\n```\n\n----------------------------------------\n\nTITLE: Illustrating Record Property Initialization in C#\nDESCRIPTION: Example showing how record properties are initialized, demonstrating the difference between synthesized and user-defined properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-01.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nrecord R(int X)\n{\n    public int X { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Nullability Differences in Partial Type Base Classes\nDESCRIPTION: Example demonstrating how nullability annotations can differ between partial class declarations with base type parameters, showing the complexity of merging nullable and non-nullable type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-23.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\npublic partial class Derived : Base<\n    object,\n#nullable disable\n    object\n#nullable enable\n> {}\n\n#nullable enable\npublic partial class Derived : Base<\n#nullable disable\n    object,\n#nullable enable\n    object\n> {}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Name Warning in C#\nDESCRIPTION: This snippet shows a case where a warning would be issued for tuple literal names not matching the target type names. This helps catch potential errors when creating or maintaining tuple literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-15.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n(int x, int y) t = (a: 1, b: 2); // Oops, forgot to update tuple literal? Names a and b would be lost\n```\n\n----------------------------------------\n\nTITLE: ASP.NET Map Method Ambiguity\nDESCRIPTION: Example showing how method overloads in ASP.NET can become ambiguous with the new lambda expression natural type feature in C# 10.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-23.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic class AppBuilderExtensions\n{\n    public static IAppBuilder Map(this IAppBuilder app, PathSring path, Action<IAppBuilder> callback) => app;\n}\nstatic class RouteBuilderExtensions\n{\n    public static IRouteBuilder Map(this IRouteBuilder routes, string path, Delegate callback) => routes;\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Implementation Visibility Example in C#\nDESCRIPTION: Shows the interaction between InternalsVisibleTo attribute and interface implementation restrictions across assemblies.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n[assembly: InternalVisibleTo(\"B\")]\n\n[InternalImplementationOnly]\npublic interface IA {}\n```\n\n----------------------------------------\n\nTITLE: Safely Dereferencing Nullable Reference Types with Null Conditional Operator\nDESCRIPTION: Demonstrates using the null conditional operator to safely access members of nullable reference types without causing null reference exceptions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-10-17.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstring? s = ...;\nvar l = s?.Length;\nvar c = s?[3];\n```\n\n----------------------------------------\n\nTITLE: Comparing Classic Extension Methods with Extension Declarations in C#\nDESCRIPTION: This snippet demonstrates how the uniqueness rule applies to both classic extension methods and new extension declarations within the same static class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source) { ... }\n    \n    extension(IEnumerable source) \n    {\n        IEnumerable<TResult> Cast<TResult>() { ... } // Error! Duplicate declaration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Default Parameter Value Mismatch Example\nDESCRIPTION: Illustrates potential issues with lambda expressions having different default parameter values when being reassigned, which will generate compiler warnings in the new implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-27.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = (int i = 1) => {};\nx = (int i = 2) => {}; // Reassigned with a different underlying default.\nx(); // What would this pass for i?\n```\n\n----------------------------------------\n\nTITLE: Classic C# Extension Methods Example\nDESCRIPTION: This C# code snippet demonstrates classic extension methods using `SyntaxToken`, `SyntaxTrivia`, `SyntaxNode`, and `SyntaxNodeOrToken` types.  It defines several `IsKind` methods and a `ContainsDirective` method, extending the functionality of Roslyn's public API. The code shows how extension methods are traditionally written in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class CSharpExtensions\n{\n    public static bool IsKind(this SyntaxToken token, SyntaxKind kind) => ...;\n    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind) => ...;\n    public static bool IsKind([NotNullWhen(true)] this SyntaxNode? node, SyntaxKind kind) => ...;\n    public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind) => ...;\n    public static bool ContainsDirective(this SyntaxNode node, SyntaxKind kind) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Legal Usage of Out Parameters with Span Types in C#\nDESCRIPTION: Shows a valid pattern where an out parameter of a ref struct type is assigned and then returned. This is allowed because the out parameter is assigned before being returned.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> StrangeButLegal(out Span<int> span)\n{\n    span = default;\n    return span;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface with Variant Type Parameter Error Example\nDESCRIPTION: Demonstrates an error case where a class declaration is not allowed within the scope of a variant type parameter in an interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IOuter<out T>\n{\n    class C { } // error: class declaration within the scope of variant type parameter 'T'\n}\n```\n\n----------------------------------------\n\nTITLE: Compilation Unit Syntax in ANTLR\nDESCRIPTION: This ANTLR grammar defines the structure of a C# compilation unit, specifying the order of extern alias directives, global using directives, using directives, global attributes, and namespace member declarations. It shows that global using directives can appear at the very beginning of a file.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/GlobalUsingDirective.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\n\"compilation_unit\\n    : extern_alias_directive* global_using_directive* using_directive* global_attributes? namespace_member_declaration*\\n    ;\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Attribute Behavior in C#\nDESCRIPTION: This code snippet shows the current behavior of nullable attributes on properties in C#, highlighting potential issues with generic types and the [MaybeNull] attribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-09-11.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing System.Diagnostics.CodeAnalysis;\n\n#nullable enable\n\nclass C<T> where T : class?\n{\n    public C(T x) => f = x;\n    T f;\n                T P1 { get => f;        set => f = value; }\n    [AllowNull] T P2 { get => f;        set => f = value ?? throw new ArgumentNullException(); }\n    [MaybeNull] T P3 { get => default!; set => f = value; }\n\n    void M()\n    {\n        P1 = null; // Warning\n        P2 = null; // No warning\n        P3 = null; // Warning\n\n        f = P1;    // No warning\n        f = P2;    // No warning\n        f = P3;    // BUG?: No warning!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Extension Operators in C#\nDESCRIPTION: This snippet demonstrates the usage of extension operators, including predefined operators, extension binary operators, and extension compound assignment operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-operators.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nint[] numbers = { 1, 2, 3 };\n\nvar i = 2 * 3;       // predefined operator *(int, int)\nvar v = numbers * 4; // extension operator *(int[], int)\nv *= 5;              // extension operator *=(int)\n```\n\n----------------------------------------\n\nTITLE: Prefer More Specific Extension Method in C#\nDESCRIPTION: This example demonstrates the concept of preferring a more specific extension method during overload resolution. Two extension methods, both named `M`, are defined for `string` and `object` respectively. The call `string.M()` should resolve to the extension method defined for the `string` type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nstring.M();\n\nstatic class E1\n{\n    extension(string)\n    {\n        public static string M() => throw null;\n    }\n}\n\nstatic class E2\n{\n    extension(object)\n    {\n        public static System.Action M => throw null;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Name Shadowing in Primary Constructors\nDESCRIPTION: This code snippet demonstrates the unintuitive behavior where a base class field shadows a primary constructor parameter in a derived class, causing Console.WriteLine to print \"base\" instead of \"derived\".\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-08.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Base\n{\n    protected readonly string a = \"base\";\n}\n\npublic class Derived(string a = \"derived\") : Base\n{\n    public void M()\n    {\n        Console.WriteLine(a);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cast-Operator for Invoking Extension Methods in C#\nDESCRIPTION: This snippet uses the cast-operator syntax to access both static and instance extension members. This approach encapsulates the invocation within a cast to 'MyExtensions', supporting type clarity and operation precision.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = ((MyExtensions)IEnumerable<int>).Range(0, 10);\nvar empty = ((MyExtensions)IEnumerable<int>).Empty;\n(MyExtensions)range += 5;\nReadOnlySpan<int> span = (MyExtensions)range;\n\n// Instance extension members\nvar query = ((MyExtensions)range).Where(i => i < 10);\nvar isEmpty = ((MyExtensions)query).IsEmpty;\nvar first = ((MyExtensions)query)[0];\nvar repetition = new ((MyExtensions)IEnumerable<int>)(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Defining NullableFilterAttribute in C#\nDESCRIPTION: Declares a NullableFilterAttribute class that can be applied to delegate parameters to improve nullable state flow in predicate lambdas. This attribute indicates that the predicate returns true for all values returned by the containing method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-22.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Diagnostics.CodeAnalysis;\n\n/// <summary>\n/// Can be applied to a parameter of a delegate type such as <see cref=\"Func<object, bool>\"/> which has a single parameter and returns <see langword=\"bool\"/>.\n///\n/// When this attribute is used, the language assumes that the predicate returns true for all values of its input type which are returned by the containing method.\n/// </summary>\n[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]\npublic sealed class NullableFilterAttribute : Attribute { }\n```\n\n----------------------------------------\n\nTITLE: Approach A2: AllowNull Example (C#)\nDESCRIPTION: Illustrates how both `MaybeNull` and `AllowNull` can be used to handle cases where the setter may need to reset the value back to null.  This can be useful for trimming properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n// will appropriately not warn.\\n[field: MaybeNull, AllowNull] string Prop { get => field ??= ComputeValue(); set => field = value is \\\"\\\" ? null : value.Trim(); } \n```\n\n----------------------------------------\n\nTITLE: Implementing an Interface with Explicit Object Constraint in #nullable enable Context\nDESCRIPTION: Shows a class implementing the interface I in a #nullable enable context with an explicit non-nullable object constraint on the type parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-15.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\nclass A : I\n{\n    public T M<T>(T arg) where T : object\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Member Disambiguation Syntax Options in C#\nDESCRIPTION: This snippet showcases various syntax proposals for disambiguating extension members in C#. It includes examples using cast, as-operator, invocation syntax, at-operator, @-operator, in-operator, using operator, and qualified member approaches.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-member-disambiguation.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Cast\n((MyExtensions)e).Prop\n((MyExtensions)e1) + e2\n\n// As-operator\n(e as MyExtensions).Prop\n(e1 as MyExtensions) + e2\n\n// Invocation syntax\nMyExtensions(e).Prop\nMyExtensions(e1) + e2\n\n// At-operator\n(e at MyExtensions).Prop\n(e1 at MyExtensions) + e2\n\n// @-operator\n(e @ MyExtensions).Prop\n(e1 @ MyExtensions) + e2\n\n// In-operator\n(e in MyExtensions).Prop\n(e1 in MyExtensions) + e2\n\n// Using operator\n(e using MyExtensions).Prop\n(e1 using MyExtensions) + e2\n\n// Qualified member\ne.(MyExtensions.Prop)\ne1 (MyExtensions.+) e2\n```\n\n----------------------------------------\n\nTITLE: Handler Overload Resolution Example in C#\nDESCRIPTION: Demonstrates potential ambiguity issues with handler overload resolution and the need for explicit type casting in certain scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nstruct Handler1\n{\n    public Handler1(int literalLength, int formattedCount, C c) => ...;\n    // AppendX... methods as necessary\n}\nstruct Handler2\n{\n    public Handler2(int literalLength, int formattedCount, C c) => ...;\n    // AppendX... methods as necessary\n}\n\nclass C\n{\n    void M(Handler1 handler) => ...;\n    void M(Handler2 handler) => ...;\n}\n\nc.M($\"{X}\"); // Ambiguous between the M overloads\n```\n\n----------------------------------------\n\nTITLE: Implementing Diamond Inheritance in C# Interfaces\nDESCRIPTION: Demonstrates how adding a virtual method to a base class can implement an interface in the derived class, showing potential inheritance patterns and method resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-17.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface IFoo { void M() { impl; } }\nclass Derived : Base, IFoo {}\n\nclass Base : Base0\n{\n    public virtual void M() {} // added later\n}\n\nclass Base0 : IFoo\n{\n    void IFoo.M() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Ref Fields in Ref Structs in C# 11.0\nDESCRIPTION: Shows how to declare ref fields in a ref struct, a low-level improvement added in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nref struct S { ref int field; ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Named Tuple Literal Natural Type in C#\nDESCRIPTION: Shows how named tuple literals affect the inferred natural type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvar t = (name: \"John\", age: 5); // The type of t is (string name, int age)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Static Abstract Interface Usage in C#\nDESCRIPTION: Example showing how type constraints work with IParsable interface, highlighting current limitations with static abstract members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-09-13.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIParsable<double>.Parse(\"123\", null)\n```\n\n----------------------------------------\n\nTITLE: Keywords Considered for Underlying Type in C#\nDESCRIPTION: This snippet lists various keywords explored for designating an underlying type in role definitions, facilitating a better understanding of potential syntax clarity and user intent.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-02-15.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nextension E of U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E extends U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E on U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E for U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E over U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nthis E of U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E is U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E override U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E using U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nextension E from U\n```\n\n----------------------------------------\n\nTITLE: Ref Parameter Basic Example\nDESCRIPTION: Example showing passing a const value by ref to a method\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-09-27.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nconst int x = 42;\nfoo(ref x);\n```\n\n----------------------------------------\n\nTITLE: Using LINQ `All` Operator with Nullable Types\nDESCRIPTION: This C# code snippet demonstrates a scenario where the `All` operator is used to check if all elements in a `List<string?>` are not null. After the check, the code intends to use the list with the assumption that all elements are non-null.  However, the compiler doesn't track the state of the collection, and there's a concern about how to invalidate the state if the collection is modified after the check. The `UseNotNullItems` method is assumed to handle a list of non-nullable strings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nList<string?> items = ...;\nif (items.All(i => i != null))\n{\n    UseNotNullItems(items);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Variance Positions for Nullable Type Inference in C#\nDESCRIPTION: Explains how variance positions (covariant, contravariant, invariant) are determined for types and type arguments in the context of nullable type inference. This defines the rules for how nullability is determined during type inference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-01.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCovariant: A type is in a covariant position if it is\\n- a top level type,\\n- a type argument to a covariant type parameter of a generic type in a covariant position\\n- a type argument to a contravariant type parameter if a generic type in a contravariant position\\n\\nContravariant: A type is in a contravariant position if it is:\\n- a type argument to a contravariant type parameter of a generic type in a covariant position\\n- a type argument to a covariant type parameter if a generic type in a contravariant position\\n\\nInvariant: A type is in an invariant position if it is:\\n- a type argument to an invariant type parameter\\n- a type argument to a type parameter of a generic type in an invariant position\n```\n\n----------------------------------------\n\nTITLE: Struct Field Constructor Ignored in C#\nDESCRIPTION: These code snippets illustrate how the implicitly-defined parameterless constructor in a struct will zero fields, ignoring any parameterless constructors defined within the field types themselves. This behavior remains unchanged from C# 9.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n\"struct S0\\n{\\n    public S0() { }\\n}\\n\\nstruct S1\\n{\\n    S0 F; // S0 constructor ignored\\n}\\n\\nstruct S<T> where T : struct\\n{\\n    T F; // constructor (if any) ignored\\n}\"\n```\n\n----------------------------------------\n\nTITLE: LoggingInterpolatedStringHandler Implementation\nDESCRIPTION: Implementation of the logging interpolated string handler showing how the method name is used to determine log levels and control string building behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/interpolated-string-handler-method-names.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Microsoft.Extensions.Logging;\n{\n    using System.Runtime.CompilerServices;\n\n    [InterpolatedStringHandler]\n    public struct LoggingInterpolatedStringHandler\n    {\n        public LoggingInterpolatedStringHandler(int literalLength, int formattedCount, string methodName, ILogger logger, out bool continueBuilding)\n        {\n            var methodLogLevel = methodName switch\n            {\n                \"LogDebug\" => LogLevel.Debug,\n                \"LogInfo\" => LogLevel.Information,\n                \"LogWarn\" => LogLevel.Warn,\n                \"LogError\" => LogLevel.Error,\n                _ => throw new ArgumentOutOfRangeException(methodName),\n            };\n\n            if (methodLogLevel < logger.LogLevel)\n            {\n                continueBuilding = false;\n            }\n            else\n            {\n                continueBuilding = true;\n                // Set up the rest of the builder\n            }\n        }\n    }\n    public static class LoggerExtensions\n    {\n        public static void LogWarn(this ILogger logger, [InterpolatedStringHandlerArgument(\"Method Name\", nameof(logger))] ref LogInterpolatedStringHandler message);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Interface with New Default Implementation in C#\nDESCRIPTION: This code snippet shows the modification of interface I3 to include a new default implementation, potentially causing ambiguity for implementing classes that haven't been recompiled.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-11.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ninterface I3 : I1 { override void M() { Impl3 } }\n```\n\n----------------------------------------\n\nTITLE: Unary Plus Operator for IntPtr and UIntPtr\nDESCRIPTION: Defines the unary plus operator for System.IntPtr and System.UIntPtr types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator +(System.IntPtr)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator +(System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Non-Nullable Return Type Breaking Change Example in C#\nDESCRIPTION: Example showing how adding non-nullable annotations to method return types would be a breaking change due to type inference changes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-04.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic string! Foo() { ... } // '!' newly added\n\nvar s = Foo(); // Now infers 'string!' instead of 'string' for s\n...\ns = GetString(); // So this assignment is now broken\n```\n\n----------------------------------------\n\nTITLE: Nullable Array Instantiation Approach 2 in C#\nDESCRIPTION: Second approach for instantiating nullable arrays with different syntax patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-28.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nnew string?[3][]\nnew string[3][]? // invalid\nnew string[]?[3]\n```\n\n----------------------------------------\n\nTITLE: Semantic equivalent of new C# language features\nDESCRIPTION: Shows the semantic equivalent of the new language features using traditional C# syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-02-29.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar p = new Person(\"Mickey\", \"Mouse\"); // constructor call\nif (p.FirstName == \"Mickey\") // property access\n{\n  return new Person(\"Minney\", p.LastName); // constructor call\n}\n```\n\n----------------------------------------\n\nTITLE: Target-typed new Grammar Definition in ANTLR\nDESCRIPTION: ANTLR grammar rules defining the syntax for target-typed new expressions in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-new.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR\nCODE:\n```\nobject_creation_expression\n    : 'new' type '(' argument_list? ')' object_or_collection_initializer?\n    | 'new' type object_or_collection_initializer\n    | target_typed_new\n    ;\ntarget_typed_new\n    : 'new' '(' argument_list? ')' object_or_collection_initializer?\n    ;\n```\n\n----------------------------------------\n\nTITLE: Translating Creation of ImmutableArray from Span<T> in C#\nDESCRIPTION: This snippet shows how to create an ImmutableArray while initializing the data directly into a span, thus optimizing the usage of arrays with reduced overhead when constructing collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<string> __storage = CollectionsMarshal.Create<string>(capacity: 3, out ImmutableArray<string> values);\n__storage[0] = \"a\";\n__storage[1] = \"b\";\n__storage[2] = \"c\";\n```\n\n----------------------------------------\n\nTITLE: Initializing Readonly Local with Null-Coalescing Operator in C#\nDESCRIPTION: Illustrates that readonly locals can be initialized with any valid expression, including the null-coalescing operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/readonly-locals.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly T data = arg1 ?? arg2;\n```\n\n----------------------------------------\n\nTITLE: Handling Type Arguments in C# Compat Mode\nDESCRIPTION: This code snippet demonstrates how compat mode handles type arguments.  It first matches type argument lists against the full type parameter list generated in the corresponding static method. Only if no applicable methods are found is an attempt made using only the type parameter list from the extension method itself.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/compat-mode-in-extensions.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TSource>(this IEnumerable<TSource> source)\n    {\n        public IEnumerable<TSource> Select<TResult>(Func<TSource, TResult> selector)  { ... }\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Flow Attributes in C#\nDESCRIPTION: Examples of flow attributes [DoesNotReturn] and [DoesNotReturnIf] in C#. These attributes signal when a method affects control flow, helping the compiler reduce unnecessary warnings in nullability analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-05-15.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Environment \n{ \n    [DoesNotReturn] \n    public static void FailFast(string message); \n} \n \npublic class ExceptionDispatchInfo \n{ \n    [DoesNotReturn] \n    public void Throw(); \n} \n \ninternal static class ThrowHelper \n{ \n    [DoesNotReturn] \n    public static void ThrowArgumentNullException(ExceptionArgument arg); \n} \n \npublic static class Debug \n{ \n    public static void Assert([DoesNotReturnIf(false)] bool condition); \n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Method in #nullable disabled Context\nDESCRIPTION: Shows how overriding a method with a nullable class constraint in a #nullable disabled context inherits the constraint from the base method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-15.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nclass B : A\n{\n#nullable disable\n    public override void F2<U>(U y)\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Pure Null Checks in Switch Expressions in C#\nDESCRIPTION: Example demonstrating the question of whether pattern matching with {} in a switch expression should be considered a pure null check, similar to its behavior in is expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-06.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(object x)\n{\n    _ = x switch\n    {\n        1 => x.ToString(),\n        {} => x.ToString(), // is this a \"pure\" null test?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Doc Comments with Partial Properties in C#\nDESCRIPTION: Example showing how documentation comments are handled when present on both definition and implementation parts of a partial property. Comments on the implementation part take precedence.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// My type\n/// </summary>\npartial class C\n{\n    /// <summary>Definition part comment</summary>\n    /// <returns>Return value comment</returns>\n    public partial int Prop { get; set; }\n    \n    /// <summary>Implementation part comment</summary>\n    public partial int Prop { get => 1; set { } }\n}\n```\n\n----------------------------------------\n\nTITLE: In-Operator for Invoking Extension Methods in C#\nDESCRIPTION: Illustrates an alternative 'in' operator syntax for invoking extension methods, offering a consistent invocation style akin to standard language keywords.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = (IEnumerable<int> in MyExtensions).Range(0, 10);\nvar empty = (IEnumerable<int> in MyExtensions).Empty;\n(range in MyExtensions) += 5;\nReadOnlySpan<int> span = range in MyExtensions;\n\n// Instance extension members\nvar query = (range in MyExtensions).Where(i => i < 10);\nvar isEmpty = (query in MyExtensions).IsEmpty;\nvar first = (query in MyExtensions)[0];\nvar repetition = new (IEnumerable<int> in MyExtensions)(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Defining a Ref Struct with Multiple Ref Fields in C#\nDESCRIPTION: This example shows two different ways of defining lifetimes for multiple ref fields within a ref struct, demonstrating the potential complexity of lifetime management.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/REF-2022-11-11.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nref struct RS { \n  ref 'a Span<byte> Field1;\n  ref 'a Span<byte> Field2;\n}\n// Option 2: flexible but now we have a tree\nref struct RS { \n  ref 'a Span<byte> Field1;\n  ref 'b Span<byte> Field2;\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage - Property Initializers\nDESCRIPTION: Code snippet demonstrating the discussed property initializer patterns and backing field access\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-12.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Example {\n    // Property with initializer\n    public int AutoProperty { get; set; } = 42;\n    \n    // Semi-auto property with field access\n    public int SemiAutoProperty {\n        get => field;\n        init => field = value;\n    } = 42; // Initializer discussion point\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Direct Invocation Examples in C#\nDESCRIPTION: Code examples demonstrating the limitations and issues with direct lambda invocation. Shows two cases: an Action lambda that can be invoked and a lambda with parameters that cannot infer delegate type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-07-26.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n(() => {})(); // Infer Action, can be invoked\n(x => x)(1); // Cannot infer a delegate type on its own: would need to take the argument expression into account\n```\n\n----------------------------------------\n\nTITLE: Surrogate Pair UTF8 Conversion in C#\nDESCRIPTION: Example of handling surrogate pairs in string constant to UTF8 byte sequence conversion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\nconst string first = \"\\uD83D\";  // high surrogate\nconst string second = \"\\uDE00\"; // low surrogate\nReadOnlySpan<byte> span = first + second;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating LongRange Usage with '..' Operator in C#\nDESCRIPTION: This snippet demonstrates how the '..' operator can be used with target typing to create a LongRange. It also highlights potential issues with conversions between range types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-12-06.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nLongRange lr = 1 .. 10;\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable-If-Reference Return Type in C#\nDESCRIPTION: Example showing proposed syntax for FirstOrDefault implementation using a hypothetical NullableIfReference attribute to handle nullable reference types in generic methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-15.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic [return:NullableIfReference] T FirstOrDefault<T>(this IEnumerable<T> src)\n{\n    if ...\n    else return default(T);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Dammit Operator Type Narrowing in C#\nDESCRIPTION: Illustrates how the dammit operator (!) can narrow nullable types to non-nullable and suppress warnings, including generic array creation scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-11.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string? n)\n{\n\tvar s = n!;       // s is string, not string? \n\tvar l = s.Length; // ok\n}\n\nT[] MakeArray<T>(T v)\n{\n\treturn new T[] { v };\n}\n\nvoid M(string? n)\n{\n\tvar a = MakeArray(n!); // a is string[], not string?[]\n\tvar l = a[0].Length;   // ok\n}\n```\n\n----------------------------------------\n\nTITLE: Interpolated String Handler Argument Value Implementation\nDESCRIPTION: Proposal for passing constant values to interpolated string handlers with a single constant value via attribute, with explicit disallowance of array arguments\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-04-07.md#2025-04-21_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Raw String Literal Interpolation in C#\nDESCRIPTION: This snippet shows how interpolation works in the proposed raw string literal syntax. The number of '$' symbols determines how many braces are required for an interpolation hole.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-05-17.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar z = $$\"\"\"\n{{{1 + 1}}}\n\"\"\";\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C# 8.0 Alternative Index Syntax\nDESCRIPTION: Shows the '-x' syntax that was considered but not adopted for indexing from the end of sequences.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-02.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n-x\n```\n\n----------------------------------------\n\nTITLE: Record Struct Declaration in C# 10.0\nDESCRIPTION: Demonstrates the new record struct syntax for declaring value types with built-in value equality and with-expression support.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nrecord struct Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Range Type Inference Example\nDESCRIPTION: Demonstrates type inference with range expressions returning Range type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-22.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvar r = 4..6; // infer Range\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Global Using Ambiguity in C#\nDESCRIPTION: Code example showing potential ambiguity between global using alias and top-level using variable declaration, where 'global' is used as both a keyword and type name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-02-22.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Is this a global using alias, or a top-level using variable declaration?\nusing global myVar = Test.AGlobal;\n\nclass Test\n{\n    public static global AGlobal = new global();\n}\n\nclass global : IDisposable { public void Dispose() {} }\n```\n\n----------------------------------------\n\nTITLE: Defining null-conditional await expression in ANTLR grammar for C#\nDESCRIPTION: This ANTLR grammar snippet defines the syntax for the proposed null-conditional await expression in C#. It adds a new form of await_expression that includes a question mark after 'await'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/null-conditional-await.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nawait_expression\n    : 'await' '?' unary_expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch Expression in C#\nDESCRIPTION: Demonstrates the current syntax for switch expressions in C#, using arrow notation and patterns for matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-30.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ne switch\n{\n    1 => \"one\",\n    2 => \"two\",\n    var x when x > 2 => \"too many\",\n    _ => \"too few\"\n}\n```\n\n----------------------------------------\n\nTITLE: Cast Operators for IntPtr\nDESCRIPTION: Defines various cast operators for System.IntPtr, including conversions to and from integer types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit operator sbyte(System.IntPtr)               // Truncate\nexplicit operator short(System.IntPtr)               // Truncate\nexplicit operator int(System.IntPtr)                 // Truncate\nexplicit operator long(System.IntPtr)                // Sign Extend\n\nexplicit operator byte(System.IntPtr)                // Truncate\nexplicit operator ushort(System.IntPtr)              // Truncate\nexplicit operator uint(System.IntPtr)                // Truncate\nexplicit operator ulong(System.IntPtr)               // Zero Extend\n\nexplicit operator System.IntPtr(int)                 // Sign Extend\nexplicit operator System.IntPtr(long)                // Truncate\n\nexplicit operator System.IntPtr(uint)                // Sign Extend\nexplicit operator System.IntPtr(ulong)               // Truncate\n\nexplicit operator System.IntPtr(System.IntPtr)\nexplicit operator System.IntPtr(System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Non-invocation Scenario in Implicit Extensions in C#\nDESCRIPTION: This example illustrates how property access works in implicit extensions with inheritance, potentially finding the same property twice.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension Base for object \n{\n    int Prop => 0;\n}\nimplicit extension Derived for object : Base\n{\n}\n\nobject o = ...;\no.Prop; // find it twice, but it's only Base.Prop, so okay\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Conditional Operator in C#\nDESCRIPTION: Example demonstrating a breaking change in overload resolution behavior when target-typing the conditional operator\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-08.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(short)\nvoid M(long)\nM(b ? 1 : 2)\n```\n\n----------------------------------------\n\nTITLE: Lowered Method with Params Reuse in C#\nDESCRIPTION: This code exhibits how a method making multiple calls to a params function can be optimized by reusing a FixedSizeArray and ReadOnlySpan. It details the consideration for clearing arrays to prevent data persistence across iterations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/params-improvements/PI-2022-11-03.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void WriteDictionary<K, V>(Dictionary<K, V> dictionary)\n{\n    FixedSizeArray2 _tmp1 = new FixedSizeArray2();\n\n    WriteLine(\"Dictionary\",\n        new ReadOnlySpan<object>(Array.Empty<object>()); // no reuse\n\n    foreach (var (k, v) in dictionary)\n    {\n        _tmp1.Array[0] = k;\n        _tmp1.Array[1] = v;\n        WriteLine(\"{0}, {1}\",\n            new ReadOnlySpan(_tmp1.Array)); // reuse\n        Array.Clear(_tmp1.Array);           // clear\n    }\n\n    _tmp1.Array[0] = dictionary.Count;\n    WriteLine(\"Count = {0}\",\n        new ReadOnlySpan(_tmp1.Array, 0, 1)); // reuse\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constructor Body Syntax Options for Primary Constructors in C#\nDESCRIPTION: Shows various syntax options for adding user-provided constructor bodies to classes with primary constructors, including full signature repetition, class name options, and using 'this' keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-21.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C(int x): B(x)\n{\n    // Repeat the full signature â€“ redundant and error prone\n    C(int x) { Register(this); } \n    // Class name and empty parens â€“ clashes with noarg constructor syntax, \n    // but similar to static constructors\n    C() { Register(this); }\n    // Just the class name â€“ a little unfamiliar\n    C { Register(this); }\n    // Prefix with 'this' keyword â€“ again a bit unfamiliar\n    this { Register(this); }\n    // Just the block â€“ succinct but mysterious â€“ and has the eval order issue\n    { Register(this); }\n}\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Mutable Properties with Structural Equality in C#\nDESCRIPTION: An example of the problematic pattern where developers might resort to using mutable properties with structural equality to avoid writing constructors. This approach creates risks when using objects as dictionary keys.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-11.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    public key string Item1 { get; set; }\n    public string Item2 { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Current CS1612 Error Behavior\nDESCRIPTION: Shows how the current compiler restricts struct property assignments with CS1612 error, even when the setter is readonly, using ArraySegment<T> as an example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/readonly-setter-calls-on-non-variables.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar c = new C();\n// Remove the current CS1612 error, because ArraySegment<T>.this is readonly:\nc.ArraySegmentProp[10] = new object();\n\n// Invocation expressions already omit the CS1612 error when the setter is readonly:\nc.ArraySegmentMethod()[10] = new object();\n\n// In limited cases, ref-returning indexers can be used to work around this:\nc.RefReturningIndexerWorkaround[10] = new object();\n\nclass C\n{\n    public ArraySegment<object> ArraySegmentProp { get; set; }\n    public ArraySegment<object> ArraySegmentMethod() => ArraySegmentProp;\n\n    public Span<object> RefReturningIndexerWorkaround => ArraySegmentProp.AsSpan();\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Span<int> with Collection Expression in C#\nDESCRIPTION: This snippet demonstrates the creation of a Span<int> using a collection expression. The working group discusses the ref-safety scope for such expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> s = [x, y, z];\n```\n\n----------------------------------------\n\nTITLE: Expression-Bodied User-Defined Conversion in C#\nDESCRIPTION: Shows how expression-bodied syntax can be used for user-defined type conversions. This allows for concise implementation of implicit or explicit conversion operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-11-04.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static implicit operator string(Name n) => n.First + \" \" + n.Last;\n```\n\n----------------------------------------\n\nTITLE: Declaring a Struct with Default Expression in C#\nDESCRIPTION: Example showing a struct declaration using the default expression, which doesn't generate warnings even with non-nullable fields due to the 'default loophole' in C#'s nullable reference type system.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-04.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar y = default(SomeStructWithNonNullableFields);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Breaking Change with nameof in C#\nDESCRIPTION: Illustrates a potential breaking change if parameter names were allowed in scope for nameof. This example shows how existing code could be affected if the change were implemented without careful consideration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-16.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nconst int p = 3;\n[Attribute(Property = p)]\nvoid M(int p) { }\n```\n\n----------------------------------------\n\nTITLE: Generic Method Nullability Overrides\nDESCRIPTION: Demonstrates explicit nullability annotations on generic type parameters in method signatures, showing how to override default nullability behavior for specific use cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-08-18.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nT! FirstNonNull<T>(IList<T> list) { ... }\nT? FirstOrDefault<T>(IList<T> list) { ... }\n```\n\n----------------------------------------\n\nTITLE: Disallowing Target Typing for ReadOnlyList Initialization in C#\nDESCRIPTION: This snippet illustrates the impact of disallowing target typing when initializing a read-only list. An explicit type conversion (to `ImmutableArray<OrderTag>`) or using `Array.Empty<OrderTag>()` becomes necessary, resulting in more verbose code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nclass Order : ITaggable\n{\n    // Not allowed:\n    public IReadOnlyList<OrderTag> Tags { get; } = [];\n\n    // Write this instead:\n    public IReadOnlyList<OrderTag> Tags { get; } = (ImmutableArray<OrderTag>)[];\n\n    // Which is worse than just:\n    public IReadOnlyList<OrderTag> Tags { get; } = Array.Empty<OrderTag>();\n}\n```\n\n----------------------------------------\n\nTITLE: Translating Collection Initialization with ImmutableHashSet in C#\nDESCRIPTION: This snippet demonstrates how an array initialization translates to an instance construction using ImmutableHashSet's factory method Create, showing the efficiency of using ReadOnlySpan.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nImmutableHashSet<int> values = [1, 2, 3];\n\n// translates to:\nReadOnlySpan<int> __values = [1, 2, 3];\nImmutableHashSet<int> values = ImmutableHashSet.Create<int>(__values);\n```\n\n----------------------------------------\n\nTITLE: Ref Assignment to Readonly Fields in Constructors\nDESCRIPTION: Shows the behavior of taking a ref to a readonly field within a constructor or init member, where the type is ref rather than ref readonly, allowing for initialization patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_52\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S\n{\n    readonly int i; \n\n    public S(string s)\n    {\n        M(ref i);\n    }\n\n    static void M(ref int i) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Range Expression Examples in C#\nDESCRIPTION: Examples of range syntax showing different ways to express ranges in C#, including closed ranges, open-ended ranges, and variable ranges.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-18.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar r = 3..5;        // Closed range\ntensor[.., ..1, ..]  // Multi-dimensional slicing with open ranges\nx..                 // Open-ended range (to end)\n..y                 // Open-ended range (from start)\n..                  // Fully open range\n```\n\n----------------------------------------\n\nTITLE: Covariant Returns in C# Interfaces\nDESCRIPTION: Examples demonstrating the proposed syntax for covariant returns in interfaces, showing both implementation and override scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-08.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ninterface I1\n{\n    object M();\n}\ninterface I2 : I1\n{\n    string M() => null;\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\ninterface I1\n{\n    object M();\n}\ninterface I2 : I1\n{\n    override string M() => null;\n}\n```\n\n----------------------------------------\n\nTITLE: Record Class Init-only Property\nDESCRIPTION: Example of init-only property syntax used in record classes\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-10-05.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic string FirstName { get; init; }\n```\n\n----------------------------------------\n\nTITLE: Tuple Item Warning Example in C#\nDESCRIPTION: Shows warning behavior when using explicit Item1/Item2 names in tuple literals where names are not preserved in target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-12.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n(int, int) t = (Item1: 1, Item2: 2); // Warning, names are lost\n```\n\n----------------------------------------\n\nTITLE: Null Tracking Expression Grammar in ANTLR\nDESCRIPTION: ANTLR grammar defining the syntax for expressions that can be tracked for null state, including simple names, this, base, and member access expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_8\n\nLANGUAGE: antlr\nCODE:\n```\ntracked_expression\n    : simple_name\n    | this\n    | base\n    | tracked_expression '.' identifier\n    ;\n```\n\n----------------------------------------\n\nTITLE: Constructor Call Translation - C#\nDESCRIPTION: Shows how the object initializer syntax would be translated into a direct constructor call by the compiler.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-07.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nvar p = new Person(\"Blaise\", \"Pascal\");\n```\n\n----------------------------------------\n\nTITLE: Manual Deconstruction Translation\nDESCRIPTION: Equivalent query using manual unpacking of tuples instead of deconstruction syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nfrom __p1 in points\nlet x = __p1.Item1\nlet y = __p1.Item2\nlet __p2 = (x - x0, y - y0)\nlet dx = __p2.Item1\nlet dy = __p2.Item2\nselect Sqrt(dx * dx, dy * dy)\n```\n\n----------------------------------------\n\nTITLE: Declaring Classic Extension Method in C#\nDESCRIPTION: This snippet represents a classic static extension method defined to convert an array to a Span type. It highlights the generic parameter 'T' and how such traditional methods facilitate operations on array-like data structures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class MemoryExtensions\n{\n    public static Span<T> AsSpan<T>(this T[]? array);\n}\n```\n\n----------------------------------------\n\nTITLE: Nominal Deconstruction Pattern Example in C#\nDESCRIPTION: Example showing the proposed nominal deconstruction syntax with nested property access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-11-16.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar { Range: { Column: column } range } = GetRange();\n```\n\n----------------------------------------\n\nTITLE: Comparing Tuple-Returning Deconstructors in C#\nDESCRIPTION: Contrasts the current syntax for deconstructors using out parameters with a potential tuple-returning syntax. The efficiency of each approach may vary depending on circumstances.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-10-25-26.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// Potential tuple-returning syntax\n(int x, int y) Deconstruct() => (X, Y);\n\n// Current syntax with out parameters\nvoid Deconstruct(out int x, out int y) => (x, y) = (X, Y);\n```\n\n----------------------------------------\n\nTITLE: C# Extension Method Conflict Example\nDESCRIPTION: This code demonstrates a potential conflict scenario with extension methods, where both the class itself and an extension method define members with the same signature. It highlights the need for validation rules to prevent ambiguous consumption scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-03-24.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    static Color Color { get; }\n\n    static void Main()\n    {\n        Color.M(); // What M is called?\n    }\n}\n\nclass Color\n{\n    public static void M() {}\n    public void M() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Updating ANTLR Grammar for Role Declaration in C#\nDESCRIPTION: Modifies the ANTLR grammar to rename 'extension_declaration' to 'role_declaration' and updates the syntax to include both 'role' and 'extension' keywords.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/rename-to-roles-and-extensions.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nrole_declaration\n    : role_modifier* ('role' | 'extension') identifier type_parameter_list? ('for' type)? type_parameter_constraints_clause* role_body\n    ;\n```\n\n----------------------------------------\n\nTITLE: Python Range Example\nDESCRIPTION: Example showing Python's approach to indexing from the end using negative numbers, where -1 refers to the last element.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-26.md#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\narray[-1]    # Access last element\narray[1:-1]   # Range from second element to second-to-last\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Current Lookup Rules for Interfaces in C#\nDESCRIPTION: This code illustrates how current C# lookup rules handle interface members in multi-inheritance scenarios, which can be applied to extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nI2 i2 = default!;\nvar r2 = i2.Prop; // Finds I2.Prop, infers long\n\nI4 i4 = default!;\nvar r4 = i4.Prop; // Finds I2.Prop, infers long\n\npublic interface I1 { public int Prop { get; } }\npublic interface I2 : I1 { new public long Prop { get; } }\npublic interface I3 : I1 { }\npublic interface I4 : I2, I3 { }\n```\n\n----------------------------------------\n\nTITLE: Exploring Underscore as Wildcard in C#\nDESCRIPTION: Examples of potential uses of underscore (_) as a wildcard in various C# contexts, including out arguments, lambda expressions, and deconstructions. Demonstrates the need for careful rules to preserve current semantics while allowing new wildcard functionality.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-10-25-26.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nM(out var _);\nint _ = e.M(_ => ..._...x...);\n(int x, var _) = e.M(_ => ..._...x...);\n(_, _) = (\"x\", 2);\n```\n\n----------------------------------------\n\nTITLE: Type Parameter Constraints with new() and struct in C#\nDESCRIPTION: This code demonstrates how the compiler treats structs with different constructor accessibility when used with new() and struct constraints. The compiler assumes all structs satisfy these constraints, which may cause runtime issues if the parameterless constructor isn't public.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n// public struct PublicConstructor { public PublicConstructor() { } }\n// public struct InternalConstructor { internal InternalConstructor() { } }\n\nstatic T CreateNew<T>() where T : new() => new T();\nstatic T CreateStruct<T>() where T : struct => new T();\n\n_ = CreateNew<PublicConstructor>();      // ok\n_ = CreateStruct<PublicConstructor>();   // ok\n\n_ = CreateNew<InternalConstructor>();    // compiles; may fail at runtime\n_ = CreateStruct<InternalConstructor>(); // compiles; may fail at runtime\n```\n\n----------------------------------------\n\nTITLE: Object Initializer with Params Collection\nDESCRIPTION: Illustrates evaluation order in object initializer syntax with params collections, showing field assignments and indexer access patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nclass C1\n{\n    public int F1;\n    public int F2;\n}\n\nclass Program\n{\n    static void Test()\n    {\n        _ = new Program() { [GetA(), GetC()] = { F1 = GetF1(), F2 = GetF2() } };\n    }\n\n    C1 this[int a, params MyCollection c] => new C1();\n\n    static int GetA() => 0;\n    static int GetC() => 0;\n    static int GetF1() => 0;\n    static int GetF2() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default in ternary operations in C#\nDESCRIPTION: Using default literal in conditional expressions where the type is inferred from the other branch of the operation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar x = flag ? default : ImmutableArray<SomeType>.Empty;\n```\n\n----------------------------------------\n\nTITLE: Implementing String Builder in C# Records - Rejected Design Pattern\nDESCRIPTION: Example reference to implementing ToString() in records using StringBuilder vs InterpolatedStringBuilder. This implementation pattern was rejected due to complexity with existing code interoperability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-05-03.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic string ToString()\n{\n    // Current approach uses StringBuilder\n    StringBuilder sb = new StringBuilder();\n    // vs proposed InterpolatedStringBuilder approach\n    // InterpolatedStringBuilder builder = new InterpolatedStringBuilder();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating IEnumerable<string> Collection Literal in C#\nDESCRIPTION: Example showing how an empty collection literal could be assigned to an IEnumerable<string> variable. The team discussed whether this should be implemented as a List<> or optimized to use Enumerable.Empty<string>() to avoid unnecessary allocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-04-26.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<string> e = [];\n```\n\n----------------------------------------\n\nTITLE: Extension Scoping Rules Example\nDESCRIPTION: Example demonstrating scoping rules for extension declarations including type parameters and receiver parameters\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic static class E\n{\n    extension<T>(T[] ts)\n    {\n        public bool M1(T t) => ts.Contains(t);        // `T` and `ts` are in scope\n        public static bool M2(T t) => ts.Contains(t); // Error: Cannot refer to `ts` from static context\n        public void M3(int T, string ts) { }          // Error: Cannot reuse names `T` and `ts`\n        public void M4<T, ts>(string s) { }           // Error: Cannot reuse names `T` and `ts`\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Out Variable Declaration with Generics\nDESCRIPTION: Example showing generic type usage in out variable declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nM(out Type name);\nM(out A<B> name);\n```\n\n----------------------------------------\n\nTITLE: Disambiguation Scenarios for Extension Methods in C#\nDESCRIPTION: This snippet explores disambiguation scenarios where both extension properties and old-style extension methods are involved. It showcases a potential issue in method resolution and the behavior of the C# language in this context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-02-28.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass TableIDoNotOwn : IEnumerable<Item> { }\n\nstatic class IEnumerableExtensions\n{\n    public int Count<T>(this IEnumerable<T> t);\n}\n\nimplicit extension MyTableExtensions for TableIDoNotOwn\n{\n    public int Count { get { ... } }\n}\n\n// What happens here?\nvar v = table.Count; // Let's get a read from LDM\n```\n\n----------------------------------------\n\nTITLE: Method Argument Ambiguity with Declaration Expressions in C#\nDESCRIPTION: Example showing how declaration expressions can be ambiguous with method arguments, where it's unclear if the code represents two arguments or one declaration expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-01-06.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\na ( b < c , d > e ) // two arguments or one declaration expression?\n```\n\n----------------------------------------\n\nTITLE: Markdown Meeting Notes Structure\nDESCRIPTION: Basic markdown structure showing the agenda and discussion points from a C# language design meeting, including headings and links to specific topics.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-15.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# C# Language Design Meeting for March 15th, 2021\n\n## Agenda\n\n1. [Interpolated string improvements](#interpolated-string-improvements)\n2. [Global usings](#global-usings)\n```\n\n----------------------------------------\n\nTITLE: Defining Unsigned Shift Right Operators in C#\nDESCRIPTION: This snippet specifies the unsigned right shift operator for nint and nuint types. It behaves similarly to the regular right shift operator but preserves the integrity of zero. Takes 'x' and 'count' parameters to perform the operation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnint operator >>>(nint x, int count);\n    nuint operator >>>(nuint x, int count);\n```\n\n----------------------------------------\n\nTITLE: Declaring File-Local Types in C# 11.0\nDESCRIPTION: Demonstrates the use of the file modifier to declare a file-local type, introduced in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nfile class C { ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Generic Type Substitution with Nullable Types in C#\nDESCRIPTION: This code snippet illustrates how generic type substitution works with nullable, non-nullable, and oblivious types in C#. It shows different scenarios of method calls with various type arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-11.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nList<T> F<T>(T t);\nvar s = F(\"\");\n\nList<T> F<T>(T t);\nvar s = F(obliviousString);\n\nList<T?> F<T>(T? t);\nvar s = F(obliviousString);\n\nList<T> F<T>(T t)\nvar s = F(nullString);\n```\n\n----------------------------------------\n\nTITLE: Signature Matching Examples for Partial Properties in C#\nDESCRIPTION: Examples demonstrating various partial property signature matching errors, including modifier mismatches, accessor mismatches, and indexer parameter default value handling.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npartial class C1\n{\n    public partial string Prop { get; private set; }\n\n    // Error: accessor modifier mismatch in 'set' accessor of 'Prop'\n    public partial string Prop { get => field; set => field = value; }\n}\n\npartial class C2\n{\n    public partial string Prop { get; init; }\n\n    // Error: implementation of 'Prop' must have an 'init' accessor to match definition\n    public partial string Prop { get => field; set => field = value; }\n}\n\npartial class C3\n{\n    public partial string Prop { get; }\n\n    // Error: implementation of 'Prop' cannot have a 'set' accessor because the definition does not have a 'set' accessor.\n    public partial string Prop { get => field; set => field = value; }\n}\n\npartial class C4\n{\n    public partial string this[string s = \"a\"] { get; set; }\n    public partial string this[string s] { get => s; set { } } // ok\n\n    public partial string this[int i, string s = \"a\"] { get; set; }\n    public partial string this[int i, string s = \"a\"] { get => s; set { } } // CS1066: The default value specified for parameter 's' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments\n}\n```\n\n----------------------------------------\n\nTITLE: Option 3: Always Stack-Allocate for Ref-Struct Target Types in C#\nDESCRIPTION: Shows the chosen approach where collection expressions targeted to ref-struct types are always stack-allocated with local scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> x1 = [a, b, c];        // stack allocated, local scope.\nscoped ReadonlySpan<int> x2 = [a, b, c]; // stack allocated, local scope.\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution Examples in C#\nDESCRIPTION: Shows differences in overload resolution between array initializers and collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void Generic<T>(Span<T> value) { }\nstatic void Generic<T>(T[] value) { }\n\nstatic void SpanDerived(Span<string> value) { }\nstatic void SpanDerived(object[] value) { }\n\nstatic void ArrayDerived(Span<object> value) { }\nstatic void ArrayDerived(string[] value) { }\n\n// Array initializers\nGeneric(new[] { \"\" });      // string[]\nSpanDerived(new[] { \"\" });  // ambiguous\nArrayDerived(new[] { \"\" }); // string[]\n\n// Collection expressions\nGeneric([\"\"]); // Span<string>\nSpanDerived([\"\"]); // Span<string>\nArrayDerived([\"\"]); // ambiguous\n```\n\n----------------------------------------\n\nTITLE: Generic Extension Implementation in C#\nDESCRIPTION: Demonstrates how to implement generic extensions for collection types, showing both method and property extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nextension IListExtensions\n{\n    public void ForEach<T>(Action<T> act) for IList<T> list\n    {\n        foreach (var value in list)\n            act(list);\n    }\n\n    public long LongCount<T> for IList<T> list\n    {\n        get\n        {\n            long count = 0;\n            foreach (var value in list)\n                count++;\n\n            return count;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: API Reference for Count Checking\nDESCRIPTION: Reference to a runtime API used for efficiently checking collection counts without enumeration\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-02-03.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nTryGetNonEnumeratedCount\n```\n\n----------------------------------------\n\nTITLE: Parameter Reference in Discussion\nDESCRIPTION: Code references showing types discussed in the meeting, including ReadOnlySpan<T> and ReadOnlySpan<U> in context of string.Concat overloads and collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-17.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nReadOnlySpan<T>\nReadOnlySpan<U>\n```\n\n----------------------------------------\n\nTITLE: Addition Operators for IntPtr and UIntPtr\nDESCRIPTION: Defines addition operators for System.IntPtr and System.UIntPtr types with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator +(int, System.IntPtr)\nSystem.IntPtr operator +(System.IntPtr, int)\nSystem.IntPtr operator +(System.IntPtr, System.IntPtr)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator +(uint, System.UIntPtr)\nSystem.UIntPtr operator +(System.UIntPtr, uint)\nSystem.UIntPtr operator +(System.UIntPtr, System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Base Interface Implementation Syntax Options in C#\nDESCRIPTION: Different syntax proposals for invoking base interface implementations, showing various approaches to specifying the interface type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-19.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nI.base.M()\nbase(I).M()\nbase<I>.M()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating params usage with WriteLine in C#\nDESCRIPTION: Illustrates the difference between expanded form params call and collection literal usage. The code shows that params offers only a slight syntactic advantage over collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/params-improvements/PI-2022-10-25.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nWriteLine(fmt, a, b, c)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nWriteLine(fmt, [a, b, c])\n```\n\n----------------------------------------\n\nTITLE: Using Discards in C# to Silence Warnings for Dropped Tasks\nDESCRIPTION: This snippet demonstrates how discards can be used to silence warnings when intentionally dropping Tasks from async methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-15.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n_ = FooAsync();\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Definition for If Statement\nDESCRIPTION: ANTLR grammar specification showing the structure of an if statement with optional else clause.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nif_statement\n    : 'if' '(' boolean_expression ')' embedded_statement\n    | 'if' '(' boolean_expression ')' embedded_statement 'else' embedded_statement\n    ;\n```\n\n----------------------------------------\n\nTITLE: Deconstruction in Lambda Parameters in C#\nDESCRIPTION: Examples showing deconstruction syntax in lambda expressions and method parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\n(var (x, y)) => x + y;\ndouble M((int x1, int y1), (int x2, int y2)) => Sqrt(x1 * x2 + y1 * y2);\n```\n\n----------------------------------------\n\nTITLE: Alternative Generic-Style Function Pointer Syntax in C#\nDESCRIPTION: An alternative syntax for function pointers using a generic-style approach to avoid parsing issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-30.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfunc*<void>\ncdecl*<int, void>\n```\n\n----------------------------------------\n\nTITLE: Nested Lambdas Capture Chain in C#\nDESCRIPTION: Example of nested lambdas showing how inner lambdas capture variables from outer scopes, creating a chain of references. This example demonstrates the potential for memory leaks due to unintended captures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/README.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass Outer {\n    event Action e;\n    int x;\n    void M() {\n        int y = 0;\n        e += () => {\n            int z = 0;\n            Func<int> f = () => x + y + z; // Captures x (via 'this'), y, and z\n        };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Hypothetical Named Function Pointer Declaration in C#\nDESCRIPTION: This snippet illustrates a potential syntax for named function pointer declarations. It shows how a named function pointer type could be declared and used, though this feature was not adopted in the final proposal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nfunc* void Action();\n\nunsafe class NamedExample {\n    void M(Action a) {\n        a();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Property with Ambient Value Fallback in C#\nDESCRIPTION: Property implementation with custom getter falling back to parent value and auto setter\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n{ get => field ?? parent.AmbientValue; set; }\n```\n\n----------------------------------------\n\nTITLE: Generic Role Definition in C#\nDESCRIPTION: This snippet demonstrates defining roles with generics and discusses how to handle type parameters within attributes. It raises a question about whether `typeof` in an attribute can refer to a type parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nrole Role<T> : T {}\n\n// TODO: Confirm whether typeof in attribute can refer to T?\nRole<T> M<T>(Role<T> role)\n=>\n[return: Role(typeof(T))] UnderlyingType M<T>([Role(typeof(T))] UnderlyingType role)\n```\n\n----------------------------------------\n\nTITLE: Assigning to Getter-Only Auto-Properties in C# Constructors\nDESCRIPTION: Shows how to initialize getter-only auto-properties within a constructor, allowing for more flexible property initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\npublic class ConfigurationException : Exception\n{\n    private Configuration configuration;\n    public bool IsRemote { get; }\n    public ConfigurationException(Configuration configuration, string message) \n        : base(message)\n    {\n        if (configuration == null) \n        {\n            throw new ArgumentNullException(nameof(configuration));\n        }\n        this.configuration = configuration;\n        IsRemote = configuration.Settings[\"remote\"];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Member Shorthand in C#\nDESCRIPTION: Shows the proposed shorthand syntax for referring to static members or nested types of a target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\n// Instead of:\n\nColor color = Color.Red;\n\n// You can write:\n\nColor color = Red;\n\n// Instead of:\n\nU u = new U.A(10, \"ten\");\n\n// You can write:\n\nU u = new A(10, \"ten\");\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Local Variable Declaration\nDESCRIPTION: Defines the syntax for local variable declarations with optional 'scoped' modifier and variable mode modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_14\n\nLANGUAGE: antlr\nCODE:\n```\nlocal_variable_declaration\n    : 'scoped'? local_variable_mode_modifier? local_variable_type local_variable_declarators\n    ;\n\nlocal_variable_mode_modifier\n    : 'ref' 'readonly'?\n    ;\n```\n\n----------------------------------------\n\nTITLE: Record equality implementation with virtual dispatch in C#\nDESCRIPTION: Example showing a potential implementation of equality for record types with inheritance. This approach generates override methods for each base type to ensure direct virtual dispatch, but results in quadratic method growth.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-15.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass R1\n{\n    public override bool Equals(object other)\n        => Equals(other as R1);\n    public virtual bool Equals(R1 other)\n        => !(other is null) &&\n           this.EqualityContract == other.EqualityContract\n           /* && compare fields */;\n}\nclass R2 : R1\n{\n    public override bool Equals(object other)\n        => Equals(other as R2);\n\n    public override bool Equals(R1 other)\n        => Equals(other as R2);\n\n    public virtual bool Equals(R2 other)\n        => base.Equals((R1)other)\n           /* && compare fields */;\n}\nclass R3 : R2\n{\n    public override bool Equals(object other)\n        => Equals(other as R3);\n\n    public override bool Equals(R1 other)\n        => Equals(other as R3);\n\n    public override bool Equals(R2 other)\n        => Equals(other as R3);\n\n    public virtual bool Equals(R2 other)\n        => base.Equals((R1)other)\n           /* && compare fields */;\n}\n```\n\n----------------------------------------\n\nTITLE: HashSet Collection with Custom Comparer\nDESCRIPTION: Example showing potential syntax for initializing a HashSet with a custom string comparer for case-insensitive comparison.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nHashSet<string> values = [StringComparer.CaseInsensitive, .. names];\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Parameter Name Initialization\nDESCRIPTION: Example demonstrating confusing initialization when parameters share names with fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-03.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n    private string first = first; // WHAT???\n    private string last = last;\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Task Builder Pattern in C#\nDESCRIPTION: Example showing a static class pattern for building ValueTask objects. Demonstrates a potential but rejected approach for implementing task builder functionality using a generic method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-08-24.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstatic class ValueTaskBuilderBuilder\n{\n    ValueTaskBuilder<T> GetBuilder<T>(ValueTask<T> dummy);\n}\n```\n\n----------------------------------------\n\nTITLE: Attribute vs Collection Literal Ambiguity in C#\nDESCRIPTION: Shows parsing ambiguity between collection literals and attributes on statements or local functions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_20\n\nLANGUAGE: c#\nCODE:\n```\n[X(), Y, Z()].ForEach(() => ...);\n\n[X(), Y, Z()] void LocalFunc() { }\n```\n\n----------------------------------------\n\nTITLE: Proposed Method Signature for Readonly Struct Methods\nDESCRIPTION: Example showing the potential syntax for declaring readonly struct methods, discussing the ambiguity with readonly ref return types and alternative explicit receiver syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-19.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(in this S s)\n```\n\n----------------------------------------\n\nTITLE: Generic Tuple Null Comparison\nDESCRIPTION: Example showing tuple equality comparison with generic types and null values, demonstrating how null comparison semantics should be applied recursively.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-21.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n(t, i) == (null, 0)\n```\n\n----------------------------------------\n\nTITLE: Implementing Input Validation with a Private Helper Method in C#\nDESCRIPTION: Shows the conventional approach of using a private helper method for implementing an iterator with proper input validation, which requires duplicating type parameters and parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npublic static IEnumerable<T> Filter<T>(IEnumerable<T> s, Func<T, bool> p)\n{\n    if (s == null) throw new ArgumentNullException(\"s\");\n    if (p == null) throw new ArgumentNullException(\"p\");\n    return FilterImpl<T>(s, p);\n}\nprivate static IEnumerable<T> FilterImpl<T>(IEnumerable<T> s, Func<T, bool> p)\n{\n    foreach (var e in s)\n        if (p(e)) yield return e;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Illegal Global Scope Assignment in C#\nDESCRIPTION: Demonstrates an illegal assignment where a global scope variable is assigned a local scope (stack-allocated) value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> x3;              // global scope\nx3 = stackalloc int[] { a, b, c }; // illegal.  global scope now points at local data.\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Main Method Workaround in C#\nDESCRIPTION: Demonstrates how to work around limitations of async Main by creating a wrapper method that awaits a custom awaitable type. Shows the pattern of converting a custom awaitable type to a Task-returning Main method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-18.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstatic MyTask MyMain() { ... }\nstatic async Task Main() => await MyMain(); // problem solved\n```\n\n----------------------------------------\n\nTITLE: Formatted DateTime Interpolation Example\nDESCRIPTION: Shows string interpolation with custom format specifiers for DateTime values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n$\"Name = {myName}, hours = {DateTime.Now:hh}\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\nString.Format(\"Name = {0}, hours = {1:hh}\", myName, DateTime.Now)\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Variable Scoping Example\nDESCRIPTION: Example demonstrating switch statement pattern matching with when clauses and variable capture across multiple cases. Shows potential scoping issues with expression variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-11.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nswitch(...)\n{\n\tcase string s when .... x1:\n\tcase int i when .... x2 & capture x1:\n\tcase 1 when ... capture x1;\n\t\tbreak\n\n\tcase string s when .... x3:\n\tcase int i when .... x4:\n\tcase 1 when .... & capture something\n\t\tbreak;\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Ambiguity with Array Specifiers and Ternary Operator in C#\nDESCRIPTION: This code demonstrates the parsing ambiguity between nullable array notation and the ternary operator in C#. The question mark after 'A[][]' could be interpreted either as a nullable type annotation or as part of a ternary conditional expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-07.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\na ? x is A[][] ? b : c\n            // ^ Is this a nullable annotation or part of a ?:\n```\n\n----------------------------------------\n\nTITLE: C# Deconstruction with var Example\nDESCRIPTION: Example showing variable deconstruction syntax where scoped modifier cannot be inferred and must be explicitly declared.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-07-27.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar (x, y) = MethodCall();\n```\n\n----------------------------------------\n\nTITLE: Errors in Constant Expressions\nDESCRIPTION: This snippet demonstrates invalid constant expressions that lead to compile-time errors due to illegal boxing or implicit conversion. It helps to illustrate the limitations of constants in C#, thus informing developers of potential pitfalls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/constant_interpolated_strings.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nclass C \n{\n    const object i = 5;         // error: boxing conversion not permitted\n    const object str = \"hello\"; // error: implicit reference conversion\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Dictionary with Collection Literal in C#\nDESCRIPTION: Example of initializing a Dictionary<TKey, TValue> using a collection literal, demonstrating key-value pair syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> nameToAge = [ \"Dustin\": 42, \"Cyrus\": 43 ]; // possibly equivalent to:\n\nDictionary<string, int> nameToAge = new Dictionary<string, int> { { \"Dustin\", 42 }, { \"Cyrus\", 43 } }; \n```\n\n----------------------------------------\n\nTITLE: Demonstrating Property Pattern Examples\nDESCRIPTION: Code examples showing C#'s two current property patterns - auto-props and manual props, which represent different ends of the flexibility spectrum.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Auto-prop example\npublic string Name { get; set; }\n\n// Manual prop example\nprivate string _name;\npublic string Name\n{\n    get { return _name; }\n    set { _name = value; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullable and Non-nullable Generic Constraints in C#\nDESCRIPTION: Shows the implementation of nullable and non-nullable generic constraints using the proposed syntax. The example demonstrates how class C allows nullable Animal types while class D requires non-nullable Animal types, and how the T? syntax works differently in each context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-07.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T> where T : Animal? \n{\n  public T x;\n  public T? y; // warning\n}\nclass D<T> where T : Animal \n{\n  public T x;\n  public T? y;\n}\n\nC<Giraffe>\nC<Giraffe?>\n\nD<Squirrel>\nD<Squirrel?> // warning\n```\n\n----------------------------------------\n\nTITLE: Extended Stackalloc Grammar Definition in ANTLR\nDESCRIPTION: The new grammar rules for stackalloc that allow more flexible usage contexts and optional array initializers. Includes support for implicit sizing and initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nested-stackalloc.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nprimary_no_array_creation_expression\n    : stackalloc_initializer\n    ;\n\nstackallocator_initializer\n    : 'stackalloc' unmanaged_type '[' expression? ']' array_initializer?\n    | 'stackalloc' '[' expression? ']' array_initializer\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Tuple Conversions in C#\nDESCRIPTION: This snippet illustrates various potential conversion types between tuples, including covariance, truncation, reordering, and renaming. The code demonstrates these conversions using a base tuple (string name, int age).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\n(string name, int age) t = (\"Johnny\", 29);\n\n/* Covariance */\n(object name, int age) t1 = t;\n\n/* Truncation */\n(object name) t2 = t;\n\n/* Reordering */\n(int age, string name) t3 = t;\n\n/* Renaming */\n(string n, int a) t4 = t;\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Declaration Expressions Examples in C#\nDESCRIPTION: Examples of code where declaration expressions are grammatically ambiguous with existing C# expressions, such as multiplication vs. pointer declaration, and nested comparisons vs. generic type declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-01-06.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\na * b // multiplication expression or uninitialized declaration of pointer?\na < b > c // nested comparison or uninitialized declaration of generic type?\n```\n\n----------------------------------------\n\nTITLE: Nullability Attribute Example with Point Class\nDESCRIPTION: Demonstration of proposed EnsuresNotNull attribute usage on a method parameter referencing class member nullability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-05.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Point\n{\n    public object? X;\n}\nstatic void M([EnsuresNotNull(nameof(Point.X))]Point p) { ... }\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation Inheritance Example in C#\nDESCRIPTION: Code example demonstrating inheritance and interface implementation scenarios with tuple parameters, showing how base class implementations and interface requirements interact.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-28.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nitf I {\n\tvoid M((int a, int b) x);\n}\n\ncls Base {\n\tpublic void M((int, int) y);\n}\n\n// Separate assembly\ncls Derived, I {} // how does it know which syntax Base used?\n```\n\n----------------------------------------\n\nTITLE: Basic Record Class Definition in C#\nDESCRIPTION: Example of a simple record class definition with mutable properties representing user information.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class UserInfo\n{\n    public string Username { get; set; }\n    public string Email { get; set; }\n    public bool IsAdmin  { get; set; } = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Nullable Parameter Breaking Change Example in C#\nDESCRIPTION: Example showing how adding non-nullable annotations to existing method parameters would be a breaking change in existing code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-04.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic void Foo(string! name) { ... } // '!' newly added\n\nFoo(GetString()); // Unless GetString also annotated, this is now broken\n```\n\n----------------------------------------\n\nTITLE: Shadowing and Inheritance in Role Definitions\nDESCRIPTION: This code snippet demonstrates how a role can shadow methods of its underlying type in C#. Here, class C defines a method M, which is then shadowed by role R1. Subsequently, role R2 tries to call method M from R1, demonstrating the shadowing effect. This highlights the importance of handling shadowing warnings and using the 'new' keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-01-23.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    void M() { ... }\n}\nrole R1 : C\n{\n    // New version adds below\n    //void M() { ... }\n}\n\n// Different library\nrole R2 : R1\n{\n    void M2()\n    {\n        M();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Expression Compilation Example\nDESCRIPTION: Example showing how dictionary expressions are rewritten by the compiler, including the use of indexers for key-value pair assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<string, int> nameToAge = [\"mads\": 21, existingDict.MaxPair(), .. otherDict];\n\n// would be rewritten similar to:\n\nDictionary<string, int> __result = new();\n__result[\"mads\"] = 21;\n\n// Note: the below casts must be legal for the dictionary\n// expression to be legal\nvar __t1 = existingDict.MaxPair();\n__result[(string)__t1.Key] = (int)__t1.Value;\n\nforeach (var __t2 in otherDict)\n    __result[(string)__t2.Key] = (int)__t2.Value;\n```\n\n----------------------------------------\n\nTITLE: Inline Property Declaration Syntax\nDESCRIPTION: Compact syntax combining property declarations with constructor parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-15.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point(\n    public key int X { get; }\n    public key int Y { get; }\n);\n```\n\n----------------------------------------\n\nTITLE: Readonly Events Implementation\nDESCRIPTION: Demonstrates the usage of readonly modifier with events, showing both valid and invalid implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/readonly-instance-members.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Allowed\npublic readonly event Action<EventArgs> Event1\n{\n    add { }\n    remove { }\n}\n\n// Not allowed\npublic readonly event Action<EventArgs> Event2;\npublic event Action<EventArgs> Event3\n{\n    readonly add { }\n    readonly remove { }\n}\npublic static readonly event Event4\n{\n    add { }\n    remove { }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Default Value Check Example\nDESCRIPTION: Example showing illegal default value checking pattern in generic methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-05.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic T ID<T>(T t)\n{\n    if (t is default) Console.WriteLine();\n    return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Equivalent Struct Implementation in C#\nDESCRIPTION: Shows a struct implementation that mimics the functionality of an extension, including implicit conversion operators to and from string.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-08-09.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstruct JsonDoc\n{\n   public static implicit operator string(JsonDoc)\n   public static implicit operator JsonDoc(string)\n}\n```\n\n----------------------------------------\n\nTITLE: Speakable Lowering Syntax for Extension Methods in C#\nDESCRIPTION: Presents a speakable lowering approach which explicitly references operational methods by name, such as 'op_addition'. This style supports readability and debugging.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = MyExtensions.Range(0, 10);\nvar empty = MyExtensions.Empty;\nrange = MyExtensions.op_addition(range, 5);\nReadOnlySpan<int> span = MyExtensions.op_implicit(range); // Need target typing?\n\n// Instance extension members\nvar query = MyExtensions.Where(range, i => i < 10);\nvar isEmpty = MyExtensions.get_IsEmpty(query);\nvar first = MyExtensions.get_Item(query, 0);\nvar repetition = MyExtensions.__ctor_IEnumerable<int>(first, 10);\n```\n\n----------------------------------------\n\nTITLE: Generic Pattern Matching in Span<T>\nDESCRIPTION: These snippets explore pattern matching for generic Span<T> to test against constant strings. Although recommended, they are not implemented, producing compiler errors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/pattern-match-span-of-char-on-string.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic bool Is123<T>(Span<T> s)\n{\n    return s is \"123\"; // test for Span<char>?\n}\n\nstatic bool IsABC<T>(Span<T> s)\n{\n    return s is Span<char> and \"ABC\"; // ok?\n}\n\nstatic bool IsEmptyString<T>(T t) where T : ref struct\n{\n    return t is \"\"; // test for ReadOnlySpan<char>, Span<char>, string?\n}\n```\n\n----------------------------------------\n\nTITLE: Prefer Non-Generic Extension Method in C#\nDESCRIPTION: This example demonstrates how to prefer a non-generic extension method over a generic one. The code defines both a generic and a non-generic extension method named `P` for the `int` type, and the non-generic version should be chosen.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\n_ = 42.P;\n\npublic static class E\n{\n    extension<T>(T t)\n    {\n        public int P => throw null; \n    }\n    extension(int i) // non-generic, so better function member\n    {\n        public int P => 0;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Mutable Expression Variables\nDESCRIPTION: Example showing pattern matching with expression variables that are mutated within the same query clause.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nfrom o in objects\nwhere o is int i || (o is string s && int.TryParse(s, out i))\nselect i;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Ref Operator Usage in C#\nDESCRIPTION: Shows the proposed syntax for using a conditional operator with refs to choose between two variables. This allows modifying the first element of either array a1 or a2 based on a condition.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-28.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n(a1 != null ? ref a1[0] : ref a2[0]) = value; // Right!\n```\n\n----------------------------------------\n\nTITLE: Potential Enforcement of NullableOut Attribute in C#\nDESCRIPTION: This snippet demonstrates potential compiler enforcement for a proposed [NullableOut] attribute, showing warnings for non-nullable inputs and possible null reference assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-10-24.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass Task<[NullableOut] T>\n{\n    private T result; // maybe this needs a warning?\n    internal void SetResult1(T t) // warning: input of type 'T' should be nullable because the type parameter is nullable-covariant.\n    {\n        result = t; // ok\n    }\n\n    internal void SetResult1(T? t) // ok\n    {\n        result = t; // warning: possible null reference assignment.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Iterator Method Declaration\nDESCRIPTION: Example demonstrating an async iterator method declaration that returns IAsyncEnumerable<string>. This code is shown as an invalid example that would produce an error due to missing yield statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-12.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static async IAsyncEnumerable<string> M()\n    {\n        throw new NotImplementedException();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Partial Method Accessibility Examples in C#\nDESCRIPTION: Shows various accessibility scenarios for partial methods, including required implementations for explicit accessibility modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npartial class C\n{\n    // Okay because no definition is required here\n    partial void M1();\n\n    // Okay because M2 has a definition\n    private partial void M2();\n\n    // Error: partial method M3 must have a definition\n    private partial void M3();\n}\n\npartial class C\n{\n    private partial void M2() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Inline Common-Subexpression Declaration\nDESCRIPTION: Example of capturing and reusing a value within the same expression using declaration expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-09-03.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nConsole.WriteLine(\"Result: {0}\", (var x = GetValue()) * x);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Group Natural Type Inference in C#\nDESCRIPTION: This C# code demonstrates a scenario where the delegate type could not be inferred due to method group natural type inference rules. It shows how type arguments might not satisfy constraints, leading to a compile-time error CS8917. The proposal aims to address such issues by moving certain checks earlier in the overload resolution process, possibly causing slight breaking changes but allowing more scenarios to succeed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-08-07.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar x = new C().M<int>; // CS8917\\tThe delegate type could not be inferred.\n\npublic class C\n{\n    public void M<T>() { }\n    public void M<T>(object o) where T : class { }\n}\n```\n\n----------------------------------------\n\nTITLE: MemberNotNull Attribute Usage\nDESCRIPTION: Example of the agreed-upon MemberNotNull attribute syntax for marking member nullability.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-05.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[MemberNotNull(nameof(X))]\nvoid M() { }\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Collection Expression Overload Scenarios in C#\nDESCRIPTION: Example code demonstrating various ambiguous overload scenarios with collection expressions. Shows cases where overloads with different collection types (ReadOnlySpan, List, Span, etc.) would be ambiguous under the proposed rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/collection-expressions-better-conversion.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nC.M1([\"Hello world\"]); // Ambiguous, no tiebreak between ROS and List\nC.M2([\"Hello world\"]); // Ambiguous, no tiebreak between Span and List\n\nC.M3([\"Hello world\"]); // Ambiguous, no tiebreak between ROS and MyList.\n\nC.M4([\"Hello\", \"Hello\"]); // Ambiguous, no tiebreak between ROS and HashSet. Created collections have different contents\n\nclass C\n{\n    public static void M1(ReadOnlySpan<string> ros) {}\n    public static void M1(List<string> list) {}\n\n    public static void M2(Span<string> ros) {}\n    public static void M2(List<string> list) {}\n\n    public static void M3(ReadOnlySpan<string> ros) {}\n    public static void M3(MyList<string> list) {}\n\n    public static void M4(ReadOnlySpan<string> ros) {}\n    public static void M4(HashSet<string> hashset) {}\n}\n\nclass MyList<T> : List<T> {}\n```\n\n----------------------------------------\n\nTITLE: Value Equality Implementation Discussion\nDESCRIPTION: Code context discussion around KeyEquals method and EqualityContractOrigin implementation for value equality. Discusses type comparison performance and metadata patterns for inheritance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-03.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ntypeof(T) // Example context from discussion about Type comparison performance\n```\n\n----------------------------------------\n\nTITLE: Partial Events and Constructors Language Feature\nDESCRIPTION: Proposal to extend partial support to events and constructors in C# 13, motivated by specific use cases and validated by the language design team\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-01-22.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Value Type Nullability Alias Examples\nDESCRIPTION: Examples showing allowed using alias declarations for nullable value types using both Nullable<T> and shorthand syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-01-11.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing NullableInt = Nullable<System.Int32>;\nusing NullableInt = int?;\n```\n\n----------------------------------------\n\nTITLE: Record Struct Field Initializers without Constructors Error in C#\nDESCRIPTION: This code demonstrates the compiler error that occurs when a `record struct` has field initializers but lacks a primary constructor or any instance constructors. This is because the field initializers would have no constructor to execute them.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n\"record struct R0;                  // ok\\nrecord struct R1 { int F = 42; }   // error: 'struct' with field initializers must include an explicitly declared constructor\\nrecord struct R2() { int F = 42; } // ok\\nrecord struct R3(int F);           // ok\"\n```\n\n----------------------------------------\n\nTITLE: Record Declaration with Semicolon Body in C#\nDESCRIPTION: Example showing a legal record declaration using a semicolon body syntax, which was discussed as part of the breaking change considerations in the language specification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-01-18.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nrecord R1; // Legal today\n```\n\n----------------------------------------\n\nTITLE: Non-Error Bouncer Pattern\nDESCRIPTION: Example of bouncer pattern that corrects invalid input rather than throwing an error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-15.md#2025-04-23_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(object o)\n{\n  if (!(o is int i)) i = 0;\n  ...; // would be nice if i was in scope and definitely assigned here\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Extension Syntax for Single Type in C#\nDESCRIPTION: Shows a proposed syntax simplification for extensions that target a single type, reducing repetition in the code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nextension E\n{\n    // All extension members extend the same thing:\n\n    public void M() for SomeType str { ... }\n    public int P for SomeType str { get { ... } }\n    public static operator+(...) for SomeType str { ... }\n    // etc\n}\n```\n\n----------------------------------------\n\nTITLE: Potential Implementation of Tuples with Attributes in C#\nDESCRIPTION: Shows a possible implementation approach for tuples using value tuple structs with attributes to preserve member names for cross-assembly scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nstruct VTuple2<T1, T2> { ... }\nstruct VTuple3<T1, T2, T3> { ... }\n\n/* Source: */\n(x: int, y: int) f() { ... }\n\n/* Generates: */\n[TupleNames(\"x\", \"y\")]\nVTuple2<int, int> f() {...}\n```\n\n----------------------------------------\n\nTITLE: VB.NET NameOf Expression Syntax Implementation\nDESCRIPTION: VB.NET syntax tree node definition for the NameOf expression operator that includes an Argument property of type ExpressionSyntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_3\n\nLANGUAGE: vbnet\nCODE:\n```\nClass NameOfExpressionSyntax : Inherits ExpressionSyntax\n    Public ReadOnly Property Argument As ExpressionSyntax\nEnd Class\n```\n\n----------------------------------------\n\nTITLE: Basic Enum Class Shape Example\nDESCRIPTION: Simple example demonstrating enum class declaration for geometric shapes with parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/discriminated-unions.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nenum class Shape\n{\n    Rectangle(float Width, float Length),\n    Circle(float Radius),\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating null-conditional await usage in C# comments\nDESCRIPTION: These code comments illustrate the behavior of the proposed null-conditional await operator in C#. They show examples with Task and Task<K> types, explaining the expected results.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/null-conditional-await.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// If `e` is of type `Task`, then `await? e;` would do nothing if `e` is `null`, and await `e` if it is not `null`.\n//\n// If `e` is of type `Task<K>` where `K` is a value type, then `await? e` would yield a value of type `K?`.\n```\n\n----------------------------------------\n\nTITLE: Approach B1: Auto-prop Initialization (C#)\nDESCRIPTION: Illustrates the required initialization to eliminate the warning.  However, this initialization doesn't necessarily mean that `null` will never be observed from the getter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n\"public C()\\n{\\n    this.Prop = \\\"\\\";\\n    // would no longer warn, the auto-prop is considered initialized\\n    Console.WriteLine(this.Prop);\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Grammar for Collection Literals in C#\nDESCRIPTION: Proposed grammar changes to support collection literals in C#, including new productions for collection_literal_expression, collection_literal_element, and related constructs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nprimary_no_array_creation_expression\n  ...\n+ | collection_literal_expression\n  ;\n\n+ collection_literal_expression\n  : '[' ']'\n  | '[' collection_literal_element ( ',' collection_literal_element )* ']'\n  ;\n\n+ collection_literal_element\n  : expression_element\n  | dictionary_element\n  | spread_element\n  ;\n\n+ expression_element\n  : expression\n  ;\n\n+ dictionary_element\n  : expression ':' expression\n  ;\n\n+ spread_element\n  : '..' expression\n  ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nested ref struct Field Rules in C#\nDESCRIPTION: Illustrates complex scenarios with nested ref struct types and ref scoped fields, showing various restrictions on field access and return values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nref struct NestedRefStruct { }\nref struct RefStruct\n{\n    public NestedRefStruct NestedField;\n}\n\nref struct S\n{\n    ref scoped RefStruct field;\n\n    RefStruct M1(RefStruct s)\n    {\n        // Okay\n        field = new(); \n\n        // Error: calling-method is not convertible to current-field-1 as they have \n        // no relationship\n        field = s;\n\n        // Error: safe-to-escape is current-field-1 which isn't returnable \n        return field;\n    }\n\n    NestedRefStruct M2()\n    {\n        // Error: safe-to-escape is current-field-1 which isn't returnable \n        return field.NestedField;\n    }\n\n    ref RefStruct M3()\n    {\n        // Error: safe-to-escape is current-ref-field-1 which isn't returnable \n        return ref field;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating nameof with Overloaded Methods in C#\nDESCRIPTION: Shows how the nameof operator works with method overloads, returning the same string regardless of which overload is referenced. This illustrates the ambiguity that creates tooling challenges but provides valuable functionality.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-21.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M();\npublic void M(int i);\npublic void M(string s);\nWriteLine(nameof(M)); // writes the string \"M\"\n```\n\n----------------------------------------\n\nTITLE: Modifying Immutable Object with Object Initializer in C#\nDESCRIPTION: Demonstrates a proposed syntax for modifying an immutable object using an object initializer. This approach combines getting a builder, modifying it, and creating a new object in one expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nperson = person { Name = \"John Deere\" };\n```\n\n----------------------------------------\n\nTITLE: Ref Returning Properties Implementation\nDESCRIPTION: Decision to disallow required ref properties and fields until motivating use cases emerge.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-23.md#2025-04-21_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Inheritance With Constructor Boilerplate\nDESCRIPTION: Example showing how constructors introduce repetition in inheritance hierarchies.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-15.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Person\n{\n    public string Name { get; }\n    public Person(string name)\n    {\n        Name = name;\n    }\n}\npublic class Student : Person\n{\n    public string ID { get; }\n    public Student(string id, string name)\n      : base(name)\n    {\n        Id = id;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Method Declaration with Generic Nullable Parameter\nDESCRIPTION: Example signature demonstrating the use of T? for nullable generic parameters in C# 9, as an alternative to using AllowNull attribute with default value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-11-04.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M([AllowNull] string s)\n```\n\n----------------------------------------\n\nTITLE: Using the Data Keyword in a Regular C# Class\nDESCRIPTION: Example of how a generalizable 'data' keyword could be applied in regular classes to create properties with specific behavior, demonstrating potential extensibility beyond record types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-11.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Person\n{\n    data string FirstName;\n    data string LastName;\n    public Person(string first, string last)\n    {\n\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda OHI Breaking Change Example\nDESCRIPTION: Shows how changes in lambda handling affect overload resolution in inheritance scenarios between C# 9 and C# 10.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-09-20.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nB.F1(() => 1); // C#9: A.F1(); C#10: B.F1()\nvar b = new B();\nb.F2(() => 2); // C#9: A.F2(); C#10: B.F2()\n\nclass A\n{\n    public static void F1(Func<int> f) { }\n    public void F2(Func<int> f) { }\n}\nclass B : A\n{\n    public static void F1(Delegate d) { }\n    public void F2(Delegate d) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Using nameof with var Declaration in C#\nDESCRIPTION: Example of a variable declaration using var with nameof operator, which was discussed as not working in C# design because var cannot use self-references in initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-04.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar POST = nameof(POST);\n```\n\n----------------------------------------\n\nTITLE: Complex Interface Constraints\nDESCRIPTION: More complex example of interface constraints with generic parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\ninterface IBar : IFoo<string?> {}\nstatic void F<T, U>(T t) where T : IFoo<U>, IBar where U : class{ }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Variables with Multiple Case Labels in C#\nDESCRIPTION: This snippet shows how pattern variables are handled when multiple case labels are used for the same switch body. The variables are not definitely assigned and cannot be read from within the body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\ncase int i:\ncase byte b:\n    WriteLine(\"Integral value!\");\n    break;\n```\n\n----------------------------------------\n\nTITLE: Brainstormed Function Pointer Syntax Options in C#\nDESCRIPTION: Various syntax options considered by the language design team for function pointers with different placements of calling conventions, return types, and parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-30.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\ndelegate managed *int(int, long)\n\ndelegate managed *List<T>(int, long)\n\ndelegate * List<T> managed(int, long)\n\ndelegate<managed> * List<T>(int, long)\n\ndelegate * managed List<T>(int, long)\n\ndelegate managed int *(int, long)\n\ndelegate managed*<int, long, void>\n\ndelegate *<int, long, void>\n\ndelegate* managed<int, long, void>\ndelegate*<int, long, void>\n```\n\n----------------------------------------\n\nTITLE: Implementing Unconstrained Type Parameter Annotation in C#\nDESCRIPTION: Example showing how unconstrained type parameter annotation (T??) works with class inheritance and different type constraints. Demonstrates the relationship between base class A<T> and derived classes B1, B2, and B3.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-08.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract class A<T>\n{\n    internal abstract void F<U>(ref U?? u) where U : T;\n}\nclass B1 : A<string>\n{\n    internal override void F<U>(ref U?? u) => default; // Is ?? allowed or required?\n}\nclass B2 : A<int>\n{\n    internal override void F<U>(ref U?? u) => default; // Is ?? allowed or required?\n}\nclass B3 : A<int?>\n{\n    internal override void F<U>(ref U?? u) => default; // Is ?? allowed or required?\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inapplicable Member Hiding in C#\nDESCRIPTION: This snippet illustrates a case where an inapplicable member (a generic method without type arguments) hides an applicable one (a static field) from an extension. This scenario needs further discussion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-03-05.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = C.Member; // error: member lookup finds C.Member (method group) and lacks type arguments to apply to that match\n\nclass C \n{\n    public static void Member<T>() { }\n}\n\nimplicit extension E for C\n{\n    public static int Member = 42;\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Property with AllowNull Constraint Example in C#\nDESCRIPTION: Example demonstrating challenges with AllowNull attributes on generic properties with unconstrained type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-09-04.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass C<T> where T : new()\n{\n    private T _f = new T();\n\n    [AllowNull]\n    public T P\n    {\n        get => _f ?? throw new Exception();\n        set\n        {\n            if (value is null)\n            {\n                throw new Exception();\n            }\n            return _f;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Refness Example with Extension Members\nDESCRIPTION: Example showing refness specifications for extension declarations with value type receivers\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong bits)\n    {\n        public bool this[int index]\n        {\n            set => bits = value ? bits | Mask(index) : bits & ~Mask(index);\n            readonly get => (bits & Mask(index)) != 0;\n        }\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Interface Field Shadowing in C#\nDESCRIPTION: This snippet shows an example of interface field shadowing that needs further investigation. It involves multiple interfaces with static fields and inheritance relationships.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-03-05.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Console.WriteLine(I4.F); \n\ninterface I1\n{\n    static int F = 1;\n}\n\ninterface I2 : I1 \n{\n    static int F = 2;\n}\n\ninterface I3 : I1 {}\n\ninterface I4 : I3, I2 {}\n```\n\n----------------------------------------\n\nTITLE: Trailing Comma in Switch Expression Example\nDESCRIPTION: Example of a switch expression with a trailing comma. The team decided to permit optional trailing commas in switch expressions and other curly brace-enclosed constructs for consistency with other parts of the language.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-09.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\ne switch {\n    1 => true,\n    2 => false,\n}\n```\n\n----------------------------------------\n\nTITLE: System Runtime Feature Flag Reference\nDESCRIPTION: Reference to the runtime feature flag system that could be used to control equality generation behavior in the future.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-01-27.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Runtime.CompilerServices.RuntimeFeature\n```\n\n----------------------------------------\n\nTITLE: Range Type Usage Pattern in C#\nDESCRIPTION: Example showing how Range type would be used in foreach loops and variable declarations, demonstrating the natural type behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-18.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar r = 3..5;\nforeach (var x in 3..5) { ... }\n```\n\n----------------------------------------\n\nTITLE: Array Allocation Ignoring Constructor in C#\nDESCRIPTION: This code shows that array allocation ignores any parameterless constructor and generates zeroed elements when creating a struct array. The behavior remains unchanged from C# 9.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n\"// struct S { public S() { } }\\n\\nvar a = new S[1]; // constructor ignored, no warning\"\n```\n\n----------------------------------------\n\nTITLE: Extension Declaration with Classic Extension Methods in C#\nDESCRIPTION: This snippet shows how new extension declarations can coexist with classic extension methods and non-extension static members within the same static class. This enables developers to gradually adopt the new syntax while maintaining compatibility with existing code. It showcases the ability to declare both types of extensions in one single class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    // New extension declaration\n    extension(IEnumerable) { ... }\n    \n    // Classic extension method\n    public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source) { ... }\n    \n    // Non-extension member\n    public static IEnumerable<int> Range(int start, int count) { ... } \n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Foreach Statement\nDESCRIPTION: Specifies the syntax for foreach statements with optional 'scoped' modifier for local variable declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_15\n\nLANGUAGE: antlr\nCODE:\n```\nforeach_statement\n    : 'foreach' '(' 'scoped'? local_variable_type identifier 'in' expression ')'\n      embedded_statement\n    ;\n```\n\n----------------------------------------\n\nTITLE: Illustrating Switch Expression with Semicolon in C#\nDESCRIPTION: Demonstrates the proposed syntax for a switch expression as a statement, including the required semicolon. This syntax was considered unappealing by the language design team.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-16.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\na switch\n{\n    b => ...,\n    c => ...\n}; // semicolon required\n```\n\n----------------------------------------\n\nTITLE: C# Function Pointer Type Equivalence\nDESCRIPTION: Shows equivalent function pointer types compared to delegate declarations, demonstrating syntax for complex scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\ndelegate int Func1(string s);\ndelegate Func1 Func2(Func1 f);\n\n// Function pointer equivalent without calling convention\ndelegate*<string, int>;\ndelegate*<delegate*<string, int>, delegate*<string, int>>;\n\n// Function pointer equivalent with calling convention\ndelegate* managed<string, int>;\ndelegate*<delegate* managed<string, int>, delegate*<string, int>>;\n```\n\n----------------------------------------\n\nTITLE: Defining Access Modifier Rules for Properties and Indexers in C#\nDESCRIPTION: This code snippet outlines the rules for using access modifiers on properties and indexers in C#. It specifies which accessor-modifiers are allowed based on the declared accessibility of the property or indexer.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/private-protected.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n- If the property or indexer has a declared accessibility of protected internal, the accessor-modifier may be either **private protected**, internal, protected, or private.\n- If the property or indexer has a declared accessibility of internal or protected, the accessor-modifier shall be **either private protected or** private.\n- **If the property or indexer has a declared accessibility of private protected, the accessor-modifier shall be private.**\n- If the property or indexer has a declared accessibility of private, no accessor-modifier may be used.\n```\n\n----------------------------------------\n\nTITLE: Tuple Deconstruction Assignment\nDESCRIPTION: Examples of deconstructing tuple values into existing variables, including array elements and variable swapping. Shows evaluation order preservation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n(x, y) = currentFrame.Crop(x, y); // x and y are existing variables\n(a[x], a[x+1], a[x+2]) = GetCoordinates();\n```\n\nLANGUAGE: c#\nCODE:\n```\n(a, b) = (b, a); // Yay!\n```\n\n----------------------------------------\n\nTITLE: Approach B2: Warning Example (C#)\nDESCRIPTION: Illustrates the case where a warning will be reported because the property can potentially be null due to the setter possibly assigning it to `null`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\n\"// warning that `field` in the getter might be null.\\nstring Prop { get => field; set => field = value is \\\"\\\" ? null : value.Trim(); }\\n\\npublic C()\\n{\\n    this.Prop = \\\"\\\";\\n}\"\n```\n\n----------------------------------------\n\nTITLE: At-Operator to Invoke Extension Methods in C#\nDESCRIPTION: Introduces an experimental syntax using the 'at' operator for accessing extension methods. This demonstrates a potential language enhancement for clarity in invoking extensions on range expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = (IEnumerable<int> at MyExtensions).Range(0, 10);\nvar empty = (IEnumerable<int> at MyExtensions).Empty;\n(range at MyExtensions) += 5;\nReadOnlySpan<int> span = range at MyExtensions;\n\n// Instance extension members\nvar query = (range at MyExtensions).Where(i => i < 10);\nvar isEmpty = (query at MyExtensions).IsEmpty;\nvar first = (query at MyExtensions)[0];\nvar repetition = new (IEnumerable<int> at MyExtensions)(first, 10);\n```\n\n----------------------------------------\n\nTITLE: LINQ Method Syntax with Null Filtering\nDESCRIPTION: Example showing the challenge of tracking null filtering through method syntax LINQ queries, where determining the nullability of the result is more difficult.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-11-27.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar query =\n    nullableStrings.Where(s => s != null);\n```\n\n----------------------------------------\n\nTITLE: Declaring a Specialized Union Struct in C#\nDESCRIPTION: This code snippet declares a specialized union struct named 'U'. Similar to union classes, it defines member types (A, B, and C) within the struct declaration. The 'union struct' declaration indicates that this union is implemented as a struct, allowing for value-type semantics and potentially avoiding heap allocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nunion struct U \n{\n    A(int x, string y);\n    B(int z);\n    C;\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Field Context Rules Example in C#\nDESCRIPTION: Shows how ref-field-safe-context behaves independently of container context and demonstrates stack allocation restrictions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_43\n\nLANGUAGE: csharp\nCODE:\n```\nref struct Nested\n{\n    ref Span<int> Span;\n}\n\nvoid M(ref Nested nested)\n{\n    scoped ref Nested refLocal = ref nested;\n\n    // the ref-field-safe-context of local is still *caller-context* which means the following\n    // is illegal\n    refLocal.Span = stackalloc int[42];\n\n    scoped Nested valLocal = nested;\n\n    // the ref-field-safe-context of local is still *caller-context* which means the following\n    // is still illegal\n    valLocal.Span = stackalloc int[42];\n}\n```\n\n----------------------------------------\n\nTITLE: Leading and Trailing Digit Separators in C# Numeric Literals\nDESCRIPTION: Example showing the proposed syntax for using underscore as a digit separator at the start of binary and hexadecimal literals. This feature aims to improve code readability and help with code generation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-16.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nM(0b_1, 0x_A)\n```\n\n----------------------------------------\n\nTITLE: Approach A1: Nullable Warning Example (C#)\nDESCRIPTION: Shows how the simplest approach from above can trigger nullable warnings and the suppressions a developer would need to apply to avoid them.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n\"string Prop { get => field ?? \\\"\\\"; private set; } // or\\nstring Prop { get => field ??= ComputeInitialValue(); }\"\n```\n\n----------------------------------------\n\nTITLE: Dynamic Runtime Resolution Example - C#\nDESCRIPTION: Example showing how dynamic binding can successfully resolve operations at runtime through derived types, which would break under the proposed compile-time rules\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-01.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar c2 = new C2();\nc2.M(0, 1);\n\npublic class C2\n{\n    public void M(dynamic d, object o)\n    {\n        this[d] += o; // Succeeds today because `Derived.operator +` is found at runtime by dynamic\n    }\n\n    Base this[int x]\n    {\n        get => new Derived();\n        set {}\n    }\n}\n\nclass Base { }\n\nclass Derived\n{\n    public static Derived operator+(Derived x, object y)\n    {\n        System.Console.Write(1);\n        return x;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating nint Constant Folding Behavior in C#\nDESCRIPTION: Example showing how constant folding with nint type handles overflow situations differently on 32-bit vs 64-bit platforms. Demonstrates both constant and runtime calculations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-03-25.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst nint m = int.MaxValue;\nconst nint u1 = unchecked(m + 1);\n      nint u2 = unchecked(m + 1);\n```\n\n----------------------------------------\n\nTITLE: Abstract Methods and Delegate Declarations\nDESCRIPTION: Demonstrates missing warnings in abstract methods and delegate declarations with optional parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-parameter-default-value-analysis.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class C\n{\n    public abstract void M1(string s = null); // expected warning, but didn't get one\n}\n\ninterface I\n{\n    void M1(string s = null); // expected warning, but didn't get one\n}\n\npublic delegate void Del1(string s = null); // expected warning, but didn't get one\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Meeting Quote\nDESCRIPTION: A humorous quote from the meeting about correlation between making 'field' a keyword and its usage as a field name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-15.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n\"Obviously what the data means is that after we make `field` a keyword, usage of it as the name of a field will skyrocket, because that's what correlation means, right?\"\n```\n\n----------------------------------------\n\nTITLE: Defining Type-Based Extensions in C#\nDESCRIPTION: This snippet illustrates a type-based extension approach which organizes extension methods within type-like declarations. It showcases how extension methods could be declared as instance methods, with syntactical support for future types such as interfaces. Prerequisites include an understanding of C# class and method syntax. Inputs and outputs mirror typical object method operations, supporting features like operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic extension Complex : Point\n{\n    public Point Scale(double s) { return new Point(X * s, Y * s); }\n    public double Size { get { return Math.Sqrt(X*X + Y*Y); } }\n    public static Point operator +(Point p1, Point p2) { return new Point(p1.X + p2.X, p1.Y + p2.Y); }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Destructible Type Example in C#\nDESCRIPTION: Illustrates a scenario where management of destructible types becomes challenging, raising questions about when destruction should occur in complex control flows and assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n{\n    D x;\n    if (e) x = new x();\n    x = new x();\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Method Parameters\nDESCRIPTION: Specifies the syntax for method parameters with support for 'scoped' modifier and parameter mode modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_17\n\nLANGUAGE: antlr\nCODE:\n```\nfixed_parameter\n    : attributes? parameter_modifier? type identifier default_argument?\n    ;\n\nparameter_modifier\n    | 'this' 'scoped'? parameter_mode_modifier?\n    | 'scoped' parameter_mode_modifier?\n    | parameter_mode_modifier\n    ;\n\nparameter_mode_modifier\n    : 'in'\n    | 'ref'\n    | 'out'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Using Normal KeyValuePair Instances in Collections - C#\nDESCRIPTION: This snippet shows that while the new syntax is convenient for declaring KeyValuePairs, you can also use traditional KeyValuePair instances in collection expressions without any loss of functionality.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nKeyValuePair<string, int> kvp = new(\"mads\", 21);\nDictionary<string, int> nameToAge = [kvp];\n```\n\n----------------------------------------\n\nTITLE: Switch expression arm grammar modification in ANTLR\nDESCRIPTION: This ANTLR grammar snippet defines the syntax for switch expression arms, allowing either a single expression or a block of statements after the '=>' operator. It also defines the `break_statement` which may or may not include an expression. This modification allows for the implementation of the block-bodied switch expression arms.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/block-bodied-switch-expression-arms.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nswitch_expression_arm\n    : pattern case_guard? '=>' expression\n    | pattern case_guard? '=>' block\n    ;\n\nbreak_statement\n    : 'break' expression? ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: UnscopedRef with Out Parameters\nDESCRIPTION: Shows how UnscopedRef can be used with out parameters to restore C# 10 behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_21\n\nLANGUAGE: c#\nCODE:\n```\nref int SneakyOut([UnscopedRef] out int i)\n{\n    i = 42;\n    return ref i;\n}\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution with Custom Ref Struct in C#\nDESCRIPTION: This snippet demonstrates how a custom ref struct (ValueList<T>) could be preferred over an array in overload resolution when using collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nref struct ValueList<T> { ... }\n\nvoid M(int[] list);\nvoid M(ValueList<int> list);\n\nM([1, 2, 3]); // calls the ValueList version.\n```\n\n----------------------------------------\n\nTITLE: Classic extension method overload resolution example 1\nDESCRIPTION: This example demonstrates how classic extension methods are resolved based on betterness rules.  When multiple extension methods are applicable, the one with the most specific parameter type is preferred.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n\"\\\".M(); // E.M(string)\\n\\npublic static class E \\n{\\n    public static void M(this object o) { }\\n    public static void M(this string s) { }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Using MaybeNull Attribute as Alternative to T?\nDESCRIPTION: Example of using the MaybeNull attribute to annotate the FirstOrDefault method return type, which was the approach adopted in C# 8.0 instead of allowing T? on unconstrained type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-25.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic [return:MaybeNull] T FirstOrDefault<T>(this IEnumerable<T> src);\n```\n\n----------------------------------------\n\nTITLE: Example of Field-Targeted Nullability Attributes\nDESCRIPTION: Demonstrates a proposed alternative approach using nullability attributes to specify the nullability behavior of the backing field in a lazy-loading scenario.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public C() { } // no need to warn about initializing C.Prop, as the backing field is marked nullable using attributes.\n\n    [field: AllowNull, MaybeNull]\n    public string Prop => field ??= GetPropValue();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing params ReadOnlySpan<T> Feature\nDESCRIPTION: Code reference discussing the implementation of params ReadOnlySpan<T> for performance optimization in C# method parameters. This feature aims to improve efficiency by avoiding multiple overloads and reducing heap allocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-11-30.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nparams ReadOnlySpan<T>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Base and Derived Class Interaction with OverloadResolutionPriority in C#\nDESCRIPTION: Example showing how OverloadResolutionPriority does not override the rule that members from derived classes take precedence over base class members in method resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/overload-resolution-priority.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Runtime.CompilerServices;\n\nvar d = new Derived();\nd.M([1, 2, 3]); // Prints \"Derived\", because members from Base are not considered due to finding an applicable member in Derived\n\nclass Base\n{\n    [OverloadResolutionPriority(1)]\n    public void M(ReadOnlySpan<int> s) => Console.WriteLine(\"Base\");\n}\n\nclass Derived : Base\n{\n    public void M(int[] a) => Console.WriteLine(\"Derived\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing IEnumerable with Collection Literal in C#\nDESCRIPTION: Example of initializing an IEnumerable<T> interface type using a collection literal, showing potential implementation options.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nIEnumerable<int> values = [1, 2, 3]; // could be:\n\nIEnumerable<int> values = new List<int> { 1, 2, 3 }; // or could be:\nIEnumerable<int> valuies = new <>UnspeakableName { 1, 2, 3 };\n```\n\n----------------------------------------\n\nTITLE: Example of `field` keyword usage with null-coalescing assignment\nDESCRIPTION: This C# code snippet demonstrates a possible usage of the `field` keyword in conjunction with the null-coalescing assignment operator (`??=`). It shows how a backing field can be lazily initialized with an empty string if it's null. The snippet is related to the discussion around handling nullability with the `field` keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-08-14.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n\"string Prop { get => field ??= \\\"\\\"; }\"\n```\n\n----------------------------------------\n\nTITLE: Analysis of Simple Programs Design in C#\nDESCRIPTION: Discussion of top-level statements feature allowing functions and statements at file level. Key points include local function scoping, mixing with classes, and comparison with CSX scripting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-26.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Role Type in Signatures and Emit Strategy in C#\nDESCRIPTION: This snippet shows how role types are used in method signatures and the proposed emit strategy using attributes.  It illustrates how the attributes encode the role type information and allow callers to get the correct return type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nMyRole M(MyRole role)\n```\n\nLANGUAGE: csharp\nCODE:\n```\n[return: Role(typeof(MyRole))] UnderlyingType M([Role(typeof(MyRole))] UnderlyingType role)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nMyRole role1 = ...;\nvar role2 = M(role1); // var == MyRole\n```\n\n----------------------------------------\n\nTITLE: Recursive Lambda Examples in C#\nDESCRIPTION: Shows challenges with recursive lambda expressions and return type inference.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar f = (int x, int c) => c = 0 ? x : f(x) * x; // can we reasonably infer a return type here?\nvar f = (int x, int c) => (int)(c = 0 ? x : f(x) * x); // or do we need to cast the result?\n```\n\n----------------------------------------\n\nTITLE: Deconstructing Immutable Object with Tuple Value in C#\nDESCRIPTION: Demonstrates how an immutable object with a tuple value could be deconstructed by position, similar to tuple deconstruction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\n(var n, var a) = GetPerson(); // deconstructed as per the `Value` tuple\n```\n\n----------------------------------------\n\nTITLE: Proposed JSON Interface Attribute Syntax in C#\nDESCRIPTION: Proposed syntax for an interface with a JSON attribute that could be used to generate runtime behavior for JSON serialization/deserialization without requiring concrete class implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-22-Design-Review.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n[Json] interface { string name; double price; }\n```\n\n----------------------------------------\n\nTITLE: Grammar Changes for Modern Extensions in C#\nDESCRIPTION: This code snippet outlines the proposed grammar changes to support modern extensions in C#, including new rules for for-clause, extension declarations, and modifications to existing declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nfor-clause\n    | 'for' parameter\n    ;\n\nparameter (no change)\n    | attributes? modifiers? type identifier ...\n    ;\n\nextension\n    | attributes? modifiers? 'extension' identifier { member_declaration* }\n    ;\n\n// For method/property/indexer/operator/constructor/event declarations\n// we are augmenting its syntax to allow type-parameters\n// (if not already allowed) and a for-clause. For example:\nproperty-declaration\n    | attributes? modifiers identifier type-parameters for-clause property-body\n    ;\n    \ncompilation-unit-member\n    | ...\n    | extension\n    ;\n \nnamespace-declaration-member\n    | ...\n    | extension\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Switch Expression as Statement in C#\nDESCRIPTION: Shows the proposed syntax for using a switch expression as a statement without the need for a discard assignment. This proposal was ultimately rejected in its current form.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-16.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\na switch \n{ \n    ...\n};\n```\n\n----------------------------------------\n\nTITLE: Collection Expression with Span Example in C#\nDESCRIPTION: Demonstrates the basic syntax for creating a Span using collection expression syntax. This example illustrates the context for the ref-safety scope discussion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-08-16.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> s = [x, y, z];\n```\n\n----------------------------------------\n\nTITLE: Proposed Generic Array Syntax for Nullable Arrays\nDESCRIPTION: Example of a potential alternative syntax using generic Array<T> notation to address ambiguities with nullable array types. This proposal would provide a clearer way to express nullable array types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-01-09.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nArray<int[]?>\nnew Array<int[]?>(3)\nnew Array<int[]?> { new[] {1}, null, new [] {2, 3 }}\n```\n\n----------------------------------------\n\nTITLE: Considering Union Type Matching in C# Switch Statements\nDESCRIPTION: This snippet explores the possibility of matching union types in switch statements, raising questions about runtime behavior and type pattern matching for union types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-10-31.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nunion (A | B) u = ...;\nswitch ((object)u)\n{\n    case union(B | A):\n        Console.WriteLine(\"Union matched\"); // Should this work?\n        break;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation Search Order Example\nDESCRIPTION: Illustrates a scenario questioning which interfaces are searched for implementations and in what order.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/CLR-2017-03-23.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\ninterface IA { void M() {} }\ninterface IB: IA { override void M() {} }\n\nclass Base : IB { }\nclass Derived : Base, IA { }\n```\n\n----------------------------------------\n\nTITLE: Async Method Declaration Reference\nDESCRIPTION: Implicit code reference to async method declarations discussed in the context of the new async2 implementation\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-01.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nasync\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Grammar in ANTLR\nDESCRIPTION: Formal grammar specification for function pointer syntax in ANTLR notation, defining all possible syntactic constructs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\npointer_type\n    : ...\n    | funcptr_type\n    ;\n\nfuncptr_type\n    : 'delegate' '*' calling_convention_specifier? '<' funcptr_parameter_list funcptr_return_type '>'\n    ;\n\ncalling_convention_specifier\n    : 'managed'\n    | 'unmanaged' ('[' unmanaged_calling_convention ']')?\n    ;\n\nunmanaged_calling_convention\n    : 'Cdecl'\n    | 'Stdcall'\n    | 'Thiscall'\n    | 'Fastcall'\n    | identifier (',' identifier)*\n    ;\n\nfunptr_parameter_list\n    : (funcptr_parameter ',')* \n    ;\n\nfuncptr_parameter\n    : funcptr_parameter_modifier? type\n    ;\n\nfuncptr_return_type\n    : funcptr_return_modifier? return_type\n    ;\n\nfuncptr_parameter_modifier\n    : 'ref'\n    | 'out'\n    | 'in'\n    ;\n\nfuncptr_return_modifier\n    : 'ref'\n    | 'ref readonly'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Exploring Collection Expression Conversion Algorithm\nDESCRIPTION: Proposed changes to handle type conversion scenarios for collection expressions, specifically addressing challenges with types like ReadOnlySpan<string> and ReadOnlySpan<object>\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-08-19.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Invocations on Role Member in C#\nDESCRIPTION: This snippet showcases how invocations on role members are handled. It describes the conversion of an `UnderlyingType` to a `MyRole` using a ref struct. The role is instantiated as part of the invocation and is short-lived.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nUnderlyingType underlying = ...;\nref MyRole role = ref underlying; // conversion creates a ref struct\nrole.M();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nUnderlyingType /*MyRole*/ role = underlying;\nnew MyRole(ref role).M();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nUnderlyingStructType underlying = ...;\n((MyRole)underlying).M(); or declare a ref local\n```\n\n----------------------------------------\n\nTITLE: Generated Class from Record Syntax in C#\nDESCRIPTION: Shows the expanded class that would be generated from the record syntax, including the tuple value, constructor, property accessors, and overridden methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nclass Person \n{\n    public readonly (string Name, int Age) Value;\n\tpublic Person((string Name, int Age) value) { Value = value; }\n    public string Name => Value.Name;\n    public int Age => Value.Age;\n    public override bool Equals(object other) => (other as Person)?.Value.Equals(Value) ?? false; // or similar\n    public override int GetHashCode() => Value.GetHashCode;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Interface Static Member Variance Issues in C#\nDESCRIPTION: Code example showing inconsistencies in how variance is applied to different static member types in interfaces, where static fields behave differently than static properties, methods, and events with variant type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-24.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface I<out T>\n{\n    static Task<T> F = Task.FromResult(default(T)); // No problem\n    static Task<T> P => Task.FromResult(default(T));   //CS1961\n    static Task<T> M() => Task.FromResult(default(T));    //CS1961\n    static event EventHandler<T> E; // CS1961\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Reference Type Inference in Finally Blocks\nDESCRIPTION: Example demonstrating a deficiency in nullable reference type flow analysis where null checks in finally blocks don't correctly influence the inferred nullable state after the try-finally statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-22.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nC? c = null;\ntry\n{\n    c = SomeNonNullComputation;\n}\nfinally\n{\n    if (c != null) c.Cleanup();\n}\nc.Operation(); // undeserved warning\n```\n\n----------------------------------------\n\nTITLE: Backward Compatibility Issues with Ref Fields Example\nDESCRIPTION: Code illustrating C# 10 patterns that would become unsafe in C# 11 due to the ability for ref state to escape as a ref field in ref struct returns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_30\n\nLANGUAGE: c#\nCODE:\n```\nSpan<int> CreateSpan(ref int parameter)\n{\n    // The implementation of this method is irrelevant when considering the lifetime of the \n    // returned Span<T>. The ref safe context rules only look at the method signature, not the \n    // implementation. In C# 10 ref fields didn't exist hence there was no way for `parameter`\n    // to escape by ref in this method\n}\n\nSpan<int> BadUseExamples(int parameter)\n{\n    // Legal in C# 10 but would be illegal with ref fields\n    return CreateSpan(ref parameter);\n\n    // Legal in C# 10 but would be illegal with ref fields\n    int local = 42;\n    return CreateSpan(ref local);\n\n    // Legal in C# 10 but would be illegal with ref fields\n    Span<int> span = stackalloc int[42];\n    return CreateSpan(ref span[0]);\n}\n```\n\n----------------------------------------\n\nTITLE: Merged Static Class and Extension Declaration Syntax\nDESCRIPTION: Shortened syntax that combines static class declaration with extension declaration to reduce nesting levels.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class EmptyExtensions : extension(IEnumerable source)\n{\n    public bool IsEmpty => !source.GetEnumerator().MoveNext();\n}\n```\n\n----------------------------------------\n\nTITLE: Diamond Inheritance Pattern with Classes and Interfaces\nDESCRIPTION: Demonstrates a diamond inheritance pattern between classes and interfaces, raising questions about implementation precedence.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/CLR-2017-03-23.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\ninterface IA { void M() {} }\ninterface IB: IA { override void M() {} }\n\nclass Base : IA { void IA.M() { } }\nclass Derived : Base, IB { }\n```\n\n----------------------------------------\n\nTITLE: Method Invocation with Nullable Collections\nDESCRIPTION: Example showing method invocation with filtered nullable collections, demonstrating a case where nested nullability suppression is needed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-03-21.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(IEnumerable<string> source) { ... }\nList<string?> strings;\nM(strings.Where(s => s != null)); // What?? Why warning?\n```\n\n----------------------------------------\n\nTITLE: Compatibility with Named Delegates for Optional and params Parameters in C#\nDESCRIPTION: Demonstrates compatibility between lambdas, method groups, and named delegates that already support optional and params parameters, including scenarios that trigger warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\ndelegate int DelegateNoDefault(int x);\ndelegate int DelegateWithDefault(int x = 1);\n\nint MethodNoDefault(int x) => x;\nint MethodWithDefault(int x = 2) => x;\nDelegateNoDefault d1 = MethodWithDefault; // no warning: source is a method group\nDelegateWithDefault d2 = MethodWithDefault; // no warning: source is a method group\nDelegateWithDefault d3 = MethodNoDefault; // no warning: source is a method group\nDelegateNoDefault d4 = (int x = 1) => x; // warning: source present, target missing\nDelegateWithDefault d5 = (int x = 2) => x; // warning: source present, target different\nDelegateWithDefault d6 = (int x) => x; // no warning: source missing, target present\n\ndelegate int DelegateNoParams(int[] xs);\ndelegate int DelegateWithParams(params int[] xs);\n\nint MethodNoParams(int[] xs) => xs.Length;\nint MethodWithParams(params int[] xs) => xs.Length;\nDelegateNoParams d7 = MethodWithParams; // no warning: source is a method group\nDelegateWithParams d8 = MethodNoParams; // no warning: source is a method group\nDelegateNoParams d9 = (params int[] xs) => xs.Length; // warning: source present, target missing\nDelegateWithParams d10 = (int[] xs) => xs.Length; // no warning: source missing, target present\n```\n\n----------------------------------------\n\nTITLE: Tuple Conversion and Deconstruction Example in C#\nDESCRIPTION: Example demonstrating how tuple conversions work by allowing a tuple to be deconstructed and then reassembled into a new tuple type with compatible element types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-05-03-04.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n(string, byte) t1 = ...;\n(object, int) t2 = t1;     // Allowed, because the following is:\n(var a, var b) = t1;       // Deconstruct, and ...\n(object, int) t2 = (a, b); // reassemble\n```\n\n----------------------------------------\n\nTITLE: Collection Type Method Example in C#\nDESCRIPTION: Example showing strongly-typed Add method in legacy collection types, specifically referencing ListView.ColumnHeaderCollection implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-02-26.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nAdd(ColumnHeader)\n```\n\nLANGUAGE: C#\nCODE:\n```\nAdd(string)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Current ReadOnlySpan<T> Initialization in C#\nDESCRIPTION: Shows existing ways to initialize ReadOnlySpan<T> with stack allocation (local scope) and heap allocation (global scope).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> x1 = stackalloc int[] { a, b, c }; // stack allocated, local scope.\nReadOnlySpan<int> x2 = new int[] { a, b, c };        // heap allocated, global scope.\n```\n\n----------------------------------------\n\nTITLE: Resolving Nullable Reference Type Warnings in C# Method Override\nDESCRIPTION: This code shows how to resolve warnings caused by mixing nullable reference types and the '!!' operator in a method override within a class hierarchy.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// Assembly3\nabstract class C3 : C2 { \n    protected override void M(object? o!!) {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Abstract Record Class in C#\nDESCRIPTION: A simple abstract record class definition with a single Name parameter. This demonstrates the concise syntax for record classes in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Person(string Name);\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Field Access in C# Constructor\nDESCRIPTION: An alternative syntax proposal using an 'init' prefix to indicate direct field assignment in a constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/fieldof.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic C(string prop)\n{\n    // 'init' prefix appearing before an assignment means assign a backing field.\n    init Prop = prop;\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Length Pattern Compatibility Issue\nDESCRIPTION: GitHub issue reference addressing Length pattern backward compatibility concerns in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-10-13.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://github.com/dotnet/csharplang/issues/5226\n```\n\n----------------------------------------\n\nTITLE: Collection Initialization with 'init' Keyword Examples\nDESCRIPTION: Alternative syntax using init() instead of with() for collection initialization with arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\n// With an existing type:\n\n// Initialize to twice the capacity since we'll have to add\n// more values later.\nList<string> names = [init(capacity: values.Count * 2), .. values];\n\n// With the dictionary types.\nDictionary<string, int> nameToAge1 = [init(comparer)];\nDictionary<string, int> nameToAge2 = [init(comparer), kvp1, kvp2, kvp3];\nDictionary<string, int> nameToAge3 = [init(comparer), k1:v1, k2:v2, k3:v4];\nDictionary<string, int> nameToAge4 = [init(comparer), .. d1, .. d2, .. d3];\n\nDictionary<string, int> nameToAge = [init(comparer), kvp1, k1: v2, .. d1];\n```\n\n----------------------------------------\n\nTITLE: Argument Validation with Exceptions in C#\nDESCRIPTION: This code snippet illustrates traditional argument validation using ArgumentNullException and ArgumentException. It demonstrates the need to manually pass the argument name using nameof, which can be redundant.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/caller-argument-expression.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nT Single<T>(this T[] array)\n{\n    if (array == null)\n    {\n        throw new ArgumentNullException(nameof(array));\n    }\n\n    if (array.Length != 1)\n    {\n        throw new ArgumentException(\"Array must contain a single element.\", nameof(array));\n    }\n\n    return array[0];\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Example Usage - field Keyword\nDESCRIPTION: Code snippet referenced in discussion about semi-auto properties with the 'field' keyword, showcasing property implementation patterns\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Example {\n    // Semi-auto property with field keyword\n    public int Value {\n        get => field;\n        set => field = value; // Custom setter implementation\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring Extended Transparency for Deconstructible Types in C# Collection Expressions\nDESCRIPTION: This snippet demonstrates how transparency could be extended to support any type that is constructible and deconstructible into two elements, including tuples and custom types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> nameToAge1 = [(\"mads\", 21)];\n\nList<(string, int)> pairs = ...;\nDictionary<string, int> nameToAge2 = [.. pairs];\n\nrecord struct NameAndAge(string Name, int Age);\nDictionary<string, int> nameToAge3 = [nameToAge1, nameToAge2];\n\nList<NameToAge> pairs = [\"mads\": 21, \"cyrus\": 22, \"joseph\": 23];\n// etc.\n```\n\n----------------------------------------\n\nTITLE: Implementing Bit Operations with Anonymous Extension Declaration in C#\nDESCRIPTION: Demonstrates an anonymous extension declaration for bit operations on a ulong value, showing the use of 'this' keyword which may be unfamiliar to some users.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong) // underlying value is passed by ref\n    {\n        public bool this[int index]\n        {\n            get => (this & Mask(index)) != 0;\n            set => this = value ? this | Mask(index) : this & ~Mask(index); // mutates underlying value\n        }\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n```\n\n----------------------------------------\n\nTITLE: @-Operator for Invoking Extension Methods in C#\nDESCRIPTION: Examines the utilization of '@' for invoking extension methods, which can introduce distinct naming and accessibility paths. This syntax could be useful in mitigating conflicts with reserved keywords.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = (IEnumerable<int> @ MyExtensions).Range(0, 10);\nvar empty = (IEnumerable<int> @ MyExtensions).Empty;\nrange @ MyExtensions += 5;\nReadOnlySpan<int> span = range @ MyExtensions;\n\n// Instance extension members\nvar query = (range @ MyExtensions).Where(i => i < 10);\nvar isEmpty = (query @ MyExtensions).IsEmpty;\nvar first = (query @ MyExtensions)[0];\nvar repetition = new (IEnumerable<int> @ MyExtensions)(first, 10);\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Argument Lists\nDESCRIPTION: Defines the syntax for argument lists, including support for 'scoped' modifier in out parameter declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_16\n\nLANGUAGE: antlr\nCODE:\n```\nargument_value\n    : expression\n    | 'in' variable_reference\n    | 'ref' variable_reference\n    | 'out' ('scoped'? local_variable_type)? identifier\n    ;\n```\n\n----------------------------------------\n\nTITLE: Constructor and Static Method Extension Syntax in C#\nDESCRIPTION: Shows how constructors and static methods can be referenced without special syntax in the extension system.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nvar v3 = new Extension(...); // Makes instance of the actual extended type.\nvar v4 = Extension.StaticExtensionMethod(...);\n```\n\n----------------------------------------\n\nTITLE: Referencing Clone Method for Records\nDESCRIPTION: Code pattern showing the special Clone method (<Clone>$) that was being used to identify record types in metadata, which was discussed as potentially problematic for struct records.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-11-11.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n<Clone>$\n```\n\n----------------------------------------\n\nTITLE: Creating a Span<T> with ref parameter in C#\nDESCRIPTION: Example of a potential syntax for creating a Span<T> using a ref parameter, which is currently not allowed due to lifetime rules. The discussion suggests introducing a CapturesAttribute to indicate ref parameter capture.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-09-23.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnew Span<T>(ref parameter)\n```\n\n----------------------------------------\n\nTITLE: Referencing C# Inline Arrays Feature\nDESCRIPTION: A markdown link to the C# inline arrays proposal document, which is referenced in the discussion about synthesizing inline array sizes for collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-07-26.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[inline arrays](https://github.com/dotnet/csharplang/blob/main/proposals/inline-arrays.md)\n```\n\n----------------------------------------\n\nTITLE: Option 3 Implementation in C# for Span Allocation\nDESCRIPTION: This code snippet presents Option 3 of treating collection expressions as local scope by default, except where explicitly defined otherwise. The first function attempts to return a span that may refer to stack data, resulting in an error, whereas the second function safely returns a heap-allocated array.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nstatic ReadOnlySpan<T> Option3_AsSpan2<T>(T x, T y)\n{\n    return [x, y];    // error: span may refer to stack data\n}\n\nstatic ReadOnlySpan<T> Option3_AsSpan3<T>(T x, T y, T z)\n{\n    return (T[])[x, y, z]; // ok: span refers to T[] on heap\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ignored Directives Usage in C#\nDESCRIPTION: Example showing how ignored directives could be used in a C# file, including shebang, SDK specification, properties, and package references.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/ignored-directives.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#!/usr/bin/dotnet run\n#:sdk      Microsoft.NET.Sdk.Web\n#:property TargetFramework net11.0\n#:property LangVersion preview\n#:package  System.CommandLine 2.0.0-*\n\nConsole.WriteLine(\"Hello, World!\");\n```\n\n----------------------------------------\n\nTITLE: Record Syntax for Immutable Objects in C#\nDESCRIPTION: Illustrates a proposed record syntax for defining immutable objects, which would generate a class with a tuple value and supporting methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nclass Person(string Name, int Age);\n```\n\n----------------------------------------\n\nTITLE: Initializing SpecialType Using Declaration Expression in C#\nDESCRIPTION: Example showing how declaration expressions can simplify type initialization with var keyword while handling value/reference type conditions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/declaration-expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nSpecialType ReferenceType =>\n    (var st = _type.SpecialType).IsValueType() ? SpecialType.None : st;\n```\n\n----------------------------------------\n\nTITLE: Defining Nullable Backing Fields in C# Properties\nDESCRIPTION: Demonstrates how to define properties with nullable backing fields in C#, where initial analysis determines field nullability without needing constructor initializers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nstring Prop { get => field ?? \"\"; private set; } // or\nstring Prop { get => field ??= ComputeInitialValue(); }\n```\n\n----------------------------------------\n\nTITLE: Collection Interface Example in C#\nDESCRIPTION: Example showing proposed collection literal syntax with interface type\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-11-01.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<int> ie = [1, 2];\n```\n\n----------------------------------------\n\nTITLE: Nullable Array Instantiation Approach 1 in C#\nDESCRIPTION: First approach for instantiating nullable arrays showing valid and invalid syntax patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-28.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnew string?[3][]\nnew string[3]?[] // invalid\nnew string[3][]?\n```\n\n----------------------------------------\n\nTITLE: Example of Manual Nullability Annotation for Reset Pattern in C#\nDESCRIPTION: Shows a pattern where manual nullability attributes would be needed if automatic nullability is not fully implemented, demonstrating a property that resets when set to a default value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[field: AllowNull] // Required if we only go halfway.\npublic string ResetIfSetToDefault\n{\n    get => field ?? GetDefault();\n    set => field = value == GetDefault() ? null : value;\n}\n```\n\n----------------------------------------\n\nTITLE: Static Extension Method Conversion Preference in C#\nDESCRIPTION: This code snippet explores conversion preferences for static extension methods in C#.  It aims to determine whether `IEnumerable<C1>` should be preferred over `IEnumerable<object>` when a static extension is called on `IEnumerable<C2>` based on inheritance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\n_ = IEnumerable<C2>.P; // should we prefer IEnumerable<C1> because it is a better conversion? (parameter-like behavior)\n\npublic static class E\n{\n    extension(IEnumerable<C1>)\n    {\n      static int P => 0;\n    }\n    extension(IEnumerable<object>)\n    {\n      static int P => throw null;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Handling Specific Types in Collections - C#\nDESCRIPTION: This code snippet illustrates how dictionary expressions can accommodate specific key and value types that are more specific than those declared for the dictionary, taking advantage of type transparency.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<object, int?> map1 = [\"mads\": 21];\n```\n\n----------------------------------------\n\nTITLE: Task Caching Optimization with Local Function in C#\nDESCRIPTION: Demonstrates optimization using local function with ref parameter for task caching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\n    Task<byte> GetTask(ref Task<byte> cache)\n    {\n        if (cache == null) cache = Task.FromResult(result);\n        return cache;\n    }\n    return GetTask(ref taskCache[result]); // only indexing once\n```\n\n----------------------------------------\n\nTITLE: Parameter Modifier Ambiguity Example in C#\nDESCRIPTION: Example showing ambiguity between in parameter modifier and value parameter overloads, which can cause compilation issues when calling methods with DateTime parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-12-04.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(in DateTime d) { }\nvoid M(DateTime d) {}\n\nM(myDT); // ambiguity\n```\n\n----------------------------------------\n\nTITLE: Exploring Conditional Operator-like Syntax for Switch Expressions in C#\nDESCRIPTION: Explores alternative syntax for switch expressions based on the conditional (ternary) operator, using question marks and colons.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-30.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ne\n    ? 1 => \"one\"\n    : 2 => \"two\"\n    : var x when x > 2 => \"too many\"\n    : _ => \"too few\"\n```\n\nLANGUAGE: c#\nCODE:\n```\ne\n    ? 1 => \"one\"\n    ? 2 => \"two\"\n    ? var x when x > 2 => \"too many\"\n    : \"too few\"\n```\n\nLANGUAGE: c#\nCODE:\n```\ne\n    ? 1 -> \"one\"\n    ? 2 -> \"two\"\n    ? var x when x > 2 -> \"too many\"\n    : \"too few\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Struct Constructor Delegation with Primary Constructors in C#\nDESCRIPTION: Example showing a struct with a primary constructor and an additional explicit constructor that delegates to the default constructor instead of the primary constructor, raising design questions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-21.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S(int x)\n{\n    public S(bool b) : this() { â€¦ }\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Name Warnings Example\nDESCRIPTION: Shows how warnings for unused names differ between explicit and inferred tuple element names.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-05.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\n(int, int) t = (x: x, y); // warning for x. No warning for y, because inferred\n```\n\n----------------------------------------\n\nTITLE: Nullable Types with Interface Constraints\nDESCRIPTION: Demonstration of warning behavior when using nullable types with interface constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nstatic void F<T>(T t) where T : IDisposable { }\nF(maybeNull); // warning: Stream? does not satisfy 'IDisposable' constraint\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unified Record Declaration Syntax in C#\nDESCRIPTION: Illustrates a proposal for unifying positional and nominal record declarations by allowing property declarations in the parameter list.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-27.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic record Point(\n    public int X { get; init; },\n    public int Y { get; init; }\n)\npublic record Point\n{\n    public int X { get; init; },\n    public int Y { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: TryConvert Method Signature in C#\nDESCRIPTION: Defines the generic signature for a hypothetical TryConvert method that would handle type conversion with a boolean return indicating success.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic static bool TryConvert<TSource, TResult>(TSource src, out TResult res);\n```\n\n----------------------------------------\n\nTITLE: Using Underscore Identifier in Nested Scopes\nDESCRIPTION: Example showing how an underscore variable behaves in a nested scope, pointing out the difference between this behavior and what might be expected in lambda expressions with discard parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-28.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M()\n{\n    int _ = 0;\n    {\n        _ = 1; // This assigns to the variable _\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: For Loop Desugaring to While Loop in C#\nDESCRIPTION: Conceptual transformation of a for loop into a while loop to illustrate how expression variables in for loop conditions should behave similar to while loop conditions with respect to scope and lifetime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-30.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nfor (<decl>; <cond>; <incr>) <body>\n\n==>\n\n{\n    <decl>\n    while(<cond>)\n    {\n        <body>\n\tcont:\n        { <incr> }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating struct constructor with ': this()' call and field initializers\nDESCRIPTION: Example of the C# code pattern being discussed where a struct constructor uses the ': this()' chaining syntax while the struct also contains field initializers, creating definite assignment issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-30.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n: this()\n```\n\n----------------------------------------\n\nTITLE: Defining an Implicit Extension in C#\nDESCRIPTION: Demonstrates the syntax for defining an implicit extension named JsonDoc for the string type, with an extension method ExtensionMember.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-08-09.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension JsonDoc for string { public void ExtensionMember() { } }\n```\n\n----------------------------------------\n\nTITLE: Issue Links\nDESCRIPTION: GitHub issue and specification links for First-Class Spans feature\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-24.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nChampion issue: https://github.com/dotnet/csharplang/issues/7905\nSpec link: https://github.com/dotnet/csharplang/blob/dd326f7fb0c282825ed1b2ffbe8180b6c54afa1c/proposals/first-class-span-types.md#conversion-from-type-vs-from-expression\n```\n\n----------------------------------------\n\nTITLE: Defining Nominal Record Syntax in C#\nDESCRIPTION: Example showing the proposed shorthand syntax for nominal records with properties X and Y, demonstrating the basic record declaration pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-19.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nrecord Point { int X; int Y; }\n```\n\n----------------------------------------\n\nTITLE: Setting Required Members in Record Copy Constructors\nDESCRIPTION: Decision regarding the SetsRequiredMembers attribute for record copy constructors. The attribute will be added when the record or any base type has required members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-23.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Using Role as a Class Type in Generics\nDESCRIPTION: The snippet exemplifies how a role can be utilized as a class type constraint within a generic method in C#. The generic method M<T> accepts a type parameter T constrained to class types. The role Role extends SomeClassType, enabling it to satisfy the generic constraint. This is achieved without revealing the ref struct implementation detail.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-01-23.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nrole Role : SomeClassType;\nvoid M<T>() where T : class { }\nM<Role>(); // okay, `modopt(Role) Underlying`, Roslyn metadata reader can recover `Role`. Can reflection see custom modifiers?\n```\n\n----------------------------------------\n\nTITLE: Out Variables in Conditions\nDESCRIPTION: Shows the usage of out variables in conditional statements with the TryParse pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nif (int.TryParse(s, out var i) && i > 0) ...\n```\n\n----------------------------------------\n\nTITLE: Preventing Readonly Field Mutation Through Ref Assignment\nDESCRIPTION: Demonstrates how ref safe context rules prevent storing a ref to a readonly field in a ref field, which would allow mutating readonly data after construction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_53\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly ref struct S\n{ \n    readonly int i; \n    readonly ref int r; \n    public S()\n    {\n        i = 0;\n        // Error: `i` has a narrower scope than `r`\n        r = ref i;\n    }\n\n    public void Oops()\n    {\n        r++;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Extension Container Type Parameters in C#\nDESCRIPTION: Example demonstrating how generic type parameters might work with extension containers. Shows valid and potentially problematic usages of type parameters in extension members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nextensions E<T>\n{\n    public void (IComparable<T> obj) M1(); // Firne\n    public int (string s) M2(IEnumerable<T> items); // Fine\n    \n    public T M3(); // Works with disambiguation, but issue a warning.\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Union Class Member in C#\nDESCRIPTION: This snippet shows how to construct a member of a union class. A new instance of the 'A' member, which is part of the 'U' union, is created using the 'new' keyword, passing in the required parameters (an integer and a string). The resulting object, of type 'A', is then implicitly converted and assigned to a variable 'u' of type 'U'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nU u = new A(10, \"ten\");\n```\n\n----------------------------------------\n\nTITLE: Example 4: Operator Resolution with Inheritance and Numeric Types\nDESCRIPTION: Demonstrates operator resolution between base and derived classes with different numeric parameter types. Shows how checked and unchecked contexts affect operator selection when dealing with byte and int parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    static void Add(C2 x, byte y)\n    {\n        object o;\n        \n        // C1.op_CheckedAddition\n        o = checked(x + y);\n        \n        // C2.op_Addition\n        o = unchecked(x + y);\n    }\n\n    static void Add2(C2 x, int y)\n    {\n        object o;\n        \n        // C2.op_Addition\n        o = checked(x + y);\n        \n        // C2.op_Addition\n        o = unchecked(x + y);\n    }\n}\n\nclass C1\n{\n    public static C1 operator checked + (C1 x, byte y) => new C1();\n}\n\nclass C2 : C1\n{\n    public static C2 operator + (C2 x, int y) => new C2();\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Grammar Changes for Inline Array Types in C#\nDESCRIPTION: This snippet shows the proposed grammar changes to support inline array types, including the addition of a constant expression for specifying array length.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_11\n\nLANGUAGE: ANTLR\nCODE:\n```\narray_type\n    : non_array_type rank_specifier+\n    ;\n\nrank_specifier\n    : '[' ','* ']'\n   | '[' constant_expression ']' \n    ;\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Member Types in ANTLR Grammar\nDESCRIPTION: ANTLR grammar definition specifying all possible types of extension member declarations including constants, fields, methods, properties, events, indexers, operators, constructors, finalizers, and nested types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_16\n\nLANGUAGE: antlr\nCODE:\n```\nextension_member_declaration\n    : constant_declaration\n    | field_declaration\n    | method_declaration\n    | property_declaration\n    | event_declaration\n    | indexer_declaration\n    | operator_declaration\n    | constructor_declaration\n    | finalizer_declaration\n    | static_constructor_declaration\n    | type_declaration\n    ;\n```\n\n----------------------------------------\n\nTITLE: Simulated Named Indexers with Structs\nDESCRIPTION: Shows how the proposal enables struct-based wrapper implementations for simulated named indexers, which currently require class wrappers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/readonly-setter-calls-on-non-variables.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar c = new C();\n\n// Proposal: no error because the indexer's set accessor is readonly.\nc.SimulatedNamedIndexer[42] = new object();\n\nclass C\n{\n    public WrapperStruct SimulatedNamedIndexer => new(this);\n\n    public readonly struct WrapperStruct(C c)\n    {\n        public object this[int index]\n        {\n            // Indexer accesses private state or calls private methods in 'C'\n            get => ...;\n            set => ...;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: C# Language Syntax Specification Changes for \\e Escape Sequence\nDESCRIPTION: Diff showing the proposed changes to the C# language syntax specification to add the \\e escape sequence to the Simple_Escape_Sequence fragment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/esc-escape-sequence.md#2025-04-21_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\nfragment Simple_Escape_Sequence\n-    : '\\\\\\'\\'' | '\\\\\\\"' | '\\\\\\\\' | '\\\\0' | '\\\\a' | '\\\\b' | '\\\\f' | '\\\\n' | '\\\\r' | '\\\\t' | '\\\\v'\n+    : '\\\\\\'\\'' | '\\\\\\\"' | '\\\\\\\\' | '\\\\0' | '\\\\a' | '\\\\b' | '\\\\f' | '\\\\n' | '\\\\r' | '\\\\t' | '\\\\v' | '\\\\e'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Abbreviated Extension Declaration (Merged Declaration and Member) in C#\nDESCRIPTION: This code shows an example of merging an extension declaration and its single member, omitting the curlies. This is a potential short-hand syntax. In the generated output, the type parameter and underlying type are applied to a generated nested class, not the member itself.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong) public bool this[int index]\n    {\n        get => (this & Mask(index)) != 0;\n        set => this = value ? this | Mask(index) : this & ~Mask(index); // mutates underlying value\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<T>(IEnumerable<T>) public IEnumerable<T> Where(Func<T, bool> predicate) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Repository Links in Markdown\nDESCRIPTION: Markdown links pointing to the new location of C# language specification documentation and historical content.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/spec/introduction.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[`dotnet/csharpstandard`](https://github.com/dotnet/csharpstandard)\n[standard/README.md](https://github.com/dotnet/csharpstandard/blob/draft-v6/standard/README.md)\n[ms-spec-text](https://github.com/dotnet/csharplang/releases/tag/ms-spec-text)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating NaN Equality Behavior Discrepancy in ValueTuples\nDESCRIPTION: Example showing how equality operations behave differently when using the == operator versus the Equals method with NaN values in a ValueTuple. This relates to the record equality operator discussion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-07-27.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar a = (float.NaN, double.NaN);\nSystem.Console.WriteLine(a == a); // Prints false\nSystem.Console.WriteLine(a.Equals(a)); // Prints true\n```\n\n----------------------------------------\n\nTITLE: Demonstrating params span issue in Expression lambda (C#)\nDESCRIPTION: This code snippet shows how the params span feature can cause issues when used within an Expression lambda. The string.Join method with a ReadOnlySpan parameter is unexpectedly selected.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/ignore-overloads-in-expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nExpression<Func<string, string, string>> expr =\n    (x, y) => string.Join(\"\", x, y); // String.Join(string?, params ReadOnlySpan<string?>)\n```\n\n----------------------------------------\n\nTITLE: Overloading Methods with Ad Hoc Union Parameters in C#\nDESCRIPTION: Illustrates the limitations of method overloading with ad hoc union parameters due to type erasure at runtime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\npublic void Wash((Cat or Dog) pet) { ... }\npublic void Wash((Compact or Sedan) car) { ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Interpolation Syntax Example\nDESCRIPTION: Example showing potential syntax for conditional interpolation evaluation using $? prefix, though this was discussed but not implemented in the final decision.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-19.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n$?\"{ConditionallyEvaluated()}\"\n```\n\n----------------------------------------\n\nTITLE: Suggested Calli Invocation Syntax\nDESCRIPTION: Proposed syntax for calling methods through function pointers with explicit calling convention specification at the call site.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-05.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n_calli_stdcall(args, f)\n```\n\n----------------------------------------\n\nTITLE: Declaration in Embedded Statement Error Example in C#\nDESCRIPTION: Example showing the existing C# restriction against declaring variables in embedded statements, which the team considered keeping despite new ways to declare variables through expression variables and deconstruction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-30.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nif (x > 3) var y = x; // Error: declaration statement not allowed as an embedded statement\n```\n\n----------------------------------------\n\nTITLE: C# Symbol Reference Example\nDESCRIPTION: Demonstrates different ways of referencing methods using nameof with various scoping contexts including static, instance, and extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass C {\n   [3 references] static void f(int i) {...nameof(f)...}\n   [3 references] void f(string s) {...nameof(this.f)...}\n   [3 references] void f(object o) {...nameof(C.f)...}\n}\nstatic class E {\n   [2 references] public static void f(this C c, double d) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Examples of Null-resilient Getters in C#\nDESCRIPTION: A collection of property getter patterns that are considered null-resilient because they handle null values without nullability warnings when the backing field is maybe-null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nget => field ?? \"\";\nget => field ??= new();\nget => LazyInitializer.EnsureInitialized(ref field, ...);\nget => field ?? throw new InvalidOperationException(...);\nget => throw new NotImplementedException();\nget => field!;\n```\n\n----------------------------------------\n\nTITLE: T?? Generic Type Syntax Ambiguities in C#\nDESCRIPTION: Code examples demonstrating parsing ambiguities with proposed T?? syntax for generic nullable types in different contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-17.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n(X??, Y?? y) t;\nusing (T?? t = u) { }\nF((T?? t) => t);\n```\n\n----------------------------------------\n\nTITLE: Shadowing with File-Local Types\nDESCRIPTION: This snippet demonstrates how a file-local type can shadow a namespace or a non-file-local type within the file it is declared. This means that unqualified references to the type name within that file will resolve to the file-local type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// File1.cs\nclass C\n{\n    public static void M() { }\n}\n\n// File2.cs\nfile class C\n{\n    public static void M() { }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        C.M(); // refers to the 'C' in File2.cs\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invariant Culture Formatting Helper\nDESCRIPTION: Utility method for formatting interpolated strings using invariant culture.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic static string INV(IFormattable formattable)\n{\n    return formattable.ToString(null, System.Globalization.CultureInfo.InvariantCulture);\n}\n```\n\n----------------------------------------\n\nTITLE: Field Keyword Usage Example\nDESCRIPTION: Conceptual example of the proposed field keyword usage in property implementation\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-03-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic string Name\n{\n    get => field;\n    set\n    {\n        if (value != field)\n        {\n            field = value;\n            NotifyPropertyChanged();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Default Value Usage\nDESCRIPTION: Example of safe usage of default value in generic method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nT M<T>()\n{\n    var t = default(T);\n    if (something) t = somethingelse;\n    if (t != null) WriteLine(t.ToString());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Required Properties in C#\nDESCRIPTION: Example of a required property declaration in C# that was discussed in the meeting regarding its default nullability state in constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-08-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic required string Prop { get; set; }\n```\n\n----------------------------------------\n\nTITLE: Specifying Language Version and Target Framework in .csproj\nDESCRIPTION: This snippet shows how to specify the language version and target framework in a .csproj file for a C# project. It indicates the use of C# version 12 with .NET 9.0, which is relevant when discussing overload resolution issues related to params collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-22.md#2025-04-21_snippet_0\n\nLANGUAGE: dotnetcli\nCODE:\n```\n<LangVersion>12</LangVersion>\n<TargetFramework>net9.0</TargetFramework>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Target-typed new-expression Syntax in C#\nDESCRIPTION: Shows the basic syntax for target-typed new-expressions in C#, allowing omission of type in the new expression when the type can be inferred from the context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-25.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nC c = new (...){ ... };\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Full Transparency for KeyValuePair in C#\nDESCRIPTION: This example shows full transparency support for KeyValuePair, allowing implicit conversions in all contexts, similar to tuple behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nKeyValuePair<string, int> kvp = new(\"mads\", 21);\nDictionary<object, int?> map1 = [kvp]; // legal.\nList<KeyValuePair<object, int?>> map1 = [kvp]; // legal.\nKeyValuePair<object, int?> kvp2 = kvp1; // legal.\n```\n\n----------------------------------------\n\nTITLE: Handling Nullable Reference Types in Extension Methods\nDESCRIPTION: Shows how separate extension declarations might be needed for nullable and non-nullable versions of the same type, which breaks the principle that nullability shouldn't have semantic impact.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic extension NullableStringExtension for string?\n{\n    [this:NotNullWhen(false)] public bool IsNullOrEmpty => this is null or [];\n}\npublic extension StringExtension for string\n{\n    public string Reverse() => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Approach B1: Setter Example (C#)\nDESCRIPTION: Demonstrates how a setter could set the backing field to null, showing the potential for false negatives in the analysis, even if the constructor initializes the property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n\"string Prop { get; set => field = value is \\\"\\\" ? null : value }\\n\\npublic C()\\n{\\n    this.Prop = \\\"\\\";\\n    // would not warn, even though you could get null. \\n    Console.WriteLine(this.Prop);\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Abstract Person class with With method for with-expressions\nDESCRIPTION: Demonstrates an abstract Person class with a virtual With method to support with-expressions for derived types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-02-29.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Person\n{\n  ...\n  public abstract Person With(string firstName, string lastName);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Target-typing Ambiguity with UTF-8 Strings in C#\nDESCRIPTION: This snippet illustrates the potential ambiguity when using string literals with overloaded methods that accept both standard string and the proposed Utf8String type. Due to backwards compatibility, the string version would be chosen by default, which might not match user expectations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-09-16.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string s) { ... }\nvoid M(Utf8String s) { ... }\n\nM(\"some string\"); // This would call the `string` version, because backwards compatibility requires\n                  // \"\" always be a `string` first, and a `Utf8String` second\n```\n\n----------------------------------------\n\nTITLE: Exploring Casting and Non-null Declarations in C#\nDESCRIPTION: This snippet demonstrates different approaches to declaring variables with potential null values, including using var, explicit casting, and a proposed var? syntax. It illustrates the nuances of preserving null state information.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-28.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar s1 = \"Hello\"; // But I want to assign null later\nvar s2 = (string?)\"Hello\"; // Either disallowed, makes no difference or forgets null state\nvar? s3 = \"Hello\"; // Nullable but keeps the null state\n```\n\n----------------------------------------\n\nTITLE: Using Ref Ternary in Non-Ref Context in C#\nDESCRIPTION: Example showing that ref ternary expressions can also be used in a regular (non-ref) context, although a regular ternary would work the same in this case.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\n// only an example\n// a regular ternary could work here just the same\nint x = (arr != null ? ref arr[0]: ref otherArr[0]);\n```\n\n----------------------------------------\n\nTITLE: Legal Mixed Uses of Generic Types in nameof (C#)\nDESCRIPTION: Examples of legal mixed uses of bound and unbound generic types in nameof expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/unbound-generic-types-in-nameof.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar v = (nameof(X<>.Y<int>));\nvar v = (nameof(X<int>.Y<>));\n```\n\n----------------------------------------\n\nTITLE: Tuple Name Checking in Deconstruction\nDESCRIPTION: Example of potential syntax for checking tuple element names during deconstruction, demonstrating optional name validation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\n(x: a, y: b) = GetCoordinates(); // Error if names in return tuple aren't x and y\n```\n\n----------------------------------------\n\nTITLE: Generated Main Method with Return\nDESCRIPTION: Shows transformation of simple example with return into Program class with int return type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\npartial class Program\n{\n    static int $Main(string[] args)\n    {\n        System.Console.WriteLine(\"Hi!\");\n        return 2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Optimized IAsyncEnumerator Design in C#\nDESCRIPTION: An alternative design for IAsyncEnumerator<T> that optimizes performance by reducing interface calls when values are available synchronously. This design separates synchronous and asynchronous access paths but introduces more complexity.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-03.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IAsyncEnumerator<out T> : IAsyncDisposable\n{\n    ValueTask<bool> WaitForNextAsync();\n    T TryGetNext(out bool success);\n}\n```\n\n----------------------------------------\n\nTITLE: Positional Record Syntax in C#\nDESCRIPTION: Example of the positional record syntax that automatically generates properties, constructor, and deconstruct methods from the parameters. This is a more concise alternative to nominal records.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-11.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nrecord Person(string FirstName, string LastName);\n```\n\n----------------------------------------\n\nTITLE: Extension Method Priority Grouping Example\nDESCRIPTION: Demonstrates how extension methods are ordered by priority within their own type, showing interaction between multiple extension classes with different priority levels.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/overload-resolution-priority.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nnew C2().M([1, 2, 3]); // Will print Ext2 ReadOnlySpan\n\nstatic class Ext1\n{\n    [OverloadResolutionPriority(1)]\n    public static void M(this C2 c, Span<int> s) => Console.WriteLine(\"Ext1 Span\");\n    [OverloadResolutionPriority(0)]\n    public static void M(this C2 c, ReadOnlySpan<int> s) => Console.WriteLine(\"Ext1 ReadOnlySpan\");\n}\n\nstatic class Ext2\n{\n    [OverloadResolutionPriority(0)]\n    public static void M(this C2 c, ReadOnlySpan<int> s) => Console.WriteLine(\"Ext2 ReadOnlySpan\");\n}\n\nclass C2 {}\n```\n\n----------------------------------------\n\nTITLE: Ref Return Method Example in C#\nDESCRIPTION: This code demonstrates a method that returns a ref to a nested node in a data structure. It shows how ref locals can be used within methods that return refs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-01.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nref Node M(ref Node n)\n{\n  if (...)\n  {\n    ref Node l = ref GetLeftMostSubNode(ref n);\n    l.Contents = ...; // modify leftmost node\n    return ref l;\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Extension method call on a Collection Expression in C#\nDESCRIPTION: Illustrates the use of extension methods with collection expressions, aiming to support scenarios like `[a, b, c].ExtensionMethod()`. The current limitation is that the expression must have a type prior to the extension method lookup. This highlights the need to allow type inference for collection expressions in extension method scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2024-01-23.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nWe are still interesting in enabling `[a, b, c].ExtensionMethod()`. However, we think this is not something that should be limited to collection expressions.  Broadly speaking, the language is very limited wrt to the interaction of extension methods and target-typed constructs.  For example, you cannot do this `(x => true).ExtensionOnStringPredicate()`.\n```\n\n----------------------------------------\n\nTITLE: Defining IAsyncEnumerable Interface with Optional Cancellation Token in C#\nDESCRIPTION: Shows a potential interface definition for IAsyncEnumerable with an optional CancellationToken parameter for GetAsyncEnumerator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-18.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IAsyncEnumerable<T>\n{\n\tIAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken ct = default);\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Tuple Conversion Complexity in C#\nDESCRIPTION: Demonstrates the complexity of tuple conversions based on element type conversions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nvar t1 = (\"John\", 5);   // (string, int)\n(object, long) t2 = t1; // What kind of conversion is this? Where is it allowed\n```\n\n----------------------------------------\n\nTITLE: Optimized Deconstruction Translation\nDESCRIPTION: Optimized translation of deconstruction in queries using fewer method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\npoints\n\t.Select(__p1 => new { x = __p1.Item1, y = __p1.Item2 })\n\t.Select(__p2 => new { dx = __p2.x - x0, dy = __p2.y - y0, * = __p2 }\n\t.Select(__p3 => Sqrt(__p3.dx * __p3.dx, __p3.dy * __p3.dy)\n```\n\n----------------------------------------\n\nTITLE: Defining an Extension Within a Class in C#\nDESCRIPTION: This snippet illustrates how to define an extension member within a class using C#. The code suggests using a static import of class C to bring the extension E into scope. This setup implies that if the extension type can be accessed with a simple name, it is effectively in scope. The dependencies include ensuring that the extension is correctly defined within its class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-01-23.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public extension E \n    { \n    }\n}\n\nusing static C;\n// E an extension here?\n```\n\n----------------------------------------\n\nTITLE: Extension Method Dumper Usage\nDESCRIPTION: This snippet shows the usage of ExtensionMethodDumper to gather statistics on extension methods in .NET libraries. It calculates the ratio of original types to the number of types needed if extension methods were organized by receiver type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-30.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n\"https://github.com/DustinCampbell/ExtensionMethodDumper\"\n```\n\n----------------------------------------\n\nTITLE: RefSafetyRulesAttribute Definition\nDESCRIPTION: Defines the RefSafetyRulesAttribute class for handling version compatibility in ref safety rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_24\n\nLANGUAGE: c#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]\n    internal sealed class RefSafetyRulesAttribute : Attribute\n    {\n        public RefSafetyRulesAttribute(int version) { Version = version; }\n        public readonly int Version;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Method with Null-Checked Parameter in C#\nDESCRIPTION: This snippet shows a potential syntax for declaring a method parameter that should be dynamically null-checked at runtime. It's part of a discussion on expanding nullable features.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-08-20.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string s!) { }\n```\n\n----------------------------------------\n\nTITLE: Extension Container Prototype with Instance Receiver in C#\nDESCRIPTION: This code snippet shows a proposed format for representing extension members in documentation, using an `extension` container. The `source` parameter is an instance of `IEnumerable<T>`. The code illustrates an extension property within the extension container.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Extension-API-docs.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nextension<T>(IEnumerable<T> source)\n{\n    public bool IsEmpty { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Definite Assignment Issues with Out Variables in C#\nDESCRIPTION: Illustrates a potential copy/paste bug that can occur with the new scope rules for out variables. This scenario could benefit from improved definite assignment analysis or a Roslyn analyzer.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-10-25-26.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nif (int.TryParse(s1, out var i)) { ... i ... }\nif (int.TryParse(s2, out var j)) { ... i ... } // copy/paste bug - still reading i instead of j\n```\n\n----------------------------------------\n\nTITLE: Interface Constraints with Generics\nDESCRIPTION: Example of generic interface constraints with nullable types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nstatic void F<T>(T t) where T : IFoo<string?> { }\nIFoo<string> foo;\nF(foo); // warning, unless IFoo is covariant\n```\n\n----------------------------------------\n\nTITLE: Params Reference Capture Example\nDESCRIPTION: Demonstrates a case where params optimization cannot be applied due to potential reference capture through ref returns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/format.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class SneakyCapture {\n    static ref int M(params Span<T> span) => ref span[0];\n\n    static void Oops() {\n        // This now holds onto the memory backing the Span<T> \n        ref int r = ref M(42);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining to Default Constructor in Struct in C#\nDESCRIPTION: Demonstrates the current approach to chaining to a default constructor in a struct, which may not work with user-defined parameterless constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nS(int x): this() { this.X = x; }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Object Initializer Rules in C#\nDESCRIPTION: This code snippet demonstrates the rules for object initializers in C#, showing how safe contexts are determined and how member initializers can be modeled as constructor arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nSpan<int> heapSpan = default;\nSpan<int> stackSpan = stackalloc int[42];\nvar x = new S(ref heapSpan)\n{\n    Field = stackSpan;\n}\n\n// Can be modeled as \nvar x = new S(ref heapSpan, stackSpan);\n```\n\n----------------------------------------\n\nTITLE: Implementing Virtual Property Override in C#\nDESCRIPTION: Example demonstrating potential ambiguity in overriding virtual properties with semi-auto properties, specifically around assignment behavior in derived classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-05-02.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Base\n{\n    public virtual int Prop { get; set; }\n}\nclass Derived : Base\n{\n    public override int Prop { get => field; }\n\n    public Derived()\n    {\n        Prop = 1; // Does this call the setter from Base? Or does it assign to the backing field in Derived?\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Enhanced Line Indicator Syntax in C#\nDESCRIPTION: New syntax allowing full span mapping with start/end line and character positions, providing more precise source code tracking\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/enhanced-line-directives.md#2025-04-21_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\nline_indicator\n    : '(' decimal_digit+ ',' decimal_digit+ ')' '-' '(' decimal_digit+ ',' decimal_digit+ ')' whitespace decimal_digit+ whitespace file_name\n    | '(' decimal_digit+ ',' decimal_digit+ ')' '-' '(' decimal_digit+ ',' decimal_digit+ ')' whitespace file_name\n    | decimal_digit+ whitespace file_name\n    | decimal_digit+\n    | 'default'\n    | 'hidden'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Null Coalescing with Conditional Access\nDESCRIPTION: Shows a case where definite assignment is incorrectly handled with null coalescing and conditional access\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nif (c?.M(out object obj4) ?? false)\n{\n    obj4.ToString(); // undesired error\n}\n```\n\n----------------------------------------\n\nTITLE: Data Class with Additional Property\nDESCRIPTION: Shows how a data class can combine primary constructor parameters with additional properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\ndata class Point(int X, int Y)\n{\n    public int Z { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Raw Interpolated String Syntax Examples in C#\nDESCRIPTION: Demonstration of raw string literal syntax patterns being discussed, showing both current and proposed behaviors for brace handling in interpolated strings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-11.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n$\"\"\" {{0}} \"\"\"\n```\n\nLANGUAGE: C#\nCODE:\n```\n$\"{{expr}}\"\n```\n\nLANGUAGE: C#\nCODE:\n```\n$\"\"\"{{expr}}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Result Union Type Definition in C#\nDESCRIPTION: Defines a Result union struct type for representing either successful results or errors, similar to Result types in other languages.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\npublic union struct Result<TValue, TError>\n{\n    Success(TValue value);\n    Failure(TError error);\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Return Type Inference with Ad Hoc Unions in C#\nDESCRIPTION: Demonstrates how the return type of a lambda expression can be inferred as an ad hoc union of the possible return types in the lambda body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\nT M<T>(F<int, T> f) => f(2);\n\n(Dog or Cat or Bird) pet = \n    M(x => \n    {\n        if (x == 1)\n            return rufus;\n        else if (x == 2)\n            return petunia;\n        return polly;\n    });\n```\n\n----------------------------------------\n\nTITLE: Complex Query Translation with Anonymous Types\nDESCRIPTION: First approach at translating expression variables in queries, using nested anonymous types to carry both the boolean result and variable value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nstrings\n\t.Select(s => new { s, __w = int.TryParse(s, out int i) ? new { __c = true, i } : new { __c = false, i = default } })\n\t.Where(__p => __p.__w.__c);\n\t.Select(__p => __p.__c.i);\n```\n\n----------------------------------------\n\nTITLE: Struct Member Access Restrictions\nDESCRIPTION: Demonstrates the access modifier restrictions for struct members, showing that private protected cannot be used in structs since they are implicitly sealed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/private-protected.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstruct MyStruct {\n    public int field1;      // Allowed\n    internal int field2;   // Allowed\n    private int field3;    // Allowed\n    // private protected int field4;  // Not allowed in structs\n}\n```\n\n----------------------------------------\n\nTITLE: Workarounds for Task<T> Covariance Issue in C#\nDESCRIPTION: This snippet shows two current workarounds for the Task<T> covariance issue: using the null-forgiving operator (!) to suppress the conversion warning, and providing an explicit type argument when creating the object.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-10-24.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nTask<string> x1 = ...;\nTask<string?> x2 = x1!; // could be doc'ed usage of suppression\nx2 = Task.FromResult<string?>(\"\"); // ok\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Cyclic Ref Assignment Problems\nDESCRIPTION: Shows a pathological case of self-reference that the compiler must prevent, where a ref field is assigned a reference to a field within the same struct instance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_54\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S\n{\n    int field;\n    ref int refField;\n\n    static void SelfAssign(ref S s)\n    {\n        // Error: s.field can only escape the current method through a return statement\n        s.refField = ref s.field;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring Filter Attributes for LINQ Methods in C#\nDESCRIPTION: This snippet presents potential attribute designs for identifying filtering methods in LINQ queries. These attributes could be used to opt-in methods to the new nullable analysis behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-07.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic static IEnumerable<T> Where<[NotNullWhenLambdaFlowStateNotNull]T>(this IEnumerable<T> enumerable, Predicate<T> predicate);\n\npublic static IEnumerable<T> Where<T>(this IEnumerable<T> enumerable, [Filter] Predicate<T> predicate);\n// or [NullFilter]?\n\n[return: Filter(nameof(predicate))]\npublic static IEnumerable<T> Where<T>(this IEnumerable<T> enumerable, Predicate<T> predicate);\n```\n\n----------------------------------------\n\nTITLE: Extension property example: Static/instance mismatch\nDESCRIPTION: These snippets demonstrates how static/instance mismatches affect the resolution of extension properties.  The compiler should prune extension properties based on whether the access is on an instance or a type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n\"_ = 42.P;\\n\\nstatic class E1\\n{\\n    extension(int i)\\n    {\\n        public int P => 0;\\n    }\\n}\\nstatic class E2\\n{\\n    extension(int)\\n    {\\n        public static int P => throw null;\\n    }\\n}\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\n\"_ = int.P;\\n\\nstatic class E1\\n{\\n    extension(int i)\\n    {\\n        public int P => throw null;\\n    }\\n}\\nstatic class E2\\n{\\n    extension(int)\\n    {\\n        public static int P => 0;\\n    }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Left Associative Interpretation in C#\nDESCRIPTION: Demonstrates how the null propagating operator would behave under left associative interpretation, checking only the first member access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nvar x = ((var tmp = a) == null ? null : tmp.b).c;\n```\n\n----------------------------------------\n\nTITLE: Implementing Bit Operations with Named Parameter in C# Extension Declaration\nDESCRIPTION: Illustrates the proposed relaxation allowing an optional parameter name in the anonymous extension declaration, improving code readability and avoiding unfamiliar use of 'this'.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Bits\n{\n    extension(ref ulong number) // underlying value is passed by ref and called \"number\"\n    {\n        public bool this[int index]\n        {\n            get => (number & Mask(index)) != 0;\n            set => number = value ? number | Mask(index) : number & ~Mask(index); // mutates underlying value\n        }\n    }\n    static ulong Mask(int index) => 1ul << index;\n}\n```\n\n----------------------------------------\n\nTITLE: For-Loop Clause Scoping with Declaration Expressions in C#\nDESCRIPTION: Example demonstrating the intended scoping rules for declaration expressions within the different clauses of a for-loop, showing how variables from earlier clauses are accessible in later ones.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-01-06.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nfor (int i = (int a = 0);\n     i < (int b = 10); // i and a in scope here\n     i += (int c = 1)) // i, a and b in scope here\n  (int d += i);        // i, a and b but not c in scope here\n```\n\n----------------------------------------\n\nTITLE: Example of Desirable Nullability Warning at Property Declaration in C#\nDESCRIPTION: Shows how warning at the property declaration rather than usage is more helpful for guiding users to properly initialize non-nullable properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T>\n{\n    // CS8618: Non-nullable property 'Prop' must contain a non-null value when exiting constructor.\n    public T[] Prop { get => (T[])field.Clone(); private set; }\n               ~~~~\n}\n```\n\n----------------------------------------\n\nTITLE: Target-Typed Switch Expression\nDESCRIPTION: Example showing a switch expression that should be implicitly convertible to a byte type based on the target type context, which requires enhanced conversion rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-22.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nbyte M(bool b) => b switch { false => 0, true => 1 };\n```\n\n----------------------------------------\n\nTITLE: Interface Default Implementation Inheritance\nDESCRIPTION: Demonstrates how default interface implementations are explicitly implemented rather than inherited as public members in implementing classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-08.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ninterface I { int M() => 0; }\nclass C : I { } // C does not have a public member \"M\"\n```\n\n----------------------------------------\n\nTITLE: Expression Element in Dictionary in C#\nDESCRIPTION: This snippet explores the possibility of using an expression that returns a `KeyValuePair` directly within a dictionary literal. It demonstrates how this could simplify dictionary initialization when the key-value pairs are derived from a function or other source.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_17\n\nLANGUAGE: c#\nCODE:\n```\nKeyValuePair<string, int> GetMads() => new(\"Mads\", 24);\n    \nDictionary<string, int> nameToAge = [\"Dustin\": 42, \"Cyrus\": 43, GetMads()]; // otherwise, you'd have to write:\n    \nvar mads = GetMads();\nDictionary<string, int> nameToAge = [\"Dustin\": 42, \"Cyrus\": 43, mads.Key: mads.Value];\n```\n\n----------------------------------------\n\nTITLE: Extension Method with Type Parameter Order Issue in C#\nDESCRIPTION: This code illustrates an extension method that cannot be expressed with the new syntax due to the type parameter order. The type parameters used in the underlying type are not first in the type parameter list. This is a case where the classic syntax must be used.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_16\n\nLANGUAGE: c#\nCODE:\n```\npublic static IEnumerable<TResult> WeirdSelect<TResult, TSource>(\n    this IEnumerable<TSource> source,\n    Func<TSource, TResult> selector) \n{ ... }\n```\n\n----------------------------------------\n\nTITLE: Nominal Record Syntax in C# with Property Declarations\nDESCRIPTION: Example of a potential simplified syntax for nominal records, where field-like declarations automatically create public init-only properties without requiring explicit property syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-11.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nrecord Person { string FirstName; string LastName; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Span<T> Constructor Limitation in C#\nDESCRIPTION: This code snippet illustrates a potential constructor for Span<T> that the language relies on not existing. Such a constructor would make Span<T> indistinguishable from a ref field, which the safety rules depend on not being a valid construct in C# or .NET.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Example(ref int x)\n{\n    // Create a span of length one\n    var span = new Span<int>(ref x); \n}\n```\n\n----------------------------------------\n\nTITLE: Integer Comparison Operators for UIntPtr\nDESCRIPTION: Defines comparison operators for System.UIntPtr type with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nbool operator ==(uint, System.UIntPtr)\nbool operator ==(System.UIntPtr, uint)\nbool operator ==(System.UIntPtr, System.UIntPtr)\n\nbool operator !=(uint, System.UIntPtr)\nbool operator !=(System.UIntPtr, uint)\nbool operator !=(System.UIntPtr, System.UIntPtr)\n\nbool operator  <(uint, System.UIntPtr)\nbool operator  <(System.UIntPtr, uint)\nbool operator  <(System.UIntPtr, System.UIntPtr)\n\nbool operator  >(uint, System.UIntPtr)\nbool operator  >(System.UIntPtr, uint)\nbool operator  >(System.UIntPtr, System.UIntPtr)\n\nbool operator <=(uint, System.UIntPtr)\nbool operator <=(System.UIntPtr, uint)\nbool operator <=(System.UIntPtr, System.UIntPtr)\n\nbool operator >=(uint, System.UIntPtr)\nbool operator >=(System.UIntPtr, uint)\nbool operator >=(System.UIntPtr, System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Explicit Casts with Nullable Reference Types in C#\nDESCRIPTION: This code snippet demonstrates various scenarios of explicit casting with nullable reference types. It shows how nullability is interpreted in different casting contexts, including object types, arrays, and generic interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-21.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n(object)null          // object?, with warning\n(object?)string.Empty // object\n(IEnumerable<object?>)new[]{string.Empty}    // IEnumerable<object> \n(IComparer<string?>)Comparer<object>.Default // IComparer<string>, with warning\n```\n\n----------------------------------------\n\nTITLE: Initializing Known Length Collection for Span in C#\nDESCRIPTION: Shows how to translate a known length collection literal to a Span<T>. It uses array allocation but notes that stackalloc or inline arrays could be used if span-safety is maintained.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nSpan<T1> __result = new T1[__len];\n\n// same assignments as the array translation\n```\n\n----------------------------------------\n\nTITLE: C# Grammar Definition for nameof Operator\nDESCRIPTION: Formal syntax definition for the nameof operator in C#. The grammar shows that nameof takes an expression as its argument, with additional constraints described in the surrounding text that limit which expression forms are allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nexpression: ... | nameof-expression\n\nname-of-expression:\n    nameof ( expression )\n```\n\n----------------------------------------\n\nTITLE: Partial Tuple Type Names in C#\nDESCRIPTION: Examples of tuple type declarations with partial naming, showing inferred types and explicit type declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-12.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar t = (1, y: 2); // infers (int, int y)\n(int x, int) t = (1, 2);\n```\n\n----------------------------------------\n\nTITLE: Defining a Person class in C#\nDESCRIPTION: Demonstrates a basic immutable Person class with FirstName and LastName properties and a constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-02-29.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Person\n{\n  public string FirstName { get; }\n  public string LastName { get; }\n\n  public Person(string firstName, string lastName)\n  {\n    FirstName = firstName;\n    LastName = lastName;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Member Hiding in C#\nDESCRIPTION: This snippet shows potential issues with extension members being hidden by underlying type members, and suggests a possible warning for such cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-as-static-types.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic extension StringExtensions for string\n{\n    public string Length => ...; // Useless - warning?\n    public bool IsUtf8 => ... Length ...; // Would bind to string.Length\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Inheritance of Allows Ref Struct Constraint in C#\nDESCRIPTION: Example showing that the 'allows ref struct' constraint is not inherited from type parameter constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T, S>\n    where T : allows ref struct\n    where S : T\n{}\n```\n\n----------------------------------------\n\nTITLE: Unconstrained Generic Parameter Default Value\nDESCRIPTION: Shows how unconstrained generics can lead to potential null reference issues with default values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-parameter-default-value-analysis.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T>\n{\n    void M0(T t) { }\n\n    void M1(T t = default) // no warning here\n    {\n        M0(t); // warning CS8604: Possible null reference argument for parameter 't' in 'void C<T>.M0(T t)'.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Protected And Internal Example\nDESCRIPTION: Example showing where protected and internal access levels are needed in C#, referencing the CSharpCompilationOptions class members that start with 'Common'\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/private-protected.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# private protected\\n\\nChampion issue: <https://github.com/dotnet/csharplang/issues/37>\\n\\n## Summary\\n[summary]: #summary\\n\\nExpose the CLR `protectedAndInternal` accessibility level in C# as `private protected`.\n```\n\n----------------------------------------\n\nTITLE: Example of Empty Record ToString Output in C#\nDESCRIPTION: This snippet shows the current output of ToString() for an empty record, which includes a double space. The team decided to remove the extra space in the output.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-08-24.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nPerson {  }\n```\n\n----------------------------------------\n\nTITLE: Generic Method with Nullable Class Constraint - Null Assignment\nDESCRIPTION: Shows warning behavior when assigning null to generic parameter. Warning is produced due to conversion from null to T.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-05.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M<T>(T p) where T : class?\n{\n    p = null; // This DOES produce a warning, because there's a conversion\n              // from `null` to T and we don't know that T is nullable\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Structural Equality with 'key' Modifier in C#\nDESCRIPTION: Example of using a proposed 'key' modifier to specify properties to be used in equality comparison. This demonstrates the basic concept but lacks initialization capability, which would be problematic in real-world usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-11.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    public key string Item1 { get; }\n    public string Item2 { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructor Usage Example\nDESCRIPTION: Shows how to use the extension constructor to create a new IEnumerable<int> instance.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nvar range = new IEnumerable<int>(1, 100);\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax for Runtime Null Checking\nDESCRIPTION: Strawman syntax for automatically generating runtime null checks for non-nullable reference type parameters using double exclamation marks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-10-17.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic void M(string!! s) { ... }\n```\n\n----------------------------------------\n\nTITLE: Primary Constructor Attribute Context\nDESCRIPTION: Contextual reference to method attribute placement on primary constructors, discussed in relation to copy constructors and deconstructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-03-13.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nmethod\n```\n\n----------------------------------------\n\nTITLE: Grammar Update for fieldof Expression in C#\nDESCRIPTION: Formal grammar definition for the new fieldof expression syntax in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/fieldof.md#2025-04-21_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\nprimary_no_array_creation_expression\n    : literal\n    | interpolated_string_expression\n    | simple_name\n    | parenthesized_expression\n(...)\n    | nameof_expression\n    | fieldof_expression\n(...)\n    ;\n\nfieldof_expression\n    : 'fieldof' '(' expression ')'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unexpected Warning in C# Constructor with Assertions\nDESCRIPTION: This example demonstrates how assertions or 'throw' statements do not prevent field initialization warnings in the current approach. An unexpected warning is generated despite the property being initialized in a separate method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-constructor-analysis.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public string Prop { get; set; }\n    public C() // unexpected warning: 'Prop' is not initialized\n    {\n        Init();\n\n        if (Prop is null)\n        {\n            throw new Exception();\n        }\n    }\n\n    void Init()\n    {\n        Prop = \"some default\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Node Generic Constraints\nDESCRIPTION: Various examples of nullable constraints with Node generic type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n... where T : Node<T>?\n... where T : Node<T?> // both currently allowed, but not where T : Node<T?>?\n... where T : class, INode<T?>\n... where T : class?, INode<T>?\n```\n\n----------------------------------------\n\nTITLE: Simple Object Instantiation with Target-typed new in C#\nDESCRIPTION: Shows basic object instantiation using target-typed new expression for a private static field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-new.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate readonly static object s_syncObj = new();\n```\n\n----------------------------------------\n\nTITLE: Minimal Position-Based Declaration\nDESCRIPTION: Most concise syntax for declaring a point class with positional parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-15.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Property Declaration Expansion - C#\nDESCRIPTION: Shows how the concise primary constructor property declaration would expand into full property declarations with getter-only auto-properties initialized from constructor parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-07.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic class Point(int x, int y)\n{\n   public int X { get; } = x;\n   public int Y { get; } = y;\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing ConfigureAwait Method Example\nDESCRIPTION: Implicit code reference discussing ConfigureAwait usage in async methods and its impact on Task materialization\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nConfigureAwait()\n```\n\n----------------------------------------\n\nTITLE: Invalid Enum Base Type Declaration with Native Integers in C#\nDESCRIPTION: This code demonstrates that native integers cannot be used as an enum base type in C#, resulting in a compilation error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nenum E : nint // error: byte, sbyte, short, ushort, int, uint, long, or ulong expected\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Type Equivalence in C# Overloading\nDESCRIPTION: This snippet shows a potential scenario where union type equivalence affects method overloading. It raises questions about whether order matters in union type declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-10-31.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Overloading\nvoid M(union (A|B) x);\nvoid M(union (B|A) x);\n```\n\n----------------------------------------\n\nTITLE: Implementing Closed Abstract Type in C#\nDESCRIPTION: Conceptual example of how a 'closed' keyword could be used with an abstract type in C# to create a discriminated union-like structure. This is not actual C# code, but a representation of the discussed concept.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclosed abstract class Shape\n{\n    // Known set of derived types in the same assembly\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conditional Expression Ambiguity in C#\nDESCRIPTION: Shows the ambiguous syntax in conditional expressions where target-typed static member lookup could be confused with null-safe dereferencing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/target-typed-static-member-lookup.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nexpr ? .Name : ...\n```\n\n----------------------------------------\n\nTITLE: Runtime Type Validation for Ad Hoc Unions in C#\nDESCRIPTION: Demonstrates how the compiler generates runtime type checks for assignments to ad hoc union types that can't be statically verified.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nobject value = ...;\nvar ab = (A or B)value;\n```\n\n----------------------------------------\n\nTITLE: Translated Abstract Record Class Implementation in C#\nDESCRIPTION: Shows how the compiler translates the abstract record class into a traditional class with property, constructor, equality methods, and other required record functionality.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Person : IEquatable<Person>\n{\n    public string Name { get; }\n    public Person(string Name)\n    {\n        this.Name = Name;\n    }\n    public bool Equals(Person other)\n    {\n        return other != null && Equals(Name, other.Name);\n    }\n    public override bool Equals(object other)\n    {\n        return Equals(other as Person);\n    }\n    public override int GetHashCode()\n    {\n        return (Name?.GetHashCode()).GetValueOrDefault();\n    }\n    public abstract Person With(string Name = this.Name);\n    public void Deconstruct(Person self, out string Name)\n    {\n        Name = self.Name;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unification of Anonymous Delegates with params Parameters in C#\nDESCRIPTION: Shows how anonymous delegates with array parameters are unified when the last parameter has the same params modifier and array type, regardless of parameter name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nint C(int[] xs) {\n  return xs.Length;\n}\n\nint D(params int[] xs) {\n  return xs.Length;\n}\n\nvar a = (int[] xs) => xs.Length;\n// internal delegate int a'(int[] xs);\nvar b = (params int[] xs) => xs.Length;\n// internal delegate int b'(params int[] xs);\n\nvar c = C;\n// internal delegate int a'(int[] xs);\nvar d = D;\n// internal delegate int b'(params int[] xs);\n\na = b; // Not allowed\na = c; // Allowed\nb = c; // Not allowed\nb = d; // Allowed\n\nc = (params int[] xs) => xs.Length; // Warning: different delegate types; no implicit conversion\nd = (int[] xs) => xs.Length; // OK. `d` is `delegate int (params int[] arg)`\n```\n\n----------------------------------------\n\nTITLE: Using 'field' Keyword in Property Initializers in C#\nDESCRIPTION: Examples examining whether 'field' should bind to a backing field in property initializers and potential scenarios for this usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\nclass A\n{\n    const int field = -1;\n\n    object P1 { get; } = field; // bind to const (ok) or backing field (error)?\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nclass B\n{\n    object P2 { get; } = (field = 2);        // error: initializer cannot reference instance member\n    static object P3 { get; } = (field = 3); // ok, but useful?\n}\n```\n\n----------------------------------------\n\nTITLE: Antlr Definition for Compilation Unit\nDESCRIPTION: This snippet presents the ANTLR grammar definition for the compilation unit structure in C#, accommodating the new file scoped namespace declaration. Adjustments were made to the existing grammar to integrate the new feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/file-scoped-namespaces.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\ncompilation_unit\n    : extern_alias_directive* using_directive* global_attributes? compilation_unit_body\n    ;\n\ncompilation_unit_body\n    : statement* namespace_member_declaration*\n    | file_scoped_namespace_declaration\n    ;\n\n```\n\n----------------------------------------\n\nTITLE: Option 2: Determining Scope Based on Usage in C#\nDESCRIPTION: Illustrates a potential approach where the scope of the target is determined based on how the variable is used in the code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> x1 = [a, b, c]; // Could be local or global scoped\nscoped ReadOnlySpan<int> x2 = [a, b, c]; // Always local scoped.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple Lifetimes in C# Method\nDESCRIPTION: This code snippet illustrates how different variables can have varying numbers of associated lifetimes, depending on their type and structure.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/REF-2022-11-11.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid E() {  \n    // Only two lifetimes here: the value and the ref \n    Span<int> span = ...; \n\n    // Three lifetimes: value, ref and value of Field\n    RS rs = ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Property Declaration Syntax in Primary Constructors - C#\nDESCRIPTION: Example showing proposed syntax for declaring properties directly in primary constructor parameters using a name mapping approach. Demonstrates how parameter names could map to property names with different casing conventions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-07.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic class Point(int x: X, int y: Y);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conversion Rules for Collection Expressions in C#\nDESCRIPTION: These snippets illustrate the conversion rules for collection expressions, including implicit conversions for elements and spread elements, and rules for collection initializer types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nstring[] a = [x, y, z];\nint[] b = [1, null];           // error: cannot convert 'null' to 'int'\nImmutableArray<int> c = [..a]; // error: cannot convert 'string' to 'int'\n```\n\nLANGUAGE: c#\nCODE:\n```\nMyCollection m = [1, \"2\", (object)3]; // error: no 'Add(object)' method found\n\nclass MyCollection : IEnumerable\n{\n    public void Add(int i) { ... }\n    public void Add(string s) { ... }\n    public IEnumerator GetEnumerator() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: IAsyncEnumerable Interface Definition\nDESCRIPTION: Definition of the IAsyncEnumerable interface for handling asynchronous sequences, with GetEnumerator method returning an IAsyncEnumerator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IAsyncEnumerable<T>\n{\n  public IAsyncEnumerator<T> GetEnumerator();\n}\n```\n\n----------------------------------------\n\nTITLE: Extension Declaration with Type Parameters (C#)\nDESCRIPTION: This C# code snippet demonstrates an extension declaration using type parameters and constraints. The code shows how the type parameters are declared on the extension declaration itself, while the underlying type is specified for the extension member, showcasing the interaction between type parameters and the proposed syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Extensions\n{\n    extension<T>\n    {\n        public bool (List<T>).IsEmpty => this.Count == 0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lightweight Dynamic Member Access with $ Operator\nDESCRIPTION: Example of the decided syntax for lightweight dynamic member access using the $ operator as a prefix to property names when accessing dynamic objects.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-12-16.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npayload.$People[i].$Name\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Variable Declaration Edge Cases in C#\nDESCRIPTION: Demonstrates various edge cases in pattern matching with variable declarations, including nullable types, tuple properties, and type inheritance scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-10-17.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// Example A\nif (e is C c || e is Wrapper { NullableReferenceTypeProp: var c }) { } // Should there be an error since `var` is `C?` here\n\n// Example B\nif (e is S s || e is Wrapper { NullableValueTypeProp: var s }) { } // Should there be an error since this is S vs Nullable<S>?\n\n// Example C\nif (e is C<(int a, int b)> c || e is Wrapper { Prop: var c }) { c.TupleProperty.a } // Is this ok? Where does the name a come from in the second example?\n\n// Example D\nif (e is Derived d) { d.DerivedMethod(); }\nelse if (e is Wrapper { BaseTypeProp: Base d }) { } // Should d be widened to `Base`? What happens to the above method access?\n```\n\n----------------------------------------\n\nTITLE: Algebraic Data Types Definition in C#\nDESCRIPTION: Example showing declaration of algebraic data types using sealed abstract class with nested record classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-10-07-Design-Review.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nabstract sealed class Expression\n{\n    class Binary(Operator Operator, Expression Left, Expression Right) : Expression;\n    class Constant(int Value) : Expression;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation Ambiguity\nDESCRIPTION: Shows problematic cases of interface implementation where ambiguity can arise from multiple inheritance paths.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-08.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\ninterface I5: I2, I3 { }\nclass C : I2, I 3 { }\n```\n\n----------------------------------------\n\nTITLE: Null String Constant Conversion Example\nDESCRIPTION: Demonstrates the conversion of null string constants to UTF-8 byte representations\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-26.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\n(string)null  // Can be converted to Span<byte>\n```\n\n----------------------------------------\n\nTITLE: Examples of Non-Null-resilient Getters in C#\nDESCRIPTION: Property getter patterns that are not considered null-resilient because they can produce nullability warnings when the backing field is maybe-null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nget;\nget => field;\nget => field ?? SomethingNullable;\nget => (T[]?)field?.Clone();\nget => (T[])field.Clone();\nget\n{\n    string unrelated = null; // Warning\n    return field ?? \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: InterpolatedStringHandlerArgumentValue Attribute Definition\nDESCRIPTION: Definition of the new attribute class that enables passing custom values to interpolated string handlers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/interpolated-string-handler-argument-value.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\n    public sealed class InterpolatedStringHandlerArgumentValueAttribute : Attribute\n    {\n        public InterpolatedStringHandlerArgumentValueAttribute(object? value)\n        {\n            Value = value; \n        }\n\n        public object? Value { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Type with Parallel Methods for Extension Type Encoding in C#\nDESCRIPTION: Illustrates a complex approach using nested types and parallel methods to encode extension types. It includes generic constraints and attribute-based matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-07.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C<T>\n{\n    [SecretMethod(\"Method1\")] // explicit matching, rather than complex auto-matching\n    U M<U>(U e, int x) where U : IDisposable\n\n    private abstract class Secret\n    {\n        abstract void/E<T, U1> Method1<U1>(E<T, U1> \"\", Secret \"\") where U1 : IDisposable;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Verbose Lambda Immediate Invocation in C#\nDESCRIPTION: Shows the verbose syntax required to immediately invoke a lambda expression in C#, highlighting a pain point that could potentially be addressed with type inference for lambdas.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\n((Func<int,int>)(x => x*x))(3); // What??!?\n```\n\n----------------------------------------\n\nTITLE: Using Null-Forgiving Operator with Target Typing in C#\nDESCRIPTION: Examples demonstrating how the null-forgiving operator works with target typing, allowing null assignments without nullability warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-16.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring s = null!;\nstring s = default!\nstring s = GetNameOrNull()!;\nList<string> l = GetList<string?>()!;\nList<string?> l = GetList<string>()!;\n```\n\n----------------------------------------\n\nTITLE: Mapping C# method syntax to lifetime model\nDESCRIPTION: This example shows how a C# method with ref parameters and returns is translated to the underlying lifetime model.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\nref int M1(ref int i) => ...\n\n// Maps to the following. \n\nref<$ro> int Identity<$ro>(ref<$ro> int i)\n{\n    // okay: has ref lifetime $ro which is equal to $ro\n    return ref i;\n\n    // okay: has ref lifetime $heap which convertible $ro\n    int[] array = new int[42];\n    return ref array[0];\n\n    // error: has ref lifetime $local which has no conversion to $a hence \n    // it's illegal\n    int local = 42;\n    return ref local;\n}\n```\n\n----------------------------------------\n\nTITLE: Object Initializer Syntax Example - C#\nDESCRIPTION: Demonstrates how object initializer syntax could be used with the proposed property declarations, showing initialization of getter-only properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-07.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvar p = new Person { LastName = \"Pascal\", FirstName = \"Blaise\" };\n```\n\n----------------------------------------\n\nTITLE: Branch Scope Pollution Example with Declaration Expressions in C#\nDESCRIPTION: Example demonstrating potential scope issues between if/else branches when using declaration expressions, where variables declared in one branch might incorrectly pollute another branch.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-01-06.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nif (â€¦) m(int x = 1); else m(x = 2); // cross pollution between branches?\n```\n\n----------------------------------------\n\nTITLE: Empty Switch Expression Example in C#\nDESCRIPTION: An example of an empty switch expression that the team decided should be allowed in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-07-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nexpr switch { }\n```\n\n----------------------------------------\n\nTITLE: Sealed Record Class Implementation Example\nDESCRIPTION: Complete implementation example of a sealed record class including equality members and deconstructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Student(string Name, decimal Gpa);\n```\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class Student : IEquatable<Student>\n{\n    public string Name { get; }\n    public decimal Gpa { get; }\n    public Student(string Name, decimal Gpa)\n    {\n        this.Name = Name;\n        this.Gpa = Gpa;\n    }\n    public bool Equals(Student other)\n    {\n        return other != null && Equals(Name, other.Name) && Equals(Gpa, other.Gpa);\n    }\n    public override bool Equals(object other)\n    {\n        return this.Equals(other as Student);\n    }\n    public override int GetHashCode()\n    {\n        return (Name?.GetHashCode()*17 + Gpa?.GetHashCode()).GetValueOrDefault();\n    }\n    public Student With(string Name = this.Name, decimal Gpa = this.Gpa) => new Student(Name, Gpa);\n    public void Deconstruct(out string Name, out decimal Gpa)\n    {\n        Name = self.Name;\n        Gpa = self.Gpa;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Original Stackalloc Grammar Definition in ANTLR\nDESCRIPTION: The original grammar rules for stackalloc initialization in unsafe contexts, showing the more restrictive syntax that is being replaced.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nested-stackalloc.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nlocal_variable_initializer_unsafe\n    : stackalloc_initializer\n    ;\n\nstackallocator_initializer\n    : 'stackalloc' unmanaged_type '[' expression ']'\n    ;\n```\n\n----------------------------------------\n\nTITLE: MVC Action Link Using nameof\nDESCRIPTION: Example of using nameof in MVC views to create type-safe action links by referencing controller and action names.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n<%= Html.ActionLink(\"Sign up\",\n             @typeof(UserController),\n             @nameof(UserController.SignUp))\n%>\n```\n\n----------------------------------------\n\nTITLE: Implicit Coercion Between Ad Hoc Union Types in C#\nDESCRIPTION: Shows how a value of one ad hoc union type can be implicitly coerced to another ad hoc union type when all source member types can be coerced to target member types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n(int or short) value = 10;\n(float or double) value2 = value;\n```\n\n----------------------------------------\n\nTITLE: Switch Expression Precedence Examples\nDESCRIPTION: Demonstrates different operator precedence behaviors with switch expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-13.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nx = a + b switch { ... } // this is `(a + b) switch { ... }`\nx = a & b switch { ... } // this is `a & (b switch { ... })`\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Breaking Change in Target-Typed Conditional for C#\nDESCRIPTION: This code snippet illustrates a potential breaking change in C# when using target-typed conditionals. It shows how method overload resolution could be affected, potentially causing ambiguity in method calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-06.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nM(b ? 1 : 2, 1); // calls M(long, long) without this feature; ambiguous without this feature\n\nM(short, short);\nM(long, long);\n```\n\n----------------------------------------\n\nTITLE: Lazy Computed Get-only Property in C#\nDESCRIPTION: Get-only property with lazy computation in getter body\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic string LazilyComputed { get => field ??= Compute(); }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Member Lookup Limitations in C#\nDESCRIPTION: This snippet illustrates that extension member lookup does not apply to Simple Names within an extension type. It shows that attempting to access a member defined in another extension results in an error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-03-05.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass C { }\n\nextension E1 for C \n{ \n    void M()\n    {\n        var x = Member; // error\n        string s = Member; // error\n    }\n}\n\nimplicit extension E2 for C\n{\n    public static string Member = \"\";\n}\n```\n\n----------------------------------------\n\nTITLE: Flow Control Safety Example - C#\nDESCRIPTION: Demonstrates potential issues with flow control and using variable lifetime/assignment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-09.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n{\n    goto target;\n    using var x = new FileStream(...);\ntarget:\n    var y = x;\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Positional Pattern Matching Syntax in C#\nDESCRIPTION: This snippet shows a potential syntax for positional pattern matching, which could provide a more concise way to match nested object structures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nif (s is ExpressionStatement(\n```\n\n----------------------------------------\n\nTITLE: Using Raw String Literals in C# 11.0\nDESCRIPTION: Demonstrates the use of raw string literals, which allow for unescaped content, introduced in C# 11.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar json = \"\"\"{ \"summary\": \"text\" }\"\"\";\n```\n\nLANGUAGE: C#\nCODE:\n```\nvar json = $$\"\"\"{ \"summary\": \"text\", \"length\": {{length}} }\"\"\";\n```\n\n----------------------------------------\n\nTITLE: Defining Record Base Call Syntax in ANTLR\nDESCRIPTION: ANTLR grammar rule defining the syntax for record base calls, including class type with optional argument list and interface type list.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-01.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nrecord_base\n    : ':' class_type argument_list?\n    | ':' interface_type_list\n    | ':' class_type argument_list? interface_type_list\n    ;\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Ref Scoped Parameter in C#\nDESCRIPTION: This snippet demonstrates how a 'ref scoped' parameter is defined and mapped to its equivalent annotation level representation. It shows the lifetime parameter and its relationship constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/expand-ref.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S { } \nvoid M(ref scoped S s) \n\n// maps to \n\nvoid M<$param1>(ref<$local> S<$param1> s)\n    where $param1 : $local\n```\n\n----------------------------------------\n\nTITLE: TryGet Method Signature with Defaultable Type Parameter in C#\nDESCRIPTION: Demonstrates a potential signature for a 'TryGet' method using a defaultable type parameter. While technically correct, it may not be the most useful approach for consumers of the method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-14.md#2025-04-23_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nbool TryGet(out T? value); // correct, but weak\n```\n\n----------------------------------------\n\nTITLE: Comparing Projection Initializers in Anonymous Types and Tuples in C#\nDESCRIPTION: Shows the difference in behavior between anonymous types and tuples for projection initializers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvar a = new { Name = c.FirstName, c.Age }; // Will have members Name and Age\nvar t = (Name: c.FirstName, c.Age); // (string Name, int Age) or error?\n```\n\n----------------------------------------\n\nTITLE: Prefix-Based String Interpolation Syntax in C#\nDESCRIPTION: The adopted string interpolation syntax using a $ prefix to indicate interpolation, with expressions in curly braces. This approach allows for easy identification of interpolated strings and potential future extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-21.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n$\"Hello, {name}, you have {amount} donut\\{s\\} left.\"\n```\n\n----------------------------------------\n\nTITLE: Null-Coalescing Assignment Operator Result Type Example\nDESCRIPTION: Example demonstrating how the ??= operator's result type is based on the result of the ?? operator rather than the assignment target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-15.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nint? b = null;\nvar c = b ??= 5;\n// b is int?\n// c is int\n```\n\n----------------------------------------\n\nTITLE: Using handleof keyword for runtime handles in C#\nDESCRIPTION: This snippet demonstrates the use of the proposed handleof contextual keyword to obtain RuntimeHandle objects for types at runtime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intrinsics.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nRuntimeHandle stringHandle = handleof(string);\n```\n\n----------------------------------------\n\nTITLE: Fixed Size Buffer Type Examples in C#\nDESCRIPTION: Code references showing potential fixed size buffer type declarations mentioned in the discussion, including Span<T>, ReadOnlySpan<T>, and hypothetical array notation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-04-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nList<int[4]>\\nList<int[TSize]>\n```\n\n----------------------------------------\n\nTITLE: Approach B2: As-If Transformation (C#)\nDESCRIPTION: Illustrates an as-if transformation showing how accessors are treated as local functions for precise NRT analysis. This includes simulating calls to the getter/setter after the constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n\"public C()\\n{\\n    T? _field = default;\\n    _field = optional_initializer; // if present\\n\\n    // ... constructor statements ...\\n    // ... any calls to this.Prop become calls to Prop_get and Prop_set ...\\n\\n    while (true)\\n    {\\n        if (rand())\\n            Prop_get();\\n        else\\n            Prop_set(...non-null-value...)\\n    }\\n\\n    T Prop_get() { ...getter body... }\\n    void Prop_set(T value) { ...setter body... }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Equality Operator Error in Pre-C# 7.2\nDESCRIPTION: Example of the error produced when attempting to use equality operators on tuple types before C# 7.2, which results in CS0019 because the operator cannot be applied to tuple operands.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/tuple-equality.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nerror CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'\n```\n\n----------------------------------------\n\nTITLE: Applying Attributes to Extension Type Members in C#\nDESCRIPTION: Demonstrates how to apply attributes to extension type members using the new 'this' attribute target. This allows for specifying attributes on the receiver, similar to classic extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Compatibility through coexistence between extension types and extension methods.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[this:NotNullWhen(false)] public bool IsNullOrEmpty() { ... }\n```\n\n----------------------------------------\n\nTITLE: Extension Declaration Merging in C#\nDESCRIPTION: This code snippet illustrates how extension declarations with equivalent type parameters and constraints are merged into a single static class.  This reduces the number of generated nested classes within an enclosing static class. Equivalent constraints mean that even if underlying types, ref-kinds, or type parameter names differ, they can be merged.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npublic static class MyExtensions\n{\n    extension<TSource>(Span<TSource>) where TSource : class?\n    {\n        ...\n    }\n    extension<TElement>(Span<TElement?>) where TElement : class\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Solution for Repeating Non-AllowMultiple Attributes in C#\nDESCRIPTION: This code demonstrates the proposed solution, allowing non-AllowMultiple attributes to be repeated on each partial declaration with identical arguments. The compiler would de-duplicate these attributes during emission.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/repeated-attributes.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic partial bool TryGetValue([NotNullWhen(true)] out object? value);\npublic partial bool TryGetValue([NotNullWhen(true)] out object? value) { ... } // ok\n\n// equivalent to:\npublic bool TryGetValue([NotNullWhen(true)] out object value) { ... }\n\n// error when attribute arguments do not match\npublic partial bool TryGetValue([NotNullWhen(true)] out object? value);\npublic partial bool TryGetValue([NotNullWhen(false)] out object? value) { ... } // error\n```\n\n----------------------------------------\n\nTITLE: Extending C# Grammar for Fixed-Size Buffer Declarations\nDESCRIPTION: This code snippet shows the proposed grammar changes to support fixed-size buffer declarations in C#. It extends the existing field declaration syntax to allow specifying buffer sizes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_14\n\nLANGUAGE: ANTLR\nCODE:\n```\nfield_declaration\n    : attributes? field_modifier* type variable_declarators ';'\n    ;\n\nfield_modifier\n    : 'new'\n    | 'public'\n    | 'protected'\n    | 'internal'\n    | 'private'\n    | 'static'\n    | 'readonly'\n    | 'volatile'\n    | unsafe_modifier   // unsafe code support\n    ;\n\nvariable_declarators\n    : variable_declarator (',' variable_declarator)*\n    ;\n    \nvariable_declarator\n    : identifier ('=' variable_initializer)?\n   | fixed_size_buffer_declarator\n    ;\n    \nfixed_size_buffer_declarator\n    : identifier '[' constant_expression ']'\n    ;    \n```\n\n----------------------------------------\n\nTITLE: Breaking Changes When 'field' is a Keyword in Primary Expressions in C#\nDESCRIPTION: Shows examples of breaking changes when 'field' is treated as a keyword only in primary expression position, affecting unqualified member access and nested functions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyClass\n{\n    private int field;\n    public int P => field; // binds to synthesized backing field rather than 'this.field'\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyClass\n{\n    private IEnumerable<string> _fields;\n    public bool HasNotNullField\n    {\n        get => _fields.Any(field => field is { }); // 'field' binds to synthesized backing field\n    }\n    public IEnumerable<string> Fields\n    {\n        get { return _fields; }\n        set { _fields = value.Where(value => Filter(value)); } // 'value' binds to setter parameter\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for null ref in C#\nDESCRIPTION: Example of using the Unsafe.IsNullRef method to check for null refs in structs. The discussion notes that this feels unnatural for safe C# code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-09-23.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nUnsafe.IsNullRef(refField)\n```\n\n----------------------------------------\n\nTITLE: Inferrability Requirement in C# Compat Mode\nDESCRIPTION: This code snippet demonstrates that in compat mode, the inferrability requirement is waived, allowing type parameters to occur on the extension declaration itself without occurring in the receiver type. This permits certain classic extension methods to be ported to the new syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/compat-mode-in-extensions.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static class E\n{\n    public static IEnumerable<TResult> Select1<TResult, TSource>(this IEnumerable<TSource> source, Func<TSource, TResult> selector) { ... }\n    extension<TResult, TSource>(this IEnumerable<TSource> source) // TResult not used\n    {\n        public static IEnumerable<TResult> Select2(Func<TSource, TResult> selector) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ECMA-335 CallKind Grammar Definition in ANTLR\nDESCRIPTION: Defines the grammar for CallKind flags in method signatures, specifying supported calling conventions for function pointers in metadata.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_7\n\nLANGUAGE: antlr\nCODE:\n```\nCallKind\n   : default\n   | unmanaged cdecl\n   | unmanaged fastcall\n   | unmanaged thiscall\n   | unmanaged stdcall\n   | varargs\n   ;\n```\n\n----------------------------------------\n\nTITLE: Approach A1: Nullable Warning Suppression (C#)\nDESCRIPTION: An example of how to suppress the warnings that occur when the field might be null at access time, even when the declared property is not nullable.  This requires developer action to eliminate the warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n\"string Prop { get => field ??= ComputeInitialValue(); } = null!; // or\\n\\n// in constructor:\\nthis.Prop = null!;\"\n```\n\n----------------------------------------\n\nTITLE: Extension Method for Collection Literals\nDESCRIPTION: Shows a potential extension method approach for transforming collection literals with type inference\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-26.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class Extensions\n{\n    public static ImmutableArray<T> AsImmutableArray<T>(this ImmutableArray<T> array) => array;\n}\n\nvoid M()\n{\n    var v = [complex, type, examples].AsImmutableArray();\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Initializer Syntax for Object Creation\nDESCRIPTION: Example of the new dictionary initializer syntax that allows setting indexed values during object creation using square brackets.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-12-16.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nvar payload = new JsonObject\n{\n    [\"first name\"] = \"Donald\",\n    [\"last name\"] = \"Duck\",\n    $city = \"Duckburg\" // equivalent to [\"city\"] = \"Duckburg\"\n};\n```\n\n----------------------------------------\n\nTITLE: Using Statement with Type Parameter Constraints\nDESCRIPTION: Shows usage of using statement with a type parameter that allows ref struct and implements IDisposable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    static void Test<T>(T t) where T : System.IDisposable, allows ref struct\n    {\n        using (t)\n        {\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Override Examples in C#\nDESCRIPTION: Shows explicit and implicit interface member override syntax examples, demonstrating how interface inheritance could work with default implementations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-21.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M(); }\ninterface I2 : I1 { override void I1.M() { ... } } // \"explicit\" override\ninterface I3 : I1 { override void M() { ... } }    // \"implicit\" override\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constant Pattern Semantics in C#\nDESCRIPTION: This snippet shows the current and proposed semantics for constant patterns in 'is' expressions. The change involves switching the order of arguments in the object.Equals call to improve consistency and behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-17.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ne is 42\n```\n\n----------------------------------------\n\nTITLE: Option 1: Stack Allocation Only for Local-Scoped Targets in C#\nDESCRIPTION: Demonstrates a potential approach where collection expressions are stack-allocated only when the target is explicitly local-scoped.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> x1 = [a, b, c];        // heap allocated, global scope.\nscoped ReadonlySpan<int> x2 = [a, b, c]; // stack allocated, local scope.\n\n// Less likely, but shown for completeness:\nReadOnlySpan<int> x3 = stackalloc int[] { d, e, f }; // stack allocated, local scope.\nx3 = [g, h, i];                                      // stack allocated.\n```\n\n----------------------------------------\n\nTITLE: Natural Type Inference Example for Dictionary-Like Collections in C#\nDESCRIPTION: This code demonstrates how natural type inference works with the new dictionary-like syntax in collection expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<string, object> d1 = ...;\nDictionary<object, string> d2 = ...;\nvar d3 = [..d1, ..d2];\n```\n\n----------------------------------------\n\nTITLE: Code Reference - C# Span Implementation\nDESCRIPTION: Reference to Span<T> and ReadOnlySpan<T> implementation concepts discussed in relation to IEnumerable<T> interface implementation challenges.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nref struct Span<T>\n{\n    // Cannot implement IEnumerable<T> due to allocation constraints\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Match Expression in C#\nDESCRIPTION: Demonstrates the use of a match expression for pattern matching in C# 7. This feature provides a more functional-style approach to type checking and conditional logic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-11-02-Design-Demo.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic string PrintedForm(Person p) => p match (\n    case Student s when s.Gpa > 3.5 :\n        $\"Honor Student {s.Name} ({s.Gpa})\"\n    case Student { Name is \"Poindexter\" } :\n        \"A Nerd\"\n    case Student s :\n        $\"Student {s.Name} ({s.Gpa})\"\n    case Teacher t :\n        $\"Teacher {t.Name} of {t.Subject}\"\n    case null :\n        throw new ArgumentNullException(nameof(p))\n    case * :\n        $\"Person {p.Name}\"\n);\n```\n\n----------------------------------------\n\nTITLE: Invalid Usage of Default Keyword with Operators in C#\nDESCRIPTION: Demonstrates how using the 'default' keyword with operators can lead to inconsistent behavior and potential future compatibility issues. This usage will not be allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-31.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvar a = default + default;  // error\nvar b = default - default;  // ok\nvar c = default * default;  // ok\nvar d = default / default;  // error\n```\n\n----------------------------------------\n\nTITLE: Using Partial Events and Constructors for Interop Code in C#\nDESCRIPTION: Example of using partial events and constructors for generating interop code, showing user-defined declarations and generated bindings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/partial-events-and-constructors.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npartial class AVAudioCompressedBuffer : AVAudioBuffer\n{\n    [Export(\"initWithFormat:packetCapacity:\")]\n    public partial AVAudioCompressedBuffer(AVAudioFormat format, uint packetCapacity);\n\n    [Export(\"create:\")]\n    public partial event EventHandler Created;\n}\n\npartial class AVAudioCompressedBuffer : AVAudioBuffer\n{\n    [BindingImpl(BindingImplOptions.GeneratedCode | BindingImplOptions.Optimizable)]\n    public partial AVAudioCompressedBuffer(AVAudioFormat format, uint packetCapacity) : base(NSObjectFlag.Empty)\n    {\n        // Call Objective-C runtime:\n        InitializeHandle(\n            global::ObjCRuntime.NativeHandle_objc_msgSendSuper_NativeHandle_UInt32(\n                this.SuperHandle,\n                Selector.GetHandle(\"initWithFormat:packetCapacity:\"),\n                format.GetNonNullHandle(nameof(format)),\n                packetCapacity),\n            \"initWithFormat:packetCapacity:\");\n    }\n\n    public partial event EventHandler Created\n    {\n        add { /* ... */ }\n        remove { /* ... */ }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Current Valid Lambda Parameter Declaration in C#\nDESCRIPTION: Example of the current valid syntax for lambda parameter declarations, including explicit type names.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/simple-lambda-parameters-with-modifiers.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nTryParse<int> parse2 = (string text, out int result) => Int32.TryParse(text, out result);\n```\n\n----------------------------------------\n\nTITLE: Defining Tracked Expression Grammar in ANTLR\nDESCRIPTION: ANTLR grammar rules defining the syntax for expressions that can be null-tracked, including variables and property access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_5\n\nLANGUAGE: antlr\nCODE:\n```\ntracked_expression\n    : simple_name\n    | this\n    | base\n    | tracked_expression '.' identifier\n    ;\n```\n\n----------------------------------------\n\nTITLE: Generic Lambda Syntax Example in C#\nDESCRIPTION: Shows potential syntax for generic lambda expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvar f = <T>(IEnumerable<T> src) => src.FirstOrDefault(); // Is this unambiguous? What's the delegate type?\n```\n\n----------------------------------------\n\nTITLE: Nullable Value Type Operations with Return Expression Example\nDESCRIPTION: Examples comparing different approaches to handling nullable value types, demonstrating how return expressions could simplify null checking patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint z = x + y ?? return null; // where x and y are of type int?\n\n//as opposed to something like\nif (x is null || y is null) return null;\nint z = (x + y).Value; // explicit unpacking\n\n// or\nint? nz = x + y;\nif (nz is null) return null;\nint z = nz ?? 0; // dummy unpacking\n\n// or using patterns\nif (!(x + y is int z)) return null;\n```\n\n----------------------------------------\n\nTITLE: Struct Definite Assignment Examples in C#\nDESCRIPTION: These examples illustrate definite assignment rules within structs. The compiler enforces that all fields are definitely assigned within constructors that do not chain to another constructor using `this()`. Field initializers can contribute to definite assignment.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n\"struct S0 // ok\\n{\\n    int x;\\n    object y;\\n}\\n\\nstruct S1 // error: 'struct' with field initializers must include an explicitly declared constructor\\n{\\n    int x = 1;\\n    object y;\\n}\\n\\nstruct S2\\n{\\n    int x = 1;\\n    object y;\\n    public S2() { } // error in C# 10 (valid starting in C# 11): field 'y' must be assigned\\n}\\n\\nstruct S3 // ok\\n{\\n    int x = 1;\\n    object y;\\n    public S3() { y = 2; }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Creating Spans from Inline Arrays in C#\nDESCRIPTION: Code that demonstrates how the compiler creates Span instances from inline array types. This provides type-safe access to the elements using MemoryMarshal helper methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nMemoryMarshal.CreateSpan(ref Unsafe.As<TBuffer, TElement>(ref buffer), size);\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Overloads Between Span and IEnumerable Example in C#\nDESCRIPTION: Example showing ambiguous method call resolution between ReadOnlySpan<T> and IEnumerable<T> overloads when using array and string arguments. The ImmutableArray.CreateRange method has two overloads that create ambiguity when passing certain types that are convertible to both interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-06-19.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar ia1 = ImmutableArray.CreateRange<int>(new[] { 1, 2, 3 }); // error: CreateRange() is ambiguous\nvar ia2 = ImmutableArray.CreateRange<char>(\"Test\"); // error: CreateRange() is ambiguous\n\npublic static class ImmutableArray\n{\n    public static ImmutableArray<T> CreateRange<T>(IEnumerable<T> items) { ... }\n    public static ImmutableArray<T> CreateRange<T>(ReadOnlySpan<T> items) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Conversions Between Constructed Types with Different Nullability in C#\nDESCRIPTION: Shows an example of conversions between constructed types that differ in the nullability of their type arguments. This demonstrates the potential for warnings in both directions of the conversion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-14.md#2025-04-23_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, string?> d = new Dictionary<string?, string>(); // warning in both directions\n```\n\n----------------------------------------\n\nTITLE: Explicit Coercion from Ad Hoc Union in C#\nDESCRIPTION: Demonstrates explicit coercion from an ad hoc union to a type when at least one member type is coercible to the target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n(string or double) value = 10.0;\nint value2 = (int)value;\n```\n\n----------------------------------------\n\nTITLE: Definition of OverloadResolutionPriorityAttribute in C#\nDESCRIPTION: The implementation of the OverloadResolutionPriorityAttribute class in the System.Runtime.CompilerServices namespace, which accepts a priority integer value and can be applied to methods, constructors, and properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/overload-resolution-priority.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices;\n\n[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]\npublic sealed class OverloadResolutionPriorityAttribute(int priority) : Attribute\n{\n    public int Priority => priority;\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Warning Behavior Change\nDESCRIPTION: Demonstrates the suggested approach to warning placement in base and override scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-parameter-default-value-analysis.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Base<T>\n{\n    public virtual void M(T t = default) { } // let's start warning here\n}\n\npublic class Override : Base<string>\n{\n    public override void M(string s)\n    {\n        s.ToString(); // let's not warn here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Generic List Element in C#\nDESCRIPTION: Example of accessing the first element of a generic List and calling a method on it. This snippet is used to illustrate a potential semantic dark corner in a proposed language feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-11-06.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nList<>.First.Foo\n```\n\n----------------------------------------\n\nTITLE: Demonstrating existing pointer support in ternary expressions\nDESCRIPTION: This snippet shows how pointers are currently supported in ternary expressions, which is used as a justification for extending null-coalescing operators to pointers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/pointer-null-coalescing.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nT *foo = bar != null ? bar : baz;\n```\n\n----------------------------------------\n\nTITLE: Field Shadowing Rules Example\nDESCRIPTION: Illustrates the decision that the 'field' keyword can be shadowed by parameters or locals in nested scopes, similar to how regular fields can be shadowed in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-16.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Example {\n    private int field; // Regular field can be shadowed\n    public void Method(int field) { // Parameter shadows field\n        int field = 0; // Local shadows parameter\n        this.field = field; // Using this. to access class field\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Potential Breaking Changes with Natural Collection Types in C#\nDESCRIPTION: Examples illustrating potential breaking changes when using natural collection types, affecting conversions and type inference in overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-inferred-type.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nbool b = true;\nList<int> x = [1, 2, 3];\nvar y = b ? x : [4]; // y: previously List<int>, now IEnumerable<int>\n```\n\nLANGUAGE: csharp\nCODE:\n```\nLog([1, 2, 3]); // previously Log<T>(IEnumerable<T>), now ambiguous\n\nvoid Log<T>(T item) { ... }\nvoid Log<T>(IEnumerable<T> items) { ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Resolution in Implicit Extensions in C#\nDESCRIPTION: This code shows a scenario where method resolution becomes ambiguous due to overloading in base and derived implicit extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension Base for object \n{\n    void M(int i) { }\n}\nimplicit extension Derived for object : Base\n{\n    void M(double d) { }\n}\n\nobject o = ...;\no.M(1); // Which does it pick?\n```\n\n----------------------------------------\n\nTITLE: Base Call Syntax Options for Primary Constructors in C#\nDESCRIPTION: Presents two accepted syntaxes for specifying base constructor calls in classes with primary constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-27.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nclass TypeName(int X, int Y) : BaseType(X, Y);\n```\n\nLANGUAGE: C#\nCODE:\n```\nclass TypeName(int X, int Y) : BaseType\n{\n    public TypeName : base(X, Y) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating No Transparency Support for KeyValuePair in C# Collection Expressions\nDESCRIPTION: This snippet shows how KeyValuePair would be handled without any special transparency support, requiring explicit conversions for type safety.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nKeyValuePair<string, int> kvp = new(\"mads\", 21);\nDictionary<object, int?> map1 = [kvp]; // illegal.  user must write:\nDictionary<object, int?> map1 = [kvp.Key: kvp.Value];\n\nDictionary<object, int?> map1 = [.. nameToAge, otherMap.Single(predicate)]; // illegal.  user must write:\n\nvar temp = otherMap.Single(predicate);\nDictionary<object, int?> map1 = [.. nameToAge.Select(kvp => new KeyValuePair<object, int?>(kvp.Key, kvp.Value)), temp.Key: temp.Value];\n```\n\n----------------------------------------\n\nTITLE: Null-Propagating Operator with Unconstrained Generics in C#\nDESCRIPTION: Demonstrates the use of the null-propagating operator with unconstrained generics. This snippet shows a scenario where the behavior is ambiguous due to the unknown type of Y.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-10.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nvar result = x?.Y;\n```\n\n----------------------------------------\n\nTITLE: Null Conditional Access Increment/Decrement Operator Limitation\nDESCRIPTION: Proposal to disallow prefix and postfix increment/decrement operators with null conditional access to prevent potential unexpected behavior. Developers are recommended to use compound assignments instead.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-28.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Example of not allowed operation\nint? value = null;\nvalue++; // Disallowed\n\n// Recommended alternative\nvalue = (value ?? 0) + 1;\n```\n\n----------------------------------------\n\nTITLE: Initializing IList<T> Property with Collection Expression in C#\nDESCRIPTION: Example of using a collection expression to initialize an IList<T> property. This shows the need for collection expression support with mutable interface types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nclass Order\n{\n    // Intended to be mutated.\n    public IList<OrderId> ProductIds { get; } = [];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing UI Page State Management in C#\nDESCRIPTION: This code demonstrates a UI app scenario with different page states and state-specific fields. It shows how discriminated unions could improve the current enum-based approach by removing the need for a default case and potentially allowing for more OOP-like state behaviors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-10-19.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic enum PageState\n{\n    NotLoaded,\n    Loading,\n    Loaded,\n    Errored\n}\n\npublic class Page {\n    PageState state;\n    \n    // used when state is Loaded\n    PageData data;\n    \n    // used when state is Errored\n    string errorMessage;\n    \n    \n    public View Render() {\n        switch (this.state)\n        {\n            case PageState.NotLoaded:\n                return ShowLoadButton();\n            case PageState.Loading:\n                return ShowLoadingSpinner();\n            case PageState.Loaded:\n                return ShowData(this.data!);\n            case PageState.Errored:\n                return ShowErrorMessage(this.errorMessage);\n            default:\n                throw Unreachable;\n        }\n    }\n}\n\nclass PageData { }\n\nclass View { }\n```\n\n----------------------------------------\n\nTITLE: Complex Interpolation with Nested Braces in C#\nDESCRIPTION: This example demonstrates how nested braces work in interpolated raw string literals. The inner two pairs of braces belong to the interpolation, while the outer single braces are treated as content.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nvar v1 = $$\"\"\"X{{{1+1}}}Z\"\"\";\n```\n\n----------------------------------------\n\nTITLE: Metadata Call Instructions Reference\nDESCRIPTION: Reference to metadata call instructions used in method signatures, discussing how modreqs affect encoded signatures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-28.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ncall\ncallvirt\n```\n\n----------------------------------------\n\nTITLE: Zero-Allocation Params Implementation in C#\nDESCRIPTION: Shows how the compiler can implement zero-allocation params using Variant2 and Variant3 types. This approach allows for efficient handling of up to three Variant arguments without heap allocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/format.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class ZeroAllocation {\n    static void Use(params Span<Variant> spans) {\n        ...\n    }\n\n    static void Go() {\n        Use(\"hello\", \"world\");\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class ZeroAllocation {\n    static void Go() {\n        Variant2 _v;\n        _v.Variant1 = new Variant(\"hello\");\n        _v.Variant2 = new Variant(\"word\");\n        Use(_v.CreateSpan());\n        _v.KeepAlive();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Attribute Union on Partial Methods in C#\nDESCRIPTION: This snippet shows how attributes are currently combined across partial method declarations. The method M has both attributes A and B applied.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/repeated-attributes.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[A]\npartial void M();\n\n[B]\npartial void M() { }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Declaration Expression Syntax in C#\nDESCRIPTION: Example of proposed syntax for declaration expressions, allowing variable declaration and initialization within an expression context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/expressions-statements/ES-2022-11-30.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n(var x = 1).ToString()\n```\n\n----------------------------------------\n\nTITLE: Razor Source Generation Example with #line Directive\nDESCRIPTION: Demonstrates how enhanced #line directives can map precise source locations in generated code for Razor templates\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/enhanced-line-directives.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n#line hidden\nvoid Render()\n{\n   _builder.Add(\"Time:\");\n#line 2 \"page.razor\"\n   _builder.Add(DateTime.Now);\n#line hidden\n}\n```\n\n----------------------------------------\n\nTITLE: API Design Patterns Comparison\nDESCRIPTION: Contrasts the current undesirable method-based approach with the desired property-based indexer approach for better API design.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/readonly-setter-calls-on-non-variables.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// Undesirable:\nc.SetXyz(\"key\", c.GetXyz(\"key\") + 1);\n\n// Desirable:\nc.Xyz[\"key\"]++;\n```\n\n----------------------------------------\n\nTITLE: C# Grammar Definition for Local Functions with Attributes\nDESCRIPTION: Modified grammar specification for local functions to support attributes and extern modifier. Defines the syntax structure for local function headers, modifiers, and function bodies including support for attributes and external implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/local-function-attributes.md#2025-04-21_snippet_0\n\nLANGUAGE: grammar\nCODE:\n```\nlocal-function-header\n    : attributes? local-function-modifiers? return-type identifier type-parameter-list?\n        ( formal-parameter-list? ) type-parameter-constraints-clauses\n    ;\n\nlocal-function-modifiers\n    : (async | unsafe | static | extern)*\n    ;\n\nlocal-function-body\n    : block\n    | arrow-expression-body\n    | ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Function Pointers Using Existing Delegate Types in C#\nDESCRIPTION: This code presents an alternative syntax for function pointers that uses existing delegate types with a * suffix. It demonstrates how to declare a function pointer to a static method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nFunc<object, object, bool>* ptr = &object.ReferenceEquals;\n```\n\n----------------------------------------\n\nTITLE: Method with Contract Syntax in C#\nDESCRIPTION: Shows a proposed syntax for specifying method contracts directly in C# code. This includes preconditions (requires) and postconditions (ensures) that could be enforced at runtime or used for static analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\npublic void Remove(string item)\n    requires item != null\n    ensures Count >= 0\n{\n   ...\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Nullability Attributes Example\nDESCRIPTION: Example showing potential nested member reference syntax for nullability attributes on complex types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-05.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nclass Point\n{\n    public object? X;\n}\nclass Line\n{\n    public Point P1;\n    public Point P2;\n}\nstatic void M([EnsuresNotNull(\"P1.X\", \"P1.Y\")]Line l) { ... }\nstatic bool M([EnsuresNotNullWhen(true, \"P1.X\", \"P1.Y\")]Line l) { ... }\n```\n\n----------------------------------------\n\nTITLE: Optimized Params Implementation\nDESCRIPTION: Shows how the compiler could transform params calls to use a single shared array with different Span windows, reducing allocations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/format.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    static void Go() {\n        var args = new string[3];\n        args[0] = \"jaredpar\";\n        Use(new Span<string>(args, start: 0, length: 1));\n\n        args[0] = \"hello\";\n        args[1] = \"world\";\n        Use(new Span<string>(args, start: 0, length: 2));\n\n        args[0] = \"a\";\n        args[1] = \"longer\";\n        args[2] = \"set\";\n        Use(new Span<string>(args, start: 0, length: 3));\n   }\n```\n\n----------------------------------------\n\nTITLE: Grammar Changes for Unsafe Contexts in Using Alias Directives\nDESCRIPTION: Proposed grammar modification to add an optional 'unsafe' keyword to using alias directives and using static directives to support pointer types in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/using-alias-types.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nusing_alias_directive\n+    : 'using' 'unsafe'? identifier '=' (namespace_name | type) ';'\n    ;\n    \nusing_static_directive\n+    : 'using' 'static' 'unsafe'? type_name ';'\n    ;\n\n+ 'unsafe' can only be used with an using_alias_directive or using_static_directive, not a using_directive.\n+ The 'unsafe' keyword present in a 'using_alias_directive' causes the entire textual extent of the 'type' portion (not the 'namespace_name' portion) to become an unsafe context. \n+ The 'unsafe' keyword present in a 'using_static_directive' causes the entire textual extent of the 'type_name' portion to become an unsafe context.\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Definition for Enum Class\nDESCRIPTION: Formal grammar specification for enum class syntax in ANTLR notation, defining the structure and allowed patterns for enum class declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/discriminated-unions.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nenum_class\n    : 'partial'? 'enum class' identifier type_parameter_list? type_parameter_constraints_clause* \n      '{' enum_class_body '}'\n    ;\n\nenum_class_body\n    : enum_class_cases?\n    | enum_class_cases ','\n    ;\n\nenum_class_cases\n    : enum_class_case\n    | enum_class_case ',' enum_class_cases\n    ;\n\nenum_class_case\n    : enum_class\n    | class_declaration\n    | identifier type_parameter_list? '(' formal_parameter_list? ')'\n    | identifier\n    ;\n```\n\n----------------------------------------\n\nTITLE: Initializing Readonly Local Variable in C#\nDESCRIPTION: Demonstrates how to declare and initialize a readonly local variable. The compiler ensures it can only be set at the time of declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/readonly-locals.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly long maxBytesToDelete = (stream.LimitBytes - stream.MaxBytes) / 10;\n...\nmaxBytesToDelete = 0; // Error: can't assign to readonly locals outside of declaration\n```\n\n----------------------------------------\n\nTITLE: LINQ Query Syntax with Nullable Types\nDESCRIPTION: This C# code snippet showcases the equivalent scenario using query syntax.  In the first example, it suppresses nullable warnings that we would expect. The query variable has oblivious nullability and its state is not tracked across operations in the query. The second example demonstrates that the compiler does not provide any warnings when it should. This indicates an inconsistency between call-chaining and query syntax in handling nullable types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-01.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<Widget> M(IEnumerable<string?> items)\n{\n    return from i in items\n        where i != null\n        select Widget.Parse(i); // ok\n}\n\nIEnumerable<Widget> M(IEnumerable<string?> items)\n{\n    return from i in items\n        select Widget.Parse(i); // should warn, but doesn't\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Tuple Element Reordering Warning in C#\nDESCRIPTION: This snippet demonstrates a case where a warning could be useful to catch accidental reordering of tuple elements. The warning is not currently implemented but could be added in the future.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-15.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n(string firstName, string lastName) GetName();\n\n(string lastName, string firstName) name = GetName(); // Oops, forgot to swap the element names in name?\n```\n\n----------------------------------------\n\nTITLE: Extending Multiple Types with Shared Code in C#\nDESCRIPTION: Demonstrates a scenario where extension methods might be preferred over extension types, allowing shared code to extend multiple types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-2023-02-21.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(this OneType one)\nvoid M(this OtherType other)\n```\n\n----------------------------------------\n\nTITLE: Type Argument Inference for Classic and New Extension Methods in C#\nDESCRIPTION: This segment discusses how type arguments in classic extension methods must correspond to all type parameters, while new extension methods allow type parameters to be inferred from the receiver. It illustrates this with a call to the Select method and how different type parameters are handled.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/implicit-compatibility-for-ported-extension-methods.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension<TSource>(IEnumerable<TSource> source)\n    {\n        public IEnumerable<TSource> Select<TResult>(Func<TSource, TResult> selector)  { ... }\n    }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\nmyList.Select<int, string>(...)\nmyList.Select<string>(...)\n```\n\n----------------------------------------\n\nTITLE: Break Expression Syntax Alternative - C#\nDESCRIPTION: Alternative syntax proposal using 'break' statement to return values from block expressions, demonstrating how values could be produced explicitly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-22.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar x = { break 3; };\n```\n\n----------------------------------------\n\nTITLE: Fixed Buffer Struct Example in C#\nDESCRIPTION: Example showing potential multi-dimensional fixed buffer syntax in a struct declaration, demonstrating a considered but not implemented feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\nstruct Dimensions\n{\n    int array[42, 13];\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Constraints with Tuple Names\nDESCRIPTION: Examples showing various scenarios of tuple name conflicts in generic constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-05.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nclass C<U> where U : I<(int a, int b)>, I<(int notA, int notB)> // this is currently allowed, and would become an error\n\nclass C<U> where U : I<(int a, int b)>, I2 // where I2 implements I<(int notA, int notB)>\n\nclass C<U, T> where U : I<(int a, int b)>, I2<T> // where I2 implements I<(T notA, T notB)>\n```\n\n----------------------------------------\n\nTITLE: Raw String with Double Quotes\nDESCRIPTION: Example of a raw string literal with content starting and ending with double quotes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n         \"\"The content of this string starts and ends with two quotes\"\"\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Encoding Roles in Metadata with Modopt in C#\nDESCRIPTION: This snippet explores using `modopt` to encode roles in metadata. It discusses the benefits and downsides of this approach, including the need for call sites to spell out the entire signature, potentially leading to breaking changes and the possibility of overloading on role types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nRole<T> M<T>(Role<T> role)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nmodopt(Role<T>) UnderlyingType M<T>(modopt(Role<T>) UnderlyingType role)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(UnderlyingType underlying) { }\nvoid M(MyRole role) { }\n```\n\n----------------------------------------\n\nTITLE: Traditional Left Join Implementation\nDESCRIPTION: Shows the current way to implement left joins using GroupJoin and DefaultIfEmpty in query syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar query =\n    from student in students\n    join department in departments on student.DepartmentID equals department.ID into gj\n    from subgroup in gj.DefaultIfEmpty()\n    select new\n    {\n        student.FirstName,\n        student.LastName,\n        Department = subgroup?.Name ?? string.Empty\n    };\n```\n\n----------------------------------------\n\nTITLE: Tuple Declaration Syntax Approaches\nDESCRIPTION: Alternative syntax approaches for tuple deconstruction with type declarations, showing both 'types-with-variables' and 'types-apart' styles.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n// Types-with-variables:\n(string first, string last) = GetName(); // Types specified\n(var first, var last) = GetName();       // Types inferred\nvar (first, last) = GetName();           // Optional shorthand for all var\n```\n\nLANGUAGE: c#\nCODE:\n```\n// Types-apart:\n(string, string) (first, last) = GetName(); // Types specified\nvar (first, last) = GetName();              // All types inferred\n(var, var) (first, last) = GetName();       // Optional long hand for types inferred\n```\n\n----------------------------------------\n\nTITLE: FormattedString Implementation\nDESCRIPTION: System.Runtime.CompilerServices implementation for handling IFormattable conversion of interpolated strings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices \n{ \n    public class FormattedString : System.IFormattable \n    {\n        private readonly String format;\n        private readonly object[] args;\n        public FormattedString(String format, params object[] args)\n        {\n            this.format = format;\n            this.args = args;\n        }\n        string IFormattable.ToString(string ignored, IFormatProvider formatProvider)\n        {\n            return String.Format(formatProvider, format, args);\n        }\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Or Operator and Type Inference in C#\nDESCRIPTION: Example showing type inference challenges with or patterns and var declarations\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-08.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nobject o = 1;\nif (o is (1 or 3L) and var x)\n    // what is the type of `x`?\n```\n\n----------------------------------------\n\nTITLE: Method Group Conversion with Span Types in C#\nDESCRIPTION: Shows how method group conversion behavior is preserved when dealing with Span extension methods to maintain backward compatibility. The example demonstrates delegate creation from extension methods with different receiver types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\nAction<int> a = new int[0].M; // binds to M<int>(IEnumerable<int>, int)\nstatic class E\n{\n    public static void M<T>(this Span<T> s, T x) => Console.Write(1);\n    public static void M<T>(this IEnumerable<T> e, T x) => Console.Write(2);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Fixed Size Buffer in C#\nDESCRIPTION: Example of declaring a safe fixed-sized buffer using the proposed syntax. Shows a simple declaration for a buffer of DXGI_RGB type with 1025 elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/fixed-sized-buffers.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic fixed DXGI_RGB GammaCurve[1025];\n```\n\n----------------------------------------\n\nTITLE: Collection Expression Order Example - C#\nDESCRIPTION: Example demonstrating the guaranteed evaluation order of collection expressions in C#, showing how increment operations must be evaluated left-to-right.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-09-25.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[i++, i++, i++]\n```\n\n----------------------------------------\n\nTITLE: Var Usage in Tuple Types\nDESCRIPTION: Shows the limitation of var usage in tuple declarations versus deconstruction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-13.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n(var x, var y) = GetTuple(); // works\n(var x, var y) t = GetTuple(): // should it work?\n```\n\n----------------------------------------\n\nTITLE: Extension Declarations with Type Parameters\nDESCRIPTION: Examples of extension declarations with different receiver specifications and type parameters\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable source)\n    {\n        public bool IsEmpty { get { ... } }\n    }\n    extension<TSource>(IEnumerable<TSource> source)\n    {\n        public IEnumerable<T> Where(Func<TSource, bool> predicate) { ... }\n        public IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector) { ... }\n    }\n    extension<TElement>(IEnumerable<TElement>)\n        where TElement : INumber<TElement>\n    {\n        public static IEnumerable<TElement> operator +(IEnumerable<TElement> first, IEnumerable<TElement> second) { ... }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Where T : struct Generic Constraint Example\nDESCRIPTION: Code constraint example mentioned in discussion about record structs and generic contexts. This pattern was discussed when considering how to handle customized 'with' semantics.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-01-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nwhere T : struct\n```\n\n----------------------------------------\n\nTITLE: Expression Span Example with Comments\nDESCRIPTION: Illustrates how CallerArgumentExpression handles expressions with surrounding comments and whitespace.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-14.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nM(arg1: /* Before */ \"A\" + /* Mid */ \"B\"\n /* After */); // What is passed for arg2?\n```\n\n----------------------------------------\n\nTITLE: Defining Role with Underlying Interface in C#\nDESCRIPTION: This is an example of defining a role using an underlying interface, showcasing various combinations that can lead to confusion over required specifications.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-02-15.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nrole R : IUnderlyingInterface, Interface1, Interface2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Improved Best Common Type Inference in C#\nDESCRIPTION: Example showing how the ternary operator should handle null and integer types to produce nullable int result instead of an error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-04-19.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nb ? null : 7 // should be int? not error\n```\n\n----------------------------------------\n\nTITLE: Existing Async Method Compilation Example\nDESCRIPTION: Demonstrates the current compiler-generated code for an async method returning a ValueTask<T>\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/async-method-builders.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic async ValueTask<T> ExampleAsync() { ... }\n```\n\nLANGUAGE: C#\nCODE:\n```\n[AsyncStateMachine(typeof(<ExampleAsync>d__29))]\n[CompilerGenerated]\nstatic ValueTask<int> ExampleAsync()\n{\n    <ExampleAsync>d__29 stateMachine;\n    stateMachine.<>t__builder = AsyncValueTaskMethodBuilder<int>.Create();\n    stateMachine.<>1__state = -1;\n    stateMachine.<>t__builder.Start(ref stateMachine);\n    return stateMachine.<>t__builder.Task;\n}\n```\n\n----------------------------------------\n\nTITLE: Named Arguments with Params Collections Example in C#\nDESCRIPTION: Demonstrates ambiguity in overload resolution when using named arguments with different params collection types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static void Main()\n    {\n        Test(x: 1, y: 2); // Ambiguous\n    }\n\n    static void Test(int x, params System.ReadOnlySpan<int> y) {}\n    static void Test(int y, params System.Span<int> x) {}\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Interface and Enum Declarations\nDESCRIPTION: ANTLR grammar rules defining the syntax for interface and enum declarations, which also support empty body declarations using semicolons.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR\nCODE:\n```\ninterface_declaration\n  : attributes? interface_modifier* 'partial'? 'interface'\n    identifier variant_type_parameter_list? interface_base?\n    type_parameter_constraints_clause* interface_body\n  ;  \n    \ninterface_body\n  : '{' interface_member_declaration* '}' ';'?\n  | ';'\n  ;\n\nenum_declaration\n  : attributes? enum_modifier* 'enum' identifier enum_base? enum_body\n  ;\n\nenum_body\n  : '{' enum_member_declarations? '}' ';'?\n  | '{' enum_member_declarations ',' '}' ';'?\n  | ';'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Tuple Conversion Breaking Change Example\nDESCRIPTION: Demonstrates potential breaking changes when upgrading from C# 6 to C# 7 regarding tuple conversions and method overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-12-22.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nA.dll:\n\n(int, long) Foo()... // ValueTuple<int, long> Foo();\n\nB.dll:\n\nvoid Bar(object o)\nvoid Bar((int?, long?) t)\n\nC.dll:\n\nBar(Foo());\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JSON Object Construction in C#\nDESCRIPTION: Example of constructing a JSON-serializable object using object initializer syntax. This shows the current C# approach that the wire format discussion is proposing to improve upon.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-22-Design-Review.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar thing = new Thing { name = \"...\", price = 123.45 }\n```\n\n----------------------------------------\n\nTITLE: Arglist Collection Expression Example\nDESCRIPTION: Demonstrates potential syntax for using __arglist with collection expressions, though this feature is not supported unless free.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyCollection : IEnumerable\n{\n    public MyCollection(__arglist) { ... }\n    public void Add(object o) { }\n}\n\nMyCollection c;\nc = [with(__arglist())];    // ok\nc = [with(__arglist(x, y)]; // ok\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable<T> usage in C#\nDESCRIPTION: This snippet shows the usage of GetValueOrDefault method on Nullable<T>, which is legal on null values and doesn't trigger warnings in the proposed null tracking system.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-24.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nNullable<T>.GetValueOrDefault()\n```\n\n----------------------------------------\n\nTITLE: Defining Roles with Underlying Type and Inheritance\nDESCRIPTION: Demonstrates role definition syntax with underlying type and multiple inherited roles in C#\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-01-25.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstruct U { }\nrole X : U { }\nrole Y : U, X, X1 { }\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression Method Overload Resolution\nDESCRIPTION: Example illustrating how conditional expression target typing would affect method overload resolution, potentially changing existing behavior if the same rules were applied as for switch expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-22.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(byte b) { }\nvoid M(long l) { }\n\nvoid Test(bool b) => M(b ? 1 : 0);\n// The above calls M(long l). If we use the above proposal for ?:\n// then it will call M(byte b) because byte\n// is a \"better\" overload than long\n```\n\n----------------------------------------\n\nTITLE: Implicit 'this' Reference in C#\nDESCRIPTION: This example shows the implicit use of `this` within an extension member declaration. When accessing members of the underlying type, the `this` keyword can be omitted, simplifying the syntax. This demonstrates how extension members can be declared similarly to instance members in classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable)\n    {\n        // implicit 'this.GetEnumerator()'\n        public bool IsEmpty => !GetEnumerator().MoveNext();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Field Access Warnings in Auto-Properties - C#\nDESCRIPTION: This snippet demonstrates the introduction of a new 'field' parameter in C# auto-properties and how it could potentially shadow existing property accessors. In C# version 12 and below, a warning is generated if 'field' is used as an identifier within a property accessor. This warning serves to alert developers of changes in behavior when upgrading to C# 13, where 'field' would reference the generated underlying field. This approach assumes developers use compilers that can warn about newer language features when compiling older versions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/breaking-change-warnings.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Entity\n{\n    string field;\n    public string Field\n    {\n        get { return field; }         // Warning in C# 12 and below\n        set { field = value.Trim(); } // Warning in C# 12 and below\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Static Anonymous Method Example\nDESCRIPTION: Example showing the basic syntax and usage of a static anonymous method in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/static-anonymous-functions.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic delegate(int x) { return x * 2; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating fieldof() Usage in C# Constructor\nDESCRIPTION: Example showing how the proposed fieldof() operator could be used in a constructor to directly set a backing field without invoking the property setter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/fieldof.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public C(string prop)\n    {\n        fieldof(Prop) = prop;\n    }\n\n    public string Prop\n    {\n        get => field;\n        set\n        {\n            if (value != field)\n            {\n                field = value;\n                OnPropertyChanged();\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compound Assignment with Value Types in C#\nDESCRIPTION: This code snippet demonstrates how compound assignment operators behave with value types (structs) in C#. It shows the differences in evaluation order and result handling compared to reference types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nvar a = (new S())+=10; // error: not a variable\nvar b = S.P2 += 100; // var temp = S.op_Addition(S.get_P2(), 100); S.set_P2(temp); b = temp;\nS.P2 += 100; // var temp = S.op_Addition(S.get_P2(), 100); S.set_P2(temp);\nvar c = b + 1000; // c = S.op_Addition(b, 1000)\nc += 5; // c.op_AdditionAssignment(5); \nvar d = S.P1 += 11; // error: setter is missing\nvar e = c += 12; // var temp = c; temp.op_AdditionAssignment(12); e = (c = temp); \n\nstruct S\n{\n    public static S P1 { get; } = new S();\n    public static S P2 { get; set; } = new S();\n\n    // op_Addition\n    public static S operator +(S x, int y) => ...;\n\n    // op_AdditionAssignment\n    public void operator +=(int y) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TryAdd Method for Generic Collection in C#\nDESCRIPTION: This code snippet demonstrates a potential issue with ad-hoc unions when used as type parameters. The TryAdd method checks if an object is of type T, but this check may always succeed if T is an erased ad-hoc union type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/Union implementation challenges.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyCollection<T>\n{\n    public bool TryAdd(object o)\n    {\n        if (o is T t)\n        {\n            // add t\n            return true;\n        }\n        else return false;\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Static Factory Method Overloading in C# Extensions\nDESCRIPTION: This C# code snippet illustrates a scenario where multiple extension declarations have static factory methods with the same parameter types but different return types. The question is whether the C# compiler should allow this, given that C# methods cannot differ solely by return type. This is related to how scopes are perceived within extension blocks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-03-03.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Factory\n{\n    extension(A)\n    {\n        public static A Create() => ...;\n    }\n\n    extension(B)\n    {\n        public static B Create() => ...;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Hypothetical Guard Statement Example\nDESCRIPTION: Example of how a Swift-style guard statement might look in C# to handle pattern variable scoping.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-15.md#2025-04-23_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(object o)\n{\n  guard (o is int i) else throw new ArgumentException(\"Not an int\", nameof(o)); // else must leave scope\n  ...i...; // i is in scope because the guard statement is specially leaky\n}\n```\n\n----------------------------------------\n\nTITLE: Antlr Definition for Namespace Declarations\nDESCRIPTION: This snippet details the ANTLR definition for namespace declarations, which includes both traditional and file scoped formats. This helps to clarify how these declarations are structured within the C# language specification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/file-scoped-namespaces.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nnamespace_declaration\n    : 'namespace' qualified_identifier namespace_body ';'?\n    ;\n    \nfile_scoped_namespace_declaration\n    : 'namespace' qualified_identifier ';' extern_alias_directive* using_directive* type_declaration*\n    ;\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements in C#\nDESCRIPTION: This snippet describes how to access elements of an array using specific expressions. It requires that the indices are of types that can be implicitly converted to the valid integer types. The output is the selected array element based on the provided indices.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/numeric-intptr.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nA[Iâ‚, Iâ‚‚, ..., Iâ‚“]\n```\n\n----------------------------------------\n\nTITLE: Accessing Non-Identifier Keys in Dynamic Objects\nDESCRIPTION: Example demonstrating how to access properties with non-identifier names in dynamic objects, combining the $ syntax with traditional indexing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-12-16.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npayload.$People[i].[\"first name\"]\n```\n\n----------------------------------------\n\nTITLE: Approach B1: Nullable Backing Field (C#)\nDESCRIPTION: Illustrates having the backing field have the nullable version of the property type.  However, this might require the developer to initialize the property in the constructor, even when not necessary.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\n\"string Prop { ...field... }\\n\\n// Would be the same as the following for the purpose of analyzing the accessors\\nstring? _field;\\nstring Prop { ..._field... }\"\n```\n\n----------------------------------------\n\nTITLE: Complex Method Call with Control Flow Expressions\nDESCRIPTION: Example showing potential complex usage of break and continue expressions within method arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-27.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nM(Foo1(), Foo2() ?? break, int.TryParse(s, out int x) ? x * 10 : continue);\n```\n\n----------------------------------------\n\nTITLE: Runtime Evaluation for Nullable Value Types in C#\nDESCRIPTION: Runtime evaluation logic for null coalescing assignment when A0 exists and B is implicitly convertible to A0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/null-coalescing-assignment.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar tmp = a.GetValueOrDefault();\nif (!a.HasValue) { tmp = b; a = tmp; }\ntmp\n```\n\n----------------------------------------\n\nTITLE: Defining Pseudo-Syntax for C# Union Types\nDESCRIPTION: This snippet outlines various syntax options for defining union types in C#, including tagged and untagged unions, internal and external members, and unions with values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-10-31.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nunion [Name] { A, B, C }      // tagged, internal (members declared within type)\nunion [Name] ( A | B | C )    // untagged, external (members declared outside type)\nunion [Name] { A(int x), B }  // tagged with values (mixed)\nunion [Name] { A = 10 }       // tagged with values\nunion [Name] { 10 | 20 }      // untagged, external, with values\nunion [Name] { ..Base }       // all known derived types of Base (splatting). Covered by `union Name { Base }`\n```\n\n----------------------------------------\n\nTITLE: Equivalent Iterator Method for LINQ Query in C#\nDESCRIPTION: This snippet shows an iterator method that is morally equivalent to the LINQ query in the previous example. It demonstrates the desired behavior for nullable analysis in LINQ queries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-07.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nIEnumerable<HasNotNullable> M2(IEnumerable<HasNullable> enumerable)\n{\n    foreach (var x in enumerable)\n    {\n        if (x.Item != null)\n        {\n            yield return new HasNotNullable(x.Item); // ok\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Var Method Declaration Conflict in C#\nDESCRIPTION: Example showing how var keyword is interpreted in ambiguous situations with method declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-12.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nref int var(int x, int y);\nvar(x, y) = e; // deconstruction or call?\n```\n\n----------------------------------------\n\nTITLE: Reference Parameter Declaration with Default Value in C#\nDESCRIPTION: Demonstrates using declaration expressions for ref parameters with optional default values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/declaration-expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nConvert(source, destination, ref List<Diagnostic> diagnostics = null);\n```\n\n----------------------------------------\n\nTITLE: Global Using Alias Directive Syntax in ANTLR\nDESCRIPTION: This ANTLR grammar defines the syntax for a global using alias directive in C#, specifying that it starts with the `global using` keywords, followed by an identifier (the alias name), an equals sign, a namespace or type name, and a semicolon. The directive creates an alias for a namespace or type that is accessible program-wide.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/GlobalUsingDirective.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\n\"global_using_alias_directive\\n    : 'global' 'using' identifier '=' namespace_or_type_name ';'\\n    ;\"\n```\n\n----------------------------------------\n\nTITLE: With Expression Grammar with ref Values in ANTLR\nDESCRIPTION: Updated ANTLR grammar for 'with' expressions that adds support for passing references using the 'ref' keyword in member initializers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_28\n\nLANGUAGE: antlr\nCODE:\n```\nmember_initializer\n    : identifier '=' 'ref' expression // added\n    | identifier '=' expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Arguments Must Match Rule with Ref Structs\nDESCRIPTION: Illustrates the ref safety rule that prevents capturing stack-allocated spans in ref struct fields, showing why the method arguments must match rule exists to prevent unsafe memory access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_49\n\nLANGUAGE: csharp\nCODE:\n```\nref struct RS\n{\n    Span<int> _field;\n    void Set(Span<int> p)\n    {\n        _field = p;\n    }\n\n    static void DangerousCode(ref RS p)\n    {\n        Span<int> span = stackalloc int[] { 42 };\n\n        // Error: if allowed this would let the method return a reference to \n        // the stack\n        p.Set(span);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Passing ref-like types in C#\nDESCRIPTION: Example of how ref-like types, such as Span<T>, can be passed. They cannot be passed by ref, only by 'in', and must be readonly structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-29.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nin\n```\n\n----------------------------------------\n\nTITLE: Internal Compiler Implementation of Fixed Size Buffer in C#\nDESCRIPTION: Shows how the compiler would internally represent the fixed-sized buffer declaration. Includes the generated struct with indexer implementation and bounds checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/fixed-sized-buffers.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[FixedBuffer(typeof(DXGI_RGB), 1024)]\npublic ConsoleApp1.<Buffer>e__FixedBuffer_1024<DXGI_RGB> GammaCurve;\n\n// Pack = 0 is the default packing and should result in indexable layout.\n[CompilerGenerated, UnsafeValueType, StructLayout(LayoutKind.Sequential, Pack = 0)]\nstruct <Buffer>e__FixedBuffer_1024<T>\n{\n    private T _e0;\n    private T _e1;\n    // _e2 ... _e1023\n    private T _e1024;\n\n    public ref T this[int index] => ref (uint)index <= 1024u ?\n                                         ref RefAdd<T>(ref _e0, index):\n                                         throw new IndexOutOfRange();\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Static Delegate in C#\nDESCRIPTION: Example showing how to declare a static delegate that returns an integer with no parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/static-delegates.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic delegate int Func()\n```\n\n----------------------------------------\n\nTITLE: Defining LogDebug Method with InterpolatedStringHandlerArgument\nDESCRIPTION: Example showing how to define a logging method that uses the new InterpolatedStringHandlerArgument attribute with method name support.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/interpolated-string-handler-method-names.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic void LogDebug(\n    this ILogger logger,\n    [InterpolatedStringHandlerArgument(nameof(logger), \"Method Name\")] LogInterpolatedStringHandler message);\n```\n\n----------------------------------------\n\nTITLE: Iterator Method Null Checking in C#\nDESCRIPTION: Demonstrates null checking behavior in iterator methods using the !! operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass Iterators {\n    IEnumerable<char> GetCharacters(string s!!) {\n        foreach (var c in s) {\n            yield return c;\n        }\n    }\n\n    void Use() {\n        // The invocation of GetCharacters will throw\n        IEnumerable<char> e = GetCharacters(null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Taking a pointer to fixed-size array field still requiring pinning in C#\nDESCRIPTION: This code demonstrates a scenario that would still require pinning even with the proposed change. When explicitly taking a pointer to a fixed-size array field in a movable context, pinning would still be necessary for memory safety.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/indexing-movable-fixed-fields.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe struct S\n{\n    public fixed int myFixedField[10];\n}\n\nclass Program\n{\n    static S s;\n\n    unsafe static void Main()\n    {\n        int* ptr = s.myFixedField; // taking a pointer explicitly still requires pinning.\n        int p = ptr[5];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Usage Examples of Ref-Like Types in C#\nDESCRIPTION: Comprehensive example showing valid and invalid operations with ref-like types, demonstrating stack confinement rules. Includes method calls, assignments, and return scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nSpanLikeType M1(ref SpanLikeType x, Span<byte> y)\n{\n    // this is all valid, unconcerned with stack-referring stuff\n    var local = new SpanLikeType(y);\n    x = local;\n    return x;\n}\n\nvoid Test1(ref SpanLikeType param1, Span<byte> param2)\n{\n    Span<byte> stackReferring1 = stackalloc byte[10];\n    var stackReferring2 = new SpanLikeType(stackReferring1);\n\n    // this is allowed\n    stackReferring2 = M1(ref stackReferring2, stackReferring1);\n\n    // this is NOT allowed\n    stackReferring2 = M1(ref param1, stackReferring1);\n\n    // this is NOT allowed\n    param1 = M1(ref stackReferring2, stackReferring1);\n\n    // this is NOT allowed\n    param2 = stackReferring1.Slice(10);\n\n    // this is allowed\n    param1 = new SpanLikeType(param2);\n\n    // this is allowed\n    stackReferring2 = param1;\n}\n\nref SpanLikeType M2(ref SpanLikeType x)\n{\n    return ref x;\n}\n\nref SpanLikeType Test2(ref SpanLikeType param1, Span<byte> param2)\n{\n    Span<byte> stackReferring1 = stackalloc byte[10];\n    var stackReferring2 = new SpanLikeType(stackReferring1);\n\n    ref var stackReferring3 = M2(ref stackReferring2);\n\n    // this is allowed\n    stackReferring3 = M1(ref stackReferring2, stackReferring1);\n\n    // this is allowed\n    M2(ref stackReferring3) = stackReferring2;\n\n    // this is NOT allowed\n    M1(ref param1) = stackReferring2;\n\n    // this is NOT allowed\n    param1 = stackReferring3;\n\n    // this is NOT allowed\n    return ref stackReferring3;\n\n    // this is allowed\n    return ref param1;\n}\n```\n\n----------------------------------------\n\nTITLE: Nested Enum Class Expression Example\nDESCRIPTION: Demonstrates nested enum class declarations for representing binary expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/discriminated-unions.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nenum class Expr\n{\n    enum class Binary\n    {\n        Addition(Expr left, Expr right),\n        Multiplication(Expr left, Expr right)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci Sequence with Local Function in C#\nDESCRIPTION: Demonstrates how to use a local function to implement the Fibonacci sequence calculation within the Main method. The local function can access variables from the enclosing scope without additional parameter passing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-11-02-Design-Demo.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic void Main(string[] args)\n{\n    int Fib(int n) => (n < 2) ? 1 : Fib(n - 1) + Fib(n - 2);\n\n    Console.WriteLine(Fib(7));\n    Console.ReadKey();\n}\n```\n\n----------------------------------------\n\nTITLE: Heap Allocation translation for Span<T> in C#\nDESCRIPTION: This code snippet shows how a collection literal can be translated to a heap allocation when a Span<T> is needed. It shows the existing array allocation rules applied, then the assignment of the resulting array to the span.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-21.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nT[] __array = [...]; // using existing rules\nSpan<T> __result = __array;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Expression Variables in LINQ Query\nDESCRIPTION: Example showing desired syntax for using expression variables across query clauses, specifically using TryParse result in a subsequent select clause.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nfrom s in strings\nwhere int.TryParse(s, out int i)\nselect i;\n```\n\n----------------------------------------\n\nTITLE: Implementing 'supersedes' Feature for Metaprogramming in C#\nDESCRIPTION: This example demonstrates the proposed 'supersedes' concept for C#, showing how generated code could override original methods and properties while maintaining access to the original implementation via 'superseded()' calls. The example shows a class with a method and property, and how a generator could extend them with additional functionality like property change notification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-02.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nclass C\n{\n  public void M()\n  {\n    // do stuff\n  }\n\n  [INPC] public int X {\n    get { ... }\n    set { ... }\n}\n\n// generated\npartial class C\n{\n  public supersedes void M()\n  {\n    // do something\n    superseded(); // calls original method\n    // do more\n  }\n\n  public supersedes int X {\n    get { return superseded; }\n    set \n    {\n      superseded = value;\n      RaiseNPC(nameof(X));\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Assignment Error Example - C#\nDESCRIPTION: Example demonstrating a case where dynamic assignment operation would result in a compile-time error under proposed rules due to incompatible types Base and object\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar c2 = new C2();\nc2.M(0, 1);\n\npublic class C2\n{\n    public void M(dynamic d, object o)\n    {\n        this[d] += o; // Would error, += cannot be applied to operands of type Base and object\n    }\n\n    Base this[int x]\n    {\n        get => new Base();\n        set {}\n    }\n}\n\nclass Base { }\n```\n\n----------------------------------------\n\nTITLE: Primary Constructor Attribute Discussion\nDESCRIPTION: Discussion about attribute placement on captured parameters in primary constructors. The team decided against allowing attributes on captured parameters since they are not guaranteed to be backed by fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-03.md#2025-04-21_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Implicit vs Explicit Interface Method Override\nDESCRIPTION: Demonstrates the difference between implicit and explicit interface method overrides, which should generate similar IL code.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/CLR-2017-03-23.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IA\n{\n    void M();\n}\npublic interface IB : IA\n{\n    override void M() { WriteLine(\"IB\"); }\n}\n```\n\nLANGUAGE: c#\nCODE:\n```\npublic interface IB : IA\n{\n    override void IA.M() { WriteLine(\"IB\"); }\n}\n```\n\n----------------------------------------\n\nTITLE: Ad Hoc Union Implementation via Erasure in C#\nDESCRIPTION: Shows how ad hoc unions are implemented through type erasure, where the union type is represented as object at runtime.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\n(A or B) ab = new A(10, \"ten\");\n```\n\n----------------------------------------\n\nTITLE: Defining Function Pointer Grammar in ANTLR\nDESCRIPTION: ANTLR grammar definition for function pointer calling conventions in C#, showing the syntax for managed and unmanaged function pointers with various calling convention options.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-24.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nfunc_ptr_calling_convention\n   : 'managed'\n   | 'unmanaged' ('[' func_ptr_callkind ']')?\n\nfunc_ptr_callkind\n  : 'CallConvCdecl'\n  | 'CallConvStdcall'\n  | 'CallConvThiscall'\n  | 'CallConvFastcall'\n  | identifier (',' identifier)*\n```\n\n----------------------------------------\n\nTITLE: Approach A2: Warning Control Example (C#)\nDESCRIPTION: Illustrates how the `MaybeNull` attribute can control warnings for unsafe uses of the `field` keyword, while not warning in other cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n\"[field: MaybeNull] string Prop { get => field; } // will appropriately warn\\n[field: MaybeNull] string Prop { get => field ??= ComputeValue(); } // will appropriately not warn.\"\n```\n\n----------------------------------------\n\nTITLE: Switching on Union Struct\nDESCRIPTION: Demonstrates how to use a switch expression with a union struct by matching on each member type without needing a default case if all member types are covered.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = u switch { \n    A a => a.x,\n    B b => b.z,\n    C c => 0\n};\n```\n\n----------------------------------------\n\nTITLE: Nullable Disabled Context Example in C#\nDESCRIPTION: Demonstrates that T? annotation behavior persists even in nullable disabled contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n#nullable disable\nvar u3 = new U[0].FirstOrDefault();  // U? u3\n```\n\n----------------------------------------\n\nTITLE: Short Circuiting Interpretation in C#\nDESCRIPTION: Demonstrates how the null propagating operator behaves under short circuiting interpretation, where subsequent member access operations are conditional.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nvar x = ((var tmp = a) == null ? null : tmp.b.c);\n```\n\n----------------------------------------\n\nTITLE: Extension Method Parameter Reference\nDESCRIPTION: Example of the new() constraint syntax mentioned in discussion about constructor constraints. Shows current limitation of only supporting parameterless constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-18.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnew()\n```\n\n----------------------------------------\n\nTITLE: Loop Iteration Scope Example with Declaration Expressions in C#\nDESCRIPTION: Example showing potential scope issues across loop iterations when using declaration expressions, where a variable declared in one iteration might incorrectly persist to subsequent iterations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-01-06.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nwhile (â€¦) m(int x = 1; x++); // survival across loop iterations?\n```\n\n----------------------------------------\n\nTITLE: Method Overload Resolution Example in C#\nDESCRIPTION: Example demonstrating potential breaking changes in overload resolution when combining target-typing with natural type inference. Shows two overloaded methods with nullable value types and a switch expression call.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-09-18.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(int? x) { ... }\nvoid M(short? y) { ... }\n```\n\n----------------------------------------\n\nTITLE: Abbreviated Extension Declaration (Merged Class and Declaration) in C#\nDESCRIPTION: This code shows an example of merging the static class and extension declaration into a single top-level extension declaration. This is a potential short-hand syntax. However, the nesting structure would still be applied in the generated output.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\npublic extension(IEnumerable) Enumerable\n{\n    public bool IsEmpty => !GetEnumerator().MoveNext();\n}\n```\n\n----------------------------------------\n\nTITLE: Comparison to Boolean Constant with Out Parameter\nDESCRIPTION: Illustrates problematic definite assignment scenarios when comparing method results with boolean constants\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nif ((c != null && c.M(out object obj1)) == true)\n{\n    obj1.ToString(); // undesired error\n}\n\nif ((c != null && c.M(out object obj2)) is true)\n{\n    obj2.ToString(); // undesired error\n}\n```\n\n----------------------------------------\n\nTITLE: Metadata Representation of Ref-Like Structs in C#\nDESCRIPTION: Shows how ref-like structs are represented in metadata using IsRefLike and Obsolete attributes. The Obsolete attribute ensures backward compatibility with older compilers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    [IsRefLike]\n    [Obsolete(\"Types with embedded references are not supported in this version of your compiler.\")]\n    public struct TwoSpans<T>\n    {\n       // . . . .\n    }\n```\n\n----------------------------------------\n\nTITLE: UnscopedRefAttribute Definition\nDESCRIPTION: Defines the UnscopedRefAttribute class with its usage attributes and scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_22\n\nLANGUAGE: c#\nCODE:\n```\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(\n        AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Parameter,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class UnscopedRefAttribute : Attribute\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using File-Local Types as Attributes\nDESCRIPTION: This snippet demonstrates how file-local classes can be used as attribute types. The attribute can be used within both file-local and non-file-local types. Accessing the file-local attribute by type using `typeof()` is the recommended way.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Linq;\n\nfile class MyFileLocalAttribute : Attribute { }\n\n[MyFileLocalAttribute]\npublic class C\n{\n    public static void Main()\n    {\n        var attribute = typeof(C).CustomAttributes.Where(attr => attr.AttributeType == typeof(MyFileLocalAttribute)).First();\n        Console.Write(attribute); // outputs the generated name of the file-local attribute type\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Type Inference with Collection Literals (Complex) in C#\nDESCRIPTION: This code snippet showcases a more complex scenario for generic type inference with collection literals. It involves a type `ImmutableArray<T>` that is *constructible* from an array of type `T[]`. The aim is to infer `T` from the literal and use it for constructing the `ImmutableArray<T>`.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-21.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nvoid M<T>(ImmutableArray<T> values);\nM([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax for Specific Base Implementation Calls in C#\nDESCRIPTION: Shows a potential syntax for specifying which base implementation to call in cases of ambiguity, though this approach is considered \"weird-ish\".\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-31.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nbase(I3).(I1.M1)<string>(1, 2, 3); // Call I3's implementation of I1's M1\n```\n\n----------------------------------------\n\nTITLE: Invalid UTF-8 Literal Usage as Default Parameter\nDESCRIPTION: This snippet shows that `u8` literals cannot be used as default values for optional parameters. This limitation is due to `ReadOnlySpan<byte>` not being a valid constant type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n\"// Error: The argument is not constant\nvoid Write(ReadOnlySpan<byte> message = \\\"missing\\\"u8) { ... } \"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Null-State Tracking in C#\nDESCRIPTION: This snippet illustrates a potential flow-based approach to tracking the null-state of a variable based on tests and assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Design-Review.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nif (x == null) return;\n// not null here\n```\n\n----------------------------------------\n\nTITLE: Generated Indexer for Safe Fixed Size Buffers in C#\nDESCRIPTION: Example of the accessor method that would be generated by the compiler for fixed size buffers, returning a reference to the element at the specified index.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_26\n\nLANGUAGE: c#\nCODE:\n```\n[UnscopedRef] internal ref char DataIndexer(int index) => ...;\n```\n\n----------------------------------------\n\nTITLE: Translated Sealed Record Class Implementation in C#\nDESCRIPTION: Shows the compiler-generated implementation of a sealed record class that inherits from an abstract record. Includes equality comparison, hash code generation, and the With method for creating modified copies.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic sealed class Student : Person, IEquatable<Student>\n{\n    public override string Name { get; }\n    public decimal Gpa { get; }\n    public Student(string Name, decimal Gpa) : base(Name)\n    {\n        this.Name = Name;\n        this.Gpa = Gpa;\n    }\n    public override bool Equals(Student other) // for IEquatable<Student>\n    {\n        return Equals(Name, other.Name) && Equals(Gpa, other.Gpa);\n    }\n    public bool Equals(Person other) // for IEquatable<Person>\n    {\n        return (other as Student)?.Equals(this) == true;\n    }\n    public override bool Equals(object other)\n    {\n        return (other as Student)?.Equals(this) == true;\n    }\n    public override int GetHashCode()\n    {\n        return (Name?.GetHashCode()*17 + Gpa.GetHashCode()).GetValueOrDefault();\n    }\n    public Student With(string Name = this.Name, decimal Gpa = this.Gpa) => new Student(Name, Gpa);\n    public override Person With(string Name = this.Name) => new Student(Name, Gpa);\n    public void Deconstruct(Student self, out string Name, out decimal Gpa)\n    {\n        Name = self.Name;\n        Gpa = self.Gpa;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Limitations of Discards in C# when '_' is Already in Scope\nDESCRIPTION: This snippet illustrates limitations of using discards when '_' is already declared in the scope, such as a parameter. It shows situations where using discards might cause errors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-11-15.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic override void M(int _) // declaring _ to signal that this override doesn't care about it\n{\n\t_ = TryFoo();     // Error: cannot assign bool result to int variable _\n\tvar _ = TryFoo(); // Error: cannot declare local _ when one is already in scope\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Parameter Null Checking Syntax in C#\nDESCRIPTION: Demonstrates the basic usage of !! operator for parameter null checking and its equivalent implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string name!!) {\n    ...\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string name) {\n    if (name is null) {\n        throw new ArgumentNullException(nameof(name));\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring Deconstruction Syntax for Tuples in C#\nDESCRIPTION: This snippet presents a hypothetical right-side deconstruction syntax for tuples, as well as deconstruction into existing variables. It highlights the potential issues with variable declaration and scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\nTally(myValues) ~> (var sum, var count); // strawman right side alternative\nConsole.WriteLine($\"Sum: {sum}, count: {count}\");\n\n(sum, count) = Tally(myValues);\n```\n\n----------------------------------------\n\nTITLE: Introducing Defaultable Types for Unconstrained Type Parameters in C#\nDESCRIPTION: Presents a potential syntax for 'defaultable types' using the '?' operator with unconstrained type parameters. This allows for creating a nullable counterpart of non-nullable reference types when used as type arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-14.md#2025-04-23_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nT? t = default(T?); // if that's allowed\n```\n\n----------------------------------------\n\nTITLE: Expression Form of Pattern Matching in C#\nDESCRIPTION: Conceptual example of an expression-based pattern matching syntax (not finalized), showing how pattern matching could be used within expressions to return different values based on the matched pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-25-Notes.md#2025-04-21_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nM(match(e) {\n\t\t3 => x,\n\t\tstring s => s.foo,\n\t\tPoint(3, int y) => y,\n\t\t* => null })\n```\n\n----------------------------------------\n\nTITLE: Defining structs with readonly and writable autoprops in C#\nDESCRIPTION: This code snippet demonstrates the declaration of a struct with readonly and writable auto-implemented properties, and a constructor that attempts to assign values to these properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-01.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic struct S {\n   public int x {get;}\n   public int y {get; set;}\n   public Z z {get;}\n\n   public S() {\n      x = 15;\n      y = 23;\n      z.z1 = 1;\n   }\n}\n\npublic struct Z { int z1; }\n```\n\n----------------------------------------\n\nTITLE: GitHub Issue Links in Markdown\nDESCRIPTION: Markdown links to GitHub issues being discussed in the meeting, demonstrating the reference format used in the documentation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-09-01.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://github.com/dotnet/csharplang/issues/5124\nhttps://github.com/dotnet/csharplang/issues/3630\nhttps://github.com/dotnet/csharplang/issues/2691\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax for Implicit Extension Types in C#\nDESCRIPTION: The snippet provides an alternative syntax for declaring implicit or explicit extension types in C#. Several keyword options for underlying types, such as 'of', 'extends', and 'on', are under consideration. The objective is to finalize a syntax that is both expressive and simple.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-17.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n(implicit | explicit) extension\n(role | extension)\nview\nshape\nalias\nthis (as in this E of U)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tuple Element Name Mismatch Warning in C#\nDESCRIPTION: Shows how tuple element names are immaterial for conversions but can lead to warnings when mismatched.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n(string first, string last) GetNames() { ... }\n(string last, string first) names = GetNames(); // Oops!\n```\n\n----------------------------------------\n\nTITLE: ConfigureAwait Usage with Async Streams in C#\nDESCRIPTION: Shows how ConfigureAwait could be implemented with async streams to control await behavior for performance optimization in libraries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nforeach (string s in asyncStream.ConfigureAwait(false)) { ... }\n```\n\n----------------------------------------\n\nTITLE: Record Class Syntax in C#\nDESCRIPTION: Proposed syntax for declaring record classes with auto-generated equality and immutable properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\ndata class UserInfo\n{\n    public string Username { get; }\n    public string Email { get; }\n    public bool IsAdmin { get; } = false;\n}\n```\n\n----------------------------------------\n\nTITLE: Else-If Chain with Type Testing\nDESCRIPTION: Pattern showing declaration expressions in an if/else-if chain for type testing, demonstrating scope issues with multiple declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-09-03.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nif ((var i = o as int?) != null) { â€¦ i â€¦ }\nelse if ((var s = o as string) != null) { â€¦ s â€¦ }\nelse if â€¦\n```\n\n----------------------------------------\n\nTITLE: ScopedRefAttribute Definition\nDESCRIPTION: Defines the compiler-only ScopedRefAttribute class for parameter scoping.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_23\n\nLANGUAGE: c#\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\n    internal sealed class ScopedRefAttribute : Attribute\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Method Arguments Must Match (MAMM) Rule in C#\nDESCRIPTION: This snippet demonstrates the MAMM rule, which ensures that ref arguments to a method can be safely assigned without causing unsafe references to the stack.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/ref-improvements/REF-2022-11-11.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Swap(ref Span<int> x, ref Span<int> y) {\n    ... \n}\n\nvoid Use(ref Span<int> span) {\n    Span<int> local = stackalloc int[42];\n    Swap(ref span, ref local);\n}\n```\n\n----------------------------------------\n\nTITLE: File private accessibility modifier syntax options\nDESCRIPTION: The proposed 'file private' accessibility modifier syntax for C#, allowing members to be accessible only within the current file.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-30.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nfile private\n```\n\n----------------------------------------\n\nTITLE: Using Readonly Ref Locals in C#\nDESCRIPTION: Demonstrates declaring and using readonly ref locals. These locals can refer to readonly LValues like in parameters, readonly fields, or ref readonly methods, but cannot be written to.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/readonly-ref.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nstatic readonly ref Vector3 M1() => . . .\n\nstatic readonly ref Vector3 M1_Trace()\n{\n    // OK\n    ref readonly var r1 = ref M1();\n\n    // Not valid. Need an LValue\n    ref readonly Vector3 r2 = ref default(Vector3);\n\n    // Not valid. r1 is readonly.\n    Mutate(ref r1);\n\n    // OK.\n    Print(in r1);\n\n    // OK.\n    return ref r1;\n}\n```\n\n----------------------------------------\n\nTITLE: Disallowing File-Local Types in Global Using Static\nDESCRIPTION: This snippet demonstrates that it is a compile-time error to use a file-local type in a `global using static` directive.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nglobal using static C; // error\n\nfile class C\n{\n    public static void M() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Static Operator Implementation Example - C#\nDESCRIPTION: Demonstrates the limitations of default implementations for static virtual operators in interfaces, showing how default implementations cannot be inherited by concrete types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ninterface I<T> where T : I<T>\n{\n    public static abstract bool operator ==(T t1, T t2);\n    public static virtual bool operator !=(T t1, T t2) => !(t1 == t2);\n    public void M() {}\n}\nclass C : I<C>\n{\n    public static bool operator ==(C c1, C c2) => ...;\n}\n\nC c = new C();\nc.M(); // M is not accessible\n((I)c).M(); // This works, however\n\n_ = c == c; // Fine: C implements ==\n_ = c != c; // Not fine: I.!= is a default implementation that C does not inherit. This method cannot be called.\n```\n\n----------------------------------------\n\nTITLE: Defining CallIndirectAttribute for calli support in C#\nDESCRIPTION: This code defines the CallIndirectAttribute used to mark methods that should be compiled using the calli instruction. It specifies the calling convention for the indirect call.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intrinsics.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n[AttributeUsage(AttributeTargets.Method)]\npublic sealed class CallIndirectAttribute : Attribute\n{\n    public CallingConvention CallingConvention { get; }\n    public CallIndirectAttribute(CallingConvention callingConvention)\n    {\n        CallingConvention = callingConvention;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Switch Expression Syntax Alternatives in C#\nDESCRIPTION: Different syntax options for switch expressions using various operators (:, =>, ->, ~>) to separate patterns from results. Examples show state machine transitions with different syntactic approaches.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-05-02.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nstate = (state, action) switch {\n    (DoorState.Closed, Action.Open)   => DoorState.Opened,\n    (DoorState.Opened, Action.Close)  => DoorState.Closed,\n    (DoorState.Closed, Action.Lock)   => DoorState.Locked,\n    (DoorState.Locked, Action.Unlock) => DoorState.Closed,\n    _                                 => state\n};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating IntPtr usage in C#\nDESCRIPTION: This snippet shows the use of IntPtr in a C# context, which is relevant to the discussion of native-size integers. It's used to illustrate the potential need for nint and nuint types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-13.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIntPtr nativeInt = IntPtr.Zero;\nstring formattedValue = String.Format(\"{0}\", nativeInt);\n```\n\n----------------------------------------\n\nTITLE: Unbound Generic Types in nameof\nDESCRIPTION: Proposal to support unbound generic types within nameof expressions with potential fallback to error handling approach\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-16.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar genericTypeName = nameof(List<>);\n```\n\n----------------------------------------\n\nTITLE: Example of Named Tuple Declaration in C#\nDESCRIPTION: This code demonstrates a hypothetical named tuple declaration, which was considered as an alternative to named function pointers. It shows how named tuples could reduce the need to type out full signatures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n(int x, int y) Point;\n\nclass NamedTupleExample {\n    void M(Point p) {\n        Console.WriteLine(p.x);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Role as Extension Method Declaration in C#\nDESCRIPTION: This snippet shows how a role can be turned into an extension method by changing the declaration from `role` to `extension`.  It demonstrates how the extension method is brought into scope using the `using` directive.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nclass UnderlyingType\n{\n    void M1() { ... }\n    void M2() { ... }\n}\n\nnamespace MyRoleNamespace\n{\n    extension MyRole : UnderlyingType \n    {\n        void M2() { }\n        void M3() { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Warning Version Command Line Option in C#\nDESCRIPTION: Shows examples of using the command line option for specifying warning versions in C# compilation. This includes options for listing all warning versions, disabling all warnings, and enabling all warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-26.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ncsc /warnversion:\n```\n\nLANGUAGE: csharp\nCODE:\n```\ncsc /warnversion:none\n```\n\nLANGUAGE: csharp\nCODE:\n```\ncsc /warnversion:all\n```\n\n----------------------------------------\n\nTITLE: Alternate Enum Class Syntax with Regular Members\nDESCRIPTION: Alternative syntax proposal for enum class that allows mixing enum cases with regular class members, separated by a semicolon delimiter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-13.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nenum class Color\n{\n    Red,\n    Greed; // semicolon delimiting end of enum class cases, and start of regular members\n\n    public static int HelperField;\n    public static int HelperProperty => 0;\n    public int HelperMethod() => 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Interface Declaration Example\nDESCRIPTION: Reference to the IAsyncDisposable interface that is required for async disposal operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-30.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nIAsyncDisposable\n```\n\n----------------------------------------\n\nTITLE: Integer Logical Operators for IntPtr\nDESCRIPTION: Defines logical operators (AND, OR, XOR) for System.IntPtr type with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator &(int, System.IntPtr)\nSystem.IntPtr operator &(System.IntPtr, int)\nSystem.IntPtr operator &(System.IntPtr, System.IntPtr)\n\nSystem.IntPtr operator |(int, System.IntPtr)\nSystem.IntPtr operator |(System.IntPtr, int)\nSystem.IntPtr operator |(System.IntPtr, System.IntPtr)\n\nSystem.IntPtr operator ^(int, System.IntPtr)\nSystem.IntPtr operator ^(System.IntPtr, int)\nSystem.IntPtr operator ^(System.IntPtr, System.IntPtr)\n```\n\n----------------------------------------\n\nTITLE: Type Inference with Conditional Expression in C#\nDESCRIPTION: Shows how ad hoc union types can be inferred from conditional expressions where the result types would form a union.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\nDog rufus = ...;\nCat petunia = ...;\nBird polly = ...;\n\n// u : (Dog or Cat or Bird)\nvar u = \n      x == 1 ? rufus\n    : x == 2 ? petunia\n    : polly;\n```\n\n----------------------------------------\n\nTITLE: Nullable Array Type Declaration Examples in C#\nDESCRIPTION: Examples showing different syntax approaches for declaring nullable array types and their interpretations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-11-28.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstring?[][] a; new string?[3][] // 1. Array nullable string, 2. likewise\nstring[]?[] a; // 1. Nullable array of array of string, 2. Array of nullable array of string\nstring[][]? a; // 1. Array of nullable array of string, 2. Nullable array of array of string\n```\n\n----------------------------------------\n\nTITLE: Parameter Passing Choice Example in C#\nDESCRIPTION: Demonstrates how parameter passing mode affects overload resolution between methods with params arrays of related types C1 and C2.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Program\n{\n    static void Main()\n    {\n        Test(1);\n    }\n\n    static void Test(in int x, params C2[] y) {} // There is an implicit conversion from `C2[]` to `C1[]`\n    static void Test(int x, params C1[] y) {} // Better candidate because of \"better parameter-passing choice\"\n}\n\nclass C1 {}\nclass C2 : C1 {}\n```\n\n----------------------------------------\n\nTITLE: Generic Type Constraint Syntax Proposals in C#\nDESCRIPTION: Various syntax proposals for specifying unconstrained generic type parameters in override scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-17.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\noverride void M1<[Unconstrained]T,U>(T? x)           // a\noverride void M1<T,U>(T? x) where T: object?         // b\noverride void M1<T,U>(T? x) where T: unconstrained   // c\noverride void M1<T,U>(T? x) where T:                 // d\noverride void M1<T,U>(T? x) where T: ?               // e\noverride void M1<T,U>(T? x) where T: null            // f\noverride void M1<T,U>(T? x) where T: class|struct    // g\noverride void M1<T,U>(T? x) where T: class or struct // h\noverride void M1<T,U>(T? x) where T: cluct           // joke\noverride void M1<T,U>(T? x) where T: default         // i\n```\n\n----------------------------------------\n\nTITLE: Top-Level Variable Declaration Example - C#\nDESCRIPTION: Example showing a simple top-level variable declaration to illustrate the ambiguity between global variables and local variables in the Main method context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-22.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nint x = ...;\n```\n\n----------------------------------------\n\nTITLE: Defining Interpolated String Handler Attributes in C#\nDESCRIPTION: This code snippet defines custom attributes used by the C# compiler to recognize and process interpolated string handlers. The InterpolatedStringHandlerAttribute indicates a valid handler, while the InterpolatedStringHandlerArgumentAttribute specifies parameter handling for interpolation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]\n    public sealed class InterpolatedStringHandlerAttribute : Attribute\n    {\n        public InterpolatedStringHandlerAttribute()\n        {\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\n    public sealed class InterpolatedStringHandlerArgumentAttribute : Attribute\n    {\n        public InterpolatedHandlerArgumentAttribute(string argument);\n        public InterpolatedHandlerArgumentAttribute(params string[] arguments);\n\n        public string[] Arguments { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Target-Typed New Expression in C#\nDESCRIPTION: This snippet shows an example of a target-typed new expression, where the type is inferred from the context. The discussion revolves around potential ambiguities and restrictions for this feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-05-21.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nM(new (1));\n```\n\n----------------------------------------\n\nTITLE: Dynamic Binding Limitations with Native Integers in C#\nDESCRIPTION: This code illustrates that native integer conversions and operators are not available for dynamic binding in C#, resulting in a RuntimeBinderException.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nnint x = 2;\nnint y = x + x; // ok\ndynamic d = x;\nnint z = d + x; // RuntimeBinderException: '+' cannot be applied 'System.IntPtr' and 'System.IntPtr'\n```\n\n----------------------------------------\n\nTITLE: Complex Value Type and Keyword Interaction in C#\nDESCRIPTION: Example showing how a type named 'value' can shadow the parameter name in attribute declarations, demonstrating current behavior with nameof expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass value(string type) : Attribute\n{    \n    value I\n    {\n        get;\n        [param: value(nameof(value))] set;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using `nameof` with Type Parameters in Attributes (C#)\nDESCRIPTION: This example shows how to use `nameof` to reference a type parameter within an attribute on a generic method. The `MyAttribute` attribute will receive the string representation of the `TParameter` type parameter name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/extended-nameof-scope.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n\"[MyAttribute(nameof(TParameter))] void M<TParameter>() { }\"\n```\n\n----------------------------------------\n\nTITLE: Using System.Int32 as Enum Base Type in C# 6.0\nDESCRIPTION: Example showing the relaxed enum base type syntax introduced in C# 6.0 that allows using System.Int32 instead of just the int keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-6.0/enum-base-type.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nenum Example : System.Int32\n{\n    // Enum members\n}\n```\n\n----------------------------------------\n\nTITLE: Escape Sequence Example - C#\nDESCRIPTION: Demonstration of the proposed \\e escape sequence as a shorthand for \\u001b (ESCAPE character) in C# strings\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-16.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n\"\\e\" // equivalent to \"\\u001b\"\n```\n\n----------------------------------------\n\nTITLE: Lambda Return Type Parsing Example - Conditional Expression\nDESCRIPTION: Code example demonstrating parsing ambiguity between conditional expression and lambda with return type\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-06-02.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nF(b ? () => a : c);\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Anonymous Functions\nDESCRIPTION: Defines the syntax for anonymous function parameters with optional 'scoped' modifier and parameter modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_18\n\nLANGUAGE: antlr\nCODE:\n```\nexplicit_anonymous_function_parameter\n    : 'scoped'? anonymous_function_parameter_modifier? type identifier\n    ;\n\nanonymous_function_parameter_modifier\n    : 'in'\n    | 'ref'\n    | 'out'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Generic Type Inference with Constructible Collection Types in C#\nDESCRIPTION: Example showing how type inference might work with collection literals when the target type is a constructible collection type like ImmutableArray<T>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M<T>(ImmutableArray<T> values);\nM([1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Alternative Local Variable Behavior in C#\nDESCRIPTION: Shows an alternative approach where all local variables are treated as nullable regardless of annotation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-07.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n        string s; // might be null\n        s = C.S; // ok\n        s = C.N; // ok\n        s = null; // ok\n        l = s.Length; // warning 1: Direct dereference\n        l = (s != null) ? s.length : 0; // ok\n```\n\n----------------------------------------\n\nTITLE: Proposed Augmented 'is' Operator Syntax for Type Testing in C#\nDESCRIPTION: Shows a proposed syntax enhancement for the 'is' operator that would allow type testing and variable declaration in a single expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nif (e is string s) { â€¦ s â€¦ } // augmented is operator\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pattern Matching in C# with Assignment Expression Syntax\nDESCRIPTION: This snippet shows a pattern matching example using assignment expression syntax. It checks if an object is an ExpressionStatement with an AssignmentExpressionSyntax, and compares the names of the left and right identifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nAssignmentExpressionSyntax(IdentifierName l, IdentifierName r)) \n    && l.name = r.name) ...\n```\n\n----------------------------------------\n\nTITLE: Parameter Null Checking with Multiple Parameters in C#\nDESCRIPTION: Shows how null checking is implemented when multiple parameters use the !! operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(string p1, string p2) {\n    if (p1 is null) {\n        throw new ArgumentNullException(nameof(p1));\n    }\n    if (p2 is null) {\n        throw new ArgumentNullException(nameof(p2));\n    }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Extension method with type inference example\nDESCRIPTION: This code highlights a situation where arguments beyond the receiver are required for type inference. It demonstrates a scenario where overload resolution can lead to unexpected errors due to the current implementation of classic extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-lookup.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"public class C\\n{\\n    public void M(I<string> i, out object o)\\n    {\\n        i.M(out o); // infers E.M<object>\\n        i.M2(out o); // error CS1503: Argument 1: cannot convert from 'out object' to 'out string'\\n    }\\n}\\npublic static class E\\n{\\n   public static void M<T>(this I<T> i, out T t) { t = default; }\\n   extension<T>(I<T> i)\\n   {\\n      public void M2(out T t) { t = default; }\\n   }\\n}\\npublic interface I<out T> { }\"\n```\n\n----------------------------------------\n\nTITLE: Collection Literal Type Discussion\nDESCRIPTION: Exploration of natural type options for collection literals, considering var, IEnumerable<T>, arrays, and List<T>. No concrete implementation was decided due to various trade-offs with each approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-03.md#2025-04-21_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Logging with Method Names\nDESCRIPTION: Using nameof for logging to capture method names in a type-safe manner.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvoid f(int i) {\n    Log(nameof(f), \"method entry\");\n}\n```\n\n----------------------------------------\n\nTITLE: Class with Value Semantics Pattern in C#\nDESCRIPTION: Demonstrates a pattern for implementing immutable classes with value semantics using a wrapped value type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-04.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person \n{\n\tpublic readonly PersonValue Value;\n\tpublic Person(PersonValue value) { Value = value; }\n\tpublic string Name => Value.Name;\n\tpublic int Age => Value.Age;\n\tâ€¦\n\tpublic struct PersonValue\n\t{\n\t\tpublic string Name;\n\t\tpublic int Age;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ReadOnlySpan of int with Collection Literal\nDESCRIPTION: This snippet shows how a ReadOnlySpan<int> can be defined using a collection literal. Just like the previous examples, it signifies global scope in terms of memory allocation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nReadOnlySpan<int> x = [1, 2, 3]; // pointer to data segment, global scope.\nreturn x;\n```\n\n----------------------------------------\n\nTITLE: Hypothetical TryConvert Method for Type Testing in C#\nDESCRIPTION: Shows a potential helper method approach for type testing that would use a more familiar pattern similar to TryParse methods in the .NET framework.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nif (MyHelpers.TryConvert(e, out string s)) { â€¦ s â€¦ }\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Class Declaration with Primary Constructor\nDESCRIPTION: ANTLR grammar rules defining the extended syntax for class declarations with primary constructor parameter lists and class base argument lists.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/primary-constructors.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nclass_declaration\n  : attributes? class_modifier* 'partial'? class_designator identifier type_parameter_list?\n  parameter_list? class_base? type_parameter_constraints_clause* class_body\n  ;\n  \nclass_designator\n  : 'record' 'class'?\n  | 'class'\n  \nclass_base\n  : ':' class_type argument_list?\n  | ':' interface_type_list\n  | ':' class_type  argument_list? ',' interface_type_list\n  ;  \n  \nclass_body\n  : '{' class_member_declaration* '}' ';'?\n  | ';'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Creating and Target Typing Tuple Literals in C#\nDESCRIPTION: Demonstrates various ways to create tuple literals, both with and without names, and how they interact with type inference and target typing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-01.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvar t1 = (\"Hello\", \"World\");           // infers (string, string)\nvar t2 = (first: \"John\", last: \"Doe\"); // infers (string first, string last)\nvar t3 = (\"Hello\", null);              // fails to infer because null doesn't have a type\nvar t4 = (first: \"John\", last: null);  // fails to infer because null doesn't have a type\n\n(string, string) t5 = (\"Hello\", null);                           // target typed to (string, string)\n(string first, string last) t6 = (\"John\", null);                 // target typed to (string first, string last)\n(string first, string last) t7 = (first: \"John\", second: \"Doe\"); // error: when given, names must match up\n(string first, string last) t8 = (last: \"Doe\", first: \"John\");   // fine, values assigned according to name\n```\n\n----------------------------------------\n\nTITLE: Initializing a C# 14 array\nDESCRIPTION: This code snippet demonstrates an attempt to initialize an array named `csharp14` with the elements `improvement1`, `improvement2`, and `improvement3`. This appears to be a hypothetical example showcasing desired language features for C# 14, possibly related to simplified array initialization syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-04-02.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar csharp14 = [improvement1, improvement2, improvement3]\n```\n\n----------------------------------------\n\nTITLE: Markdown Repository Link\nDESCRIPTION: Link to csharplang repository branch for standard proposals\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-11-specification-update.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n[branch in csharplang](https://github.com/dotnet/csharplang/tree/standard-proposals)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Erasure with ExtensionAttribute in C#\nDESCRIPTION: This snippet shows how type erasure would be implemented using an ExtensionAttribute with a string parameter to encode type information. It demonstrates the transformation from source code to metadata representation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-14.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// source\nvoid M(C<E<int>>)\n\n// metadata\nvoid M([ExtensionAttribute(\"E<int>\")] C<U>)\n```\n\n----------------------------------------\n\nTITLE: Ref Parameter Example in C# - ImmutableArray\nDESCRIPTION: Example showing ImmutableArray<T>.ItemRef method referenced in the discussion about struct method parameters and scoping rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-08-03.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nImmutableArray<T>.ItemRef(int index)\n```\n\n----------------------------------------\n\nTITLE: Mixing Implicit and Explicit Extensions in C#\nDESCRIPTION: These examples show scenarios where implicit and explicit extensions are mixed in a hierarchy, which is allowed but may be questionable in some cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension Base for object { }\nexplicit extension Derived for object : Base { }\n```\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit extension Base for object { }\nimplicit extension Derived for object : Base { } // why? this may be scoped in a namespace\n```\n\n----------------------------------------\n\nTITLE: Practical Implementation of 'key' Modifier with Constructor in C#\nDESCRIPTION: A more realistic example of the 'key' modifier that includes a constructor to initialize the get-only properties. This demonstrates how the simple concept requires significantly more boilerplate code in practice.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-11.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass C\n{\n    public key string Item1 { get; }\n    public string Item2 { get; }\n    public C(string item1, string item2)\n    {\n        Item1 = item1;\n        Item2 = item2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Primary Constructor Syntax in C#\nDESCRIPTION: Shows the basic syntax for a class with a primary constructor, where the constructor parameters are visible throughout the class body.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-27.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass MyClass(int x, int y)\n{\n    public int P => x + y;\n}\n```\n\n----------------------------------------\n\nTITLE: Workaround: Calling Default Constructor\nDESCRIPTION: Pre-C# 6.0 workaround for struct auto-property initialization by explicitly calling the default constructor using a constructor initializer. This initializes all fields to their default values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-6.0/struct-autoprop-init.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S \n{ \n    int X { get; set; } \n    int Y { get; set; } \n    public S(int x, int y) : this() \n    { \n        this.X = x; \n        this.Y = y; \n    } \n} \n```\n\n----------------------------------------\n\nTITLE: Struct Constructor Pattern Example\nDESCRIPTION: Example showing struct initialization patterns that may trigger warnings when a parameterless constructor is not explicitly defined but field initializers are present.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-12-15.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstruct S {\n    private int x = 1; // Field initializer\n    public S(int y) { } // Custom constructor\n}\n\nS s = new S(); // May trigger warning in future\n```\n\n----------------------------------------\n\nTITLE: Type Expression Matrix - Type System Features\nDESCRIPTION: A markdown table showing the relationship between different type categories and their expression forms (denoting, creating, matching) in C#. This demonstrates planned feature support across different data structures.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Type       | Denote                  | Create                       | Match                    |\n|------------|-------------------------|------------------------------|---------------------------|\n| General    | `T`                     | `new T()`, `new T { x = e }` | `T x`, `var x`, `*`      |\n| Primitive  | `int`, `double`, `bool` | `5`, `.234`, `false`         | `5`, `.234`, `false`     |\n| String     | `string`                | `\"Hello\"`                    | `\"Hello\"`                |\n| Tuple      | `(T1, T2)`              | `(e1, e2)`                   | `(P1, P2)`               |\n| Record     | `{ T1 x1, T2 x2 }`      | `new { x1 = e1, x2 = e2 }`   | `{ x1 is P1, x2 is P2 }` |\n| Array      | `T[]`                   | `new T[e]`, `{ e1, e2 }`     | `{ P1, P2 }`, `P1 :: P2` |\n| List       | ?                       | ?                            | ?                        |\n| Dictionary | ?                       | ?                            | ?                        |\n```\n\n----------------------------------------\n\nTITLE: Complex With-er Implementation with Parameter Tracking\nDESCRIPTION: Demonstrates a more complex implementation approach using boolean flags to track which parameters are being updated.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-29.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point(int X, int Y)\n{\n    public virtual Point With(bool[] provided, int X, int Y)\n    {\n        return new Point(provided[0] ? X : this.X, provided[1] ? Y : this.Y);\n    }\n}\nvar p2 = p1.With(new bool { false, true}, default, 2);\n```\n\n----------------------------------------\n\nTITLE: Required Ref Field Declaration - C#\nDESCRIPTION: Example showing potential syntax for declaring a required ref field in C#. This demonstrates one possible way to enforce ref assignment to a field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-05-23.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nrequired ref int Field;\n```\n\n----------------------------------------\n\nTITLE: Inferred Type Arguments in Invocation with Roles in C#\nDESCRIPTION: This snippet explores the challenges of type inference when using roles, particularly with interface constraints. It raises questions about how type tests (`is IEnumerable<int>`) and the erasure of role types into underlying types are handled in phase 2.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nMyStruct m = new();\nref MyRole r = ref myStruct;\nvar x = M(ref r); // T is MyStruct /* MyRole */\nvar y = M2(ref r); // In phase 2, T would be MyRole, would we change what is emitted for calling M from phase 1?\n\nref T M<T>([Unscoped] ref T t) => ref t;\n\nref T M2<T>([Unscoped] ref T t) where T : IEnumerable<int> => ref t;\n\nref T M3<T>([Unscoped] ref T t)\n{\n    // problem with erasure\n    if (t is IEnumerable<int> i) ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Interface Equality with Reference Equality\nDESCRIPTION: Example showing how equality between interface instances would still use reference equality despite the declaration of static virtual equality operators in the interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-06-06.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar result = i1 == i2; // Reference equality\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default with method invocation in C#\nDESCRIPTION: Using default literal to avoid typing redundant type information when passing default values to methods. The type is inferred from the method parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nM(default)\n```\n\n----------------------------------------\n\nTITLE: Reference Local Declaration Examples in C#\nDESCRIPTION: Examples showing how ref locals are disambiguated based on the initializer expression type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/declaration-expressions.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nF(ref int x = IntFunc());    // int x;\nF(ref int y = RefIntFunc()); // ref int y;\n```\n\n----------------------------------------\n\nTITLE: String Interpolation with Embedded Local Function in C#\nDESCRIPTION: Complex example showing a string-interpolated JSON literal containing an embedded local function that generates and serializes an enumerable sequence.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nreturn $@\"\"\"hello\"\": \"\"world\"\"\\n          ... // 30 lines of other stuff\\n          \"\"list\"\" : { (\\n              IEnumerable<int> GetValues() {\\n                  ... yield return ...\\n              };\\n              JsonConvert.SerializeObject(GetValues())) }\";\n```\n\n----------------------------------------\n\nTITLE: Defining FixedSizeArray2 Struct in C#\nDESCRIPTION: This snippet demonstrates the definition of a struct with an inline fixed size array for use with params arguments. It requires the type to be defined with pseudo-code syntax to indicate in-line array support, potentially relying on future support from BCL for managed fixed size arrays.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/params-improvements/PI-2022-11-03.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstruct FixedSizeArray2<T>\n{\n    public T[2] Array; // pseudo-code for inline array\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression Null Checking in C#\nDESCRIPTION: Shows how the !! operator can be used with lambda expressions for null checking.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid G() {\n    // An identity lambda which throws on a null input\n    Func<string, string> s = x!! => x;\n}\n```\n\n----------------------------------------\n\nTITLE: Required Members Interaction with Params Parameters\nDESCRIPTION: Example demonstrating the interaction between required members and params parameters in collections. Shows validation of required members against the constructor used for params parameter eligibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MyCollection1 : IEnumerable<long>\n{\n    IEnumerator<long> IEnumerable<long>.GetEnumerator() => throw null;\n    IEnumerator IEnumerable.GetEnumerator() => throw null;\n    public void Add(long l) => throw null;\n\n    public required int F; // Collection has required member and constructor doesn't initialize it explicitly\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Test(2, 3); // error CS9035: Required member 'MyCollection1.F' must be set in the object initializer or attribute constructor.\n    }\n\n    // Proposal: An error is reported for the parameter indicating that the constructor that is required\n    // to be available doesn't initialize required members. In other words, one is able\n    // to declare such a parameter under the specified conditions.\n    static void Test(params MyCollection1 a)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing GitHub Discussion on Required Properties in C#\nDESCRIPTION: A markdown link to the GitHub discussion thread about the Required Properties proposal in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-07.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://github.com/dotnet/csharplang/discussions/4209\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression Grammar in C#\nDESCRIPTION: The current grammar for lambda expressions in C#, which already considers modifiers with identifiers to be syntactically legal.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/simple-lambda-parameters-with-modifiers.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nlambda_expression\n  : modifier* identifier '=>' (block | expression)\n  | attribute_list* modifier* type? lambda_parameter_list '=>' (block | expression)\n  ;\n\nlambda_parameter_list\n  : lambda_parameters (',' parameter_array)?\n  | parameter_array\n  ;\n\nlambda_parameter\n  : identifier\n  | attribute_list* modifier* type? identifier default_argument?\n  ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Tuple Equality in C#\nDESCRIPTION: Describes the chosen approach for implementing tuple equality using element-wise comparisons and boolean conversions. The method aims to handle various comparison scenarios and dynamic types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-02-07.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n(bool)(tempA == tempC) && (bool)(tempB == tempD)\n```\n\nLANGUAGE: C#\nCODE:\n```\n!(tempA == tempC).false && !(tempB == tempD).false\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression Method Resolution Example\nDESCRIPTION: Demonstrates method overload resolution with conditional expressions showing the difference between calling M with short and long parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-conditional-expression.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nM(b ? 1 : 2);\n\nvoid M(short);\nvoid M(long);\n```\n\n----------------------------------------\n\nTITLE: Defining Type Patterns in ANTLR Grammar for C#\nDESCRIPTION: This ANTLR grammar snippet defines the syntax for type patterns in C# 9.0, allowing types to be used as patterns in pattern matching expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nprimary_pattern\n    : type-pattern\n    | // all of the existing forms\n    ;\ntype_pattern\n    : type\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Params and Scoped Parameters in Method Overrides\nDESCRIPTION: Example showing the interaction between params and scoped modifiers in base and derived class method overrides. Illustrates the requirement to explicitly state either params or scoped in overrides when the original definition has a scoped parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nclass Base\n{\n    internal virtual Span<int> M1(scoped Span<int> s1, params Span<int> s2) => throw null!;\n}\n\nclass Derived : Base\n{\n    internal override Span<int> M1(Span<int> s1, // Error, missing `scoped` on override\n                                   Span<int> s2  // Proposal: Error: parameter must include either `params` or `scoped`\n                                  ) => throw null!;\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting Grammar for Checked User-Defined Operators in C#\nDESCRIPTION: This snippet presents a revised grammar definition for user-defined operators, introducing the 'checked' keyword. The update allows operators to handle overflow behavior explicitly by supporting checked and unchecked contexts. Dependencies include the C# standard upon which these grammar definitions are based.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/checked-user-defined-operators.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\noverloadable_unary_operator\n    : '+' | 'checked'? '-' | '!' | '~' | 'checked'? '++' | 'checked'? '--' | 'true' | 'false'\n    ;\n\noverloadable_binary_operator\n    : 'checked'? '+'   | 'checked'? '-'   | 'checked'? '*'   | 'checked'? '/'   | '%'   | '&'   | '|'   | '^'   | '<<'\n    | right_shift | '=='  | '!='  | '>'   | '<'   | '>='  | '<='\n    ;\n    \nconversion_operator_declarator\n    : 'implicit' 'operator' type '(' type identifier ')'\n    | 'explicit' 'operator' 'checked'? type '(' type identifier ')'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Potential Breaking Change Example\nDESCRIPTION: Demonstrates a potential breaking change scenario with method calls on conditional expressions returning value types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-01.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n(cond ? v1 : v2).M(...);\n```\n\n----------------------------------------\n\nTITLE: Invalid Empty Collection Example\nDESCRIPTION: Demonstrates an illegal use of empty collection literal without a target type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/collection-expressions.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar v = []; // illegal\n```\n\n----------------------------------------\n\nTITLE: Comparing Conditional Ref vs Explicit Ref Locals for Nullability Tracking in C#\nDESCRIPTION: Contrasting example showing how assigning null through conditional expressions differs from using explicit ref locals in terms of nullability warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstring? x = \"\";\nstring? y = \"\";\nif (b)\n{\n    ref string? rx = ref x;\n    rx = null;\n}\nelse\n{\n    ref string? ry = ref y;\n    ry = null;\n}\nx.ToString(); // no warning\ny.ToString(); // no warning\n```\n\n----------------------------------------\n\nTITLE: Specifying Access Modifier Restrictions for Struct Members in C#\nDESCRIPTION: This code snippet explains the limitations on access modifiers for struct members in C#. It states that certain access modifiers cannot be used with struct members due to the lack of inheritance support for structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/private-protected.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nSince inheritance isn't supported for structs, the declared accessibility of a struct member cannot be protected, **private protected**, or protected internal.\n```\n\n----------------------------------------\n\nTITLE: Anonymous Type Field Nullability Example in C#\nDESCRIPTION: Simplified example showing how nullability should be tracked when assigning variables with different nullability to anonymous type fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-06.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string x, string? y)\n{\n    var a = new { x };\n\n    a = new { x = y };\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Synthesized Record Property Initialization in C#\nDESCRIPTION: Example of how synthesized record properties are initialized using property initializers, equivalent to the compact record syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-06-01.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nrecord Point(int X, int Y)\n{\n    public int X { get; init; } = X;\n    public int Y { get; init; } = Y;\n}\n```\n\n----------------------------------------\n\nTITLE: NotNull Parameter Declaration\nDESCRIPTION: Method signature showing the use of NotNull attribute on string parameter, demonstrating parameter state tracking behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-11-04.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M([NotNull] string s)\n```\n\n----------------------------------------\n\nTITLE: Extension Declarations with Separate Underlying Types (C#)\nDESCRIPTION: This C# code snippet illustrates how the classic extension methods would be declared if using the base design for extension declarations, which requires separating extension declarations by underlying type. This approach leads to multiple extension declarations, one for each of `SyntaxToken`, `SyntaxTrivia`, `SyntaxNode?`, `SyntaxNodeOrToken`, and `SyntaxNode` . It showcases the verbosity that the proposal aims to address.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class CSharpExtensions\n{\n    extension(SyntaxToken)\n    {\n        public bool IsKind(SyntaxKind kind) => ...;\n    }\n    \n    extension(SyntaxTrivia)\n    {\n        public bool IsKind(SyntaxKind kind) => ...;\n    }\n    \n    extension(SyntaxNode?)\n    {\n        [param: NotNullWhen(true)]\n        public bool IsKind(SyntaxKind kind) => ...;\n    }\n    \n    extension(SyntaxNodeOrToken)\n    {\n        public bool IsKind(SyntaxKind kind) => ...;\n    }\n    \n    extension(SyntaxNode)\n    {\n        public bool ContainsDirective(SyntaxKind kind) => ...;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Async Main Method with Return\nDESCRIPTION: Shows transformation of async example with return into Program class with Task<int> return type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\npartial class Program\n{\n    static async Task<int> $Main(string[] args)\n    {\n        await System.Threading.Tasks.Task.Delay(1000);\n        System.Console.WriteLine(\"Hi!\");\n        return 0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Unit Type Return Syntax in C#\nDESCRIPTION: Example of potential syntax for methods returning unit type (zero-element tuple).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n() M(...) => ();\n```\n\n----------------------------------------\n\nTITLE: Parenthesized Pattern Matching in C#\nDESCRIPTION: Example showing how parentheses affect type inference in or patterns\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-08.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nif (o is ((Derived1 or Derived2) or Base { ... }))\n```\n\n----------------------------------------\n\nTITLE: Basic nameof Parameter Usage in C#\nDESCRIPTION: Demonstrates using nameof operator with a parameter in a method. Shows how nameof returns the string name of the parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nvoid f(int x) {\n   nameof(x)\n}\n// result \"x\": Parameter (simple name lookup)\n```\n\n----------------------------------------\n\nTITLE: Optimized Nested Type Encoding for Extensions in C#\nDESCRIPTION: Shows potential optimizations for the nested type approach, including sharing methods and removing unnecessary parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-07.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n    private class Secret\n    {\n        // More parameter cause more methods, but we can share\n        E<T, U1> Method1<U1> where U1 : IDisposable { }\n        E<T, U1> Method1<U2> where U1 : IDisposable { }\n    }\n```\n\nLANGUAGE: csharp\nCODE:\n```\n    private class Secret\n    {\n        void Method1<U1>(E<T, U1> p0 /*, Secret x */) where U1 : IDisposable\n    }\n```\n\n----------------------------------------\n\nTITLE: Iterator Lambda Example in C#\nDESCRIPTION: Demonstrates iterator implementation using lambda expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-05-20.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvar f = (int x, int c) => { for (int i = 0; i < c; i++) { yield return x; } }; // default to IEnumerable<T>?\n```\n\n----------------------------------------\n\nTITLE: Proposing Changes to Interpolated Strings - C#\nDESCRIPTION: This code snippet demonstrates the current limitation with interpolated strings in C#, where interpolation expressions cannot span multiple lines. It highlights an example where the user attempts to create a complex interpolation that exceeds the current single-line requirement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/new-line-in-interpolation.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar v = $\"Count is\\t: { this.Is.A.Really(long(expr))\n                            .That.I.Should(\n                                be + able)[\n                                    to.Wrap()] }.\";\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Nullable Reference Types\nDESCRIPTION: Example of using pattern matching to safely work with nullable reference types by introducing a non-null variable when the value is not null.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-10-17.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nstring? ns = ...;\nif (ns is string! s) // introduces non-null variable s\n{\n    var l = s.Length;\n    var c = s[3];\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring AsyncMethodBuilderAttribute in Runtime\nDESCRIPTION: Defines the updated AsyncMethodBuilderAttribute with support for method-level targeting, enabling custom async method builder configuration\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/async-method-builders.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.Delegate | AttributeTargets.Enum, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncMethodBuilderAttribute : Attribute\n    {\n        public AsyncMethodBuilderAttribute(Type builderType) => BuilderType = builderType;\n        public Type BuilderType { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Class Hierarchy with Nullable Reference Types in C#\nDESCRIPTION: This code snippet shows a class hierarchy across multiple assemblies, demonstrating how nullable reference types and the '!!' operator interact in method overrides.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Assembly1\nabstract class C1 {\n    protected abstract void M(object o); \n}\n\n// Assembly2\nabstract class C2 : C1 {\n\n}\n\n// Assembly3\nabstract class C3 : C2 { \n    protected override void M(object o!!) {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Delegate Type Argument Examples in C#\nDESCRIPTION: Examples of proposed delegate type declarations with relaxed type argument restrictions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-10-25.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nAction<void>\nAction<in int, ref readonly Span<char>>\nFunc<T, bool>\n```\n\n----------------------------------------\n\nTITLE: UTF-8 String Literal Example in C#\nDESCRIPTION: Example showing potential syntax for UTF-8 string literals using the u8 suffix. This is a proposed feature being discussed for implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-10-27.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar myStr = \"Hello world\"u8;\n```\n\n----------------------------------------\n\nTITLE: Proposed Collection Expression Syntax for ReadOnlySpan<T> in C#\nDESCRIPTION: Illustrates the proposed syntax for using collection expressions with ReadOnlySpan<T>, which needs semantic clarification.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-03.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nReadOnlySpan<int> x4 = [a, b, c];\n```\n\n----------------------------------------\n\nTITLE: Basic Immutable Point Implementation Without Init\nDESCRIPTION: Traditional implementation of an immutable Point struct using readonly fields and constructor pattern, showing the verbose boilerplate required.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstruct Point\n{\n    public int X { get; }\n    public int Y { get; }\n\n    public Point(int x, int y)\n    {\n        this.X = x;\n        this.Y = y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Standard String Interpolation Example\nDESCRIPTION: Example showing conventional string interpolation syntax for comparison.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-19.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n$\"{ConditionallyEvaluated()}\"\n```\n\n----------------------------------------\n\nTITLE: Extension Members Declaration in C#\nDESCRIPTION: This code demonstrates the declaration of extension members within a static class using the `extension` keyword.  It shows how extension members are grouped by underlying type and type parameters. The code also illustrates the use of `this` to refer to the underlying value within the extension member's implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic static class Enumerable\n{\n    // Extension members for IEnumerable\n    extension(IEnumerable)\n    {\n        // 'this' refers to underlying value\n        public bool IsEmpty => !this.GetEnumerator().MoveNext();\n    }\n    // Extension members for IEnumerable<T>\n    extension<T>(IEnumerable<T>)\n    {\n        public IEnumerable<T> Where(Func<T, bool> predicate) { ... }\n        public IEnumerable<TResult> Select<TResult>(Func<T, TResult> selector) { ... }\n        public static IEnumerable<T> operator +(IEnumerable<T> e1, IEnumerable<T> e2) { ... }\n    }\n    \n    // Classic extension method\n    public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source) { ... }\n    \n    // Non-extension member\n    public static IEnumerable<int> Range(int start, int count) { ... } \n\n}\n```\n\n----------------------------------------\n\nTITLE: IEnumerable with Collection Expression in C#\nDESCRIPTION: Explores the semantics of assigning a collection expression to a non-generic `IEnumerable` interface. It presents three possible approaches: using the natural type, treating it as `IEnumerable<object>`, or a hybrid approach with `IEnumerable<int>`. The different approaches affect type safety and boxing behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2024-01-23.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nThere is an open question on what the (currently illegal) semantics should be for `IEnumerable x = [1, 2, 3];`\n\nThere are a few paths we could conceivably take here.\n\n- Have no special behavior for this, and allow 'natural type' to take care of it.  If, for example, the natural type of `[1, 2, 3]` was `List<int>` then this would be equivalent to: `IEnumerable x = (List<int>)[1, 2, 3];`.  Note that this would then be making a mutable collection under the covers, strongly typed to 'int'.\n\n- Treat the non-generic interfaces as the generic versions with 'object'.  In this case, that would mean the above would be equivalent to: `IEnumerable x = (IEnumerable<object>)[1, 2, 3];`.  This would then mean the compiler would synthesize the read-only collection, but also that every element would be boxed as object.\n\n- A hybrid approach where the element type might be picked using whatever natural-type system we had, but the collection type itself was the generic interface.  In this case, that would mean the above would be equivalent to: `IEnumerable x = (IEnumerable<int>)[1, 2, 3];`, This would then mean the compiler would synthesize the read-only collection, and also that every element would be non-boxed in the underlying storage.\n```\n\n----------------------------------------\n\nTITLE: Implementing Constant Interpolated String in C#\nDESCRIPTION: Example showing the proposed syntax for constant interpolated strings, which would allow using the $ prefix with constant strings even without substitutions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-11-11.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nconst string s = $\"abc\";\n```\n\n----------------------------------------\n\nTITLE: Handling Ambiguity in HashSet Constructor Overloads in C#\nDESCRIPTION: This snippet addresses the potential ambiguity when a HashSet has multiple constructor overloads, one for IEnumerable<T> and another for ReadOnlySpan<T>, proposing the need for clearer overload resolution rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-06-12.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class HashSet<T>\n{\n    // existing constructor\n    public HashSet(IEnumerable<T> values);\n\n    // newly added\n    public HashSet(ReadOnlySpan<T> values);\n}\n\n// code:\nnew HashSet<int>(new int[] { 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: Problematic C# 6 Usage of Nullable Types\nDESCRIPTION: Example of code in C# 6 that would cause runtime issues by ignoring the nullability annotations, demonstrating why C# 7 can't fully enforce non-null constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-10-17.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar l = C.M(null).Length;\n```\n\n----------------------------------------\n\nTITLE: Proposed Self Constraint Syntax\nDESCRIPTION: New syntax proposal for self constraint using 'this' keyword in generic type parameter declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/self-constraint.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IAdditionOperators<this TSelf, TOther, TResult>\n{\n    static abstract TResult operator +(TSelf left, TOther right);\n}\n\ninterface IAdditiveIdentity<this TSelf>\n{\n    static abstract TSelf AdditiveIdentity { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Extension Methods with Member-Based Approach in C#\nDESCRIPTION: This snippet demonstrates how to declare an extension method in a member-based approach, allowing compatibility with classic extension methods while introducing a new syntax. The method 'AsSpan' converts an array to a Span type, showcasing the generic nature of the extension.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic extensions MemoryExtensions\n{\n    public Span<T> (T[]? array).AsSpan<T>();\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Extensions with Attribute-Based Nullability in C#\nDESCRIPTION: Demonstrates how using attributes with a 'this' target could allow extension members on nullable and non-nullable versions of the same type to be grouped together in a single extension declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic extension StringExtension for string\n{\n    [this:AllowNull][this:NotNullWhen(false)] public bool IsNullOrEmpty => this is null or [];\n    public string Reverse() => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid UTF16 String Conversion Example in C#\nDESCRIPTION: Demonstration of error handling when attempting to convert malformed UTF16 string constants to UTF8 byte sequences.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\nconst string text = \"hello \\uD801\\uD802\";\nbyte[] bytes = text; // Error: the input string is not valid UTF16\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fixed Buffer Local Syntax in C#\nDESCRIPTION: This snippet illustrates the syntax for fixed buffer locals in C#, which is described as attractive and potentially applicable to fields without the 'fixed' keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-10-12.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint[] array[10]\n```\n\n----------------------------------------\n\nTITLE: Collection Type Conversion Example in C#\nDESCRIPTION: Demonstration of conversion behavior between IReadOnlyList<object> and IEnumerable<string>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-09-20.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstatic void B(IReadOnlyList<object> e) => Console.WriteLine(\"List<object>\");\nstatic void B(IEnumerable<string> e) => Console.WriteLine(\"IEnumerable<string>\");\n\nB(new List<string>() { \"one\", \"two\" });\n```\n\n----------------------------------------\n\nTITLE: Original Proposed Function Pointer Syntax in C#\nDESCRIPTION: The initially proposed syntax for function pointers that was found to have exponential parsing behavior in nested cases.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-10-30.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nfunc*(int, int)\n```\n\n----------------------------------------\n\nTITLE: Non-Expression Types Not Allowed in nameof\nDESCRIPTION: List of language elements that are not expressions in C# grammar and therefore cannot be used as arguments to the nameof operator. This includes type names, qualified aliases, and the void keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n    predefined-type              int, bool, float, object,\n                                 dynamic, string\n    nullable-type                Customer?\n    array-type                   Customer[,]\n    pointer-type                 Buffer*, void* \n    qualified-alias-member       A::B\n    void                         void\n    unbound-type-name            Dictionary<,>\n```\n\n----------------------------------------\n\nTITLE: Value Equality Pattern Implementation\nDESCRIPTION: Discussion of implementing value equality through either 'key' or 'value' modifiers, including equality contract inheritance and operator overloading considerations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-03.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IEquatable<T> // Referenced in discussion about additional equality members\n```\n\n----------------------------------------\n\nTITLE: Lowered Extension Member with Attribute in C#\nDESCRIPTION: This snippet shows the lowered form of the extension member with the `NotNull` attribute. Note that the attribute is correctly applied to the `__this` parameter. This demonstrates how attributes are propagated during the lowering process.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_10\n\nLANGUAGE: c#\nCODE:\n```\npublic static class NullableExtensions\n{\n    public static class __E1<__T1> where T1__ : class\n    {\n        public static void ThrowIfNull([NotNull] __this) => ArgumentNullException.ThrowIfNull(__this);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Experimental Expression Trees Implementation\nDESCRIPTION: Reference to an experimental implementation of extended expression trees that supports features like dynamic, async, null-conditional operators, and discards up to C# 6.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-06.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ngithub.com/bartdesmet/ExpressionFutures/tree\n```\n\n----------------------------------------\n\nTITLE: Alternative Range Syntax Examples\nDESCRIPTION: Shows potential alternative syntax for range operations in containment and iteration scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-01-22.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nbool b = x is in 3 to 5;\nforeach (var x in 0 to 100) { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Role Syntax with Underlying Type and Interfaces in C#\nDESCRIPTION: This code snippet shows the syntax for defining a role in C# with an underlying type, various base roles, and interfaces. It's presented as an example with the potential complexity of mixing roles and interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-02-15.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nrole R : UnderlyingType, BaseRole1, Interface1, BaseRole2, Interface2\n```\n\n----------------------------------------\n\nTITLE: Constructor Parameter Inheritance Example in C#\nDESCRIPTION: Illustrates the complexity of constructor parameter handling with inheritance, property hiding, and virtual properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-10-21.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class Base {\n    public object Prop1 { get; set; }\n    public virtual object Prop2 { get; set; }\n    public Base(Prop1, Prop2) { Prop2 = 1; }\n}\n\npublic class Derived : Base\n{\n    public new string Prop1 { get; set; }\n    public override object Prop2 { get; set; }\n    public Derived(Prop1, Prop2) : base(Prop1, Prop2) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative NativeInt Structure Implementation\nDESCRIPTION: Example of an alternative implementation approach using a distinct NativeInt structure instead of type erasure. This approach was not chosen due to efficiency concerns and potential interop complications.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/native-integers.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic readonly struct NativeInt\n{\n    public IntPtr Value;\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Interceptor Call Syntax Example\nDESCRIPTION: Hypothetical syntax for calling an intercepted method, demonstrating a potential syntax with a sigil character\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-02-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ncontroller.MapGet#(\"/\", CreateFeed)\n```\n\n----------------------------------------\n\nTITLE: Async Top-level Example in C#\nDESCRIPTION: Shows a simple async top-level program using Task.Delay.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nawait System.Threading.Tasks.Task.Delay(1000);\nSystem.Console.WriteLine(\"Hi!\");\n```\n\n----------------------------------------\n\nTITLE: Equivalent Lazy Initialization with Traditional Backing Field\nDESCRIPTION: Shows the equivalent implementation of the lazy initialization example with a traditional named backing field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n// No 'field' symbol in scope.\npublic class Point\n{\n    private string __value;\n    public string Value { get { return __value ??= ComputeValue(); } }\n    private static string ComputeValue() { /*...*/ }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Inheritance Constructor\nDESCRIPTION: Shows the generated constructor code for a derived class using primary constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nclass B\n{\n    // ..\n    public B(int x, int y, int z)\n    : base(x, y)\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Reference Type Nullability Alias Example\nDESCRIPTION: Example of a disallowed using alias declaration for a nullable string type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-01-11.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing NullableString = string?;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Extension Properties in C#\nDESCRIPTION: Defines ANTLR grammar rules for declaring static and instance extension properties. This snippet outlines the structure required to declare these properties in an extension container, providing a framework to extend property functionality in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_7\n\nLANGUAGE: antlr\nCODE:\n```\nextension_property_declaration\n    : attributes? property_modifier* type extension_property_header property_body\n    | attributes? property_modifier* ref_kind type extension_property_header ref_property_body\n    ;\n    \nextension_property_header\n    : receiver_parameter '.' name\n    ;\n\n```\n\n----------------------------------------\n\nTITLE: Generated Implementation Code for Extension Declarations in C#\nDESCRIPTION: The emitted IL code for the extension declarations, showing how extension methods and properties are implemented as static methods with the [Extension] attribute and appropriate skeletal classes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[Extension]\nstatic class IEnumerableExtensions\n{\n    public class <>E__1<T>\n    {\n        private static <Extension>$(IEnumerable<T> source) => throw null;\n        public void Method() => throw null;\n        internal static int Property { get => throw null; set => throw null; }\n        public int Property2 { get => throw null; set => throw null; }\n    }\n\n    public class <>E__2\n    {\n        private static <Extension>$(IAsyncEnumerable<int> values) => throw null;\n        public Task<int> SumAsync() => throw null;\n    }\n\n    // Implementation for Method\n    [Extension]\n    public static void Method<T>(IEnumerable<T> source) { ... }\n\n    // Implementation for Property\n    internal static int get_Property<T>() { ... }\n    internal static void set_Property<T>(int value) { ... }\n\n    // Implementation for Property2\n    public static int get_Property2<T>(IEnumerable<T> source) { ... }\n    public static void set_Property2<T>(IEnumerable<T> source, int value) { ... }\n\n    // Implementation for SumAsync\n    [Extension]\n    public static int SumAsync(IAsyncEnumerable<int> values) { ... }\n\n    public static void Method2() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Expression Reference\nDESCRIPTION: Reference to the await keyword in discussion about expression tree limitations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-18.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nawait\n```\n\n----------------------------------------\n\nTITLE: Illustrating method group ambiguity with address-of in C#\nDESCRIPTION: This code demonstrates how method group ambiguity is handled when using the address-of operator. It shows both error cases and valid usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intrinsics.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass Util { \n    public void Log() { } \n    public void Log(string p1) { } \n    public static void Log(int i) { };\n}\n\nunsafe {\n    // Error: Method group Log has more than one applicable candidate.\n    void* ptr1 = &Log; \n\n    // Okay: only one static member to consider here.\n    void* ptr2 = &Util.Log;\n}\n```\n\n----------------------------------------\n\nTITLE: IFormattable ToString Implementation in C#\nDESCRIPTION: Demonstrates the IFormattable interface implementation used for custom string formatting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nIFormattable.ToString(string format, IFormatProvider formatProvider)\n```\n\n----------------------------------------\n\nTITLE: Defining Extension Declarations and Modifiers - ANTLR\nDESCRIPTION: This ANTLR syntax defines the structure for extension declarations in C#, including how to specify modifiers, types, and member declarations. It aims to create a syntax for both type-based and member-based extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/compromise-design-for-extensions.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nextension_declaration\n    : attributes? extension_modifier* 'partial'? 'extension' identifier\n        type_parameter_list? for_clause? type_parameter_constraints_clause*\n        extension_body ';'?\\n    ;\\n    \nextension_modifier\n    : 'new'\n    | 'public'\n    | 'protected'\n    | 'internal'\n    | 'private'\n    | 'sealed'\n    | 'static'\n    | unsafe_modifier   // unsafe code support\\n    ;\\n    \nfor_clause\n    : 'for' attributes? extension_mode_modifier? type\\n    ;\\n    \nextension_mode_modifier:\n    | 'ref'\n    | 'ref readonly'\n    | 'in'\n    ;\\n    \nextension_body\n    : '{' extension_member_declaration* '}\\n    ;\\n    \nextension_member_declaration\n    : constant_declaration\\n    | field_declaration\\n    | extension_method_declaration\\n    | extension_property_declaration\\n    | extension_event_declaration\\n    | extension_indexer_declaration\\n    | operator_declaration\\n    | constructor_declaration\\n    | static_constructor_declaration\\n    | type_declaration\\n    ;\n```\n\n----------------------------------------\n\nTITLE: Interface Implementation Diamond Problem\nDESCRIPTION: Example showing the diamond problem with multiple interface inheritance and default implementations, demonstrating how base calls need to be disambiguated.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-08.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M() { WriteLine(\"1\"); } }\ninterface I2 : I1 { override void M() { WriteLine(\"2\"); } }\ninterface I3 : I1 { override void M() { WriteLine(\"3\"); } } \ninterface I4 : I2, I3 { override void M() { base(I2).M(); } }\n```\n\n----------------------------------------\n\nTITLE: Read-only Property with Throw in C#\nDESCRIPTION: Property with field getter and setter that throws exception\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n{ get => field; set => throw new InvalidOperationException(); }\n```\n\n----------------------------------------\n\nTITLE: Primary Constructor Struct with Field Initialization\nDESCRIPTION: Example of a struct using a primary constructor pattern where field initializers reference constructor parameters, highlighting challenges with generating a parameterless constructor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nstruct Name(string first, string last)\n{\t\n\tstring first = first;\n\tstring last = last;\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax Options for Type Inference in C#\nDESCRIPTION: This snippet lists the potential syntax options for type inference in C#, indicating characters that could represent type parameters. The list includes '_', 'var', '', '..', '*', and '__'. This is part of the discussion about enhancing type inference capabilities.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-22.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n- `_` (underscore)\n- `var`\n- `` (empty)\n- `..`\n- `*`\n- `__`\n```\n\n----------------------------------------\n\nTITLE: Target-Typed Object Creation Without Specifying Type in C#\nDESCRIPTION: Examples of a proposed feature allowing the omission of the type in an object creation expression when it can be inferred from the target type, working with different constructor patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-05-03-04.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nPoint p = new (3, 4); // Same as new Point(3, 4)\nList<string> l1 = new (10); // Works for 0 or 1 argument\nList<int> l2 = new (){ 3, 4, 5 }; // Works with object/collection initializers, but must have parens as well.\n```\n\n----------------------------------------\n\nTITLE: Assigning to Method Call Return Value in C#\nDESCRIPTION: Demonstrates a potential syntax for assigning a value to a method call return, which could be possible if ref returns are implemented. This raises questions about the implications of returning variables instead of values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nm(x, y) = 5;\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression with Explicit Capture List in C#\nDESCRIPTION: Demonstrates a proposed syntax for lambda expressions with explicit capture lists. This feature would allow developers to specify exactly which variables from the enclosing scope should be captured by the lambda.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nvar name = GetName();\nvar query = customers.Where([name]c => c.Name == name);\n```\n\n----------------------------------------\n\nTITLE: Complex Switch Expression Examples\nDESCRIPTION: Various examples showing switch expression usage with different operators and contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-13.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nx + e switch {} * y\n\n((x + e) switch {}) * y\n\n_ = await e switch { ... };\n\n_ = a ?? (b switch {\n            ...\n          });\n\n_ = (a ?? b) switch {\n            ...\n            };\n\n_ = a ?? b switch {\n        ...\n        };\n\n_ = 1 + o switch { int i => i, _ => 0 };\n\n_ = a && b ? c : d;\n\n_ = a ? b : d ? e : f;\n\n_ = (string)s switch { ... };\n\n_ = -x switch { ... };\n\n_ = await x switch { ... };\n```\n\n----------------------------------------\n\nTITLE: Markdown List Entry for field Keyword\nDESCRIPTION: Code reference showing the field keyword usage in markdown context, related to semi-auto properties and struct initialization discussions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/README.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n`field`\n```\n\n----------------------------------------\n\nTITLE: Conditional Ref Example\nDESCRIPTION: Example showing how readonly status affects method calls on conditional ref expressions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-09-27.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(bool b, in x, ref y)\n{\n    (b ? ref x : ref y).M(); // M is always called on a copy, even if b is false\n}\n```\n\n----------------------------------------\n\nTITLE: Postfix Increment/Decrement Operator Examples with Value Types\nDESCRIPTION: Examples of postfix increment operations with value types, showing behavior with structs and various property access patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/user-defined-compound-assignment.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nvar a = (new S())++; // error: not a variable\nvar b = S.P2++; // var temp = S.get_P2(); S.set_P2(S.op_Increment(temp)); b = temp;\nS.P2++; // var temp = S.get_P2(); S.set_P2(S.op_Increment(temp));\nb++; // b.op_Increment(); \nvar d = S.P1++; // error: set is missing\nS.P1++; // error: missing setter\nvar e = b++; // var temp = b; b = S.op_Increment(temp); e = temp; \n\nstruct S\n{\n    public static S P1 { get; } = new S();\n    public static S P2 { get; set; } = new S();\n\n    public static S operator ++(S x) => ...; \n    public void operator ++() => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaration Expression Scope Rules in Guard Clauses\nDESCRIPTION: Example demonstrating how declaration expressions in guard clauses would not work with the decided scope rules, since variables declared within an if statement would be scoped only to that statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-12-16.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nif (!int.TryParse(s, out int i)) return false; // or throw, etc.\nâ€¦ // code ideally consuming i\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Unconstrained Type Parameter Annotation in C#\nDESCRIPTION: Demonstrates the basic syntax for applying nullable annotation to an unconstrained type parameter in a generic method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nstatic T? FirstOrDefault<T>(this IEnumerable<T> collection) { ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Reference Type Warnings in C# Method Calls\nDESCRIPTION: Illustrates how nullable reference type warnings might appear in method calls and local variable assignments, highlighting potential issues with warning placement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-07-26.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(string s);\n\nM(p.MiddleName);\nstring s = p.MiddleName; // warning here\nM(s); // but the problem is really here\n```\n\n----------------------------------------\n\nTITLE: Defining Relational Patterns in ANTLR Grammar for C#\nDESCRIPTION: This ANTLR grammar snippet defines the syntax for relational patterns in C# 9.0, supporting comparison operators for pattern matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR\nCODE:\n```\nprimary_pattern\n    : relational_pattern\n    ;\nrelational_pattern\n    : '<' relational_expression\n    | '<=' relational_expression\n    | '>' relational_expression\n    | '>=' relational_expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Grammar Definition in ANTLR\nDESCRIPTION: Defines the ANTLR grammar rules for the enhanced switch statement syntax, including support for switch arms and pattern matching.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/enhanced-switch-statements.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nswitch_block\n    : '{' switch_section* '}'\n    | '{' switch_statement_arms ','? '}'\n    ;\n\nswitch_statement_arms\n    : switch_statement_arm\n    | switch_statement_arms ',' switch_statement_arm\n    ;\n\nswitch_statement_arm\n    : pattern case_guard? '=>' statement_expression\n    | pattern case_guard? '=>' block\n    ;\n```\n\n----------------------------------------\n\nTITLE: Constraint Language Example\nDESCRIPTION: Demonstration of current constraint syntax allowing ref struct with interface constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-07-22-ref-struct-interface-examples.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M<T>(T t) where T : IDisposable, allows ref struct { }\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Extension Properties in C#\nDESCRIPTION: Illustrates how to define multiple implicit extensions with the same property name and how to disambiguate between them when accessing the property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-08-09.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension StringExtension1 for string { public int Prop { get; set; } }\nimplicit extension StringExtension2 for string { public int Prop { get; set; } }\n\n\"\".Prop // how to disambiguate?\n((StringExtension1)\"\").Prop\n```\n\n----------------------------------------\n\nTITLE: Defining FixedSizeBuffer3<T> Struct for Stack Allocation in C#\nDESCRIPTION: Example of a ref struct with a fixed-size buffer that can be used for stack allocation of params arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nref struct FixedSizeBuffer3<T>\n{\n    public fixed T Items[3]; // pseudo-code for inline fixed size buffer\n}\n```\n\n----------------------------------------\n\nTITLE: Nullable Reference Types Syntax Example in C#\nDESCRIPTION: Conceptual code example showing potential syntax for nullable and non-nullable reference types, demonstrating how nullability checks would work in a hypothetical implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-04.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nstring? n; nullable string\nstring! s; non-nullable string\n\nn = null; // Sure; it's nullable\ns = null; // Error!\n\nWriteLine(s.Length); // Sure; it can't be null so no harm\nWriteLine(n.Length); // Error!\nif (n is string! ns) WriteLine(ns.Length); // Sure; you checked and dug out the value\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inaccurate Initial Flow State in C# Constructor\nDESCRIPTION: This snippet shows how the current approach leads to inaccurate initial flow state of members in a constructor. The code unexpectedly does not produce a 'possible null receiver' warning when accessing an uninitialized property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-constructor-analysis.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    public string Prop { get; set; }\n    public C() // we get no \"uninitialized member\" warning, as expected\n    {\n        Prop.ToString(); // unexpectedly, there is no \"possible null receiver\" warning here\n        Prop = \"\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Headers and Structure\nDESCRIPTION: The main structure and organization of the meeting notes, including agenda items and discussion sections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-09-28.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# C# Language Design Meeting for September 28th, 2022\n\n## Agenda\n\n- [Working set triage](#working-set-triage)\n    - [Discriminated Unions](#discriminated-unions)\n    - [Collection literals](#collection-literals)\n    - [Nullability improvements](#nullability-improvements)\n    - [Ungrouped](#ungrouped)\n```\n\n----------------------------------------\n\nTITLE: Breaking Change Example with Multiple Parameters\nDESCRIPTION: Illustrates a breaking change scenario where method overload resolution becomes ambiguous with multiple parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/target-typed-conditional-expression.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nM(b ? 1 : 2, 1); // calls M(long, long) without this feature; ambiguous with this feature.\n\nM(short, short);\nM(long, long);\n```\n\n----------------------------------------\n\nTITLE: Alternative Variable Declaration Approach\nDESCRIPTION: Shows the traditional approach to variable declaration that would be required instead of using declaration expressions in guard clauses.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-12-16.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nint i;\nif (!int.TryParse(s, out i)) return false; // or throw, etc.\nâ€¦ // code consuming i\n```\n\n----------------------------------------\n\nTITLE: Defining Global Using Static Directive in ANTLR\nDESCRIPTION: The 'global_using_static_directive' rule outlines how to import static members and nested types of a class directly into the program. This allows static members to be accessed without qualification, except for extension methods, which cannot be used as static methods directly but can still be invoked as extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/GlobalUsingDirective.md#2025-04-21_snippet_4\n\nLANGUAGE: antlr\nCODE:\n```\nglobal_using_static_directive\n    : 'global' 'using' 'static' type_name ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating address-of on static methods in C#\nDESCRIPTION: This snippet shows how to use the address-of operator on a static method to obtain a function pointer. It demonstrates the ldftn IL opcode usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intrinsics.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nclass Util { \n    public static void Log() { } \n}\n\n// ldftn Util.Log\nvoid* ptr = &Util.Log;\n```\n\n----------------------------------------\n\nTITLE: Container Ref Struct Example in C#\nDESCRIPTION: Demonstrates how readonly ref structs can store ref state through ref fields to ref structs, affecting method argument matching rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_41\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly ref struct Container\n{\n    readonly ref Span<int> Span;\n\n    void Store(Span<int> span)\n    {\n        Span = span;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lowering List Pattern '[3]' in C#\nDESCRIPTION: Example of lowering a simple list pattern that checks for a collection with exactly 3 elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/list-patterns-enumerables.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n@{\n  var helper = new ListPatternHelper(collection, 0, 0);\n\n  helper.Count() == 3\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Initialization with 'with' Keyword Examples\nDESCRIPTION: Examples showing how the with() syntax would be used to initialize various collection types with configuration arguments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n// With an existing type:\n\n// Initialize to twice the capacity since we'll have to add\n// more values later.\nList<string> names = [with(capacity: values.Count * 2), .. values];\n\n// With the dictionary types.\nDictionary<string, int> nameToAge1 = [with(comparer)];\nDictionary<string, int> nameToAge2 = [with(comparer), kvp1, kvp2, kvp3];\nDictionary<string, int> nameToAge3 = [with(comparer), k1:v1, k2:v2, k3:v4];\nDictionary<string, int> nameToAge4 = [with(comparer), .. d1, .. d2, .. d3];\n\nDictionary<string, int> nameToAge = [with(comparer), kvp1, k1: v2, .. d1];\n```\n\n----------------------------------------\n\nTITLE: Property Shadowing in Implicit Extensions in C#\nDESCRIPTION: This snippet demonstrates how property shadowing in derived implicit extensions can lead to ambiguity in property access.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension Base for object \n{\n    int Prop => 0;\n}\nimplicit extension Derived for object : Base\n{\n    new long Prop => 0; // warning so you put \"new\"\n}\n\nobject o = ...;\no.Prop; // ambiguity (this is an argument for pruning)\nderived.Prop; // would find Derived.Prop\n```\n\n----------------------------------------\n\nTITLE: Tuple Name Mismatch Example in C#\nDESCRIPTION: Example demonstrating a potential name mismatch warning scenario in tuple assignments where element names from the source and target don't match positionally.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-10-18.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n(int first, int last) M() ...\n\n(int last, int first) t = M(); // Oops!\n```\n\n----------------------------------------\n\nTITLE: Switch Expression Syntax Examples\nDESCRIPTION: Examples showing different syntax patterns for switch expressions including arrow syntax, block bodies, and pattern matching with when clauses.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-01-11.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ncase 1 => WriteLine(...);\ncase 2\n{\n\n}\n\ncase string s when (...)\n{\n   ...\n}\n```\n\n----------------------------------------\n\nTITLE: C# scoped Modifier Example with Method Return\nDESCRIPTION: Example showing invalid syntax for scoped modifier placement in method declaration, demonstrating that scoped should be applied directly to return or parameter values rather than as a general method modifier.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-07-27.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nscoped unsafe Span<int> M() => ...;\n```\n\n----------------------------------------\n\nTITLE: Example Static Extension Method with `out` Parameter in C#\nDESCRIPTION: This code snippet demonstrates a static extension method `M` with an `out` parameter. It highlights a potential issue where the type of the variable `e` and the compilation behavior are ambiguous due to the interaction of extension methods and type inference with `out` parameters. The example serves to illustrate the challenges in defining extension method lookup rules and maintaining consistency with existing C# behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-02-19.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar e = IEnumerable<string>.M(out object o); // What type is e? Does this line compile?\n\npublic static class Ext\n{\n    extension<T>(IEnumerable<T>)\n    {\n        public static IEnumerable<T> M(out T t) => ...;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Invoker Method for Lightweight Dynamic in C#\nDESCRIPTION: Example of a proposed invoker syntax for Lightweight Dynamic that allows instances to be invoked directly with parameters, similar to indexers but with round parentheses.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-21.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic int this(int x) { return x*x; } // allow instances to be invoked with ints\n```\n\n----------------------------------------\n\nTITLE: Constraint Inheritance Examples in C#\nDESCRIPTION: Demonstrates how constraints are handled in inheritance scenarios with both struct and class constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/unconstrained-type-parameter-annotations.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nclass A1\n{\n    public virtual void F1<T>(T? t) where T : struct { }\n    public virtual void F1<T>(T? t) where T : class { }\n}\n\nclass B1 : A1\n{\n    public override void F1<T>(T? t) /*where T : struct*/ { }\n    public override void F1<T>(T? t) where T : class { }\n}\n```\n\n----------------------------------------\n\nTITLE: Hypothetical Dot Operator Overload in C#\nDESCRIPTION: This code snippet demonstrates a hypothetical syntax for overloading the dot operator in C#. It's presented as an example of what might seem attractive but is ultimately problematic due to the fundamental nature of the dot operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-21.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic static JsonObject operator .(JsonObject receiver, string name) { â€¦ }\n```\n\n----------------------------------------\n\nTITLE: Scenarios for Property Implementation with 'field' Keyword in C#\nDESCRIPTION: Various examples showing different ways to implement a property setter that introduces a backing field that is never read, with the question of which should be allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_21\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    set\n    {\n        if (field == value) return;\n        field = value;\n        SendEvent(nameof(Prop), value);\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    get => unrelated;\n    set\n    {\n        if (field == value) return;\n        field = value;\n        SendEvent(nameof(Prop), value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Parameter Naming in Interface Method Overrides in C#\nDESCRIPTION: This snippet demonstrates the question of whether parameter names can be changed in interface method overrides. The conclusion was to use the names from the original declaration, differing from the class rule for simplicity.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-17.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1 { void M1(int a); }\n\ninterface I2 : I1 { override void M1(int b); } // allowed to change parameter names?\n\nI2 x;\nx.M(a: 3); // allowed?\nx.M(b: 4); // allowed?\n```\n\n----------------------------------------\n\nTITLE: Nullable Context Switch with Generic Inference\nDESCRIPTION: Demonstrates type inference behavior across nullable context switches.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-12-05.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n#nullable disable\nvar t = M(new object()); // What is T inferred as?\n...\n#nullable enable\nt.Value = null; // warning?\n...\n\nBox<T> M<T>(T t) => new Box(t);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Complex Array Syntax in C#\nDESCRIPTION: Example of potentially confusing syntax for nested arrays that influenced the decision to reject anonymous inline arrays. Shows what a regular array of 4-element int arrays would look like.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-01.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nint[][4]\n```\n\n----------------------------------------\n\nTITLE: Encoding Extension Types for Base Types and Interfaces in C#\nDESCRIPTION: Demonstrates how extension types could be encoded for base types and interfaces using a nested class and attribute approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-07.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n   // class C<T> : I<E<T>> { }\n   class C<T> : [SecretField(\"Field1\")] I<Underlying>\n   {\n       private abstract class Secret\n       {\n          I<E<T>> Field1;\n       }\n   }\n```\n\n----------------------------------------\n\nTITLE: Modified ANTLR Grammar for Params Collections in C# 12\nDESCRIPTION: This code snippet shows the grammar modifications needed to support params collections in C#. It modifies the formal_parameter_list and changes parameter_array to parameter_collection to accept more collection types beyond arrays.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/params-collections.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nformal_parameter_list\n    : fixed_parameters\n-    | fixed_parameters ',' parameter_array\n+    | fixed_parameters ',' parameter_collection\n-    | parameter_array\n+    | parameter_collection\n    ;\n\n-parameter_array\n+parameter_collection\n-    : attributes? 'params' array_type identifier\n+    : attributes? 'params' 'scoped'? type identifier\n    ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Usability Issue with Partial Methods and Attributes in C#\nDESCRIPTION: This snippet illustrates the usability problem where important attributes like NotNullWhen cannot be repeated on both partial method declarations, potentially causing confusion for users and maintainers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/repeated-attributes.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic partial bool TryGetValue([NotNullWhen(true)] out object? value);\npublic partial bool TryGetValue(out object? value) { ... }\n```\n\n----------------------------------------\n\nTITLE: Non Null Types Attribute Examples\nDESCRIPTION: Demonstrates different ways to use the NonNullTypes attribute to control nullable reference type behavior and warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-07-16.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[NonNullTypes(true)]  // Warnings on, unannotated types are non-nullable\n[NonNullTypes(false)] // Warnings on, unannotated types are oblivious\n[NonNullTypes]       // Equivalent to NonNullTypes(true)\n[NonNullTypes(true, Warnings = false)]  // Configure warnings explicitly\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion of List<T> to ImmutableArray\nDESCRIPTION: This C# code snippet illustrates the desired behavior regarding conversions from `List<T>` to other collection types like `ImmutableArray<T>`. The working group leaned toward not allowing implicit or explicit conversions, so the code would fail to compile.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-05-10.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar collection = [1, 2];\nTakesImmutableArray(collection); // Or Span\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Existing API with params and non-params Overloads in C#\nDESCRIPTION: Example showing existing Console.WriteLine() method overloads, including both params and non-params versions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Existing API with params and non-params overloads\npublic static class Console\n{\n    public static void WriteLine(string value);\n    public static void WriteLine(string format, object arg0);\n    public static void WriteLine(string format, object arg0, object arg1);\n    public static void WriteLine(string format, object arg0, object arg1, object arg2);\n    public static void WriteLine(string format, params object[] arg);\n}\n\n// New API with single overload\nabstract class Logger\n{\n    public abstract void Log(string format, params ReadOnlySpan<object> args);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Instance Method Function Pointers in C#\nDESCRIPTION: This snippet shows how instance methods could be supported using the EXPLICITTHIS CLI calling convention. It demonstrates creating and using a function pointer to an instance method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/function-pointers.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nunsafe class Instance {\n    void Use() {\n        delegate* instance<Instance, string> f = &ToString;\n        f(this);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Deconstruction Syntax Example in C#\nDESCRIPTION: Shows a potential deconstruction syntax for tuples that was considered but not initially included in the prototype design.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-07-01.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n(int sum, int count) = Tally(...);   \n```\n\n----------------------------------------\n\nTITLE: Alternative Expression-Bodied Property Syntax in C#\nDESCRIPTION: Shows a more verbose alternative syntax for expression-bodied properties that was considered but not adopted. This syntax explicitly includes the 'get' keyword but was deemed less terse than the preferred arrow syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-11-04.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic int X { get => x; }\n```\n\n----------------------------------------\n\nTITLE: Inline Type Testing for Non-nullable Value Types in C#\nDESCRIPTION: Demonstrates the more convoluted approach needed for testing non-nullable value types, using the nullable version of the type with the 'as' operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nif ((var i = e as int?) != null) { â€¦ i.Value â€¦ } // inline type test\n```\n\n----------------------------------------\n\nTITLE: Minimal Valid Raw String\nDESCRIPTION: Shows the smallest valid raw string literal example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar v1 = \"\"\"\n\n         \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Default State Handling in Union Structs\nDESCRIPTION: Describes the default state assignment for a union struct where no member type is matched, potentially triggering a warning or exception.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nU u = default;\n\n// switch throws, since not A, B or C\nvar x = u switch \n{\n    A a => a.x,\n    B b => b.z,\n    C c => 0\n};\n```\n\n----------------------------------------\n\nTITLE: Constructor Initialization Example in C#\nDESCRIPTION: Illustrates property initialization in a constructor with a custom setter that conditionally sets the backing field\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public C() { Prop = \"...\"; }\n\n    public string Prop\n    {\n        get;\n        set { if (condition) field = value; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Suppression with SetsRequiredMembers\nDESCRIPTION: Implementation detail about how SetsRequiredMembers attribute will suppress errors around required members, particularly in scenarios involving other languages extending types with required members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-23.md#2025-04-21_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Person Class Property Declaration - C#\nDESCRIPTION: Example showing property declarations with longer parameter names, demonstrating potential verbosity issues with the proposed syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-07.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person(string firstName: FirstName, string lastName: LastName);\n```\n\n----------------------------------------\n\nTITLE: ConfigureAwait Usage with Async Enumeration\nDESCRIPTION: Demonstrates how to use ConfigureAwait with async enumeration to control context switching behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/async-streams.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nawait foreach (T item in enumerable.ConfigureAwait(false))\n{\n   ...\n}\n```\n\n----------------------------------------\n\nTITLE: Target-Typed Object Creation Examples in C#\nDESCRIPTION: These snippets showcase different scenarios for target-typed object creation, including anonymous objects, collection initializers, and lambda expressions. They illustrate potential complexities in type inference and overload resolution.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-18.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nM(new { X = 7, Y = new { A = \"Hello\" } });\n```\n\nLANGUAGE: c#\nCODE:\n```\nx = new () { Y = { e1, e2 } };\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(() => new (1));\n```\n\nLANGUAGE: c#\nCODE:\n```\nM(Foo)\nM(Goo)\n\nM(new (1))\n```\n\n----------------------------------------\n\nTITLE: Implementing Params with Span Optimization Example\nDESCRIPTION: Demonstrates how params with Span<T> can be optimized by the compiler to reduce allocations by reusing a single array for multiple params calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/format.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class OneAllocation {\n    static void Use(params Span<string> spans) {\n        ...\n    }\n\n    static void Go() {\n        Use(\"jaredpar\");\n        Use(\"hello\", \"world\");\n        Use(\"a\", \"longer\", \"set\");\n    }\n```\n\n----------------------------------------\n\nTITLE: Lowered Property Implementation in C#\nDESCRIPTION: Internal compiler representation of initonly properties showing backing field implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class UserInfo\n{\n    private readonly string <Backing>_username;\n    public string get_Username() => <Backing>_username;\n    [return: modreq(initonly)]\n    public void set_Username(string value) { <Backing>_username = value; }\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Generic Constraint Scenarios\nDESCRIPTION: Examples of complex generic constraint scenarios with nullable types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nclass C<T, U, V> where T: class? where U : T, IDisposable where V : T, IDisposable?\n{\n    // Fine\n}\nclass D<T, U, V> where T: class where U : T, IDisposable where V : T, IDisposable?\n{\n    // Warn on V\n}\n```\n\n----------------------------------------\n\nTITLE: Primary Constructor Body ANTLR Grammar\nDESCRIPTION: ANTLR grammar definition for primary constructor body syntax in record type declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_4\n\nLANGUAGE: antlr\nCODE:\n```\nprimary_constructor_body\n    : attributes? constructor_modifiers? identifier block\n    ;\n```\n\n----------------------------------------\n\nTITLE: Expression Tree API Features - Code References\nDESCRIPTION: Code concepts mentioned but not explicitly shown in code form - including Expression.Compile method, lambda conversions, and expression tree nodes. The document discusses limitations in representing dynamic operations, await expressions, null conditional operators, and string interpolation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-14.md#2025-04-21_snippet_0\n\nLANGUAGE: concept\nCODE:\n```\nExpression.Compile()\nlambda => expression_tree\ndynamic operations\nawait expressions\nnull conditional operators\nstring interpolation\nfor/foreach nodes\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression Example in C#\nDESCRIPTION: Example showing how the enhanced type inference would handle a conditional expression with a null literal\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/nullable-enhanced-common-type.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ncondition ? 1 : null    // Results in int?\n```\n\n----------------------------------------\n\nTITLE: Linking to C# Language Design Notes for Jan 7, 2019 in Markdown\nDESCRIPTION: This snippet creates a Markdown link to the C# Language Design Notes for January 7, 2019, and lists the main topics related to nullable types discussed in the meeting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/README.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[C# Language Design Notes for Jan 7, 2019](LDM-2019-01-07.md)\n\nNullable:\n\n1. Variance in overriding/interface implementation\n2. Breaking change in parsing array specifiers\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lookup Rules for Implicit Extensions in C#\nDESCRIPTION: This snippet shows how implicit extension methods can lead to duplicates or conflicts in member lookups when inheritance is involved.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension Base for object \n{\n    void M() { }\n}\nimplicit extension Derived for object : Base\n{\n}\n\nobject o = ...;\no.M();\n```\n\n----------------------------------------\n\nTITLE: Ad Hoc Union Construction\nDESCRIPTION: Demonstrates how to construct an ad hoc union by assigning an instance of one of its member types to a variable of the ad hoc union type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nrecord A(int x, string y);\nrecord B(int z);\nrecord C() { public static C Singleton = new C(); };\n\n(A or B or C) u = new A(10, \"ten\");\n```\n\n----------------------------------------\n\nTITLE: Markdown Draft V8 Branch Reference\nDESCRIPTION: Git branch reference for the draft version 8 branch\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-11-specification-update.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n`draft-v8`\n```\n\n----------------------------------------\n\nTITLE: Exploring Extension Member Disambiguation Syntax Options\nDESCRIPTION: Proposed alternative syntaxes for qualifying extension members, including using 'in' keyword and member qualification approaches\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-01-06.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ne.(MyExtension.Prop)\n```\n\nLANGUAGE: csharp\nCODE:\n```\ne1 (MyExtension.+) e2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Nullable Generic Type Syntax in C#\nDESCRIPTION: Illustrates a proposed syntax for nullable generic types, showing how it might behave differently based on type constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-09.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvoid M<T>()\n{\n    T? t = null; // would be an error!\n}\n\nT? M1<T>(T t) => t;\nT? M2<T>(T t) where T : struct => t;\n\nvar i1 = M1(1); // 'int'\nvar i2 = M2(2); // 'int?'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple File-scoped Namespace Declarations in C#\nDESCRIPTION: Example code showing ambiguous behavior of multiple file-scoped namespace declarations. This demonstrates the potential confusion between interpretations of whether class B belongs to namespace Y or X.Y.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-01-05.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace X;\nclass A {}\nnamespace Y;\nclass B {}\n```\n\n----------------------------------------\n\nTITLE: Object Initializer Grammar with ref Values in ANTLR\nDESCRIPTION: Updated ANTLR grammar for object initializers that adds support for passing references using the 'ref' keyword in initializer expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_27\n\nLANGUAGE: antlr\nCODE:\n```\ninitializer_value\n    : 'ref' expression // added\n    | expression\n    | object_or_collection_initializer\n    ;\n```\n\n----------------------------------------\n\nTITLE: Alternative Type Testing Syntax Proposals in C#\nDESCRIPTION: Demonstrates various alternative syntax proposals for a type testing expression that combines type checking and variable declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\ne is T x\nT x is e\nT e as x\n```\n\n----------------------------------------\n\nTITLE: Override Method with Optional Parameters\nDESCRIPTION: Demonstrates issues with nullable analysis in method overrides with optional parameters that can lead to runtime null reference exceptions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-parameter-default-value-analysis.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nBase<string> obj = new Override();\nobj.M(); // throws NRE at runtime\n\npublic class Base<T>\n{\n    public virtual void M(T t = default) { } // no warning\n}\n\npublic class Override : Base<string>\n{\n    public override void M(string s)\n    {\n        s.ToString(); // no warning today, but something in this sample ought to warn. :)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Memory<T> with Collection Expression in C#\nDESCRIPTION: This snippet demonstrates a potential syntax for initializing Memory<T> using a collection expression, which is being considered for future C# versions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/LDM-questions-2023-08-15.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nMemory<int> m = [1, 2, 3];\n```\n\n----------------------------------------\n\nTITLE: Declaring Method with Default Struct Argument in C#\nDESCRIPTION: Shows a method declaration with a default struct argument, which is problematic and should be avoided in favor of default(S).\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvoid M(S s = new S()){ â€¦ }\n```\n\n----------------------------------------\n\nTITLE: Nullable Context in Partial Classes with Type Parameters\nDESCRIPTION: Example showing partial class declarations with different nullable contexts, raising the question of how type parameter constraints should be merged across partial declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-22.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n#nullable disable\npartial class C<T> { }\n#nullable enable\npartial class C<T> { }\n```\n\n----------------------------------------\n\nTITLE: Using Alias Example with Dictionary Generic Type\nDESCRIPTION: Example showing a proposed syntax for using aliases with generic types, demonstrating potential improvements to the C# using directive system.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-02-10.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nglobal using MyDictionary<TValue> = System.Collections.Generic.Dictionary<int, TValue>\n```\n\n----------------------------------------\n\nTITLE: Field Questions Links\nDESCRIPTION: GitHub issue and specification links for field questions discussion\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-24.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nChampion issue: https://github.com/dotnet/csharplang/issues/140\nQuestions: https://github.com/dotnet/csharplang/blob/dd326f7fb0c282825ed1b2ffbe8180b6c54afa1c/proposals/semi-auto-properties.md#open-ldm-questions\n```\n\n----------------------------------------\n\nTITLE: Method-Based Left Join Implementation\nDESCRIPTION: Shows the current method syntax approach for implementing left joins using GroupJoin and SelectMany.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvar query = students\n    .GroupJoin(departments, student => student.DepartmentID, department => department.ID, (student, departmentList) => new { student, subgroup = departmentList })\n    .SelectMany(\n        joinedSet => joinedSet.subgroup.DefaultIfEmpty(),\n        (student, department) => new\n        {\n            student.student.FirstName,\n            student.student.LastName,\n            Department = department.Name\n        });\n```\n\n----------------------------------------\n\nTITLE: Extension with NotNullIfNotNull Attribute in C#\nDESCRIPTION: Example of an extension declaration using the NotNullIfNotNull attribute on a reference parameter, demonstrating how nullability attributes work with extension parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n    extension([System.Diagnostics.CodeAnalysis.NotNullIfNotNull(\"o\")] ref int? i)\n    {\n        public void M(object? o)  => throw null!;\n    }\n```\n\n----------------------------------------\n\nTITLE: Modified Protected Constructor Generation\nDESCRIPTION: Demonstrates how the protected copy constructor changes when additional properties are present.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nclass Point\n{\n    // ...\n    protected Point(Point other)\n    : this(other.X, other.Y)\n    {\n        Z = other.Z;\n    }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generalized Dynamic Invoker in C#\nDESCRIPTION: Example of a proposed generalized dynamic invoker that accepts variable arguments, demonstrating the potential for dynamic invocation capabilities in service calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-21.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic object this(params object[] args) { â€¦ } // generalized dynamic invoker\n```\n\n----------------------------------------\n\nTITLE: Alternative Copy Constructor Implementation for Records in C#\nDESCRIPTION: Shows an alternative implementation of a copy constructor that calls the primary constructor, which may have side effects.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-27.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nrecord class Point(int X, int Y)\n{\n    protected Point(Point other) : Point(other.X, other.Y) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Feature Reference - pragma warning enable\nDESCRIPTION: Reference to proposed feature for enabling pragma warnings, noted as simple but lacking community engagement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-08-31.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npragma warning enable\n```\n\n----------------------------------------\n\nTITLE: Method Group Expression Conversion Breaking Change Example\nDESCRIPTION: Demonstrates a breaking change in C# 10 where method group conversion to Expression type fails compared to C# 9 behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-09-20.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar c = new C();\nc.M(F); // C#9: E.M(); C#10: error CS0428: Cannot convert method group 'F' to 'Expression'.\n\nstatic int F() => 0;\n\nclass C\n{\n    public void M(Expression e) { Console.WriteLine(\"C.M\"); }\n}\nstatic class E\n{\n    public static void M(this object o, Func<int> a) { Console.WriteLine(\"E.M\"); }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nullable Type Parameters in Generic Classes\nDESCRIPTION: Example of a generic class with methods that handle nullable type parameters, demonstrating the proposed behavior where T? would be similar to object? without additional constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-27.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass C<T>\n{\n    T? M(T p1, T? p2)\n    {\n        if (p2 != null)\n            M(p1, null); // error on the `null` because T may be `int`\n        if (p2 != null)\n            M(p1, default); // OK, because if T is `int`, default is valid\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Variable Declaration Example\nDESCRIPTION: Example showing tuple patterns with nullability differences being compared for pattern matching variable declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-11-11.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n(object?, object) (object, object?)\n```\n\n----------------------------------------\n\nTITLE: Defining InternalImplementationOnly Attribute for Interfaces in C#\nDESCRIPTION: Example of how to use the proposed InternalImplementationOnly attribute on an interface. This attribute would restrict implementation of the interface to the same assembly or InternalsVisibleTo friends.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-01.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.InternalImplementationOnly] interface I<...> {...}\n```\n\n----------------------------------------\n\nTITLE: Implementing a User-Defined 'is' Operator in C# for Custom Pattern Matching\nDESCRIPTION: This code shows how a user-defined 'is' operator could be implemented to enable custom pattern matching logic for a type. It includes a Point class with properties and the custom 'is' operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\npublic class Point\n{\n    public Point(int x, int y) { this.X = x; this.Y = y; }\n    public int X { get; }\n    public int Y { get; }\n    overrides public int GetHashCode() ...\n    overrides public bool Equals(...)...\n    public static bool operator is(Point self out int x, out int y) {...}\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Virtual Interface Method Access Error in C#\nDESCRIPTION: Example showing compiler error when invoking a non-virtual interface method on a type parameter that allows ref struct.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface I1\n{\n    sealed void M3() {}\n}\n\nclass C\n{\n    static void Test2<T>(T x) where T : I1, allows ref struct\n    {\n#line 100\n        x.M3(); // (100,9): error: A non-virtual instance interface member cannot be accessed on a type parameter that allows ref struct.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Less Serious Type Testing Syntax Proposals in C#\nDESCRIPTION: Shows some 'sillier' syntax proposals mentioned during the design discussion for combined type testing and variable declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\ne x is T\nT e x as\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default in equality comparisons in C#\nDESCRIPTION: Examples showing valid and invalid uses of default literal in equality operations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\ndefault == x\nx == default\ndefault == default // illegal\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration in Deconstruction Example\nDESCRIPTION: Example showing potential syntax for mixing declarations and variables in tuple deconstruction, which could lead to ambiguity.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-02-21.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nM((int x, y) = e)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating nullable state propagation with filtered enumerables in C#\nDESCRIPTION: Shows how the nullable state can propagate through a filtered enumerable using the Where method with a non-null check. The resulting enumerable elements are treated as having non-null properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-22.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nrecord Widget(string? Prop) { }\n\nvar en = widgets.Where(widget => widget.Prop != null); // IEnumerable<Widget+__predicateReturnedTrue>\nforeach (var item in en)\n{\n    item.Prop.ToString(); // ok\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Local Function Syntax for C#\nDESCRIPTION: Demonstrates how a local function could simplify the implementation of an iterator with proper input validation by allowing the helper function to be defined inside the main method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-07.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\npublic static IEnumerable<T> Filter<T>(IEnumerable<T> s, Func<T, bool> p)\n{\n    if (s == null) throw new ArgumentNullException(\"s\");\n    if (p == null) throw new ArgumentNullException(\"p\");\n    IEnumerable<T> Impl() // Doesn't need unique name, type params or params\n    {\n        foreach (var e in s)          // s is in scope\n            if (p(e)) yield return e; // p is in scope\n    }\n    return Impl<T>(s, p);\n}\n```\n\n----------------------------------------\n\nTITLE: Var Type Declaration Conflict in C#\nDESCRIPTION: Example showing how var keyword behaves when a type named 'var' exists in scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-12.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nclass var {}\nvar (x, y) = e;\n```\n\n----------------------------------------\n\nTITLE: Synthesizing Delegate Types with Optional and params Parameters in C#\nDESCRIPTION: Shows how delegate types are synthesized for lambdas or method groups with optional or params parameters, using anonymous delegate types represented with notation a', b', etc.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar addWithDefault = (int addTo = 2) => addTo + 1;\n// internal delegate int a'(int arg = 2);\nvar printString = (string toPrint = \"defaultString\") => Console.WriteLine(toPrint);\n// internal delegate void b'(string arg = \"defaultString\");\nvar counter = (params int[] xs) => xs.Length;\n// internal delegate int c'(params int[] arg);\nstring PathJoin(string s1, string s2, string sep = \"/\") { return $\"{s1}{sep}{s2}\"; }\nvar joinFunc = PathJoin;\n// internal delegate string d'(string arg1, string arg2, string arg3 = \" \");\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax for Zero-Initializing Struct in C#\nDESCRIPTION: Suggests a potential new syntax for zero-initializing a struct from a constructor using default().\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-08-27.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nS(int x): default() { this.X = x; }\n```\n\n----------------------------------------\n\nTITLE: Span<T> Definition Highlighting Ref Struct Compatibility Issues\nDESCRIPTION: This code snippet shows the definition of Span<T>, illustrating why constructs like Span<Span<T>> are not allowed and the challenges in supporting ref structs as generic parameters for such types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly ref struct Span<T>\n{\n    public readonly ref T _data;\n    public readonly int _length;\n\n    public Span(T[] array) { ... }\n\n    public static implicit operator Span<T>(T[]? array) { }\n \n    public static implicit operator Span<T>(ArraySegment<T> segment) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiplication Operators for IntPtr and UIntPtr\nDESCRIPTION: Defines multiplication operators for System.IntPtr and System.UIntPtr types with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator *(int, System.IntPtr)\nSystem.IntPtr operator *(System.IntPtr, int)\nSystem.IntPtr operator *(System.IntPtr, System.IntPtr)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator *(uint, System.UIntPtr)\nSystem.UIntPtr operator *(System.UIntPtr, uint)\nSystem.UIntPtr operator *(System.UIntPtr, System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: VB.NET class with readonly field and ByRef parameter usage\nDESCRIPTION: This VB.NET code example shows a class with a readonly field, a constructor that passes the readonly field to a ByRef parameter, and a lambda expression that attempts to modify the readonly field.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-01.md#2025-04-21_snippet_1\n\nLANGUAGE: VB.NET\nCODE:\n```\nClass C\n    ReadOnly x As Integer = 15\n\n    Public Sub New()\n        f(x)\n        Dim lambda = Sub()\n                         f(x) ' error BC36602: 'ReadOnly' variable\n                         ' cannot be the target of an assignment in a lambda expression\n                         ' inside a constructor.\n                     End Sub\n    End Sub\n    Shared Sub f(ByRef x As Integer)\n        x = 23\n    End Sub\nEnd Class\n```\n\n----------------------------------------\n\nTITLE: Nullable Type Conversion Example in C#\nDESCRIPTION: Example demonstrating type inference with nullable value types and implicit conversions\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/nullable-enhanced-common-type.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ncondition ? x : 1.0    // Where x is int?, results in double?\n```\n\n----------------------------------------\n\nTITLE: Accessing File-Local Types with Namespaces\nDESCRIPTION: This snippet shows that even with namespaces, file-local types are only accessible within their defining file. Attempting to access them through qualified names from other files will result in errors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// File1.cs\nnamespace NS1\n{\n    file class C\n    {\n        public static void M() { }\n    }\n}\n\nnamespace NS2\n{\n    class Program\n    {\n        public static void M()\n        {\n            C.M(); // error: C is not in scope\n            NS1.C.M(); // ok: C can be accessed through NS1.\n        }\n    }\n}\n\n// File2.cs\nnamespace NS1\n{\n    class Program\n    {\n        C.M(); // error\n        NS1.C.M(); // error\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illegal Uses of Generic Dimension Specifier (C#)\nDESCRIPTION: Examples of illegal uses of the generic dimension specifier outside of nameof or typeof expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/unbound-generic-types-in-nameof.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// Illegal, not inside `nameof` or `typeof`\nvar v = SomeType<>.StaticMember;\n\n// All illegal\nvar v = typeof(List<>[]);\nvar v = typeof(List<>*);\nvar v = typeof((List<> a, int b));\n```\n\n----------------------------------------\n\nTITLE: Illustrating Default Parameters with Tuple Types in C#\nDESCRIPTION: Shows the proposed syntax for default parameters with tuple types, which is not allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nvoid M((string, int) t = (\"Bob\", 7)) { ... } // Allowed?\n```\n\n----------------------------------------\n\nTITLE: Default Interface Method Limitations with Ref Struct in C#\nDESCRIPTION: Illustrates why default interface methods pose a problem for ref struct types due to potential boxing of the 'this' parameter.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    void M()\n    {\n        // Danger: both of these box if I1 is implemented by a ref struct\n        I1 local1 = this;\n        object local2 = this;\n    }\n}\n\n// Error: I1.M cannot implement interface member I1.M() for ref struct S\nref struct S : I1 { }\n```\n\n----------------------------------------\n\nTITLE: Defining the Ref Assignment Operator in ANTLR Grammar for C# 7.3\nDESCRIPTION: ANTLR grammar definition for the new ref assignment operator (=ref) added to C# 7.3. This operator allows rebinding the referent of ref local variables or ref parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/ref-local-reassignment.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nassignment_operator\n    : '=' 'ref'\n    ;\n```\n\n----------------------------------------\n\nTITLE: String Expression Reference\nDESCRIPTION: Reference to the nameof operator introduced in C# 6 that provides compile-time checked name references.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-18.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnameof\n```\n\n----------------------------------------\n\nTITLE: Default Value Assignment Warning Example - C#\nDESCRIPTION: Code pattern demonstrating the default value assignment that triggers warnings in C#. This syntax assigns the default value to a variable of type T.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-07-27.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nT t = default;\n```\n\n----------------------------------------\n\nTITLE: Record Type Member Example\nDESCRIPTION: Example showing potential nullability warnings in manually implemented record members, specifically for Equals and EqualityContract methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-09-14.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic virtual bool Equals(R other)\npublic virtual Type EqualityContract\n```\n\n----------------------------------------\n\nTITLE: Using modreqs vs Attributes for Ref Fields\nDESCRIPTION: Discussion of encoding mechanisms for ref fields semantic elements, comparing modreqs vs attributes approach. Decided on modreqs for stronger safety rule enforcement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-28.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nDoesNotEscape // Example attribute/modifier mentioned in discussion\n```\n\n----------------------------------------\n\nTITLE: Specification Change for Interpolation Rules - C#\nDESCRIPTION: This diff snippet outlines a proposed change to the specification of valid characters in interpolated strings, facilitating the potential inclusion of new lines in interpolation expressions without the existing restrictions. It presents a before-and-after view of the specification changes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/new-line-in-interpolation.md#2025-04-21_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\nsingle_regular_balanced_text_character\n-    : '<Any character except / (U+002F), @ (U+0040), \\\" (U+0022), $ (U+0024), ( (U+0028), ) (U+0029), [ (U+005B), ] (U+005D), { (U+007B), } (U+007D) and new_line_character>'\n-    | '</ (U+002F), if not directly followed by / (U+002F) or * (U+002A)>'\n+    : <Any character except @ (U+0040), \\\" (U+0022), $ (U+0024), ( (U+0028), ) (U+0029), [ (U+005B), ] (U+005D), { (U+007B), } (U+007D)>\n+    | comment\n    ;\n```\n\n----------------------------------------\n\nTITLE: UnscopedRef Implementation Rules in C#\nDESCRIPTION: Shows the rules for implementing interface members with [UnscopedRef] attribute by struct and ref struct types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    [UnscopedRef]\n    ref int P1 { get; }\n    ref int P2 { get; }\n}\n\nstruct S1\n{\n    internal ref int P1 { get {...} }\n    internal ref int P2 { get {...} }\n}\n\nstruct S2\n{\n    [UnscopedRef]\n    internal ref int P1 { get {...} }\n    internal ref int P2 { get {...} }\n}\n\nstruct S3 : I1\n{\n    internal ref int P1 { get {...} }\n    // Error: P2 is marked with [UnscopedRef] and cannot implement I1.P2 as is not marked \n    // with [UnscopedRef]\n    [UnscopedRef]\n    internal ref int P2 { get {...} }\n}\n\nclass C1 : I1\n{\n    internal ref int P1 { get {...} }\n    internal ref int P2 { get {...} }\n}\n```\n\n----------------------------------------\n\nTITLE: Remainder Operators for IntPtr and UIntPtr\nDESCRIPTION: Defines remainder operators for System.IntPtr and System.UIntPtr types with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator %(int, System.IntPtr)\nSystem.IntPtr operator %(System.IntPtr, int)\nSystem.IntPtr operator %(System.IntPtr, System.IntPtr)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator %(uint, System.UIntPtr)\nSystem.UIntPtr operator %(System.UIntPtr, uint)\nSystem.UIntPtr operator %(System.UIntPtr, System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Example Generic Type References\nDESCRIPTION: Code reference showing generic type notation mentioned in discussion about nested generics conversion challenges\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-12-11.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nList<U>\\nList<E>\n```\n\n----------------------------------------\n\nTITLE: Implementing IAdditionOperators Interface with Recursive Constraint\nDESCRIPTION: Example showing current recursive constraint implementation for operator declarations in interfaces requiring the implementing type to be one of the operator parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/self-constraint.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IAdditionOperators<TSelf, TOther, TResult>\n    where TSelf : IAdditionOperators<TSelf, TOther, TResult>\n{\n    static abstract TResult operator +(TSelf left, TOther right);\n}\n```\n\n----------------------------------------\n\nTITLE: Warning Configuration Pragma Syntax in C#\nDESCRIPTION: Examples showing the correct syntax for configuring warnings using pragma directives, specifically noting the correct order of 'restore' and the diagnostic ID.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-29.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n#pragma warning CS4321 restore\n```\n\nLANGUAGE: C#\nCODE:\n```\n#pragma warning restore CS4321\n```\n\n----------------------------------------\n\nTITLE: Struct-Based Representation of Nullable Types\nDESCRIPTION: Shows how nullable and non-nullable reference types could be represented as wrapper structs in compiled code, which would provide stronger type checking but has interoperability issues.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-10-17.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C\n{\n    NullableRef<string> M(NonNullableRef<string> s) { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Comparison Operators for IntPtr\nDESCRIPTION: Defines comparison operators for System.IntPtr type with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nbool operator ==(int, System.IntPtr)\nbool operator ==(System.IntPtr, int)\nbool operator ==(System.IntPtr, System.IntPtr)\n\nbool operator !=(int, System.IntPtr)\nbool operator !=(System.IntPtr, int)\nbool operator !=(System.IntPtr, System.IntPtr)\n\nbool operator  <(int, System.IntPtr)\nbool operator  <(System.IntPtr, int)\nbool operator  <(System.IntPtr, System.IntPtr)\n\nbool operator  >(int, System.IntPtr)\nbool operator  >(System.IntPtr, int)\nbool operator  >(System.IntPtr, System.IntPtr)\n\nbool operator <=(int, System.IntPtr)\nbool operator <=(System.IntPtr, int)\nbool operator <=(System.IntPtr, System.IntPtr)\n\nbool operator >=(int, System.IntPtr)\nbool operator >=(System.IntPtr, int)\nbool operator >=(System.IntPtr, System.IntPtr)\n```\n\n----------------------------------------\n\nTITLE: Examples of Breaking Changes When 'field' is Always Considered a Keyword in C#\nDESCRIPTION: Demonstrates the breaking changes that would occur if 'field' were always treated as a keyword in property accessors, including conflicts with existing field names.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyClass\n{\n    private int field;\n    public int P => this.field; // error: expected identifier\n\n    private int value;\n    public int Q\n    {\n        set { this.value = value; } // error: expected identifier\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ListPatternHelper Class in C#\nDESCRIPTION: Helper class for implementing list pattern matching on enumerable types, handling element buffering and enumeration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/list-patterns-enumerables.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nclass ListPatternHelper\n{\n  private EnumeratorType enumerator;\n  private int count;\n  private ElementType[] startBuffer;\n  private ElementType[] endCircularBuffer;\n\n  public ListPatternHelper(EnumerableType enumerable, int startPatternsCount, int endPatternsCount)\n  {\n    count = 0;\n    enumerator = enumerable.GetEnumerator();\n    startBuffer = startPatternsCount == 0 ? null : new ElementType[startPatternsCount];\n    endCircularBuffer = endPatternsCount == 0 ? null : new ElementType[endPatternsCount];\n  }\n\n  private int MoveNextIfNeeded(int targetIndex)\n  {\n    int startSize = startBuffer?.Length ?? 0;\n    int endSize = endCircularBuffer?.Length ?? 0;\n    Debug.Assert(targetIndex == -1 || (targetIndex >= 0 && targetIndex < startSize));\n\n    while ((targetIndex == -1 || count <= targetIndex) && enumerator.MoveNext())\n    {\n      if (count < startSize)\n        startBuffer[count] = enumerator.Current;\n\n      if (endSize > 0)\n        endCircularBuffer[count % endSize] = enumerator.Current;\n\n      count++;\n    }\n\n    return count;\n  }\n\n  public bool Last()\n  {\n    return !enumerator.MoveNext();\n  }\n\n  public int Count()\n  {\n    return MoveNextIfNeeded(-1);\n  }\n\n  public bool TryGetStartElement(int index, out ElementType value)\n  {\n    Debug.Assert(startBuffer is not null && index >= 0 && index < startBuffer.Length);\n    MoveNextIfNeeded(index);\n    if (count > index)\n    {\n      value = startBuffer[index];\n      return true;\n    }\n    value = default;\n    return false;\n  }\n\n  public ElementType GetEndElement(int hatIndex)\n  {\n    Debug.Assert(endCircularBuffer is not null && hatIndex > 0 && hatIndex <= endCircularBuffer.Length);\n    int endSize = endCircularBuffer.Length;\n    Debug.Assert(endSize > 0);\n    return endCircularBuffer[(count - hatIndex) % endSize];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unsigned Right Shift Assignment Operator in ANTLR\nDESCRIPTION: This snippet adds the `unsigned_right_shift_assignment` to the list of possible assignment operators in the ANTLR grammar. This allows the use of the `>>>=` operator for performing an unsigned right shift and assigning the result back to the left operand.  The grammar production connects the new operator into the assignment expression rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/unsigned-right-shift-operator.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\n\"assignment_operator\\n    : '='\\n    | '+='\\n    | '-='\\n    | '*='\\n    | '/='\\n    | '%='\\n    | '&='\\n    | '|='\\n    | '^='\\n    | '<<='\\n    | right_shift_assignment\\n    | unsigned_right_shift_assignment\\n    ;\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nullable Attribute Behavior for Non-Generic Types in C#\nDESCRIPTION: This code snippet illustrates the expected behavior of nullable attributes on properties for non-generic types in C#, focusing on the [AllowNull] attribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-09-11.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nusing System.Diagnostics.CodeAnalysis;\n\nclass Widget {\n    string _description = string.Empty;\n\n    [AllowNull]\n    string Description {\n        get => _description;\n        set => _description = value ?? string.Empty;\n    }\n\n    static void Test(Widget w) {\n        w.Description = null; // ok\n        Console.WriteLine(w.Description.ToUpper()); // ok\n\n        if (w.Description == null) {\n            Console.WriteLine(w.Description.ToUpper()); // warning\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'let' Keyword for Readonly Variables in C#\nDESCRIPTION: Shows the use of the 'let' keyword as a shorthand for 'readonly var' when declaring readonly local variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/readonly-locals.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nlet maxBytesToDelete = (stream.LimitBytes - stream.MaxBytes) / 10;\n...\nmaxBytesToDelete = 0; // Error: can't assign to readonly locals outside of declaration\n```\n\n----------------------------------------\n\nTITLE: Ref Struct Usage in Async Methods\nDESCRIPTION: Shows how ref structs can be used within async methods in segments without await or yield statements. Demonstrates various scenarios including using statements and foreach loops.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-unsafe-in-iterators-async.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Threading.Tasks;\n\nref struct R\n{\n    public ref int Current { get { ... }};\n    public bool MoveNext() => false;\n    public void Dispose() { }\n}\nclass C\n{\n    public R GetEnumerator() => new R();\n    async void M()\n    {\n        await Task.Yield();\n        using (new R()) { } // allowed under this proposal\n        foreach (var x in new C()) { } // allowed under this proposal\n        foreach (ref int x in new C()) { } // allowed under this proposal\n        lock (new System.Threading.Lock()) { } // allowed under this proposal\n        await Task.Yield();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ExtensionAttribute Class for Type Erasure in C#\nDESCRIPTION: This code defines the ExtensionAttribute class used for type erasure. It includes properties for handling nullability, tuple names, and dynamic types, in addition to the main string constructor for encoded type information.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extension-wg-2024-06-14.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass ExtensionAttribute\n{\n    ExtensionAttribute(string) { }\n    Nullability { get; }\n    TupleNames { get; }\n    Dynamic { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Definition for Parameter Modifier\nDESCRIPTION: Grammar rule modification for parameter_modifier to include readonly keyword support.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/readonly-parameters.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nparameter_modifier\n    : parameter_mode_modifier\n    | 'this'\n    | 'readonly'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Parameter Default Value New() Binding in C#\nDESCRIPTION: This code shows that a parameter default value of `new()` binds to the parameterless constructor if public (and reports an error that the value is not constant); otherwise the instance is zeroed. The behavior remains unchanged from C# 9.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n\"// public struct PublicConstructor { public PublicConstructor() { } }\\n// public struct PrivateConstructor { private PrivateConstructor() { } }\\n\\nstatic void F1(PublicConstructor s1 = new()) { }  // error: default value must be constant\\nstatic void F2(PrivateConstructor s2 = new()) { } // ok: initobj\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Interfaces with Ref Struct in C#\nDESCRIPTION: Example showing how a ref struct can implement an interface but cannot be directly cast to it due to boxing limitations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nref struct File : IDisposable\n{\n    private SafeHandle _handle;\n    public void Dispose()\n    {\n        _handle.Dispose();\n    }\n}\n\nFile f = ...;\n// Error: cannot box `ref struct` type `File`\nIDisposable d = f;\n```\n\n----------------------------------------\n\nTITLE: Struct Mutation Through Interface Methods\nDESCRIPTION: Shows how mutations through interface methods operate on boxed copies and don't affect the original struct.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IB\n{\n    public void Increment() { P += 1; }\n    public int P { get; set; }\n}\nstruct T : IB\n{\n    public int P { get; set; } // auto-property\n}\n\nT t = default(T);\nConsole.WriteLine(t.P); // prints 0\n(t as IB).Increment();\nConsole.WriteLine(t.P); // prints 0\n```\n\n----------------------------------------\n\nTITLE: Extension Member Kinds with Member-Level Underlying Types (C#)\nDESCRIPTION: This C# code snippet demonstrates declaring various extension member kinds (property, indexer, event, and methods) with member-level underlying types. It showcases how the proposed syntax can be applied to different extension members, providing a consistent approach for specifying the underlying type.  The snippet includes static extension methods, properties and events.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Extensions\n{\n    extension\n    {\n        // instance extension property\n        public bool (Digit).IsPrime => ...;\n\nÂ Â Â      // instance extension indexer\nÂ Â Â      public bool (Digit).this[int bit] => ...;\n\nÂ Â Â      // instance extension event\nÂ Â Â      public event EventHandler (Digit).BitFlipped\nÂ Â Â      {\nÂ Â Â          add => ...;\nÂ Â Â          remove => ...;\nÂ Â Â      }\n\n        // static extension method\n        public static int (int).FromBits(ReadOnlySpan<bool> bits) => ...;\n\n        // static extension property\n        public static Utf8StringComparer (StringComparer).OrdinalUtf8 => ...;\n\n        // static extension event\n        public static event EventHandler SystemEvents.NetworkConnected\n        {\n            add => ...;\n            remove => ...;\n        }\n\n        // operator overloads\nÂ Â Â      public static Digit operator +(Digit d) => ...;\nÂ Â Â      public static Digit operator +(Digit d1, Digit d2) => ...;\nÂ Â Â      \nÂ Â Â      // User-defined conversions\nÂ Â Â      public static implicit operator byte(Digit d) => ...;\n    Â Â Â  public static explicit operator Digit(byte b) => ...;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Primary Constructor Syntax in C#\nDESCRIPTION: Shows the basic syntax for declaring a primary constructor on a class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nclass Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Defining Deconstruct Method in C#\nDESCRIPTION: Example of a Deconstruct method definition with byte parameters, which demonstrates the need for type conversion in deconstruction.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-09-06.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid Deconstruct(out byte x, out byte y) ...;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Pattern Matching in C# 7\nDESCRIPTION: ANTLR grammar definitions for the new pattern matching syntax in C# 7, including the extended 'is' operator, declaration patterns, constant patterns, and var patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nrelational_expression\n    : relational_expression 'is' pattern\n    ;\n```\n\nLANGUAGE: antlr\nCODE:\n```\npattern\n    : declaration_pattern\n    | constant_pattern\n    | var_pattern\n    ;\n\ndeclaration_pattern\n    : type simple_designation\n    ;\n\nconstant_pattern\n    : shift_expression\n    ;\n\nvar_pattern\n    : 'var' simple_designation\n    ;\n```\n\nLANGUAGE: antlr\nCODE:\n```\ndeclaration_pattern\n    : type simple_designation\n    ;\n```\n\nLANGUAGE: antlr\nCODE:\n```\nconstant_pattern\n    : shift_expression\n    ;\n```\n\nLANGUAGE: antlr\nCODE:\n```\nvar_pattern\n    : 'var' simple_designation\n    ;\n```\n\nLANGUAGE: antlr\nCODE:\n```\nswitch_label\n    : 'case' complex_pattern case_guard? ':'\n    | 'case' constant_expression case_guard? ':'\n    | 'default' ':'\n    ;\n\ncase_guard\n    : 'when' expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Ref Reassignment and Call Sites Example\nDESCRIPTION: Demonstration of ref reassignment rules and method invocation behavior with ref structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_47\n\nLANGUAGE: c#\nCODE:\n```\nref struct RS\n{\n    ref int _refField;\n\n    public ref int Prop => ref _refField;\n\n    public RS(int[] array)\n    {\n        _refField = ref array[0];\n    }\n\n    public RS(ref int i)\n    {\n        _refField = ref i;\n    }\n\n    public RS CreateRS() => ...;\n\n    public ref int M1(RS rs)\n    {\n        ref int local1 = ref rs.Prop;\n        return ref local1;\n        RS local2 = CreateRS();\n        return ref local2.Prop;\n        int local3 = 42;\n        var local4 = new RS(ref local3);\n        return ref local4.Prop;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String Interpolation Syntax with Backslash Escaping in C#\nDESCRIPTION: An early proposed syntax for string interpolation using backslashes to escape curly braces. This approach was ultimately rejected in favor of a prefix-based syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-21.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n\"Hello, \\{name}, you have \\{amount} donut{s} left.\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Access with Boolean Comparison\nDESCRIPTION: Demonstrates a scenario where definite assignment fails with conditional access and boolean comparison\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nif (c?.M(out object obj3) == true)\n{\n    obj3.ToString(); // undesired error\n}\n```\n\n----------------------------------------\n\nTITLE: Defaulting Property with Field Keyword in C#\nDESCRIPTION: Shows a property with a defaulting mechanism using the `field` keyword, enabling flexible property initialization and value retrieval\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic string DefaultingProp { get => field ?? GetDefault(); private set; }\n```\n\n----------------------------------------\n\nTITLE: Lambda Parameter Capture in Primary Constructor Example - C#\nDESCRIPTION: Demonstrates a scenario where a primary constructor parameter is captured both by a lambda in a field initializer and by a method in the class. Shows potential capture complexity with parameter p1.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-02-15.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npartial class C1\n{\n    public System.Func<int> F1 = Execute1(() => p1++); // Capture 1\n}\n\npartial class C1 (int p1)\n{\n    public int M1() { return p1++; } // Capture 2\n    static System.Func<int> Execute1(System.Func<int> f)\n    {\n        _ = f();\n        return f;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed Lookup Operator Usage in C#\nDESCRIPTION: This code snippet illustrates the proposed usage of the '!' lookup operator in C#. It shows how the lookup operator could be used as a shorthand for string indexing, providing a way to implement dynamic behavior for member access without conflicting with normal dot notation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-21.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nobj!x\nobj[\"x\"]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating User-Defined Conversion Limitations with UTF-8 Literals\nDESCRIPTION: Code example showing how user-defined conversions from byte[] to custom types are not chained automatically with UTF-8 string literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nusing System;\nclass C\n{\n    static void Main()\n    {\n        var y = (C2)\"dog\"u8; // error CS0030: Cannot convert type 'byte[]' to 'C2'\n        var z = (C3)\"cat\"u8; // error CS0030: Cannot convert type 'byte[]' to 'C3'\n    }\n}\n\nclass C2\n{\n    public static implicit operator C2(Span<byte> x) => new C2();\n}\n\nclass C3\n{\n    public static explicit operator C3(ReadOnlySpan<byte> x) => new C3();\n}\n```\n\n----------------------------------------\n\nTITLE: Illegal Class Declaration with Name Collision in Primary Constructor\nDESCRIPTION: Example of code that was illegal before initialization scope changes due to name collision between primary constructor parameter and field with the same name.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-04-21.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic class ConfigurationException(Configuration configuration, string message) \n    : Exception(message)\n{\n    private Configuration configuration = configuration;\n    public override string ToString() => message + \"(\" + configuration + \")\";\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Variable Scope in If-Else Statements\nDESCRIPTION: Demonstrates current scope rules where pattern variables in if conditions are not accessible in else clauses, allowing reuse of variable names.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-07-15.md#2025-04-23_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nif (o is bool b) ...b...; // b is in scope\nelse if (o is byte b) ...b...; // fine because bool b is out of scope\n...; // no b's in scope here\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Expression Tree Limitations with Optional and Named Arguments\nDESCRIPTION: Example showing current compiler errors when using optional parameters and named arguments in Expression trees with the Contains method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/optional-and-named-parameters-in-expression-trees.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System\n{\n    public static class MemoryExtensions\n    {\n        public static bool Contains<T>(this ReadOnlySpan<T> span, T value, IEqualityComparer<T>? comparer = null);\n    }\n}\n\nExpression<Func<int?[], int, bool>> e;\n        \ne = (a, i) => a.Contains(i); // error CS0854: expression tree may not contain a call that uses optional arguments\ne = (a, i) => a.Contains(i, comparer: null); // error CS0853: expression tree may not contain a named argument specification\n```\n\n----------------------------------------\n\nTITLE: Instance Method Pointer Syntax\nDESCRIPTION: Example of instance method pointer syntax that was discussed and ultimately rejected in favor of type-only references for instance methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-05.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n&receiver.M\n&TypeName.M\n```\n\n----------------------------------------\n\nTITLE: Interface Reference\nDESCRIPTION: Reference to the ISupportInitialize interface discussed for object initialization validation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-18.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nISupportInitialize\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Extension Type Members in C#\nDESCRIPTION: Demonstrates how to disambiguate extension type members by calling them through the extension type instead of the underlying type. This is useful when multiple extensions with the same name exist.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Compatibility through coexistence between extension types and extension methods.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nMyStringExtensions.Format(...); // Instead of string.Format(...)\n```\n\n----------------------------------------\n\nTITLE: Lambda Conversion with Optional Parameters\nDESCRIPTION: Shows how lambda conversions to delegates with optional parameters can miss important null warnings.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-parameter-default-value-analysis.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic delegate void Del<T>(T t = default);\n\npublic class C\n{\n    public static void Main()\n    {\n        Del<string> del = str => str.ToString(); // expected warning, but didn't get one\n        del(); // throws NRE at runtime\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Statement Block in Razor\nDESCRIPTION: Shows how to map a statement block using #line directive to align generated code with source Razor file\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/enhanced-line-directives.md#2025-04-21_snippet_3\n\nLANGUAGE: Razor\nCODE:\n```\n@{Console.WriteLine(1);Console.WriteLine(2);}\n```\n\nLANGUAGE: C#\nCODE:\n```\n#line lineof('@{') \"a.razor\"\n  Console.WriteLine(1);Console.WriteLine(2);\n#line hidden\n```\n\n----------------------------------------\n\nTITLE: Parameter Shadowing Example in C#\nDESCRIPTION: Demonstrates potential issue with parameter shadowing in async continuations where the same variable name is reused.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nvar t = FooAsync(...)\n\nt.ContinueWith(t => ... ); // whoops\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C# 8.0 Potential Wildcard Syntax\nDESCRIPTION: Shows the '*' operator that was considered as an alternative syntax for ranges.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-02.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n*\n```\n\n----------------------------------------\n\nTITLE: C# Interpolated String Grammar Rules\nDESCRIPTION: Formal grammar specification for interpolated string expressions in C#, defining the syntax for interpolation expressions, formats, and string components.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_15\n\nLANGUAGE: abnf\nCODE:\n```\nexpression:\n    interpolated-string-expression\n\ninterpolated-string-expression:\n    interpolated-string-start interpolations interpolated-string-end\n\ninterpolations:\n    single-interpolation\n    single-interpolation interpolated-string-mid interpolations\n\nsingle-interpolation:\n    interpolation-start\n    interpolation-start : regular-string-literal\n\ninterpolation-start:\n    expression\n    expression , expression\n```\n\n----------------------------------------\n\nTITLE: Meeting Quotes Section\nDESCRIPTION: Markdown formatted section showing notable quotes from the meeting\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-02.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## Quote(s) of the Day\n\n- \"Have you noticed how similar what you just said is to function pointers?\"\n- \"This is a modern version of COM aggregation.\" \"But in a good way.\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating One-Element Tuple Syntax Options in C#\nDESCRIPTION: Code examples showing different ways to represent one-element tuples in C#. The parenthesized expression `(3)` is interpreted as just the constant 3, while using a named element like `(_: 3)` could be a pattern for representing one-element tuples.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-08-26.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n(3)\n```\n\nLANGUAGE: C#\nCODE:\n```\n(_: 3)\n```\n\n----------------------------------------\n\nTITLE: Markdown Branch Reference\nDESCRIPTION: Git branch reference showing the transition from draft-v7 to standard-v7 branch\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-11-specification-update.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`draft-v7`\n```\n\n----------------------------------------\n\nTITLE: Illustrating Current Limitation with Non-AllowMultiple Attributes in C#\nDESCRIPTION: This example demonstrates the current limitation where non-AllowMultiple attributes cannot be repeated across partial method declarations, resulting in a compiler error.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/repeated-attributes.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[A]\npartial void M();\n\n[A] // error: duplicate attribute!\npartial void M() { }\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Type Declaration Example\nDESCRIPTION: Example showing rejected syntax pattern for function pointer types using Func<> pattern. The team determined this syntax was unworkable and needed an alternative approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-15.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nFunc<a,b>*\n```\n\n----------------------------------------\n\nTITLE: Record Property with Key Modifier Example\nDESCRIPTION: Example showing record declaration with explicit property implementation using the key modifier.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-12.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nrecord Point1(int X)\n{\n    public key int X { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Union Type in F#\nDESCRIPTION: An example of defining an opaque union type in F#. This creates an interchange type that appears as a union to the file or assembly that created it, but is opaque to consumers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/discriminated-unions/DU-2022-10-24.md#2025-04-21_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\ntype C =\n    private // or internal\n    | Case1 of int\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shadowing Behavior in C# Record Types\nDESCRIPTION: This code snippet illustrates a potential issue with shadowing in record types, where the behavior of deconstruction could change between C# 9 and C# 10. The team decided to make this code an error in C# 9 to prevent unexpected behavior changes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-04-14.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\n\nvar c = new C(2);\nc.Deconstruct(out var x);\nConsole.WriteLine(x); // Prints 1\n\npublic record Base \n{\n    public int X { get; set; } = 1;\n}\npublic record C(int X) : Base\n{\n    public new int X = X;\n}\n```\n\n----------------------------------------\n\nTITLE: GitHub Query for Championed Issues\nDESCRIPTION: URL query used to find open issues labeled as 'Proposal champion' without assigned milestones for triage purposes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-09.md#2025-04-21_snippet_0\n\nLANGUAGE: url\nCODE:\n```\nhttps://github.com/dotnet/csharplang/issues?q=is%3Aopen+is%3Aissue+label%3A%22Proposal+champion%22+no%3Amilestone\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Valid Conversion Targets for Collection Expressions in C#\nDESCRIPTION: This snippet shows the valid target types for collection expression conversions, including arrays, spans, builder types, generic interfaces, and collection initializer types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nint[]               a = [1]; // array\nReadOnlySpan<int>   b = [2]; // span\nImmutableArray<int> c = [3]; // builder\nIReadOnlyList<int>  d = [4]; // generic list interface\nList<int>           e = [5]; // collection initializer\n```\n\n----------------------------------------\n\nTITLE: Primary Constructor with Data Class\nDESCRIPTION: Demonstrates the concise syntax for using primary constructors with a data class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\ndata class Point(int X, int Y);\n```\n\n----------------------------------------\n\nTITLE: Explicit Interface Property Implementation in C#\nDESCRIPTION: Demonstrates explicit interface implementation for a property, which would be invalid due to accessibility restrictions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-17.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nclass C : IA\n{\n    int IA.P\n    {\n        get => 4;\n        set { }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Declaration Assignment Expressions\nDESCRIPTION: Grammar rules defining the syntax for declaration assignment expressions, extending the existing expression grammar with new production rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/declaration-expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nexpression\n    : non_assignment_expression\n    | assignment\n    | declaration_assignment_expression // new\n    ;\ndeclaration_assignment_expression // new\n    : declaration_expression '=' local_variable_initializer\n    ;\ndeclaration_expression // C# 7.0\n    | type variable_designation\n    ;\n```\n\n----------------------------------------\n\nTITLE: Using target-typed default with constant declarations in C#\nDESCRIPTION: Example showing that default literal can be used with constant declarations if the inferred type allows it.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nconst int x = default;\n```\n\n----------------------------------------\n\nTITLE: IEqualityOperators Interface Definition in C#\nDESCRIPTION: This snippet shows the definition of the IEqualityOperators interface, which demonstrates a scenario where nullable contravariance might be useful for generic type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-10-24.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IEqualityOperators<TSelf, TOther, TResult>\n        where TSelf : IEqualityOperators<TSelf, TOther, TResult>?\n{\n    static abstract TResult operator ==(TSelf? left, TOther? right);\n    static abstract TResult operator !=(TSelf? left, TOther? right);\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Meeting Minutes with Design Options\nDESCRIPTION: Meeting notes outlining four considered options for implementing primary constructor parameters in C#, with discussion of mutability behavior and readonly considerations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-07-31.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. Do nothing. Leave primary constructors as mutable, and do not plan on addressing this. If a user wants to enforce readonly class state, they should\n   declare a class member (field or property), explicitly assign into that member, and use that member, not the parameter.\n2. Plan on adding a `readonly` keyword. This keyword may come with C# 12, but might also be delayed until C# 13. There are open questions as to\n   what this keyword would mean: would it follow field `readonly`, where the parameter capture would actually be mutable during initialization, or not?\n   But by default, primary constructor parameters would always be mutable unless otherwise specified.\n3. Follow the default established by record primary constructors. This would mean that all primary constructor parameters would be mutable during\n   initialization (as in all `record` types today), but for `class`es and `readonly struct`s, they would be readonly after construction.\n4. Have all primary constructor parameters on non-record types be always `readonly`.\n```\n\n----------------------------------------\n\nTITLE: Example of Final Initializers Discussion\nDESCRIPTION: Code snippet showing a concept being discussed in the context of final initializers. The snippet itself doesn't contain actual code but is referenced in the discussion about when initializers should run relative to constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-04.md#2025-04-21_snippet_0\n\nLANGUAGE: none\nCODE:\n```\n- Design review said it was very complicated, when do I use an initializer vs a constructor?\n```\n\n----------------------------------------\n\nTITLE: Partial Members Interface Breaking Change Proposal\nDESCRIPTION: Discussion of modifying partial members in interfaces, with a decision to apply bugfix for partial properties and events but not for methods\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-04-07.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: With method with default parameters for property mapping\nDESCRIPTION: Shows a potential syntax for explicitly mapping With method parameters to properties using default parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-02-29.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract Person With(string firstName = this.FirstName, string lastName = this.LastName);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Abstract Override in Interfaces (C#)\nDESCRIPTION: Example showing the concept of 'reabstracting' an inherited method in interfaces, which was initially considered but later decided against.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    void M();\n}\ninterface IB : IA\n{\n    override void M() { }\n}\ninterface IC : IB\n{\n    override void M(); // make it abstract again\n}\n```\n\n----------------------------------------\n\nTITLE: Inline Array Object Initializer Example\nDESCRIPTION: This represents a conceptual discussion about inline array object initializer syntax, though no actual code was shown. The team decided not to natively support index initialization in object initializers for inline arrays unless users define their own indexers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-03.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Conditional Expression with Continue Statement Example\nDESCRIPTION: Comparison between using continue as an expression in a ternary operator versus traditional if-statement approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-27.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\naccumulator += (y != 0) ? x/y : continue;\n\n// as opposed to\nif (y == 0) continue;\naccumulator += x/y;\n```\n\n----------------------------------------\n\nTITLE: Linking to C# Language Design Notes for Jan 9, 2019 in Markdown\nDESCRIPTION: This snippet creates a Markdown link to the C# Language Design Notes for January 9, 2019, and lists the main topics discussed in the meeting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[C# Language Design Notes for Jan 9, 2019](LDM-2019-01-09.md)\n\n1. GetAsyncEnumerator signature\n2. Ambiguities in nullable array type syntax\n2. Recursive Patterns Open Language Issues https://github.com/dotnet/csharplang/issues/2095\n```\n\n----------------------------------------\n\nTITLE: Invalid Switch Expression Precedence Example\nDESCRIPTION: Example showing syntax error due to switch expression precedence conflicts with addition operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-13.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nx = e switch { .. } + 1 // syntax error\n```\n\n----------------------------------------\n\nTITLE: File Path Reference\nDESCRIPTION: Project path reference for the C# language design repository\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-06-24.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n/dotnet/csharplang\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression Syntax Definition in ANTLR\nDESCRIPTION: Formal grammar rules defining the syntax for lambda expressions in C#, including support for modifiers, attributes, parameter types, and lambda parameters with optional default values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/lambda-improvements.md#2025-04-21_snippet_12\n\nLANGUAGE: antlr\nCODE:\n```\nlambda_expression\n  : modifier* identifier '=>' (block | expression)\n  | attribute_list* modifier* type? lambda_parameters '=>' (block | expression)\n  ;\n\nlambda_parameters\n  : lambda_parameter\n  | '(' (lambda_parameter (',' lambda_parameter)*)? ')'\n  ;\n\nlambda_parameter\n  : identifier\n  | attribute_list* modifier* type? identifier equals_value_clause?\n  ;\n```\n\n----------------------------------------\n\nTITLE: Default Member Constructor Generation Example in C#\nDESCRIPTION: Shows a potential alternative syntax where constructor parameters are generated based on class members marked with 'default' keyword.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-10-21.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class C\n{\n    default public int A { get; }\n    default public string B { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Switch Statement in C#\nDESCRIPTION: Shows an enhanced switch statement that supports pattern matching across different types with variable extraction. Demonstrates cases for strings, integers, custom types and null handling.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-21.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nswitch (o) {\ncase string s:\n    Console.WriteLine(s);\n    break;\ncase int i:\n    Console.WriteLine($\"Number {i}\");\n    break;\ncase Point(int x, int y):\n    Console.WriteLine(\"({x},{y})\");\n    break;\ncase null:\n    Console.WriteLine(\"<null>);\n    break\n}\n```\n\n----------------------------------------\n\nTITLE: Lock Statement Example in C#\nDESCRIPTION: Example of lock statement syntax mentioned in meeting discussion\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-12-04.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nlock(ness) // monster\n```\n\n----------------------------------------\n\nTITLE: Feature Reference - await?\nDESCRIPTION: Reference to proposed null-conditional await operator feature, expanding C#'s operator monad over nulls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-08-31.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nawait?\n```\n\n----------------------------------------\n\nTITLE: Disambiguation Strategies for Extension Methods in C#\nDESCRIPTION: The snippet provides proposed strategies for disambiguating extension methods when encounter conflicts or identifying applicable methods. Varied syntactic approaches, such as cast-like, invocation-based, and alias-qualified methods, are proposed for resolving ambiguities.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\n((Extensions)instance).Prop = 42;\nConsole.WriteLine(((Extensions)instance).Prop);\n```\n\nLANGUAGE: C#\nCODE:\n```\nExtensions(instance).Prop = 42;\nConsole.WriteLine(Extensions(instance).Prop);\n```\n\nLANGUAGE: C#\nCODE:\n```\nExtensions::instance.Prop = 42;\nConsole.WriteLine(Extensions::instance.Prop);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Types for Extension Members in C#\nDESCRIPTION: This snippet demonstrates declaring an enclosing extension type that specifies type parameters and an underlying type for extension members, such as properties. This approach addresses complexity when dealing with open generic underlying types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/the-design-space-for-extensions.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic extensions MemoryExtensions<T> for T[]?\n{\n    public Span<T> (array).AsSpan { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Ignored Pre-processing Directives in C#\nDESCRIPTION: ANTLR grammar rules defining the syntax for ignored pre-processing directives in C#, including the new PP_Ignored and PP_IgnoredToken rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/ignored-directives.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nPP_Kind\n    : ... // Existing directive kinds\n    | PP_Ignored\n    ;\n\nPP_Ignored\n    : PP_IgnoredToken Input_Character*\n    ;\n\nPP_IgnoredToken\n    : '!'\n    | ':'\n    ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Top-level Statements\nDESCRIPTION: Defines the ANTLR grammar rule for compilation units that allow statements before namespace declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\ncompilation_unit\n    : extern_alias_directive* using_directive* global_attributes? statement* namespace_member_declaration*\n    ;\n```\n\n----------------------------------------\n\nTITLE: Object Constraint Example\nDESCRIPTION: Example showing object constraint with nullable warning.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nstatic void F<T>(T t) where T : object { }\nF(maybeNull); // warning: constraint violated\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullability Constraints in C# Inheritance\nDESCRIPTION: Demonstrates how nullability constraints are handled between base and derived classes with different NonNullTypes attributes. Shows inheritance behavior when base and derived classes have different nullability contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-09-10.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Assembly 1\n[NonNullTypes(true)]\nclass Base\n{\n    virtual void M<T>() where T : C?\n    { }\n}\n\n---\n// Assembly 2\n\n[NonNullTypes(false)]\nclass Derived : Base\n{\n    override void M<T>()\n    { }\n}\n```\n\n----------------------------------------\n\nTITLE: Current Workaround Pattern\nDESCRIPTION: Demonstrates the current workaround pattern required to modify struct properties, which involves creating a temporary variable.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/readonly-setter-calls-on-non-variables.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar temp = c.ArraySegmentProp;\ntemp[10] = new object();\nc.ArraySegmentProp = temp; // But this line is purposeless; 'temp' cannot have changed.\n```\n\n----------------------------------------\n\nTITLE: Interface Inheritance Constraints\nDESCRIPTION: Examples showing interface inheritance constraints with nullable types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-04-25.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\ninterface IBar : IFoo<string> {}\nstatic void F<T>(T t) where T : IFoo<string?>, IBar { }\n```\n\n----------------------------------------\n\nTITLE: Problematic Primary Constructor Implementation in C#\nDESCRIPTION: Example showing issues with implicit parameter capture in primary constructors where x and y are captured as private fields separate from X and Y properties, leading to inconsistent state.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-03.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic class Point(int x, int y)\n{\n    public int X { get; set; } = x;\n    public int Y { get; set; } = y;\n    public double Dist => Math.Sqrt(x * x + y * y);\n    public void Move(int dx, int dy)\n    {\n        x += dx; y += dy;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IAdditiveIdentity Interface with Current Constraints\nDESCRIPTION: Example demonstrating current limitations with recursive constraints for non-operator static abstract members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/self-constraint.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IAdditiveIdentity<TSelf>\n    where TSelf : IAdditiveIdentity<TSelf>\n{\n    static abstract TSelf AdditiveIdentity { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'data' Modifier for Record Properties in C#\nDESCRIPTION: Shows the proposed syntax using a 'data' modifier to indicate public init-only properties in record declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-05-27.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic record Point(int X, int Y);\npublic record Point\n{\n    data int X;\n    data int Y;\n}\n```\n\n----------------------------------------\n\nTITLE: XML Indentation Examples\nDESCRIPTION: Various examples showing how indentation is handled with XML content.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/raw-string-literal.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar xml = \"\"\"\n          <element attr=\"content\">\n            <body>\n            </body>\n          </element>\n          \"\"\";\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Example for IEnumerable\nDESCRIPTION: Example showing a list pattern matching against an enumerable with length and element constraints\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-02-03.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nenumerable [< 6] { 1, 2, 3, .., 10 }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Extension Member Lookup on Underlying Type in C#\nDESCRIPTION: This snippet shows how extension members on the underlying type should be eligible when given an extension type or value. The extension member lookup rule was updated to look at the underlying type when given an extension type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2024-03-05.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = E1.Member;\nSystem.Console.Write(x);\n\nclass C { }\n\nextension E1 for C { }\n\nimplicit extension E2 for C\n{\n    public static string Member = \"ran\";\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating null check on pointer type in C#\nDESCRIPTION: This snippet demonstrates the allowed null check on pointer types in pattern matching, which was decided to be permitted in the language design meeting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-24.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nptr is null\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax for Extension Member Parameter Declaration in C#\nDESCRIPTION: Examples showing alternative syntax options being considered for extension member parameter declarations. These alternatives aim to make the receiver parameter syntax more consistent with regular method declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nextensions StringExtensions for string\n{\n    public bool ([NotNullWhen(false)] string? s) IsNullOrEmpty => ...;\n    \n    public int (text) CountWord(string word) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Flow in 'and' Pattern for C#\nDESCRIPTION: Shows how type information from the left side of an 'and' pattern could flow to the right side, narrowing the input type for the second pattern.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/patterns3.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nbool isSmallByte(object o) => o is byte and < 100;\n```\n\n----------------------------------------\n\nTITLE: Alternative Builder Creation Example\nDESCRIPTION: Demonstrates creating a builder with a different type from the Create method\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/async-method-builders.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nAsyncPooledBuilder _builder = AsyncPooledBuilderWithSize4.Create();\n```\n\n----------------------------------------\n\nTITLE: Member Access Null Tracking Example in C#\nDESCRIPTION: Demonstrates how null tracking works with member access expressions, comparing tracked properties versus untracked method returns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/nullable-reference-types-specification.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nvar person = new Person();\n\n// The receiver is a tracked expression hence the member_access of the property \n// is tracked as well \nif (person.FirstName is not null)\n{\n    Use(person.FirstName);\n}\n\n// The return of an invocation is not a tracked expression hence the member_access\n// of the return is also not tracked\nif (GetAnonymous().FirstName is not null)\n{\n    // Warning: Cannot convert null literal to non-nullable reference type.\n    Use(GetAnonymous().FirstName);\n}\n\nvoid Use(string s) \n{ \n    // ...\n}\n\npublic class Person\n{\n    public string? FirstName { get; set; }\n    public string? LastName { get; set; }\n\n    private static Person s_anonymous = new Person();\n    public static Person GetAnonymous() => s_anonymous;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Unsigned Right Shift Operators in ANTLR\nDESCRIPTION: This snippet defines the grammar rules for the unsigned right shift operator `>>>` and the unsigned right shift assignment operator `>>>=` using ANTLR.  These definitions are added to the C# language grammar to support the new operators.  Whitespace is disallowed between the characters forming these operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/unsigned-right-shift-operator.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\n\"unsigned_right_shift\\n    : '>>>'\\n    ;\\n\\nunsigned_right_shift_assignment\\n    : '>>>='\\n    ;\"\n```\n\n----------------------------------------\n\nTITLE: Referencing Anonymous Inline Array Type Syntax in C#\nDESCRIPTION: Example syntax of anonymous inline array types that was discussed and ultimately rejected. The notation shown as 'int[4]' would have represented an anonymous inline array of 4 integers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-05-01.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nint[4]\n```\n\n----------------------------------------\n\nTITLE: Implementing Nullability Context with Pseudo-Attributes in C#\nDESCRIPTION: Example of using pseudo-attributes to control nullable annotations and warnings in a Dictionary class. The [NonNullTypes] attribute is used to toggle nullability context at different levels.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-10-03.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[module:NonNullTypes]\n\npublic class Dictionary<TKey, TValue> : ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, ICollection, IDictionary, IDeserializationCallback, ISerializable\n{\n    public Dictionary() { }\n    public Dictionary(IDictionary<TKey, TValue> dictionary) { }\n    public Dictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection) { }\n    public Dictionary(IEqualityComparer<TKey>? comparer) { }\n    [NonNullTypes(false)] public Dictionary(int capacity) { }\n    [NonNullTypes(false)] public Dictionary(IDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer) { }\n    [NonNullTypes(false)] public Dictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer) { }\n    public Dictionary(int capacity, IEqualityComparer<TKey>? comparer) { }\n    [NonNullTypes(warn = false)] protected Dictionary(SerializationInfo info, StreamingContext context) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Lowered Extension Declaration in C#\nDESCRIPTION: This code snippet shows the result of lowering the previous extension declaration.  A single static class `__E1` is generated with a type parameter `__T1` that has a `class` constraint. This is because the original extension declarations were determined to be equivalent.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/anonymous-extension-declarations.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\npublic static class MyExtensions\n{\n    public static class __E1<__T1> where __T1 : class\n    {\n        ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic EqualityComparer Usage\nDESCRIPTION: Example of how GetHashCode is implemented for record types using the generic EqualityComparer.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-01-27.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Collections.Generic.EqualityComparer<TN>.Default.GetHashCode(fieldN)\n```\n\n----------------------------------------\n\nTITLE: Base Interface Invocations in C# (Proposed Syntax)\nDESCRIPTION: This code demonstrates the proposed syntax for base interface invocations in C#, allowing explicit invocation of a base interface's default method implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I0\n{\n   void M() { Console.WriteLine(\"I0\"); }\n}\ninterface I1 : I0\n{\n   override void M() { Console.WriteLine(\"I1\"); }\n}\ninterface I2 : I0\n{\n   override void M() { Console.WriteLine(\"I2\"); }\n}\ninterface I3 : I1, I2\n{\n   // an explicit override that invoke's a base interface's default method\n   void I0.M() { I2.base.M(); }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic String Interpolation Example\nDESCRIPTION: Demonstrates basic string interpolation syntax and its translation to String.Format.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-10-15.md#2025-04-21_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n$\"{hello}, {world}!\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\nString.Format(\"{0}, {1}!\", hello, world)\n```\n\n----------------------------------------\n\nTITLE: Specifying Nullability in Extension Type Members in C#\nDESCRIPTION: Shows how to specify nullability for extension type members using attributes. This approach allows for creating null-safe extension methods like 'IsNullOrEmpty' without requiring dedicated language syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/Compatibility through coexistence between extension types and extension methods.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[this:AllowNull][this:NotNullWhen(false)] public bool IsNullOrEmpty() { ... }\n```\n\n----------------------------------------\n\nTITLE: Markdown Branch Standard Reference\nDESCRIPTION: Git branch reference for the standardized version 7 branch\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-10-11-specification-update.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n`standard-v7`\n```\n\n----------------------------------------\n\nTITLE: Comparison of is Expressions with int and default in C#\nDESCRIPTION: Illustrates the difference in behavior between using int literals and default in is expressions, highlighting potential confusion.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-07.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nif (0 is int)            { ... } // True: 0 is an int \nif (default(int) is int) { ... } // True: 0 is still an int\nif (default is int)      { ... } // Would be false! default(object) is null, which is not an int.\n```\n\n----------------------------------------\n\nTITLE: Derived Type Pattern Matching in C#\nDESCRIPTION: Examples showing how type inference works with multiple derived types in or patterns\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-04-08.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nif (o is (Derived1 or Derived2 or Base { ... }) and var x)\n```\n\n----------------------------------------\n\nTITLE: Implementing IEnumerable<T>, IReadOnlyCollection<T>, or IReadOnlyList<T> in C#\nDESCRIPTION: For non-empty collections targeting readonly interfaces, the compiler will synthesize a private type within the assembly, similar to System.Collections.ObjectModel.ReadOnlyCollection<T>. This prevents casting to the framework class and allows for future optimizations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2023-08-11.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Synthesized by the compiler\nprivate sealed class SynthesizedReadOnlyCollection<T> : IReadOnlyList<T>, IList<T>, IList\n{\n    // Implementation details\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy Computed Expression Property in C#\nDESCRIPTION: Expression-bodied property with lazy computation using null coalescing assignment\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic string LazilyComputed => field ??= Compute();\n```\n\n----------------------------------------\n\nTITLE: Declaring KeyValuePair Syntax in Collection Expressions - C#\nDESCRIPTION: This snippet illustrates the special syntax for declaring KeyValuePairs within collection expressions and how it applies to dictionary and list types in C#. The versatility of this syntax is highlighted through various examples.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nX x = [k: v];\n```\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> nameToAge = [\"mads\": 21];\n```\n\nLANGUAGE: c#\nCODE:\n```\nList<KeyValuePair<string, int>> pairs = [\"mads\": 21];\n```\n\n----------------------------------------\n\nTITLE: Attribute Usage with Value Keyword in C#\nDESCRIPTION: Example demonstrating the current legal usage of 'value' keyword in property setter attribute declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class C(string s) : Attribute\n{\n    public int P\n    { \n        get;\n        [param: C(nameof(value))] set;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Async Iterator with Multiple Cancellation Tokens\nDESCRIPTION: Shows the async iterator cancellation scenario where cancellation tokens are passed both during iterator creation and enumeration. The LDM decided to implement a combined token approach that respects both cancellation tokens.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-04-29.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nIAsyncEnumerable<T> enumerable = SomeIteratorAsync(ct1);\nIAsyncEnumerator<T> enumerator = enumerable.GetAsyncEnumerator(ct2);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constant Pattern Equality in C# Switch Statement\nDESCRIPTION: This snippet shows how constant pattern equality works in a switch statement when the case label is implicitly convertible to the governing type of the switch expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_12\n\nLANGUAGE: c#\nCODE:\n```\nswitch(7)\n{\n  case (byte)7:\n    WriteLine(\"Match!\");\n    break;\n}\n```\n\n----------------------------------------\n\nTITLE: Unary Minus Operator for IntPtr\nDESCRIPTION: Defines the unary minus operator for System.IntPtr type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator -(System.IntPtr)\n```\n\n----------------------------------------\n\nTITLE: Memory and Span Types in C#\nDESCRIPTION: Reference to Memory<char> and Span<char> types, which are related to discussions about UTF8 support and potential language improvements for working with these types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-08-26.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nMemory<char>\n```\n\nLANGUAGE: C#\nCODE:\n```\nSpan<char>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating parameter capture problem with lifetimes in C#\nDESCRIPTION: This snippet illustrates how the lifetime model prevents incorrect parameter capture in ref struct methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S<out $this>\n{\n    ref<$this> int refField;\n    \n    // Using static form of this method signature so the type of this is explicit. \n    static void Use<$ro, $cm>(ref<$local> S<$cm> @this, ref<$ro> int parameter)\n    {\n```\n\n----------------------------------------\n\nTITLE: Unification of Base Extensions Example in C#\nDESCRIPTION: This snippet demonstrates a scenario where base extensions could potentially unify, which may cause issues if special runtime support for extension types is added in the future.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-wg-2023-04-27.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit extension E<T> for object { }\nexplicit extension E2<U> for object : E<int>, E<U>\n{ \n    void M() { }\n}\n```\n\n----------------------------------------\n\nTITLE: System.Range Structure Definition\nDESCRIPTION: Definition of the System.Range structure with required members for range operations. Includes constructor and static factory methods for different range scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/ranges.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System\n{\n    public readonly struct Range\n    {\n        public Range(System.Index start, System.Index end);\n        public static Range StartAt(System.Index start);\n        public static Range EndAt(System.Index end);\n        public static Range All { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Is Expression Pattern Matching Grammar in ANTLR\nDESCRIPTION: ANTLR grammar rules defining the syntax for the extended 'is' operator that tests expressions against patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/patterns.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nrelational_expression\n    : is_pattern_expression\n    ;\nis_pattern_expression\n    : relational_expression 'is' pattern\n    ;\n```\n\n----------------------------------------\n\nTITLE: Block Expression Syntax Examples - C#\nDESCRIPTION: Examples demonstrating proposed block expression syntax with implicit return values. Shows how semicolons and nested blocks can be used to produce expression values.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-22.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar x = { ; 3 };    // int x = 3\nvar x = { {} 3 };   // int x = 3\n```\n\n----------------------------------------\n\nTITLE: Ref Reassignment Safety Example\nDESCRIPTION: Example demonstrating unsafe ref reassignment scenarios and lifetime constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_48\n\nLANGUAGE: c#\nCODE:\n```\nvoid Example(ref Span<int> p)\n{\n    Span<int> local = stackalloc int[42];\n    ref Span<int> refLocal = ref local;\n    refLocal = ref p;\n    refLocal = stackalloc int[13];\n}\n```\n\n----------------------------------------\n\nTITLE: Expression-Bodied Interface Default Implementation in C#\nDESCRIPTION: Example showing expression-bodied syntax for default implementations in interfaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-06-14.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1\n{\n    int M(int i, bool b, string s) => s?.Length ?? i;\n}\n\ninterface I2 : I1\n{\n    int I1.M(int i, bool b, string s) => b ? i : s?.Length ?? 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using UnscopedRef to Allow Cyclic Ref Assignment\nDESCRIPTION: Demonstrates how [UnscopedRef] attribute promotes ref safe context, allowing cyclic assignment patterns but requiring viral propagation of the attribute through the call chain.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_56\n\nLANGUAGE: csharp\nCODE:\n```\nS F()\n{\n    S local = new();\n    // Error: self assignment possible inside `S.M`.\n    S.M(ref local);\n    return local;\n}\n\nref struct S\n{\n    int field;\n    ref int refField;\n\n    public static void M([UnscopedRef] ref S s)\n    {\n        // Allowed: s has both safe-context and ref-safe-context of caller-context\n        s.refField = ref s.field;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sealed Enum of Planets in C#\nDESCRIPTION: Example of a sealed enum declaration listing planets in the solar system. Used as part of the language design discussion context.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-03-27.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed enum Planets { Earth, Jupiter, Mars, Mercury, Neptune, Pluto, Saturn, Uranus, Venus }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inferrability and Uniqueness Rules in C# Extension Declarations\nDESCRIPTION: This snippet shows examples of valid and invalid extension declarations, illustrating the inferrability requirement for type parameters and uniqueness rules within a static class.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\npublic static class MyExtensions\n{\n    extension<T1>(IEnumerable<int>) // Error! T1 not inferrable\n    {\n        ...\n    }\n    extension<T2>(IEnumerable<T2>)\n    {\n        public bool IsEmpty { get ... }\n    }\n    extension<T3>(IEnumerable<T3>?)\n    {\n        public bool IsEmpty { get ... } // Error! Duplicate declaration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: System.Threading.Lock Required Shape for lock Integration\nDESCRIPTION: The required shape of the System.Threading.Lock type that the compiler expects for the special-case behavior to work correctly. The type must be in the System.Threading namespace and have an EnterScope method returning a Scope ref struct.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/lock-object.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace System.Threading\n{\n    public sealed class Lock\n    {\n        public Scope EnterScope();\n\n        public ref struct Scope\n        {\n            public void Dispose();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: UnscopedRef Annotation Equivalence\nDESCRIPTION: Shows the annotation equivalence of methods with and without [UnscopedRef], demonstrating the lifetimes relationships that the attribute changes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_58\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S { }\n\n// C# code\nS Create1(ref S p)\nS Create2([UnscopedRef] ref S p)\n\n// Annotation equivalent\nscoped<'b> S Create1(scoped<'a> ref scoped<'b> S)\nscoped<'a> S Create2(scoped<'a> ref scoped<'b> S)\n  where 'b >= 'a\n```\n\n----------------------------------------\n\nTITLE: Var Nullability Example in C#\nDESCRIPTION: Example demonstrating the proposed behavior of var with nullable types and flow analysis.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-12-18.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar current = myLinkedList.Head; // annotated not null\nwhile (current is object)\n{\n    ...\n    current = current.Next; // warning, Next is annotated nullable, but current is non-null\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing Set Accessors in Readonly Contexts with 'field' Keyword in C#\nDESCRIPTION: Examination of whether a 'set' accessor should be allowed in a 'readonly' context for properties that use the 'field' keyword, comparing with traditional patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nreadonly struct S1\n{\n    readonly object _p1;\n    object P1 { get => _p1; set { } }   // ok\n    object P2 { get; set; }             // error: auto-prop in readonly struct must be readonly\n    object P3 { get => field; set { } } // ok?\n}\n\nstruct S2\n{\n    readonly object _p1;\n    readonly object P1 { get => _p1; set { } }   // ok\n    readonly object P2 { get; set; }             // error: auto-prop with set marked readonly\n    readonly object P3 { get => field; set { } } // ok?\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Lambda Parameters Modifier\nDESCRIPTION: Proposed change to allow 'scoped' as a modifier for simple lambda parameters, overriding previous type name interpretation\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-16.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n(scoped int x) => x * 2\n```\n\n----------------------------------------\n\nTITLE: Init Property Compatibility Example\nDESCRIPTION: Shows how adding init to existing get-only properties is a non-breaking change.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/init.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nclass Name\n{\n    public string First { get; }\n    public string Last { get; }\n\n    public Name(string first, string last)\n    {\n        First = first;\n        Last = last;\n    }\n}\n\n// After adding init\nclass Name\n{\n    public string First { get; init; }\n    public string Last { get; init; }\n\n    public Name(string first, string last)\n    {\n        First = first;\n        Last = last;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Expression with Boolean Constant\nDESCRIPTION: Illustrates a scenario involving a conditional expression with a boolean constant\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-definite-assignment.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nif (c != null ? c.M(out object obj4) : false)\n{\n    obj4.ToString(); // undesired error\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Switch Statement Example in C# with Various Case Types\nDESCRIPTION: This code demonstrates a switch statement that can handle various types of cases, including constants, type patterns, and variables. It also shows potential limitations and syntax considerations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-01-28.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nobject o = ...\nswitch(o) {\n    case 1:\n    case 2:\n    case 3:\n    case Color.Red:\n    case string s:\n    case *: // no\n    case var x: // would have to be last and there'd have to not be a default:\n    default:\n}\n```\n\n----------------------------------------\n\nTITLE: Accessibility of File-Local Classes\nDESCRIPTION: This snippet illustrates the accessibility rules for file-local classes. The `file` modifier cannot be combined with accessibility modifiers like `public` or `internal`. The default accessibility `internal` is implicitly used with `file` types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/file-local-types.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic file class C1 { } // error\ninternal file class C2 { } // error\nfile class C3 { } // ok\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with One Element Tuples in C#\nDESCRIPTION: Examples of pattern matching syntax with one element tuples.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nif (o is OneDPoint(3)) ...\nif (odp is (3)) ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a custom Where method with multiple predicates in C#\nDESCRIPTION: Demonstrates a custom Where method implementation that uses two predicates, showing how the [Filter] attribute affects nullable state analysis for different lambda parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-22.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static IEnumerable<T> Where(IEnumerable<T> source, [Filter] Func<T, bool> primary, Func<T, bool> lastChance)\n{\n    foreach (T item in source)\n    {\n        if (primary(item)) yield return item;\n        else if (lastChance(item)) yield return item;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Extension Method with Typeness\nDESCRIPTION: This snippet demonstrates how to define an extension method for the 'object' type, showcasing the impact of 'this' on the identity of the type during runtime. The method 'M' prints the type name of 'this' by using a generic identity function within the extension.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-09-30.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nextension E for object\n{\n    public void M()\n    {\n        Console.WriteLine(Identity(this));\n\n        string Identity<T>(T t) => typeof(T).Name;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exploring nullable state persistence across collection mutations in C#\nDESCRIPTION: Illustrates scenarios where collection elements' nullable states may change due to mutations, highlighting potential runtime errors that static analysis cannot catch.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-11-22.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar en = widgets.Where(widget => widget.Prop != null);\nforeach (var item in en)\n{\n    item.Prop = null;\n}\nforeach (var item in en)\n{\n    item.Prop.ToString(); // no warning and NRE at runtime\n}\n```\n\n----------------------------------------\n\nTITLE: If/Else Pattern Matching with Shared Variables in C#\nDESCRIPTION: Shows relaxed single-declaration rules within conditions of an if/else statement chain.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/pattern-variables.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nif (e is C c) { }\nelse if (e is Wrapper { Prop: C c }) { }\n```\n\n----------------------------------------\n\nTITLE: Record Struct Parameterless Primary Constructor in C#\nDESCRIPTION: These examples illustrate how a `record struct` with an empty parameter list creates a parameterless primary constructor. This constructor can also execute field initializers, simplifying the struct's initialization.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n\"record struct R3();                // primary .ctor: public R3() { }\\nrecord struct R4() { int F = 42; } // primary .ctor: public R4() { F = 42; }\"\n```\n\n----------------------------------------\n\nTITLE: Invalid usage of target-typed default with nullable constant in C#\nDESCRIPTION: Example showing that default literal cannot be used with constant declarations if the inferred type is not allowed in constants.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.1/target-typed-default.md#2025-04-21_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nconst int? y = default;\n```\n\n----------------------------------------\n\nTITLE: Modified Join Grammar\nDESCRIPTION: The proposed grammar change to support left and right join modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/left-right-join-in-query-expressions.md#2025-04-21_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\njoin_clause\n-    : 'join' type? identifier 'in' expression 'on' expression 'equals' expression\n+    : ('left' | 'right')? 'join' type? identifier 'in' expression 'on' expression 'equals' expression\n    ;\n```\n\n----------------------------------------\n\nTITLE: Using CallIndirectAttribute for indirect method calls in C#\nDESCRIPTION: This snippet shows how to use the CallIndirectAttribute to define a method that will be called indirectly using the calli instruction. It demonstrates passing a function pointer to the method.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intrinsics.md#2025-04-21_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n[CallIndirect(CallingConvention.Cdecl)]\nstatic extern int MapValue(string s, void *ptr);\n\nunsafe {\n    var i = MapValue(\"42\", &int.Parse);\n    Console.WriteLine(i);\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Property Declaration Syntax - C#\nDESCRIPTION: Alternative syntax proposal using accessibility modifiers directly on parameters to generate corresponding properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-07.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person(public string FirstName, public string LastName);\n```\n\n----------------------------------------\n\nTITLE: Dictionary Initialization Ambiguity in C#\nDESCRIPTION: This snippet highlights a potential syntactic ambiguity when using collection literals for dictionaries, specifically when ternary operators are involved within the dictionary initialization. The ambiguity arises in determining whether the expression inside the square brackets is a key-value pair or a more complex expression.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nDictionary<K, V> d = [a ? [b] : c]; // [a ? ([b]) : c)] or [(a ? [b]) : c]?\n```\n\n----------------------------------------\n\nTITLE: Referencing Type Naming Convention Issue\nDESCRIPTION: GitHub issue reference discussing the proposal for warning on lowercase type names in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-10-13.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://github.com/dotnet/roslyn/issues/56653\n```\n\n----------------------------------------\n\nTITLE: Defining a Role with Multiple Base Types in C#\nDESCRIPTION: This snippet shows how to define a role that inherits from multiple base roles and interfaces. The Role named DiamondRole is defined as extending NarrowerUnderlyingType, BaseRole1, Interface1, BaseRole2, and Interface2. This illustrates how roles can combine different base roles/interfaces without using inheritance directly.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-01-23.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nrole DiamondRole : NarrowerUnderlyingType, BaseRole1, Interface1, BaseRole2, Interface2 { }\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax Options for Roles in C#\nDESCRIPTION: This snippet proposes different options for structuring the role definitions, discussing the potential for ordering requirements and optional underlying types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-02-15.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nrole R : BaseRole(s), Interface(s)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nview VJsonView on type : views, interfaces\n```\n\nLANGUAGE: csharp\nCODE:\n```\nview VCustomer extends type : view, interfaces\n```\n\nLANGUAGE: csharp\nCODE:\n```\nview VJsonView of type : views, interfaces\n```\n\n----------------------------------------\n\nTITLE: Integer Logical Operators for UIntPtr\nDESCRIPTION: Defines logical operators (AND, OR, XOR) for System.UIntPtr type with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator &(uint, System.UIntPtr)\nSystem.UIntPtr operator &(System.UIntPtr, uint)\nSystem.UIntPtr operator &(System.UIntPtr, System.UIntPtr)\n\nSystem.UIntPtr operator |(uint, System.UIntPtr)\nSystem.UIntPtr operator |(System.UIntPtr, uint)\nSystem.UIntPtr operator |(System.UIntPtr, System.UIntPtr)\n\nSystem.UIntPtr operator ^(uint, System.UIntPtr)\nSystem.UIntPtr operator ^(System.UIntPtr, uint)\nSystem.UIntPtr operator ^(System.UIntPtr, System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Async Top-level Example with Return in C#\nDESCRIPTION: Demonstrates an async top-level program with integer return value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\nawait System.Threading.Tasks.Task.Delay(1000);\nSystem.Console.WriteLine(\"Hi!\");\nreturn 0;\n```\n\n----------------------------------------\n\nTITLE: Modified C# Foreach Statement Specification\nDESCRIPTION: Detailed language specification modification to support extension GetEnumerator methods in foreach loops. Includes rules for collection type, enumerator type, and element type determination, with support for both instance and extension methods.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extension-getenumerator.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nThe compile-time processing of a foreach statement first determines the ***collection type***, ***enumerator type*** and ***element type*** of the expression. This determination proceeds as follows:\n\n*  If the type `X` of *expression* is an array type then there is an implicit reference conversion from `X` to the `IEnumerable` interface (since `System.Array` implements this interface). The ***collection type*** is the `IEnumerable` interface, the ***enumerator type*** is the `IEnumerator` interface and the ***element type*** is the element type of the array type `X`.\n*  If the type `X` of *expression* is `dynamic` then there is an implicit conversion from *expression* to the `IEnumerable` interface. The ***collection type*** is the `IEnumerable` interface and the ***enumerator type*** is the `IEnumerator` interface. If the `var` identifier is given as the *local_variable_type* then the ***element type*** is `dynamic`, otherwise it is `object`.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Overload Resolution Ambiguity in C#\nDESCRIPTION: Demonstrates a potential ambiguity in overload resolution when using target-typed new-expressions with structs that have different members.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2018/LDM-2018-06-25.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nstruct S1 { public int x; }\nstruct S2 {}\n\nM(S1 s1);\nM(S2 s2);\n\nM(new () { x = 43 }); // ambiguous with late filter, resolved with early. What does the IDE show?\n```\n\n----------------------------------------\n\nTITLE: Declaring Non-Nullable Parameter in C#\nDESCRIPTION: Demonstrates the declaration of a method parameter marked as non-nullable using the [ShouldNotBeNull] attribute.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-01-08.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid Foo([ShouldNotBeNull] string s) { }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating List Pattern Syntax with Slice Operator\nDESCRIPTION: Examples showing different pattern matching syntax variations with the slice operator in C# list patterns, including pattern declaration and parsing behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-05-26.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n..var x and not null   // Parses as ..(var x and not null)\n..1+2             // Parses as (..1)+2\n```\n\n----------------------------------------\n\nTITLE: Proposed Stackalloc Array Initialization Syntax\nDESCRIPTION: Proposed syntax patterns for initializing stack-allocated arrays, including the current allowed syntax and new proposed variations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/stackalloc-array-initializers.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstackalloc int[3]\t\t\t\t// currently allowed\nstackalloc int[3] { 1, 2, 3 }\nstackalloc int[] { 1, 2, 3 }\nstackalloc[] { 1, 2, 3 }\n```\n\n----------------------------------------\n\nTITLE: Approach B1: Auto-prop Initialization Warning (C#)\nDESCRIPTION: Illustrates that the developer must initialize the property in the constructor, even when it might not be necessary to do so.  If not initialized, then a warning would occur.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-06-26.md#2025-04-21_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\n\"public C()\\n{\\n    // would warn, the auto-prop is not considered initialized\\n    Console.WriteLine(this.Prop);\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Future Consideration: Length-one Span<T> over Ref Values in C#\nDESCRIPTION: This snippet explores a potential future enhancement to allow creating length-one Span<T> instances over ref values. It compares the current approach using stackalloc with a proposed simpler syntax, highlighting the benefits of such a feature.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/span-safety.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvoid RefExample()\n{\n    int x = ...;\n\n    // Today creating a length one Span<int> requires a stackalloc and a new \n    // local\n    Span<int> span1 = stackalloc [] { x };\n    Use(span1);\n    x = span1[0]; \n\n    // Simpler to just allow length one span\n    var span2 = new Span<int>(ref x);\n    Use(span2);\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Function with Ad Hoc Union Array in C#\nDESCRIPTION: Shows how ad hoc unions with the same member types are interchangeable through generics and array elements, with an example function returning an array of union types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_20\n\nLANGUAGE: csharp\nCODE:\n```\n(T1 or T2)[] F<T1, T2>(T1 v1, T2 v2) => new (T1 or T2)[] { v1, v2 };\n\n(Dog or Cat)[] pets = F<Dog, Cat>(rufus, petunia);\n```\n\n----------------------------------------\n\nTITLE: Example of Tuple Element Name Warning\nDESCRIPTION: Example showing how providing an explicit tuple element name in a literal will trigger a warning if it doesn't match the target tuple element name during comparison.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/tuple-equality.md#2025-04-21_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n(int a, int b) t;\nt == (c, d: 0)\n```\n\n----------------------------------------\n\nTITLE: Type Tests on Boxed Union Structs\nDESCRIPTION: Explains how type testing and unboxing works with union structs, including translation to TryGet methods when a union struct's member type is checked.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/TypeUnions.md#2025-04-21_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nU u = ...;\nobject value = u;\n\n// will succeed since A is known to be a member type of U\nif (value is A a) {...}\n\nTranslates to:\n\nif (value is A a || (value is U u && u.TryGetA(out a))) {...}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with ReadOnlySpan<char> for Empty String\nDESCRIPTION: This example demonstrates how to use a switch expression with ReadOnlySpan<char> to check against null or empty string constants.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/pattern-match-span-of-char-on-string.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstatic bool IsEmpty(ReadOnlySpan<char> span)\n{\n    return span switch\n    {\n        (string)null => true, // ok?\n        \"\" => true,           // error: unreachable?\n        _ => false,\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Unsigned Right Shift with Expression Trees in C#\nDESCRIPTION: This code snippet demonstrates an attempt to use the unsigned right shift operator in a LINQ expression tree. Due to limitations in representing the semantics of the operator for signed types, the example shows that the expression is converted into a more complex expression that includes conversions to unsigned types and back. This approach was ultimately rejected.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/unsigned-right-shift-operator.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n\"Expression<System.Func<int, int, int>> z = (x, y) => x >>> y; // (x, y) => Convert((Convert(x, UInt32) >> y), Int32)\"\n```\n\n----------------------------------------\n\nTITLE: Error Messages for Invalid Struct Auto-Properties\nDESCRIPTION: Error messages that would be generated by the compiler when attempting to use auto-properties in structs without proper initialization before C# 6.0.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-6.0/struct-autoprop-init.md#2025-04-21_snippet_1\n\nLANGUAGE: none\nCODE:\n```\nerror CS0188: The 'this' object cannot be used before all of its fields are assigned to\nerror CS0843: Backing field for automatically implemented property 'S.X' must be fully assigned before control is returned to the caller. Consider calling the default constructor from a constructor initializer. \nerror CS0843: Backing field for automatically implemented property 'S.Y' must be fully assigned before control is returned to the caller. Consider calling the default constructor from a constructor initializer. \n```\n\n----------------------------------------\n\nTITLE: Extension Method Lookup with Span Types\nDESCRIPTION: Shows how implicit span conversions affect extension method resolution, demonstrating the change in behavior between current and future implementations when resolving extension methods across different namespaces.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace N1\n{\n    using N2;\n\n    public class C\n    {\n        public static void M()\n        {\n            Span<string> span = new string[0];\n            span.Test(); // Prints N2 today, N1 tomorrow\n        }\n    }\n\n    public static class N1Ext\n    {\n        public static void Test(this ReadOnlySpan<string> span)\n        {\n            Console.WriteLine(\"N1\");\n        }\n    }\n}\n\nnamespace N2\n{\n    public static class N2Ext\n    {\n        public static void Test(this Span<string> span)\n        {\n            Console.WriteLine(\"N2\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependent Nullability Check with HasValue Pattern\nDESCRIPTION: Example showing desired pattern for null checking where a HasValue check should inform the compiler about nullability of the Value property.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-02-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nif (x.HasValue)\n{\n    x.Value // should not warn when HasValue is true\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Comparer Syntax Proposals\nDESCRIPTION: Shows various proposed syntax options for specifying comparers in collection expressions, including labeled and delimited variations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/dictionary-expressions.md#2025-04-23_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\n// `comparer: ...` to indicate the purpose of this value\nDictionary<string, int> caseInsensitiveMap = [comparer: StringComparer.CaseInsensitive, .. existingMap];\n\n// Semicolon to more clearly delineate the comparer\nDictionary<string, int> caseInsensitiveMap = [StringComparer.CaseInsensitive; .. existingMap];\n\n// Both?\nDictionary<string, int> caseInsensitiveMap = [comparer : StringComparer.CaseInsensitive; .. existingMap];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Flow-Based Nullability Checking in C#\nDESCRIPTION: Illustrates various scenarios where flow analysis determines that a potentially null value is safe to use after null checks or assignments.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-04-01-08.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvoid Ok1([CouldBeNull] string s)\n{\n    s = \"Not null\";\n    Foo(s); // Ok\n}\nvoid Ok2([CouldBeNull] string s)\n{\n    if (s != null)\n    {\n        Foo(s); // Ok\n    }\n}\nvoid Ok3([CouldBeNull] string s)\n{\n    if (s == null)\n    {\n        throw new ArgumentNullException();\n    }\n    Foo(s); // Ok\n}\nvoid Ok4([CouldBeNull] string s)\n{\n    if (s == null)\n    {\n        s = \"NotNull\";\n    }\n    Foo(s); // Ok\n}\nvoid Ok5([CouldBeNull] string s)\n{\n    if (s != null && s.Length > 0) // Ok\n    {\n    }\n}\nvoid Ok6([CouldBeNull] string s)\n{\n    if (s == null || s.Length > 0) // Ok\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Init Method - C#\nDESCRIPTION: The code snippet presents a possible signature for an `Init` method used to initialize dictionaries from dictionary literals. The method would receive an array of `KeyValuePair<TKey, TValue>` objects, allowing for efficient construction of the dictionary. This echoes the similar init strategy proposed for collection literals.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-06.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n\"// Or ReadOnlySpan<>, just like with collection literals\\ninit void Init(KeyValuePair<TKey, TValue>[] values)\"\n```\n\n----------------------------------------\n\nTITLE: Adding Unsigned Right Shift to Overloadable Binary Operators in ANTLR\nDESCRIPTION: This snippet includes the `unsigned_right_shift` operator in the list of overloadable binary operators defined in the ANTLR grammar. This allows developers to define custom behavior for the `>>>` operator when applied to user-defined types. Operator overloading enables polymorphism for the new operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/unsigned-right-shift-operator.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\n\"overloadable_binary_operator\\n    : '+'   | '-'   | '*'   | '/'   | '%'   | '&'   | '|'   | '^'   | '<<'\\n    | right_shift | unsigned_right_shift | '=='  | '!='  | '>'   | '<'   | '>='  | '<='\\n    ;\"\n```\n\n----------------------------------------\n\nTITLE: Solutions for Struct Property Setter Assignment\nDESCRIPTION: Provides examples of workarounds for initializing fields in structs with property setters, by either assigning a value in the constructor before using the property setter or directly assigning the field with repeated logic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/auto-default-structs.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstruct S\n{\n    private int _x;\n    public int X\n    {\n        get => _x;\n        set => _x = value >= 0 ? value : throw new ArgumentOutOfRangeException();\n    }\n\n    // Solution 1: assign some value in the constructor before \"really\" assigning through the property setter.\n    public S(int x)\n    {\n        _x = default;\n        X = x;\n    }\n\n    // Solution 2: assign the field once in the constructor, repeating the implementation of the setter.\n    public S(int x)\n    {\n        _x = x >= 0 ? x : throw new ArgumentOutOfRangeException();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Proposed Syntax for Partially Automatic Properties in C#\nDESCRIPTION: A code example showing a proposed syntax for partially automatic properties where a backing field can be declared inside the property and is only accessible within that property's scope.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-03-19.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic int Property\n{\n    private int _field;\n    get => _field;\n    set { _field = value; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Interface Members in C#\nDESCRIPTION: Demonstrates the proposed syntax for implementing default interface members using explicit interface implementation rather than overriding. This approach aligns more closely with the existing interface implementation paradigm.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-05-31.md#2025-04-21_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\ninterface I1\n{\n\tvoid M1();\n}\n\ninterface I2 : I1\n{\n\tvoid I1.M1 { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Lambda Parameter Example in C#\nDESCRIPTION: Example demonstrating current limitations with lambda parameter modifiers where type inference is not allowed.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/readonly-parameters.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ndelegate void D(ref int i);\nD d = (ref i) => {};\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Issue with INumberBase<T> Example in C#\nDESCRIPTION: This code demonstrates a counterintuitive behavior where pattern matching a generic type parameter constrained to INumberBase<T> against a numeric constant produces an error, even though it might seem like it should work with numeric types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/static-abstracts-in-interfaces.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nM(1.0);\n\nstatic void M<T>(T t) where T : INumberBase<T>\n{\n    Console.WriteLine(t is 1); // Error. Cannot use a numeric constant\n    Console.WriteLine((t is int i) && (i is 1)); \n}\n```\n\n----------------------------------------\n\nTITLE: Indexing Syntax for Extension Methods in C#\nDESCRIPTION: Presents an indexing-style syntax for invoking extension methods, mirroring array-like access patterns. This form enhances readability and introduces a concise way to target extension operations applicable to indexed collections.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/disambiguation-syntax-examples.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\n// Static extension members\nvar range = MyExtensions[IEnumerable<int>].Range(0, 10);\nvar empty = MyExtensions[IEnumerable<int>].Empty;\nMyExtensions[range] += 5;\nReadOnlySpan<int> span = MyExtensions[range];\n\n// Instance extension members\nvar query = MyExtensions[range].Where(i => i < 10);\nvar isEmpty = MyExtensions[query].IsEmpty;\nvar first = MyExtensions[query][0];\nvar repetition = new MyExtensions[IEnumerable<int>](first, 10);\n```\n\n----------------------------------------\n\nTITLE: Discriminated Union Example with Inline Values vs Struct Values in C#\nDESCRIPTION: Example showing two different potential representations of discriminated unions in C#, one using inline primitive values and the other using struct values, illustrating layout efficiency concerns discussed in the meeting.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2023/LDM-2023-03-08.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nunion { MyFourInts(int, int, int, int), MyThreeInts(int, int, int) }\nunion { MyFourInts(StructOfFourInts), MyThreeInts(StructOfThreeInts) }\n```\n\n----------------------------------------\n\nTITLE: Markdown Meeting Notes Structure\nDESCRIPTION: Structured meeting notes with agenda items, quotes of the day, and detailed discussion points about C# language design decisions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-01-24.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# C# Language Design Meeting for January 24th, 2022\n\n## Agenda\n\n1. [Required members metadata representation](#required-members-metadata-representation)\n2. [Default implementations of abstract statics](#default-implementations-of-abstract-statics)\n3. [Triage](#triage)\n    1. [Nested members in with and object creation](#nested-members-in-with-and-object-creation)\n    2. [Binary Compat Only](#binary-compat-only)\n    3. [Attribute for passing caller identity implicitly](#attribute-for-passing-caller-identity-implicitly)\n    4. [Attributes on Main for top level programs](#attributes-on-main-for-top-level-programs)\n```\n\n----------------------------------------\n\nTITLE: Naive Stack Allocation translation in C#\nDESCRIPTION: This code snippet presents an undesirable translation of a collection literal to stackalloc within a loop.  This direct use of `stackalloc` inside the loop will grow the stack on each iteration, which can cause stack overflow errors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-2022-10-21.md#2025-04-21_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nforeach (...)\n{\n   Span<T> values = stackalloc T[3];\n```\n\n----------------------------------------\n\nTITLE: Concatenating UTF-8 String Literals in C#\nDESCRIPTION: Example code demonstrating the proposed concatenation of UTF-8 string literals using the + operator. This shows a function returning a UTF-8 string literal and attempting to concatenate it with another literal, which was discussed as a case not to be supported.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-06-29.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nReadOnlySpan<byte> M() => \"hello \"u8;\nvar helloWorld = M() + \"world\"u8;\n```\n\n----------------------------------------\n\nTITLE: Defining Null-Forgiving Operator Grammar in ANTLR\nDESCRIPTION: ANTLR grammar rules defining the syntax for the null-forgiving operator (!) in expressions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/nullable-reference-types-specification.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nprimary_expression\n    : ...\n    | null_forgiving_expression\n    ;\n    \nnull_forgiving_expression\n    : primary_expression '!'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Nullability Attributes in C#\nDESCRIPTION: Examples showing use of [AllowNull] and [NotNull] attributes for array resizing methods to handle nullable references.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-05-15.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Array \n{ \n    // [AllowNull] on a non-nullable ref to express that nulls may be passed in, \n    // but that nulls will not come out. \n    public static void Resize<T>([AllowNull] ref T[] array, int newSize); \n \n    // Alternatively, [NotNull] on a nullable ref to express that nulls \n    // may be passed in but will not be passed out. \n    public static void Resize<T>([NotNull] ref T[]? array, int newSize); \n}\n```\n\n----------------------------------------\n\nTITLE: Array Initializer Examples for Inline Array Types in C# (Proposed)\nDESCRIPTION: This snippet shows proposed syntax for initializing inline array types using array initializers, including both anonymous and user-defined inline arrays.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nint[5] a = {1, 2, 3, 4, 5}; // initializes anonymous inline array of length 5\nBuffer10<int> b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // initializes user-defined inline array\nvar c = new int[][] {{11, 12}, {21, 22}, {31, 32}}; // An error for the nested array initializer\nvar d = new int[][2] {{11, 12}, {21, 22}, {31, 32}}; // An error for the nested array initializer\n```\n\n----------------------------------------\n\nTITLE: Demonstrating params Span<T> Usage in C#\nDESCRIPTION: Conceptual feature demonstration for params Span<T>, which would allow more efficient parameter array handling without requiring multiple overloads. This was discussed but no actual code was provided in the meeting notes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-11-03.md#2025-04-21_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Implementing Readonly Methods in Vector2 Struct\nDESCRIPTION: Demonstrates implementation of readonly and non-readonly methods in a Vector2 struct, showing compiler enforcement of state immutability and illegal modifications.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/readonly-instance-members.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic struct Vector2\n{\n    public float x;\n    public float y;\n\n    public readonly float GetLengthReadonly()\n    {\n        return MathF.Sqrt(LengthSquared);\n    }\n\n    public float GetLength()\n    {\n        return MathF.Sqrt(LengthSquared);\n    }\n\n    public readonly float GetLengthIllegal()\n    {\n        var tmp = MathF.Sqrt(LengthSquared);\n\n        x = tmp;    // Compiler error, cannot write x\n        y = tmp;    // Compiler error, cannot write y\n\n        return tmp;\n    }\n\n    public readonly float LengthSquared\n    {\n        get\n        {\n            return (x * x) +\n                   (y * y);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing IsEmpty Extension Method with Named Parameter in C#\nDESCRIPTION: Shows how the proposed relaxation affects the implementation of extension methods, requiring the use of the parameter name instead of 'this' to access the underlying value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extending-extensions-a-guide-to-relaxation.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class Enumerable\n{\n    extension(IEnumerable source)\n    {\n        // Must use the parameter name to access the underlying value.\n        public bool IsEmpty => !source.GetEnumerator().MoveNext();\n\n        // Removing the parameter name would make it possible to use this, implicitly and explicitly.\n        // public bool IsEmpty => !this.GetEnumerator().MoveNext();\n        // public bool IsEmpty => !GetEnumerator().MoveNext();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Partial Transparency for KeyValuePair in C# Dictionary Expressions\nDESCRIPTION: This example demonstrates partial transparency support for KeyValuePair, allowing implicit conversion only when targeting dictionary types but not for other collection types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-05-15-KeyValuePairCorrespondence.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nKeyValuePair<string, int> kvp = new(\"mads\", 21);\nDictionary<object, int?> map1 = [kvp]; // legal.\n\nList<KeyValuePair<object, int?>> map1 = [kvp]; // not legal.  User must write:\nList<KeyValuePair<object, int?>> map1 = [kvp.Key: kvp.Value]; // or\nList<KeyValuePair<object, int?>> map1 = [new KeyValuePair<object, int?>(kvp.Key, kvp.Value)];\n```\n\n----------------------------------------\n\nTITLE: Interface Declaration with Static Virtual Equality Operators\nDESCRIPTION: Example of a potentially confusing interface declaration with static virtual equality operators that apply to the interface type itself. This is discussed as an approach that could lead to confusion since the operators wouldn't apply to instances of the interface.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-06-06.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IThing\n{\n    static virtual bool operator ==(IThing i1, IThing i2) => ...\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Struct with Field Initializers and No Constructor Error in C#\nDESCRIPTION: This code snippet shows a scenario that results in a compiler error: a struct with field initializers but without an explicitly declared constructor. The compiler flags this because the field initializers would never be executed, leading to uninitialized fields.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/parameterless-struct-constructors.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n\"struct S { int F = 42; } // error: 'struct' with field initializers must include an explicitly declared constructor\"\n```\n\n----------------------------------------\n\nTITLE: Choosing Keywords for Role Declaration in C#\nDESCRIPTION: This snippet evaluates various candidates for the keyword to define roles and reviews the preferred choices among candidates for implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-02-15.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nrole\n```\n\nLANGUAGE: csharp\nCODE:\n```\nview\n```\n\nLANGUAGE: csharp\nCODE:\n```\nshape\n```\n\nLANGUAGE: csharp\nCODE:\n```\nalias\n```\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit extension Role for U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit view Role for U\n```\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit view Extension for U\n```\n\n----------------------------------------\n\nTITLE: Implementing params with IEnumerable overload pattern in C#\nDESCRIPTION: Demonstrates a common pattern for supporting both params arrays and IEnumerable<T> by implementing overloaded methods. One method accepts a params array while the other accepts IEnumerable<T>, with the params version delegating to the IEnumerable version.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nabstract class Logger\n{\n    public abstract void Log(string format, IEnumerable<object> args);\n\n    public void Log(string format, params object[] args)\n    {\n        Log(format, (IEnumerable<object>)args);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Syntax with Explicit Type Declaration for Receiver Parameters in C#\nDESCRIPTION: Example showing a more explicit syntax alternative where receiver parameters always include both name and type. This approach aims to make extension methods more regular with standard method declarations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions-an-evolution-of-extension-methods.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nextensions StringExtensions for string\n{\n    public bool ([NotNullWhen(false)] string? s) IsNullOrEmpty => ...;\n    \n    public int (string text) CountWord(string word) => ...;\n}\n```\n\n----------------------------------------\n\nTITLE: Disallowing Target Typing with Collection Expressions in C#\nDESCRIPTION: This snippet demonstrates the result of disallowing target typing with collection expressions. The user is forced to explicitly specify the type they want to generate, which decreases simplicity and brevity.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/Core-interface-target-type-proposal.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvoid DoSomething(IEnumerable<int> values) { ... }\n\n// Not allowed.\nDoSomething([1, 2, 3]);\n\n// Write this instead:\nDoSomething((List<int>)[1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Cast Operators for UIntPtr\nDESCRIPTION: Defines various cast operators for System.UIntPtr, including conversions to and from integer types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nexplicit operator sbyte(System.UIntPtr)               // Truncate\nexplicit operator short(System.UIntPtr)               // Truncate\nexplicit operator int(System.UIntPtr)                 // Truncate\nexplicit operator long(System.UIntPtr)                // Sign Extend\n\nexplicit operator byte(System.UIntPtr)                // Truncate\nexplicit operator ushort(System.UIntPtr)              // Truncate\nexplicit operator uint(System.UIntPtr)                // Truncate\nexplicit operator ulong(System.UIntPtr)               // Zero Extend\n\nexplicit operator System.UIntPtr(int)                 // Zero Extend\nexplicit operator System.UIntPtr(long)                // Truncate\n\nexplicit operator System.UIntPtr(uint)                // Zero Extend\nexplicit operator System.UIntPtr(ulong)               // Truncate\n\nexplicit operator System.UIntPtr(System.IntPtr)\nexplicit operator System.UIntPtr(System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Existing Field-Targeted Attribute Support for Events in C#\nDESCRIPTION: This example shows how field-targeted attributes are already supported for events in C#, which serves as a precedent for the proposed property feature. The proposal aims to bring parity between events and properties.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/auto-prop-field-attrs.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[Serializable]\npublic class Foo\n{\n    [field: NonSerialized]\n    public event EventHandler MyEvent;\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar Extension for Collection Elements in C#\nDESCRIPTION: Grammar modification to add with_element as a new type of collection_element alongside existing expression, spread and key-value pair elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/collection-expression-arguments.md#2025-04-23_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\ncollection_element\n   : expression_element\n   | spread_element\n   | key_value_pair_element\n+  | with_element\n   ;\n\n+with_element\n+  : 'with' argument_list\n+  ;\n```\n\n----------------------------------------\n\nTITLE: Ref Struct Field Assignment Example in C#\nDESCRIPTION: Demonstrates potential safety issues with ref struct field assignments when 'this' is not scoped ref by default. Shows how uncontrolled ref reassignment could lead to dangerous scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\nref struct Sneaky\n{\n    int Field;\n    ref int RefField;\n\n    public void SelfAssign()\n    {\n        // This pattern of ref reassign to fields on this inside instance methods would now\n        // completely legal.\n        RefField = ref Field;\n    }\n\n    static Sneaky UseExample()\n    {\n        Sneaky local = default;\n\n        // Error: this is illegal, and must be illegal, by our existing rules as the \n        // ref-safe-context of local is now an input into method arguments must match. \n        local.SelfAssign();\n\n        // This would be dangerous as local now has a dangerous `ref` but the above \n        // prevents us from getting here.\n        return local;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Reference to Union Types in C#\nDESCRIPTION: A code reference from the discussion mentioning the OfType<Cat or Dog>() pattern, which was highlighted as a potential pitfall in adhoc unions implementation.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2025/LDM-2025-01-13.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nOfType<Cat or Dog>()\n```\n\n----------------------------------------\n\nTITLE: Lambda Capture vs. Extension Method in C#\nDESCRIPTION: Comparison showing two approaches: one using a lambda that captures 'this' and another using an extension method to avoid 'this' capture. The extension method approach helps prevent memory leaks.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/README.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Lambda captures 'this'\nbigExpensiveField.ForEveryFoo(foo => {\n    this.DoSomething(foo);\n});\n\n// Extension method doesn't capture 'this'\nbigExpensiveField.ForEveryFoo(this.DoSomethingWithFoo);\n```\n\n----------------------------------------\n\nTITLE: Name Shadowing in Local Functions\nDESCRIPTION: Discussion of name shadowing behavior in local functions and lambdas, where a variable can be both captured from outer scope and shadowed in nested scope. No actual code was provided in the meeting notes.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-11-03.md#2025-04-21_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Demonstrating Unconditional Deconstruction in C#\nDESCRIPTION: This snippet shows a potential future syntax for unconditional deconstruction, where pattern matching is used to introduce new variables into scope without explicitly specifying the type.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-04-06.md#2025-04-21_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\n(string name, int age) = GetPerson();    // Unconditional deconstruction\nWriteLine($\"{name} is {age} years old\"); // name and age are in scope\n```\n\n----------------------------------------\n\nTITLE: Testing Nullable Types in C#\nDESCRIPTION: This example shows how to simplify the process of checking and using nullable types in C#. It compares the traditional approach using HasValue and GetValueOrDefault with a more concise pattern matching approach.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nType? v = x?.y?.z;\nif (v.HasValue) {\n    var value = v.GetValueOrDefault();\n    // code using value\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nif (x?.y?.z is Type value) {\n    // code using value\n}\n```\n\n----------------------------------------\n\nTITLE: Proposed NullableOut and NullableIn Attributes in C#\nDESCRIPTION: This snippet demonstrates a potential solution using proposed [NullableOut] and [NullableIn] attributes to denote nullable covariance and contravariance for generic type parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/nullability-improvements/NI-2022-10-24.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IEquatable<[NullableIn] T> { }\nclass Task<[NullableOut] T> { }\nstruct ImmutableArray<[NullableOut] T> { }\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Reachability Example\nDESCRIPTION: Example demonstrating pattern matching reachability analysis with irrefutable patterns.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-12-07-14.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nint i = 3\nif (i is int j) {}\nelse { /* reachable? */ }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Base Call on Parameterless Record in C#\nDESCRIPTION: This code snippet illustrates a currently invalid scenario where a derived record attempts to call a base record constructor without parameters. The team decided to allow empty parentheses as a constructor in C# 9 to address this issue.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-08-24.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nrecord Base(int a);\nrecord Derived : Base(1);\n```\n\n----------------------------------------\n\nTITLE: Record Struct Property Definition\nDESCRIPTION: Example of property definition in record structs showing mutable property syntax\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-10-05.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic string FirstName { get; set; }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the Need for Null-resilient Getters in C#\nDESCRIPTION: Example showing the current ungainly approach of manually adding nullability attributes to lazily-initialized properties to avoid compiler warnings about initialization in constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/field-keyword/FK-2024-08-07 Nullability analysis with the `field` keyword.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// This is ungainly.\n[field: MaybeNull]\npublic List<int> Prop => field ??= new();\n```\n\n----------------------------------------\n\nTITLE: Comparing Explicit Invoke Method with Proposed Invoker Syntax in C#\nDESCRIPTION: Comparison between using an explicit Invoke method versus the proposed more concise invoker syntax, highlighting the minimal difference in usage.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2013/LDM-2013-10-21.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nmyOperation.Invoke(5, \"Hello\"); // instead of\nmyOperation(5, \"Hello\");\n```\n\n----------------------------------------\n\nTITLE: Runtime Type Checking Issues with Tuples in C#\nDESCRIPTION: Demonstrates potential runtime type checking issues with tuples where member names might be lost, causing false positives in pattern matching scenarios.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-02-11.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nobject o = (a: 7, b: 9);\nif (o is (int x, int y) t) WriteLine(t.x); // false positive\n```\n\n----------------------------------------\n\nTITLE: Analyzing Parenthesized Type Expression Ambiguity in C#\nDESCRIPTION: Demonstrates the ambiguous syntax when using parenthesized type expressions with member access. Shows how (A).B can be interpreted differently depending on whether A is a type or value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/target-typed-static-member-lookup.md#2025-04-21_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n(A).B\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compiler Emission for params ReadOnlySpan<T> in C#\nDESCRIPTION: Example showing how a call to a method with params ReadOnlySpan<T> might be emitted by the compiler using FixedSizeBuffer3<T>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/params-span.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar _tmp = new FixedSizeBuffer3<object>();\n_tmp.Items[0] = x;\n_tmp.Items[1] = y;\n_tmp.Items[2] = z;\n\n// Logger.Log(string format, params ReadOnlySpan<object> args);\nlog.Log(\"({0}, {1}, {2})\",\n    MemoryMarshal.CreateReadOnlySpan<object>(ref _tmp.Items, 3));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ambiguous String Interpolation in C#\nDESCRIPTION: Example showing how certain expressions within string interpolation holes can be ambiguous, specifically with conditional operators and format specifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-05-21.md#2025-04-21_snippet_6\n\nLANGUAGE: c#\nCODE:\n```\n$\"{a as b ? â€“ c : d}\" // ?: or nullable type and format specifier?\n```\n\n----------------------------------------\n\nTITLE: Changed Behavior of Out Parameters in C#\nDESCRIPTION: Illustrates how the language changed the default ref-safe-context for 'out' parameters to be function-member scope. This prevents returning out parameters by reference and increases API flexibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/low-level-struct-improvements.md#2025-04-21_snippet_9\n\nLANGUAGE: c#\nCODE:\n```\nref int Sneaky(out int i) \n{\n    i = 42;\n\n    // Error: ref-safe-context of out is now function-member\n    return ref i;\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar Modification for Supporting Partial Indexers in C#\nDESCRIPTION: Syntax grammar diff showing the modifications needed to support the 'partial' keyword with indexer declarations in C#.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/partial-properties.md#2025-04-21_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\nindexer_declaration\n-    : attributes? indexer_modifier* indexer_declarator indexer_body\n+    : attributes? indexer_modifier* 'partial'? indexer_declarator indexer_body\n-    | attributes? indexer_modifier* ref_kind indexer_declarator ref_indexer_body\n+    | attributes? indexer_modifier* 'partial'? ref_kind indexer_declarator ref_indexer_body\n    ;\n```\n\n----------------------------------------\n\nTITLE: Source Generator Type Name Generation\nDESCRIPTION: Alternative approach to generating type name constants using a source generator with a generative attribute\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-10-16.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[GenerateTypeName<MyType>()]\npublic partial class TypeNameHolder { }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C# Null-Check Operator Syntax\nDESCRIPTION: Example showing the !! syntax for parameter null checking and ! for null-forgiveness operator in C#, illustrating the distinction between the two operators.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-06.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nx!\n```\n\nLANGUAGE: csharp\nCODE:\n```\n!!\n```\n\n----------------------------------------\n\nTITLE: Specifying SkipLocalsInitAttribute in C#\nDESCRIPTION: Example of how to use the `System.Runtime.CompilerServices.SkipLocalsInitAttribute` to suppress the `localsinit` flag. This attribute can be applied to methods, properties, modules, classes, structs, interfaces, and constructors.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/skip-localsinit.md#2025-04-21_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[System.Runtime.CompilerServices.SkipLocalsInitAttribute]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Abstract Implementation of Interface Method (C#)\nDESCRIPTION: Example showing how a class can implement an interface method with an abstract method, which is permitted to maintain backward compatibility.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\ninterface I1\n{\n    void M() { }\n}\nabstract class C : I1\n{\n    public abstract void M(); // implement I1.M with an abstract method in C\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Element-wise Comparisons with Type Conversions\nDESCRIPTION: Example showing how tuple literals with different element types create a converted tuple type formed by element-wise conversions when binding the equality operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.3/tuple-equality.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n(1L, 2, \"hello\") == (1, 2L, null)\n```\n\n----------------------------------------\n\nTITLE: Potential implicit dereferencing with null-coalescing operator\nDESCRIPTION: This code snippet presents an unresolved question about whether support should be extended to implicit dereferencing when using the null-coalescing operator with pointers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/inactive/pointer-null-coalescing.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nint* foo = null;\nint bar = foo ?? 3;\n```\n\n----------------------------------------\n\nTITLE: Anonymous Type With Expression Example\nDESCRIPTION: Syntax example showing the proposed extension of with expressions to anonymous types, allowing property modifications similar to records.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-09-28.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnew { }\n```\n\n----------------------------------------\n\nTITLE: Constructor Parameter Syntax in Class Declaration\nDESCRIPTION: Further simplified syntax moving constructor parameters to class declaration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-01-15.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class Point(X, Y)\n{\n    public key int X { get; }\n    public key int Y { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Record Struct Property Initialization Example\nDESCRIPTION: Demonstrates potential confusion with record struct property initialization where the initializer bypasses the property setter validation. The example shows how direct field assignment could skip setter validation logic.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-02.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nnew Rec(-1);\n\nrecord struct Rec(int Item)\n{\n    public int Item { get; set => value < 0 ? throw new Exception() : field = value; } = Item;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Confusion with 'init' Keyword in C#\nDESCRIPTION: Example showing how using 'init' as a prefix for field assignment could lead to confusion with the existing 'init' accessor.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/fieldof.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nclass C\n{\n    public string Prop { get; init { SideEffect(); field = value; } }\n    public C(string prop)\n    {\n        // wait.. putting 'init' here means \"don't use the init accessor\"?\n        init Prop = prop;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Interface Implementation Example\nDESCRIPTION: Example showing explicit implementation of IAdditiveIdentity interface with current constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/self-constraint.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IAdditiveIdentity<TSelf>\n    where TSelf : IAdditiveIdentity<TSelf>\n{\n    static abstract TSelf AdditiveIdentity { get; }\n}\n\npublic struct Half : IAdditiveIdentity<Half>\n{\n    public Half IAdditiveIdentity<Half>.AdditiveIdentity { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Await Using Statement with Ref Struct Implementation\nDESCRIPTION: Demonstrates async disposal of a ref struct implementing IAsyncDisposable interface using await using statement.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-13.0/ref-struct-interfaces.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nref struct S2 : IAsyncDisposable\n{\n    ValueTask IAsyncDisposable.DisposeAsync()\n    {\n    }\n}\n\nclass C\n{\n    static async Task Main()\n    {\n        await using (new S2())\n        {\n        } // S2.IAsyncDisposable.DisposeAsync\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for Out Variable Declaration\nDESCRIPTION: Defines the grammar rule for out variable declarations in method arguments, allowing a type and identifier to be specified directly in the out argument position.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/out-var.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nargument_value\n    : 'out' type identifier\n    | ...\n    ;\n```\n\n----------------------------------------\n\nTITLE: Interface Methods with Structs Implementation\nDESCRIPTION: Demonstrates the interaction between default interface methods and structs, showing how boxing occurs when accessing interface methods on structs.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-8.0/default-interface-methods.md#2025-04-23_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IA\n{\n    public void M() { }\n}\nstruct S : IA\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Potential CLR Stack Allocation Helpers in C#\nDESCRIPTION: Illustrates potential CLR enhancements for universal stack allocation, which could be used to efficiently allocate backing storage for params Span<T> calls. Includes examples of StackAlloc and MaybeStackAlloc intrinsics.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/format.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class BetterAllocation {\n    static void Use(params Span<string> spans) {\n        ...\n    }\n\n    static void Go() {\n        Use(\"hello\", \"world\");\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class ZeroAllocation {\n    static void Go() {\n        Span<T> span = RuntimeIntrinsic.StackAlloc<string>(length: 2);\n        span[0] = \"hello\";\n        span[1] = \"world\";\n        Use(span);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Parameter Capture Syntax\nDESCRIPTION: New syntax proposal for explicit parameter capture in primary constructors using accessibility modifiers.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-02-03.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic class Person(private string first, private string last)\n{\n    public string Name => _first + \" \" + _last;\n}\n```\n\n----------------------------------------\n\nTITLE: Assert Equal Ambiguity Examples\nDESCRIPTION: Shows ambiguity issues in unit testing scenarios where type inference now succeeds for both array and Span overloads, requiring explicit AsSpan() calls.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/first-class-span-types.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = new long[] { 1 };\nAssert.Equal([2], x); // previously Assert.Equal<T>(T[], T[]), now ambiguous with Assert.Equal<T>(ReadOnlySpan<T>, Span<T>)\nAssert.Equal([2], x.AsSpan()); // workaround\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = new int[] { 1, 2 };\nvar s = new ArraySegment<int>(x, 1, 1);\nAssert.Equal(x, s); // previously Assert.Equal<T>(T, T), now ambiguous with Assert.Equal<T>(Span<T>, Span<T>)\nAssert.Equal(x.AsSpan(), s); // workaround\n```\n\n----------------------------------------\n\nTITLE: Tuple Variable Declaration Examples in C#\nDESCRIPTION: Various syntax examples for declaring tuple variables with zero and one elements.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-03-15.md#2025-04-21_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\n() t = ();\n(int x) = (5);\n(int x) = (d); // could go either way - deconstruct a womple, or deconstruct d?\n```\n\n----------------------------------------\n\nTITLE: Deriving Extension Types in C#\nDESCRIPTION: Illustrates a potential syntax for deriving extension types from other extension types, where the underlying type could be derived from base extensions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/extensions-2023-02-21.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nimplicit extension R : R1, R2\n```\n\n----------------------------------------\n\nTITLE: IntelliSense Nullable Parameter Example in C#\nDESCRIPTION: Example showing potential IntelliSense challenges with nullable types and method parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-08-23.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvoid M(string s) => ...;\n\nstring? s = \"Hello\";\n\nM(s); // Does IntelliSense confuse you here if the type of 's' is shown as 'string?' ?\n```\n\n----------------------------------------\n\nTITLE: Meeting Header and Agenda Section\nDESCRIPTION: Markdown formatted header showing meeting date and agenda structure\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-12-02.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# C# Language Design Meeting for December 2nd, 2020\n\n## Agenda\n\n1. [Partner scenarios in roles and extensions](#partner-scenarios-in-roles-and-extensions)\n```\n\n----------------------------------------\n\nTITLE: Equivalent Shape Class Definition\nDESCRIPTION: Shows the equivalent class-based implementation of the Shape enum class example.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/discriminated-unions.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n abstract partial class Shape\n{\n    public record Rectangle(float Width, float Length) : Shape;\n    public record Circle(float Radius) : Shape;\n}\n```\n\n----------------------------------------\n\nTITLE: Future Work: Merging Static Class and Extension Declaration Syntax\nDESCRIPTION: Proposed shorthand syntax that merges static class and extension declaration into a single construct for brevity. This approach is similar to a 'type-based' extension model where the container itself is named.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extension-members-unified-proposal.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\npublic static class EmptyExtensions : extension(IEnumerable source)\n{\n    public bool IsEmpty => !source.GetEnumerator().MoveNext();\n}\n```\n\n----------------------------------------\n\nTITLE: Overload Resolution Subtleties with Named Arguments\nDESCRIPTION: Example showing potential subtleties in overload resolution when using named arguments. Different combinations of named and positional arguments can result in calling different overloads, which can be confusing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.2/non-trailing-named-arguments.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvoid M(int x, int y) { }\nvoid M<T>(T y, int x) { }\n\nvoid M2()\n{\n    M(3, 4);\n    M(y: 3, x: 4); // Invokes M(int, int)\n    M(y: 3, 4); // Invokes M<T>(T, int)\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Examples\nDESCRIPTION: Examples demonstrating pattern matching syntax with generic types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-7.0/pattern-matching.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar x = e is T < A > B;\nvar x = e is A<B> && f;\nvar x = e is A<B> || f;\nvar x = e is A<B> & f;\nvar x = e is A<B>[];\n```\n\n----------------------------------------\n\nTITLE: Mapping Control Flow Statements in Razor\nDESCRIPTION: Shows line mapping for control flow statements like for loops and if-else blocks in Razor\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/enhanced-line-directives.md#2025-04-21_snippet_5\n\nLANGUAGE: Razor\nCODE:\n```\n@for (var i = 0; i < 10; i++)\n{\n}\n@if (condition)\n{\n}\nelse\n{\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\n#line lineof('for') \"a.razor\"\n for (var i = 0; i < 10; i++)\n{\n}\n#line lineof('if') \"a.razor\"\n if (condition)\n{\n}\nelse\n{\n}\n#line hidden\n```\n\n----------------------------------------\n\nTITLE: Person Record Class Version Compatibility Example\nDESCRIPTION: Demonstration of backward compatibility when adding new properties to record types across versions.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/records.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// v1\npublic class Person(string Name, DateTime DateOfBirth);\n```\n\nLANGUAGE: csharp\nCODE:\n```\n// v2\npublic class Person(string Name, DateTime DateOfBirth, string HomeTown)\n{\n    // Note: below operations added to retain binary compatibility with v1\n    public Person(string Name, DateTime DateOfBirth) : this(Name, DateOfBirth, string.Empty) {}\n    public static void operator is(Person self, out string Name, out DateTime DateOfBirth)\n        { Name = self.Name; DateOfBirth = self.DateOfBirth; }\n    public Person With(string Name, DateTime DateOfBirth) => new Person(Name, DateOfBirth);\n}\n```\n\n----------------------------------------\n\nTITLE: Inheritance Example with Primary Constructors\nDESCRIPTION: Shows an example of inheritance between classes with primary constructors that requires explicit parameter passing.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/recordsv2.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\ndata class A(int X, int Y);\ndata class B(int X, int Y, int Z) : A(X, Y);\n```\n\n----------------------------------------\n\nTITLE: Subtraction Operators for IntPtr and UIntPtr\nDESCRIPTION: Defines subtraction operators for System.IntPtr and System.UIntPtr types with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator -(int, System.IntPtr)\nSystem.IntPtr operator -(System.IntPtr, int)\nSystem.IntPtr operator -(System.IntPtr, System.IntPtr)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator -(uint, System.UIntPtr)\nSystem.UIntPtr operator -(System.UIntPtr, uint)\nSystem.UIntPtr operator -(System.UIntPtr, System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Division Operators for IntPtr and UIntPtr\nDESCRIPTION: Defines division operators for System.IntPtr and System.UIntPtr types with various integer combinations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator /(int, System.IntPtr)\nSystem.IntPtr operator /(System.IntPtr, int)\nSystem.IntPtr operator /(System.IntPtr, System.IntPtr)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator /(uint, System.UIntPtr)\nSystem.UIntPtr operator /(System.UIntPtr, uint)\nSystem.UIntPtr operator /(System.UIntPtr, System.UIntPtr)\n```\n\n----------------------------------------\n\nTITLE: Set-only Property with Event in C#\nDESCRIPTION: Set-only property implementation with change tracking and event raising\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    set\n    {\n        if (field == value) return;\n        field = value;\n        OnXyzChanged(new XyzEventArgs(value));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Constant String to UTF8 Conversion in C#\nDESCRIPTION: Example of converting constant string values to UTF8 byte sequences using ReadOnlySpan<byte>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_11\n\nLANGUAGE: c#\nCODE:\n```\nconst string data = \"dog\"\nReadOnlySpan<byte> span = data;     // new byte[] { 0x64, 0x6f, 0x67 }\n```\n\n----------------------------------------\n\nTITLE: C# Compiler Error Reference\nDESCRIPTION: Reference to a C# compiler error code discussed in context of struct initialization behavior\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-02-14.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nCS8882\n```\n\n----------------------------------------\n\nTITLE: Role on a Role Declaration and Emit Strategy in C#\nDESCRIPTION: This snippet illustrates a role inheriting from another role and its proposed emit strategy. It demonstrates how the relationship between roles might be encoded using a `Role` attribute. The necessity of the attribute is an open question.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2022-11-10.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nrole MyRole2<T> : MyRole<T> where T : Constraint \n{\n  ...\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\n// Need to encode relationship to MyRole<T>. Maybe the @this field is sufficient.\nref struct MyRole2<T> where T : Constraint\n{\n    [Role(typeof(MyRole))] ref UnderlyingType @this;\n    // ... members ...\n}\n```\n\n----------------------------------------\n\nTITLE: Semicolon Expression Example\nDESCRIPTION: Proposed but not implemented syntax for let-like declarations using semicolon operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2014/LDM-2014-09-03.md#2025-04-21_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\nConsole.WriteLine(\"Result: {0}\", (var x = GetValue(); x * x));\n```\n\n----------------------------------------\n\nTITLE: Ref Assignment in Method Parameters\nDESCRIPTION: Example showing potential ambiguity when using ref assignment expressions as method parameters, highlighting the need for clear syntax rules.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2017/LDM-2017-10-02.md#2025-04-21_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nM(out r = ref v); //What?\n```\n\n----------------------------------------\n\nTITLE: ReadOnlyMemory Conversion Example with UTF-8 Literals\nDESCRIPTION: Example demonstrating conversion behavior between string literals and ReadOnlyMemory<byte>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/utf8-string-literals.md#2025-04-21_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic readonly ReadOnlyMemory<byte> s_data1 = \"Data\"u8;\nstatic readonly ReadOnlyMemory<byte> s_data2 = \"Data\";\n```\n\n----------------------------------------\n\nTITLE: Shift Operators for IntPtr and UIntPtr\nDESCRIPTION: Defines left and right shift operators for System.IntPtr and System.UIntPtr types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/intptr-operators.md#2025-04-21_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.IntPtr operator <<(System.IntPtr, int)\nSystem.IntPtr operator >>(System.IntPtr, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.UIntPtr operator <<(System.UIntPtr, int)\nSystem.UIntPtr operator >>(System.UIntPtr, int)\n```\n\n----------------------------------------\n\nTITLE: Operator Reference\nDESCRIPTION: Reference to the plus operator in discussion about generic numeric constraints.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-03-18.md#2025-04-21_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n+\n```\n\n----------------------------------------\n\nTITLE: Tracking Nullability through Conditional Ref with Non-null Initial Values in C#\nDESCRIPTION: Example showing how nullability is tracked when non-null strings are conditionally assigned null values through ref variables.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2019/LDM-2019-02-13.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstring? x = null;\nstring? y = null;\n(b ? ref x : ref y) = \"\";\n```\n\n----------------------------------------\n\nTITLE: Handling of Obsolete Required Members\nDESCRIPTION: Implementation decision to issue warnings for Obsolete required members, with suppression for Obsolete constructors and types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-23.md#2025-04-21_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Extension Members ANTLR Grammar Definition\nDESCRIPTION: ANTLR grammar rules defining the syntax for extension member declarations including class body, member declarations, and extension-specific components\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/extensions.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nclass_body\n    : '{' class_member_declaration* '}' ';'?\n    | ';'\n    ;\n\nclass_member_declaration\n    : constant_declaration\n    | field_declaration\n    | method_declaration\n    | property_declaration\n    | event_declaration\n    | indexer_declaration\n    | operator_declaration\n    | constructor_declaration\n    | finalizer_declaration\n    | static_constructor_declaration\n    | type_declaration\n    | extension_declaration\n    ;\n\nextension_declaration\n    : 'extension' type_parameter_list? '(' receiver_parameter ')' type_parameter_constraints_clause* extension_body\n    ;\n\nextension_body\n    : '{' extension_member_declaration* '}' ';'?\n    ;\n\nextension_member_declaration\n    : method_declaration\n    | property_declaration\n    | indexer_declaration\n    | operator_declaration\n    ;\n\nreceiver_parameter\n    : attributes? parameter_modifiers? type identifier?\n    ;\n```\n\n----------------------------------------\n\nTITLE: Generic Type Inference with Nullable Types in C#\nDESCRIPTION: Shows how type inference behaves with generic interpolated string handlers, where flow analysis does not consider constructor parameter annotations.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/improved-interpolated-strings.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nstring? s = null;\nM(s, $\"\"); // Infers `string` for `T` because of the `T?` parameter, not `string?`, as flow analysis does not consider the unannotated `T` parameter of the constructor\n\nvoid M<T>(T? t, [InterpolatedStringHandlerArgument(\"s1\")] CustomHandler<T> c) { }\n\n[InterpolatedStringHandler]\npublic partial struct CustomHandler<T>\n{\n    public CustomHandler(int literalLength, int formattedCount, T t) : this()\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Member Shadowing in Roles and Extensions\nDESCRIPTION: Illustrates method shadowing behavior in roles and extensions, showing member resolution rules\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/roles/roles-2023-01-25.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass U { public void M() { } }\nrole R : U { /*new*/ public void M() { } }\n```\n\nLANGUAGE: csharp\nCODE:\n```\nclass U { public void M() { } }\nextension X : U { /*new*/ public void M() { } }\n```\n\nLANGUAGE: csharp\nCODE:\n```\nclass U { }\nrole R : U { public void M() { } }\nrole R2 : U, R { /*new*/ public void M() { } }\n```\n\n----------------------------------------\n\nTITLE: Async Foreach Loop Syntax Options in C#\nDESCRIPTION: Demonstrates different potential syntax options for handling async streams in foreach loops, showing various ways to express the async nature of the iteration.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2015/LDM-2015-09-08.md#2025-04-21_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\nforeach (string s in asyncStream) { ... } // or\nforeach async (string s in asyncStream) { ... } // or\nforeach (await string s in asyncStream) { ... } // etc.\n```\n\n----------------------------------------\n\nTITLE: Natural Type Inference with Null Values in Dictionary-Like Collections in C#\nDESCRIPTION: This example shows how natural type inference handles null values in the new dictionary-like syntax.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/collection-expressions-next.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar d = [null: null, \"a\": \"b\"];\n```\n\n----------------------------------------\n\nTITLE: Examining 'field' Keyword in Event Accessors in C#\nDESCRIPTION: Example showing the potential use of 'field' as a keyword in event accessors to automatically generate a backing field, which was decided against.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/field-keyword.md#2025-04-21_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nclass MyClass\n{\n    public event EventHandler E\n    {\n        add { field += value; }\n        remove { field -= value; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Interpolated String Handler Assignment - C#\nDESCRIPTION: Example showing the assignment of parenthesized interpolated string expressions to a custom handler type, demonstrating the scenario where parentheses transparency is important.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-25.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nCustomHandler c = ($\"\" + $\"\");\n```\n\n----------------------------------------\n\nTITLE: Equivalent Method Reference for Web Application Endpoints\nDESCRIPTION: Shows the equivalent of using a method reference instead of a lambda for handling a web API endpoint. This demonstrates the consistency between lambdas and methods with optional parameters.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/lambda-method-group-defaults.md#2025-04-21_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar app = WebApplication.Create(args);\n\nResult TodoHandler(TodoService todoService, int id, string task = \"foo\") {\n  var todo = todoService.Create(id, task);\n  return Results.Created(todo);\n}\n\napp.MapPost(\"/todos/{id}\", TodoHandler);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating double.NaN Warning Example\nDESCRIPTION: Code comparison example that would trigger warning CA2242 for invalid comparisons to double.NaN. This is discussed in the context of potentially moving this warning into the compiler.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2020/LDM-2020-09-28.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ndouble.NaN\n```\n\n----------------------------------------\n\nTITLE: GetValues method for positional deconstruction\nDESCRIPTION: Illustrates a potential GetValues method to support custom positional deconstruction behavior.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2016/LDM-2016-02-29.md#2025-04-21_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic abstract class Person\n{\n  ...\n  public void Person GetValues(out string firstName, out string lastName);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Roles and Extensions Usage in C#\nDESCRIPTION: Provides examples of how roles and extensions would be declared and used under the proposed renaming scheme. Includes examples for roles intended to be used as types and extensions for adding members to existing types.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/rename-to-roles-and-extensions.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// Roles intended to be used directly as types\npublic role Order for JsonElement\n{\n    public string Description => GetProperty(\"description\").GetString()!;\n}\n\npublic role Customer for JsonElement\n{\n    public string Name => GetProperty(\"name\").GetString()!;\n    public IEnumerable<Order> Orders => GetProperty(\"orders\").EnumerateArray();\n}\n\n// Extensions intended to provide new function members to existing types\npublic extension JsonString for string\n{\n    private static readonly JsonSerializerOptions s_indentedOptions = new() { WriteIndented = true };\n\n    public JsonElement ParseAsJson() => JsonDocument.Parse(this).RootElement;\n\n    public static string CreateIndented(JsonElement element)\n        => element.ValueKind != JsonValueKind.Undefined\n            ? JsonSerializer.Serialize(element, s_indentedOptions)\n            : string.Empty;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Fixed-Size Buffers in C#\nDESCRIPTION: This snippet shows how fixed-size buffers are accessed in C# code and the equivalent generated code using Span<T> and ReadOnlySpan<T>.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-12.0/inline-arrays.md#2025-04-21_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\npublic partial class C\n{\n    void M1(int val)\n    {\n        buffer1[1] = val;\n    }\n\n    int M2()\n    {\n        return buffer2[1];\n    }\n}\n```\n\nLANGUAGE: C#\nCODE:\n```\npublic partial class C\n{\n    void M1(int val)\n    {\n        buffer.AsSpan()[1] = val;\n    }\n\n    int M2()\n    {\n        return buffer2.AsReadOnlySpan()[1];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Scope Ambiguity in Span Allocation in C#\nDESCRIPTION: This snippet illustrates a scenario where it is unclear whether a collection expression should have local or global scope. Depending on this scope, stack allocation might be incorrect leading to an error when attempting to return the span.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-08-14.md#2025-04-21_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nstatic ReadOnlySpan<T> AsSpan2<T>(T x, T y)\n{\n    Span<int> s = [x, y]; // local scope or global?\n    return s;             // error if local scope\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Extension Type Usage Examples in C#\nDESCRIPTION: Demonstrates illegal uses of extensions as types, highlighting that extensions themselves are not types and cannot be used in type contexts.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/extensions/extensions_v2.md#2025-04-21_snippet_7\n\nLANGUAGE: c#\nCODE:\n```\nExtension e1;                   // Not legal.  Extension is not a type.\nExtension[] e2;                // Not legal.  Extension is not a type.\nList<Extension> e3;             // Not legal.  Extension is not a type.\nvar v1 = (Extension)receiver;   // Not legal.  Can't can't have a value of extension type.\n```\n\n----------------------------------------\n\nTITLE: Array Slicing Syntax in C#\nDESCRIPTION: Example showing the current array slicing syntax using range operator.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-03-09.md#2025-04-21_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar x = array[1..3];\n```\n\n----------------------------------------\n\nTITLE: Simple Top-level Example with Return in C#\nDESCRIPTION: Shows a basic top-level program with integer return value.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/top-level-statements.md#2025-04-21_snippet_8\n\nLANGUAGE: c#\nCODE:\n```\nSystem.Console.WriteLine(\"Hi!\");\nreturn 2;\n```\n\n----------------------------------------\n\nTITLE: Dictionary Spreading with Collection Literals in C#\nDESCRIPTION: This snippet illustrates how the spread operator can be used with collection literals to create a new dictionary by combining an existing dictionary with new key-value pairs. The spread operator simplifies the process of merging dictionaries.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/meetings/working-groups/collection-literals/CL-LDM-2023-05-31.md#2025-04-21_snippet_14\n\nLANGUAGE: c#\nCODE:\n```\nDictionary<string, int> nameToAge = [\"Dustin\": 42, \"Cyrus\": 43];\nDictionary<string, int> newNameToAge = [.. nameToAge, \"Mads\": 25];\n```\n\n----------------------------------------\n\nTITLE: Constructor Null Checking Implementation in C#\nDESCRIPTION: Demonstrates how null checking works in constructors with field initializers and constructor chaining.\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/rejected/param-nullchecking.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass C {\n    string field = GetString();\n    C(string name!!): this(name) {\n        ...\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nclass C {\n    C(string name)\n        if (name is null) {\n            throw new ArgumentNullException(nameof(name));\n        }\n        field = GetString();\n        :this(name);\n        ...\n}\n```\n\n----------------------------------------\n\nTITLE: Current Line Indicator Syntax in C#\nDESCRIPTION: Original syntax for #line directive with limited mapping capabilities, supporting only line number and file path\nSOURCE: https://github.com/dotnet/csharplang/blob/main/proposals/csharp-10.0/enhanced-line-directives.md#2025-04-21_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nline_indicator\n    : decimal_digit+ whitespace file_name\n    | decimal_digit+\n    | 'default'\n    | 'hidden'\n    ;\n```"
  }
]